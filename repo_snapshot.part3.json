{"generated_at":"2025-08-17T20:04:18.057896Z","root":"/home/runner/workspace","git":{"head":"7b7135163eb4227ef98e4c2d7b4ab78ea306bd73","branch":"main","status":" M corrections.db\n?? app_changes.json\n?? export_changes.py\n"},"filters":{"git_range":null,"since":null,"include_ext":[".cfg",".css",".env",".htm",".html",".ini",".jinja",".jinja2",".js",".json",".md",".py",".toml",".ts",".yaml",".yml"],"exclude_dirs":[".git",".ipynb_checkpoints",".mypy_cache",".pytest_cache",".pythonlibs",".venv","__pycache__","cache","chroma_db","data/exports","node_modules","venv"],"exclude_globs":["*.bmp","*.db","*.feather","*.gif","*.gz","*.ico","*.jpeg","*.jpg","*.jsonl","*.lock","*.log","*.parquet","*.png","*.sqlite","*.sqlite3","*.tar","*.webp","*.zip"],"max_file_bytes":400000},"summary":{"file_count":876,"total_bytes":9265289},"files":[{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/idna/idnadata.py","size":78306,"sha1":"4c9e8b910da0ddd4975f1c5d188ea2cc56a0fb9f","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is automatically generated by tools/idna-data\n\n__version__ = \"15.1.0\"\nscripts = {\n    \"Greek\": (\n        0x37000000374,\n        0x37500000378,\n        0x37A0000037E,\n        0x37F00000380,\n        0x38400000385,\n        0x38600000387,\n        0x3880000038B,\n        0x38C0000038D,\n        0x38E000003A2,\n        0x3A3000003E2,\n        0x3F000000400,\n        0x1D2600001D2B,\n        0x1D5D00001D62,\n        0x1D6600001D6B,\n        0x1DBF00001DC0,\n        0x1F0000001F16,\n        0x1F1800001F1E,\n        0x1F2000001F46,\n        0x1F4800001F4E,\n        0x1F5000001F58,\n        0x1F5900001F5A,\n        0x1F5B00001F5C,\n        0x1F5D00001F5E,\n        0x1F5F00001F7E,\n        0x1F8000001FB5,\n        0x1FB600001FC5,\n        0x1FC600001FD4,\n        0x1FD600001FDC,\n        0x1FDD00001FF0,\n        0x1FF200001FF5,\n        0x1FF600001FFF,\n        0x212600002127,\n        0xAB650000AB66,\n        0x101400001018F,\n        0x101A0000101A1,\n        0x1D2000001D246,\n    ),\n    \"Han\": (\n        0x2E8000002E9A,\n        0x2E9B00002EF4,\n        0x2F0000002FD6,\n        0x300500003006,\n        0x300700003008,\n        0x30210000302A,\n        0x30380000303C,\n        0x340000004DC0,\n        0x4E000000A000,\n        0xF9000000FA6E,\n        0xFA700000FADA,\n        0x16FE200016FE4,\n        0x16FF000016FF2,\n        0x200000002A6E0,\n        0x2A7000002B73A,\n        0x2B7400002B81E,\n        0x2B8200002CEA2,\n        0x2CEB00002EBE1,\n        0x2EBF00002EE5E,\n        0x2F8000002FA1E,\n        0x300000003134B,\n        0x31350000323B0,\n    ),\n    \"Hebrew\": (\n        0x591000005C8,\n        0x5D0000005EB,\n        0x5EF000005F5,\n        0xFB1D0000FB37,\n        0xFB380000FB3D,\n        0xFB3E0000FB3F,\n        0xFB400000FB42,\n        0xFB430000FB45,\n        0xFB460000FB50,\n    ),\n    \"Hiragana\": (\n        0x304100003097,\n        0x309D000030A0,\n        0x1B0010001B120,\n        0x1B1320001B133,\n        0x1B1500001B153,\n        0x1F2000001F201,\n    ),\n    \"Katakana\": (\n        0x30A1000030FB,\n        0x30FD00003100,\n        0x31F000003200,\n        0x32D0000032FF,\n        0x330000003358,\n        0xFF660000FF70,\n        0xFF710000FF9E,\n        0x1AFF00001AFF4,\n        0x1AFF50001AFFC,\n        0x1AFFD0001AFFF,\n        0x1B0000001B001,\n        0x1B1200001B123,\n        0x1B1550001B156,\n        0x1B1640001B168,\n    ),\n}\njoining_types = {\n    0xAD: 84,\n    0x300: 84,\n    0x301: 84,\n    0x302: 84,\n    0x303: 84,\n    0x304: 84,\n    0x305: 84,\n    0x306: 84,\n    0x307: 84,\n    0x308: 84,\n    0x309: 84,\n    0x30A: 84,\n    0x30B: 84,\n    0x30C: 84,\n    0x30D: 84,\n    0x30E: 84,\n    0x30F: 84,\n    0x310: 84,\n    0x311: 84,\n    0x312: 84,\n    0x313: 84,\n    0x314: 84,\n    0x315: 84,\n    0x316: 84,\n    0x317: 84,\n    0x318: 84,\n    0x319: 84,\n    0x31A: 84,\n    0x31B: 84,\n    0x31C: 84,\n    0x31D: 84,\n    0x31E: 84,\n    0x31F: 84,\n    0x320: 84,\n    0x321: 84,\n    0x322: 84,\n    0x323: 84,\n    0x324: 84,\n    0x325: 84,\n    0x326: 84,\n    0x327: 84,\n    0x328: 84,\n    0x329: 84,\n    0x32A: 84,\n    0x32B: 84,\n    0x32C: 84,\n    0x32D: 84,\n    0x32E: 84,\n    0x32F: 84,\n    0x330: 84,\n    0x331: 84,\n    0x332: 84,\n    0x333: 84,\n    0x334: 84,\n    0x335: 84,\n    0x336: 84,\n    0x337: 84,\n    0x338: 84,\n    0x339: 84,\n    0x33A: 84,\n    0x33B: 84,\n    0x33C: 84,\n    0x33D: 84,\n    0x33E: 84,\n    0x33F: 84,\n    0x340: 84,\n    0x341: 84,\n    0x342: 84,\n    0x343: 84,\n    0x344: 84,\n    0x345: 84,\n    0x346: 84,\n    0x347: 84,\n    0x348: 84,\n    0x349: 84,\n    0x34A: 84,\n    0x34B: 84,\n    0x34C: 84,\n    0x34D: 84,\n    0x34E: 84,\n    0x34F: 84,\n    0x350: 84,\n    0x351: 84,\n    0x352: 84,\n    0x353: 84,\n    0x354: 84,\n    0x355: 84,\n    0x356: 84,\n    0x357: 84,\n    0x358: 84,\n    0x359: 84,\n    0x35A: 84,\n    0x35B: 84,\n    0x35C: 84,\n    0x35D: 84,\n    0x35E: 84,\n    0x35F: 84,\n    0x360: 84,\n    0x361: 84,\n    0x362: 84,\n    0x363: 84,\n    0x364: 84,\n    0x365: 84,\n    0x366: 84,\n    0x367: 84,\n    0x368: 84,\n    0x369: 84,\n    0x36A: 84,\n    0x36B: 84,\n    0x36C: 84,\n    0x36D: 84,\n    0x36E: 84,\n    0x36F: 84,\n    0x483: 84,\n    0x484: 84,\n    0x485: 84,\n    0x486: 84,\n    0x487: 84,\n    0x488: 84,\n    0x489: 84,\n    0x591: 84,\n    0x592: 84,\n    0x593: 84,\n    0x594: 84,\n    0x595: 84,\n    0x596: 84,\n    0x597: 84,\n    0x598: 84,\n    0x599: 84,\n    0x59A: 84,\n    0x59B: 84,\n    0x59C: 84,\n    0x59D: 84,\n    0x59E: 84,\n    0x59F: 84,\n    0x5A0: 84,\n    0x5A1: 84,\n    0x5A2: 84,\n    0x5A3: 84,\n    0x5A4: 84,\n    0x5A5: 84,\n    0x5A6: 84,\n    0x5A7: 84,\n    0x5A8: 84,\n    0x5A9: 84,\n    0x5AA: 84,\n    0x5AB: 84,\n    0x5AC: 84,\n    0x5AD: 84,\n    0x5AE: 84,\n    0x5AF: 84,\n    0x5B0: 84,\n    0x5B1: 84,\n    0x5B2: 84,\n    0x5B3: 84,\n    0x5B4: 84,\n    0x5B5: 84,\n    0x5B6: 84,\n    0x5B7: 84,\n    0x5B8: 84,\n    0x5B9: 84,\n    0x5BA: 84,\n    0x5BB: 84,\n    0x5BC: 84,\n    0x5BD: 84,\n    0x5BF: 84,\n    0x5C1: 84,\n    0x5C2: 84,\n    0x5C4: 84,\n    0x5C5: 84,\n    0x5C7: 84,\n    0x610: 84,\n    0x611: 84,\n    0x612: 84,\n    0x613: 84,\n    0x614: 84,\n    0x615: 84,\n    0x616: 84,\n    0x617: 84,\n    0x618: 84,\n    0x619: 84,\n    0x61A: 84,\n    0x61C: 84,\n    0x620: 68,\n    0x622: 82,\n    0x623: 82,\n    0x624: 82,\n    0x625: 82,\n    0x626: 68,\n    0x627: 82,\n    0x628: 68,\n    0x629: 82,\n    0x62A: 68,\n    0x62B: 68,\n    0x62C: 68,\n    0x62D: 68,\n    0x62E: 68,\n    0x62F: 82,\n    0x630: 82,\n    0x631: 82,\n    0x632: 82,\n    0x633: 68,\n    0x634: 68,\n    0x635: 68,\n    0x636: 68,\n    0x637: 68,\n    0x638: 68,\n    0x639: 68,\n    0x63A: 68,\n    0x63B: 68,\n    0x63C: 68,\n    0x63D: 68,\n    0x63E: 68,\n    0x63F: 68,\n    0x640: 67,\n    0x641: 68,\n    0x642: 68,\n    0x643: 68,\n    0x644: 68,\n    0x645: 68,\n    0x646: 68,\n    0x647: 68,\n    0x648: 82,\n    0x649: 68,\n    0x64A: 68,\n    0x64B: 84,\n    0x64C: 84,\n    0x64D: 84,\n    0x64E: 84,\n    0x64F: 84,\n    0x650: 84,\n    0x651: 84,\n    0x652: 84,\n    0x653: 84,\n    0x654: 84,\n    0x655: 84,\n    0x656: 84,\n    0x657: 84,\n    0x658: 84,\n    0x659: 84,\n    0x65A: 84,\n    0x65B: 84,\n    0x65C: 84,\n    0x65D: 84,\n    0x65E: 84,\n    0x65F: 84,\n    0x66E: 68,\n    0x66F: 68,\n    0x670: 84,\n    0x671: 82,\n    0x672: 82,\n    0x673: 82,\n    0x675: 82,\n    0x676: 82,\n    0x677: 82,\n    0x678: 68,\n    0x679: 68,\n    0x67A: 68,\n    0x67B: 68,\n    0x67C: 68,\n    0x67D: 68,\n    0x67E: 68,\n    0x67F: 68,\n    0x680: 68,\n    0x681: 68,\n    0x682: 68,\n    0x683: 68,\n    0x684: 68,\n    0x685: 68,\n    0x686: 68,\n    0x687: 68,\n    0x688: 82,\n    0x689: 82,\n    0x68A: 82,\n    0x68B: 82,\n    0x68C: 82,\n    0x68D: 82,\n    0x68E: 82,\n    0x68F: 82,\n    0x690: 82,\n    0x691: 82,\n    0x692: 82,\n    0x693: 82,\n    0x694: 82,\n    0x695: 82,\n    0x696: 82,\n    0x697: 82,\n    0x698: 82,\n    0x699: 82,\n    0x69A: 68,\n    0x69B: 68,\n    0x69C: 68,\n    0x69D: 68,\n    0x69E: 68,\n    0x69F: 68,\n    0x6A0: 68,\n    0x6A1: 68,\n    0x6A2: 68,\n    0x6A3: 68,\n    0x6A4: 68,\n    0x6A5: 68,\n    0x6A6: 68,\n    0x6A7: 68,\n    0x6A8: 68,\n    0x6A9: 68,\n    0x6AA: 68,\n    0x6AB: 68,\n    0x6AC: 68,\n    0x6AD: 68,\n    0x6AE: 68,\n    0x6AF: 68,\n    0x6B0: 68,\n    0x6B1: 68,\n    0x6B2: 68,\n    0x6B3: 68,\n    0x6B4: 68,\n    0x6B5: 68,\n    0x6B6: 68,\n    0x6B7: 68,\n    0x6B8: 68,\n    0x6B9: 68,\n    0x6BA: 68,\n    0x6BB: 68,\n    0x6BC: 68,\n    0x6BD: 68,\n    0x6BE: 68,\n    0x6BF: 68,\n    0x6C0: 82,\n    0x6C1: 68,\n    0x6C2: 68,\n    0x6C3: 82,\n    0x6C4: 82,\n    0x6C5: 82,\n    0x6C6: 82,\n    0x6C7: 82,\n    0x6C8: 82,\n    0x6C9: 82,\n    0x6CA: 82,\n    0x6CB: 82,\n    0x6CC: 68,\n    0x6CD: 82,\n    0x6CE: 68,\n    0x6CF: 82,\n    0x6D0: 68,\n    0x6D1: 68,\n    0x6D2: 82,\n    0x6D3: 82,\n    0x6D5: 82,\n    0x6D6: 84,\n    0x6D7: 84,\n    0x6D8: 84,\n    0x6D9: 84,\n    0x6DA: 84,\n    0x6DB: 84,\n    0x6DC: 84,\n    0x6DF: 84,\n    0x6E0: 84,\n    0x6E1: 84,\n    0x6E2: 84,\n    0x6E3: 84,\n    0x6E4: 84,\n    0x6E7: 84,\n    0x6E8: 84,\n    0x6EA: 84,\n    0x6EB: 84,\n    0x6EC: 84,\n    0x6ED: 84,\n    0x6EE: 82,\n    0x6EF: 82,\n    0x6FA: 68,\n    0x6FB: 68,\n    0x6FC: 68,\n    0x6FF: 68,\n    0x70F: 84,\n    0x710: 82,\n    0x711: 84,\n    0x712: 68,\n    0x713: 68,\n    0x714: 68,\n    0x715: 82,\n    0x716: 82,\n    0x717: 82,\n    0x718: 82,\n    0x719: 82,\n    0x71A: 68,\n    0x71B: 68,\n    0x71C: 68,\n    0x71D: 68,\n    0x71E: 82,\n    0x71F: 68,\n    0x720: 68,\n    0x721: 68,\n    0x722: 68,\n    0x723: 68,\n    0x724: 68,\n    0x725: 68,\n    0x726: 68,\n    0x727: 68,\n    0x728: 82,\n    0x729: 68,\n    0x72A: 82,\n    0x72B: 68,\n    0x72C: 82,\n    0x72D: 68,\n    0x72E: 68,\n    0x72F: 82,\n    0x730: 84,\n    0x731: 84,\n    0x732: 84,\n    0x733: 84,\n    0x734: 84,\n    0x735: 84,\n    0x736: 84,\n    0x737: 84,\n    0x738: 84,\n    0x739: 84,\n    0x73A: 84,\n    0x73B: 84,\n    0x73C: 84,\n    0x73D: 84,\n    0x73E: 84,\n    0x73F: 84,\n    0x740: 84,\n    0x741: 84,\n    0x742: 84,\n    0x743: 84,\n    0x744: 84,\n    0x745: 84,\n    0x746: 84,\n    0x747: 84,\n    0x748: 84,\n    0x749: 84,\n    0x74A: 84,\n    0x74D: 82,\n    0x74E: 68,\n    0x74F: 68,\n    0x750: 68,\n    0x751: 68,\n    0x752: 68,\n    0x753: 68,\n    0x754: 68,\n    0x755: 68,\n    0x756: 68,\n    0x757: 68,\n    0x758: 68,\n    0x759: 82,\n    0x75A: 82,\n    0x75B: 82,\n    0x75C: 68,\n    0x75D: 68,\n    0x75E: 68,\n    0x75F: 68,\n    0x760: 68,\n    0x761: 68,\n    0x762: 68,\n    0x763: 68,\n    0x764: 68,\n    0x765: 68,\n    0x766: 68,\n    0x767: 68,\n    0x768: 68,\n    0x769: 68,\n    0x76A: 68,\n    0x76B: 82,\n    0x76C: 82,\n    0x76D: 68,\n    0x76E: 68,\n    0x76F: 68,\n    0x770: 68,\n    0x771: 82,\n    0x772: 68,\n    0x773: 82,\n    0x774: 82,\n    0x775: 68,\n    0x776: 68,\n    0x777: 68,\n    0x778: 82,\n    0x779: 82,\n    0x77A: 68,\n    0x77B: 68,\n    0x77C: 68,\n    0x77D: 68,\n    0x77E: 68,\n    0x77F: 68,\n    0x7A6: 84,\n    0x7A7: 84,\n    0x7A8: 84,\n    0x7A9: 84,\n    0x7AA: 84,\n    0x7AB: 84,\n    0x7AC: 84,\n    0x7AD: 84,\n    0x7AE: 84,\n    0x7AF: 84,\n    0x7B0: 84,\n    0x7CA: 68,\n    0x7CB: 68,\n    0x7CC: 68,\n    0x7CD: 68,\n    0x7CE: 68,\n    0x7CF: 68,\n    0x7D0: 68,\n    0x7D1: 68,\n    0x7D2: 68,\n    0x7D3: 68,\n    0x7D4: 68,\n    0x7D5: 68,\n    0x7D6: 68,\n    0x7D7: 68,\n    0x7D8: 68,\n    0x7D9: 68,\n    0x7DA: 68,\n    0x7DB: 68,\n    0x7DC: 68,\n    0x7DD: 68,\n    0x7DE: 68,\n    0x7DF: 68,\n    0x7E0: 68,\n    0x7E1: 68,\n    0x7E2: 68,\n    0x7E3: 68,\n    0x7E4: 68,\n    0x7E5: 68,\n    0x7E6: 68,\n    0x7E7: 68,\n    0x7E8: 68,\n    0x7E9: 68,\n    0x7EA: 68,\n    0x7EB: 84,\n    0x7EC: 84,\n    0x7ED: 84,\n    0x7EE: 84,\n    0x7EF: 84,\n    0x7F0: 84,\n    0x7F1: 84,\n    0x7F2: 84,\n    0x7F3: 84,\n    0x7FA: 67,\n    0x7FD: 84,\n    0x816: 84,\n    0x817: 84,\n    0x818: 84,\n    0x819: 84,\n    0x81B: 84,\n    0x81C: 84,\n    0x81D: 84,\n    0x81E: 84,\n    0x81F: 84,\n    0x820: 84,\n    0x821: 84,\n    0x822: 84,\n    0x823: 84,\n    0x825: 84,\n    0x826: 84,\n    0x827: 84,\n    0x829: 84,\n    0x82A: 84,\n    0x82B: 84,\n    0x82C: 84,\n    0x82D: 84,\n    0x840: 82,\n    0x841: 68,\n    0x842: 68,\n    0x843: 68,\n    0x844: 68,\n    0x845: 68,\n    0x846: 82,\n    0x847: 82,\n    0x848: 68,\n    0x849: 82,\n    0x84A: 68,\n    0x84B: 68,\n    0x84C: 68,\n    0x84D: 68,\n    0x84E: 68,\n    0x84F: 68,\n    0x850: 68,\n    0x851: 68,\n    0x852: 68,\n    0x853: 68,\n    0x854: 82,\n    0x855: 68,\n    0x856: 82,\n    0x857: 82,\n    0x858: 82,\n    0x859: 84,\n    0x85A: 84,\n    0x85B: 84,\n    0x860: 68,\n    0x862: 68,\n    0x863: 68,\n    0x864: 68,\n    0x865: 68,\n    0x867: 82,\n    0x868: 68,\n    0x869: 82,\n    0x86A: 82,\n    0x870: 82,\n    0x871: 82,\n    0x872: 82,\n    0x873: 82,\n    0x874: 82,\n    0x875: 82,\n    0x876: 82,\n    0x877: 82,\n    0x878: 82,\n    0x879: 82,\n    0x87A: 82,\n    0x87B: 82,\n    0x87C: 82,\n    0x87D: 82,\n    0x87E: 82,\n    0x87F: 82,\n    0x880: 82,\n    0x881: 82,\n    0x882: 82,\n    0x883: 67,\n    0x884: 67,\n    0x885: 67,\n    0x886: 68,\n    0x889: 68,\n    0x88A: 68,\n    0x88B: 68,\n    0x88C: 68,\n    0x88D: 68,\n    0x88E: 82,\n    0x898: 84,\n    0x899: 84,\n    0x89A: 84,\n    0x89B: 84,\n    0x89C: 84,\n    0x89D: 84,\n    0x89E: 84,\n    0x89F: 84,\n    0x8A0: 68,\n    0x8A1: 68,\n    0x8A2: 68,\n    0x8A3: 68,\n    0x8A4: 68,\n    0x8A5: 68,\n    0x8A6: 68,\n    0x8A7: 68,\n    0x8A8: 68,\n    0x8A9: 68,\n    0x8AA: 82,\n    0x8AB: 82,\n    0x8AC: 82,\n    0x8AE: 82,\n    0x8AF: 68,\n    0x8B0: 68,\n    0x8B1: 82,\n    0x8B2: 82,\n    0x8B3: 68,\n    0x8B4: 68,\n    0x8B5: 68,\n    0x8B6: 68,\n    0x8B7: 68,\n    0x8B8: 68,\n    0x8B9: 82,\n    0x8BA: 68,\n    0x8BB: 68,\n    0x8BC: 68,\n    0x8BD: 68,\n    0x8BE: 68,\n    0x8BF: 68,\n    0x8C0: 68,\n    0x8C1: 68,\n    0x8C2: 68,\n    0x8C3: 68,\n    0x8C4: 68,\n    0x8C5: 68,\n    0x8C6: 68,\n    0x8C7: 68,\n    0x8C8: 68,\n    0x8CA: 84,\n    0x8CB: 84,\n    0x8CC: 84,\n    0x8CD: 84,\n    0x8CE: 84,\n    0x8CF: 84,\n    0x8D0: 84,\n    0x8D1: 84,\n    0x8D2: 84,\n    0x8D3: 84,\n    0x8D4: 84,\n    0x8D5: 84,\n    0x8D6: 84,\n    0x8D7: 84,\n    0x8D8: 84,\n    0x8D9: 84,\n    0x8DA: 84,\n    0x8DB: 84,\n    0x8DC: 84,\n    0x8DD: 84,\n    0x8DE: 84,\n    0x8DF: 84,\n    0x8E0: 84,\n    0x8E1: 84,\n    0x8E3: 84,\n    0x8E4: 84,\n    0x8E5: 84,\n    0x8E6: 84,\n    0x8E7: 84,\n    0x8E8: 84,\n    0x8E9: 84,\n    0x8EA: 84,\n    0x8EB: 84,\n    0x8EC: 84,\n    0x8ED: 84,\n    0x8EE: 84,\n    0x8EF: 84,\n    0x8F0: 84,\n    0x8F1: 84,\n    0x8F2: 84,\n    0x8F3: 84,\n    0x8F4: 84,\n    0x8F5: 84,\n    0x8F6: 84,\n    0x8F7: 84,\n    0x8F8: 84,\n    0x8F9: 84,\n    0x8FA: 84,\n    0x8FB: 84,\n    0x8FC: 84,\n    0x8FD: 84,\n    0x8FE: 84,\n    0x8FF: 84,\n    0x900: 84,\n    0x901: 84,\n    0x902: 84,\n    0x93A: 84,\n    0x93C: 84,\n    0x941: 84,\n    0x942: 84,\n    0x943: 84,\n    0x944: 84,\n    0x945: 84,\n    0x946: 84,\n    0x947: 84,\n    0x948: 84,\n    0x94D: 84,\n    0x951: 84,\n    0x952: 84,\n    0x953: 84,\n    0x954: 84,\n    0x955: 84,\n    0x956: 84,\n    0x957: 84,\n    0x962: 84,\n    0x963: 84,\n    0x981: 84,\n    0x9BC: 84,\n    0x9C1: 84,\n    0x9C2: 84,\n    0x9C3: 84,\n    0x9C4: 84,\n    0x9CD: 84,\n    0x9E2: 84,\n    0x9E3: 84,\n    0x9FE: 84,\n    0xA01: 84,\n    0xA02: 84,\n    0xA3C: 84,\n    0xA41: 84,\n    0xA42: 84,\n    0xA47: 84,\n    0xA48: 84,\n    0xA4B: 84,\n    0xA4C: 84,\n    0xA4D: 84,\n    0xA51: 84,\n    0xA70: 84,\n    0xA71: 84,\n    0xA75: 84,\n    0xA81: 84,\n    0xA82: 84,\n    0xABC: 84,\n    0xAC1: 84,\n    0xAC2: 84,\n    0xAC3: 84,\n    0xAC4: 84,\n    0xAC5: 84,\n    0xAC7: 84,\n    0xAC8: 84,\n    0xACD: 84,\n    0xAE2: 84,\n    0xAE3: 84,\n    0xAFA: 84,\n    0xAFB: 84,\n    0xAFC: 84,\n    0xAFD: 84,\n    0xAFE: 84,\n    0xAFF: 84,\n    0xB01: 84,\n    0xB3C: 84,\n    0xB3F: 84,\n    0xB41: 84,\n    0xB42: 84,\n    0xB43: 84,\n    0xB44: 84,\n    0xB4D: 84,\n    0xB55: 84,\n    0xB56: 84,\n    0xB62: 84,\n    0xB63: 84,\n    0xB82: 84,\n    0xBC0: 84,\n    0xBCD: 84,\n    0xC00: 84,\n    0xC04: 84,\n    0xC3C: 84,\n    0xC3E: 84,\n    0xC3F: 84,\n    0xC40: 84,\n    0xC46: 84,\n    0xC47: 84,\n    0xC48: 84,\n    0xC4A: 84,\n    0xC4B: 84,\n    0xC4C: 84,\n    0xC4D: 84,\n    0xC55: 84,\n    0xC56: 84,\n    0xC62: 84,\n    0xC63: 84,\n    0xC81: 84,\n    0xCBC: 84,\n    0xCBF: 84,\n    0xCC6: 84,\n    0xCCC: 84,\n    0xCCD: 84,\n    0xCE2: 84,\n    0xCE3: 84,\n    0xD00: 84,\n    0xD01: 84,\n    0xD3B: 84,\n    0xD3C: 84,\n    0xD41: 84,\n    0xD42: 84,\n    0xD43: 84,\n    0xD44: 84,\n    0xD4D: 84,\n    0xD62: 84,\n    0xD63: 84,\n    0xD81: 84,\n    0xDCA: 84,\n    0xDD2: 84,\n    0xDD3: 84,\n    0xDD4: 84,\n    0xDD6: 84,\n    0xE31: 84,\n    0xE34: 84,\n    0xE35: 84,\n    0xE36: 84,\n    0xE37: 84,\n    0xE38: 84,\n    0xE39: 84,\n    0xE3A: 84,\n    0xE47: 84,\n    0xE48: 84,\n    0xE49: 84,\n    0xE4A: 84,\n    0xE4B: 84,\n    0xE4C: 84,\n    0xE4D: 84,\n    0xE4E: 84,\n    0xEB1: 84,\n    0xEB4: 84,\n    0xEB5: 84,\n    0xEB6: 84,\n    0xEB7: 84,\n    0xEB8: 84,\n    0xEB9: 84,\n    0xEBA: 84,\n    0xEBB: 84,\n    0xEBC: 84,\n    0xEC8: 84,\n    0xEC9: 84,\n    0xECA: 84,\n    0xECB: 84,\n    0xECC: 84,\n    0xECD: 84,\n    0xECE: 84,\n    0xF18: 84,\n    0xF19: 84,\n    0xF35: 84,\n    0xF37: 84,\n    0xF39: 84,\n    0xF71: 84,\n    0xF72: 84,\n    0xF73: 84,\n    0xF74: 84,\n    0xF75: 84,\n    0xF76: 84,\n    0xF77: 84,\n    0xF78: 84,\n    0xF79: 84,\n    0xF7A: 84,\n    0xF7B: 84,\n    0xF7C: 84,\n    0xF7D: 84,\n    0xF7E: 84,\n    0xF80: 84,\n    0xF81: 84,\n    0xF82: 84,\n    0xF83: 84,\n    0xF84: 84,\n    0xF86: 84,\n    0xF87: 84,\n    0xF8D: 84,\n    0xF8E: 84,\n    0xF8F: 84,\n    0xF90: 84,\n    0xF91: 84,\n    0xF92: 84,\n    0xF93: 84,\n    0xF94: 84,\n    0xF95: 84,\n    0xF96: 84,\n    0xF97: 84,\n    0xF99: 84,\n    0xF9A: 84,\n    0xF9B: 84,\n    0xF9C: 84,\n    0xF9D: 84,\n    0xF9E: 84,\n    0xF9F: 84,\n    0xFA0: 84,\n    0xFA1: 84,\n    0xFA2: 84,\n    0xFA3: 84,\n    0xFA4: 84,\n    0xFA5: 84,\n    0xFA6: 84,\n    0xFA7: 84,\n    0xFA8: 84,\n    0xFA9: 84,\n    0xFAA: 84,\n    0xFAB: 84,\n    0xFAC: 84,\n    0xFAD: 84,\n    0xFAE: 84,\n    0xFAF: 84,\n    0xFB0: 84,\n    0xFB1: 84,\n    0xFB2: 84,\n    0xFB3: 84,\n    0xFB4: 84,\n    0xFB5: 84,\n    0xFB6: 84,\n    0xFB7: 84,\n    0xFB8: 84,\n    0xFB9: 84,\n    0xFBA: 84,\n    0xFBB: 84,\n    0xFBC: 84,\n    0xFC6: 84,\n    0x102D: 84,\n    0x102E: 84,\n    0x102F: 84,\n    0x1030: 84,\n    0x1032: 84,\n    0x1033: 84,\n    0x1034: 84,\n    0x1035: 84,\n    0x1036: 84,\n    0x1037: 84,\n    0x1039: 84,\n    0x103A: 84,\n    0x103D: 84,\n    0x103E: 84,\n    0x1058: 84,\n    0x1059: 84,\n    0x105E: 84,\n    0x105F: 84,\n    0x1060: 84,\n    0x1071: 84,\n    0x1072: 84,\n    0x1073: 84,\n    0x1074: 84,\n    0x1082: 84,\n    0x1085: 84,\n    0x1086: 84,\n    0x108D: 84,\n    0x109D: 84,\n    0x135D: 84,\n    0x135E: 84,\n    0x135F: 84,\n    0x1712: 84,\n    0x1713: 84,\n    0x1714: 84,\n    0x1732: 84,\n    0x1733: 84,\n    0x1752: 84,\n    0x1753: 84,\n    0x1772: 84,\n    0x1773: 84,\n    0x17B4: 84,\n    0x17B5: 84,\n    0x17B7: 84,\n    0x17B8: 84,\n    0x17B9: 84,\n    0x17BA: 84,\n    0x17BB: 84,\n    0x17BC: 84,\n    0x17BD: 84,\n    0x17C6: 84,\n    0x17C9: 84,\n    0x17CA: 84,\n    0x17CB: 84,\n    0x17CC: 84,\n    0x17CD: 84,\n    0x17CE: 84,\n    0x17CF: 84,\n    0x17D0: 84,\n    0x17D1: 84,\n    0x17D2: 84,\n    0x17D3: 84,\n    0x17DD: 84,\n    0x1807: 68,\n    0x180A: 67,\n    0x180B: 84,\n    0x180C: 84,\n    0x180D: 84,\n    0x180F: 84,\n    0x1820: 68,\n    0x1821: 68,\n    0x1822: 68,\n    0x1823: 68,\n    0x1824: 68,\n    0x1825: 68,\n    0x1826: 68,\n    0x1827: 68,\n    0x1828: 68,\n    0x1829: 68,\n    0x182A: 68,\n    0x182B: 68,\n    0x182C: 68,\n    0x182D: 68,\n    0x182E: 68,\n    0x182F: 68,\n    0x1830: 68,\n    0x1831: 68,\n    0x1832: 68,\n    0x1833: 68,\n    0x1834: 68,\n    0x1835: 68,\n    0x1836: 68,\n    0x1837: 68,\n    0x1838: 68,\n    0x1839: 68,\n    0x183A: 68,\n    0x183B: 68,\n    0x183C: 68,\n    0x183D: 68,\n    0x183E: 68,\n    0x183F: 68,\n    0x1840: 68,\n    0x1841: 68,\n    0x1842: 68,\n    0x1843: 68,\n    0x1844: 68,\n    0x1845: 68,\n    0x1846: 68,\n    0x1847: 68,\n    0x1848: 68,\n    0x1849: 68,\n    0x184A: 68,\n    0x184B: 68,\n    0x184C: 68,\n    0x184D: 68,\n    0x184E: 68,\n    0x184F: 68,\n    0x1850: 68,\n    0x1851: 68,\n    0x1852: 68,\n    0x1853: 68,\n    0x1854: 68,\n    0x1855: 68,\n    0x1856: 68,\n    0x1857: 68,\n    0x1858: 68,\n    0x1859: 68,\n    0x185A: 68,\n    0x185B: 68,\n    0x185C: 68,\n    0x185D: 68,\n    0x185E: 68,\n    0x185F: 68,\n    0x1860: 68,\n    0x1861: 68,\n    0x1862: 68,\n    0x1863: 68,\n    0x1864: 68,\n    0x1865: 68,\n    0x1866: 68,\n    0x1867: 68,\n    0x1868: 68,\n    0x1869: 68,\n    0x186A: 68,\n    0x186B: 68,\n    0x186C: 68,\n    0x186D: 68,\n    0x186E: 68,\n    0x186F: 68,\n    0x1870: 68,\n    0x1871: 68,\n    0x1872: 68,\n    0x1873: 68,\n    0x1874: 68,\n    0x1875: 68,\n    0x1876: 68,\n    0x1877: 68,\n    0x1878: 68,\n    0x1885: 84,\n    0x1886: 84,\n    0x1887: 68,\n    0x1888: 68,\n    0x1889: 68,\n    0x188A: 68,\n    0x188B: 68,\n    0x188C: 68,\n    0x188D: 68,\n    0x188E: 68,\n    0x188F: 68,\n    0x1890: 68,\n    0x1891: 68,\n    0x1892: 68,\n    0x1893: 68,\n    0x1894: 68,\n    0x1895: 68,\n    0x1896: 68,\n    0x1897: 68,\n    0x1898: 68,\n    0x1899: 68,\n    0x189A: 68,\n    0x189B: 68,\n    0x189C: 68,\n    0x189D: 68,\n    0x189E: 68,\n    0x189F: 68,\n    0x18A0: 68,\n    0x18A1: 68,\n    0x18A2: 68,\n    0x18A3: 68,\n    0x18A4: 68,\n    0x18A5: 68,\n    0x18A6: 68,\n    0x18A7: 68,\n    0x18A8: 68,\n    0x18A9: 84,\n    0x18AA: 68,\n    0x1920: 84,\n    0x1921: 84,\n    0x1922: 84,\n    0x1927: 84,\n    0x1928: 84,\n    0x1932: 84,\n    0x1939: 84,\n    0x193A: 84,\n    0x193B: 84,\n    0x1A17: 84,\n    0x1A18: 84,\n    0x1A1B: 84,\n    0x1A56: 84,\n    0x1A58: 84,\n    0x1A59: 84,\n    0x1A5A: 84,\n    0x1A5B: 84,\n    0x1A5C: 84,\n    0x1A5D: 84,\n    0x1A5E: 84,\n    0x1A60: 84,\n    0x1A62: 84,\n    0x1A65: 84,\n    0x1A66: 84,\n    0x1A67: 84,\n    0x1A68: 84,\n    0x1A69: 84,\n    0x1A6A: 84,\n    0x1A6B: 84,\n    0x1A6C: 84,\n    0x1A73: 84,\n    0x1A74: 84,\n    0x1A75: 84,\n    0x1A76: 84,\n    0x1A77: 84,\n    0x1A78: 84,\n    0x1A79: 84,\n    0x1A7A: 84,\n    0x1A7B: 84,\n    0x1A7C: 84,\n    0x1A7F: 84,\n    0x1AB0: 84,\n    0x1AB1: 84,\n    0x1AB2: 84,\n    0x1AB3: 84,\n    0x1AB4: 84,\n    0x1AB5: 84,\n    0x1AB6: 84,\n    0x1AB7: 84,\n    0x1AB8: 84,\n    0x1AB9: 84,\n    0x1ABA: 84,\n    0x1ABB: 84,\n    0x1ABC: 84,\n    0x1ABD: 84,\n    0x1ABE: 84,\n    0x1ABF: 84,\n    0x1AC0: 84,\n    0x1AC1: 84,\n    0x1AC2: 84,\n    0x1AC3: 84,\n    0x1AC4: 84,\n    0x1AC5: 84,\n    0x1AC6: 84,\n    0x1AC7: 84,\n    0x1AC8: 84,\n    0x1AC9: 84,\n    0x1ACA: 84,\n    0x1ACB: 84,\n    0x1ACC: 84,\n    0x1ACD: 84,\n    0x1ACE: 84,\n    0x1B00: 84,\n    0x1B01: 84,\n    0x1B02: 84,\n    0x1B03: 84,\n    0x1B34: 84,\n    0x1B36: 84,\n    0x1B37: 84,\n    0x1B38: 84,\n    0x1B39: 84,\n    0x1B3A: 84,\n    0x1B3C: 84,\n    0x1B42: 84,\n    0x1B6B: 84,\n    0x1B6C: 84,\n    0x1B6D: 84,\n    0x1B6E: 84,\n    0x1B6F: 84,\n    0x1B70: 84,\n    0x1B71: 84,\n    0x1B72: 84,\n    0x1B73: 84,\n    0x1B80: 84,\n    0x1B81: 84,\n    0x1BA2: 84,\n    0x1BA3: 84,\n    0x1BA4: 84,\n    0x1BA5: 84,\n    0x1BA8: 84,\n    0x1BA9: 84,\n    0x1BAB: 84,\n    0x1BAC: 84,\n    0x1BAD: 84,\n    0x1BE6: 84,\n    0x1BE8: 84,\n    0x1BE9: 84,\n    0x1BED: 84,\n    0x1BEF: 84,\n    0x1BF0: 84,\n    0x1BF1: 84,\n    0x1C2C: 84,\n    0x1C2D: 84,\n    0x1C2E: 84,\n    0x1C2F: 84,\n    0x1C30: 84,\n    0x1C31: 84,\n    0x1C32: 84,\n    0x1C33: 84,\n    0x1C36: 84,\n    0x1C37: 84,\n    0x1CD0: 84,\n    0x1CD1: 84,\n    0x1CD2: 84,\n    0x1CD4: 84,\n    0x1CD5: 84,\n    0x1CD6: 84,\n    0x1CD7: 84,\n    0x1CD8: 84,\n    0x1CD9: 84,\n    0x1CDA: 84,\n    0x1CDB: 84,\n    0x1CDC: 84,\n    0x1CDD: 84,\n    0x1CDE: 84,\n    0x1CDF: 84,\n    0x1CE0: 84,\n    0x1CE2: 84,\n    0x1CE3: 84,\n    0x1CE4: 84,\n    0x1CE5: 84,\n    0x1CE6: 84,\n    0x1CE7: 84,\n    0x1CE8: 84,\n    0x1CED: 84,\n    0x1CF4: 84,\n    0x1CF8: 84,\n    0x1CF9: 84,\n    0x1DC0: 84,\n    0x1DC1: 84,\n    0x1DC2: 84,\n    0x1DC3: 84,\n    0x1DC4: 84,\n    0x1DC5: 84,\n    0x1DC6: 84,\n    0x1DC7: 84,\n    0x1DC8: 84,\n    0x1DC9: 84,\n    0x1DCA: 84,\n    0x1DCB: 84,\n    0x1DCC: 84,\n    0x1DCD: 84,\n    0x1DCE: 84,\n    0x1DCF: 84,\n    0x1DD0: 84,\n    0x1DD1: 84,\n    0x1DD2: 84,\n    0x1DD3: 84,\n    0x1DD4: 84,\n    0x1DD5: 84,\n    0x1DD6: 84,\n    0x1DD7: 84,\n    0x1DD8: 84,\n    0x1DD9: 84,\n    0x1DDA: 84,\n    0x1DDB: 84,\n    0x1DDC: 84,\n    0x1DDD: 84,\n    0x1DDE: 84,\n    0x1DDF: 84,\n    0x1DE0: 84,\n    0x1DE1: 84,\n    0x1DE2: 84,\n    0x1DE3: 84,\n    0x1DE4: 84,\n    0x1DE5: 84,\n    0x1DE6: 84,\n    0x1DE7: 84,\n    0x1DE8: 84,\n    0x1DE9: 84,\n    0x1DEA: 84,\n    0x1DEB: 84,\n    0x1DEC: 84,\n    0x1DED: 84,\n    0x1DEE: 84,\n    0x1DEF: 84,\n    0x1DF0: 84,\n    0x1DF1: 84,\n    0x1DF2: 84,\n    0x1DF3: 84,\n    0x1DF4: 84,\n    0x1DF5: 84,\n    0x1DF6: 84,\n    0x1DF7: 84,\n    0x1DF8: 84,\n    0x1DF9: 84,\n    0x1DFA: 84,\n    0x1DFB: 84,\n    0x1DFC: 84,\n    0x1DFD: 84,\n    0x1DFE: 84,\n    0x1DFF: 84,\n    0x200B: 84,\n    0x200D: 67,\n    0x200E: 84,\n    0x200F: 84,\n    0x202A: 84,\n    0x202B: 84,\n    0x202C: 84,\n    0x202D: 84,\n    0x202E: 84,\n    0x2060: 84,\n    0x2061: 84,\n    0x2062: 84,\n    0x2063: 84,\n    0x2064: 84,\n    0x206A: 84,\n    0x206B: 84,\n    0x206C: 84,\n    0x206D: 84,\n    0x206E: 84,\n    0x206F: 84,\n    0x20D0: 84,\n    0x20D1: 84,\n    0x20D2: 84,\n    0x20D3: 84,\n    0x20D4: 84,\n    0x20D5: 84,\n    0x20D6: 84,\n    0x20D7: 84,\n    0x20D8: 84,\n    0x20D9: 84,\n    0x20DA: 84,\n    0x20DB: 84,\n    0x20DC: 84,\n    0x20DD: 84,\n    0x20DE: 84,\n    0x20DF: 84,\n    0x20E0: 84,\n    0x20E1: 84,\n    0x20E2: 84,\n    0x20E3: 84,\n    0x20E4: 84,\n    0x20E5: 84,\n    0x20E6: 84,\n    0x20E7: 84,\n    0x20E8: 84,\n    0x20E9: 84,\n    0x20EA: 84,\n    0x20EB: 84,\n    0x20EC: 84,\n    0x20ED: 84,\n    0x20EE: 84,\n    0x20EF: 84,\n    0x20F0: 84,\n    0x2CEF: 84,\n    0x2CF0: 84,\n    0x2CF1: 84,\n    0x2D7F: 84,\n    0x2DE0: 84,\n    0x2DE1: 84,\n    0x2DE2: 84,\n    0x2DE3: 84,\n    0x2DE4: 84,\n    0x2DE5: 84,\n    0x2DE6: 84,\n    0x2DE7: 84,\n    0x2DE8: 84,\n    0x2DE9: 84,\n    0x2DEA: 84,\n    0x2DEB: 84,\n    0x2DEC: 84,\n    0x2DED: 84,\n    0x2DEE: 84,\n    0x2DEF: 84,\n    0x2DF0: 84,\n    0x2DF1: 84,\n    0x2DF2: 84,\n    0x2DF3: 84,\n    0x2DF4: 84,\n    0x2DF5: 84,\n    0x2DF6: 84,\n    0x2DF7: 84,\n    0x2DF8: 84,\n    0x2DF9: 84,\n    0x2DFA: 84,\n    0x2DFB: 84,\n    0x2DFC: 84,\n    0x2DFD: 84,\n    0x2DFE: 84,\n    0x2DFF: 84,\n    0x302A: 84,\n    0x302B: 84,\n    0x302C: 84,\n    0x302D: 84,\n    0x3099: 84,\n    0x309A: 84,\n    0xA66F: 84,\n    0xA670: 84,\n    0xA671: 84,\n    0xA672: 84,\n    0xA674: 84,\n    0xA675: 84,\n    0xA676: 84,\n    0xA677: 84,\n    0xA678: 84,\n    0xA679: 84,\n    0xA67A: 84,\n    0xA67B: 84,\n    0xA67C: 84,\n    0xA67D: 84,\n    0xA69E: 84,\n    0xA69F: 84,\n    0xA6F0: 84,\n    0xA6F1: 84,\n    0xA802: 84,\n    0xA806: 84,\n    0xA80B: 84,\n    0xA825: 84,\n    0xA826: 84,\n    0xA82C: 84,\n    0xA840: 68,\n    0xA841: 68,\n    0xA842: 68,\n    0xA843: 68,\n    0xA844: 68,\n    0xA845: 68,\n    0xA846: 68,\n    0xA847: 68,\n    0xA848: 68,\n    0xA849: 68,\n    0xA84A: 68,\n    0xA84B: 68,\n    0xA84C: 68,\n    0xA84D: 68,\n    0xA84E: 68,\n    0xA84F: 68,\n    0xA850: 68,\n    0xA851: 68,\n    0xA852: 68,\n    0xA853: 68,\n    0xA854: 68,\n    0xA855: 68,\n    0xA856: 68,\n    0xA857: 68,\n    0xA858: 68,\n    0xA859: 68,\n    0xA85A: 68,\n    0xA85B: 68,\n    0xA85C: 68,\n    0xA85D: 68,\n    0xA85E: 68,\n    0xA85F: 68,\n    0xA860: 68,\n    0xA861: 68,\n    0xA862: 68,\n    0xA863: 68,\n    0xA864: 68,\n    0xA865: 68,\n    0xA866: 68,\n    0xA867: 68,\n    0xA868: 68,\n    0xA869: 68,\n    0xA86A: 68,\n    0xA86B: 68,\n    0xA86C: 68,\n    0xA86D: 68,\n    0xA86E: 68,\n    0xA86F: 68,\n    0xA870: 68,\n    0xA871: 68,\n    0xA872: 76,\n    0xA8C4: 84,\n    0xA8C5: 84,\n    0xA8E0: 84,\n    0xA8E1: 84,\n    0xA8E2: 84,\n    0xA8E3: 84,\n    0xA8E4: 84,\n    0xA8E5: 84,\n    0xA8E6: 84,\n    0xA8E7: 84,\n    0xA8E8: 84,\n    0xA8E9: 84,\n    0xA8EA: 84,\n    0xA8EB: 84,\n    0xA8EC: 84,\n    0xA8ED: 84,\n    0xA8EE: 84,\n    0xA8EF: 84,\n    0xA8F0: 84,\n    0xA8F1: 84,\n    0xA8FF: 84,\n    0xA926: 84,\n    0xA927: 84,\n    0xA928: 84,\n    0xA929: 84,\n    0xA92A: 84,\n    0xA92B: 84,\n    0xA92C: 84,\n    0xA92D: 84,\n    0xA947: 84,\n    0xA948: 84,\n    0xA949: 84,\n    0xA94A: 84,\n    0xA94B: 84,\n    0xA94C: 84,\n    0xA94D: 84,\n    0xA94E: 84,\n    0xA94F: 84,\n    0xA950: 84,\n    0xA951: 84,\n    0xA980: 84,\n    0xA981: 84,\n    0xA982: 84,\n    0xA9B3: 84,\n    0xA9B6: 84,\n    0xA9B7: 84,\n    0xA9B8: 84,\n    0xA9B9: 84,\n    0xA9BC: 84,\n    0xA9BD: 84,\n    0xA9E5: 84,\n    0xAA29: 84,\n    0xAA2A: 84,\n    0xAA2B: 84,\n    0xAA2C: 84,\n    0xAA2D: 84,\n    0xAA2E: 84,\n    0xAA31: 84,\n    0xAA32: 84,\n    0xAA35: 84,\n    0xAA36: 84,\n    0xAA43: 84,\n    0xAA4C: 84,\n    0xAA7C: 84,\n    0xAAB0: 84,\n    0xAAB2: 84,\n    0xAAB3: 84,\n    0xAAB4: 84,\n    0xAAB7: 84,\n    0xAAB8: 84,\n    0xAABE: 84,\n    0xAABF: 84,\n    0xAAC1: 84,\n    0xAAEC: 84,\n    0xAAED: 84,\n    0xAAF6: 84,\n    0xABE5: 84,\n    0xABE8: 84,\n    0xABED: 84,\n    0xFB1E: 84,\n    0xFE00: 84,\n    0xFE01: 84,\n    0xFE02: 84,\n    0xFE03: 84,\n    0xFE04: 84,\n    0xFE05: 84,\n    0xFE06: 84,\n    0xFE07: 84,\n    0xFE08: 84,\n    0xFE09: 84,\n    0xFE0A: 84,\n    0xFE0B: 84,\n    0xFE0C: 84,\n    0xFE0D: 84,\n    0xFE0E: 84,\n    0xFE0F: 84,\n    0xFE20: 84,\n    0xFE21: 84,\n    0xFE22: 84,\n    0xFE23: 84,\n    0xFE24: 84,\n    0xFE25: 84,\n    0xFE26: 84,\n    0xFE27: 84,\n    0xFE28: 84,\n    0xFE29: 84,\n    0xFE2A: 84,\n    0xFE2B: 84,\n    0xFE2C: 84,\n    0xFE2D: 84,\n    0xFE2E: 84,\n    0xFE2F: 84,\n    0xFEFF: 84,\n    0xFFF9: 84,\n    0xFFFA: 84,\n    0xFFFB: 84,\n    0x101FD: 84,\n    0x102E0: 84,\n    0x10376: 84,\n    0x10377: 84,\n    0x10378: 84,\n    0x10379: 84,\n    0x1037A: 84,\n    0x10A01: 84,\n    0x10A02: 84,\n    0x10A03: 84,\n    0x10A05: 84,\n    0x10A06: 84,\n    0x10A0C: 84,\n    0x10A0D: 84,\n    0x10A0E: 84,\n    0x10A0F: 84,\n    0x10A38: 84,\n    0x10A39: 84,\n    0x10A3A: 84,\n    0x10A3F: 84,\n    0x10AC0: 68,\n    0x10AC1: 68,\n    0x10AC2: 68,\n    0x10AC3: 68,\n    0x10AC4: 68,\n    0x10AC5: 82,\n    0x10AC7: 82,\n    0x10AC9: 82,\n    0x10ACA: 82,\n    0x10ACD: 76,\n    0x10ACE: 82,\n    0x10ACF: 82,\n    0x10AD0: 82,\n    0x10AD1: 82,\n    0x10AD2: 82,\n    0x10AD3: 68,\n    0x10AD4: 68,\n    0x10AD5: 68,\n    0x10AD6: 68,\n    0x10AD7: 76,\n    0x10AD8: 68,\n    0x10AD9: 68,\n    0x10ADA: 68,\n    0x10ADB: 68,\n    0x10ADC: 68,\n    0x10ADD: 82,\n    0x10ADE: 68,\n    0x10ADF: 68,\n    0x10AE0: 68,\n    0x10AE1: 82,\n    0x10AE4: 82,\n    0x10AE5: 84,\n    0x10AE6: 84,\n    0x10AEB: 68,\n    0x10AEC: 68,\n    0x10AED: 68,\n    0x10AEE: 68,\n    0x10AEF: 82,\n    0x10B80: 68,\n    0x10B81: 82,\n    0x10B82: 68,\n    0x10B83: 82,\n    0x10B84: 82,\n    0x10B85: 82,\n    0x10B86: 68,\n    0x10B87: 68,\n    0x10B88: 68,\n    0x10B89: 82,\n    0x10B8A: 68,\n    0x10B8B: 68,\n    0x10B8C: 82,\n    0x10B8D: 68,\n    0x10B8E: 82,\n    0x10B8F: 82,\n    0x10B90: 68,\n    0x10B91: 82,\n    0x10BA9: 82,\n    0x10BAA: 82,\n    0x10BAB: 82,\n    0x10BAC: 82,\n    0x10BAD: 68,\n    0x10BAE: 68,\n    0x10D00: 76,\n    0x10D01: 68,\n    0x10D02: 68,\n    0x10D03: 68,\n    0x10D04: 68,\n    0x10D05: 68,\n    0x10D06: 68,\n    0x10D07: 68,\n    0x10D08: 68,\n    0x10D09: 68,\n    0x10D0A: 68,\n    0x10D0B: 68,\n    0x10D0C: 68,\n    0x10D0D: 68,\n    0x10D0E: 68,\n    0x10D0F: 68,\n    0x10D10: 68,\n    0x10D11: 68,\n    0x10D12: 68,\n    0x10D13: 68,\n    0x10D14: 68,\n    0x10D15: 68,\n    0x10D16: 68,\n    0x10D17: 68,\n    0x10D18: 68,\n    0x10D19: 68,\n    0x10D1A: 68,\n    0x10D1B: 68,\n    0x10D1C: 68,\n    0x10D1D: 68,\n    0x10D1E: 68,\n    0x10D1F: 68,\n    0x10D20: 68,\n    0x10D21: 68,\n    0x10D22: 82,\n    0x10D23: 68,\n    0x10D24: 84,\n    0x10D25: 84,\n    0x10D26: 84,\n    0x10D27: 84,\n    0x10EAB: 84,\n    0x10EAC: 84,\n    0x10EFD: 84,\n    0x10EFE: 84,\n    0x10EFF: 84,\n    0x10F30: 68,\n    0x10F31: 68,\n    0x10F32: 68,\n    0x10F33: 82,\n    0x10F34: 68,\n    0x10F35: 68,\n    0x10F36: 68,\n    0x10F37: 68,\n    0x10F38: 68,\n    0x10F39: 68,\n    0x10F3A: 68,\n    0x10F3B: 68,\n    0x10F3C: 68,\n    0x10F3D: 68,\n    0x10F3E: 68,\n    0x10F3F: 68,\n    0x10F40: 68,\n    0x10F41: 68,\n    0x10F42: 68,\n    0x10F43: 68,\n    0x10F44: 68,\n    0x10F46: 84,\n    0x10F47: 84,\n    0x10F48: 84,\n    0x10F49: 84,\n    0x10F4A: 84,\n    0x10F4B: 84,\n    0x10F4C: 84,\n    0x10F4D: 84,\n    0x10F4E: 84,\n    0x10F4F: 84,\n    0x10F50: 84,\n    0x10F51: 68,\n    0x10F52: 68,\n    0x10F53: 68,\n    0x10F54: 82,\n    0x10F70: 68,\n    0x10F71: 68,\n    0x10F72: 68,\n    0x10F73: 68,\n    0x10F74: 82,\n    0x10F75: 82,\n    0x10F76: 68,\n    0x10F77: 68,\n    0x10F78: 68,\n    0x10F79: 68,\n    0x10F7A: 68,\n    0x10F7B: 68,\n    0x10F7C: 68,\n    0x10F7D: 68,\n    0x10F7E: 68,\n    0x10F7F: 68,\n    0x10F80: 68,\n    0x10F81: 68,\n    0x10F82: 84,\n    0x10F83: 84,\n    0x10F84: 84,\n    0x10F85: 84,\n    0x10FB0: 68,\n    0x10FB2: 68,\n    0x10FB3: 68,\n    0x10FB4: 82,\n    0x10FB5: 82,\n    0x10FB6: 82,\n    0x10FB8: 68,\n    0x10FB9: 82,\n    0x10FBA: 82,\n    0x10FBB: 68,\n    0x10FBC: 68,\n    0x10FBD: 82,\n    0x10FBE: 68,\n    0x10FBF: 68,\n    0x10FC1: 68,\n    0x10FC2: 82,\n    0x10FC3: 82,\n    0x10FC4: 68,\n    0x10FC9: 82,\n    0x10FCA: 68,\n    0x10FCB: 76,\n    0x11001: 84,\n    0x11038: 84,\n    0x11039: 84,\n    0x1103A: 84,\n    0x1103B: 84,\n    0x1103C: 84,\n    0x1103D: 84,\n    0x1103E: 84,\n    0x1103F: 84,\n    0x11040: 84,\n    0x11041: 84,\n    0x11042: 84,\n    0x11043: 84,\n    0x11044: 84,\n    0x11045: 84,\n    0x11046: 84,\n    0x11070: 84,\n    0x11073: 84,\n    0x11074: 84,\n    0x1107F: 84,\n    0x11080: 84,\n    0x11081: 84,\n    0x110B3: 84,\n    0x110B4: 84,\n    0x110B5: 84,\n    0x110B6: 84,\n    0x110B9: 84,\n    0x110BA: 84,\n    0x110C2: 84,\n    0x11100: 84,\n    0x11101: 84,\n    0x11102: 84,\n    0x11127: 84,\n    0x11128: 84,\n    0x11129: 84,\n    0x1112A: 84,\n    0x1112B: 84,\n    0x1112D: 84,\n    0x1112E: 84,\n    0x1112F: 84,\n    0x11130: 84,\n    0x11131: 84,\n    0x11132: 84,\n    0x11133: 84,\n    0x11134: 84,\n    0x11173: 84,\n    0x11180: 84,\n    0x11181: 84,\n    0x111B6: 84,\n    0x111B7: 84,\n    0x111B8: 84,\n    0x111B9: 84,\n    0x111BA: 84,\n    0x111BB: 84,\n    0x111BC: 84,\n    0x111BD: 84,\n    0x111BE: 84,\n    0x111C9: 84,\n    0x111CA: 84,\n    0x111CB: 84,\n    0x111CC: 84,\n    0x111CF: 84,\n    0x1122F: 84,\n    0x11230: 84,\n    0x11231: 84,\n    0x11234: 84,\n    0x11236: 84,\n    0x11237: 84,\n    0x1123E: 84,\n    0x11241: 84,\n    0x112DF: 84,\n    0x112E3: 84,\n    0x112E4: 84,\n    0x112E5: 84,\n    0x112E6: 84,\n    0x112E7: 84,\n    0x112E8: 84,\n    0x112E9: 84,\n    0x112EA: 84,\n    0x11300: 84,\n    0x11301: 84,\n    0x1133B: 84,\n    0x1133C: 84,\n    0x11340: 84,\n    0x11366: 84,\n    0x11367: 84,\n    0x11368: 84,\n    0x11369: 84,\n    0x1136A: 84,\n    0x1136B: 84,\n    0x1136C: 84,\n    0x11370: 84,\n    0x11371: 84,\n    0x11372: 84,\n    0x11373: 84,\n    0x11374: 84,\n    0x11438: 84,\n    0x11439: 84,\n    0x1143A: 84,\n    0x1143B: 84,\n    0x1143C: 84,\n    0x1143D: 84,\n    0x1143E: 84,\n    0x1143F: 84,\n    0x11442: 84,\n    0x11443: 84,\n    0x11444: 84,\n    0x11446: 84,\n    0x1145E: 84,\n    0x114B3: 84,\n    0x114B4: 84,\n    0x114B5: 84,\n    0x114B6: 84,\n    0x114B7: 84,\n    0x114B8: 84,\n    0x114BA: 84,\n    0x114BF: 84,\n    0x114C0: 84,\n    0x114C2: 84,\n    0x114C3: 84,\n    0x115B2: 84,\n    0x115B3: 84,\n    0x115B4: 84,\n    0x115B5: 84,\n    0x115BC: 84,\n    0x115BD: 84,\n    0x115BF: 84,\n    0x115C0: 84,\n    0x115DC: 84,\n    0x115DD: 84,\n    0x11633: 84,\n    0x11634: 84,\n    0x11635: 84,\n    0x11636: 84,\n    0x11637: 84,\n    0x11638: 84,\n    0x11639: 84,\n    0x1163A: 84,\n    0x1163D: 84,\n    0x1163F: 84,\n    0x11640: 84,\n    0x116AB: 84,\n    0x116AD: 84,\n    0x116B0: 84,\n    0x116B1: 84,\n    0x116B2: 84,\n    0x116B3: 84,\n    0x116B4: 84,\n    0x116B5: 84,\n    0x116B7: 84,\n    0x1171D: 84,\n    0x1171E: 84,\n    0x1171F: 84,\n    0x11722: 84,\n    0x11723: 84,\n    0x11724: 84,\n    0x11725: 84,\n    0x11727: 84,\n    0x11728: 84,\n    0x11729: 84,\n    0x1172A: 84,\n    0x1172B: 84,\n    0x1182F: 84,\n    0x11830: 84,\n    0x11831: 84,\n    0x11832: 84,\n    0x11833: 84,\n    0x11834: 84,\n    0x11835: 84,\n    0x11836: 84,\n    0x11837: 84,\n    0x11839: 84,\n    0x1183A: 84,\n    0x1193B: 84,\n    0x1193C: 84,\n    0x1193E: 84,\n    0x11943: 84,\n    0x119D4: 84,\n    0x119D5: 84,\n    0x119D6: 84,\n    0x119D7: 84,\n    0x119DA: 84,\n    0x119DB: 84,\n    0x119E0: 84,\n    0x11A01: 84,\n    0x11A02: 84,\n    0x11A03: 84,\n    0x11A04: 84,\n    0x11A05: 84,\n    0x11A06: 84,\n    0x11A07: 84,\n    0x11A08: 84,\n    0x11A09: 84,\n    0x11A0A: 84,\n    0x11A33: 84,\n    0x11A34: 84,\n    0x11A35: 84,\n    0x11A36: 84,\n    0x11A37: 84,\n    0x11A38: 84,\n    0x11A3B: 84,\n    0x11A3C: 84,\n    0x11A3D: 84,\n    0x11A3E: 84,\n    0x11A47: 84,\n    0x11A51: 84,\n    0x11A52: 84,\n    0x11A53: 84,\n    0x11A54: 84,\n    0x11A55: 84,\n    0x11A56: 84,\n    0x11A59: 84,\n    0x11A5A: 84,\n    0x11A5B: 84,\n    0x11A8A: 84,\n    0x11A8B: 84,\n    0x11A8C: 84,\n    0x11A8D: 84,\n    0x11A8E: 84,\n    0x11A8F: 84,\n    0x11A90: 84,\n    0x11A91: 84,\n    0x11A92: 84,\n    0x11A93: 84,\n    0x11A94: 84,\n    0x11A95: 84,\n    0x11A96: 84,\n    0x11A98: 84,\n    0x11A99: 84,\n    0x11C30: 84,\n    0x11C31: 84,\n    0x11C32: 84,\n    0x11C33: 84,\n    0x11C34: 84,\n    0x11C35: 84,\n    0x11C36: 84,\n    0x11C38: 84,\n    0x11C39: 84,\n    0x11C3A: 84,\n    0x11C3B: 84,\n    0x11C3C: 84,\n    0x11C3D: 84,\n    0x11C3F: 84,\n    0x11C92: 84,\n    0x11C93: 84,\n    0x11C94: 84,\n    0x11C95: 84,\n    0x11C96: 84,\n    0x11C97: 84,\n    0x11C98: 84,\n    0x11C99: 84,\n    0x11C9A: 84,\n    0x11C9B: 84,\n    0x11C9C: 84,\n    0x11C9D: 84,\n    0x11C9E: 84,\n    0x11C9F: 84,\n    0x11CA0: 84,\n    0x11CA1: 84,\n    0x11CA2: 84,\n    0x11CA3: 84,\n    0x11CA4: 84,\n    0x11CA5: 84,\n    0x11CA6: 84,\n    0x11CA7: 84,\n    0x11CAA: 84,\n    0x11CAB: 84,\n    0x11CAC: 84,\n    0x11CAD: 84,\n    0x11CAE: 84,\n    0x11CAF: 84,\n    0x11CB0: 84,\n    0x11CB2: 84,\n    0x11CB3: 84,\n    0x11CB5: 84,\n    0x11CB6: 84,\n    0x11D31: 84,\n    0x11D32: 84,\n    0x11D33: 84,\n    0x11D34: 84,\n    0x11D35: 84,\n    0x11D36: 84,\n    0x11D3A: 84,\n    0x11D3C: 84,\n    0x11D3D: 84,\n    0x11D3F: 84,\n    0x11D40: 84,\n    0x11D41: 84,\n    0x11D42: 84,\n    0x11D43: 84,\n    0x11D44: 84,\n    0x11D45: 84,\n    0x11D47: 84,\n    0x11D90: 84,\n    0x11D91: 84,\n    0x11D95: 84,\n    0x11D97: 84,\n    0x11EF3: 84,\n    0x11EF4: 84,\n    0x11F00: 84,\n    0x11F01: 84,\n    0x11F36: 84,\n    0x11F37: 84,\n    0x11F38: 84,\n    0x11F39: 84,\n    0x11F3A: 84,\n    0x11F40: 84,\n    0x11F42: 84,\n    0x13430: 84,\n    0x13431: 84,\n    0x13432: 84,\n    0x13433: 84,\n    0x13434: 84,\n    0x13435: 84,\n    0x13436: 84,\n    0x13437: 84,\n    0x13438: 84,\n    0x13439: 84,\n    0x1343A: 84,\n    0x1343B: 84,\n    0x1343C: 84,\n    0x1343D: 84,\n    0x1343E: 84,\n    0x1343F: 84,\n    0x13440: 84,\n    0x13447: 84,\n    0x13448: 84,\n    0x13449: 84,\n    0x1344A: 84,\n    0x1344B: 84,\n    0x1344C: 84,\n    0x1344D: 84,\n    0x1344E: 84,\n    0x1344F: 84,\n    0x13450: 84,\n    0x13451: 84,\n    0x13452: 84,\n    0x13453: 84,\n    0x13454: 84,\n    0x13455: 84,\n    0x16AF0: 84,\n    0x16AF1: 84,\n    0x16AF2: 84,\n    0x16AF3: 84,\n    0x16AF4: 84,\n    0x16B30: 84,\n    0x16B31: 84,\n    0x16B32: 84,\n    0x16B33: 84,\n    0x16B34: 84,\n    0x16B35: 84,\n    0x16B36: 84,\n    0x16F4F: 84,\n    0x16F8F: 84,\n    0x16F90: 84,\n    0x16F91: 84,\n    0x16F92: 84,\n    0x16FE4: 84,\n    0x1BC9D: 84,\n    0x1BC9E: 84,\n    0x1BCA0: 84,\n    0x1BCA1: 84,\n    0x1BCA2: 84,\n    0x1BCA3: 84,\n    0x1CF00: 84,\n    0x1CF01: 84,\n    0x1CF02: 84,\n    0x1CF03: 84,\n    0x1CF04: 84,\n    0x1CF05: 84,\n    0x1CF06: 84,\n    0x1CF07: 84,\n    0x1CF08: 84,\n    0x1CF09: 84,\n    0x1CF0A: 84,\n    0x1CF0B: 84,\n    0x1CF0C: 84,\n    0x1CF0D: 84,\n    0x1CF0E: 84,\n    0x1CF0F: 84,\n    0x1CF10: 84,\n    0x1CF11: 84,\n    0x1CF12: 84,\n    0x1CF13: 84,\n    0x1CF14: 84,\n    0x1CF15: 84,\n    0x1CF16: 84,\n    0x1CF17: 84,\n    0x1CF18: 84,\n    0x1CF19: 84,\n    0x1CF1A: 84,\n    0x1CF1B: 84,\n    0x1CF1C: 84,\n    0x1CF1D: 84,\n    0x1CF1E: 84,\n    0x1CF1F: 84,\n    0x1CF20: 84,\n    0x1CF21: 84,\n    0x1CF22: 84,\n    0x1CF23: 84,\n    0x1CF24: 84,\n    0x1CF25: 84,\n    0x1CF26: 84,\n    0x1CF27: 84,\n    0x1CF28: 84,\n    0x1CF29: 84,\n    0x1CF2A: 84,\n    0x1CF2B: 84,\n    0x1CF2C: 84,\n    0x1CF2D: 84,\n    0x1CF30: 84,\n    0x1CF31: 84,\n    0x1CF32: 84,\n    0x1CF33: 84,\n    0x1CF34: 84,\n    0x1CF35: 84,\n    0x1CF36: 84,\n    0x1CF37: 84,\n    0x1CF38: 84,\n    0x1CF39: 84,\n    0x1CF3A: 84,\n    0x1CF3B: 84,\n    0x1CF3C: 84,\n    0x1CF3D: 84,\n    0x1CF3E: 84,\n    0x1CF3F: 84,\n    0x1CF40: 84,\n    0x1CF41: 84,\n    0x1CF42: 84,\n    0x1CF43: 84,\n    0x1CF44: 84,\n    0x1CF45: 84,\n    0x1CF46: 84,\n    0x1D167: 84,\n    0x1D168: 84,\n    0x1D169: 84,\n    0x1D173: 84,\n    0x1D174: 84,\n    0x1D175: 84,\n    0x1D176: 84,\n    0x1D177: 84,\n    0x1D178: 84,\n    0x1D179: 84,\n    0x1D17A: 84,\n    0x1D17B: 84,\n    0x1D17C: 84,\n    0x1D17D: 84,\n    0x1D17E: 84,\n    0x1D17F: 84,\n    0x1D180: 84,\n    0x1D181: 84,\n    0x1D182: 84,\n    0x1D185: 84,\n    0x1D186: 84,\n    0x1D187: 84,\n    0x1D188: 84,\n    0x1D189: 84,\n    0x1D18A: 84,\n    0x1D18B: 84,\n    0x1D1AA: 84,\n    0x1D1AB: 84,\n    0x1D1AC: 84,\n    0x1D1AD: 84,\n    0x1D242: 84,\n    0x1D243: 84,\n    0x1D244: 84,\n    0x1DA00: 84,\n    0x1DA01: 84,\n    0x1DA02: 84,\n    0x1DA03: 84,\n    0x1DA04: 84,\n    0x1DA05: 84,\n    0x1DA06: 84,\n    0x1DA07: 84,\n    0x1DA08: 84,\n    0x1DA09: 84,\n    0x1DA0A: 84,\n    0x1DA0B: 84,\n    0x1DA0C: 84,\n    0x1DA0D: 84,\n    0x1DA0E: 84,\n    0x1DA0F: 84,\n    0x1DA10: 84,\n    0x1DA11: 84,\n    0x1DA12: 84,\n    0x1DA13: 84,\n    0x1DA14: 84,\n    0x1DA15: 84,\n    0x1DA16: 84,\n    0x1DA17: 84,\n    0x1DA18: 84,\n    0x1DA19: 84,\n    0x1DA1A: 84,\n    0x1DA1B: 84,\n    0x1DA1C: 84,\n    0x1DA1D: 84,\n    0x1DA1E: 84,\n    0x1DA1F: 84,\n    0x1DA20: 84,\n    0x1DA21: 84,\n    0x1DA22: 84,\n    0x1DA23: 84,\n    0x1DA24: 84,\n    0x1DA25: 84,\n    0x1DA26: 84,\n    0x1DA27: 84,\n    0x1DA28: 84,\n    0x1DA29: 84,\n    0x1DA2A: 84,\n    0x1DA2B: 84,\n    0x1DA2C: 84,\n    0x1DA2D: 84,\n    0x1DA2E: 84,\n    0x1DA2F: 84,\n    0x1DA30: 84,\n    0x1DA31: 84,\n    0x1DA32: 84,\n    0x1DA33: 84,\n    0x1DA34: 84,\n    0x1DA35: 84,\n    0x1DA36: 84,\n    0x1DA3B: 84,\n    0x1DA3C: 84,\n    0x1DA3D: 84,\n    0x1DA3E: 84,\n    0x1DA3F: 84,\n    0x1DA40: 84,\n    0x1DA41: 84,\n    0x1DA42: 84,\n    0x1DA43: 84,\n    0x1DA44: 84,\n    0x1DA45: 84,\n    0x1DA46: 84,\n    0x1DA47: 84,\n    0x1DA48: 84,\n    0x1DA49: 84,\n    0x1DA4A: 84,\n    0x1DA4B: 84,\n    0x1DA4C: 84,\n    0x1DA4D: 84,\n    0x1DA4E: 84,\n    0x1DA4F: 84,\n    0x1DA50: 84,\n    0x1DA51: 84,\n    0x1DA52: 84,\n    0x1DA53: 84,\n    0x1DA54: 84,\n    0x1DA55: 84,\n    0x1DA56: 84,\n    0x1DA57: 84,\n    0x1DA58: 84,\n    0x1DA59: 84,\n    0x1DA5A: 84,\n    0x1DA5B: 84,\n    0x1DA5C: 84,\n    0x1DA5D: 84,\n    0x1DA5E: 84,\n    0x1DA5F: 84,\n    0x1DA60: 84,\n    0x1DA61: 84,\n    0x1DA62: 84,\n    0x1DA63: 84,\n    0x1DA64: 84,\n    0x1DA65: 84,\n    0x1DA66: 84,\n    0x1DA67: 84,\n    0x1DA68: 84,\n    0x1DA69: 84,\n    0x1DA6A: 84,\n    0x1DA6B: 84,\n    0x1DA6C: 84,\n    0x1DA75: 84,\n    0x1DA84: 84,\n    0x1DA9B: 84,\n    0x1DA9C: 84,\n    0x1DA9D: 84,\n    0x1DA9E: 84,\n    0x1DA9F: 84,\n    0x1DAA1: 84,\n    0x1DAA2: 84,\n    0x1DAA3: 84,\n    0x1DAA4: 84,\n    0x1DAA5: 84,\n    0x1DAA6: 84,\n    0x1DAA7: 84,\n    0x1DAA8: 84,\n    0x1DAA9: 84,\n    0x1DAAA: 84,\n    0x1DAAB: 84,\n    0x1DAAC: 84,\n    0x1DAAD: 84,\n    0x1DAAE: 84,\n    0x1DAAF: 84,\n    0x1E000: 84,\n    0x1E001: 84,\n    0x1E002: 84,\n    0x1E003: 84,\n    0x1E004: 84,\n    0x1E005: 84,\n    0x1E006: 84,\n    0x1E008: 84,\n    0x1E009: 84,\n    0x1E00A: 84,\n    0x1E00B: 84,\n    0x1E00C: 84,\n    0x1E00D: 84,\n    0x1E00E: 84,\n    0x1E00F: 84,\n    0x1E010: 84,\n    0x1E011: 84,\n    0x1E012: 84,\n    0x1E013: 84,\n    0x1E014: 84,\n    0x1E015: 84,\n    0x1E016: 84,\n    0x1E017: 84,\n    0x1E018: 84,\n    0x1E01B: 84,\n    0x1E01C: 84,\n    0x1E01D: 84,\n    0x1E01E: 84,\n    0x1E01F: 84,\n    0x1E020: 84,\n    0x1E021: 84,\n    0x1E023: 84,\n    0x1E024: 84,\n    0x1E026: 84,\n    0x1E027: 84,\n    0x1E028: 84,\n    0x1E029: 84,\n    0x1E02A: 84,\n    0x1E08F: 84,\n    0x1E130: 84,\n    0x1E131: 84,\n    0x1E132: 84,\n    0x1E133: 84,\n    0x1E134: 84,\n    0x1E135: 84,\n    0x1E136: 84,\n    0x1E2AE: 84,\n    0x1E2EC: 84,\n    0x1E2ED: 84,\n    0x1E2EE: 84,\n    0x1E2EF: 84,\n    0x1E4EC: 84,\n    0x1E4ED: 84,\n    0x1E4EE: 84,\n    0x1E4EF: 84,\n    0x1E8D0: 84,\n    0x1E8D1: 84,\n    0x1E8D2: 84,\n    0x1E8D3: 84,\n    0x1E8D4: 84,\n    0x1E8D5: 84,\n    0x1E8D6: 84,\n    0x1E900: 68,\n    0x1E901: 68,\n    0x1E902: 68,\n    0x1E903: 68,\n    0x1E904: 68,\n    0x1E905: 68,\n    0x1E906: 68,\n    0x1E907: 68,\n    0x1E908: 68,\n    0x1E909: 68,\n    0x1E90A: 68,\n    0x1E90B: 68,\n    0x1E90C: 68,\n    0x1E90D: 68,\n    0x1E90E: 68,\n    0x1E90F: 68,\n    0x1E910: 68,\n    0x1E911: 68,\n    0x1E912: 68,\n    0x1E913: 68,\n    0x1E914: 68,\n    0x1E915: 68,\n    0x1E916: 68,\n    0x1E917: 68,\n    0x1E918: 68,\n    0x1E919: 68,\n    0x1E91A: 68,\n    0x1E91B: 68,\n    0x1E91C: 68,\n    0x1E91D: 68,\n    0x1E91E: 68,\n    0x1E91F: 68,\n    0x1E920: 68,\n    0x1E921: 68,\n    0x1E922: 68,\n    0x1E923: 68,\n    0x1E924: 68,\n    0x1E925: 68,\n    0x1E926: 68,\n    0x1E927: 68,\n    0x1E928: 68,\n    0x1E929: 68,\n    0x1E92A: 68,\n    0x1E92B: 68,\n    0x1E92C: 68,\n    0x1E92D: 68,\n    0x1E92E: 68,\n    0x1E92F: 68,\n    0x1E930: 68,\n    0x1E931: 68,\n    0x1E932: 68,\n    0x1E933: 68,\n    0x1E934: 68,\n    0x1E935: 68,\n    0x1E936: 68,\n    0x1E937: 68,\n    0x1E938: 68,\n    0x1E939: 68,\n    0x1E93A: 68,\n    0x1E93B: 68,\n    0x1E93C: 68,\n    0x1E93D: 68,\n    0x1E93E: 68,\n    0x1E93F: 68,\n    0x1E940: 68,\n    0x1E941: 68,\n    0x1E942: 68,\n    0x1E943: 68,\n    0x1E944: 84,\n    0x1E945: 84,\n    0x1E946: 84,\n    0x1E947: 84,\n    0x1E948: 84,\n    0x1E949: 84,\n    0x1E94A: 84,\n    0x1E94B: 84,\n    0xE0001: 84,\n    0xE0020: 84,\n    0xE0021: 84,\n    0xE0022: 84,\n    0xE0023: 84,\n    0xE0024: 84,\n    0xE0025: 84,\n    0xE0026: 84,\n    0xE0027: 84,\n    0xE0028: 84,\n    0xE0029: 84,\n    0xE002A: 84,\n    0xE002B: 84,\n    0xE002C: 84,\n    0xE002D: 84,\n    0xE002E: 84,\n    0xE002F: 84,\n    0xE0030: 84,\n    0xE0031: 84,\n    0xE0032: 84,\n    0xE0033: 84,\n    0xE0034: 84,\n    0xE0035: 84,\n    0xE0036: 84,\n    0xE0037: 84,\n    0xE0038: 84,\n    0xE0039: 84,\n    0xE003A: 84,\n    0xE003B: 84,\n    0xE003C: 84,\n    0xE003D: 84,\n    0xE003E: 84,\n    0xE003F: 84,\n    0xE0040: 84,\n    0xE0041: 84,\n    0xE0042: 84,\n    0xE0043: 84,\n    0xE0044: 84,\n    0xE0045: 84,\n    0xE0046: 84,\n    0xE0047: 84,\n    0xE0048: 84,\n    0xE0049: 84,\n    0xE004A: 84,\n    0xE004B: 84,\n    0xE004C: 84,\n    0xE004D: 84,\n    0xE004E: 84,\n    0xE004F: 84,\n    0xE0050: 84,\n    0xE0051: 84,\n    0xE0052: 84,\n    0xE0053: 84,\n    0xE0054: 84,\n    0xE0055: 84,\n    0xE0056: 84,\n    0xE0057: 84,\n    0xE0058: 84,\n    0xE0059: 84,\n    0xE005A: 84,\n    0xE005B: 84,\n    0xE005C: 84,\n    0xE005D: 84,\n    0xE005E: 84,\n    0xE005F: 84,\n    0xE0060: 84,\n    0xE0061: 84,\n    0xE0062: 84,\n    0xE0063: 84,\n    0xE0064: 84,\n    0xE0065: 84,\n    0xE0066: 84,\n    0xE0067: 84,\n    0xE0068: 84,\n    0xE0069: 84,\n    0xE006A: 84,\n    0xE006B: 84,\n    0xE006C: 84,\n    0xE006D: 84,\n    0xE006E: 84,\n    0xE006F: 84,\n    0xE0070: 84,\n    0xE0071: 84,\n    0xE0072: 84,\n    0xE0073: 84,\n    0xE0074: 84,\n    0xE0075: 84,\n    0xE0076: 84,\n    0xE0077: 84,\n    0xE0078: 84,\n    0xE0079: 84,\n    0xE007A: 84,\n    0xE007B: 84,\n    0xE007C: 84,\n    0xE007D: 84,\n    0xE007E: 84,\n    0xE007F: 84,\n    0xE0100: 84,\n    0xE0101: 84,\n    0xE0102: 84,\n    0xE0103: 84,\n    0xE0104: 84,\n    0xE0105: 84,\n    0xE0106: 84,\n    0xE0107: 84,\n    0xE0108: 84,\n    0xE0109: 84,\n    0xE010A: 84,\n    0xE010B: 84,\n    0xE010C: 84,\n    0xE010D: 84,\n    0xE010E: 84,\n    0xE010F: 84,\n    0xE0110: 84,\n    0xE0111: 84,\n    0xE0112: 84,\n    0xE0113: 84,\n    0xE0114: 84,\n    0xE0115: 84,\n    0xE0116: 84,\n    0xE0117: 84,\n    0xE0118: 84,\n    0xE0119: 84,\n    0xE011A: 84,\n    0xE011B: 84,\n    0xE011C: 84,\n    0xE011D: 84,\n    0xE011E: 84,\n    0xE011F: 84,\n    0xE0120: 84,\n    0xE0121: 84,\n    0xE0122: 84,\n    0xE0123: 84,\n    0xE0124: 84,\n    0xE0125: 84,\n    0xE0126: 84,\n    0xE0127: 84,\n    0xE0128: 84,\n    0xE0129: 84,\n    0xE012A: 84,\n    0xE012B: 84,\n    0xE012C: 84,\n    0xE012D: 84,\n    0xE012E: 84,\n    0xE012F: 84,\n    0xE0130: 84,\n    0xE0131: 84,\n    0xE0132: 84,\n    0xE0133: 84,\n    0xE0134: 84,\n    0xE0135: 84,\n    0xE0136: 84,\n    0xE0137: 84,\n    0xE0138: 84,\n    0xE0139: 84,\n    0xE013A: 84,\n    0xE013B: 84,\n    0xE013C: 84,\n    0xE013D: 84,\n    0xE013E: 84,\n    0xE013F: 84,\n    0xE0140: 84,\n    0xE0141: 84,\n    0xE0142: 84,\n    0xE0143: 84,\n    0xE0144: 84,\n    0xE0145: 84,\n    0xE0146: 84,\n    0xE0147: 84,\n    0xE0148: 84,\n    0xE0149: 84,\n    0xE014A: 84,\n    0xE014B: 84,\n    0xE014C: 84,\n    0xE014D: 84,\n    0xE014E: 84,\n    0xE014F: 84,\n    0xE0150: 84,\n    0xE0151: 84,\n    0xE0152: 84,\n    0xE0153: 84,\n    0xE0154: 84,\n    0xE0155: 84,\n    0xE0156: 84,\n    0xE0157: 84,\n    0xE0158: 84,\n    0xE0159: 84,\n    0xE015A: 84,\n    0xE015B: 84,\n    0xE015C: 84,\n    0xE015D: 84,\n    0xE015E: 84,\n    0xE015F: 84,\n    0xE0160: 84,\n    0xE0161: 84,\n    0xE0162: 84,\n    0xE0163: 84,\n    0xE0164: 84,\n    0xE0165: 84,\n    0xE0166: 84,\n    0xE0167: 84,\n    0xE0168: 84,\n    0xE0169: 84,\n    0xE016A: 84,\n    0xE016B: 84,\n    0xE016C: 84,\n    0xE016D: 84,\n    0xE016E: 84,\n    0xE016F: 84,\n    0xE0170: 84,\n    0xE0171: 84,\n    0xE0172: 84,\n    0xE0173: 84,\n    0xE0174: 84,\n    0xE0175: 84,\n    0xE0176: 84,\n    0xE0177: 84,\n    0xE0178: 84,\n    0xE0179: 84,\n    0xE017A: 84,\n    0xE017B: 84,\n    0xE017C: 84,\n    0xE017D: 84,\n    0xE017E: 84,\n    0xE017F: 84,\n    0xE0180: 84,\n    0xE0181: 84,\n    0xE0182: 84,\n    0xE0183: 84,\n    0xE0184: 84,\n    0xE0185: 84,\n    0xE0186: 84,\n    0xE0187: 84,\n    0xE0188: 84,\n    0xE0189: 84,\n    0xE018A: 84,\n    0xE018B: 84,\n    0xE018C: 84,\n    0xE018D: 84,\n    0xE018E: 84,\n    0xE018F: 84,\n    0xE0190: 84,\n    0xE0191: 84,\n    0xE0192: 84,\n    0xE0193: 84,\n    0xE0194: 84,\n    0xE0195: 84,\n    0xE0196: 84,\n    0xE0197: 84,\n    0xE0198: 84,\n    0xE0199: 84,\n    0xE019A: 84,\n    0xE019B: 84,\n    0xE019C: 84,\n    0xE019D: 84,\n    0xE019E: 84,\n    0xE019F: 84,\n    0xE01A0: 84,\n    0xE01A1: 84,\n    0xE01A2: 84,\n    0xE01A3: 84,\n    0xE01A4: 84,\n    0xE01A5: 84,\n    0xE01A6: 84,\n    0xE01A7: 84,\n    0xE01A8: 84,\n    0xE01A9: 84,\n    0xE01AA: 84,\n    0xE01AB: 84,\n    0xE01AC: 84,\n    0xE01AD: 84,\n    0xE01AE: 84,\n    0xE01AF: 84,\n    0xE01B0: 84,\n    0xE01B1: 84,\n    0xE01B2: 84,\n    0xE01B3: 84,\n    0xE01B4: 84,\n    0xE01B5: 84,\n    0xE01B6: 84,\n    0xE01B7: 84,\n    0xE01B8: 84,\n    0xE01B9: 84,\n    0xE01BA: 84,\n    0xE01BB: 84,\n    0xE01BC: 84,\n    0xE01BD: 84,\n    0xE01BE: 84,\n    0xE01BF: 84,\n    0xE01C0: 84,\n    0xE01C1: 84,\n    0xE01C2: 84,\n    0xE01C3: 84,\n    0xE01C4: 84,\n    0xE01C5: 84,\n    0xE01C6: 84,\n    0xE01C7: 84,\n    0xE01C8: 84,\n    0xE01C9: 84,\n    0xE01CA: 84,\n    0xE01CB: 84,\n    0xE01CC: 84,\n    0xE01CD: 84,\n    0xE01CE: 84,\n    0xE01CF: 84,\n    0xE01D0: 84,\n    0xE01D1: 84,\n    0xE01D2: 84,\n    0xE01D3: 84,\n    0xE01D4: 84,\n    0xE01D5: 84,\n    0xE01D6: 84,\n    0xE01D7: 84,\n    0xE01D8: 84,\n    0xE01D9: 84,\n    0xE01DA: 84,\n    0xE01DB: 84,\n    0xE01DC: 84,\n    0xE01DD: 84,\n    0xE01DE: 84,\n    0xE01DF: 84,\n    0xE01E0: 84,\n    0xE01E1: 84,\n    0xE01E2: 84,\n    0xE01E3: 84,\n    0xE01E4: 84,\n    0xE01E5: 84,\n    0xE01E6: 84,\n    0xE01E7: 84,\n    0xE01E8: 84,\n    0xE01E9: 84,\n    0xE01EA: 84,\n    0xE01EB: 84,\n    0xE01EC: 84,\n    0xE01ED: 84,\n    0xE01EE: 84,\n    0xE01EF: 84,\n}\ncodepoint_classes = {\n    \"PVALID\": (\n        0x2D0000002E,\n        0x300000003A,\n        0x610000007B,\n        0xDF000000F7,\n        0xF800000100,\n        0x10100000102,\n        0x10300000104,\n        0x10500000106,\n        0x10700000108,\n        0x1090000010A,\n        0x10B0000010C,\n        0x10D0000010E,\n        0x10F00000110,\n        0x11100000112,\n        0x11300000114,\n        0x11500000116,\n        0x11700000118,\n        0x1190000011A,\n        0x11B0000011C,\n        0x11D0000011E,\n        0x11F00000120,\n        0x12100000122,\n        0x12300000124,\n        0x12500000126,\n        0x12700000128,\n        0x1290000012A,\n        0x12B0000012C,\n        0x12D0000012E,\n        0x12F00000130,\n        0x13100000132,\n        0x13500000136,\n        0x13700000139,\n        0x13A0000013B,\n        0x13C0000013D,\n        0x13E0000013F,\n        0x14200000143,\n        0x14400000145,\n        0x14600000147,\n        0x14800000149,\n        0x14B0000014C,\n        0x14D0000014E,\n        0x14F00000150,\n        0x15100000152,\n        0x15300000154,\n        0x15500000156,\n        0x15700000158,\n        0x1590000015A,\n        0x15B0000015C,\n        0x15D0000015E,\n        0x15F00000160,\n        0x16100000162,\n        0x16300000164,\n        0x16500000166,\n        0x16700000168,\n        0x1690000016A,\n        0x16B0000016C,\n        0x16D0000016E,\n        0x16F00000170,\n        0x17100000172,\n        0x17300000174,\n        0x17500000176,\n        0x17700000178,\n        0x17A0000017B,\n        0x17C0000017D,\n        0x17E0000017F,\n        0x18000000181,\n        0x18300000184,\n        0x18500000186,\n        0x18800000189,\n        0x18C0000018E,\n        0x19200000193,\n        0x19500000196,\n        0x1990000019C,\n        0x19E0000019F,\n        0x1A1000001A2,\n        0x1A3000001A4,\n        0x1A5000001A6,\n        0x1A8000001A9,\n        0x1AA000001AC,\n        0x1AD000001AE,\n        0x1B0000001B1,\n        0x1B4000001B5,\n        0x1B6000001B7,\n        0x1B9000001BC,\n        0x1BD000001C4,\n        0x1CE000001CF,\n        0x1D0000001D1,\n        0x1D2000001D3,\n        0x1D4000001D5,\n        0x1D6000001D7,\n        0x1D8000001D9,\n        0x1DA000001DB,\n        0x1DC000001DE,\n        0x1DF000001E0,\n        0x1E1000001E2,\n        0x1E3000001E4,\n        0x1E5000001E6,\n        0x1E7000001E8,\n        0x1E9000001EA,\n        0x1EB000001EC,\n        0x1ED000001EE,\n        0x1EF000001F1,\n        0x1F5000001F6,\n        0x1F9000001FA,\n        0x1FB000001FC,\n        0x1FD000001FE,\n        0x1FF00000200,\n        0x20100000202,\n        0x20300000204,\n        0x20500000206,\n        0x20700000208,\n        0x2090000020A,\n        0x20B0000020C,\n        0x20D0000020E,\n        0x20F00000210,\n        0x21100000212,\n        0x21300000214,\n        0x21500000216,\n        0x21700000218,\n        0x2190000021A,\n        0x21B0000021C,\n        0x21D0000021E,\n        0x21F00000220,\n        0x22100000222,\n        0x22300000224,\n        0x22500000226,\n        0x22700000228,\n        0x2290000022A,\n        0x22B0000022C,\n        0x22D0000022E,\n        0x22F00000230,\n        0x23100000232,\n        0x2330000023A,\n        0x23C0000023D,\n        0x23F00000241,\n        0x24200000243,\n        0x24700000248,\n        0x2490000024A,\n        0x24B0000024C,\n        0x24D0000024E,\n        0x24F000002B0,\n        0x2B9000002C2,\n        0x2C6000002D2,\n        0x2EC000002ED,\n        0x2EE000002EF,\n        0x30000000340,\n        0x34200000343,\n        0x3460000034F,\n        0x35000000370,\n        0x37100000372,\n        0x37300000374,\n        0x37700000378,\n        0x37B0000037E,\n        0x39000000391,\n        0x3AC000003CF,\n        0x3D7000003D8,\n        0x3D9000003DA,\n        0x3DB000003DC,\n        0x3DD000003DE,\n        0x3DF000003E0,\n        0x3E1000003E2,\n        0x3E3000003E4,\n        0x3E5000003E6,\n        0x3E7000003E8,\n        0x3E9000003EA,\n        0x3EB000003EC,\n        0x3ED000003EE,\n        0x3EF000003F0,\n        0x3F3000003F4,\n        0x3F8000003F9,\n        0x3FB000003FD,\n        0x43000000460,\n        0x46100000462,\n        0x46300000464,\n        0x46500000466,\n        0x46700000468,\n        0x4690000046A,\n        0x46B0000046C,\n        0x46D0000046E,\n        0x46F00000470,\n        0x47100000472,\n        0x47300000474,\n        0x47500000476,\n        0x47700000478,\n        0x4790000047A,\n        0x47B0000047C,\n        0x47D0000047E,\n        0x47F00000480,\n        0x48100000482,\n        0x48300000488,\n        0x48B0000048C,\n        0x48D0000048E,\n        0x48F00000490,\n        0x49100000492,\n        0x49300000494,\n        0x49500000496,\n        0x49700000498,\n        0x4990000049A,\n        0x49B0000049C,\n        0x49D0000049E,\n        0x49F000004A0,\n        0x4A1000004A2,\n        0x4A3000004A4,\n        0x4A5000004A6,\n        0x4A7000004A8,\n        0x4A9000004AA,\n        0x4AB000004AC,\n        0x4AD000004AE,\n        0x4AF000004B0,\n        0x4B1000004B2,\n        0x4B3000004B4,\n        0x4B5000004B6,\n        0x4B7000004B8,\n        0x4B9000004BA,\n        0x4BB000004BC,\n        0x4BD000004BE,\n        0x4BF000004C0,\n        0x4C2000004C3,\n        0x4C4000004C5,\n        0x4C6000004C7,\n        0x4C8000004C9,\n        0x4CA000004CB,\n        0x4CC000004CD,\n        0x4CE000004D0,\n        0x4D1000004D2,\n        0x4D3000004D4,\n        0x4D5000004D6,\n        0x4D7000004D8,\n        0x4D9000004DA,\n        0x4DB000004DC,\n        0x4DD000004DE,\n        0x4DF000004E0,\n        0x4E1000004E2,\n        0x4E3000004E4,\n        0x4E5000004E6,\n        0x4E7000004E8,\n        0x4E9000004EA,\n        0x4EB000004EC,\n        0x4ED000004EE,\n        0x4EF000004F0,\n        0x4F1000004F2,\n        0x4F3000004F4,\n        0x4F5000004F6,\n        0x4F7000004F8,\n        0x4F9000004FA,\n        0x4FB000004FC,\n        0x4FD000004FE,\n        0x4FF00000500,\n        0x50100000502,\n        0x50300000504,\n        0x50500000506,\n        0x50700000508,\n        0x5090000050A,\n        0x50B0000050C,\n        0x50D0000050E,\n        0x50F00000510,\n        0x51100000512,\n        0x51300000514,\n        0x51500000516,\n        0x51700000518,\n        0x5190000051A,\n        0x51B0000051C,\n        0x51D0000051E,\n        0x51F00000520,\n        0x52100000522,\n        0x52300000524,\n        0x52500000526,\n        0x52700000528,\n        0x5290000052A,\n        0x52B0000052C,\n        0x52D0000052E,\n        0x52F00000530,\n        0x5590000055A,\n        0x56000000587,\n        0x58800000589,\n        0x591000005BE,\n        0x5BF000005C0,\n        0x5C1000005C3,\n        0x5C4000005C6,\n        0x5C7000005C8,\n        0x5D0000005EB,\n        0x5EF000005F3,\n        0x6100000061B,\n        0x62000000640,\n        0x64100000660,\n        0x66E00000675,\n        0x679000006D4,\n        0x6D5000006DD,\n        0x6DF000006E9,\n        0x6EA000006F0,\n        0x6FA00000700,\n        0x7100000074B,\n        0x74D000007B2,\n        0x7C0000007F6,\n        0x7FD000007FE,\n        0x8000000082E,\n        0x8400000085C,\n        0x8600000086B,\n        0x87000000888,\n        0x8890000088F,\n        0x898000008E2,\n        0x8E300000958,\n        0x96000000964,\n        0x96600000970,\n        0x97100000984,\n        0x9850000098D,\n        0x98F00000991,\n        0x993000009A9,\n        0x9AA000009B1,\n        0x9B2000009B3,\n        0x9B6000009BA,\n        0x9BC000009C5,\n        0x9C7000009C9,\n        0x9CB000009CF,\n        0x9D7000009D8,\n        0x9E0000009E4,\n        0x9E6000009F2,\n        0x9FC000009FD,\n        0x9FE000009FF,\n        0xA0100000A04,\n        0xA0500000A0B,\n        0xA0F00000A11,\n        0xA1300000A29,\n        0xA2A00000A31,\n        0xA3200000A33,\n        0xA3500000A36,\n        0xA3800000A3A,\n        0xA3C00000A3D,\n        0xA3E00000A43,\n        0xA4700000A49,\n        0xA4B00000A4E,\n        0xA5100000A52,\n        0xA5C00000A5D,\n        0xA6600000A76,\n        0xA8100000A84,\n        0xA8500000A8E,\n        0xA8F00000A92,\n        0xA9300000AA9,\n        0xAAA00000AB1,\n        0xAB200000AB4,\n        0xAB500000ABA,\n        0xABC00000AC6,\n        0xAC700000ACA,\n        0xACB00000ACE,\n        0xAD000000AD1,\n        0xAE000000AE4,\n        0xAE600000AF0,\n        0xAF900000B00,\n        0xB0100000B04,\n        0xB0500000B0D,\n        0xB0F00000B11,\n        0xB1300000B29,\n        0xB2A00000B31,\n        0xB3200000B34,\n        0xB3500000B3A,\n        0xB3C00000B45,\n        0xB4700000B49,\n        0xB4B00000B4E,\n        0xB5500000B58,\n        0xB5F00000B64,\n        0xB6600000B70,\n        0xB7100000B72,\n        0xB8200000B84,\n        0xB8500000B8B,\n        0xB8E00000B91,\n        0xB9200000B96,\n        0xB9900000B9B,\n        0xB9C00000B9D,\n        0xB9E00000BA0,\n        0xBA300000BA5,\n        0xBA800000BAB,\n        0xBAE00000BBA,\n        0xBBE00000BC3,\n        0xBC600000BC9,\n        0xBCA00000BCE,\n        0xBD000000BD1,\n        0xBD700000BD8,\n        0xBE600000BF0,\n        0xC0000000C0D,\n        0xC0E00000C11,\n        0xC1200000C29,\n        0xC2A00000C3A,\n        0xC3C00000C45,\n        0xC4600000C49,\n        0xC4A00000C4E,\n        0xC5500000C57,\n        0xC5800000C5B,\n        0xC5D00000C5E,\n        0xC6000000C64,\n        0xC6600000C70,\n        0xC8000000C84,\n        0xC8500000C8D,\n        0xC8E00000C91,\n        0xC9200000CA9,\n        0xCAA00000CB4,\n        0xCB500000CBA,\n        0xCBC00000CC5,\n        0xCC600000CC9,\n        0xCCA00000CCE,\n        0xCD500000CD7,\n        0xCDD00000CDF,\n        0xCE000000CE4,\n        0xCE600000CF0,\n        0xCF100000CF4,\n        0xD0000000D0D,\n        0xD0E00000D11,\n        0xD1200000D45,\n        0xD4600000D49,\n        0xD4A00000D4F,\n        0xD5400000D58,\n        0xD5F00000D64,\n        0xD6600000D70,\n        0xD7A00000D80,\n        0xD8100000D84,\n        0xD8500000D97,\n        0xD9A00000DB2,\n        0xDB300000DBC,\n        0xDBD00000DBE,\n        0xDC000000DC7,\n        0xDCA00000DCB,\n        0xDCF00000DD5,\n        0xDD600000DD7,\n        0xDD800000DE0,\n        0xDE600000DF0,\n        0xDF200000DF4,\n        0xE0100000E33,\n        0xE3400000E3B,\n        0xE4000000E4F,\n        0xE5000000E5A,\n        0xE8100000E83,\n        0xE8400000E85,\n        0xE8600000E8B,\n        0xE8C00000EA4,\n        0xEA500000EA6,\n        0xEA700000EB3,\n        0xEB400000EBE,\n        0xEC000000EC5,\n        0xEC600000EC7,\n        0xEC800000ECF,\n        0xED000000EDA,\n        0xEDE00000EE0,\n        0xF0000000F01,\n        0xF0B00000F0C,\n        0xF1800000F1A,\n        0xF2000000F2A,\n        0xF3500000F36,\n        0xF3700000F38,\n        0xF3900000F3A,\n        0xF3E00000F43,\n        0xF4400000F48,\n        0xF4900000F4D,\n        0xF4E00000F52,\n        0xF5300000F57,\n        0xF5800000F5C,\n        0xF5D00000F69,\n        0xF6A00000F6D,\n        0xF7100000F73,\n        0xF7400000F75,\n        0xF7A00000F81,\n        0xF8200000F85,\n        0xF8600000F93,\n        0xF9400000F98,\n        0xF9900000F9D,\n        0xF9E00000FA2,\n        0xFA300000FA7,\n        0xFA800000FAC,\n        0xFAD00000FB9,\n        0xFBA00000FBD,\n        0xFC600000FC7,\n        0x10000000104A,\n        0x10500000109E,\n        0x10D0000010FB,\n        0x10FD00001100,\n        0x120000001249,\n        0x124A0000124E,\n        0x125000001257,\n        0x125800001259,\n        0x125A0000125E,\n        0x126000001289,\n        0x128A0000128E,\n        0x1290000012B1,\n        0x12B2000012B6,\n        0x12B8000012BF,\n        0x12C0000012C1,\n        0x12C2000012C6,\n        0x12C8000012D7,\n        0x12D800001311,\n        0x131200001316,\n        0x13180000135B,\n        0x135D00001360,\n        0x138000001390,\n        0x13A0000013F6,\n        0x14010000166D,\n        0x166F00001680,\n        0x16810000169B,\n        0x16A0000016EB,\n        0x16F1000016F9,\n        0x170000001716,\n        0x171F00001735,\n        0x174000001754,\n        0x17600000176D,\n        0x176E00001771,\n        0x177200001774,\n        0x1780000017B4,\n        0x17B6000017D4,\n        0x17D7000017D8,\n        0x17DC000017DE,\n        0x17E0000017EA,\n        0x18100000181A,\n        0x182000001879,\n        0x1880000018AB,\n        0x18B0000018F6,\n        0x19000000191F,\n        0x19200000192C,\n        0x19300000193C,\n        0x19460000196E,\n        0x197000001975,\n        0x1980000019AC,\n        0x19B0000019CA,\n        0x19D0000019DA,\n        0x1A0000001A1C,\n        0x1A2000001A5F,\n        0x1A6000001A7D,\n        0x1A7F00001A8A,\n        0x1A9000001A9A,\n        0x1AA700001AA8,\n        0x1AB000001ABE,\n        0x1ABF00001ACF,\n        0x1B0000001B4D,\n        0x1B5000001B5A,\n        0x1B6B00001B74,\n        0x1B8000001BF4,\n        0x1C0000001C38,\n        0x1C4000001C4A,\n        0x1C4D00001C7E,\n        0x1CD000001CD3,\n        0x1CD400001CFB,\n        0x1D0000001D2C,\n        0x1D2F00001D30,\n        0x1D3B00001D3C,\n        0x1D4E00001D4F,\n        0x1D6B00001D78,\n        0x1D7900001D9B,\n        0x1DC000001E00,\n        0x1E0100001E02,\n        0x1E0300001E04,\n        0x1E0500001E06,\n        0x1E0700001E08,\n        0x1E0900001E0A,\n        0x1E0B00001E0C,\n        0x1E0D00001E0E,\n        0x1E0F00001E10,\n        0x1E1100001E12,\n        0x1E1300001E14,\n        0x1E1500001E16,\n        0x1E1700001E18,\n        0x1E1900001E1A,\n        0x1E1B00001E1C,\n        0x1E1D00001E1E,\n        0x1E1F00001E20,\n        0x1E2100001E22,\n        0x1E2300001E24,\n        0x1E2500001E26,\n        0x1E2700001E28,\n        0x1E2900001E2A,\n        0x1E2B00001E2C,\n        0x1E2D00001E2E,\n        0x1E2F00001E30,\n        0x1E3100001E32,\n        0x1E3300001E34,\n        0x1E3500001E36,\n        0x1E3700001E38,\n        0x1E3900001E3A,\n        0x1E3B00001E3C,\n        0x1E3D00001E3E,\n        0x1E3F00001E40,\n        0x1E4100001E42,\n        0x1E4300001E44,\n        0x1E4500001E46,\n        0x1E4700001E48,\n        0x1E4900001E4A,\n        0x1E4B00001E4C,\n        0x1E4D00001E4E,\n        0x1E4F00001E50,\n        0x1E5100001E52,\n        0x1E5300001E54,\n        0x1E5500001E56,\n        0x1E5700001E58,\n        0x1E5900001E5A,\n        0x1E5B00001E5C,\n        0x1E5D00001E5E,\n        0x1E5F00001E60,\n        0x1E6100001E62,\n        0x1E6300001E64,\n        0x1E6500001E66,\n        0x1E6700001E68,\n        0x1E6900001E6A,\n        0x1E6B00001E6C,\n        0x1E6D00001E6E,\n        0x1E6F00001E70,\n        0x1E7100001E72,\n        0x1E7300001E74,\n        0x1E7500001E76,\n        0x1E7700001E78,\n        0x1E7900001E7A,\n        0x1E7B00001E7C,\n        0x1E7D00001E7E,\n        0x1E7F00001E80,\n        0x1E8100001E82,\n        0x1E8300001E84,\n        0x1E8500001E86,\n        0x1E8700001E88,\n        0x1E8900001E8A,\n        0x1E8B00001E8C,\n        0x1E8D00001E8E,\n        0x1E8F00001E90,\n        0x1E9100001E92,\n        0x1E9300001E94,\n        0x1E9500001E9A,\n        0x1E9C00001E9E,\n        0x1E9F00001EA0,\n        0x1EA100001EA2,\n        0x1EA300001EA4,\n        0x1EA500001EA6,\n        0x1EA700001EA8,\n        0x1EA900001EAA,\n        0x1EAB00001EAC,\n        0x1EAD00001EAE,\n        0x1EAF00001EB0,\n        0x1EB100001EB2,\n        0x1EB300001EB4,\n        0x1EB500001EB6,\n        0x1EB700001EB8,\n        0x1EB900001EBA,\n        0x1EBB00001EBC,\n        0x1EBD00001EBE,\n        0x1EBF00001EC0,\n        0x1EC100001EC2,\n        0x1EC300001EC4,\n        0x1EC500001EC6,\n        0x1EC700001EC8,\n        0x1EC900001ECA,\n        0x1ECB00001ECC,\n        0x1ECD00001ECE,\n        0x1ECF00001ED0,\n        0x1ED100001ED2,\n        0x1ED300001ED4,\n        0x1ED500001ED6,\n        0x1ED700001ED8,\n        0x1ED900001EDA,\n        0x1EDB00001EDC,\n        0x1EDD00001EDE,\n        0x1EDF00001EE0,\n        0x1EE100001EE2,\n        0x1EE300001EE4,\n        0x1EE500001EE6,\n        0x1EE700001EE8,\n        0x1EE900001EEA,\n        0x1EEB00001EEC,\n        0x1EED00001EEE,\n        0x1EEF00001EF0,\n        0x1EF100001EF2,\n        0x1EF300001EF4,\n        0x1EF500001EF6,\n        0x1EF700001EF8,\n        0x1EF900001EFA,\n        0x1EFB00001EFC,\n        0x1EFD00001EFE,\n        0x1EFF00001F08,\n        0x1F1000001F16,\n        0x1F2000001F28,\n        0x1F3000001F38,\n        0x1F4000001F46,\n        0x1F5000001F58,\n        0x1F6000001F68,\n        0x1F7000001F71,\n        0x1F7200001F73,\n        0x1F7400001F75,\n        0x1F7600001F77,\n        0x1F7800001F79,\n        0x1F7A00001F7B,\n        0x1F7C00001F7D,\n        0x1FB000001FB2,\n        0x1FB600001FB7,\n        0x1FC600001FC7,\n        0x1FD000001FD3,\n        0x1FD600001FD8,\n        0x1FE000001FE3,\n        0x1FE400001FE8,\n        0x1FF600001FF7,\n        0x214E0000214F,\n        0x218400002185,\n        0x2C3000002C60,\n        0x2C6100002C62,\n        0x2C6500002C67,\n        0x2C6800002C69,\n        0x2C6A00002C6B,\n        0x2C6C00002C6D,\n        0x2C7100002C72,\n        0x2C7300002C75,\n        0x2C7600002C7C,\n        0x2C8100002C82,\n        0x2C8300002C84,\n        0x2C8500002C86,\n        0x2C8700002C88,\n        0x2C8900002C8A,\n        0x2C8B00002C8C,\n        0x2C8D00002C8E,\n        0x2C8F00002C90,\n        0x2C9100002C92,\n        0x2C9300002C94,\n        0x2C9500002C96,\n        0x2C9700002C98,\n        0x2C9900002C9A,\n        0x2C9B00002C9C,\n        0x2C9D00002C9E,\n        0x2C9F00002CA0,\n        0x2CA100002CA2,\n        0x2CA300002CA4,\n        0x2CA500002CA6,\n        0x2CA700002CA8,\n        0x2CA900002CAA,\n        0x2CAB00002CAC,\n        0x2CAD00002CAE,\n        0x2CAF00002CB0,\n        0x2CB100002CB2,\n        0x2CB300002CB4,\n        0x2CB500002CB6,\n        0x2CB700002CB8,\n        0x2CB900002CBA,\n        0x2CBB00002CBC,\n        0x2CBD00002CBE,\n        0x2CBF00002CC0,\n        0x2CC100002CC2,\n        0x2CC300002CC4,\n        0x2CC500002CC6,\n        0x2CC700002CC8,\n        0x2CC900002CCA,\n        0x2CCB00002CCC,\n        0x2CCD00002CCE,\n        0x2CCF00002CD0,\n        0x2CD100002CD2,\n        0x2CD300002CD4,\n        0x2CD500002CD6,\n        0x2CD700002CD8,\n        0x2CD900002CDA,\n        0x2CDB00002CDC,\n        0x2CDD00002CDE,\n        0x2CDF00002CE0,\n        0x2CE100002CE2,\n        0x2CE300002CE5,\n        0x2CEC00002CED,\n        0x2CEE00002CF2,\n        0x2CF300002CF4,\n        0x2D0000002D26,\n        0x2D2700002D28,\n        0x2D2D00002D2E,\n        0x2D3000002D68,\n        0x2D7F00002D97,\n        0x2DA000002DA7,\n        0x2DA800002DAF,\n        0x2DB000002DB7,\n        0x2DB800002DBF,\n        0x2DC000002DC7,\n        0x2DC800002DCF,\n        0x2DD000002DD7,\n        0x2DD800002DDF,\n        0x2DE000002E00,\n        0x2E2F00002E30,\n        0x300500003008,\n        0x302A0000302E,\n        0x303C0000303D,\n        0x304100003097,\n        0x30990000309B,\n        0x309D0000309F,\n        0x30A1000030FB,\n        0x30FC000030FF,\n        0x310500003130,\n        0x31A0000031C0,\n        0x31F000003200,\n        0x340000004DC0,\n        0x4E000000A48D,\n        0xA4D00000A4FE,\n        0xA5000000A60D,\n        0xA6100000A62C,\n        0xA6410000A642,\n        0xA6430000A644,\n        0xA6450000A646,\n        0xA6470000A648,\n        0xA6490000A64A,\n        0xA64B0000A64C,\n        0xA64D0000A64E,\n        0xA64F0000A650,\n        0xA6510000A652,\n        0xA6530000A654,\n        0xA6550000A656,\n        0xA6570000A658,\n        0xA6590000A65A,\n        0xA65B0000A65C,\n        0xA65D0000A65E,\n        0xA65F0000A660,\n        0xA6610000A662,\n        0xA6630000A664,\n        0xA6650000A666,\n        0xA6670000A668,\n        0xA6690000A66A,\n        0xA66B0000A66C,\n        0xA66D0000A670,\n        0xA6740000A67E,\n        0xA67F0000A680,\n        0xA6810000A682,\n        0xA6830000A684,\n        0xA6850000A686,\n        0xA6870000A688,\n        0xA6890000A68A,\n        0xA68B0000A68C,\n        0xA68D0000A68E,\n        0xA68F0000A690,\n        0xA6910000A692,\n        0xA6930000A694,\n        0xA6950000A696,\n        0xA6970000A698,\n        0xA6990000A69A,\n        0xA69B0000A69C,\n        0xA69E0000A6E6,\n        0xA6F00000A6F2,\n        0xA7170000A720,\n        0xA7230000A724,\n        0xA7250000A726,\n        0xA7270000A728,\n        0xA7290000A72A,\n        0xA72B0000A72C,\n        0xA72D0000A72E,\n        0xA72F0000A732,\n        0xA7330000A734,\n        0xA7350000A736,\n        0xA7370000A738,\n        0xA7390000A73A,\n        0xA73B0000A73C,\n        0xA73D0000A73E,\n        0xA73F0000A740,\n        0xA7410000A742,\n        0xA7430000A744,\n        0xA7450000A746,\n        0xA7470000A748,\n        0xA7490000A74A,\n        0xA74B0000A74C,\n        0xA74D0000A74E,\n        0xA74F0000A750,\n        0xA7510000A752,\n        0xA7530000A754,\n        0xA7550000A756,\n        0xA7570000A758,\n        0xA7590000A75A,\n        0xA75B0000A75C,\n        0xA75D0000A75E,\n        0xA75F0000A760,\n        0xA7610000A762,\n        0xA7630000A764,\n        0xA7650000A766,\n        0xA7670000A768,\n        0xA7690000A76A,\n        0xA76B0000A76C,\n        0xA76D0000A76E,\n        0xA76F0000A770,\n        0xA7710000A779,\n        0xA77A0000A77B,\n        0xA77C0000A77D,\n        0xA77F0000A780,\n        0xA7810000A782,\n        0xA7830000A784,\n        0xA7850000A786,\n        0xA7870000A789,\n        0xA78C0000A78D,\n        0xA78E0000A790,\n        0xA7910000A792,\n        0xA7930000A796,\n        0xA7970000A798,\n        0xA7990000A79A,\n        0xA79B0000A79C,\n        0xA79D0000A79E,\n        0xA79F0000A7A0,\n        0xA7A10000A7A2,\n        0xA7A30000A7A4,\n        0xA7A50000A7A6,\n        0xA7A70000A7A8,\n        0xA7A90000A7AA,\n        0xA7AF0000A7B0,\n        0xA7B50000A7B6,\n        0xA7B70000A7B8,\n        0xA7B90000A7BA,\n        0xA7BB0000A7BC,\n        0xA7BD0000A7BE,\n        0xA7BF0000A7C0,\n        0xA7C10000A7C2,\n        0xA7C30000A7C4,\n        0xA7C80000A7C9,\n        0xA7CA0000A7CB,\n        0xA7D10000A7D2,\n        0xA7D30000A7D4,\n        0xA7D50000A7D6,\n        0xA7D70000A7D8,\n        0xA7D90000A7DA,\n        0xA7F60000A7F8,\n        0xA7FA0000A828,\n        0xA82C0000A82D,\n        0xA8400000A874,\n        0xA8800000A8C6,\n        0xA8D00000A8DA,\n        0xA8E00000A8F8,\n        0xA8FB0000A8FC,\n        0xA8FD0000A92E,\n        0xA9300000A954,\n        0xA9800000A9C1,\n        0xA9CF0000A9DA,\n        0xA9E00000A9FF,\n        0xAA000000AA37,\n        0xAA400000AA4E,\n        0xAA500000AA5A,\n        0xAA600000AA77,\n        0xAA7A0000AAC3,\n        0xAADB0000AADE,\n        0xAAE00000AAF0,\n        0xAAF20000AAF7,\n        0xAB010000AB07,\n        0xAB090000AB0F,\n        0xAB110000AB17,\n        0xAB200000AB27,\n        0xAB280000AB2F,\n        0xAB300000AB5B,\n        0xAB600000AB69,\n        0xABC00000ABEB,\n        0xABEC0000ABEE,\n        0xABF00000ABFA,\n        0xAC000000D7A4,\n        0xFA0E0000FA10,\n        0xFA110000FA12,\n        0xFA130000FA15,\n        0xFA1F0000FA20,\n        0xFA210000FA22,\n        0xFA230000FA25,\n        0xFA270000FA2A,\n        0xFB1E0000FB1F,\n        0xFE200000FE30,\n        0xFE730000FE74,\n        0x100000001000C,\n        0x1000D00010027,\n        0x100280001003B,\n        0x1003C0001003E,\n        0x1003F0001004E,\n        0x100500001005E,\n        0x10080000100FB,\n        0x101FD000101FE,\n        0x102800001029D,\n        0x102A0000102D1,\n        0x102E0000102E1,\n        0x1030000010320,\n        0x1032D00010341,\n        0x103420001034A,\n        0x103500001037B,\n        0x103800001039E,\n        0x103A0000103C4,\n        0x103C8000103D0,\n        0x104280001049E,\n        0x104A0000104AA,\n        0x104D8000104FC,\n        0x1050000010528,\n        0x1053000010564,\n        0x10597000105A2,\n        0x105A3000105B2,\n        0x105B3000105BA,\n        0x105BB000105BD,\n        0x1060000010737,\n        0x1074000010756,\n        0x1076000010768,\n        0x1078000010781,\n        0x1080000010806,\n        0x1080800010809,\n        0x1080A00010836,\n        0x1083700010839,\n        0x1083C0001083D,\n        0x1083F00010856,\n        0x1086000010877,\n        0x108800001089F,\n        0x108E0000108F3,\n        0x108F4000108F6,\n        0x1090000010916,\n        0x109200001093A,\n        0x10980000109B8,\n        0x109BE000109C0,\n        0x10A0000010A04,\n        0x10A0500010A07,\n        0x10A0C00010A14,\n        0x10A1500010A18,\n        0x10A1900010A36,\n        0x10A3800010A3B,\n        0x10A3F00010A40,\n        0x10A6000010A7D,\n        0x10A8000010A9D,\n        0x10AC000010AC8,\n        0x10AC900010AE7,\n        0x10B0000010B36,\n        0x10B4000010B56,\n        0x10B6000010B73,\n        0x10B8000010B92,\n        0x10C0000010C49,\n        0x10CC000010CF3,\n        0x10D0000010D28,\n        0x10D3000010D3A,\n        0x10E8000010EAA,\n        0x10EAB00010EAD,\n        0x10EB000010EB2,\n        0x10EFD00010F1D,\n        0x10F2700010F28,\n        0x10F3000010F51,\n        0x10F7000010F86,\n        0x10FB000010FC5,\n        0x10FE000010FF7,\n        0x1100000011047,\n        0x1106600011076,\n        0x1107F000110BB,\n        0x110C2000110C3,\n        0x110D0000110E9,\n        0x110F0000110FA,\n        0x1110000011135,\n        0x1113600011140,\n        0x1114400011148,\n        0x1115000011174,\n        0x1117600011177,\n        0x11180000111C5,\n        0x111C9000111CD,\n        0x111CE000111DB,\n        0x111DC000111DD,\n        0x1120000011212,\n        0x1121300011238,\n        0x1123E00011242,\n        0x1128000011287,\n        0x1128800011289,\n        0x1128A0001128E,\n        0x1128F0001129E,\n        0x1129F000112A9,\n        0x112B0000112EB,\n        0x112F0000112FA,\n        0x1130000011304,\n        0x113050001130D,\n        0x1130F00011311,\n        0x1131300011329,\n        0x1132A00011331,\n        0x1133200011334,\n        0x113350001133A,\n        0x1133B00011345,\n        0x1134700011349,\n        0x1134B0001134E,\n        0x1135000011351,\n        0x1135700011358,\n        0x1135D00011364,\n        0x113660001136D,\n        0x1137000011375,\n        0x114000001144B,\n        0x114500001145A,\n        0x1145E00011462,\n        0x11480000114C6,\n        0x114C7000114C8,\n        0x114D0000114DA,\n        0x11580000115B6,\n        0x115B8000115C1,\n        0x115D8000115DE,\n        0x1160000011641,\n        0x1164400011645,\n        0x116500001165A,\n        0x11680000116B9,\n        0x116C0000116CA,\n        0x117000001171B,\n        0x1171D0001172C,\n        0x117300001173A,\n        0x1174000011747,\n        0x118000001183B,\n        0x118C0000118EA,\n        0x118FF00011907,\n        0x119090001190A,\n        0x1190C00011914,\n        0x1191500011917,\n        0x1191800011936,\n        0x1193700011939,\n        0x1193B00011944,\n        0x119500001195A,\n        0x119A0000119A8,\n        0x119AA000119D8,\n        0x119DA000119E2,\n        0x119E3000119E5,\n        0x11A0000011A3F,\n        0x11A4700011A48,\n        0x11A5000011A9A,\n        0x11A9D00011A9E,\n        0x11AB000011AF9,\n        0x11C0000011C09,\n        0x11C0A00011C37,\n        0x11C3800011C41,\n        0x11C5000011C5A,\n        0x11C7200011C90,\n        0x11C9200011CA8,\n        0x11CA900011CB7,\n        0x11D0000011D07,\n        0x11D0800011D0A,\n        0x11D0B00011D37,\n        0x11D3A00011D3B,\n        0x11D3C00011D3E,\n        0x11D3F00011D48,\n        0x11D5000011D5A,\n        0x11D6000011D66,\n        0x11D6700011D69,\n        0x11D6A00011D8F,\n        0x11D9000011D92,\n        0x11D9300011D99,\n        0x11DA000011DAA,\n        0x11EE000011EF7,\n        0x11F0000011F11,\n        0x11F1200011F3B,\n        0x11F3E00011F43,\n        0x11F5000011F5A,\n        0x11FB000011FB1,\n        0x120000001239A,\n        0x1248000012544,\n        0x12F9000012FF1,\n        0x1300000013430,\n        0x1344000013456,\n        0x1440000014647,\n        0x1680000016A39,\n        0x16A4000016A5F,\n        0x16A6000016A6A,\n        0x16A7000016ABF,\n        0x16AC000016ACA,\n        0x16AD000016AEE,\n        0x16AF000016AF5,\n        0x16B0000016B37,\n        0x16B4000016B44,\n        0x16B5000016B5A,\n        0x16B6300016B78,\n        0x16B7D00016B90,\n        0x16E6000016E80,\n        0x16F0000016F4B,\n        0x16F4F00016F88,\n        0x16F8F00016FA0,\n        0x16FE000016FE2,\n        0x16FE300016FE5,\n        0x16FF000016FF2,\n        0x17000000187F8,\n        0x1880000018CD6,\n        0x18D0000018D09,\n        0x1AFF00001AFF4,\n        0x1AFF50001AFFC,\n        0x1AFFD0001AFFF,\n        0x1B0000001B123,\n        0x1B1320001B133,\n        0x1B1500001B153,\n        0x1B1550001B156,\n        0x1B1640001B168,\n        0x1B1700001B2FC,\n        0x1BC000001BC6B,\n        0x1BC700001BC7D,\n        0x1BC800001BC89,\n        0x1BC900001BC9A,\n        0x1BC9D0001BC9F,\n        0x1CF000001CF2E,\n        0x1CF300001CF47,\n        0x1DA000001DA37,\n        0x1DA3B0001DA6D,\n        0x1DA750001DA76,\n        0x1DA840001DA85,\n        0x1DA9B0001DAA0,\n        0x1DAA10001DAB0,\n        0x1DF000001DF1F,\n        0x1DF250001DF2B,\n        0x1E0000001E007,\n        0x1E0080001E019,\n        0x1E01B0001E022,\n        0x1E0230001E025,\n        0x1E0260001E02B,\n        0x1E08F0001E090,\n        0x1E1000001E12D,\n        0x1E1300001E13E,\n        0x1E1400001E14A,\n        0x1E14E0001E14F,\n        0x1E2900001E2AF,\n        0x1E2C00001E2FA,\n        0x1E4D00001E4FA,\n        0x1E7E00001E7E7,\n        0x1E7E80001E7EC,\n        0x1E7ED0001E7EF,\n        0x1E7F00001E7FF,\n        0x1E8000001E8C5,\n        0x1E8D00001E8D7,\n        0x1E9220001E94C,\n        0x1E9500001E95A,\n        0x200000002A6E0,\n        0x2A7000002B73A,\n        0x2B7400002B81E,\n        0x2B8200002CEA2,\n        0x2CEB00002EBE1,\n        0x2EBF00002EE5E,\n        0x300000003134B,\n        0x31350000323B0,\n    ),\n    \"CONTEXTJ\": (0x200C0000200E,),\n    \"CONTEXTO\": (\n        0xB7000000B8,\n        0x37500000376,\n        0x5F3000005F5,\n        0x6600000066A,\n        0x6F0000006FA,\n        0x30FB000030FC,\n    ),\n}\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/idna/intranges.py","size":1898,"sha1":"6eaa004ade4ee81378c86cec87646dff617be72f","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nGiven a list of integers, made up of (hopefully) a small number of long runs\nof consecutive integers, compute a representation of the form\n((start1, end1), (start2, end2) ...). Then answer the question \"was x present\nin the original list?\" in time O(log(# runs)).\n\"\"\"\n\nimport bisect\nfrom typing import List, Tuple\n\n\ndef intranges_from_list(list_: List[int]) -> Tuple[int, ...]:\n    \"\"\"Represent a list of integers as a sequence of ranges:\n    ((start_0, end_0), (start_1, end_1), ...), such that the original\n    integers are exactly those x such that start_i <= x < end_i for some i.\n\n    Ranges are encoded as single integers (start << 32 | end), not as tuples.\n    \"\"\"\n\n    sorted_list = sorted(list_)\n    ranges = []\n    last_write = -1\n    for i in range(len(sorted_list)):\n        if i + 1 < len(sorted_list):\n            if sorted_list[i] == sorted_list[i + 1] - 1:\n                continue\n        current_range = sorted_list[last_write + 1 : i + 1]\n        ranges.append(_encode_range(current_range[0], current_range[-1] + 1))\n        last_write = i\n\n    return tuple(ranges)\n\n\ndef _encode_range(start: int, end: int) -> int:\n    return (start << 32) | end\n\n\ndef _decode_range(r: int) -> Tuple[int, int]:\n    return (r >> 32), (r & ((1 << 32) - 1))\n\n\ndef intranges_contain(int_: int, ranges: Tuple[int, ...]) -> bool:\n    \"\"\"Determine if `int_` falls into one of the ranges in `ranges`.\"\"\"\n    tuple_ = _encode_range(int_, 0)\n    pos = bisect.bisect_left(ranges, tuple_)\n    # we could be immediately ahead of a tuple (start, end)\n    # with start < int_ <= end\n    if pos > 0:\n        left, right = _decode_range(ranges[pos - 1])\n        if left <= int_ < right:\n            return True\n    # or we could be immediately behind a tuple (int_, end)\n    if pos < len(ranges):\n        left, _ = _decode_range(ranges[pos])\n        if left == int_:\n            return True\n    return False\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/idna/package_data.py","size":21,"sha1":"fb51b9874f7a47010ae7d4182681525711373289","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"__version__ = \"3.10\"\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/idna/uts46data.py","size":239289,"sha1":"1656dbb17e984dacbeeed911cab91afdf442ecd1","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is automatically generated by tools/idna-data\n# vim: set fileencoding=utf-8 :\n\nfrom typing import List, Tuple, Union\n\n\"\"\"IDNA Mapping Table from UTS46.\"\"\"\n\n\n__version__ = \"15.1.0\"\n\n\ndef _seg_0() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x0, \"3\"),\n        (0x1, \"3\"),\n        (0x2, \"3\"),\n        (0x3, \"3\"),\n        (0x4, \"3\"),\n        (0x5, \"3\"),\n        (0x6, \"3\"),\n        (0x7, \"3\"),\n        (0x8, \"3\"),\n        (0x9, \"3\"),\n        (0xA, \"3\"),\n        (0xB, \"3\"),\n        (0xC, \"3\"),\n        (0xD, \"3\"),\n        (0xE, \"3\"),\n        (0xF, \"3\"),\n        (0x10, \"3\"),\n        (0x11, \"3\"),\n        (0x12, \"3\"),\n        (0x13, \"3\"),\n        (0x14, \"3\"),\n        (0x15, \"3\"),\n        (0x16, \"3\"),\n        (0x17, \"3\"),\n        (0x18, \"3\"),\n        (0x19, \"3\"),\n        (0x1A, \"3\"),\n        (0x1B, \"3\"),\n        (0x1C, \"3\"),\n        (0x1D, \"3\"),\n        (0x1E, \"3\"),\n        (0x1F, \"3\"),\n        (0x20, \"3\"),\n        (0x21, \"3\"),\n        (0x22, \"3\"),\n        (0x23, \"3\"),\n        (0x24, \"3\"),\n        (0x25, \"3\"),\n        (0x26, \"3\"),\n        (0x27, \"3\"),\n        (0x28, \"3\"),\n        (0x29, \"3\"),\n        (0x2A, \"3\"),\n        (0x2B, \"3\"),\n        (0x2C, \"3\"),\n        (0x2D, \"V\"),\n        (0x2E, \"V\"),\n        (0x2F, \"3\"),\n        (0x30, \"V\"),\n        (0x31, \"V\"),\n        (0x32, \"V\"),\n        (0x33, \"V\"),\n        (0x34, \"V\"),\n        (0x35, \"V\"),\n        (0x36, \"V\"),\n        (0x37, \"V\"),\n        (0x38, \"V\"),\n        (0x39, \"V\"),\n        (0x3A, \"3\"),\n        (0x3B, \"3\"),\n        (0x3C, \"3\"),\n        (0x3D, \"3\"),\n        (0x3E, \"3\"),\n        (0x3F, \"3\"),\n        (0x40, \"3\"),\n        (0x41, \"M\", \"a\"),\n        (0x42, \"M\", \"b\"),\n        (0x43, \"M\", \"c\"),\n        (0x44, \"M\", \"d\"),\n        (0x45, \"M\", \"e\"),\n        (0x46, \"M\", \"f\"),\n        (0x47, \"M\", \"g\"),\n        (0x48, \"M\", \"h\"),\n        (0x49, \"M\", \"i\"),\n        (0x4A, \"M\", \"j\"),\n        (0x4B, \"M\", \"k\"),\n        (0x4C, \"M\", \"l\"),\n        (0x4D, \"M\", \"m\"),\n        (0x4E, \"M\", \"n\"),\n        (0x4F, \"M\", \"o\"),\n        (0x50, \"M\", \"p\"),\n        (0x51, \"M\", \"q\"),\n        (0x52, \"M\", \"r\"),\n        (0x53, \"M\", \"s\"),\n        (0x54, \"M\", \"t\"),\n        (0x55, \"M\", \"u\"),\n        (0x56, \"M\", \"v\"),\n        (0x57, \"M\", \"w\"),\n        (0x58, \"M\", \"x\"),\n        (0x59, \"M\", \"y\"),\n        (0x5A, \"M\", \"z\"),\n        (0x5B, \"3\"),\n        (0x5C, \"3\"),\n        (0x5D, \"3\"),\n        (0x5E, \"3\"),\n        (0x5F, \"3\"),\n        (0x60, \"3\"),\n        (0x61, \"V\"),\n        (0x62, \"V\"),\n        (0x63, \"V\"),\n    ]\n\n\ndef _seg_1() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x64, \"V\"),\n        (0x65, \"V\"),\n        (0x66, \"V\"),\n        (0x67, \"V\"),\n        (0x68, \"V\"),\n        (0x69, \"V\"),\n        (0x6A, \"V\"),\n        (0x6B, \"V\"),\n        (0x6C, \"V\"),\n        (0x6D, \"V\"),\n        (0x6E, \"V\"),\n        (0x6F, \"V\"),\n        (0x70, \"V\"),\n        (0x71, \"V\"),\n        (0x72, \"V\"),\n        (0x73, \"V\"),\n        (0x74, \"V\"),\n        (0x75, \"V\"),\n        (0x76, \"V\"),\n        (0x77, \"V\"),\n        (0x78, \"V\"),\n        (0x79, \"V\"),\n        (0x7A, \"V\"),\n        (0x7B, \"3\"),\n        (0x7C, \"3\"),\n        (0x7D, \"3\"),\n        (0x7E, \"3\"),\n        (0x7F, \"3\"),\n        (0x80, \"X\"),\n        (0x81, \"X\"),\n        (0x82, \"X\"),\n        (0x83, \"X\"),\n        (0x84, \"X\"),\n        (0x85, \"X\"),\n        (0x86, \"X\"),\n        (0x87, \"X\"),\n        (0x88, \"X\"),\n        (0x89, \"X\"),\n        (0x8A, \"X\"),\n        (0x8B, \"X\"),\n        (0x8C, \"X\"),\n        (0x8D, \"X\"),\n        (0x8E, \"X\"),\n        (0x8F, \"X\"),\n        (0x90, \"X\"),\n        (0x91, \"X\"),\n        (0x92, \"X\"),\n        (0x93, \"X\"),\n        (0x94, \"X\"),\n        (0x95, \"X\"),\n        (0x96, \"X\"),\n        (0x97, \"X\"),\n        (0x98, \"X\"),\n        (0x99, \"X\"),\n        (0x9A, \"X\"),\n        (0x9B, \"X\"),\n        (0x9C, \"X\"),\n        (0x9D, \"X\"),\n        (0x9E, \"X\"),\n        (0x9F, \"X\"),\n        (0xA0, \"3\", \" \"),\n        (0xA1, \"V\"),\n        (0xA2, \"V\"),\n        (0xA3, \"V\"),\n        (0xA4, \"V\"),\n        (0xA5, \"V\"),\n        (0xA6, \"V\"),\n        (0xA7, \"V\"),\n        (0xA8, \"3\", \" \"),\n        (0xA9, \"V\"),\n        (0xAA, \"M\", \"a\"),\n        (0xAB, \"V\"),\n        (0xAC, \"V\"),\n        (0xAD, \"I\"),\n        (0xAE, \"V\"),\n        (0xAF, \"3\", \" \"),\n        (0xB0, \"V\"),\n        (0xB1, \"V\"),\n        (0xB2, \"M\", \"2\"),\n        (0xB3, \"M\", \"3\"),\n        (0xB4, \"3\", \" \"),\n        (0xB5, \"M\", \"\"),\n        (0xB6, \"V\"),\n        (0xB7, \"V\"),\n        (0xB8, \"3\", \" \"),\n        (0xB9, \"M\", \"1\"),\n        (0xBA, \"M\", \"o\"),\n        (0xBB, \"V\"),\n        (0xBC, \"M\", \"14\"),\n        (0xBD, \"M\", \"12\"),\n        (0xBE, \"M\", \"34\"),\n        (0xBF, \"V\"),\n        (0xC0, \"M\", \"\"),\n        (0xC1, \"M\", \"\"),\n        (0xC2, \"M\", \"\"),\n        (0xC3, \"M\", \"\"),\n        (0xC4, \"M\", \"\"),\n        (0xC5, \"M\", \"\"),\n        (0xC6, \"M\", \"\"),\n        (0xC7, \"M\", \"\"),\n    ]\n\n\ndef _seg_2() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xC8, \"M\", \"\"),\n        (0xC9, \"M\", \"\"),\n        (0xCA, \"M\", \"\"),\n        (0xCB, \"M\", \"\"),\n        (0xCC, \"M\", \"\"),\n        (0xCD, \"M\", \"\"),\n        (0xCE, \"M\", \"\"),\n        (0xCF, \"M\", \"\"),\n        (0xD0, \"M\", \"\"),\n        (0xD1, \"M\", \"\"),\n        (0xD2, \"M\", \"\"),\n        (0xD3, \"M\", \"\"),\n        (0xD4, \"M\", \"\"),\n        (0xD5, \"M\", \"\"),\n        (0xD6, \"M\", \"\"),\n        (0xD7, \"V\"),\n        (0xD8, \"M\", \"\"),\n        (0xD9, \"M\", \"\"),\n        (0xDA, \"M\", \"\"),\n        (0xDB, \"M\", \"\"),\n        (0xDC, \"M\", \"\"),\n        (0xDD, \"M\", \"\"),\n        (0xDE, \"M\", \"\"),\n        (0xDF, \"D\", \"ss\"),\n        (0xE0, \"V\"),\n        (0xE1, \"V\"),\n        (0xE2, \"V\"),\n        (0xE3, \"V\"),\n        (0xE4, \"V\"),\n        (0xE5, \"V\"),\n        (0xE6, \"V\"),\n        (0xE7, \"V\"),\n        (0xE8, \"V\"),\n        (0xE9, \"V\"),\n        (0xEA, \"V\"),\n        (0xEB, \"V\"),\n        (0xEC, \"V\"),\n        (0xED, \"V\"),\n        (0xEE, \"V\"),\n        (0xEF, \"V\"),\n        (0xF0, \"V\"),\n        (0xF1, \"V\"),\n        (0xF2, \"V\"),\n        (0xF3, \"V\"),\n        (0xF4, \"V\"),\n        (0xF5, \"V\"),\n        (0xF6, \"V\"),\n        (0xF7, \"V\"),\n        (0xF8, \"V\"),\n        (0xF9, \"V\"),\n        (0xFA, \"V\"),\n        (0xFB, \"V\"),\n        (0xFC, \"V\"),\n        (0xFD, \"V\"),\n        (0xFE, \"V\"),\n        (0xFF, \"V\"),\n        (0x100, \"M\", \"\"),\n        (0x101, \"V\"),\n        (0x102, \"M\", \"\"),\n        (0x103, \"V\"),\n        (0x104, \"M\", \"\"),\n        (0x105, \"V\"),\n        (0x106, \"M\", \"\"),\n        (0x107, \"V\"),\n        (0x108, \"M\", \"\"),\n        (0x109, \"V\"),\n        (0x10A, \"M\", \"\"),\n        (0x10B, \"V\"),\n        (0x10C, \"M\", \"\"),\n        (0x10D, \"V\"),\n        (0x10E, \"M\", \"\"),\n        (0x10F, \"V\"),\n        (0x110, \"M\", \"\"),\n        (0x111, \"V\"),\n        (0x112, \"M\", \"\"),\n        (0x113, \"V\"),\n        (0x114, \"M\", \"\"),\n        (0x115, \"V\"),\n        (0x116, \"M\", \"\"),\n        (0x117, \"V\"),\n        (0x118, \"M\", \"\"),\n        (0x119, \"V\"),\n        (0x11A, \"M\", \"\"),\n        (0x11B, \"V\"),\n        (0x11C, \"M\", \"\"),\n        (0x11D, \"V\"),\n        (0x11E, \"M\", \"\"),\n        (0x11F, \"V\"),\n        (0x120, \"M\", \"\"),\n        (0x121, \"V\"),\n        (0x122, \"M\", \"\"),\n        (0x123, \"V\"),\n        (0x124, \"M\", \"\"),\n        (0x125, \"V\"),\n        (0x126, \"M\", \"\"),\n        (0x127, \"V\"),\n        (0x128, \"M\", \"\"),\n        (0x129, \"V\"),\n        (0x12A, \"M\", \"\"),\n        (0x12B, \"V\"),\n    ]\n\n\ndef _seg_3() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x12C, \"M\", \"\"),\n        (0x12D, \"V\"),\n        (0x12E, \"M\", \"\"),\n        (0x12F, \"V\"),\n        (0x130, \"M\", \"i\"),\n        (0x131, \"V\"),\n        (0x132, \"M\", \"ij\"),\n        (0x134, \"M\", \"\"),\n        (0x135, \"V\"),\n        (0x136, \"M\", \"\"),\n        (0x137, \"V\"),\n        (0x139, \"M\", \"\"),\n        (0x13A, \"V\"),\n        (0x13B, \"M\", \"\"),\n        (0x13C, \"V\"),\n        (0x13D, \"M\", \"\"),\n        (0x13E, \"V\"),\n        (0x13F, \"M\", \"l\"),\n        (0x141, \"M\", \"\"),\n        (0x142, \"V\"),\n        (0x143, \"M\", \"\"),\n        (0x144, \"V\"),\n        (0x145, \"M\", \"\"),\n        (0x146, \"V\"),\n        (0x147, \"M\", \"\"),\n        (0x148, \"V\"),\n        (0x149, \"M\", \"n\"),\n        (0x14A, \"M\", \"\"),\n        (0x14B, \"V\"),\n        (0x14C, \"M\", \"\"),\n        (0x14D, \"V\"),\n        (0x14E, \"M\", \"\"),\n        (0x14F, \"V\"),\n        (0x150, \"M\", \"\"),\n        (0x151, \"V\"),\n        (0x152, \"M\", \"\"),\n        (0x153, \"V\"),\n        (0x154, \"M\", \"\"),\n        (0x155, \"V\"),\n        (0x156, \"M\", \"\"),\n        (0x157, \"V\"),\n        (0x158, \"M\", \"\"),\n        (0x159, \"V\"),\n        (0x15A, \"M\", \"\"),\n        (0x15B, \"V\"),\n        (0x15C, \"M\", \"\"),\n        (0x15D, \"V\"),\n        (0x15E, \"M\", \"\"),\n        (0x15F, \"V\"),\n        (0x160, \"M\", \"\"),\n        (0x161, \"V\"),\n        (0x162, \"M\", \"\"),\n        (0x163, \"V\"),\n        (0x164, \"M\", \"\"),\n        (0x165, \"V\"),\n        (0x166, \"M\", \"\"),\n        (0x167, \"V\"),\n        (0x168, \"M\", \"\"),\n        (0x169, \"V\"),\n        (0x16A, \"M\", \"\"),\n        (0x16B, \"V\"),\n        (0x16C, \"M\", \"\"),\n        (0x16D, \"V\"),\n        (0x16E, \"M\", \"\"),\n        (0x16F, \"V\"),\n        (0x170, \"M\", \"\"),\n        (0x171, \"V\"),\n        (0x172, \"M\", \"\"),\n        (0x173, \"V\"),\n        (0x174, \"M\", \"\"),\n        (0x175, \"V\"),\n        (0x176, \"M\", \"\"),\n        (0x177, \"V\"),\n        (0x178, \"M\", \"\"),\n        (0x179, \"M\", \"\"),\n        (0x17A, \"V\"),\n        (0x17B, \"M\", \"\"),\n        (0x17C, \"V\"),\n        (0x17D, \"M\", \"\"),\n        (0x17E, \"V\"),\n        (0x17F, \"M\", \"s\"),\n        (0x180, \"V\"),\n        (0x181, \"M\", \"\"),\n        (0x182, \"M\", \"\"),\n        (0x183, \"V\"),\n        (0x184, \"M\", \"\"),\n        (0x185, \"V\"),\n        (0x186, \"M\", \"\"),\n        (0x187, \"M\", \"\"),\n        (0x188, \"V\"),\n        (0x189, \"M\", \"\"),\n        (0x18A, \"M\", \"\"),\n        (0x18B, \"M\", \"\"),\n        (0x18C, \"V\"),\n        (0x18E, \"M\", \"\"),\n        (0x18F, \"M\", \"\"),\n        (0x190, \"M\", \"\"),\n        (0x191, \"M\", \"\"),\n        (0x192, \"V\"),\n        (0x193, \"M\", \"\"),\n    ]\n\n\ndef _seg_4() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x194, \"M\", \"\"),\n        (0x195, \"V\"),\n        (0x196, \"M\", \"\"),\n        (0x197, \"M\", \"\"),\n        (0x198, \"M\", \"\"),\n        (0x199, \"V\"),\n        (0x19C, \"M\", \"\"),\n        (0x19D, \"M\", \"\"),\n        (0x19E, \"V\"),\n        (0x19F, \"M\", \"\"),\n        (0x1A0, \"M\", \"\"),\n        (0x1A1, \"V\"),\n        (0x1A2, \"M\", \"\"),\n        (0x1A3, \"V\"),\n        (0x1A4, \"M\", \"\"),\n        (0x1A5, \"V\"),\n        (0x1A6, \"M\", \"\"),\n        (0x1A7, \"M\", \"\"),\n        (0x1A8, \"V\"),\n        (0x1A9, \"M\", \"\"),\n        (0x1AA, \"V\"),\n        (0x1AC, \"M\", \"\"),\n        (0x1AD, \"V\"),\n        (0x1AE, \"M\", \"\"),\n        (0x1AF, \"M\", \"\"),\n        (0x1B0, \"V\"),\n        (0x1B1, \"M\", \"\"),\n        (0x1B2, \"M\", \"\"),\n        (0x1B3, \"M\", \"\"),\n        (0x1B4, \"V\"),\n        (0x1B5, \"M\", \"\"),\n        (0x1B6, \"V\"),\n        (0x1B7, \"M\", \"\"),\n        (0x1B8, \"M\", \"\"),\n        (0x1B9, \"V\"),\n        (0x1BC, \"M\", \"\"),\n        (0x1BD, \"V\"),\n        (0x1C4, \"M\", \"d\"),\n        (0x1C7, \"M\", \"lj\"),\n        (0x1CA, \"M\", \"nj\"),\n        (0x1CD, \"M\", \"\"),\n        (0x1CE, \"V\"),\n        (0x1CF, \"M\", \"\"),\n        (0x1D0, \"V\"),\n        (0x1D1, \"M\", \"\"),\n        (0x1D2, \"V\"),\n        (0x1D3, \"M\", \"\"),\n        (0x1D4, \"V\"),\n        (0x1D5, \"M\", \"\"),\n        (0x1D6, \"V\"),\n        (0x1D7, \"M\", \"\"),\n        (0x1D8, \"V\"),\n        (0x1D9, \"M\", \"\"),\n        (0x1DA, \"V\"),\n        (0x1DB, \"M\", \"\"),\n        (0x1DC, \"V\"),\n        (0x1DE, \"M\", \"\"),\n        (0x1DF, \"V\"),\n        (0x1E0, \"M\", \"\"),\n        (0x1E1, \"V\"),\n        (0x1E2, \"M\", \"\"),\n        (0x1E3, \"V\"),\n        (0x1E4, \"M\", \"\"),\n        (0x1E5, \"V\"),\n        (0x1E6, \"M\", \"\"),\n        (0x1E7, \"V\"),\n        (0x1E8, \"M\", \"\"),\n        (0x1E9, \"V\"),\n        (0x1EA, \"M\", \"\"),\n        (0x1EB, \"V\"),\n        (0x1EC, \"M\", \"\"),\n        (0x1ED, \"V\"),\n        (0x1EE, \"M\", \"\"),\n        (0x1EF, \"V\"),\n        (0x1F1, \"M\", \"dz\"),\n        (0x1F4, \"M\", \"\"),\n        (0x1F5, \"V\"),\n        (0x1F6, \"M\", \"\"),\n        (0x1F7, \"M\", \"\"),\n        (0x1F8, \"M\", \"\"),\n        (0x1F9, \"V\"),\n        (0x1FA, \"M\", \"\"),\n        (0x1FB, \"V\"),\n        (0x1FC, \"M\", \"\"),\n        (0x1FD, \"V\"),\n        (0x1FE, \"M\", \"\"),\n        (0x1FF, \"V\"),\n        (0x200, \"M\", \"\"),\n        (0x201, \"V\"),\n        (0x202, \"M\", \"\"),\n        (0x203, \"V\"),\n        (0x204, \"M\", \"\"),\n        (0x205, \"V\"),\n        (0x206, \"M\", \"\"),\n        (0x207, \"V\"),\n        (0x208, \"M\", \"\"),\n        (0x209, \"V\"),\n        (0x20A, \"M\", \"\"),\n        (0x20B, \"V\"),\n        (0x20C, \"M\", \"\"),\n    ]\n\n\ndef _seg_5() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x20D, \"V\"),\n        (0x20E, \"M\", \"\"),\n        (0x20F, \"V\"),\n        (0x210, \"M\", \"\"),\n        (0x211, \"V\"),\n        (0x212, \"M\", \"\"),\n        (0x213, \"V\"),\n        (0x214, \"M\", \"\"),\n        (0x215, \"V\"),\n        (0x216, \"M\", \"\"),\n        (0x217, \"V\"),\n        (0x218, \"M\", \"\"),\n        (0x219, \"V\"),\n        (0x21A, \"M\", \"\"),\n        (0x21B, \"V\"),\n        (0x21C, \"M\", \"\"),\n        (0x21D, \"V\"),\n        (0x21E, \"M\", \"\"),\n        (0x21F, \"V\"),\n        (0x220, \"M\", \"\"),\n        (0x221, \"V\"),\n        (0x222, \"M\", \"\"),\n        (0x223, \"V\"),\n        (0x224, \"M\", \"\"),\n        (0x225, \"V\"),\n        (0x226, \"M\", \"\"),\n        (0x227, \"V\"),\n        (0x228, \"M\", \"\"),\n        (0x229, \"V\"),\n        (0x22A, \"M\", \"\"),\n        (0x22B, \"V\"),\n        (0x22C, \"M\", \"\"),\n        (0x22D, \"V\"),\n        (0x22E, \"M\", \"\"),\n        (0x22F, \"V\"),\n        (0x230, \"M\", \"\"),\n        (0x231, \"V\"),\n        (0x232, \"M\", \"\"),\n        (0x233, \"V\"),\n        (0x23A, \"M\", \"\"),\n        (0x23B, \"M\", \"\"),\n        (0x23C, \"V\"),\n        (0x23D, \"M\", \"\"),\n        (0x23E, \"M\", \"\"),\n        (0x23F, \"V\"),\n        (0x241, \"M\", \"\"),\n        (0x242, \"V\"),\n        (0x243, \"M\", \"\"),\n        (0x244, \"M\", \"\"),\n        (0x245, \"M\", \"\"),\n        (0x246, \"M\", \"\"),\n        (0x247, \"V\"),\n        (0x248, \"M\", \"\"),\n        (0x249, \"V\"),\n        (0x24A, \"M\", \"\"),\n        (0x24B, \"V\"),\n        (0x24C, \"M\", \"\"),\n        (0x24D, \"V\"),\n        (0x24E, \"M\", \"\"),\n        (0x24F, \"V\"),\n        (0x2B0, \"M\", \"h\"),\n        (0x2B1, \"M\", \"\"),\n        (0x2B2, \"M\", \"j\"),\n        (0x2B3, \"M\", \"r\"),\n        (0x2B4, \"M\", \"\"),\n        (0x2B5, \"M\", \"\"),\n        (0x2B6, \"M\", \"\"),\n        (0x2B7, \"M\", \"w\"),\n        (0x2B8, \"M\", \"y\"),\n        (0x2B9, \"V\"),\n        (0x2D8, \"3\", \" \"),\n        (0x2D9, \"3\", \" \"),\n        (0x2DA, \"3\", \" \"),\n        (0x2DB, \"3\", \" \"),\n        (0x2DC, \"3\", \" \"),\n        (0x2DD, \"3\", \" \"),\n        (0x2DE, \"V\"),\n        (0x2E0, \"M\", \"\"),\n        (0x2E1, \"M\", \"l\"),\n        (0x2E2, \"M\", \"s\"),\n        (0x2E3, \"M\", \"x\"),\n        (0x2E4, \"M\", \"\"),\n        (0x2E5, \"V\"),\n        (0x340, \"M\", \"\"),\n        (0x341, \"M\", \"\"),\n        (0x342, \"V\"),\n        (0x343, \"M\", \"\"),\n        (0x344, \"M\", \"\"),\n        (0x345, \"M\", \"\"),\n        (0x346, \"V\"),\n        (0x34F, \"I\"),\n        (0x350, \"V\"),\n        (0x370, \"M\", \"\"),\n        (0x371, \"V\"),\n        (0x372, \"M\", \"\"),\n        (0x373, \"V\"),\n        (0x374, \"M\", \"\"),\n        (0x375, \"V\"),\n        (0x376, \"M\", \"\"),\n        (0x377, \"V\"),\n    ]\n\n\ndef _seg_6() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x378, \"X\"),\n        (0x37A, \"3\", \" \"),\n        (0x37B, \"V\"),\n        (0x37E, \"3\", \";\"),\n        (0x37F, \"M\", \"\"),\n        (0x380, \"X\"),\n        (0x384, \"3\", \" \"),\n        (0x385, \"3\", \" \"),\n        (0x386, \"M\", \"\"),\n        (0x387, \"M\", \"\"),\n        (0x388, \"M\", \"\"),\n        (0x389, \"M\", \"\"),\n        (0x38A, \"M\", \"\"),\n        (0x38B, \"X\"),\n        (0x38C, \"M\", \"\"),\n        (0x38D, \"X\"),\n        (0x38E, \"M\", \"\"),\n        (0x38F, \"M\", \"\"),\n        (0x390, \"V\"),\n        (0x391, \"M\", \"\"),\n        (0x392, \"M\", \"\"),\n        (0x393, \"M\", \"\"),\n        (0x394, \"M\", \"\"),\n        (0x395, \"M\", \"\"),\n        (0x396, \"M\", \"\"),\n        (0x397, \"M\", \"\"),\n        (0x398, \"M\", \"\"),\n        (0x399, \"M\", \"\"),\n        (0x39A, \"M\", \"\"),\n        (0x39B, \"M\", \"\"),\n        (0x39C, \"M\", \"\"),\n        (0x39D, \"M\", \"\"),\n        (0x39E, \"M\", \"\"),\n        (0x39F, \"M\", \"\"),\n        (0x3A0, \"M\", \"\"),\n        (0x3A1, \"M\", \"\"),\n        (0x3A2, \"X\"),\n        (0x3A3, \"M\", \"\"),\n        (0x3A4, \"M\", \"\"),\n        (0x3A5, \"M\", \"\"),\n        (0x3A6, \"M\", \"\"),\n        (0x3A7, \"M\", \"\"),\n        (0x3A8, \"M\", \"\"),\n        (0x3A9, \"M\", \"\"),\n        (0x3AA, \"M\", \"\"),\n        (0x3AB, \"M\", \"\"),\n        (0x3AC, \"V\"),\n        (0x3C2, \"D\", \"\"),\n        (0x3C3, \"V\"),\n        (0x3CF, \"M\", \"\"),\n        (0x3D0, \"M\", \"\"),\n        (0x3D1, \"M\", \"\"),\n        (0x3D2, \"M\", \"\"),\n        (0x3D3, \"M\", \"\"),\n        (0x3D4, \"M\", \"\"),\n        (0x3D5, \"M\", \"\"),\n        (0x3D6, \"M\", \"\"),\n        (0x3D7, \"V\"),\n        (0x3D8, \"M\", \"\"),\n        (0x3D9, \"V\"),\n        (0x3DA, \"M\", \"\"),\n        (0x3DB, \"V\"),\n        (0x3DC, \"M\", \"\"),\n        (0x3DD, \"V\"),\n        (0x3DE, \"M\", \"\"),\n        (0x3DF, \"V\"),\n        (0x3E0, \"M\", \"\"),\n        (0x3E1, \"V\"),\n        (0x3E2, \"M\", \"\"),\n        (0x3E3, \"V\"),\n        (0x3E4, \"M\", \"\"),\n        (0x3E5, \"V\"),\n        (0x3E6, \"M\", \"\"),\n        (0x3E7, \"V\"),\n        (0x3E8, \"M\", \"\"),\n        (0x3E9, \"V\"),\n        (0x3EA, \"M\", \"\"),\n        (0x3EB, \"V\"),\n        (0x3EC, \"M\", \"\"),\n        (0x3ED, \"V\"),\n        (0x3EE, \"M\", \"\"),\n        (0x3EF, \"V\"),\n        (0x3F0, \"M\", \"\"),\n        (0x3F1, \"M\", \"\"),\n        (0x3F2, \"M\", \"\"),\n        (0x3F3, \"V\"),\n        (0x3F4, \"M\", \"\"),\n        (0x3F5, \"M\", \"\"),\n        (0x3F6, \"V\"),\n        (0x3F7, \"M\", \"\"),\n        (0x3F8, \"V\"),\n        (0x3F9, \"M\", \"\"),\n        (0x3FA, \"M\", \"\"),\n        (0x3FB, \"V\"),\n        (0x3FD, \"M\", \"\"),\n        (0x3FE, \"M\", \"\"),\n        (0x3FF, \"M\", \"\"),\n        (0x400, \"M\", \"\"),\n        (0x401, \"M\", \"\"),\n        (0x402, \"M\", \"\"),\n    ]\n\n\ndef _seg_7() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x403, \"M\", \"\"),\n        (0x404, \"M\", \"\"),\n        (0x405, \"M\", \"\"),\n        (0x406, \"M\", \"\"),\n        (0x407, \"M\", \"\"),\n        (0x408, \"M\", \"\"),\n        (0x409, \"M\", \"\"),\n        (0x40A, \"M\", \"\"),\n        (0x40B, \"M\", \"\"),\n        (0x40C, \"M\", \"\"),\n        (0x40D, \"M\", \"\"),\n        (0x40E, \"M\", \"\"),\n        (0x40F, \"M\", \"\"),\n        (0x410, \"M\", \"\"),\n        (0x411, \"M\", \"\"),\n        (0x412, \"M\", \"\"),\n        (0x413, \"M\", \"\"),\n        (0x414, \"M\", \"\"),\n        (0x415, \"M\", \"\"),\n        (0x416, \"M\", \"\"),\n        (0x417, \"M\", \"\"),\n        (0x418, \"M\", \"\"),\n        (0x419, \"M\", \"\"),\n        (0x41A, \"M\", \"\"),\n        (0x41B, \"M\", \"\"),\n        (0x41C, \"M\", \"\"),\n        (0x41D, \"M\", \"\"),\n        (0x41E, \"M\", \"\"),\n        (0x41F, \"M\", \"\"),\n        (0x420, \"M\", \"\"),\n        (0x421, \"M\", \"\"),\n        (0x422, \"M\", \"\"),\n        (0x423, \"M\", \"\"),\n        (0x424, \"M\", \"\"),\n        (0x425, \"M\", \"\"),\n        (0x426, \"M\", \"\"),\n        (0x427, \"M\", \"\"),\n        (0x428, \"M\", \"\"),\n        (0x429, \"M\", \"\"),\n        (0x42A, \"M\", \"\"),\n        (0x42B, \"M\", \"\"),\n        (0x42C, \"M\", \"\"),\n        (0x42D, \"M\", \"\"),\n        (0x42E, \"M\", \"\"),\n        (0x42F, \"M\", \"\"),\n        (0x430, \"V\"),\n        (0x460, \"M\", \"\"),\n        (0x461, \"V\"),\n        (0x462, \"M\", \"\"),\n        (0x463, \"V\"),\n        (0x464, \"M\", \"\"),\n        (0x465, \"V\"),\n        (0x466, \"M\", \"\"),\n        (0x467, \"V\"),\n        (0x468, \"M\", \"\"),\n        (0x469, \"V\"),\n        (0x46A, \"M\", \"\"),\n        (0x46B, \"V\"),\n        (0x46C, \"M\", \"\"),\n        (0x46D, \"V\"),\n        (0x46E, \"M\", \"\"),\n        (0x46F, \"V\"),\n        (0x470, \"M\", \"\"),\n        (0x471, \"V\"),\n        (0x472, \"M\", \"\"),\n        (0x473, \"V\"),\n        (0x474, \"M\", \"\"),\n        (0x475, \"V\"),\n        (0x476, \"M\", \"\"),\n        (0x477, \"V\"),\n        (0x478, \"M\", \"\"),\n        (0x479, \"V\"),\n        (0x47A, \"M\", \"\"),\n        (0x47B, \"V\"),\n        (0x47C, \"M\", \"\"),\n        (0x47D, \"V\"),\n        (0x47E, \"M\", \"\"),\n        (0x47F, \"V\"),\n        (0x480, \"M\", \"\"),\n        (0x481, \"V\"),\n        (0x48A, \"M\", \"\"),\n        (0x48B, \"V\"),\n        (0x48C, \"M\", \"\"),\n        (0x48D, \"V\"),\n        (0x48E, \"M\", \"\"),\n        (0x48F, \"V\"),\n        (0x490, \"M\", \"\"),\n        (0x491, \"V\"),\n        (0x492, \"M\", \"\"),\n        (0x493, \"V\"),\n        (0x494, \"M\", \"\"),\n        (0x495, \"V\"),\n        (0x496, \"M\", \"\"),\n        (0x497, \"V\"),\n        (0x498, \"M\", \"\"),\n        (0x499, \"V\"),\n        (0x49A, \"M\", \"\"),\n        (0x49B, \"V\"),\n        (0x49C, \"M\", \"\"),\n        (0x49D, \"V\"),\n    ]\n\n\ndef _seg_8() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x49E, \"M\", \"\"),\n        (0x49F, \"V\"),\n        (0x4A0, \"M\", \"\"),\n        (0x4A1, \"V\"),\n        (0x4A2, \"M\", \"\"),\n        (0x4A3, \"V\"),\n        (0x4A4, \"M\", \"\"),\n        (0x4A5, \"V\"),\n        (0x4A6, \"M\", \"\"),\n        (0x4A7, \"V\"),\n        (0x4A8, \"M\", \"\"),\n        (0x4A9, \"V\"),\n        (0x4AA, \"M\", \"\"),\n        (0x4AB, \"V\"),\n        (0x4AC, \"M\", \"\"),\n        (0x4AD, \"V\"),\n        (0x4AE, \"M\", \"\"),\n        (0x4AF, \"V\"),\n        (0x4B0, \"M\", \"\"),\n        (0x4B1, \"V\"),\n        (0x4B2, \"M\", \"\"),\n        (0x4B3, \"V\"),\n        (0x4B4, \"M\", \"\"),\n        (0x4B5, \"V\"),\n        (0x4B6, \"M\", \"\"),\n        (0x4B7, \"V\"),\n        (0x4B8, \"M\", \"\"),\n        (0x4B9, \"V\"),\n        (0x4BA, \"M\", \"\"),\n        (0x4BB, \"V\"),\n        (0x4BC, \"M\", \"\"),\n        (0x4BD, \"V\"),\n        (0x4BE, \"M\", \"\"),\n        (0x4BF, \"V\"),\n        (0x4C0, \"X\"),\n        (0x4C1, \"M\", \"\"),\n        (0x4C2, \"V\"),\n        (0x4C3, \"M\", \"\"),\n        (0x4C4, \"V\"),\n        (0x4C5, \"M\", \"\"),\n        (0x4C6, \"V\"),\n        (0x4C7, \"M\", \"\"),\n        (0x4C8, \"V\"),\n        (0x4C9, \"M\", \"\"),\n        (0x4CA, \"V\"),\n        (0x4CB, \"M\", \"\"),\n        (0x4CC, \"V\"),\n        (0x4CD, \"M\", \"\"),\n        (0x4CE, \"V\"),\n        (0x4D0, \"M\", \"\"),\n        (0x4D1, \"V\"),\n        (0x4D2, \"M\", \"\"),\n        (0x4D3, \"V\"),\n        (0x4D4, \"M\", \"\"),\n        (0x4D5, \"V\"),\n        (0x4D6, \"M\", \"\"),\n        (0x4D7, \"V\"),\n        (0x4D8, \"M\", \"\"),\n        (0x4D9, \"V\"),\n        (0x4DA, \"M\", \"\"),\n        (0x4DB, \"V\"),\n        (0x4DC, \"M\", \"\"),\n        (0x4DD, \"V\"),\n        (0x4DE, \"M\", \"\"),\n        (0x4DF, \"V\"),\n        (0x4E0, \"M\", \"\"),\n        (0x4E1, \"V\"),\n        (0x4E2, \"M\", \"\"),\n        (0x4E3, \"V\"),\n        (0x4E4, \"M\", \"\"),\n        (0x4E5, \"V\"),\n        (0x4E6, \"M\", \"\"),\n        (0x4E7, \"V\"),\n        (0x4E8, \"M\", \"\"),\n        (0x4E9, \"V\"),\n        (0x4EA, \"M\", \"\"),\n        (0x4EB, \"V\"),\n        (0x4EC, \"M\", \"\"),\n        (0x4ED, \"V\"),\n        (0x4EE, \"M\", \"\"),\n        (0x4EF, \"V\"),\n        (0x4F0, \"M\", \"\"),\n        (0x4F1, \"V\"),\n        (0x4F2, \"M\", \"\"),\n        (0x4F3, \"V\"),\n        (0x4F4, \"M\", \"\"),\n        (0x4F5, \"V\"),\n        (0x4F6, \"M\", \"\"),\n        (0x4F7, \"V\"),\n        (0x4F8, \"M\", \"\"),\n        (0x4F9, \"V\"),\n        (0x4FA, \"M\", \"\"),\n        (0x4FB, \"V\"),\n        (0x4FC, \"M\", \"\"),\n        (0x4FD, \"V\"),\n        (0x4FE, \"M\", \"\"),\n        (0x4FF, \"V\"),\n        (0x500, \"M\", \"\"),\n        (0x501, \"V\"),\n        (0x502, \"M\", \"\"),\n    ]\n\n\ndef _seg_9() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x503, \"V\"),\n        (0x504, \"M\", \"\"),\n        (0x505, \"V\"),\n        (0x506, \"M\", \"\"),\n        (0x507, \"V\"),\n        (0x508, \"M\", \"\"),\n        (0x509, \"V\"),\n        (0x50A, \"M\", \"\"),\n        (0x50B, \"V\"),\n        (0x50C, \"M\", \"\"),\n        (0x50D, \"V\"),\n        (0x50E, \"M\", \"\"),\n        (0x50F, \"V\"),\n        (0x510, \"M\", \"\"),\n        (0x511, \"V\"),\n        (0x512, \"M\", \"\"),\n        (0x513, \"V\"),\n        (0x514, \"M\", \"\"),\n        (0x515, \"V\"),\n        (0x516, \"M\", \"\"),\n        (0x517, \"V\"),\n        (0x518, \"M\", \"\"),\n        (0x519, \"V\"),\n        (0x51A, \"M\", \"\"),\n        (0x51B, \"V\"),\n        (0x51C, \"M\", \"\"),\n        (0x51D, \"V\"),\n        (0x51E, \"M\", \"\"),\n        (0x51F, \"V\"),\n        (0x520, \"M\", \"\"),\n        (0x521, \"V\"),\n        (0x522, \"M\", \"\"),\n        (0x523, \"V\"),\n        (0x524, \"M\", \"\"),\n        (0x525, \"V\"),\n        (0x526, \"M\", \"\"),\n        (0x527, \"V\"),\n        (0x528, \"M\", \"\"),\n        (0x529, \"V\"),\n        (0x52A, \"M\", \"\"),\n        (0x52B, \"V\"),\n        (0x52C, \"M\", \"\"),\n        (0x52D, \"V\"),\n        (0x52E, \"M\", \"\"),\n        (0x52F, \"V\"),\n        (0x530, \"X\"),\n        (0x531, \"M\", \"\"),\n        (0x532, \"M\", \"\"),\n        (0x533, \"M\", \"\"),\n        (0x534, \"M\", \"\"),\n        (0x535, \"M\", \"\"),\n        (0x536, \"M\", \"\"),\n        (0x537, \"M\", \"\"),\n        (0x538, \"M\", \"\"),\n        (0x539, \"M\", \"\"),\n        (0x53A, \"M\", \"\"),\n        (0x53B, \"M\", \"\"),\n        (0x53C, \"M\", \"\"),\n        (0x53D, \"M\", \"\"),\n        (0x53E, \"M\", \"\"),\n        (0x53F, \"M\", \"\"),\n        (0x540, \"M\", \"\"),\n        (0x541, \"M\", \"\"),\n        (0x542, \"M\", \"\"),\n        (0x543, \"M\", \"\"),\n        (0x544, \"M\", \"\"),\n        (0x545, \"M\", \"\"),\n        (0x546, \"M\", \"\"),\n        (0x547, \"M\", \"\"),\n        (0x548, \"M\", \"\"),\n        (0x549, \"M\", \"\"),\n        (0x54A, \"M\", \"\"),\n        (0x54B, \"M\", \"\"),\n        (0x54C, \"M\", \"\"),\n        (0x54D, \"M\", \"\"),\n        (0x54E, \"M\", \"\"),\n        (0x54F, \"M\", \"\"),\n        (0x550, \"M\", \"\"),\n        (0x551, \"M\", \"\"),\n        (0x552, \"M\", \"\"),\n        (0x553, \"M\", \"\"),\n        (0x554, \"M\", \"\"),\n        (0x555, \"M\", \"\"),\n        (0x556, \"M\", \"\"),\n        (0x557, \"X\"),\n        (0x559, \"V\"),\n        (0x587, \"M\", \"\"),\n        (0x588, \"V\"),\n        (0x58B, \"X\"),\n        (0x58D, \"V\"),\n        (0x590, \"X\"),\n        (0x591, \"V\"),\n        (0x5C8, \"X\"),\n        (0x5D0, \"V\"),\n        (0x5EB, \"X\"),\n        (0x5EF, \"V\"),\n        (0x5F5, \"X\"),\n        (0x606, \"V\"),\n        (0x61C, \"X\"),\n        (0x61D, \"V\"),\n    ]\n\n\ndef _seg_10() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x675, \"M\", \"\"),\n        (0x676, \"M\", \"\"),\n        (0x677, \"M\", \"\"),\n        (0x678, \"M\", \"\"),\n        (0x679, \"V\"),\n        (0x6DD, \"X\"),\n        (0x6DE, \"V\"),\n        (0x70E, \"X\"),\n        (0x710, \"V\"),\n        (0x74B, \"X\"),\n        (0x74D, \"V\"),\n        (0x7B2, \"X\"),\n        (0x7C0, \"V\"),\n        (0x7FB, \"X\"),\n        (0x7FD, \"V\"),\n        (0x82E, \"X\"),\n        (0x830, \"V\"),\n        (0x83F, \"X\"),\n        (0x840, \"V\"),\n        (0x85C, \"X\"),\n        (0x85E, \"V\"),\n        (0x85F, \"X\"),\n        (0x860, \"V\"),\n        (0x86B, \"X\"),\n        (0x870, \"V\"),\n        (0x88F, \"X\"),\n        (0x898, \"V\"),\n        (0x8E2, \"X\"),\n        (0x8E3, \"V\"),\n        (0x958, \"M\", \"\"),\n        (0x959, \"M\", \"\"),\n        (0x95A, \"M\", \"\"),\n        (0x95B, \"M\", \"\"),\n        (0x95C, \"M\", \"\"),\n        (0x95D, \"M\", \"\"),\n        (0x95E, \"M\", \"\"),\n        (0x95F, \"M\", \"\"),\n        (0x960, \"V\"),\n        (0x984, \"X\"),\n        (0x985, \"V\"),\n        (0x98D, \"X\"),\n        (0x98F, \"V\"),\n        (0x991, \"X\"),\n        (0x993, \"V\"),\n        (0x9A9, \"X\"),\n        (0x9AA, \"V\"),\n        (0x9B1, \"X\"),\n        (0x9B2, \"V\"),\n        (0x9B3, \"X\"),\n        (0x9B6, \"V\"),\n        (0x9BA, \"X\"),\n        (0x9BC, \"V\"),\n        (0x9C5, \"X\"),\n        (0x9C7, \"V\"),\n        (0x9C9, \"X\"),\n        (0x9CB, \"V\"),\n        (0x9CF, \"X\"),\n        (0x9D7, \"V\"),\n        (0x9D8, \"X\"),\n        (0x9DC, \"M\", \"\"),\n        (0x9DD, \"M\", \"\"),\n        (0x9DE, \"X\"),\n        (0x9DF, \"M\", \"\"),\n        (0x9E0, \"V\"),\n        (0x9E4, \"X\"),\n        (0x9E6, \"V\"),\n        (0x9FF, \"X\"),\n        (0xA01, \"V\"),\n        (0xA04, \"X\"),\n        (0xA05, \"V\"),\n        (0xA0B, \"X\"),\n        (0xA0F, \"V\"),\n        (0xA11, \"X\"),\n        (0xA13, \"V\"),\n        (0xA29, \"X\"),\n        (0xA2A, \"V\"),\n        (0xA31, \"X\"),\n        (0xA32, \"V\"),\n        (0xA33, \"M\", \"\"),\n        (0xA34, \"X\"),\n        (0xA35, \"V\"),\n        (0xA36, \"M\", \"\"),\n        (0xA37, \"X\"),\n        (0xA38, \"V\"),\n        (0xA3A, \"X\"),\n        (0xA3C, \"V\"),\n        (0xA3D, \"X\"),\n        (0xA3E, \"V\"),\n        (0xA43, \"X\"),\n        (0xA47, \"V\"),\n        (0xA49, \"X\"),\n        (0xA4B, \"V\"),\n        (0xA4E, \"X\"),\n        (0xA51, \"V\"),\n        (0xA52, \"X\"),\n        (0xA59, \"M\", \"\"),\n        (0xA5A, \"M\", \"\"),\n        (0xA5B, \"M\", \"\"),\n        (0xA5C, \"V\"),\n        (0xA5D, \"X\"),\n    ]\n\n\ndef _seg_11() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xA5E, \"M\", \"\"),\n        (0xA5F, \"X\"),\n        (0xA66, \"V\"),\n        (0xA77, \"X\"),\n        (0xA81, \"V\"),\n        (0xA84, \"X\"),\n        (0xA85, \"V\"),\n        (0xA8E, \"X\"),\n        (0xA8F, \"V\"),\n        (0xA92, \"X\"),\n        (0xA93, \"V\"),\n        (0xAA9, \"X\"),\n        (0xAAA, \"V\"),\n        (0xAB1, \"X\"),\n        (0xAB2, \"V\"),\n        (0xAB4, \"X\"),\n        (0xAB5, \"V\"),\n        (0xABA, \"X\"),\n        (0xABC, \"V\"),\n        (0xAC6, \"X\"),\n        (0xAC7, \"V\"),\n        (0xACA, \"X\"),\n        (0xACB, \"V\"),\n        (0xACE, \"X\"),\n        (0xAD0, \"V\"),\n        (0xAD1, \"X\"),\n        (0xAE0, \"V\"),\n        (0xAE4, \"X\"),\n        (0xAE6, \"V\"),\n        (0xAF2, \"X\"),\n        (0xAF9, \"V\"),\n        (0xB00, \"X\"),\n        (0xB01, \"V\"),\n        (0xB04, \"X\"),\n        (0xB05, \"V\"),\n        (0xB0D, \"X\"),\n        (0xB0F, \"V\"),\n        (0xB11, \"X\"),\n        (0xB13, \"V\"),\n        (0xB29, \"X\"),\n        (0xB2A, \"V\"),\n        (0xB31, \"X\"),\n        (0xB32, \"V\"),\n        (0xB34, \"X\"),\n        (0xB35, \"V\"),\n        (0xB3A, \"X\"),\n        (0xB3C, \"V\"),\n        (0xB45, \"X\"),\n        (0xB47, \"V\"),\n        (0xB49, \"X\"),\n        (0xB4B, \"V\"),\n        (0xB4E, \"X\"),\n        (0xB55, \"V\"),\n        (0xB58, \"X\"),\n        (0xB5C, \"M\", \"\"),\n        (0xB5D, \"M\", \"\"),\n        (0xB5E, \"X\"),\n        (0xB5F, \"V\"),\n        (0xB64, \"X\"),\n        (0xB66, \"V\"),\n        (0xB78, \"X\"),\n        (0xB82, \"V\"),\n        (0xB84, \"X\"),\n        (0xB85, \"V\"),\n        (0xB8B, \"X\"),\n        (0xB8E, \"V\"),\n        (0xB91, \"X\"),\n        (0xB92, \"V\"),\n        (0xB96, \"X\"),\n        (0xB99, \"V\"),\n        (0xB9B, \"X\"),\n        (0xB9C, \"V\"),\n        (0xB9D, \"X\"),\n        (0xB9E, \"V\"),\n        (0xBA0, \"X\"),\n        (0xBA3, \"V\"),\n        (0xBA5, \"X\"),\n        (0xBA8, \"V\"),\n        (0xBAB, \"X\"),\n        (0xBAE, \"V\"),\n        (0xBBA, \"X\"),\n        (0xBBE, \"V\"),\n        (0xBC3, \"X\"),\n        (0xBC6, \"V\"),\n        (0xBC9, \"X\"),\n        (0xBCA, \"V\"),\n        (0xBCE, \"X\"),\n        (0xBD0, \"V\"),\n        (0xBD1, \"X\"),\n        (0xBD7, \"V\"),\n        (0xBD8, \"X\"),\n        (0xBE6, \"V\"),\n        (0xBFB, \"X\"),\n        (0xC00, \"V\"),\n        (0xC0D, \"X\"),\n        (0xC0E, \"V\"),\n        (0xC11, \"X\"),\n        (0xC12, \"V\"),\n        (0xC29, \"X\"),\n        (0xC2A, \"V\"),\n    ]\n\n\ndef _seg_12() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xC3A, \"X\"),\n        (0xC3C, \"V\"),\n        (0xC45, \"X\"),\n        (0xC46, \"V\"),\n        (0xC49, \"X\"),\n        (0xC4A, \"V\"),\n        (0xC4E, \"X\"),\n        (0xC55, \"V\"),\n        (0xC57, \"X\"),\n        (0xC58, \"V\"),\n        (0xC5B, \"X\"),\n        (0xC5D, \"V\"),\n        (0xC5E, \"X\"),\n        (0xC60, \"V\"),\n        (0xC64, \"X\"),\n        (0xC66, \"V\"),\n        (0xC70, \"X\"),\n        (0xC77, \"V\"),\n        (0xC8D, \"X\"),\n        (0xC8E, \"V\"),\n        (0xC91, \"X\"),\n        (0xC92, \"V\"),\n        (0xCA9, \"X\"),\n        (0xCAA, \"V\"),\n        (0xCB4, \"X\"),\n        (0xCB5, \"V\"),\n        (0xCBA, \"X\"),\n        (0xCBC, \"V\"),\n        (0xCC5, \"X\"),\n        (0xCC6, \"V\"),\n        (0xCC9, \"X\"),\n        (0xCCA, \"V\"),\n        (0xCCE, \"X\"),\n        (0xCD5, \"V\"),\n        (0xCD7, \"X\"),\n        (0xCDD, \"V\"),\n        (0xCDF, \"X\"),\n        (0xCE0, \"V\"),\n        (0xCE4, \"X\"),\n        (0xCE6, \"V\"),\n        (0xCF0, \"X\"),\n        (0xCF1, \"V\"),\n        (0xCF4, \"X\"),\n        (0xD00, \"V\"),\n        (0xD0D, \"X\"),\n        (0xD0E, \"V\"),\n        (0xD11, \"X\"),\n        (0xD12, \"V\"),\n        (0xD45, \"X\"),\n        (0xD46, \"V\"),\n        (0xD49, \"X\"),\n        (0xD4A, \"V\"),\n        (0xD50, \"X\"),\n        (0xD54, \"V\"),\n        (0xD64, \"X\"),\n        (0xD66, \"V\"),\n        (0xD80, \"X\"),\n        (0xD81, \"V\"),\n        (0xD84, \"X\"),\n        (0xD85, \"V\"),\n        (0xD97, \"X\"),\n        (0xD9A, \"V\"),\n        (0xDB2, \"X\"),\n        (0xDB3, \"V\"),\n        (0xDBC, \"X\"),\n        (0xDBD, \"V\"),\n        (0xDBE, \"X\"),\n        (0xDC0, \"V\"),\n        (0xDC7, \"X\"),\n        (0xDCA, \"V\"),\n        (0xDCB, \"X\"),\n        (0xDCF, \"V\"),\n        (0xDD5, \"X\"),\n        (0xDD6, \"V\"),\n        (0xDD7, \"X\"),\n        (0xDD8, \"V\"),\n        (0xDE0, \"X\"),\n        (0xDE6, \"V\"),\n        (0xDF0, \"X\"),\n        (0xDF2, \"V\"),\n        (0xDF5, \"X\"),\n        (0xE01, \"V\"),\n        (0xE33, \"M\", \"\"),\n        (0xE34, \"V\"),\n        (0xE3B, \"X\"),\n        (0xE3F, \"V\"),\n        (0xE5C, \"X\"),\n        (0xE81, \"V\"),\n        (0xE83, \"X\"),\n        (0xE84, \"V\"),\n        (0xE85, \"X\"),\n        (0xE86, \"V\"),\n        (0xE8B, \"X\"),\n        (0xE8C, \"V\"),\n        (0xEA4, \"X\"),\n        (0xEA5, \"V\"),\n        (0xEA6, \"X\"),\n        (0xEA7, \"V\"),\n        (0xEB3, \"M\", \"\"),\n        (0xEB4, \"V\"),\n    ]\n\n\ndef _seg_13() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xEBE, \"X\"),\n        (0xEC0, \"V\"),\n        (0xEC5, \"X\"),\n        (0xEC6, \"V\"),\n        (0xEC7, \"X\"),\n        (0xEC8, \"V\"),\n        (0xECF, \"X\"),\n        (0xED0, \"V\"),\n        (0xEDA, \"X\"),\n        (0xEDC, \"M\", \"\"),\n        (0xEDD, \"M\", \"\"),\n        (0xEDE, \"V\"),\n        (0xEE0, \"X\"),\n        (0xF00, \"V\"),\n        (0xF0C, \"M\", \"\"),\n        (0xF0D, \"V\"),\n        (0xF43, \"M\", \"\"),\n        (0xF44, \"V\"),\n        (0xF48, \"X\"),\n        (0xF49, \"V\"),\n        (0xF4D, \"M\", \"\"),\n        (0xF4E, \"V\"),\n        (0xF52, \"M\", \"\"),\n        (0xF53, \"V\"),\n        (0xF57, \"M\", \"\"),\n        (0xF58, \"V\"),\n        (0xF5C, \"M\", \"\"),\n        (0xF5D, \"V\"),\n        (0xF69, \"M\", \"\"),\n        (0xF6A, \"V\"),\n        (0xF6D, \"X\"),\n        (0xF71, \"V\"),\n        (0xF73, \"M\", \"\"),\n        (0xF74, \"V\"),\n        (0xF75, \"M\", \"\"),\n        (0xF76, \"M\", \"\"),\n        (0xF77, \"M\", \"\"),\n        (0xF78, \"M\", \"\"),\n        (0xF79, \"M\", \"\"),\n        (0xF7A, \"V\"),\n        (0xF81, \"M\", \"\"),\n        (0xF82, \"V\"),\n        (0xF93, \"M\", \"\"),\n        (0xF94, \"V\"),\n        (0xF98, \"X\"),\n        (0xF99, \"V\"),\n        (0xF9D, \"M\", \"\"),\n        (0xF9E, \"V\"),\n        (0xFA2, \"M\", \"\"),\n        (0xFA3, \"V\"),\n        (0xFA7, \"M\", \"\"),\n        (0xFA8, \"V\"),\n        (0xFAC, \"M\", \"\"),\n        (0xFAD, \"V\"),\n        (0xFB9, \"M\", \"\"),\n        (0xFBA, \"V\"),\n        (0xFBD, \"X\"),\n        (0xFBE, \"V\"),\n        (0xFCD, \"X\"),\n        (0xFCE, \"V\"),\n        (0xFDB, \"X\"),\n        (0x1000, \"V\"),\n        (0x10A0, \"X\"),\n        (0x10C7, \"M\", \"\"),\n        (0x10C8, \"X\"),\n        (0x10CD, \"M\", \"\"),\n        (0x10CE, \"X\"),\n        (0x10D0, \"V\"),\n        (0x10FC, \"M\", \"\"),\n        (0x10FD, \"V\"),\n        (0x115F, \"X\"),\n        (0x1161, \"V\"),\n        (0x1249, \"X\"),\n        (0x124A, \"V\"),\n        (0x124E, \"X\"),\n        (0x1250, \"V\"),\n        (0x1257, \"X\"),\n        (0x1258, \"V\"),\n        (0x1259, \"X\"),\n        (0x125A, \"V\"),\n        (0x125E, \"X\"),\n        (0x1260, \"V\"),\n        (0x1289, \"X\"),\n        (0x128A, \"V\"),\n        (0x128E, \"X\"),\n        (0x1290, \"V\"),\n        (0x12B1, \"X\"),\n        (0x12B2, \"V\"),\n        (0x12B6, \"X\"),\n        (0x12B8, \"V\"),\n        (0x12BF, \"X\"),\n        (0x12C0, \"V\"),\n        (0x12C1, \"X\"),\n        (0x12C2, \"V\"),\n        (0x12C6, \"X\"),\n        (0x12C8, \"V\"),\n        (0x12D7, \"X\"),\n        (0x12D8, \"V\"),\n        (0x1311, \"X\"),\n        (0x1312, \"V\"),\n    ]\n\n\ndef _seg_14() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1316, \"X\"),\n        (0x1318, \"V\"),\n        (0x135B, \"X\"),\n        (0x135D, \"V\"),\n        (0x137D, \"X\"),\n        (0x1380, \"V\"),\n        (0x139A, \"X\"),\n        (0x13A0, \"V\"),\n        (0x13F6, \"X\"),\n        (0x13F8, \"M\", \"\"),\n        (0x13F9, \"M\", \"\"),\n        (0x13FA, \"M\", \"\"),\n        (0x13FB, \"M\", \"\"),\n        (0x13FC, \"M\", \"\"),\n        (0x13FD, \"M\", \"\"),\n        (0x13FE, \"X\"),\n        (0x1400, \"V\"),\n        (0x1680, \"X\"),\n        (0x1681, \"V\"),\n        (0x169D, \"X\"),\n        (0x16A0, \"V\"),\n        (0x16F9, \"X\"),\n        (0x1700, \"V\"),\n        (0x1716, \"X\"),\n        (0x171F, \"V\"),\n        (0x1737, \"X\"),\n        (0x1740, \"V\"),\n        (0x1754, \"X\"),\n        (0x1760, \"V\"),\n        (0x176D, \"X\"),\n        (0x176E, \"V\"),\n        (0x1771, \"X\"),\n        (0x1772, \"V\"),\n        (0x1774, \"X\"),\n        (0x1780, \"V\"),\n        (0x17B4, \"X\"),\n        (0x17B6, \"V\"),\n        (0x17DE, \"X\"),\n        (0x17E0, \"V\"),\n        (0x17EA, \"X\"),\n        (0x17F0, \"V\"),\n        (0x17FA, \"X\"),\n        (0x1800, \"V\"),\n        (0x1806, \"X\"),\n        (0x1807, \"V\"),\n        (0x180B, \"I\"),\n        (0x180E, \"X\"),\n        (0x180F, \"I\"),\n        (0x1810, \"V\"),\n        (0x181A, \"X\"),\n        (0x1820, \"V\"),\n        (0x1879, \"X\"),\n        (0x1880, \"V\"),\n        (0x18AB, \"X\"),\n        (0x18B0, \"V\"),\n        (0x18F6, \"X\"),\n        (0x1900, \"V\"),\n        (0x191F, \"X\"),\n        (0x1920, \"V\"),\n        (0x192C, \"X\"),\n        (0x1930, \"V\"),\n        (0x193C, \"X\"),\n        (0x1940, \"V\"),\n        (0x1941, \"X\"),\n        (0x1944, \"V\"),\n        (0x196E, \"X\"),\n        (0x1970, \"V\"),\n        (0x1975, \"X\"),\n        (0x1980, \"V\"),\n        (0x19AC, \"X\"),\n        (0x19B0, \"V\"),\n        (0x19CA, \"X\"),\n        (0x19D0, \"V\"),\n        (0x19DB, \"X\"),\n        (0x19DE, \"V\"),\n        (0x1A1C, \"X\"),\n        (0x1A1E, \"V\"),\n        (0x1A5F, \"X\"),\n        (0x1A60, \"V\"),\n        (0x1A7D, \"X\"),\n        (0x1A7F, \"V\"),\n        (0x1A8A, \"X\"),\n        (0x1A90, \"V\"),\n        (0x1A9A, \"X\"),\n        (0x1AA0, \"V\"),\n        (0x1AAE, \"X\"),\n        (0x1AB0, \"V\"),\n        (0x1ACF, \"X\"),\n        (0x1B00, \"V\"),\n        (0x1B4D, \"X\"),\n        (0x1B50, \"V\"),\n        (0x1B7F, \"X\"),\n        (0x1B80, \"V\"),\n        (0x1BF4, \"X\"),\n        (0x1BFC, \"V\"),\n        (0x1C38, \"X\"),\n        (0x1C3B, \"V\"),\n        (0x1C4A, \"X\"),\n        (0x1C4D, \"V\"),\n        (0x1C80, \"M\", \"\"),\n    ]\n\n\ndef _seg_15() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1C81, \"M\", \"\"),\n        (0x1C82, \"M\", \"\"),\n        (0x1C83, \"M\", \"\"),\n        (0x1C84, \"M\", \"\"),\n        (0x1C86, \"M\", \"\"),\n        (0x1C87, \"M\", \"\"),\n        (0x1C88, \"M\", \"\"),\n        (0x1C89, \"X\"),\n        (0x1C90, \"M\", \"\"),\n        (0x1C91, \"M\", \"\"),\n        (0x1C92, \"M\", \"\"),\n        (0x1C93, \"M\", \"\"),\n        (0x1C94, \"M\", \"\"),\n        (0x1C95, \"M\", \"\"),\n        (0x1C96, \"M\", \"\"),\n        (0x1C97, \"M\", \"\"),\n        (0x1C98, \"M\", \"\"),\n        (0x1C99, \"M\", \"\"),\n        (0x1C9A, \"M\", \"\"),\n        (0x1C9B, \"M\", \"\"),\n        (0x1C9C, \"M\", \"\"),\n        (0x1C9D, \"M\", \"\"),\n        (0x1C9E, \"M\", \"\"),\n        (0x1C9F, \"M\", \"\"),\n        (0x1CA0, \"M\", \"\"),\n        (0x1CA1, \"M\", \"\"),\n        (0x1CA2, \"M\", \"\"),\n        (0x1CA3, \"M\", \"\"),\n        (0x1CA4, \"M\", \"\"),\n        (0x1CA5, \"M\", \"\"),\n        (0x1CA6, \"M\", \"\"),\n        (0x1CA7, \"M\", \"\"),\n        (0x1CA8, \"M\", \"\"),\n        (0x1CA9, \"M\", \"\"),\n        (0x1CAA, \"M\", \"\"),\n        (0x1CAB, \"M\", \"\"),\n        (0x1CAC, \"M\", \"\"),\n        (0x1CAD, \"M\", \"\"),\n        (0x1CAE, \"M\", \"\"),\n        (0x1CAF, \"M\", \"\"),\n        (0x1CB0, \"M\", \"\"),\n        (0x1CB1, \"M\", \"\"),\n        (0x1CB2, \"M\", \"\"),\n        (0x1CB3, \"M\", \"\"),\n        (0x1CB4, \"M\", \"\"),\n        (0x1CB5, \"M\", \"\"),\n        (0x1CB6, \"M\", \"\"),\n        (0x1CB7, \"M\", \"\"),\n        (0x1CB8, \"M\", \"\"),\n        (0x1CB9, \"M\", \"\"),\n        (0x1CBA, \"M\", \"\"),\n        (0x1CBB, \"X\"),\n        (0x1CBD, \"M\", \"\"),\n        (0x1CBE, \"M\", \"\"),\n        (0x1CBF, \"M\", \"\"),\n        (0x1CC0, \"V\"),\n        (0x1CC8, \"X\"),\n        (0x1CD0, \"V\"),\n        (0x1CFB, \"X\"),\n        (0x1D00, \"V\"),\n        (0x1D2C, \"M\", \"a\"),\n        (0x1D2D, \"M\", \"\"),\n        (0x1D2E, \"M\", \"b\"),\n        (0x1D2F, \"V\"),\n        (0x1D30, \"M\", \"d\"),\n        (0x1D31, \"M\", \"e\"),\n        (0x1D32, \"M\", \"\"),\n        (0x1D33, \"M\", \"g\"),\n        (0x1D34, \"M\", \"h\"),\n        (0x1D35, \"M\", \"i\"),\n        (0x1D36, \"M\", \"j\"),\n        (0x1D37, \"M\", \"k\"),\n        (0x1D38, \"M\", \"l\"),\n        (0x1D39, \"M\", \"m\"),\n        (0x1D3A, \"M\", \"n\"),\n        (0x1D3B, \"V\"),\n        (0x1D3C, \"M\", \"o\"),\n        (0x1D3D, \"M\", \"\"),\n        (0x1D3E, \"M\", \"p\"),\n        (0x1D3F, \"M\", \"r\"),\n        (0x1D40, \"M\", \"t\"),\n        (0x1D41, \"M\", \"u\"),\n        (0x1D42, \"M\", \"w\"),\n        (0x1D43, \"M\", \"a\"),\n        (0x1D44, \"M\", \"\"),\n        (0x1D45, \"M\", \"\"),\n        (0x1D46, \"M\", \"\"),\n        (0x1D47, \"M\", \"b\"),\n        (0x1D48, \"M\", \"d\"),\n        (0x1D49, \"M\", \"e\"),\n        (0x1D4A, \"M\", \"\"),\n        (0x1D4B, \"M\", \"\"),\n        (0x1D4C, \"M\", \"\"),\n        (0x1D4D, \"M\", \"g\"),\n        (0x1D4E, \"V\"),\n        (0x1D4F, \"M\", \"k\"),\n        (0x1D50, \"M\", \"m\"),\n        (0x1D51, \"M\", \"\"),\n        (0x1D52, \"M\", \"o\"),\n        (0x1D53, \"M\", \"\"),\n    ]\n\n\ndef _seg_16() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1D54, \"M\", \"\"),\n        (0x1D55, \"M\", \"\"),\n        (0x1D56, \"M\", \"p\"),\n        (0x1D57, \"M\", \"t\"),\n        (0x1D58, \"M\", \"u\"),\n        (0x1D59, \"M\", \"\"),\n        (0x1D5A, \"M\", \"\"),\n        (0x1D5B, \"M\", \"v\"),\n        (0x1D5C, \"M\", \"\"),\n        (0x1D5D, \"M\", \"\"),\n        (0x1D5E, \"M\", \"\"),\n        (0x1D5F, \"M\", \"\"),\n        (0x1D60, \"M\", \"\"),\n        (0x1D61, \"M\", \"\"),\n        (0x1D62, \"M\", \"i\"),\n        (0x1D63, \"M\", \"r\"),\n        (0x1D64, \"M\", \"u\"),\n        (0x1D65, \"M\", \"v\"),\n        (0x1D66, \"M\", \"\"),\n        (0x1D67, \"M\", \"\"),\n        (0x1D68, \"M\", \"\"),\n        (0x1D69, \"M\", \"\"),\n        (0x1D6A, \"M\", \"\"),\n        (0x1D6B, \"V\"),\n        (0x1D78, \"M\", \"\"),\n        (0x1D79, \"V\"),\n        (0x1D9B, \"M\", \"\"),\n        (0x1D9C, \"M\", \"c\"),\n        (0x1D9D, \"M\", \"\"),\n        (0x1D9E, \"M\", \"\"),\n        (0x1D9F, \"M\", \"\"),\n        (0x1DA0, \"M\", \"f\"),\n        (0x1DA1, \"M\", \"\"),\n        (0x1DA2, \"M\", \"\"),\n        (0x1DA3, \"M\", \"\"),\n        (0x1DA4, \"M\", \"\"),\n        (0x1DA5, \"M\", \"\"),\n        (0x1DA6, \"M\", \"\"),\n        (0x1DA7, \"M\", \"\"),\n        (0x1DA8, \"M\", \"\"),\n        (0x1DA9, \"M\", \"\"),\n        (0x1DAA, \"M\", \"\"),\n        (0x1DAB, \"M\", \"\"),\n        (0x1DAC, \"M\", \"\"),\n        (0x1DAD, \"M\", \"\"),\n        (0x1DAE, \"M\", \"\"),\n        (0x1DAF, \"M\", \"\"),\n        (0x1DB0, \"M\", \"\"),\n        (0x1DB1, \"M\", \"\"),\n        (0x1DB2, \"M\", \"\"),\n        (0x1DB3, \"M\", \"\"),\n        (0x1DB4, \"M\", \"\"),\n        (0x1DB5, \"M\", \"\"),\n        (0x1DB6, \"M\", \"\"),\n        (0x1DB7, \"M\", \"\"),\n        (0x1DB8, \"M\", \"\"),\n        (0x1DB9, \"M\", \"\"),\n        (0x1DBA, \"M\", \"\"),\n        (0x1DBB, \"M\", \"z\"),\n        (0x1DBC, \"M\", \"\"),\n        (0x1DBD, \"M\", \"\"),\n        (0x1DBE, \"M\", \"\"),\n        (0x1DBF, \"M\", \"\"),\n        (0x1DC0, \"V\"),\n        (0x1E00, \"M\", \"\"),\n        (0x1E01, \"V\"),\n        (0x1E02, \"M\", \"\"),\n        (0x1E03, \"V\"),\n        (0x1E04, \"M\", \"\"),\n        (0x1E05, \"V\"),\n        (0x1E06, \"M\", \"\"),\n        (0x1E07, \"V\"),\n        (0x1E08, \"M\", \"\"),\n        (0x1E09, \"V\"),\n        (0x1E0A, \"M\", \"\"),\n        (0x1E0B, \"V\"),\n        (0x1E0C, \"M\", \"\"),\n        (0x1E0D, \"V\"),\n        (0x1E0E, \"M\", \"\"),\n        (0x1E0F, \"V\"),\n        (0x1E10, \"M\", \"\"),\n        (0x1E11, \"V\"),\n        (0x1E12, \"M\", \"\"),\n        (0x1E13, \"V\"),\n        (0x1E14, \"M\", \"\"),\n        (0x1E15, \"V\"),\n        (0x1E16, \"M\", \"\"),\n        (0x1E17, \"V\"),\n        (0x1E18, \"M\", \"\"),\n        (0x1E19, \"V\"),\n        (0x1E1A, \"M\", \"\"),\n        (0x1E1B, \"V\"),\n        (0x1E1C, \"M\", \"\"),\n        (0x1E1D, \"V\"),\n        (0x1E1E, \"M\", \"\"),\n        (0x1E1F, \"V\"),\n        (0x1E20, \"M\", \"\"),\n        (0x1E21, \"V\"),\n        (0x1E22, \"M\", \"\"),\n        (0x1E23, \"V\"),\n    ]\n\n\ndef _seg_17() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1E24, \"M\", \"\"),\n        (0x1E25, \"V\"),\n        (0x1E26, \"M\", \"\"),\n        (0x1E27, \"V\"),\n        (0x1E28, \"M\", \"\"),\n        (0x1E29, \"V\"),\n        (0x1E2A, \"M\", \"\"),\n        (0x1E2B, \"V\"),\n        (0x1E2C, \"M\", \"\"),\n        (0x1E2D, \"V\"),\n        (0x1E2E, \"M\", \"\"),\n        (0x1E2F, \"V\"),\n        (0x1E30, \"M\", \"\"),\n        (0x1E31, \"V\"),\n        (0x1E32, \"M\", \"\"),\n        (0x1E33, \"V\"),\n        (0x1E34, \"M\", \"\"),\n        (0x1E35, \"V\"),\n        (0x1E36, \"M\", \"\"),\n        (0x1E37, \"V\"),\n        (0x1E38, \"M\", \"\"),\n        (0x1E39, \"V\"),\n        (0x1E3A, \"M\", \"\"),\n        (0x1E3B, \"V\"),\n        (0x1E3C, \"M\", \"\"),\n        (0x1E3D, \"V\"),\n        (0x1E3E, \"M\", \"\"),\n        (0x1E3F, \"V\"),\n        (0x1E40, \"M\", \"\"),\n        (0x1E41, \"V\"),\n        (0x1E42, \"M\", \"\"),\n        (0x1E43, \"V\"),\n        (0x1E44, \"M\", \"\"),\n        (0x1E45, \"V\"),\n        (0x1E46, \"M\", \"\"),\n        (0x1E47, \"V\"),\n        (0x1E48, \"M\", \"\"),\n        (0x1E49, \"V\"),\n        (0x1E4A, \"M\", \"\"),\n        (0x1E4B, \"V\"),\n        (0x1E4C, \"M\", \"\"),\n        (0x1E4D, \"V\"),\n        (0x1E4E, \"M\", \"\"),\n        (0x1E4F, \"V\"),\n        (0x1E50, \"M\", \"\"),\n        (0x1E51, \"V\"),\n        (0x1E52, \"M\", \"\"),\n        (0x1E53, \"V\"),\n        (0x1E54, \"M\", \"\"),\n        (0x1E55, \"V\"),\n        (0x1E56, \"M\", \"\"),\n        (0x1E57, \"V\"),\n        (0x1E58, \"M\", \"\"),\n        (0x1E59, \"V\"),\n        (0x1E5A, \"M\", \"\"),\n        (0x1E5B, \"V\"),\n        (0x1E5C, \"M\", \"\"),\n        (0x1E5D, \"V\"),\n        (0x1E5E, \"M\", \"\"),\n        (0x1E5F, \"V\"),\n        (0x1E60, \"M\", \"\"),\n        (0x1E61, \"V\"),\n        (0x1E62, \"M\", \"\"),\n        (0x1E63, \"V\"),\n        (0x1E64, \"M\", \"\"),\n        (0x1E65, \"V\"),\n        (0x1E66, \"M\", \"\"),\n        (0x1E67, \"V\"),\n        (0x1E68, \"M\", \"\"),\n        (0x1E69, \"V\"),\n        (0x1E6A, \"M\", \"\"),\n        (0x1E6B, \"V\"),\n        (0x1E6C, \"M\", \"\"),\n        (0x1E6D, \"V\"),\n        (0x1E6E, \"M\", \"\"),\n        (0x1E6F, \"V\"),\n        (0x1E70, \"M\", \"\"),\n        (0x1E71, \"V\"),\n        (0x1E72, \"M\", \"\"),\n        (0x1E73, \"V\"),\n        (0x1E74, \"M\", \"\"),\n        (0x1E75, \"V\"),\n        (0x1E76, \"M\", \"\"),\n        (0x1E77, \"V\"),\n        (0x1E78, \"M\", \"\"),\n        (0x1E79, \"V\"),\n        (0x1E7A, \"M\", \"\"),\n        (0x1E7B, \"V\"),\n        (0x1E7C, \"M\", \"\"),\n        (0x1E7D, \"V\"),\n        (0x1E7E, \"M\", \"\"),\n        (0x1E7F, \"V\"),\n        (0x1E80, \"M\", \"\"),\n        (0x1E81, \"V\"),\n        (0x1E82, \"M\", \"\"),\n        (0x1E83, \"V\"),\n        (0x1E84, \"M\", \"\"),\n        (0x1E85, \"V\"),\n        (0x1E86, \"M\", \"\"),\n        (0x1E87, \"V\"),\n    ]\n\n\ndef _seg_18() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1E88, \"M\", \"\"),\n        (0x1E89, \"V\"),\n        (0x1E8A, \"M\", \"\"),\n        (0x1E8B, \"V\"),\n        (0x1E8C, \"M\", \"\"),\n        (0x1E8D, \"V\"),\n        (0x1E8E, \"M\", \"\"),\n        (0x1E8F, \"V\"),\n        (0x1E90, \"M\", \"\"),\n        (0x1E91, \"V\"),\n        (0x1E92, \"M\", \"\"),\n        (0x1E93, \"V\"),\n        (0x1E94, \"M\", \"\"),\n        (0x1E95, \"V\"),\n        (0x1E9A, \"M\", \"a\"),\n        (0x1E9B, \"M\", \"\"),\n        (0x1E9C, \"V\"),\n        (0x1E9E, \"M\", \"\"),\n        (0x1E9F, \"V\"),\n        (0x1EA0, \"M\", \"\"),\n        (0x1EA1, \"V\"),\n        (0x1EA2, \"M\", \"\"),\n        (0x1EA3, \"V\"),\n        (0x1EA4, \"M\", \"\"),\n        (0x1EA5, \"V\"),\n        (0x1EA6, \"M\", \"\"),\n        (0x1EA7, \"V\"),\n        (0x1EA8, \"M\", \"\"),\n        (0x1EA9, \"V\"),\n        (0x1EAA, \"M\", \"\"),\n        (0x1EAB, \"V\"),\n        (0x1EAC, \"M\", \"\"),\n        (0x1EAD, \"V\"),\n        (0x1EAE, \"M\", \"\"),\n        (0x1EAF, \"V\"),\n        (0x1EB0, \"M\", \"\"),\n        (0x1EB1, \"V\"),\n        (0x1EB2, \"M\", \"\"),\n        (0x1EB3, \"V\"),\n        (0x1EB4, \"M\", \"\"),\n        (0x1EB5, \"V\"),\n        (0x1EB6, \"M\", \"\"),\n        (0x1EB7, \"V\"),\n        (0x1EB8, \"M\", \"\"),\n        (0x1EB9, \"V\"),\n        (0x1EBA, \"M\", \"\"),\n        (0x1EBB, \"V\"),\n        (0x1EBC, \"M\", \"\"),\n        (0x1EBD, \"V\"),\n        (0x1EBE, \"M\", \"\"),\n        (0x1EBF, \"V\"),\n        (0x1EC0, \"M\", \"\"),\n        (0x1EC1, \"V\"),\n        (0x1EC2, \"M\", \"\"),\n        (0x1EC3, \"V\"),\n        (0x1EC4, \"M\", \"\"),\n        (0x1EC5, \"V\"),\n        (0x1EC6, \"M\", \"\"),\n        (0x1EC7, \"V\"),\n        (0x1EC8, \"M\", \"\"),\n        (0x1EC9, \"V\"),\n        (0x1ECA, \"M\", \"\"),\n        (0x1ECB, \"V\"),\n        (0x1ECC, \"M\", \"\"),\n        (0x1ECD, \"V\"),\n        (0x1ECE, \"M\", \"\"),\n        (0x1ECF, \"V\"),\n        (0x1ED0, \"M\", \"\"),\n        (0x1ED1, \"V\"),\n        (0x1ED2, \"M\", \"\"),\n        (0x1ED3, \"V\"),\n        (0x1ED4, \"M\", \"\"),\n        (0x1ED5, \"V\"),\n        (0x1ED6, \"M\", \"\"),\n        (0x1ED7, \"V\"),\n        (0x1ED8, \"M\", \"\"),\n        (0x1ED9, \"V\"),\n        (0x1EDA, \"M\", \"\"),\n        (0x1EDB, \"V\"),\n        (0x1EDC, \"M\", \"\"),\n        (0x1EDD, \"V\"),\n        (0x1EDE, \"M\", \"\"),\n        (0x1EDF, \"V\"),\n        (0x1EE0, \"M\", \"\"),\n        (0x1EE1, \"V\"),\n        (0x1EE2, \"M\", \"\"),\n        (0x1EE3, \"V\"),\n        (0x1EE4, \"M\", \"\"),\n        (0x1EE5, \"V\"),\n        (0x1EE6, \"M\", \"\"),\n        (0x1EE7, \"V\"),\n        (0x1EE8, \"M\", \"\"),\n        (0x1EE9, \"V\"),\n        (0x1EEA, \"M\", \"\"),\n        (0x1EEB, \"V\"),\n        (0x1EEC, \"M\", \"\"),\n        (0x1EED, \"V\"),\n        (0x1EEE, \"M\", \"\"),\n        (0x1EEF, \"V\"),\n        (0x1EF0, \"M\", \"\"),\n    ]\n\n\ndef _seg_19() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1EF1, \"V\"),\n        (0x1EF2, \"M\", \"\"),\n        (0x1EF3, \"V\"),\n        (0x1EF4, \"M\", \"\"),\n        (0x1EF5, \"V\"),\n        (0x1EF6, \"M\", \"\"),\n        (0x1EF7, \"V\"),\n        (0x1EF8, \"M\", \"\"),\n        (0x1EF9, \"V\"),\n        (0x1EFA, \"M\", \"\"),\n        (0x1EFB, \"V\"),\n        (0x1EFC, \"M\", \"\"),\n        (0x1EFD, \"V\"),\n        (0x1EFE, \"M\", \"\"),\n        (0x1EFF, \"V\"),\n        (0x1F08, \"M\", \"\"),\n        (0x1F09, \"M\", \"\"),\n        (0x1F0A, \"M\", \"\"),\n        (0x1F0B, \"M\", \"\"),\n        (0x1F0C, \"M\", \"\"),\n        (0x1F0D, \"M\", \"\"),\n        (0x1F0E, \"M\", \"\"),\n        (0x1F0F, \"M\", \"\"),\n        (0x1F10, \"V\"),\n        (0x1F16, \"X\"),\n        (0x1F18, \"M\", \"\"),\n        (0x1F19, \"M\", \"\"),\n        (0x1F1A, \"M\", \"\"),\n        (0x1F1B, \"M\", \"\"),\n        (0x1F1C, \"M\", \"\"),\n        (0x1F1D, \"M\", \"\"),\n        (0x1F1E, \"X\"),\n        (0x1F20, \"V\"),\n        (0x1F28, \"M\", \"\"),\n        (0x1F29, \"M\", \"\"),\n        (0x1F2A, \"M\", \"\"),\n        (0x1F2B, \"M\", \"\"),\n        (0x1F2C, \"M\", \"\"),\n        (0x1F2D, \"M\", \"\"),\n        (0x1F2E, \"M\", \"\"),\n        (0x1F2F, \"M\", \"\"),\n        (0x1F30, \"V\"),\n        (0x1F38, \"M\", \"\"),\n        (0x1F39, \"M\", \"\"),\n        (0x1F3A, \"M\", \"\"),\n        (0x1F3B, \"M\", \"\"),\n        (0x1F3C, \"M\", \"\"),\n        (0x1F3D, \"M\", \"\"),\n        (0x1F3E, \"M\", \"\"),\n        (0x1F3F, \"M\", \"\"),\n        (0x1F40, \"V\"),\n        (0x1F46, \"X\"),\n        (0x1F48, \"M\", \"\"),\n        (0x1F49, \"M\", \"\"),\n        (0x1F4A, \"M\", \"\"),\n        (0x1F4B, \"M\", \"\"),\n        (0x1F4C, \"M\", \"\"),\n        (0x1F4D, \"M\", \"\"),\n        (0x1F4E, \"X\"),\n        (0x1F50, \"V\"),\n        (0x1F58, \"X\"),\n        (0x1F59, \"M\", \"\"),\n        (0x1F5A, \"X\"),\n        (0x1F5B, \"M\", \"\"),\n        (0x1F5C, \"X\"),\n        (0x1F5D, \"M\", \"\"),\n        (0x1F5E, \"X\"),\n        (0x1F5F, \"M\", \"\"),\n        (0x1F60, \"V\"),\n        (0x1F68, \"M\", \"\"),\n        (0x1F69, \"M\", \"\"),\n        (0x1F6A, \"M\", \"\"),\n        (0x1F6B, \"M\", \"\"),\n        (0x1F6C, \"M\", \"\"),\n        (0x1F6D, \"M\", \"\"),\n        (0x1F6E, \"M\", \"\"),\n        (0x1F6F, \"M\", \"\"),\n        (0x1F70, \"V\"),\n        (0x1F71, \"M\", \"\"),\n        (0x1F72, \"V\"),\n        (0x1F73, \"M\", \"\"),\n        (0x1F74, \"V\"),\n        (0x1F75, \"M\", \"\"),\n        (0x1F76, \"V\"),\n        (0x1F77, \"M\", \"\"),\n        (0x1F78, \"V\"),\n        (0x1F79, \"M\", \"\"),\n        (0x1F7A, \"V\"),\n        (0x1F7B, \"M\", \"\"),\n        (0x1F7C, \"V\"),\n        (0x1F7D, \"M\", \"\"),\n        (0x1F7E, \"X\"),\n        (0x1F80, \"M\", \"\"),\n        (0x1F81, \"M\", \"\"),\n        (0x1F82, \"M\", \"\"),\n        (0x1F83, \"M\", \"\"),\n        (0x1F84, \"M\", \"\"),\n        (0x1F85, \"M\", \"\"),\n        (0x1F86, \"M\", \"\"),\n        (0x1F87, \"M\", \"\"),\n    ]\n\n\ndef _seg_20() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1F88, \"M\", \"\"),\n        (0x1F89, \"M\", \"\"),\n        (0x1F8A, \"M\", \"\"),\n        (0x1F8B, \"M\", \"\"),\n        (0x1F8C, \"M\", \"\"),\n        (0x1F8D, \"M\", \"\"),\n        (0x1F8E, \"M\", \"\"),\n        (0x1F8F, \"M\", \"\"),\n        (0x1F90, \"M\", \"\"),\n        (0x1F91, \"M\", \"\"),\n        (0x1F92, \"M\", \"\"),\n        (0x1F93, \"M\", \"\"),\n        (0x1F94, \"M\", \"\"),\n        (0x1F95, \"M\", \"\"),\n        (0x1F96, \"M\", \"\"),\n        (0x1F97, \"M\", \"\"),\n        (0x1F98, \"M\", \"\"),\n        (0x1F99, \"M\", \"\"),\n        (0x1F9A, \"M\", \"\"),\n        (0x1F9B, \"M\", \"\"),\n        (0x1F9C, \"M\", \"\"),\n        (0x1F9D, \"M\", \"\"),\n        (0x1F9E, \"M\", \"\"),\n        (0x1F9F, \"M\", \"\"),\n        (0x1FA0, \"M\", \"\"),\n        (0x1FA1, \"M\", \"\"),\n        (0x1FA2, \"M\", \"\"),\n        (0x1FA3, \"M\", \"\"),\n        (0x1FA4, \"M\", \"\"),\n        (0x1FA5, \"M\", \"\"),\n        (0x1FA6, \"M\", \"\"),\n        (0x1FA7, \"M\", \"\"),\n        (0x1FA8, \"M\", \"\"),\n        (0x1FA9, \"M\", \"\"),\n        (0x1FAA, \"M\", \"\"),\n        (0x1FAB, \"M\", \"\"),\n        (0x1FAC, \"M\", \"\"),\n        (0x1FAD, \"M\", \"\"),\n        (0x1FAE, \"M\", \"\"),\n        (0x1FAF, \"M\", \"\"),\n        (0x1FB0, \"V\"),\n        (0x1FB2, \"M\", \"\"),\n        (0x1FB3, \"M\", \"\"),\n        (0x1FB4, \"M\", \"\"),\n        (0x1FB5, \"X\"),\n        (0x1FB6, \"V\"),\n        (0x1FB7, \"M\", \"\"),\n        (0x1FB8, \"M\", \"\"),\n        (0x1FB9, \"M\", \"\"),\n        (0x1FBA, \"M\", \"\"),\n        (0x1FBB, \"M\", \"\"),\n        (0x1FBC, \"M\", \"\"),\n        (0x1FBD, \"3\", \" \"),\n        (0x1FBE, \"M\", \"\"),\n        (0x1FBF, \"3\", \" \"),\n        (0x1FC0, \"3\", \" \"),\n        (0x1FC1, \"3\", \" \"),\n        (0x1FC2, \"M\", \"\"),\n        (0x1FC3, \"M\", \"\"),\n        (0x1FC4, \"M\", \"\"),\n        (0x1FC5, \"X\"),\n        (0x1FC6, \"V\"),\n        (0x1FC7, \"M\", \"\"),\n        (0x1FC8, \"M\", \"\"),\n        (0x1FC9, \"M\", \"\"),\n        (0x1FCA, \"M\", \"\"),\n        (0x1FCB, \"M\", \"\"),\n        (0x1FCC, \"M\", \"\"),\n        (0x1FCD, \"3\", \" \"),\n        (0x1FCE, \"3\", \" \"),\n        (0x1FCF, \"3\", \" \"),\n        (0x1FD0, \"V\"),\n        (0x1FD3, \"M\", \"\"),\n        (0x1FD4, \"X\"),\n        (0x1FD6, \"V\"),\n        (0x1FD8, \"M\", \"\"),\n        (0x1FD9, \"M\", \"\"),\n        (0x1FDA, \"M\", \"\"),\n        (0x1FDB, \"M\", \"\"),\n        (0x1FDC, \"X\"),\n        (0x1FDD, \"3\", \" \"),\n        (0x1FDE, \"3\", \" \"),\n        (0x1FDF, \"3\", \" \"),\n        (0x1FE0, \"V\"),\n        (0x1FE3, \"M\", \"\"),\n        (0x1FE4, \"V\"),\n        (0x1FE8, \"M\", \"\"),\n        (0x1FE9, \"M\", \"\"),\n        (0x1FEA, \"M\", \"\"),\n        (0x1FEB, \"M\", \"\"),\n        (0x1FEC, \"M\", \"\"),\n        (0x1FED, \"3\", \" \"),\n        (0x1FEE, \"3\", \" \"),\n        (0x1FEF, \"3\", \"`\"),\n        (0x1FF0, \"X\"),\n        (0x1FF2, \"M\", \"\"),\n        (0x1FF3, \"M\", \"\"),\n        (0x1FF4, \"M\", \"\"),\n        (0x1FF5, \"X\"),\n        (0x1FF6, \"V\"),\n    ]\n\n\ndef _seg_21() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1FF7, \"M\", \"\"),\n        (0x1FF8, \"M\", \"\"),\n        (0x1FF9, \"M\", \"\"),\n        (0x1FFA, \"M\", \"\"),\n        (0x1FFB, \"M\", \"\"),\n        (0x1FFC, \"M\", \"\"),\n        (0x1FFD, \"3\", \" \"),\n        (0x1FFE, \"3\", \" \"),\n        (0x1FFF, \"X\"),\n        (0x2000, \"3\", \" \"),\n        (0x200B, \"I\"),\n        (0x200C, \"D\", \"\"),\n        (0x200E, \"X\"),\n        (0x2010, \"V\"),\n        (0x2011, \"M\", \"\"),\n        (0x2012, \"V\"),\n        (0x2017, \"3\", \" \"),\n        (0x2018, \"V\"),\n        (0x2024, \"X\"),\n        (0x2027, \"V\"),\n        (0x2028, \"X\"),\n        (0x202F, \"3\", \" \"),\n        (0x2030, \"V\"),\n        (0x2033, \"M\", \"\"),\n        (0x2034, \"M\", \"\"),\n        (0x2035, \"V\"),\n        (0x2036, \"M\", \"\"),\n        (0x2037, \"M\", \"\"),\n        (0x2038, \"V\"),\n        (0x203C, \"3\", \"!!\"),\n        (0x203D, \"V\"),\n        (0x203E, \"3\", \" \"),\n        (0x203F, \"V\"),\n        (0x2047, \"3\", \"??\"),\n        (0x2048, \"3\", \"?!\"),\n        (0x2049, \"3\", \"!?\"),\n        (0x204A, \"V\"),\n        (0x2057, \"M\", \"\"),\n        (0x2058, \"V\"),\n        (0x205F, \"3\", \" \"),\n        (0x2060, \"I\"),\n        (0x2061, \"X\"),\n        (0x2064, \"I\"),\n        (0x2065, \"X\"),\n        (0x2070, \"M\", \"0\"),\n        (0x2071, \"M\", \"i\"),\n        (0x2072, \"X\"),\n        (0x2074, \"M\", \"4\"),\n        (0x2075, \"M\", \"5\"),\n        (0x2076, \"M\", \"6\"),\n        (0x2077, \"M\", \"7\"),\n        (0x2078, \"M\", \"8\"),\n        (0x2079, \"M\", \"9\"),\n        (0x207A, \"3\", \"+\"),\n        (0x207B, \"M\", \"\"),\n        (0x207C, \"3\", \"=\"),\n        (0x207D, \"3\", \"(\"),\n        (0x207E, \"3\", \")\"),\n        (0x207F, \"M\", \"n\"),\n        (0x2080, \"M\", \"0\"),\n        (0x2081, \"M\", \"1\"),\n        (0x2082, \"M\", \"2\"),\n        (0x2083, \"M\", \"3\"),\n        (0x2084, \"M\", \"4\"),\n        (0x2085, \"M\", \"5\"),\n        (0x2086, \"M\", \"6\"),\n        (0x2087, \"M\", \"7\"),\n        (0x2088, \"M\", \"8\"),\n        (0x2089, \"M\", \"9\"),\n        (0x208A, \"3\", \"+\"),\n        (0x208B, \"M\", \"\"),\n        (0x208C, \"3\", \"=\"),\n        (0x208D, \"3\", \"(\"),\n        (0x208E, \"3\", \")\"),\n        (0x208F, \"X\"),\n        (0x2090, \"M\", \"a\"),\n        (0x2091, \"M\", \"e\"),\n        (0x2092, \"M\", \"o\"),\n        (0x2093, \"M\", \"x\"),\n        (0x2094, \"M\", \"\"),\n        (0x2095, \"M\", \"h\"),\n        (0x2096, \"M\", \"k\"),\n        (0x2097, \"M\", \"l\"),\n        (0x2098, \"M\", \"m\"),\n        (0x2099, \"M\", \"n\"),\n        (0x209A, \"M\", \"p\"),\n        (0x209B, \"M\", \"s\"),\n        (0x209C, \"M\", \"t\"),\n        (0x209D, \"X\"),\n        (0x20A0, \"V\"),\n        (0x20A8, \"M\", \"rs\"),\n        (0x20A9, \"V\"),\n        (0x20C1, \"X\"),\n        (0x20D0, \"V\"),\n        (0x20F1, \"X\"),\n        (0x2100, \"3\", \"a/c\"),\n        (0x2101, \"3\", \"a/s\"),\n        (0x2102, \"M\", \"c\"),\n        (0x2103, \"M\", \"c\"),\n        (0x2104, \"V\"),\n    ]\n\n\ndef _seg_22() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x2105, \"3\", \"c/o\"),\n        (0x2106, \"3\", \"c/u\"),\n        (0x2107, \"M\", \"\"),\n        (0x2108, \"V\"),\n        (0x2109, \"M\", \"f\"),\n        (0x210A, \"M\", \"g\"),\n        (0x210B, \"M\", \"h\"),\n        (0x210F, \"M\", \"\"),\n        (0x2110, \"M\", \"i\"),\n        (0x2112, \"M\", \"l\"),\n        (0x2114, \"V\"),\n        (0x2115, \"M\", \"n\"),\n        (0x2116, \"M\", \"no\"),\n        (0x2117, \"V\"),\n        (0x2119, \"M\", \"p\"),\n        (0x211A, \"M\", \"q\"),\n        (0x211B, \"M\", \"r\"),\n        (0x211E, \"V\"),\n        (0x2120, \"M\", \"sm\"),\n        (0x2121, \"M\", \"tel\"),\n        (0x2122, \"M\", \"tm\"),\n        (0x2123, \"V\"),\n        (0x2124, \"M\", \"z\"),\n        (0x2125, \"V\"),\n        (0x2126, \"M\", \"\"),\n        (0x2127, \"V\"),\n        (0x2128, \"M\", \"z\"),\n        (0x2129, \"V\"),\n        (0x212A, \"M\", \"k\"),\n        (0x212B, \"M\", \"\"),\n        (0x212C, \"M\", \"b\"),\n        (0x212D, \"M\", \"c\"),\n        (0x212E, \"V\"),\n        (0x212F, \"M\", \"e\"),\n        (0x2131, \"M\", \"f\"),\n        (0x2132, \"X\"),\n        (0x2133, \"M\", \"m\"),\n        (0x2134, \"M\", \"o\"),\n        (0x2135, \"M\", \"\"),\n        (0x2136, \"M\", \"\"),\n        (0x2137, \"M\", \"\"),\n        (0x2138, \"M\", \"\"),\n        (0x2139, \"M\", \"i\"),\n        (0x213A, \"V\"),\n        (0x213B, \"M\", \"fax\"),\n        (0x213C, \"M\", \"\"),\n        (0x213D, \"M\", \"\"),\n        (0x213F, \"M\", \"\"),\n        (0x2140, \"M\", \"\"),\n        (0x2141, \"V\"),\n        (0x2145, \"M\", \"d\"),\n        (0x2147, \"M\", \"e\"),\n        (0x2148, \"M\", \"i\"),\n        (0x2149, \"M\", \"j\"),\n        (0x214A, \"V\"),\n        (0x2150, \"M\", \"17\"),\n        (0x2151, \"M\", \"19\"),\n        (0x2152, \"M\", \"110\"),\n        (0x2153, \"M\", \"13\"),\n        (0x2154, \"M\", \"23\"),\n        (0x2155, \"M\", \"15\"),\n        (0x2156, \"M\", \"25\"),\n        (0x2157, \"M\", \"35\"),\n        (0x2158, \"M\", \"45\"),\n        (0x2159, \"M\", \"16\"),\n        (0x215A, \"M\", \"56\"),\n        (0x215B, \"M\", \"18\"),\n        (0x215C, \"M\", \"38\"),\n        (0x215D, \"M\", \"58\"),\n        (0x215E, \"M\", \"78\"),\n        (0x215F, \"M\", \"1\"),\n        (0x2160, \"M\", \"i\"),\n        (0x2161, \"M\", \"ii\"),\n        (0x2162, \"M\", \"iii\"),\n        (0x2163, \"M\", \"iv\"),\n        (0x2164, \"M\", \"v\"),\n        (0x2165, \"M\", \"vi\"),\n        (0x2166, \"M\", \"vii\"),\n        (0x2167, \"M\", \"viii\"),\n        (0x2168, \"M\", \"ix\"),\n        (0x2169, \"M\", \"x\"),\n        (0x216A, \"M\", \"xi\"),\n        (0x216B, \"M\", \"xii\"),\n        (0x216C, \"M\", \"l\"),\n        (0x216D, \"M\", \"c\"),\n        (0x216E, \"M\", \"d\"),\n        (0x216F, \"M\", \"m\"),\n        (0x2170, \"M\", \"i\"),\n        (0x2171, \"M\", \"ii\"),\n        (0x2172, \"M\", \"iii\"),\n        (0x2173, \"M\", \"iv\"),\n        (0x2174, \"M\", \"v\"),\n        (0x2175, \"M\", \"vi\"),\n        (0x2176, \"M\", \"vii\"),\n        (0x2177, \"M\", \"viii\"),\n        (0x2178, \"M\", \"ix\"),\n        (0x2179, \"M\", \"x\"),\n        (0x217A, \"M\", \"xi\"),\n        (0x217B, \"M\", \"xii\"),\n        (0x217C, \"M\", \"l\"),\n    ]\n\n\ndef _seg_23() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x217D, \"M\", \"c\"),\n        (0x217E, \"M\", \"d\"),\n        (0x217F, \"M\", \"m\"),\n        (0x2180, \"V\"),\n        (0x2183, \"X\"),\n        (0x2184, \"V\"),\n        (0x2189, \"M\", \"03\"),\n        (0x218A, \"V\"),\n        (0x218C, \"X\"),\n        (0x2190, \"V\"),\n        (0x222C, \"M\", \"\"),\n        (0x222D, \"M\", \"\"),\n        (0x222E, \"V\"),\n        (0x222F, \"M\", \"\"),\n        (0x2230, \"M\", \"\"),\n        (0x2231, \"V\"),\n        (0x2329, \"M\", \"\"),\n        (0x232A, \"M\", \"\"),\n        (0x232B, \"V\"),\n        (0x2427, \"X\"),\n        (0x2440, \"V\"),\n        (0x244B, \"X\"),\n        (0x2460, \"M\", \"1\"),\n        (0x2461, \"M\", \"2\"),\n        (0x2462, \"M\", \"3\"),\n        (0x2463, \"M\", \"4\"),\n        (0x2464, \"M\", \"5\"),\n        (0x2465, \"M\", \"6\"),\n        (0x2466, \"M\", \"7\"),\n        (0x2467, \"M\", \"8\"),\n        (0x2468, \"M\", \"9\"),\n        (0x2469, \"M\", \"10\"),\n        (0x246A, \"M\", \"11\"),\n        (0x246B, \"M\", \"12\"),\n        (0x246C, \"M\", \"13\"),\n        (0x246D, \"M\", \"14\"),\n        (0x246E, \"M\", \"15\"),\n        (0x246F, \"M\", \"16\"),\n        (0x2470, \"M\", \"17\"),\n        (0x2471, \"M\", \"18\"),\n        (0x2472, \"M\", \"19\"),\n        (0x2473, \"M\", \"20\"),\n        (0x2474, \"3\", \"(1)\"),\n        (0x2475, \"3\", \"(2)\"),\n        (0x2476, \"3\", \"(3)\"),\n        (0x2477, \"3\", \"(4)\"),\n        (0x2478, \"3\", \"(5)\"),\n        (0x2479, \"3\", \"(6)\"),\n        (0x247A, \"3\", \"(7)\"),\n        (0x247B, \"3\", \"(8)\"),\n        (0x247C, \"3\", \"(9)\"),\n        (0x247D, \"3\", \"(10)\"),\n        (0x247E, \"3\", \"(11)\"),\n        (0x247F, \"3\", \"(12)\"),\n        (0x2480, \"3\", \"(13)\"),\n        (0x2481, \"3\", \"(14)\"),\n        (0x2482, \"3\", \"(15)\"),\n        (0x2483, \"3\", \"(16)\"),\n        (0x2484, \"3\", \"(17)\"),\n        (0x2485, \"3\", \"(18)\"),\n        (0x2486, \"3\", \"(19)\"),\n        (0x2487, \"3\", \"(20)\"),\n        (0x2488, \"X\"),\n        (0x249C, \"3\", \"(a)\"),\n        (0x249D, \"3\", \"(b)\"),\n        (0x249E, \"3\", \"(c)\"),\n        (0x249F, \"3\", \"(d)\"),\n        (0x24A0, \"3\", \"(e)\"),\n        (0x24A1, \"3\", \"(f)\"),\n        (0x24A2, \"3\", \"(g)\"),\n        (0x24A3, \"3\", \"(h)\"),\n        (0x24A4, \"3\", \"(i)\"),\n        (0x24A5, \"3\", \"(j)\"),\n        (0x24A6, \"3\", \"(k)\"),\n        (0x24A7, \"3\", \"(l)\"),\n        (0x24A8, \"3\", \"(m)\"),\n        (0x24A9, \"3\", \"(n)\"),\n        (0x24AA, \"3\", \"(o)\"),\n        (0x24AB, \"3\", \"(p)\"),\n        (0x24AC, \"3\", \"(q)\"),\n        (0x24AD, \"3\", \"(r)\"),\n        (0x24AE, \"3\", \"(s)\"),\n        (0x24AF, \"3\", \"(t)\"),\n        (0x24B0, \"3\", \"(u)\"),\n        (0x24B1, \"3\", \"(v)\"),\n        (0x24B2, \"3\", \"(w)\"),\n        (0x24B3, \"3\", \"(x)\"),\n        (0x24B4, \"3\", \"(y)\"),\n        (0x24B5, \"3\", \"(z)\"),\n        (0x24B6, \"M\", \"a\"),\n        (0x24B7, \"M\", \"b\"),\n        (0x24B8, \"M\", \"c\"),\n        (0x24B9, \"M\", \"d\"),\n        (0x24BA, \"M\", \"e\"),\n        (0x24BB, \"M\", \"f\"),\n        (0x24BC, \"M\", \"g\"),\n        (0x24BD, \"M\", \"h\"),\n        (0x24BE, \"M\", \"i\"),\n        (0x24BF, \"M\", \"j\"),\n        (0x24C0, \"M\", \"k\"),\n    ]\n\n\ndef _seg_24() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x24C1, \"M\", \"l\"),\n        (0x24C2, \"M\", \"m\"),\n        (0x24C3, \"M\", \"n\"),\n        (0x24C4, \"M\", \"o\"),\n        (0x24C5, \"M\", \"p\"),\n        (0x24C6, \"M\", \"q\"),\n        (0x24C7, \"M\", \"r\"),\n        (0x24C8, \"M\", \"s\"),\n        (0x24C9, \"M\", \"t\"),\n        (0x24CA, \"M\", \"u\"),\n        (0x24CB, \"M\", \"v\"),\n        (0x24CC, \"M\", \"w\"),\n        (0x24CD, \"M\", \"x\"),\n        (0x24CE, \"M\", \"y\"),\n        (0x24CF, \"M\", \"z\"),\n        (0x24D0, \"M\", \"a\"),\n        (0x24D1, \"M\", \"b\"),\n        (0x24D2, \"M\", \"c\"),\n        (0x24D3, \"M\", \"d\"),\n        (0x24D4, \"M\", \"e\"),\n        (0x24D5, \"M\", \"f\"),\n        (0x24D6, \"M\", \"g\"),\n        (0x24D7, \"M\", \"h\"),\n        (0x24D8, \"M\", \"i\"),\n        (0x24D9, \"M\", \"j\"),\n        (0x24DA, \"M\", \"k\"),\n        (0x24DB, \"M\", \"l\"),\n        (0x24DC, \"M\", \"m\"),\n        (0x24DD, \"M\", \"n\"),\n        (0x24DE, \"M\", \"o\"),\n        (0x24DF, \"M\", \"p\"),\n        (0x24E0, \"M\", \"q\"),\n        (0x24E1, \"M\", \"r\"),\n        (0x24E2, \"M\", \"s\"),\n        (0x24E3, \"M\", \"t\"),\n        (0x24E4, \"M\", \"u\"),\n        (0x24E5, \"M\", \"v\"),\n        (0x24E6, \"M\", \"w\"),\n        (0x24E7, \"M\", \"x\"),\n        (0x24E8, \"M\", \"y\"),\n        (0x24E9, \"M\", \"z\"),\n        (0x24EA, \"M\", \"0\"),\n        (0x24EB, \"V\"),\n        (0x2A0C, \"M\", \"\"),\n        (0x2A0D, \"V\"),\n        (0x2A74, \"3\", \"::=\"),\n        (0x2A75, \"3\", \"==\"),\n        (0x2A76, \"3\", \"===\"),\n        (0x2A77, \"V\"),\n        (0x2ADC, \"M\", \"\"),\n        (0x2ADD, \"V\"),\n        (0x2B74, \"X\"),\n        (0x2B76, \"V\"),\n        (0x2B96, \"X\"),\n        (0x2B97, \"V\"),\n        (0x2C00, \"M\", \"\"),\n        (0x2C01, \"M\", \"\"),\n        (0x2C02, \"M\", \"\"),\n        (0x2C03, \"M\", \"\"),\n        (0x2C04, \"M\", \"\"),\n        (0x2C05, \"M\", \"\"),\n        (0x2C06, \"M\", \"\"),\n        (0x2C07, \"M\", \"\"),\n        (0x2C08, \"M\", \"\"),\n        (0x2C09, \"M\", \"\"),\n        (0x2C0A, \"M\", \"\"),\n        (0x2C0B, \"M\", \"\"),\n        (0x2C0C, \"M\", \"\"),\n        (0x2C0D, \"M\", \"\"),\n        (0x2C0E, \"M\", \"\"),\n        (0x2C0F, \"M\", \"\"),\n        (0x2C10, \"M\", \"\"),\n        (0x2C11, \"M\", \"\"),\n        (0x2C12, \"M\", \"\"),\n        (0x2C13, \"M\", \"\"),\n        (0x2C14, \"M\", \"\"),\n        (0x2C15, \"M\", \"\"),\n        (0x2C16, \"M\", \"\"),\n        (0x2C17, \"M\", \"\"),\n        (0x2C18, \"M\", \"\"),\n        (0x2C19, \"M\", \"\"),\n        (0x2C1A, \"M\", \"\"),\n        (0x2C1B, \"M\", \"\"),\n        (0x2C1C, \"M\", \"\"),\n        (0x2C1D, \"M\", \"\"),\n        (0x2C1E, \"M\", \"\"),\n        (0x2C1F, \"M\", \"\"),\n        (0x2C20, \"M\", \"\"),\n        (0x2C21, \"M\", \"\"),\n        (0x2C22, \"M\", \"\"),\n        (0x2C23, \"M\", \"\"),\n        (0x2C24, \"M\", \"\"),\n        (0x2C25, \"M\", \"\"),\n        (0x2C26, \"M\", \"\"),\n        (0x2C27, \"M\", \"\"),\n        (0x2C28, \"M\", \"\"),\n        (0x2C29, \"M\", \"\"),\n        (0x2C2A, \"M\", \"\"),\n        (0x2C2B, \"M\", \"\"),\n        (0x2C2C, \"M\", \"\"),\n    ]\n\n\ndef _seg_25() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x2C2D, \"M\", \"\"),\n        (0x2C2E, \"M\", \"\"),\n        (0x2C2F, \"M\", \"\"),\n        (0x2C30, \"V\"),\n        (0x2C60, \"M\", \"\"),\n        (0x2C61, \"V\"),\n        (0x2C62, \"M\", \"\"),\n        (0x2C63, \"M\", \"\"),\n        (0x2C64, \"M\", \"\"),\n        (0x2C65, \"V\"),\n        (0x2C67, \"M\", \"\"),\n        (0x2C68, \"V\"),\n        (0x2C69, \"M\", \"\"),\n        (0x2C6A, \"V\"),\n        (0x2C6B, \"M\", \"\"),\n        (0x2C6C, \"V\"),\n        (0x2C6D, \"M\", \"\"),\n        (0x2C6E, \"M\", \"\"),\n        (0x2C6F, \"M\", \"\"),\n        (0x2C70, \"M\", \"\"),\n        (0x2C71, \"V\"),\n        (0x2C72, \"M\", \"\"),\n        (0x2C73, \"V\"),\n        (0x2C75, \"M\", \"\"),\n        (0x2C76, \"V\"),\n        (0x2C7C, \"M\", \"j\"),\n        (0x2C7D, \"M\", \"v\"),\n        (0x2C7E, \"M\", \"\"),\n        (0x2C7F, \"M\", \"\"),\n        (0x2C80, \"M\", \"\"),\n        (0x2C81, \"V\"),\n        (0x2C82, \"M\", \"\"),\n        (0x2C83, \"V\"),\n        (0x2C84, \"M\", \"\"),\n        (0x2C85, \"V\"),\n        (0x2C86, \"M\", \"\"),\n        (0x2C87, \"V\"),\n        (0x2C88, \"M\", \"\"),\n        (0x2C89, \"V\"),\n        (0x2C8A, \"M\", \"\"),\n        (0x2C8B, \"V\"),\n        (0x2C8C, \"M\", \"\"),\n        (0x2C8D, \"V\"),\n        (0x2C8E, \"M\", \"\"),\n        (0x2C8F, \"V\"),\n        (0x2C90, \"M\", \"\"),\n        (0x2C91, \"V\"),\n        (0x2C92, \"M\", \"\"),\n        (0x2C93, \"V\"),\n        (0x2C94, \"M\", \"\"),\n        (0x2C95, \"V\"),\n        (0x2C96, \"M\", \"\"),\n        (0x2C97, \"V\"),\n        (0x2C98, \"M\", \"\"),\n        (0x2C99, \"V\"),\n        (0x2C9A, \"M\", \"\"),\n        (0x2C9B, \"V\"),\n        (0x2C9C, \"M\", \"\"),\n        (0x2C9D, \"V\"),\n        (0x2C9E, \"M\", \"\"),\n        (0x2C9F, \"V\"),\n        (0x2CA0, \"M\", \"\"),\n        (0x2CA1, \"V\"),\n        (0x2CA2, \"M\", \"\"),\n        (0x2CA3, \"V\"),\n        (0x2CA4, \"M\", \"\"),\n        (0x2CA5, \"V\"),\n        (0x2CA6, \"M\", \"\"),\n        (0x2CA7, \"V\"),\n        (0x2CA8, \"M\", \"\"),\n        (0x2CA9, \"V\"),\n        (0x2CAA, \"M\", \"\"),\n        (0x2CAB, \"V\"),\n        (0x2CAC, \"M\", \"\"),\n        (0x2CAD, \"V\"),\n        (0x2CAE, \"M\", \"\"),\n        (0x2CAF, \"V\"),\n        (0x2CB0, \"M\", \"\"),\n        (0x2CB1, \"V\"),\n        (0x2CB2, \"M\", \"\"),\n        (0x2CB3, \"V\"),\n        (0x2CB4, \"M\", \"\"),\n        (0x2CB5, \"V\"),\n        (0x2CB6, \"M\", \"\"),\n        (0x2CB7, \"V\"),\n        (0x2CB8, \"M\", \"\"),\n        (0x2CB9, \"V\"),\n        (0x2CBA, \"M\", \"\"),\n        (0x2CBB, \"V\"),\n        (0x2CBC, \"M\", \"\"),\n        (0x2CBD, \"V\"),\n        (0x2CBE, \"M\", \"\"),\n        (0x2CBF, \"V\"),\n        (0x2CC0, \"M\", \"\"),\n        (0x2CC1, \"V\"),\n        (0x2CC2, \"M\", \"\"),\n        (0x2CC3, \"V\"),\n        (0x2CC4, \"M\", \"\"),\n        (0x2CC5, \"V\"),\n        (0x2CC6, \"M\", \"\"),\n    ]\n\n\ndef _seg_26() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x2CC7, \"V\"),\n        (0x2CC8, \"M\", \"\"),\n        (0x2CC9, \"V\"),\n        (0x2CCA, \"M\", \"\"),\n        (0x2CCB, \"V\"),\n        (0x2CCC, \"M\", \"\"),\n        (0x2CCD, \"V\"),\n        (0x2CCE, \"M\", \"\"),\n        (0x2CCF, \"V\"),\n        (0x2CD0, \"M\", \"\"),\n        (0x2CD1, \"V\"),\n        (0x2CD2, \"M\", \"\"),\n        (0x2CD3, \"V\"),\n        (0x2CD4, \"M\", \"\"),\n        (0x2CD5, \"V\"),\n        (0x2CD6, \"M\", \"\"),\n        (0x2CD7, \"V\"),\n        (0x2CD8, \"M\", \"\"),\n        (0x2CD9, \"V\"),\n        (0x2CDA, \"M\", \"\"),\n        (0x2CDB, \"V\"),\n        (0x2CDC, \"M\", \"\"),\n        (0x2CDD, \"V\"),\n        (0x2CDE, \"M\", \"\"),\n        (0x2CDF, \"V\"),\n        (0x2CE0, \"M\", \"\"),\n        (0x2CE1, \"V\"),\n        (0x2CE2, \"M\", \"\"),\n        (0x2CE3, \"V\"),\n        (0x2CEB, \"M\", \"\"),\n        (0x2CEC, \"V\"),\n        (0x2CED, \"M\", \"\"),\n        (0x2CEE, \"V\"),\n        (0x2CF2, \"M\", \"\"),\n        (0x2CF3, \"V\"),\n        (0x2CF4, \"X\"),\n        (0x2CF9, \"V\"),\n        (0x2D26, \"X\"),\n        (0x2D27, \"V\"),\n        (0x2D28, \"X\"),\n        (0x2D2D, \"V\"),\n        (0x2D2E, \"X\"),\n        (0x2D30, \"V\"),\n        (0x2D68, \"X\"),\n        (0x2D6F, \"M\", \"\"),\n        (0x2D70, \"V\"),\n        (0x2D71, \"X\"),\n        (0x2D7F, \"V\"),\n        (0x2D97, \"X\"),\n        (0x2DA0, \"V\"),\n        (0x2DA7, \"X\"),\n        (0x2DA8, \"V\"),\n        (0x2DAF, \"X\"),\n        (0x2DB0, \"V\"),\n        (0x2DB7, \"X\"),\n        (0x2DB8, \"V\"),\n        (0x2DBF, \"X\"),\n        (0x2DC0, \"V\"),\n        (0x2DC7, \"X\"),\n        (0x2DC8, \"V\"),\n        (0x2DCF, \"X\"),\n        (0x2DD0, \"V\"),\n        (0x2DD7, \"X\"),\n        (0x2DD8, \"V\"),\n        (0x2DDF, \"X\"),\n        (0x2DE0, \"V\"),\n        (0x2E5E, \"X\"),\n        (0x2E80, \"V\"),\n        (0x2E9A, \"X\"),\n        (0x2E9B, \"V\"),\n        (0x2E9F, \"M\", \"\"),\n        (0x2EA0, \"V\"),\n        (0x2EF3, \"M\", \"\"),\n        (0x2EF4, \"X\"),\n        (0x2F00, \"M\", \"\"),\n        (0x2F01, \"M\", \"\"),\n        (0x2F02, \"M\", \"\"),\n        (0x2F03, \"M\", \"\"),\n        (0x2F04, \"M\", \"\"),\n        (0x2F05, \"M\", \"\"),\n        (0x2F06, \"M\", \"\"),\n        (0x2F07, \"M\", \"\"),\n        (0x2F08, \"M\", \"\"),\n        (0x2F09, \"M\", \"\"),\n        (0x2F0A, \"M\", \"\"),\n        (0x2F0B, \"M\", \"\"),\n        (0x2F0C, \"M\", \"\"),\n        (0x2F0D, \"M\", \"\"),\n        (0x2F0E, \"M\", \"\"),\n        (0x2F0F, \"M\", \"\"),\n        (0x2F10, \"M\", \"\"),\n        (0x2F11, \"M\", \"\"),\n        (0x2F12, \"M\", \"\"),\n        (0x2F13, \"M\", \"\"),\n        (0x2F14, \"M\", \"\"),\n        (0x2F15, \"M\", \"\"),\n        (0x2F16, \"M\", \"\"),\n        (0x2F17, \"M\", \"\"),\n        (0x2F18, \"M\", \"\"),\n        (0x2F19, \"M\", \"\"),\n    ]\n\n\ndef _seg_27() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x2F1A, \"M\", \"\"),\n        (0x2F1B, \"M\", \"\"),\n        (0x2F1C, \"M\", \"\"),\n        (0x2F1D, \"M\", \"\"),\n        (0x2F1E, \"M\", \"\"),\n        (0x2F1F, \"M\", \"\"),\n        (0x2F20, \"M\", \"\"),\n        (0x2F21, \"M\", \"\"),\n        (0x2F22, \"M\", \"\"),\n        (0x2F23, \"M\", \"\"),\n        (0x2F24, \"M\", \"\"),\n        (0x2F25, \"M\", \"\"),\n        (0x2F26, \"M\", \"\"),\n        (0x2F27, \"M\", \"\"),\n        (0x2F28, \"M\", \"\"),\n        (0x2F29, \"M\", \"\"),\n        (0x2F2A, \"M\", \"\"),\n        (0x2F2B, \"M\", \"\"),\n        (0x2F2C, \"M\", \"\"),\n        (0x2F2D, \"M\", \"\"),\n        (0x2F2E, \"M\", \"\"),\n        (0x2F2F, \"M\", \"\"),\n        (0x2F30, \"M\", \"\"),\n        (0x2F31, \"M\", \"\"),\n        (0x2F32, \"M\", \"\"),\n        (0x2F33, \"M\", \"\"),\n        (0x2F34, \"M\", \"\"),\n        (0x2F35, \"M\", \"\"),\n        (0x2F36, \"M\", \"\"),\n        (0x2F37, \"M\", \"\"),\n        (0x2F38, \"M\", \"\"),\n        (0x2F39, \"M\", \"\"),\n        (0x2F3A, \"M\", \"\"),\n        (0x2F3B, \"M\", \"\"),\n        (0x2F3C, \"M\", \"\"),\n        (0x2F3D, \"M\", \"\"),\n        (0x2F3E, \"M\", \"\"),\n        (0x2F3F, \"M\", \"\"),\n        (0x2F40, \"M\", \"\"),\n        (0x2F41, \"M\", \"\"),\n        (0x2F42, \"M\", \"\"),\n        (0x2F43, \"M\", \"\"),\n        (0x2F44, \"M\", \"\"),\n        (0x2F45, \"M\", \"\"),\n        (0x2F46, \"M\", \"\"),\n        (0x2F47, \"M\", \"\"),\n        (0x2F48, \"M\", \"\"),\n        (0x2F49, \"M\", \"\"),\n        (0x2F4A, \"M\", \"\"),\n        (0x2F4B, \"M\", \"\"),\n        (0x2F4C, \"M\", \"\"),\n        (0x2F4D, \"M\", \"\"),\n        (0x2F4E, \"M\", \"\"),\n        (0x2F4F, \"M\", \"\"),\n        (0x2F50, \"M\", \"\"),\n        (0x2F51, \"M\", \"\"),\n        (0x2F52, \"M\", \"\"),\n        (0x2F53, \"M\", \"\"),\n        (0x2F54, \"M\", \"\"),\n        (0x2F55, \"M\", \"\"),\n        (0x2F56, \"M\", \"\"),\n        (0x2F57, \"M\", \"\"),\n        (0x2F58, \"M\", \"\"),\n        (0x2F59, \"M\", \"\"),\n        (0x2F5A, \"M\", \"\"),\n        (0x2F5B, \"M\", \"\"),\n        (0x2F5C, \"M\", \"\"),\n        (0x2F5D, \"M\", \"\"),\n        (0x2F5E, \"M\", \"\"),\n        (0x2F5F, \"M\", \"\"),\n        (0x2F60, \"M\", \"\"),\n        (0x2F61, \"M\", \"\"),\n        (0x2F62, \"M\", \"\"),\n        (0x2F63, \"M\", \"\"),\n        (0x2F64, \"M\", \"\"),\n        (0x2F65, \"M\", \"\"),\n        (0x2F66, \"M\", \"\"),\n        (0x2F67, \"M\", \"\"),\n        (0x2F68, \"M\", \"\"),\n        (0x2F69, \"M\", \"\"),\n        (0x2F6A, \"M\", \"\"),\n        (0x2F6B, \"M\", \"\"),\n        (0x2F6C, \"M\", \"\"),\n        (0x2F6D, \"M\", \"\"),\n        (0x2F6E, \"M\", \"\"),\n        (0x2F6F, \"M\", \"\"),\n        (0x2F70, \"M\", \"\"),\n        (0x2F71, \"M\", \"\"),\n        (0x2F72, \"M\", \"\"),\n        (0x2F73, \"M\", \"\"),\n        (0x2F74, \"M\", \"\"),\n        (0x2F75, \"M\", \"\"),\n        (0x2F76, \"M\", \"\"),\n        (0x2F77, \"M\", \"\"),\n        (0x2F78, \"M\", \"\"),\n        (0x2F79, \"M\", \"\"),\n        (0x2F7A, \"M\", \"\"),\n        (0x2F7B, \"M\", \"\"),\n        (0x2F7C, \"M\", \"\"),\n        (0x2F7D, \"M\", \"\"),\n    ]\n\n\ndef _seg_28() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x2F7E, \"M\", \"\"),\n        (0x2F7F, \"M\", \"\"),\n        (0x2F80, \"M\", \"\"),\n        (0x2F81, \"M\", \"\"),\n        (0x2F82, \"M\", \"\"),\n        (0x2F83, \"M\", \"\"),\n        (0x2F84, \"M\", \"\"),\n        (0x2F85, \"M\", \"\"),\n        (0x2F86, \"M\", \"\"),\n        (0x2F87, \"M\", \"\"),\n        (0x2F88, \"M\", \"\"),\n        (0x2F89, \"M\", \"\"),\n        (0x2F8A, \"M\", \"\"),\n        (0x2F8B, \"M\", \"\"),\n        (0x2F8C, \"M\", \"\"),\n        (0x2F8D, \"M\", \"\"),\n        (0x2F8E, \"M\", \"\"),\n        (0x2F8F, \"M\", \"\"),\n        (0x2F90, \"M\", \"\"),\n        (0x2F91, \"M\", \"\"),\n        (0x2F92, \"M\", \"\"),\n        (0x2F93, \"M\", \"\"),\n        (0x2F94, \"M\", \"\"),\n        (0x2F95, \"M\", \"\"),\n        (0x2F96, \"M\", \"\"),\n        (0x2F97, \"M\", \"\"),\n        (0x2F98, \"M\", \"\"),\n        (0x2F99, \"M\", \"\"),\n        (0x2F9A, \"M\", \"\"),\n        (0x2F9B, \"M\", \"\"),\n        (0x2F9C, \"M\", \"\"),\n        (0x2F9D, \"M\", \"\"),\n        (0x2F9E, \"M\", \"\"),\n        (0x2F9F, \"M\", \"\"),\n        (0x2FA0, \"M\", \"\"),\n        (0x2FA1, \"M\", \"\"),\n        (0x2FA2, \"M\", \"\"),\n        (0x2FA3, \"M\", \"\"),\n        (0x2FA4, \"M\", \"\"),\n        (0x2FA5, \"M\", \"\"),\n        (0x2FA6, \"M\", \"\"),\n        (0x2FA7, \"M\", \"\"),\n        (0x2FA8, \"M\", \"\"),\n        (0x2FA9, \"M\", \"\"),\n        (0x2FAA, \"M\", \"\"),\n        (0x2FAB, \"M\", \"\"),\n        (0x2FAC, \"M\", \"\"),\n        (0x2FAD, \"M\", \"\"),\n        (0x2FAE, \"M\", \"\"),\n        (0x2FAF, \"M\", \"\"),\n        (0x2FB0, \"M\", \"\"),\n        (0x2FB1, \"M\", \"\"),\n        (0x2FB2, \"M\", \"\"),\n        (0x2FB3, \"M\", \"\"),\n        (0x2FB4, \"M\", \"\"),\n        (0x2FB5, \"M\", \"\"),\n        (0x2FB6, \"M\", \"\"),\n        (0x2FB7, \"M\", \"\"),\n        (0x2FB8, \"M\", \"\"),\n        (0x2FB9, \"M\", \"\"),\n        (0x2FBA, \"M\", \"\"),\n        (0x2FBB, \"M\", \"\"),\n        (0x2FBC, \"M\", \"\"),\n        (0x2FBD, \"M\", \"\"),\n        (0x2FBE, \"M\", \"\"),\n        (0x2FBF, \"M\", \"\"),\n        (0x2FC0, \"M\", \"\"),\n        (0x2FC1, \"M\", \"\"),\n        (0x2FC2, \"M\", \"\"),\n        (0x2FC3, \"M\", \"\"),\n        (0x2FC4, \"M\", \"\"),\n        (0x2FC5, \"M\", \"\"),\n        (0x2FC6, \"M\", \"\"),\n        (0x2FC7, \"M\", \"\"),\n        (0x2FC8, \"M\", \"\"),\n        (0x2FC9, \"M\", \"\"),\n        (0x2FCA, \"M\", \"\"),\n        (0x2FCB, \"M\", \"\"),\n        (0x2FCC, \"M\", \"\"),\n        (0x2FCD, \"M\", \"\"),\n        (0x2FCE, \"M\", \"\"),\n        (0x2FCF, \"M\", \"\"),\n        (0x2FD0, \"M\", \"\"),\n        (0x2FD1, \"M\", \"\"),\n        (0x2FD2, \"M\", \"\"),\n        (0x2FD3, \"M\", \"\"),\n        (0x2FD4, \"M\", \"\"),\n        (0x2FD5, \"M\", \"\"),\n        (0x2FD6, \"X\"),\n        (0x3000, \"3\", \" \"),\n        (0x3001, \"V\"),\n        (0x3002, \"M\", \".\"),\n        (0x3003, \"V\"),\n        (0x3036, \"M\", \"\"),\n        (0x3037, \"V\"),\n        (0x3038, \"M\", \"\"),\n        (0x3039, \"M\", \"\"),\n        (0x303A, \"M\", \"\"),\n        (0x303B, \"V\"),\n        (0x3040, \"X\"),\n    ]\n\n\ndef _seg_29() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x3041, \"V\"),\n        (0x3097, \"X\"),\n        (0x3099, \"V\"),\n        (0x309B, \"3\", \" \"),\n        (0x309C, \"3\", \" \"),\n        (0x309D, \"V\"),\n        (0x309F, \"M\", \"\"),\n        (0x30A0, \"V\"),\n        (0x30FF, \"M\", \"\"),\n        (0x3100, \"X\"),\n        (0x3105, \"V\"),\n        (0x3130, \"X\"),\n        (0x3131, \"M\", \"\"),\n        (0x3132, \"M\", \"\"),\n        (0x3133, \"M\", \"\"),\n        (0x3134, \"M\", \"\"),\n        (0x3135, \"M\", \"\"),\n        (0x3136, \"M\", \"\"),\n        (0x3137, \"M\", \"\"),\n        (0x3138, \"M\", \"\"),\n        (0x3139, \"M\", \"\"),\n        (0x313A, \"M\", \"\"),\n        (0x313B, \"M\", \"\"),\n        (0x313C, \"M\", \"\"),\n        (0x313D, \"M\", \"\"),\n        (0x313E, \"M\", \"\"),\n        (0x313F, \"M\", \"\"),\n        (0x3140, \"M\", \"\"),\n        (0x3141, \"M\", \"\"),\n        (0x3142, \"M\", \"\"),\n        (0x3143, \"M\", \"\"),\n        (0x3144, \"M\", \"\"),\n        (0x3145, \"M\", \"\"),\n        (0x3146, \"M\", \"\"),\n        (0x3147, \"M\", \"\"),\n        (0x3148, \"M\", \"\"),\n        (0x3149, \"M\", \"\"),\n        (0x314A, \"M\", \"\"),\n        (0x314B, \"M\", \"\"),\n        (0x314C, \"M\", \"\"),\n        (0x314D, \"M\", \"\"),\n        (0x314E, \"M\", \"\"),\n        (0x314F, \"M\", \"\"),\n        (0x3150, \"M\", \"\"),\n        (0x3151, \"M\", \"\"),\n        (0x3152, \"M\", \"\"),\n        (0x3153, \"M\", \"\"),\n        (0x3154, \"M\", \"\"),\n        (0x3155, \"M\", \"\"),\n        (0x3156, \"M\", \"\"),\n        (0x3157, \"M\", \"\"),\n        (0x3158, \"M\", \"\"),\n        (0x3159, \"M\", \"\"),\n        (0x315A, \"M\", \"\"),\n        (0x315B, \"M\", \"\"),\n        (0x315C, \"M\", \"\"),\n        (0x315D, \"M\", \"\"),\n        (0x315E, \"M\", \"\"),\n        (0x315F, \"M\", \"\"),\n        (0x3160, \"M\", \"\"),\n        (0x3161, \"M\", \"\"),\n        (0x3162, \"M\", \"\"),\n        (0x3163, \"M\", \"\"),\n        (0x3164, \"X\"),\n        (0x3165, \"M\", \"\"),\n        (0x3166, \"M\", \"\"),\n        (0x3167, \"M\", \"\"),\n        (0x3168, \"M\", \"\"),\n        (0x3169, \"M\", \"\"),\n        (0x316A, \"M\", \"\"),\n        (0x316B, \"M\", \"\"),\n        (0x316C, \"M\", \"\"),\n        (0x316D, \"M\", \"\"),\n        (0x316E, \"M\", \"\"),\n        (0x316F, \"M\", \"\"),\n        (0x3170, \"M\", \"\"),\n        (0x3171, \"M\", \"\"),\n        (0x3172, \"M\", \"\"),\n        (0x3173, \"M\", \"\"),\n        (0x3174, \"M\", \"\"),\n        (0x3175, \"M\", \"\"),\n        (0x3176, \"M\", \"\"),\n        (0x3177, \"M\", \"\"),\n        (0x3178, \"M\", \"\"),\n        (0x3179, \"M\", \"\"),\n        (0x317A, \"M\", \"\"),\n        (0x317B, \"M\", \"\"),\n        (0x317C, \"M\", \"\"),\n        (0x317D, \"M\", \"\"),\n        (0x317E, \"M\", \"\"),\n        (0x317F, \"M\", \"\"),\n        (0x3180, \"M\", \"\"),\n        (0x3181, \"M\", \"\"),\n        (0x3182, \"M\", \"\"),\n        (0x3183, \"M\", \"\"),\n        (0x3184, \"M\", \"\"),\n        (0x3185, \"M\", \"\"),\n        (0x3186, \"M\", \"\"),\n        (0x3187, \"M\", \"\"),\n        (0x3188, \"M\", \"\"),\n    ]\n\n\ndef _seg_30() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x3189, \"M\", \"\"),\n        (0x318A, \"M\", \"\"),\n        (0x318B, \"M\", \"\"),\n        (0x318C, \"M\", \"\"),\n        (0x318D, \"M\", \"\"),\n        (0x318E, \"M\", \"\"),\n        (0x318F, \"X\"),\n        (0x3190, \"V\"),\n        (0x3192, \"M\", \"\"),\n        (0x3193, \"M\", \"\"),\n        (0x3194, \"M\", \"\"),\n        (0x3195, \"M\", \"\"),\n        (0x3196, \"M\", \"\"),\n        (0x3197, \"M\", \"\"),\n        (0x3198, \"M\", \"\"),\n        (0x3199, \"M\", \"\"),\n        (0x319A, \"M\", \"\"),\n        (0x319B, \"M\", \"\"),\n        (0x319C, \"M\", \"\"),\n        (0x319D, \"M\", \"\"),\n        (0x319E, \"M\", \"\"),\n        (0x319F, \"M\", \"\"),\n        (0x31A0, \"V\"),\n        (0x31E4, \"X\"),\n        (0x31F0, \"V\"),\n        (0x3200, \"3\", \"()\"),\n        (0x3201, \"3\", \"()\"),\n        (0x3202, \"3\", \"()\"),\n        (0x3203, \"3\", \"()\"),\n        (0x3204, \"3\", \"()\"),\n        (0x3205, \"3\", \"()\"),\n        (0x3206, \"3\", \"()\"),\n        (0x3207, \"3\", \"()\"),\n        (0x3208, \"3\", \"()\"),\n        (0x3209, \"3\", \"()\"),\n        (0x320A, \"3\", \"()\"),\n        (0x320B, \"3\", \"()\"),\n        (0x320C, \"3\", \"()\"),\n        (0x320D, \"3\", \"()\"),\n        (0x320E, \"3\", \"()\"),\n        (0x320F, \"3\", \"()\"),\n        (0x3210, \"3\", \"()\"),\n        (0x3211, \"3\", \"()\"),\n        (0x3212, \"3\", \"()\"),\n        (0x3213, \"3\", \"()\"),\n        (0x3214, \"3\", \"()\"),\n        (0x3215, \"3\", \"()\"),\n        (0x3216, \"3\", \"()\"),\n        (0x3217, \"3\", \"()\"),\n        (0x3218, \"3\", \"()\"),\n        (0x3219, \"3\", \"()\"),\n        (0x321A, \"3\", \"()\"),\n        (0x321B, \"3\", \"()\"),\n        (0x321C, \"3\", \"()\"),\n        (0x321D, \"3\", \"()\"),\n        (0x321E, \"3\", \"()\"),\n        (0x321F, \"X\"),\n        (0x3220, \"3\", \"()\"),\n        (0x3221, \"3\", \"()\"),\n        (0x3222, \"3\", \"()\"),\n        (0x3223, \"3\", \"()\"),\n        (0x3224, \"3\", \"()\"),\n        (0x3225, \"3\", \"()\"),\n        (0x3226, \"3\", \"()\"),\n        (0x3227, \"3\", \"()\"),\n        (0x3228, \"3\", \"()\"),\n        (0x3229, \"3\", \"()\"),\n        (0x322A, \"3\", \"()\"),\n        (0x322B, \"3\", \"()\"),\n        (0x322C, \"3\", \"()\"),\n        (0x322D, \"3\", \"()\"),\n        (0x322E, \"3\", \"()\"),\n        (0x322F, \"3\", \"()\"),\n        (0x3230, \"3\", \"()\"),\n        (0x3231, \"3\", \"()\"),\n        (0x3232, \"3\", \"()\"),\n        (0x3233, \"3\", \"()\"),\n        (0x3234, \"3\", \"()\"),\n        (0x3235, \"3\", \"()\"),\n        (0x3236, \"3\", \"()\"),\n        (0x3237, \"3\", \"()\"),\n        (0x3238, \"3\", \"()\"),\n        (0x3239, \"3\", \"()\"),\n        (0x323A, \"3\", \"()\"),\n        (0x323B, \"3\", \"()\"),\n        (0x323C, \"3\", \"()\"),\n        (0x323D, \"3\", \"()\"),\n        (0x323E, \"3\", \"()\"),\n        (0x323F, \"3\", \"()\"),\n        (0x3240, \"3\", \"()\"),\n        (0x3241, \"3\", \"()\"),\n        (0x3242, \"3\", \"()\"),\n        (0x3243, \"3\", \"()\"),\n        (0x3244, \"M\", \"\"),\n        (0x3245, \"M\", \"\"),\n        (0x3246, \"M\", \"\"),\n        (0x3247, \"M\", \"\"),\n        (0x3248, \"V\"),\n        (0x3250, \"M\", \"pte\"),\n        (0x3251, \"M\", \"21\"),\n    ]\n\n\ndef _seg_31() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x3252, \"M\", \"22\"),\n        (0x3253, \"M\", \"23\"),\n        (0x3254, \"M\", \"24\"),\n        (0x3255, \"M\", \"25\"),\n        (0x3256, \"M\", \"26\"),\n        (0x3257, \"M\", \"27\"),\n        (0x3258, \"M\", \"28\"),\n        (0x3259, \"M\", \"29\"),\n        (0x325A, \"M\", \"30\"),\n        (0x325B, \"M\", \"31\"),\n        (0x325C, \"M\", \"32\"),\n        (0x325D, \"M\", \"33\"),\n        (0x325E, \"M\", \"34\"),\n        (0x325F, \"M\", \"35\"),\n        (0x3260, \"M\", \"\"),\n        (0x3261, \"M\", \"\"),\n        (0x3262, \"M\", \"\"),\n        (0x3263, \"M\", \"\"),\n        (0x3264, \"M\", \"\"),\n        (0x3265, \"M\", \"\"),\n        (0x3266, \"M\", \"\"),\n        (0x3267, \"M\", \"\"),\n        (0x3268, \"M\", \"\"),\n        (0x3269, \"M\", \"\"),\n        (0x326A, \"M\", \"\"),\n        (0x326B, \"M\", \"\"),\n        (0x326C, \"M\", \"\"),\n        (0x326D, \"M\", \"\"),\n        (0x326E, \"M\", \"\"),\n        (0x326F, \"M\", \"\"),\n        (0x3270, \"M\", \"\"),\n        (0x3271, \"M\", \"\"),\n        (0x3272, \"M\", \"\"),\n        (0x3273, \"M\", \"\"),\n        (0x3274, \"M\", \"\"),\n        (0x3275, \"M\", \"\"),\n        (0x3276, \"M\", \"\"),\n        (0x3277, \"M\", \"\"),\n        (0x3278, \"M\", \"\"),\n        (0x3279, \"M\", \"\"),\n        (0x327A, \"M\", \"\"),\n        (0x327B, \"M\", \"\"),\n        (0x327C, \"M\", \"\"),\n        (0x327D, \"M\", \"\"),\n        (0x327E, \"M\", \"\"),\n        (0x327F, \"V\"),\n        (0x3280, \"M\", \"\"),\n        (0x3281, \"M\", \"\"),\n        (0x3282, \"M\", \"\"),\n        (0x3283, \"M\", \"\"),\n        (0x3284, \"M\", \"\"),\n        (0x3285, \"M\", \"\"),\n        (0x3286, \"M\", \"\"),\n        (0x3287, \"M\", \"\"),\n        (0x3288, \"M\", \"\"),\n        (0x3289, \"M\", \"\"),\n        (0x328A, \"M\", \"\"),\n        (0x328B, \"M\", \"\"),\n        (0x328C, \"M\", \"\"),\n        (0x328D, \"M\", \"\"),\n        (0x328E, \"M\", \"\"),\n        (0x328F, \"M\", \"\"),\n        (0x3290, \"M\", \"\"),\n        (0x3291, \"M\", \"\"),\n        (0x3292, \"M\", \"\"),\n        (0x3293, \"M\", \"\"),\n        (0x3294, \"M\", \"\"),\n        (0x3295, \"M\", \"\"),\n        (0x3296, \"M\", \"\"),\n        (0x3297, \"M\", \"\"),\n        (0x3298, \"M\", \"\"),\n        (0x3299, \"M\", \"\"),\n        (0x329A, \"M\", \"\"),\n        (0x329B, \"M\", \"\"),\n        (0x329C, \"M\", \"\"),\n        (0x329D, \"M\", \"\"),\n        (0x329E, \"M\", \"\"),\n        (0x329F, \"M\", \"\"),\n        (0x32A0, \"M\", \"\"),\n        (0x32A1, \"M\", \"\"),\n        (0x32A2, \"M\", \"\"),\n        (0x32A3, \"M\", \"\"),\n        (0x32A4, \"M\", \"\"),\n        (0x32A5, \"M\", \"\"),\n        (0x32A6, \"M\", \"\"),\n        (0x32A7, \"M\", \"\"),\n        (0x32A8, \"M\", \"\"),\n        (0x32A9, \"M\", \"\"),\n        (0x32AA, \"M\", \"\"),\n        (0x32AB, \"M\", \"\"),\n        (0x32AC, \"M\", \"\"),\n        (0x32AD, \"M\", \"\"),\n        (0x32AE, \"M\", \"\"),\n        (0x32AF, \"M\", \"\"),\n        (0x32B0, \"M\", \"\"),\n        (0x32B1, \"M\", \"36\"),\n        (0x32B2, \"M\", \"37\"),\n        (0x32B3, \"M\", \"38\"),\n        (0x32B4, \"M\", \"39\"),\n        (0x32B5, \"M\", \"40\"),\n    ]\n\n\ndef _seg_32() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x32B6, \"M\", \"41\"),\n        (0x32B7, \"M\", \"42\"),\n        (0x32B8, \"M\", \"43\"),\n        (0x32B9, \"M\", \"44\"),\n        (0x32BA, \"M\", \"45\"),\n        (0x32BB, \"M\", \"46\"),\n        (0x32BC, \"M\", \"47\"),\n        (0x32BD, \"M\", \"48\"),\n        (0x32BE, \"M\", \"49\"),\n        (0x32BF, \"M\", \"50\"),\n        (0x32C0, \"M\", \"1\"),\n        (0x32C1, \"M\", \"2\"),\n        (0x32C2, \"M\", \"3\"),\n        (0x32C3, \"M\", \"4\"),\n        (0x32C4, \"M\", \"5\"),\n        (0x32C5, \"M\", \"6\"),\n        (0x32C6, \"M\", \"7\"),\n        (0x32C7, \"M\", \"8\"),\n        (0x32C8, \"M\", \"9\"),\n        (0x32C9, \"M\", \"10\"),\n        (0x32CA, \"M\", \"11\"),\n        (0x32CB, \"M\", \"12\"),\n        (0x32CC, \"M\", \"hg\"),\n        (0x32CD, \"M\", \"erg\"),\n        (0x32CE, \"M\", \"ev\"),\n        (0x32CF, \"M\", \"ltd\"),\n        (0x32D0, \"M\", \"\"),\n        (0x32D1, \"M\", \"\"),\n        (0x32D2, \"M\", \"\"),\n        (0x32D3, \"M\", \"\"),\n        (0x32D4, \"M\", \"\"),\n        (0x32D5, \"M\", \"\"),\n        (0x32D6, \"M\", \"\"),\n        (0x32D7, \"M\", \"\"),\n        (0x32D8, \"M\", \"\"),\n        (0x32D9, \"M\", \"\"),\n        (0x32DA, \"M\", \"\"),\n        (0x32DB, \"M\", \"\"),\n        (0x32DC, \"M\", \"\"),\n        (0x32DD, \"M\", \"\"),\n        (0x32DE, \"M\", \"\"),\n        (0x32DF, \"M\", \"\"),\n        (0x32E0, \"M\", \"\"),\n        (0x32E1, \"M\", \"\"),\n        (0x32E2, \"M\", \"\"),\n        (0x32E3, \"M\", \"\"),\n        (0x32E4, \"M\", \"\"),\n        (0x32E5, \"M\", \"\"),\n        (0x32E6, \"M\", \"\"),\n        (0x32E7, \"M\", \"\"),\n        (0x32E8, \"M\", \"\"),\n        (0x32E9, \"M\", \"\"),\n        (0x32EA, \"M\", \"\"),\n        (0x32EB, \"M\", \"\"),\n        (0x32EC, \"M\", \"\"),\n        (0x32ED, \"M\", \"\"),\n        (0x32EE, \"M\", \"\"),\n        (0x32EF, \"M\", \"\"),\n        (0x32F0, \"M\", \"\"),\n        (0x32F1, \"M\", \"\"),\n        (0x32F2, \"M\", \"\"),\n        (0x32F3, \"M\", \"\"),\n        (0x32F4, \"M\", \"\"),\n        (0x32F5, \"M\", \"\"),\n        (0x32F6, \"M\", \"\"),\n        (0x32F7, \"M\", \"\"),\n        (0x32F8, \"M\", \"\"),\n        (0x32F9, \"M\", \"\"),\n        (0x32FA, \"M\", \"\"),\n        (0x32FB, \"M\", \"\"),\n        (0x32FC, \"M\", \"\"),\n        (0x32FD, \"M\", \"\"),\n        (0x32FE, \"M\", \"\"),\n        (0x32FF, \"M\", \"\"),\n        (0x3300, \"M\", \"\"),\n        (0x3301, \"M\", \"\"),\n        (0x3302, \"M\", \"\"),\n        (0x3303, \"M\", \"\"),\n        (0x3304, \"M\", \"\"),\n        (0x3305, \"M\", \"\"),\n        (0x3306, \"M\", \"\"),\n        (0x3307, \"M\", \"\"),\n        (0x3308, \"M\", \"\"),\n        (0x3309, \"M\", \"\"),\n        (0x330A, \"M\", \"\"),\n        (0x330B, \"M\", \"\"),\n        (0x330C, \"M\", \"\"),\n        (0x330D, \"M\", \"\"),\n        (0x330E, \"M\", \"\"),\n        (0x330F, \"M\", \"\"),\n        (0x3310, \"M\", \"\"),\n        (0x3311, \"M\", \"\"),\n        (0x3312, \"M\", \"\"),\n        (0x3313, \"M\", \"\"),\n        (0x3314, \"M\", \"\"),\n        (0x3315, \"M\", \"\"),\n        (0x3316, \"M\", \"\"),\n        (0x3317, \"M\", \"\"),\n        (0x3318, \"M\", \"\"),\n        (0x3319, \"M\", \"\"),\n    ]\n\n\ndef _seg_33() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x331A, \"M\", \"\"),\n        (0x331B, \"M\", \"\"),\n        (0x331C, \"M\", \"\"),\n        (0x331D, \"M\", \"\"),\n        (0x331E, \"M\", \"\"),\n        (0x331F, \"M\", \"\"),\n        (0x3320, \"M\", \"\"),\n        (0x3321, \"M\", \"\"),\n        (0x3322, \"M\", \"\"),\n        (0x3323, \"M\", \"\"),\n        (0x3324, \"M\", \"\"),\n        (0x3325, \"M\", \"\"),\n        (0x3326, \"M\", \"\"),\n        (0x3327, \"M\", \"\"),\n        (0x3328, \"M\", \"\"),\n        (0x3329, \"M\", \"\"),\n        (0x332A, \"M\", \"\"),\n        (0x332B, \"M\", \"\"),\n        (0x332C, \"M\", \"\"),\n        (0x332D, \"M\", \"\"),\n        (0x332E, \"M\", \"\"),\n        (0x332F, \"M\", \"\"),\n        (0x3330, \"M\", \"\"),\n        (0x3331, \"M\", \"\"),\n        (0x3332, \"M\", \"\"),\n        (0x3333, \"M\", \"\"),\n        (0x3334, \"M\", \"\"),\n        (0x3335, \"M\", \"\"),\n        (0x3336, \"M\", \"\"),\n        (0x3337, \"M\", \"\"),\n        (0x3338, \"M\", \"\"),\n        (0x3339, \"M\", \"\"),\n        (0x333A, \"M\", \"\"),\n        (0x333B, \"M\", \"\"),\n        (0x333C, \"M\", \"\"),\n        (0x333D, \"M\", \"\"),\n        (0x333E, \"M\", \"\"),\n        (0x333F, \"M\", \"\"),\n        (0x3340, \"M\", \"\"),\n        (0x3341, \"M\", \"\"),\n        (0x3342, \"M\", \"\"),\n        (0x3343, \"M\", \"\"),\n        (0x3344, \"M\", \"\"),\n        (0x3345, \"M\", \"\"),\n        (0x3346, \"M\", \"\"),\n        (0x3347, \"M\", \"\"),\n        (0x3348, \"M\", \"\"),\n        (0x3349, \"M\", \"\"),\n        (0x334A, \"M\", \"\"),\n        (0x334B, \"M\", \"\"),\n        (0x334C, \"M\", \"\"),\n        (0x334D, \"M\", \"\"),\n        (0x334E, \"M\", \"\"),\n        (0x334F, \"M\", \"\"),\n        (0x3350, \"M\", \"\"),\n        (0x3351, \"M\", \"\"),\n        (0x3352, \"M\", \"\"),\n        (0x3353, \"M\", \"\"),\n        (0x3354, \"M\", \"\"),\n        (0x3355, \"M\", \"\"),\n        (0x3356, \"M\", \"\"),\n        (0x3357, \"M\", \"\"),\n        (0x3358, \"M\", \"0\"),\n        (0x3359, \"M\", \"1\"),\n        (0x335A, \"M\", \"2\"),\n        (0x335B, \"M\", \"3\"),\n        (0x335C, \"M\", \"4\"),\n        (0x335D, \"M\", \"5\"),\n        (0x335E, \"M\", \"6\"),\n        (0x335F, \"M\", \"7\"),\n        (0x3360, \"M\", \"8\"),\n        (0x3361, \"M\", \"9\"),\n        (0x3362, \"M\", \"10\"),\n        (0x3363, \"M\", \"11\"),\n        (0x3364, \"M\", \"12\"),\n        (0x3365, \"M\", \"13\"),\n        (0x3366, \"M\", \"14\"),\n        (0x3367, \"M\", \"15\"),\n        (0x3368, \"M\", \"16\"),\n        (0x3369, \"M\", \"17\"),\n        (0x336A, \"M\", \"18\"),\n        (0x336B, \"M\", \"19\"),\n        (0x336C, \"M\", \"20\"),\n        (0x336D, \"M\", \"21\"),\n        (0x336E, \"M\", \"22\"),\n        (0x336F, \"M\", \"23\"),\n        (0x3370, \"M\", \"24\"),\n        (0x3371, \"M\", \"hpa\"),\n        (0x3372, \"M\", \"da\"),\n        (0x3373, \"M\", \"au\"),\n        (0x3374, \"M\", \"bar\"),\n        (0x3375, \"M\", \"ov\"),\n        (0x3376, \"M\", \"pc\"),\n        (0x3377, \"M\", \"dm\"),\n        (0x3378, \"M\", \"dm2\"),\n        (0x3379, \"M\", \"dm3\"),\n        (0x337A, \"M\", \"iu\"),\n        (0x337B, \"M\", \"\"),\n        (0x337C, \"M\", \"\"),\n        (0x337D, \"M\", \"\"),\n    ]\n\n\ndef _seg_34() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x337E, \"M\", \"\"),\n        (0x337F, \"M\", \"\"),\n        (0x3380, \"M\", \"pa\"),\n        (0x3381, \"M\", \"na\"),\n        (0x3382, \"M\", \"a\"),\n        (0x3383, \"M\", \"ma\"),\n        (0x3384, \"M\", \"ka\"),\n        (0x3385, \"M\", \"kb\"),\n        (0x3386, \"M\", \"mb\"),\n        (0x3387, \"M\", \"gb\"),\n        (0x3388, \"M\", \"cal\"),\n        (0x3389, \"M\", \"kcal\"),\n        (0x338A, \"M\", \"pf\"),\n        (0x338B, \"M\", \"nf\"),\n        (0x338C, \"M\", \"f\"),\n        (0x338D, \"M\", \"g\"),\n        (0x338E, \"M\", \"mg\"),\n        (0x338F, \"M\", \"kg\"),\n        (0x3390, \"M\", \"hz\"),\n        (0x3391, \"M\", \"khz\"),\n        (0x3392, \"M\", \"mhz\"),\n        (0x3393, \"M\", \"ghz\"),\n        (0x3394, \"M\", \"thz\"),\n        (0x3395, \"M\", \"l\"),\n        (0x3396, \"M\", \"ml\"),\n        (0x3397, \"M\", \"dl\"),\n        (0x3398, \"M\", \"kl\"),\n        (0x3399, \"M\", \"fm\"),\n        (0x339A, \"M\", \"nm\"),\n        (0x339B, \"M\", \"m\"),\n        (0x339C, \"M\", \"mm\"),\n        (0x339D, \"M\", \"cm\"),\n        (0x339E, \"M\", \"km\"),\n        (0x339F, \"M\", \"mm2\"),\n        (0x33A0, \"M\", \"cm2\"),\n        (0x33A1, \"M\", \"m2\"),\n        (0x33A2, \"M\", \"km2\"),\n        (0x33A3, \"M\", \"mm3\"),\n        (0x33A4, \"M\", \"cm3\"),\n        (0x33A5, \"M\", \"m3\"),\n        (0x33A6, \"M\", \"km3\"),\n        (0x33A7, \"M\", \"ms\"),\n        (0x33A8, \"M\", \"ms2\"),\n        (0x33A9, \"M\", \"pa\"),\n        (0x33AA, \"M\", \"kpa\"),\n        (0x33AB, \"M\", \"mpa\"),\n        (0x33AC, \"M\", \"gpa\"),\n        (0x33AD, \"M\", \"rad\"),\n        (0x33AE, \"M\", \"rads\"),\n        (0x33AF, \"M\", \"rads2\"),\n        (0x33B0, \"M\", \"ps\"),\n        (0x33B1, \"M\", \"ns\"),\n        (0x33B2, \"M\", \"s\"),\n        (0x33B3, \"M\", \"ms\"),\n        (0x33B4, \"M\", \"pv\"),\n        (0x33B5, \"M\", \"nv\"),\n        (0x33B6, \"M\", \"v\"),\n        (0x33B7, \"M\", \"mv\"),\n        (0x33B8, \"M\", \"kv\"),\n        (0x33B9, \"M\", \"mv\"),\n        (0x33BA, \"M\", \"pw\"),\n        (0x33BB, \"M\", \"nw\"),\n        (0x33BC, \"M\", \"w\"),\n        (0x33BD, \"M\", \"mw\"),\n        (0x33BE, \"M\", \"kw\"),\n        (0x33BF, \"M\", \"mw\"),\n        (0x33C0, \"M\", \"k\"),\n        (0x33C1, \"M\", \"m\"),\n        (0x33C2, \"X\"),\n        (0x33C3, \"M\", \"bq\"),\n        (0x33C4, \"M\", \"cc\"),\n        (0x33C5, \"M\", \"cd\"),\n        (0x33C6, \"M\", \"ckg\"),\n        (0x33C7, \"X\"),\n        (0x33C8, \"M\", \"db\"),\n        (0x33C9, \"M\", \"gy\"),\n        (0x33CA, \"M\", \"ha\"),\n        (0x33CB, \"M\", \"hp\"),\n        (0x33CC, \"M\", \"in\"),\n        (0x33CD, \"M\", \"kk\"),\n        (0x33CE, \"M\", \"km\"),\n        (0x33CF, \"M\", \"kt\"),\n        (0x33D0, \"M\", \"lm\"),\n        (0x33D1, \"M\", \"ln\"),\n        (0x33D2, \"M\", \"log\"),\n        (0x33D3, \"M\", \"lx\"),\n        (0x33D4, \"M\", \"mb\"),\n        (0x33D5, \"M\", \"mil\"),\n        (0x33D6, \"M\", \"mol\"),\n        (0x33D7, \"M\", \"ph\"),\n        (0x33D8, \"X\"),\n        (0x33D9, \"M\", \"ppm\"),\n        (0x33DA, \"M\", \"pr\"),\n        (0x33DB, \"M\", \"sr\"),\n        (0x33DC, \"M\", \"sv\"),\n        (0x33DD, \"M\", \"wb\"),\n        (0x33DE, \"M\", \"vm\"),\n        (0x33DF, \"M\", \"am\"),\n        (0x33E0, \"M\", \"1\"),\n        (0x33E1, \"M\", \"2\"),\n    ]\n\n\ndef _seg_35() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x33E2, \"M\", \"3\"),\n        (0x33E3, \"M\", \"4\"),\n        (0x33E4, \"M\", \"5\"),\n        (0x33E5, \"M\", \"6\"),\n        (0x33E6, \"M\", \"7\"),\n        (0x33E7, \"M\", \"8\"),\n        (0x33E8, \"M\", \"9\"),\n        (0x33E9, \"M\", \"10\"),\n        (0x33EA, \"M\", \"11\"),\n        (0x33EB, \"M\", \"12\"),\n        (0x33EC, \"M\", \"13\"),\n        (0x33ED, \"M\", \"14\"),\n        (0x33EE, \"M\", \"15\"),\n        (0x33EF, \"M\", \"16\"),\n        (0x33F0, \"M\", \"17\"),\n        (0x33F1, \"M\", \"18\"),\n        (0x33F2, \"M\", \"19\"),\n        (0x33F3, \"M\", \"20\"),\n        (0x33F4, \"M\", \"21\"),\n        (0x33F5, \"M\", \"22\"),\n        (0x33F6, \"M\", \"23\"),\n        (0x33F7, \"M\", \"24\"),\n        (0x33F8, \"M\", \"25\"),\n        (0x33F9, \"M\", \"26\"),\n        (0x33FA, \"M\", \"27\"),\n        (0x33FB, \"M\", \"28\"),\n        (0x33FC, \"M\", \"29\"),\n        (0x33FD, \"M\", \"30\"),\n        (0x33FE, \"M\", \"31\"),\n        (0x33FF, \"M\", \"gal\"),\n        (0x3400, \"V\"),\n        (0xA48D, \"X\"),\n        (0xA490, \"V\"),\n        (0xA4C7, \"X\"),\n        (0xA4D0, \"V\"),\n        (0xA62C, \"X\"),\n        (0xA640, \"M\", \"\"),\n        (0xA641, \"V\"),\n        (0xA642, \"M\", \"\"),\n        (0xA643, \"V\"),\n        (0xA644, \"M\", \"\"),\n        (0xA645, \"V\"),\n        (0xA646, \"M\", \"\"),\n        (0xA647, \"V\"),\n        (0xA648, \"M\", \"\"),\n        (0xA649, \"V\"),\n        (0xA64A, \"M\", \"\"),\n        (0xA64B, \"V\"),\n        (0xA64C, \"M\", \"\"),\n        (0xA64D, \"V\"),\n        (0xA64E, \"M\", \"\"),\n        (0xA64F, \"V\"),\n        (0xA650, \"M\", \"\"),\n        (0xA651, \"V\"),\n        (0xA652, \"M\", \"\"),\n        (0xA653, \"V\"),\n        (0xA654, \"M\", \"\"),\n        (0xA655, \"V\"),\n        (0xA656, \"M\", \"\"),\n        (0xA657, \"V\"),\n        (0xA658, \"M\", \"\"),\n        (0xA659, \"V\"),\n        (0xA65A, \"M\", \"\"),\n        (0xA65B, \"V\"),\n        (0xA65C, \"M\", \"\"),\n        (0xA65D, \"V\"),\n        (0xA65E, \"M\", \"\"),\n        (0xA65F, \"V\"),\n        (0xA660, \"M\", \"\"),\n        (0xA661, \"V\"),\n        (0xA662, \"M\", \"\"),\n        (0xA663, \"V\"),\n        (0xA664, \"M\", \"\"),\n        (0xA665, \"V\"),\n        (0xA666, \"M\", \"\"),\n        (0xA667, \"V\"),\n        (0xA668, \"M\", \"\"),\n        (0xA669, \"V\"),\n        (0xA66A, \"M\", \"\"),\n        (0xA66B, \"V\"),\n        (0xA66C, \"M\", \"\"),\n        (0xA66D, \"V\"),\n        (0xA680, \"M\", \"\"),\n        (0xA681, \"V\"),\n        (0xA682, \"M\", \"\"),\n        (0xA683, \"V\"),\n        (0xA684, \"M\", \"\"),\n        (0xA685, \"V\"),\n        (0xA686, \"M\", \"\"),\n        (0xA687, \"V\"),\n        (0xA688, \"M\", \"\"),\n        (0xA689, \"V\"),\n        (0xA68A, \"M\", \"\"),\n        (0xA68B, \"V\"),\n        (0xA68C, \"M\", \"\"),\n        (0xA68D, \"V\"),\n        (0xA68E, \"M\", \"\"),\n        (0xA68F, \"V\"),\n        (0xA690, \"M\", \"\"),\n        (0xA691, \"V\"),\n    ]\n\n\ndef _seg_36() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xA692, \"M\", \"\"),\n        (0xA693, \"V\"),\n        (0xA694, \"M\", \"\"),\n        (0xA695, \"V\"),\n        (0xA696, \"M\", \"\"),\n        (0xA697, \"V\"),\n        (0xA698, \"M\", \"\"),\n        (0xA699, \"V\"),\n        (0xA69A, \"M\", \"\"),\n        (0xA69B, \"V\"),\n        (0xA69C, \"M\", \"\"),\n        (0xA69D, \"M\", \"\"),\n        (0xA69E, \"V\"),\n        (0xA6F8, \"X\"),\n        (0xA700, \"V\"),\n        (0xA722, \"M\", \"\"),\n        (0xA723, \"V\"),\n        (0xA724, \"M\", \"\"),\n        (0xA725, \"V\"),\n        (0xA726, \"M\", \"\"),\n        (0xA727, \"V\"),\n        (0xA728, \"M\", \"\"),\n        (0xA729, \"V\"),\n        (0xA72A, \"M\", \"\"),\n        (0xA72B, \"V\"),\n        (0xA72C, \"M\", \"\"),\n        (0xA72D, \"V\"),\n        (0xA72E, \"M\", \"\"),\n        (0xA72F, \"V\"),\n        (0xA732, \"M\", \"\"),\n        (0xA733, \"V\"),\n        (0xA734, \"M\", \"\"),\n        (0xA735, \"V\"),\n        (0xA736, \"M\", \"\"),\n        (0xA737, \"V\"),\n        (0xA738, \"M\", \"\"),\n        (0xA739, \"V\"),\n        (0xA73A, \"M\", \"\"),\n        (0xA73B, \"V\"),\n        (0xA73C, \"M\", \"\"),\n        (0xA73D, \"V\"),\n        (0xA73E, \"M\", \"\"),\n        (0xA73F, \"V\"),\n        (0xA740, \"M\", \"\"),\n        (0xA741, \"V\"),\n        (0xA742, \"M\", \"\"),\n        (0xA743, \"V\"),\n        (0xA744, \"M\", \"\"),\n        (0xA745, \"V\"),\n        (0xA746, \"M\", \"\"),\n        (0xA747, \"V\"),\n        (0xA748, \"M\", \"\"),\n        (0xA749, \"V\"),\n        (0xA74A, \"M\", \"\"),\n        (0xA74B, \"V\"),\n        (0xA74C, \"M\", \"\"),\n        (0xA74D, \"V\"),\n        (0xA74E, \"M\", \"\"),\n        (0xA74F, \"V\"),\n        (0xA750, \"M\", \"\"),\n        (0xA751, \"V\"),\n        (0xA752, \"M\", \"\"),\n        (0xA753, \"V\"),\n        (0xA754, \"M\", \"\"),\n        (0xA755, \"V\"),\n        (0xA756, \"M\", \"\"),\n        (0xA757, \"V\"),\n        (0xA758, \"M\", \"\"),\n        (0xA759, \"V\"),\n        (0xA75A, \"M\", \"\"),\n        (0xA75B, \"V\"),\n        (0xA75C, \"M\", \"\"),\n        (0xA75D, \"V\"),\n        (0xA75E, \"M\", \"\"),\n        (0xA75F, \"V\"),\n        (0xA760, \"M\", \"\"),\n        (0xA761, \"V\"),\n        (0xA762, \"M\", \"\"),\n        (0xA763, \"V\"),\n        (0xA764, \"M\", \"\"),\n        (0xA765, \"V\"),\n        (0xA766, \"M\", \"\"),\n        (0xA767, \"V\"),\n        (0xA768, \"M\", \"\"),\n        (0xA769, \"V\"),\n        (0xA76A, \"M\", \"\"),\n        (0xA76B, \"V\"),\n        (0xA76C, \"M\", \"\"),\n        (0xA76D, \"V\"),\n        (0xA76E, \"M\", \"\"),\n        (0xA76F, \"V\"),\n        (0xA770, \"M\", \"\"),\n        (0xA771, \"V\"),\n        (0xA779, \"M\", \"\"),\n        (0xA77A, \"V\"),\n        (0xA77B, \"M\", \"\"),\n        (0xA77C, \"V\"),\n        (0xA77D, \"M\", \"\"),\n        (0xA77E, \"M\", \"\"),\n        (0xA77F, \"V\"),\n    ]\n\n\ndef _seg_37() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xA780, \"M\", \"\"),\n        (0xA781, \"V\"),\n        (0xA782, \"M\", \"\"),\n        (0xA783, \"V\"),\n        (0xA784, \"M\", \"\"),\n        (0xA785, \"V\"),\n        (0xA786, \"M\", \"\"),\n        (0xA787, \"V\"),\n        (0xA78B, \"M\", \"\"),\n        (0xA78C, \"V\"),\n        (0xA78D, \"M\", \"\"),\n        (0xA78E, \"V\"),\n        (0xA790, \"M\", \"\"),\n        (0xA791, \"V\"),\n        (0xA792, \"M\", \"\"),\n        (0xA793, \"V\"),\n        (0xA796, \"M\", \"\"),\n        (0xA797, \"V\"),\n        (0xA798, \"M\", \"\"),\n        (0xA799, \"V\"),\n        (0xA79A, \"M\", \"\"),\n        (0xA79B, \"V\"),\n        (0xA79C, \"M\", \"\"),\n        (0xA79D, \"V\"),\n        (0xA79E, \"M\", \"\"),\n        (0xA79F, \"V\"),\n        (0xA7A0, \"M\", \"\"),\n        (0xA7A1, \"V\"),\n        (0xA7A2, \"M\", \"\"),\n        (0xA7A3, \"V\"),\n        (0xA7A4, \"M\", \"\"),\n        (0xA7A5, \"V\"),\n        (0xA7A6, \"M\", \"\"),\n        (0xA7A7, \"V\"),\n        (0xA7A8, \"M\", \"\"),\n        (0xA7A9, \"V\"),\n        (0xA7AA, \"M\", \"\"),\n        (0xA7AB, \"M\", \"\"),\n        (0xA7AC, \"M\", \"\"),\n        (0xA7AD, \"M\", \"\"),\n        (0xA7AE, \"M\", \"\"),\n        (0xA7AF, \"V\"),\n        (0xA7B0, \"M\", \"\"),\n        (0xA7B1, \"M\", \"\"),\n        (0xA7B2, \"M\", \"\"),\n        (0xA7B3, \"M\", \"\"),\n        (0xA7B4, \"M\", \"\"),\n        (0xA7B5, \"V\"),\n        (0xA7B6, \"M\", \"\"),\n        (0xA7B7, \"V\"),\n        (0xA7B8, \"M\", \"\"),\n        (0xA7B9, \"V\"),\n        (0xA7BA, \"M\", \"\"),\n        (0xA7BB, \"V\"),\n        (0xA7BC, \"M\", \"\"),\n        (0xA7BD, \"V\"),\n        (0xA7BE, \"M\", \"\"),\n        (0xA7BF, \"V\"),\n        (0xA7C0, \"M\", \"\"),\n        (0xA7C1, \"V\"),\n        (0xA7C2, \"M\", \"\"),\n        (0xA7C3, \"V\"),\n        (0xA7C4, \"M\", \"\"),\n        (0xA7C5, \"M\", \"\"),\n        (0xA7C6, \"M\", \"\"),\n        (0xA7C7, \"M\", \"\"),\n        (0xA7C8, \"V\"),\n        (0xA7C9, \"M\", \"\"),\n        (0xA7CA, \"V\"),\n        (0xA7CB, \"X\"),\n        (0xA7D0, \"M\", \"\"),\n        (0xA7D1, \"V\"),\n        (0xA7D2, \"X\"),\n        (0xA7D3, \"V\"),\n        (0xA7D4, \"X\"),\n        (0xA7D5, \"V\"),\n        (0xA7D6, \"M\", \"\"),\n        (0xA7D7, \"V\"),\n        (0xA7D8, \"M\", \"\"),\n        (0xA7D9, \"V\"),\n        (0xA7DA, \"X\"),\n        (0xA7F2, \"M\", \"c\"),\n        (0xA7F3, \"M\", \"f\"),\n        (0xA7F4, \"M\", \"q\"),\n        (0xA7F5, \"M\", \"\"),\n        (0xA7F6, \"V\"),\n        (0xA7F8, \"M\", \"\"),\n        (0xA7F9, \"M\", \"\"),\n        (0xA7FA, \"V\"),\n        (0xA82D, \"X\"),\n        (0xA830, \"V\"),\n        (0xA83A, \"X\"),\n        (0xA840, \"V\"),\n        (0xA878, \"X\"),\n        (0xA880, \"V\"),\n        (0xA8C6, \"X\"),\n        (0xA8CE, \"V\"),\n        (0xA8DA, \"X\"),\n        (0xA8E0, \"V\"),\n        (0xA954, \"X\"),\n    ]\n\n\ndef _seg_38() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xA95F, \"V\"),\n        (0xA97D, \"X\"),\n        (0xA980, \"V\"),\n        (0xA9CE, \"X\"),\n        (0xA9CF, \"V\"),\n        (0xA9DA, \"X\"),\n        (0xA9DE, \"V\"),\n        (0xA9FF, \"X\"),\n        (0xAA00, \"V\"),\n        (0xAA37, \"X\"),\n        (0xAA40, \"V\"),\n        (0xAA4E, \"X\"),\n        (0xAA50, \"V\"),\n        (0xAA5A, \"X\"),\n        (0xAA5C, \"V\"),\n        (0xAAC3, \"X\"),\n        (0xAADB, \"V\"),\n        (0xAAF7, \"X\"),\n        (0xAB01, \"V\"),\n        (0xAB07, \"X\"),\n        (0xAB09, \"V\"),\n        (0xAB0F, \"X\"),\n        (0xAB11, \"V\"),\n        (0xAB17, \"X\"),\n        (0xAB20, \"V\"),\n        (0xAB27, \"X\"),\n        (0xAB28, \"V\"),\n        (0xAB2F, \"X\"),\n        (0xAB30, \"V\"),\n        (0xAB5C, \"M\", \"\"),\n        (0xAB5D, \"M\", \"\"),\n        (0xAB5E, \"M\", \"\"),\n        (0xAB5F, \"M\", \"\"),\n        (0xAB60, \"V\"),\n        (0xAB69, \"M\", \"\"),\n        (0xAB6A, \"V\"),\n        (0xAB6C, \"X\"),\n        (0xAB70, \"M\", \"\"),\n        (0xAB71, \"M\", \"\"),\n        (0xAB72, \"M\", \"\"),\n        (0xAB73, \"M\", \"\"),\n        (0xAB74, \"M\", \"\"),\n        (0xAB75, \"M\", \"\"),\n        (0xAB76, \"M\", \"\"),\n        (0xAB77, \"M\", \"\"),\n        (0xAB78, \"M\", \"\"),\n        (0xAB79, \"M\", \"\"),\n        (0xAB7A, \"M\", \"\"),\n        (0xAB7B, \"M\", \"\"),\n        (0xAB7C, \"M\", \"\"),\n        (0xAB7D, \"M\", \"\"),\n        (0xAB7E, \"M\", \"\"),\n        (0xAB7F, \"M\", \"\"),\n        (0xAB80, \"M\", \"\"),\n        (0xAB81, \"M\", \"\"),\n        (0xAB82, \"M\", \"\"),\n        (0xAB83, \"M\", \"\"),\n        (0xAB84, \"M\", \"\"),\n        (0xAB85, \"M\", \"\"),\n        (0xAB86, \"M\", \"\"),\n        (0xAB87, \"M\", \"\"),\n        (0xAB88, \"M\", \"\"),\n        (0xAB89, \"M\", \"\"),\n        (0xAB8A, \"M\", \"\"),\n        (0xAB8B, \"M\", \"\"),\n        (0xAB8C, \"M\", \"\"),\n        (0xAB8D, \"M\", \"\"),\n        (0xAB8E, \"M\", \"\"),\n        (0xAB8F, \"M\", \"\"),\n        (0xAB90, \"M\", \"\"),\n        (0xAB91, \"M\", \"\"),\n        (0xAB92, \"M\", \"\"),\n        (0xAB93, \"M\", \"\"),\n        (0xAB94, \"M\", \"\"),\n        (0xAB95, \"M\", \"\"),\n        (0xAB96, \"M\", \"\"),\n        (0xAB97, \"M\", \"\"),\n        (0xAB98, \"M\", \"\"),\n        (0xAB99, \"M\", \"\"),\n        (0xAB9A, \"M\", \"\"),\n        (0xAB9B, \"M\", \"\"),\n        (0xAB9C, \"M\", \"\"),\n        (0xAB9D, \"M\", \"\"),\n        (0xAB9E, \"M\", \"\"),\n        (0xAB9F, \"M\", \"\"),\n        (0xABA0, \"M\", \"\"),\n        (0xABA1, \"M\", \"\"),\n        (0xABA2, \"M\", \"\"),\n        (0xABA3, \"M\", \"\"),\n        (0xABA4, \"M\", \"\"),\n        (0xABA5, \"M\", \"\"),\n        (0xABA6, \"M\", \"\"),\n        (0xABA7, \"M\", \"\"),\n        (0xABA8, \"M\", \"\"),\n        (0xABA9, \"M\", \"\"),\n        (0xABAA, \"M\", \"\"),\n        (0xABAB, \"M\", \"\"),\n        (0xABAC, \"M\", \"\"),\n        (0xABAD, \"M\", \"\"),\n        (0xABAE, \"M\", \"\"),\n    ]\n\n\ndef _seg_39() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xABAF, \"M\", \"\"),\n        (0xABB0, \"M\", \"\"),\n        (0xABB1, \"M\", \"\"),\n        (0xABB2, \"M\", \"\"),\n        (0xABB3, \"M\", \"\"),\n        (0xABB4, \"M\", \"\"),\n        (0xABB5, \"M\", \"\"),\n        (0xABB6, \"M\", \"\"),\n        (0xABB7, \"M\", \"\"),\n        (0xABB8, \"M\", \"\"),\n        (0xABB9, \"M\", \"\"),\n        (0xABBA, \"M\", \"\"),\n        (0xABBB, \"M\", \"\"),\n        (0xABBC, \"M\", \"\"),\n        (0xABBD, \"M\", \"\"),\n        (0xABBE, \"M\", \"\"),\n        (0xABBF, \"M\", \"\"),\n        (0xABC0, \"V\"),\n        (0xABEE, \"X\"),\n        (0xABF0, \"V\"),\n        (0xABFA, \"X\"),\n        (0xAC00, \"V\"),\n        (0xD7A4, \"X\"),\n        (0xD7B0, \"V\"),\n        (0xD7C7, \"X\"),\n        (0xD7CB, \"V\"),\n        (0xD7FC, \"X\"),\n        (0xF900, \"M\", \"\"),\n        (0xF901, \"M\", \"\"),\n        (0xF902, \"M\", \"\"),\n        (0xF903, \"M\", \"\"),\n        (0xF904, \"M\", \"\"),\n        (0xF905, \"M\", \"\"),\n        (0xF906, \"M\", \"\"),\n        (0xF907, \"M\", \"\"),\n        (0xF909, \"M\", \"\"),\n        (0xF90A, \"M\", \"\"),\n        (0xF90B, \"M\", \"\"),\n        (0xF90C, \"M\", \"\"),\n        (0xF90D, \"M\", \"\"),\n        (0xF90E, \"M\", \"\"),\n        (0xF90F, \"M\", \"\"),\n        (0xF910, \"M\", \"\"),\n        (0xF911, \"M\", \"\"),\n        (0xF912, \"M\", \"\"),\n        (0xF913, \"M\", \"\"),\n        (0xF914, \"M\", \"\"),\n        (0xF915, \"M\", \"\"),\n        (0xF916, \"M\", \"\"),\n        (0xF917, \"M\", \"\"),\n        (0xF918, \"M\", \"\"),\n        (0xF919, \"M\", \"\"),\n        (0xF91A, \"M\", \"\"),\n        (0xF91B, \"M\", \"\"),\n        (0xF91C, \"M\", \"\"),\n        (0xF91D, \"M\", \"\"),\n        (0xF91E, \"M\", \"\"),\n        (0xF91F, \"M\", \"\"),\n        (0xF920, \"M\", \"\"),\n        (0xF921, \"M\", \"\"),\n        (0xF922, \"M\", \"\"),\n        (0xF923, \"M\", \"\"),\n        (0xF924, \"M\", \"\"),\n        (0xF925, \"M\", \"\"),\n        (0xF926, \"M\", \"\"),\n        (0xF927, \"M\", \"\"),\n        (0xF928, \"M\", \"\"),\n        (0xF929, \"M\", \"\"),\n        (0xF92A, \"M\", \"\"),\n        (0xF92B, \"M\", \"\"),\n        (0xF92C, \"M\", \"\"),\n        (0xF92D, \"M\", \"\"),\n        (0xF92E, \"M\", \"\"),\n        (0xF92F, \"M\", \"\"),\n        (0xF930, \"M\", \"\"),\n        (0xF931, \"M\", \"\"),\n        (0xF932, \"M\", \"\"),\n        (0xF933, \"M\", \"\"),\n        (0xF934, \"M\", \"\"),\n        (0xF935, \"M\", \"\"),\n        (0xF936, \"M\", \"\"),\n        (0xF937, \"M\", \"\"),\n        (0xF938, \"M\", \"\"),\n        (0xF939, \"M\", \"\"),\n        (0xF93A, \"M\", \"\"),\n        (0xF93B, \"M\", \"\"),\n        (0xF93C, \"M\", \"\"),\n        (0xF93D, \"M\", \"\"),\n        (0xF93E, \"M\", \"\"),\n        (0xF93F, \"M\", \"\"),\n        (0xF940, \"M\", \"\"),\n        (0xF941, \"M\", \"\"),\n        (0xF942, \"M\", \"\"),\n        (0xF943, \"M\", \"\"),\n        (0xF944, \"M\", \"\"),\n        (0xF945, \"M\", \"\"),\n        (0xF946, \"M\", \"\"),\n        (0xF947, \"M\", \"\"),\n        (0xF948, \"M\", \"\"),\n        (0xF949, \"M\", \"\"),\n    ]\n\n\ndef _seg_40() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xF94A, \"M\", \"\"),\n        (0xF94B, \"M\", \"\"),\n        (0xF94C, \"M\", \"\"),\n        (0xF94D, \"M\", \"\"),\n        (0xF94E, \"M\", \"\"),\n        (0xF94F, \"M\", \"\"),\n        (0xF950, \"M\", \"\"),\n        (0xF951, \"M\", \"\"),\n        (0xF952, \"M\", \"\"),\n        (0xF953, \"M\", \"\"),\n        (0xF954, \"M\", \"\"),\n        (0xF955, \"M\", \"\"),\n        (0xF956, \"M\", \"\"),\n        (0xF957, \"M\", \"\"),\n        (0xF958, \"M\", \"\"),\n        (0xF959, \"M\", \"\"),\n        (0xF95A, \"M\", \"\"),\n        (0xF95B, \"M\", \"\"),\n        (0xF95C, \"M\", \"\"),\n        (0xF95D, \"M\", \"\"),\n        (0xF95E, \"M\", \"\"),\n        (0xF95F, \"M\", \"\"),\n        (0xF960, \"M\", \"\"),\n        (0xF961, \"M\", \"\"),\n        (0xF962, \"M\", \"\"),\n        (0xF963, \"M\", \"\"),\n        (0xF964, \"M\", \"\"),\n        (0xF965, \"M\", \"\"),\n        (0xF966, \"M\", \"\"),\n        (0xF967, \"M\", \"\"),\n        (0xF968, \"M\", \"\"),\n        (0xF969, \"M\", \"\"),\n        (0xF96A, \"M\", \"\"),\n        (0xF96B, \"M\", \"\"),\n        (0xF96C, \"M\", \"\"),\n        (0xF96D, \"M\", \"\"),\n        (0xF96E, \"M\", \"\"),\n        (0xF96F, \"M\", \"\"),\n        (0xF970, \"M\", \"\"),\n        (0xF971, \"M\", \"\"),\n        (0xF972, \"M\", \"\"),\n        (0xF973, \"M\", \"\"),\n        (0xF974, \"M\", \"\"),\n        (0xF975, \"M\", \"\"),\n        (0xF976, \"M\", \"\"),\n        (0xF977, \"M\", \"\"),\n        (0xF978, \"M\", \"\"),\n        (0xF979, \"M\", \"\"),\n        (0xF97A, \"M\", \"\"),\n        (0xF97B, \"M\", \"\"),\n        (0xF97C, \"M\", \"\"),\n        (0xF97D, \"M\", \"\"),\n        (0xF97E, \"M\", \"\"),\n        (0xF97F, \"M\", \"\"),\n        (0xF980, \"M\", \"\"),\n        (0xF981, \"M\", \"\"),\n        (0xF982, \"M\", \"\"),\n        (0xF983, \"M\", \"\"),\n        (0xF984, \"M\", \"\"),\n        (0xF985, \"M\", \"\"),\n        (0xF986, \"M\", \"\"),\n        (0xF987, \"M\", \"\"),\n        (0xF988, \"M\", \"\"),\n        (0xF989, \"M\", \"\"),\n        (0xF98A, \"M\", \"\"),\n        (0xF98B, \"M\", \"\"),\n        (0xF98C, \"M\", \"\"),\n        (0xF98D, \"M\", \"\"),\n        (0xF98E, \"M\", \"\"),\n        (0xF98F, \"M\", \"\"),\n        (0xF990, \"M\", \"\"),\n        (0xF991, \"M\", \"\"),\n        (0xF992, \"M\", \"\"),\n        (0xF993, \"M\", \"\"),\n        (0xF994, \"M\", \"\"),\n        (0xF995, \"M\", \"\"),\n        (0xF996, \"M\", \"\"),\n        (0xF997, \"M\", \"\"),\n        (0xF998, \"M\", \"\"),\n        (0xF999, \"M\", \"\"),\n        (0xF99A, \"M\", \"\"),\n        (0xF99B, \"M\", \"\"),\n        (0xF99C, \"M\", \"\"),\n        (0xF99D, \"M\", \"\"),\n        (0xF99E, \"M\", \"\"),\n        (0xF99F, \"M\", \"\"),\n        (0xF9A0, \"M\", \"\"),\n        (0xF9A1, \"M\", \"\"),\n        (0xF9A2, \"M\", \"\"),\n        (0xF9A3, \"M\", \"\"),\n        (0xF9A4, \"M\", \"\"),\n        (0xF9A5, \"M\", \"\"),\n        (0xF9A6, \"M\", \"\"),\n        (0xF9A7, \"M\", \"\"),\n        (0xF9A8, \"M\", \"\"),\n        (0xF9A9, \"M\", \"\"),\n        (0xF9AA, \"M\", \"\"),\n        (0xF9AB, \"M\", \"\"),\n        (0xF9AC, \"M\", \"\"),\n        (0xF9AD, \"M\", \"\"),\n    ]\n\n\ndef _seg_41() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xF9AE, \"M\", \"\"),\n        (0xF9AF, \"M\", \"\"),\n        (0xF9B0, \"M\", \"\"),\n        (0xF9B1, \"M\", \"\"),\n        (0xF9B2, \"M\", \"\"),\n        (0xF9B3, \"M\", \"\"),\n        (0xF9B4, \"M\", \"\"),\n        (0xF9B5, \"M\", \"\"),\n        (0xF9B6, \"M\", \"\"),\n        (0xF9B7, \"M\", \"\"),\n        (0xF9B8, \"M\", \"\"),\n        (0xF9B9, \"M\", \"\"),\n        (0xF9BA, \"M\", \"\"),\n        (0xF9BB, \"M\", \"\"),\n        (0xF9BC, \"M\", \"\"),\n        (0xF9BD, \"M\", \"\"),\n        (0xF9BE, \"M\", \"\"),\n        (0xF9BF, \"M\", \"\"),\n        (0xF9C0, \"M\", \"\"),\n        (0xF9C1, \"M\", \"\"),\n        (0xF9C2, \"M\", \"\"),\n        (0xF9C3, \"M\", \"\"),\n        (0xF9C4, \"M\", \"\"),\n        (0xF9C5, \"M\", \"\"),\n        (0xF9C6, \"M\", \"\"),\n        (0xF9C7, \"M\", \"\"),\n        (0xF9C8, \"M\", \"\"),\n        (0xF9C9, \"M\", \"\"),\n        (0xF9CA, \"M\", \"\"),\n        (0xF9CB, \"M\", \"\"),\n        (0xF9CC, \"M\", \"\"),\n        (0xF9CD, \"M\", \"\"),\n        (0xF9CE, \"M\", \"\"),\n        (0xF9CF, \"M\", \"\"),\n        (0xF9D0, \"M\", \"\"),\n        (0xF9D1, \"M\", \"\"),\n        (0xF9D2, \"M\", \"\"),\n        (0xF9D3, \"M\", \"\"),\n        (0xF9D4, \"M\", \"\"),\n        (0xF9D5, \"M\", \"\"),\n        (0xF9D6, \"M\", \"\"),\n        (0xF9D7, \"M\", \"\"),\n        (0xF9D8, \"M\", \"\"),\n        (0xF9D9, \"M\", \"\"),\n        (0xF9DA, \"M\", \"\"),\n        (0xF9DB, \"M\", \"\"),\n        (0xF9DC, \"M\", \"\"),\n        (0xF9DD, \"M\", \"\"),\n        (0xF9DE, \"M\", \"\"),\n        (0xF9DF, \"M\", \"\"),\n        (0xF9E0, \"M\", \"\"),\n        (0xF9E1, \"M\", \"\"),\n        (0xF9E2, \"M\", \"\"),\n        (0xF9E3, \"M\", \"\"),\n        (0xF9E4, \"M\", \"\"),\n        (0xF9E5, \"M\", \"\"),\n        (0xF9E6, \"M\", \"\"),\n        (0xF9E7, \"M\", \"\"),\n        (0xF9E8, \"M\", \"\"),\n        (0xF9E9, \"M\", \"\"),\n        (0xF9EA, \"M\", \"\"),\n        (0xF9EB, \"M\", \"\"),\n        (0xF9EC, \"M\", \"\"),\n        (0xF9ED, \"M\", \"\"),\n        (0xF9EE, \"M\", \"\"),\n        (0xF9EF, \"M\", \"\"),\n        (0xF9F0, \"M\", \"\"),\n        (0xF9F1, \"M\", \"\"),\n        (0xF9F2, \"M\", \"\"),\n        (0xF9F3, \"M\", \"\"),\n        (0xF9F4, \"M\", \"\"),\n        (0xF9F5, \"M\", \"\"),\n        (0xF9F6, \"M\", \"\"),\n        (0xF9F7, \"M\", \"\"),\n        (0xF9F8, \"M\", \"\"),\n        (0xF9F9, \"M\", \"\"),\n        (0xF9FA, \"M\", \"\"),\n        (0xF9FB, \"M\", \"\"),\n        (0xF9FC, \"M\", \"\"),\n        (0xF9FD, \"M\", \"\"),\n        (0xF9FE, \"M\", \"\"),\n        (0xF9FF, \"M\", \"\"),\n        (0xFA00, \"M\", \"\"),\n        (0xFA01, \"M\", \"\"),\n        (0xFA02, \"M\", \"\"),\n        (0xFA03, \"M\", \"\"),\n        (0xFA04, \"M\", \"\"),\n        (0xFA05, \"M\", \"\"),\n        (0xFA06, \"M\", \"\"),\n        (0xFA07, \"M\", \"\"),\n        (0xFA08, \"M\", \"\"),\n        (0xFA09, \"M\", \"\"),\n        (0xFA0A, \"M\", \"\"),\n        (0xFA0B, \"M\", \"\"),\n        (0xFA0C, \"M\", \"\"),\n        (0xFA0D, \"M\", \"\"),\n        (0xFA0E, \"V\"),\n        (0xFA10, \"M\", \"\"),\n        (0xFA11, \"V\"),\n        (0xFA12, \"M\", \"\"),\n    ]\n\n\ndef _seg_42() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xFA13, \"V\"),\n        (0xFA15, \"M\", \"\"),\n        (0xFA16, \"M\", \"\"),\n        (0xFA17, \"M\", \"\"),\n        (0xFA18, \"M\", \"\"),\n        (0xFA19, \"M\", \"\"),\n        (0xFA1A, \"M\", \"\"),\n        (0xFA1B, \"M\", \"\"),\n        (0xFA1C, \"M\", \"\"),\n        (0xFA1D, \"M\", \"\"),\n        (0xFA1E, \"M\", \"\"),\n        (0xFA1F, \"V\"),\n        (0xFA20, \"M\", \"\"),\n        (0xFA21, \"V\"),\n        (0xFA22, \"M\", \"\"),\n        (0xFA23, \"V\"),\n        (0xFA25, \"M\", \"\"),\n        (0xFA26, \"M\", \"\"),\n        (0xFA27, \"V\"),\n        (0xFA2A, \"M\", \"\"),\n        (0xFA2B, \"M\", \"\"),\n        (0xFA2C, \"M\", \"\"),\n        (0xFA2D, \"M\", \"\"),\n        (0xFA2E, \"M\", \"\"),\n        (0xFA2F, \"M\", \"\"),\n        (0xFA30, \"M\", \"\"),\n        (0xFA31, \"M\", \"\"),\n        (0xFA32, \"M\", \"\"),\n        (0xFA33, \"M\", \"\"),\n        (0xFA34, \"M\", \"\"),\n        (0xFA35, \"M\", \"\"),\n        (0xFA36, \"M\", \"\"),\n        (0xFA37, \"M\", \"\"),\n        (0xFA38, \"M\", \"\"),\n        (0xFA39, \"M\", \"\"),\n        (0xFA3A, \"M\", \"\"),\n        (0xFA3B, \"M\", \"\"),\n        (0xFA3C, \"M\", \"\"),\n        (0xFA3D, \"M\", \"\"),\n        (0xFA3E, \"M\", \"\"),\n        (0xFA3F, \"M\", \"\"),\n        (0xFA40, \"M\", \"\"),\n        (0xFA41, \"M\", \"\"),\n        (0xFA42, \"M\", \"\"),\n        (0xFA43, \"M\", \"\"),\n        (0xFA44, \"M\", \"\"),\n        (0xFA45, \"M\", \"\"),\n        (0xFA46, \"M\", \"\"),\n        (0xFA47, \"M\", \"\"),\n        (0xFA48, \"M\", \"\"),\n        (0xFA49, \"M\", \"\"),\n        (0xFA4A, \"M\", \"\"),\n        (0xFA4B, \"M\", \"\"),\n        (0xFA4C, \"M\", \"\"),\n        (0xFA4D, \"M\", \"\"),\n        (0xFA4E, \"M\", \"\"),\n        (0xFA4F, \"M\", \"\"),\n        (0xFA50, \"M\", \"\"),\n        (0xFA51, \"M\", \"\"),\n        (0xFA52, \"M\", \"\"),\n        (0xFA53, \"M\", \"\"),\n        (0xFA54, \"M\", \"\"),\n        (0xFA55, \"M\", \"\"),\n        (0xFA56, \"M\", \"\"),\n        (0xFA57, \"M\", \"\"),\n        (0xFA58, \"M\", \"\"),\n        (0xFA59, \"M\", \"\"),\n        (0xFA5A, \"M\", \"\"),\n        (0xFA5B, \"M\", \"\"),\n        (0xFA5C, \"M\", \"\"),\n        (0xFA5D, \"M\", \"\"),\n        (0xFA5F, \"M\", \"\"),\n        (0xFA60, \"M\", \"\"),\n        (0xFA61, \"M\", \"\"),\n        (0xFA62, \"M\", \"\"),\n        (0xFA63, \"M\", \"\"),\n        (0xFA64, \"M\", \"\"),\n        (0xFA65, \"M\", \"\"),\n        (0xFA66, \"M\", \"\"),\n        (0xFA67, \"M\", \"\"),\n        (0xFA68, \"M\", \"\"),\n        (0xFA69, \"M\", \"\"),\n        (0xFA6A, \"M\", \"\"),\n        (0xFA6B, \"M\", \"\"),\n        (0xFA6C, \"M\", \"\"),\n        (0xFA6D, \"M\", \"\"),\n        (0xFA6E, \"X\"),\n        (0xFA70, \"M\", \"\"),\n        (0xFA71, \"M\", \"\"),\n        (0xFA72, \"M\", \"\"),\n        (0xFA73, \"M\", \"\"),\n        (0xFA74, \"M\", \"\"),\n        (0xFA75, \"M\", \"\"),\n        (0xFA76, \"M\", \"\"),\n        (0xFA77, \"M\", \"\"),\n        (0xFA78, \"M\", \"\"),\n        (0xFA79, \"M\", \"\"),\n        (0xFA7A, \"M\", \"\"),\n        (0xFA7B, \"M\", \"\"),\n        (0xFA7C, \"M\", \"\"),\n    ]\n\n\ndef _seg_43() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xFA7D, \"M\", \"\"),\n        (0xFA7E, \"M\", \"\"),\n        (0xFA7F, \"M\", \"\"),\n        (0xFA80, \"M\", \"\"),\n        (0xFA81, \"M\", \"\"),\n        (0xFA82, \"M\", \"\"),\n        (0xFA83, \"M\", \"\"),\n        (0xFA84, \"M\", \"\"),\n        (0xFA85, \"M\", \"\"),\n        (0xFA86, \"M\", \"\"),\n        (0xFA87, \"M\", \"\"),\n        (0xFA88, \"M\", \"\"),\n        (0xFA89, \"M\", \"\"),\n        (0xFA8A, \"M\", \"\"),\n        (0xFA8B, \"M\", \"\"),\n        (0xFA8C, \"M\", \"\"),\n        (0xFA8D, \"M\", \"\"),\n        (0xFA8E, \"M\", \"\"),\n        (0xFA8F, \"M\", \"\"),\n        (0xFA90, \"M\", \"\"),\n        (0xFA91, \"M\", \"\"),\n        (0xFA92, \"M\", \"\"),\n        (0xFA93, \"M\", \"\"),\n        (0xFA94, \"M\", \"\"),\n        (0xFA95, \"M\", \"\"),\n        (0xFA96, \"M\", \"\"),\n        (0xFA97, \"M\", \"\"),\n        (0xFA98, \"M\", \"\"),\n        (0xFA99, \"M\", \"\"),\n        (0xFA9A, \"M\", \"\"),\n        (0xFA9B, \"M\", \"\"),\n        (0xFA9C, \"M\", \"\"),\n        (0xFA9D, \"M\", \"\"),\n        (0xFA9E, \"M\", \"\"),\n        (0xFA9F, \"M\", \"\"),\n        (0xFAA0, \"M\", \"\"),\n        (0xFAA1, \"M\", \"\"),\n        (0xFAA2, \"M\", \"\"),\n        (0xFAA3, \"M\", \"\"),\n        (0xFAA4, \"M\", \"\"),\n        (0xFAA5, \"M\", \"\"),\n        (0xFAA6, \"M\", \"\"),\n        (0xFAA7, \"M\", \"\"),\n        (0xFAA8, \"M\", \"\"),\n        (0xFAA9, \"M\", \"\"),\n        (0xFAAA, \"M\", \"\"),\n        (0xFAAB, \"M\", \"\"),\n        (0xFAAC, \"M\", \"\"),\n        (0xFAAD, \"M\", \"\"),\n        (0xFAAE, \"M\", \"\"),\n        (0xFAAF, \"M\", \"\"),\n        (0xFAB0, \"M\", \"\"),\n        (0xFAB1, \"M\", \"\"),\n        (0xFAB2, \"M\", \"\"),\n        (0xFAB3, \"M\", \"\"),\n        (0xFAB4, \"M\", \"\"),\n        (0xFAB5, \"M\", \"\"),\n        (0xFAB6, \"M\", \"\"),\n        (0xFAB7, \"M\", \"\"),\n        (0xFAB8, \"M\", \"\"),\n        (0xFAB9, \"M\", \"\"),\n        (0xFABA, \"M\", \"\"),\n        (0xFABB, \"M\", \"\"),\n        (0xFABC, \"M\", \"\"),\n        (0xFABD, \"M\", \"\"),\n        (0xFABE, \"M\", \"\"),\n        (0xFABF, \"M\", \"\"),\n        (0xFAC0, \"M\", \"\"),\n        (0xFAC1, \"M\", \"\"),\n        (0xFAC2, \"M\", \"\"),\n        (0xFAC3, \"M\", \"\"),\n        (0xFAC4, \"M\", \"\"),\n        (0xFAC5, \"M\", \"\"),\n        (0xFAC6, \"M\", \"\"),\n        (0xFAC7, \"M\", \"\"),\n        (0xFAC8, \"M\", \"\"),\n        (0xFAC9, \"M\", \"\"),\n        (0xFACA, \"M\", \"\"),\n        (0xFACB, \"M\", \"\"),\n        (0xFACC, \"M\", \"\"),\n        (0xFACD, \"M\", \"\"),\n        (0xFACE, \"M\", \"\"),\n        (0xFACF, \"M\", \"\"),\n        (0xFAD0, \"M\", \"\"),\n        (0xFAD1, \"M\", \"\"),\n        (0xFAD2, \"M\", \"\"),\n        (0xFAD3, \"M\", \"\"),\n        (0xFAD4, \"M\", \"\"),\n        (0xFAD5, \"M\", \"\"),\n        (0xFAD6, \"M\", \"\"),\n        (0xFAD7, \"M\", \"\"),\n        (0xFAD8, \"M\", \"\"),\n        (0xFAD9, \"M\", \"\"),\n        (0xFADA, \"X\"),\n        (0xFB00, \"M\", \"ff\"),\n        (0xFB01, \"M\", \"fi\"),\n        (0xFB02, \"M\", \"fl\"),\n        (0xFB03, \"M\", \"ffi\"),\n        (0xFB04, \"M\", \"ffl\"),\n        (0xFB05, \"M\", \"st\"),\n    ]\n\n\ndef _seg_44() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xFB07, \"X\"),\n        (0xFB13, \"M\", \"\"),\n        (0xFB14, \"M\", \"\"),\n        (0xFB15, \"M\", \"\"),\n        (0xFB16, \"M\", \"\"),\n        (0xFB17, \"M\", \"\"),\n        (0xFB18, \"X\"),\n        (0xFB1D, \"M\", \"\"),\n        (0xFB1E, \"V\"),\n        (0xFB1F, \"M\", \"\"),\n        (0xFB20, \"M\", \"\"),\n        (0xFB21, \"M\", \"\"),\n        (0xFB22, \"M\", \"\"),\n        (0xFB23, \"M\", \"\"),\n        (0xFB24, \"M\", \"\"),\n        (0xFB25, \"M\", \"\"),\n        (0xFB26, \"M\", \"\"),\n        (0xFB27, \"M\", \"\"),\n        (0xFB28, \"M\", \"\"),\n        (0xFB29, \"3\", \"+\"),\n        (0xFB2A, \"M\", \"\"),\n        (0xFB2B, \"M\", \"\"),\n        (0xFB2C, \"M\", \"\"),\n        (0xFB2D, \"M\", \"\"),\n        (0xFB2E, \"M\", \"\"),\n        (0xFB2F, \"M\", \"\"),\n        (0xFB30, \"M\", \"\"),\n        (0xFB31, \"M\", \"\"),\n        (0xFB32, \"M\", \"\"),\n        (0xFB33, \"M\", \"\"),\n        (0xFB34, \"M\", \"\"),\n        (0xFB35, \"M\", \"\"),\n        (0xFB36, \"M\", \"\"),\n        (0xFB37, \"X\"),\n        (0xFB38, \"M\", \"\"),\n        (0xFB39, \"M\", \"\"),\n        (0xFB3A, \"M\", \"\"),\n        (0xFB3B, \"M\", \"\"),\n        (0xFB3C, \"M\", \"\"),\n        (0xFB3D, \"X\"),\n        (0xFB3E, \"M\", \"\"),\n        (0xFB3F, \"X\"),\n        (0xFB40, \"M\", \"\"),\n        (0xFB41, \"M\", \"\"),\n        (0xFB42, \"X\"),\n        (0xFB43, \"M\", \"\"),\n        (0xFB44, \"M\", \"\"),\n        (0xFB45, \"X\"),\n        (0xFB46, \"M\", \"\"),\n        (0xFB47, \"M\", \"\"),\n        (0xFB48, \"M\", \"\"),\n        (0xFB49, \"M\", \"\"),\n        (0xFB4A, \"M\", \"\"),\n        (0xFB4B, \"M\", \"\"),\n        (0xFB4C, \"M\", \"\"),\n        (0xFB4D, \"M\", \"\"),\n        (0xFB4E, \"M\", \"\"),\n        (0xFB4F, \"M\", \"\"),\n        (0xFB50, \"M\", \"\"),\n        (0xFB52, \"M\", \"\"),\n        (0xFB56, \"M\", \"\"),\n        (0xFB5A, \"M\", \"\"),\n        (0xFB5E, \"M\", \"\"),\n        (0xFB62, \"M\", \"\"),\n        (0xFB66, \"M\", \"\"),\n        (0xFB6A, \"M\", \"\"),\n        (0xFB6E, \"M\", \"\"),\n        (0xFB72, \"M\", \"\"),\n        (0xFB76, \"M\", \"\"),\n        (0xFB7A, \"M\", \"\"),\n        (0xFB7E, \"M\", \"\"),\n        (0xFB82, \"M\", \"\"),\n        (0xFB84, \"M\", \"\"),\n        (0xFB86, \"M\", \"\"),\n        (0xFB88, \"M\", \"\"),\n        (0xFB8A, \"M\", \"\"),\n        (0xFB8C, \"M\", \"\"),\n        (0xFB8E, \"M\", \"\"),\n        (0xFB92, \"M\", \"\"),\n        (0xFB96, \"M\", \"\"),\n        (0xFB9A, \"M\", \"\"),\n        (0xFB9E, \"M\", \"\"),\n        (0xFBA0, \"M\", \"\"),\n        (0xFBA4, \"M\", \"\"),\n        (0xFBA6, \"M\", \"\"),\n        (0xFBAA, \"M\", \"\"),\n        (0xFBAE, \"M\", \"\"),\n        (0xFBB0, \"M\", \"\"),\n        (0xFBB2, \"V\"),\n        (0xFBC3, \"X\"),\n        (0xFBD3, \"M\", \"\"),\n        (0xFBD7, \"M\", \"\"),\n        (0xFBD9, \"M\", \"\"),\n        (0xFBDB, \"M\", \"\"),\n        (0xFBDD, \"M\", \"\"),\n        (0xFBDE, \"M\", \"\"),\n        (0xFBE0, \"M\", \"\"),\n        (0xFBE2, \"M\", \"\"),\n        (0xFBE4, \"M\", \"\"),\n        (0xFBE8, \"M\", \"\"),\n    ]\n\n\ndef _seg_45() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xFBEA, \"M\", \"\"),\n        (0xFBEC, \"M\", \"\"),\n        (0xFBEE, \"M\", \"\"),\n        (0xFBF0, \"M\", \"\"),\n        (0xFBF2, \"M\", \"\"),\n        (0xFBF4, \"M\", \"\"),\n        (0xFBF6, \"M\", \"\"),\n        (0xFBF9, \"M\", \"\"),\n        (0xFBFC, \"M\", \"\"),\n        (0xFC00, \"M\", \"\"),\n        (0xFC01, \"M\", \"\"),\n        (0xFC02, \"M\", \"\"),\n        (0xFC03, \"M\", \"\"),\n        (0xFC04, \"M\", \"\"),\n        (0xFC05, \"M\", \"\"),\n        (0xFC06, \"M\", \"\"),\n        (0xFC07, \"M\", \"\"),\n        (0xFC08, \"M\", \"\"),\n        (0xFC09, \"M\", \"\"),\n        (0xFC0A, \"M\", \"\"),\n        (0xFC0B, \"M\", \"\"),\n        (0xFC0C, \"M\", \"\"),\n        (0xFC0D, \"M\", \"\"),\n        (0xFC0E, \"M\", \"\"),\n        (0xFC0F, \"M\", \"\"),\n        (0xFC10, \"M\", \"\"),\n        (0xFC11, \"M\", \"\"),\n        (0xFC12, \"M\", \"\"),\n        (0xFC13, \"M\", \"\"),\n        (0xFC14, \"M\", \"\"),\n        (0xFC15, \"M\", \"\"),\n        (0xFC16, \"M\", \"\"),\n        (0xFC17, \"M\", \"\"),\n        (0xFC18, \"M\", \"\"),\n        (0xFC19, \"M\", \"\"),\n        (0xFC1A, \"M\", \"\"),\n        (0xFC1B, \"M\", \"\"),\n        (0xFC1C, \"M\", \"\"),\n        (0xFC1D, \"M\", \"\"),\n        (0xFC1E, \"M\", \"\"),\n        (0xFC1F, \"M\", \"\"),\n        (0xFC20, \"M\", \"\"),\n        (0xFC21, \"M\", \"\"),\n        (0xFC22, \"M\", \"\"),\n        (0xFC23, \"M\", \"\"),\n        (0xFC24, \"M\", \"\"),\n        (0xFC25, \"M\", \"\"),\n        (0xFC26, \"M\", \"\"),\n        (0xFC27, \"M\", \"\"),\n        (0xFC28, \"M\", \"\"),\n        (0xFC29, \"M\", \"\"),\n        (0xFC2A, \"M\", \"\"),\n        (0xFC2B, \"M\", \"\"),\n        (0xFC2C, \"M\", \"\"),\n        (0xFC2D, \"M\", \"\"),\n        (0xFC2E, \"M\", \"\"),\n        (0xFC2F, \"M\", \"\"),\n        (0xFC30, \"M\", \"\"),\n        (0xFC31, \"M\", \"\"),\n        (0xFC32, \"M\", \"\"),\n        (0xFC33, \"M\", \"\"),\n        (0xFC34, \"M\", \"\"),\n        (0xFC35, \"M\", \"\"),\n        (0xFC36, \"M\", \"\"),\n        (0xFC37, \"M\", \"\"),\n        (0xFC38, \"M\", \"\"),\n        (0xFC39, \"M\", \"\"),\n        (0xFC3A, \"M\", \"\"),\n        (0xFC3B, \"M\", \"\"),\n        (0xFC3C, \"M\", \"\"),\n        (0xFC3D, \"M\", \"\"),\n        (0xFC3E, \"M\", \"\"),\n        (0xFC3F, \"M\", \"\"),\n        (0xFC40, \"M\", \"\"),\n        (0xFC41, \"M\", \"\"),\n        (0xFC42, \"M\", \"\"),\n        (0xFC43, \"M\", \"\"),\n        (0xFC44, \"M\", \"\"),\n        (0xFC45, \"M\", \"\"),\n        (0xFC46, \"M\", \"\"),\n        (0xFC47, \"M\", \"\"),\n        (0xFC48, \"M\", \"\"),\n        (0xFC49, \"M\", \"\"),\n        (0xFC4A, \"M\", \"\"),\n        (0xFC4B, \"M\", \"\"),\n        (0xFC4C, \"M\", \"\"),\n        (0xFC4D, \"M\", \"\"),\n        (0xFC4E, \"M\", \"\"),\n        (0xFC4F, \"M\", \"\"),\n        (0xFC50, \"M\", \"\"),\n        (0xFC51, \"M\", \"\"),\n        (0xFC52, \"M\", \"\"),\n        (0xFC53, \"M\", \"\"),\n        (0xFC54, \"M\", \"\"),\n        (0xFC55, \"M\", \"\"),\n        (0xFC56, \"M\", \"\"),\n        (0xFC57, \"M\", \"\"),\n        (0xFC58, \"M\", \"\"),\n        (0xFC59, \"M\", \"\"),\n        (0xFC5A, \"M\", \"\"),\n    ]\n\n\ndef _seg_46() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xFC5B, \"M\", \"\"),\n        (0xFC5C, \"M\", \"\"),\n        (0xFC5D, \"M\", \"\"),\n        (0xFC5E, \"3\", \" \"),\n        (0xFC5F, \"3\", \" \"),\n        (0xFC60, \"3\", \" \"),\n        (0xFC61, \"3\", \" \"),\n        (0xFC62, \"3\", \" \"),\n        (0xFC63, \"3\", \" \"),\n        (0xFC64, \"M\", \"\"),\n        (0xFC65, \"M\", \"\"),\n        (0xFC66, \"M\", \"\"),\n        (0xFC67, \"M\", \"\"),\n        (0xFC68, \"M\", \"\"),\n        (0xFC69, \"M\", \"\"),\n        (0xFC6A, \"M\", \"\"),\n        (0xFC6B, \"M\", \"\"),\n        (0xFC6C, \"M\", \"\"),\n        (0xFC6D, \"M\", \"\"),\n        (0xFC6E, \"M\", \"\"),\n        (0xFC6F, \"M\", \"\"),\n        (0xFC70, \"M\", \"\"),\n        (0xFC71, \"M\", \"\"),\n        (0xFC72, \"M\", \"\"),\n        (0xFC73, \"M\", \"\"),\n        (0xFC74, \"M\", \"\"),\n        (0xFC75, \"M\", \"\"),\n        (0xFC76, \"M\", \"\"),\n        (0xFC77, \"M\", \"\"),\n        (0xFC78, \"M\", \"\"),\n        (0xFC79, \"M\", \"\"),\n        (0xFC7A, \"M\", \"\"),\n        (0xFC7B, \"M\", \"\"),\n        (0xFC7C, \"M\", \"\"),\n        (0xFC7D, \"M\", \"\"),\n        (0xFC7E, \"M\", \"\"),\n        (0xFC7F, \"M\", \"\"),\n        (0xFC80, \"M\", \"\"),\n        (0xFC81, \"M\", \"\"),\n        (0xFC82, \"M\", \"\"),\n        (0xFC83, \"M\", \"\"),\n        (0xFC84, \"M\", \"\"),\n        (0xFC85, \"M\", \"\"),\n        (0xFC86, \"M\", \"\"),\n        (0xFC87, \"M\", \"\"),\n        (0xFC88, \"M\", \"\"),\n        (0xFC89, \"M\", \"\"),\n        (0xFC8A, \"M\", \"\"),\n        (0xFC8B, \"M\", \"\"),\n        (0xFC8C, \"M\", \"\"),\n        (0xFC8D, \"M\", \"\"),\n        (0xFC8E, \"M\", \"\"),\n        (0xFC8F, \"M\", \"\"),\n        (0xFC90, \"M\", \"\"),\n        (0xFC91, \"M\", \"\"),\n        (0xFC92, \"M\", \"\"),\n        (0xFC93, \"M\", \"\"),\n        (0xFC94, \"M\", \"\"),\n        (0xFC95, \"M\", \"\"),\n        (0xFC96, \"M\", \"\"),\n        (0xFC97, \"M\", \"\"),\n        (0xFC98, \"M\", \"\"),\n        (0xFC99, \"M\", \"\"),\n        (0xFC9A, \"M\", \"\"),\n        (0xFC9B, \"M\", \"\"),\n        (0xFC9C, \"M\", \"\"),\n        (0xFC9D, \"M\", \"\"),\n        (0xFC9E, \"M\", \"\"),\n        (0xFC9F, \"M\", \"\"),\n        (0xFCA0, \"M\", \"\"),\n        (0xFCA1, \"M\", \"\"),\n        (0xFCA2, \"M\", \"\"),\n        (0xFCA3, \"M\", \"\"),\n        (0xFCA4, \"M\", \"\"),\n        (0xFCA5, \"M\", \"\"),\n        (0xFCA6, \"M\", \"\"),\n        (0xFCA7, \"M\", \"\"),\n        (0xFCA8, \"M\", \"\"),\n        (0xFCA9, \"M\", \"\"),\n        (0xFCAA, \"M\", \"\"),\n        (0xFCAB, \"M\", \"\"),\n        (0xFCAC, \"M\", \"\"),\n        (0xFCAD, \"M\", \"\"),\n        (0xFCAE, \"M\", \"\"),\n        (0xFCAF, \"M\", \"\"),\n        (0xFCB0, \"M\", \"\"),\n        (0xFCB1, \"M\", \"\"),\n        (0xFCB2, \"M\", \"\"),\n        (0xFCB3, \"M\", \"\"),\n        (0xFCB4, \"M\", \"\"),\n        (0xFCB5, \"M\", \"\"),\n        (0xFCB6, \"M\", \"\"),\n        (0xFCB7, \"M\", \"\"),\n        (0xFCB8, \"M\", \"\"),\n        (0xFCB9, \"M\", \"\"),\n        (0xFCBA, \"M\", \"\"),\n        (0xFCBB, \"M\", \"\"),\n        (0xFCBC, \"M\", \"\"),\n        (0xFCBD, \"M\", \"\"),\n        (0xFCBE, \"M\", \"\"),\n    ]\n\n\ndef _seg_47() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xFCBF, \"M\", \"\"),\n        (0xFCC0, \"M\", \"\"),\n        (0xFCC1, \"M\", \"\"),\n        (0xFCC2, \"M\", \"\"),\n        (0xFCC3, \"M\", \"\"),\n        (0xFCC4, \"M\", \"\"),\n        (0xFCC5, \"M\", \"\"),\n        (0xFCC6, \"M\", \"\"),\n        (0xFCC7, \"M\", \"\"),\n        (0xFCC8, \"M\", \"\"),\n        (0xFCC9, \"M\", \"\"),\n        (0xFCCA, \"M\", \"\"),\n        (0xFCCB, \"M\", \"\"),\n        (0xFCCC, \"M\", \"\"),\n        (0xFCCD, \"M\", \"\"),\n        (0xFCCE, \"M\", \"\"),\n        (0xFCCF, \"M\", \"\"),\n        (0xFCD0, \"M\", \"\"),\n        (0xFCD1, \"M\", \"\"),\n        (0xFCD2, \"M\", \"\"),\n        (0xFCD3, \"M\", \"\"),\n        (0xFCD4, \"M\", \"\"),\n        (0xFCD5, \"M\", \"\"),\n        (0xFCD6, \"M\", \"\"),\n        (0xFCD7, \"M\", \"\"),\n        (0xFCD8, \"M\", \"\"),\n        (0xFCD9, \"M\", \"\"),\n        (0xFCDA, \"M\", \"\"),\n        (0xFCDB, \"M\", \"\"),\n        (0xFCDC, \"M\", \"\"),\n        (0xFCDD, \"M\", \"\"),\n        (0xFCDE, \"M\", \"\"),\n        (0xFCDF, \"M\", \"\"),\n        (0xFCE0, \"M\", \"\"),\n        (0xFCE1, \"M\", \"\"),\n        (0xFCE2, \"M\", \"\"),\n        (0xFCE3, \"M\", \"\"),\n        (0xFCE4, \"M\", \"\"),\n        (0xFCE5, \"M\", \"\"),\n        (0xFCE6, \"M\", \"\"),\n        (0xFCE7, \"M\", \"\"),\n        (0xFCE8, \"M\", \"\"),\n        (0xFCE9, \"M\", \"\"),\n        (0xFCEA, \"M\", \"\"),\n        (0xFCEB, \"M\", \"\"),\n        (0xFCEC, \"M\", \"\"),\n        (0xFCED, \"M\", \"\"),\n        (0xFCEE, \"M\", \"\"),\n        (0xFCEF, \"M\", \"\"),\n        (0xFCF0, \"M\", \"\"),\n        (0xFCF1, \"M\", \"\"),\n        (0xFCF2, \"M\", \"\"),\n        (0xFCF3, \"M\", \"\"),\n        (0xFCF4, \"M\", \"\"),\n        (0xFCF5, \"M\", \"\"),\n        (0xFCF6, \"M\", \"\"),\n        (0xFCF7, \"M\", \"\"),\n        (0xFCF8, \"M\", \"\"),\n        (0xFCF9, \"M\", \"\"),\n        (0xFCFA, \"M\", \"\"),\n        (0xFCFB, \"M\", \"\"),\n        (0xFCFC, \"M\", \"\"),\n        (0xFCFD, \"M\", \"\"),\n        (0xFCFE, \"M\", \"\"),\n        (0xFCFF, \"M\", \"\"),\n        (0xFD00, \"M\", \"\"),\n        (0xFD01, \"M\", \"\"),\n        (0xFD02, \"M\", \"\"),\n        (0xFD03, \"M\", \"\"),\n        (0xFD04, \"M\", \"\"),\n        (0xFD05, \"M\", \"\"),\n        (0xFD06, \"M\", \"\"),\n        (0xFD07, \"M\", \"\"),\n        (0xFD08, \"M\", \"\"),\n        (0xFD09, \"M\", \"\"),\n        (0xFD0A, \"M\", \"\"),\n        (0xFD0B, \"M\", \"\"),\n        (0xFD0C, \"M\", \"\"),\n        (0xFD0D, \"M\", \"\"),\n        (0xFD0E, \"M\", \"\"),\n        (0xFD0F, \"M\", \"\"),\n        (0xFD10, \"M\", \"\"),\n        (0xFD11, \"M\", \"\"),\n        (0xFD12, \"M\", \"\"),\n        (0xFD13, \"M\", \"\"),\n        (0xFD14, \"M\", \"\"),\n        (0xFD15, \"M\", \"\"),\n        (0xFD16, \"M\", \"\"),\n        (0xFD17, \"M\", \"\"),\n        (0xFD18, \"M\", \"\"),\n        (0xFD19, \"M\", \"\"),\n        (0xFD1A, \"M\", \"\"),\n        (0xFD1B, \"M\", \"\"),\n        (0xFD1C, \"M\", \"\"),\n        (0xFD1D, \"M\", \"\"),\n        (0xFD1E, \"M\", \"\"),\n        (0xFD1F, \"M\", \"\"),\n        (0xFD20, \"M\", \"\"),\n        (0xFD21, \"M\", \"\"),\n        (0xFD22, \"M\", \"\"),\n    ]\n\n\ndef _seg_48() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xFD23, \"M\", \"\"),\n        (0xFD24, \"M\", \"\"),\n        (0xFD25, \"M\", \"\"),\n        (0xFD26, \"M\", \"\"),\n        (0xFD27, \"M\", \"\"),\n        (0xFD28, \"M\", \"\"),\n        (0xFD29, \"M\", \"\"),\n        (0xFD2A, \"M\", \"\"),\n        (0xFD2B, \"M\", \"\"),\n        (0xFD2C, \"M\", \"\"),\n        (0xFD2D, \"M\", \"\"),\n        (0xFD2E, \"M\", \"\"),\n        (0xFD2F, \"M\", \"\"),\n        (0xFD30, \"M\", \"\"),\n        (0xFD31, \"M\", \"\"),\n        (0xFD32, \"M\", \"\"),\n        (0xFD33, \"M\", \"\"),\n        (0xFD34, \"M\", \"\"),\n        (0xFD35, \"M\", \"\"),\n        (0xFD36, \"M\", \"\"),\n        (0xFD37, \"M\", \"\"),\n        (0xFD38, \"M\", \"\"),\n        (0xFD39, \"M\", \"\"),\n        (0xFD3A, \"M\", \"\"),\n        (0xFD3B, \"M\", \"\"),\n        (0xFD3C, \"M\", \"\"),\n        (0xFD3E, \"V\"),\n        (0xFD50, \"M\", \"\"),\n        (0xFD51, \"M\", \"\"),\n        (0xFD53, \"M\", \"\"),\n        (0xFD54, \"M\", \"\"),\n        (0xFD55, \"M\", \"\"),\n        (0xFD56, \"M\", \"\"),\n        (0xFD57, \"M\", \"\"),\n        (0xFD58, \"M\", \"\"),\n        (0xFD5A, \"M\", \"\"),\n        (0xFD5B, \"M\", \"\"),\n        (0xFD5C, \"M\", \"\"),\n        (0xFD5D, \"M\", \"\"),\n        (0xFD5E, \"M\", \"\"),\n        (0xFD5F, \"M\", \"\"),\n        (0xFD61, \"M\", \"\"),\n        (0xFD62, \"M\", \"\"),\n        (0xFD64, \"M\", \"\"),\n        (0xFD66, \"M\", \"\"),\n        (0xFD67, \"M\", \"\"),\n        (0xFD69, \"M\", \"\"),\n        (0xFD6A, \"M\", \"\"),\n        (0xFD6C, \"M\", \"\"),\n        (0xFD6E, \"M\", \"\"),\n        (0xFD6F, \"M\", \"\"),\n        (0xFD71, \"M\", \"\"),\n        (0xFD73, \"M\", \"\"),\n        (0xFD74, \"M\", \"\"),\n        (0xFD75, \"M\", \"\"),\n        (0xFD76, \"M\", \"\"),\n        (0xFD78, \"M\", \"\"),\n        (0xFD79, \"M\", \"\"),\n        (0xFD7A, \"M\", \"\"),\n        (0xFD7B, \"M\", \"\"),\n        (0xFD7C, \"M\", \"\"),\n        (0xFD7E, \"M\", \"\"),\n        (0xFD7F, \"M\", \"\"),\n        (0xFD80, \"M\", \"\"),\n        (0xFD81, \"M\", \"\"),\n        (0xFD82, \"M\", \"\"),\n        (0xFD83, \"M\", \"\"),\n        (0xFD85, \"M\", \"\"),\n        (0xFD87, \"M\", \"\"),\n        (0xFD89, \"M\", \"\"),\n        (0xFD8A, \"M\", \"\"),\n        (0xFD8B, \"M\", \"\"),\n        (0xFD8C, \"M\", \"\"),\n        (0xFD8D, \"M\", \"\"),\n        (0xFD8E, \"M\", \"\"),\n        (0xFD8F, \"M\", \"\"),\n        (0xFD90, \"X\"),\n        (0xFD92, \"M\", \"\"),\n        (0xFD93, \"M\", \"\"),\n        (0xFD94, \"M\", \"\"),\n        (0xFD95, \"M\", \"\"),\n        (0xFD96, \"M\", \"\"),\n        (0xFD97, \"M\", \"\"),\n        (0xFD99, \"M\", \"\"),\n        (0xFD9A, \"M\", \"\"),\n        (0xFD9B, \"M\", \"\"),\n        (0xFD9C, \"M\", \"\"),\n        (0xFD9E, \"M\", \"\"),\n        (0xFD9F, \"M\", \"\"),\n        (0xFDA0, \"M\", \"\"),\n        (0xFDA1, \"M\", \"\"),\n        (0xFDA2, \"M\", \"\"),\n        (0xFDA3, \"M\", \"\"),\n        (0xFDA4, \"M\", \"\"),\n        (0xFDA5, \"M\", \"\"),\n        (0xFDA6, \"M\", \"\"),\n        (0xFDA7, \"M\", \"\"),\n        (0xFDA8, \"M\", \"\"),\n        (0xFDA9, \"M\", \"\"),\n        (0xFDAA, \"M\", \"\"),\n    ]\n\n\ndef _seg_49() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xFDAB, \"M\", \"\"),\n        (0xFDAC, \"M\", \"\"),\n        (0xFDAD, \"M\", \"\"),\n        (0xFDAE, \"M\", \"\"),\n        (0xFDAF, \"M\", \"\"),\n        (0xFDB0, \"M\", \"\"),\n        (0xFDB1, \"M\", \"\"),\n        (0xFDB2, \"M\", \"\"),\n        (0xFDB3, \"M\", \"\"),\n        (0xFDB4, \"M\", \"\"),\n        (0xFDB5, \"M\", \"\"),\n        (0xFDB6, \"M\", \"\"),\n        (0xFDB7, \"M\", \"\"),\n        (0xFDB8, \"M\", \"\"),\n        (0xFDB9, \"M\", \"\"),\n        (0xFDBA, \"M\", \"\"),\n        (0xFDBB, \"M\", \"\"),\n        (0xFDBC, \"M\", \"\"),\n        (0xFDBD, \"M\", \"\"),\n        (0xFDBE, \"M\", \"\"),\n        (0xFDBF, \"M\", \"\"),\n        (0xFDC0, \"M\", \"\"),\n        (0xFDC1, \"M\", \"\"),\n        (0xFDC2, \"M\", \"\"),\n        (0xFDC3, \"M\", \"\"),\n        (0xFDC4, \"M\", \"\"),\n        (0xFDC5, \"M\", \"\"),\n        (0xFDC6, \"M\", \"\"),\n        (0xFDC7, \"M\", \"\"),\n        (0xFDC8, \"X\"),\n        (0xFDCF, \"V\"),\n        (0xFDD0, \"X\"),\n        (0xFDF0, \"M\", \"\"),\n        (0xFDF1, \"M\", \"\"),\n        (0xFDF2, \"M\", \"\"),\n        (0xFDF3, \"M\", \"\"),\n        (0xFDF4, \"M\", \"\"),\n        (0xFDF5, \"M\", \"\"),\n        (0xFDF6, \"M\", \"\"),\n        (0xFDF7, \"M\", \"\"),\n        (0xFDF8, \"M\", \"\"),\n        (0xFDF9, \"M\", \"\"),\n        (0xFDFA, \"3\", \"   \"),\n        (0xFDFB, \"3\", \" \"),\n        (0xFDFC, \"M\", \"\"),\n        (0xFDFD, \"V\"),\n        (0xFE00, \"I\"),\n        (0xFE10, \"3\", \",\"),\n        (0xFE11, \"M\", \"\"),\n        (0xFE12, \"X\"),\n        (0xFE13, \"3\", \":\"),\n        (0xFE14, \"3\", \";\"),\n        (0xFE15, \"3\", \"!\"),\n        (0xFE16, \"3\", \"?\"),\n        (0xFE17, \"M\", \"\"),\n        (0xFE18, \"M\", \"\"),\n        (0xFE19, \"X\"),\n        (0xFE20, \"V\"),\n        (0xFE30, \"X\"),\n        (0xFE31, \"M\", \"\"),\n        (0xFE32, \"M\", \"\"),\n        (0xFE33, \"3\", \"_\"),\n        (0xFE35, \"3\", \"(\"),\n        (0xFE36, \"3\", \")\"),\n        (0xFE37, \"3\", \"{\"),\n        (0xFE38, \"3\", \"}\"),\n        (0xFE39, \"M\", \"\"),\n        (0xFE3A, \"M\", \"\"),\n        (0xFE3B, \"M\", \"\"),\n        (0xFE3C, \"M\", \"\"),\n        (0xFE3D, \"M\", \"\"),\n        (0xFE3E, \"M\", \"\"),\n        (0xFE3F, \"M\", \"\"),\n        (0xFE40, \"M\", \"\"),\n        (0xFE41, \"M\", \"\"),\n        (0xFE42, \"M\", \"\"),\n        (0xFE43, \"M\", \"\"),\n        (0xFE44, \"M\", \"\"),\n        (0xFE45, \"V\"),\n        (0xFE47, \"3\", \"[\"),\n        (0xFE48, \"3\", \"]\"),\n        (0xFE49, \"3\", \" \"),\n        (0xFE4D, \"3\", \"_\"),\n        (0xFE50, \"3\", \",\"),\n        (0xFE51, \"M\", \"\"),\n        (0xFE52, \"X\"),\n        (0xFE54, \"3\", \";\"),\n        (0xFE55, \"3\", \":\"),\n        (0xFE56, \"3\", \"?\"),\n        (0xFE57, \"3\", \"!\"),\n        (0xFE58, \"M\", \"\"),\n        (0xFE59, \"3\", \"(\"),\n        (0xFE5A, \"3\", \")\"),\n        (0xFE5B, \"3\", \"{\"),\n        (0xFE5C, \"3\", \"}\"),\n        (0xFE5D, \"M\", \"\"),\n        (0xFE5E, \"M\", \"\"),\n        (0xFE5F, \"3\", \"#\"),\n        (0xFE60, \"3\", \"&\"),\n        (0xFE61, \"3\", \"*\"),\n    ]\n\n\ndef _seg_50() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xFE62, \"3\", \"+\"),\n        (0xFE63, \"M\", \"-\"),\n        (0xFE64, \"3\", \"<\"),\n        (0xFE65, \"3\", \">\"),\n        (0xFE66, \"3\", \"=\"),\n        (0xFE67, \"X\"),\n        (0xFE68, \"3\", \"\\\\\"),\n        (0xFE69, \"3\", \"$\"),\n        (0xFE6A, \"3\", \"%\"),\n        (0xFE6B, \"3\", \"@\"),\n        (0xFE6C, \"X\"),\n        (0xFE70, \"3\", \" \"),\n        (0xFE71, \"M\", \"\"),\n        (0xFE72, \"3\", \" \"),\n        (0xFE73, \"V\"),\n        (0xFE74, \"3\", \" \"),\n        (0xFE75, \"X\"),\n        (0xFE76, \"3\", \" \"),\n        (0xFE77, \"M\", \"\"),\n        (0xFE78, \"3\", \" \"),\n        (0xFE79, \"M\", \"\"),\n        (0xFE7A, \"3\", \" \"),\n        (0xFE7B, \"M\", \"\"),\n        (0xFE7C, \"3\", \" \"),\n        (0xFE7D, \"M\", \"\"),\n        (0xFE7E, \"3\", \" \"),\n        (0xFE7F, \"M\", \"\"),\n        (0xFE80, \"M\", \"\"),\n        (0xFE81, \"M\", \"\"),\n        (0xFE83, \"M\", \"\"),\n        (0xFE85, \"M\", \"\"),\n        (0xFE87, \"M\", \"\"),\n        (0xFE89, \"M\", \"\"),\n        (0xFE8D, \"M\", \"\"),\n        (0xFE8F, \"M\", \"\"),\n        (0xFE93, \"M\", \"\"),\n        (0xFE95, \"M\", \"\"),\n        (0xFE99, \"M\", \"\"),\n        (0xFE9D, \"M\", \"\"),\n        (0xFEA1, \"M\", \"\"),\n        (0xFEA5, \"M\", \"\"),\n        (0xFEA9, \"M\", \"\"),\n        (0xFEAB, \"M\", \"\"),\n        (0xFEAD, \"M\", \"\"),\n        (0xFEAF, \"M\", \"\"),\n        (0xFEB1, \"M\", \"\"),\n        (0xFEB5, \"M\", \"\"),\n        (0xFEB9, \"M\", \"\"),\n        (0xFEBD, \"M\", \"\"),\n        (0xFEC1, \"M\", \"\"),\n        (0xFEC5, \"M\", \"\"),\n        (0xFEC9, \"M\", \"\"),\n        (0xFECD, \"M\", \"\"),\n        (0xFED1, \"M\", \"\"),\n        (0xFED5, \"M\", \"\"),\n        (0xFED9, \"M\", \"\"),\n        (0xFEDD, \"M\", \"\"),\n        (0xFEE1, \"M\", \"\"),\n        (0xFEE5, \"M\", \"\"),\n        (0xFEE9, \"M\", \"\"),\n        (0xFEED, \"M\", \"\"),\n        (0xFEEF, \"M\", \"\"),\n        (0xFEF1, \"M\", \"\"),\n        (0xFEF5, \"M\", \"\"),\n        (0xFEF7, \"M\", \"\"),\n        (0xFEF9, \"M\", \"\"),\n        (0xFEFB, \"M\", \"\"),\n        (0xFEFD, \"X\"),\n        (0xFEFF, \"I\"),\n        (0xFF00, \"X\"),\n        (0xFF01, \"3\", \"!\"),\n        (0xFF02, \"3\", '\"'),\n        (0xFF03, \"3\", \"#\"),\n        (0xFF04, \"3\", \"$\"),\n        (0xFF05, \"3\", \"%\"),\n        (0xFF06, \"3\", \"&\"),\n        (0xFF07, \"3\", \"'\"),\n        (0xFF08, \"3\", \"(\"),\n        (0xFF09, \"3\", \")\"),\n        (0xFF0A, \"3\", \"*\"),\n        (0xFF0B, \"3\", \"+\"),\n        (0xFF0C, \"3\", \",\"),\n        (0xFF0D, \"M\", \"-\"),\n        (0xFF0E, \"M\", \".\"),\n        (0xFF0F, \"3\", \"/\"),\n        (0xFF10, \"M\", \"0\"),\n        (0xFF11, \"M\", \"1\"),\n        (0xFF12, \"M\", \"2\"),\n        (0xFF13, \"M\", \"3\"),\n        (0xFF14, \"M\", \"4\"),\n        (0xFF15, \"M\", \"5\"),\n        (0xFF16, \"M\", \"6\"),\n        (0xFF17, \"M\", \"7\"),\n        (0xFF18, \"M\", \"8\"),\n        (0xFF19, \"M\", \"9\"),\n        (0xFF1A, \"3\", \":\"),\n        (0xFF1B, \"3\", \";\"),\n        (0xFF1C, \"3\", \"<\"),\n        (0xFF1D, \"3\", \"=\"),\n        (0xFF1E, \"3\", \">\"),\n    ]\n\n\ndef _seg_51() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xFF1F, \"3\", \"?\"),\n        (0xFF20, \"3\", \"@\"),\n        (0xFF21, \"M\", \"a\"),\n        (0xFF22, \"M\", \"b\"),\n        (0xFF23, \"M\", \"c\"),\n        (0xFF24, \"M\", \"d\"),\n        (0xFF25, \"M\", \"e\"),\n        (0xFF26, \"M\", \"f\"),\n        (0xFF27, \"M\", \"g\"),\n        (0xFF28, \"M\", \"h\"),\n        (0xFF29, \"M\", \"i\"),\n        (0xFF2A, \"M\", \"j\"),\n        (0xFF2B, \"M\", \"k\"),\n        (0xFF2C, \"M\", \"l\"),\n        (0xFF2D, \"M\", \"m\"),\n        (0xFF2E, \"M\", \"n\"),\n        (0xFF2F, \"M\", \"o\"),\n        (0xFF30, \"M\", \"p\"),\n        (0xFF31, \"M\", \"q\"),\n        (0xFF32, \"M\", \"r\"),\n        (0xFF33, \"M\", \"s\"),\n        (0xFF34, \"M\", \"t\"),\n        (0xFF35, \"M\", \"u\"),\n        (0xFF36, \"M\", \"v\"),\n        (0xFF37, \"M\", \"w\"),\n        (0xFF38, \"M\", \"x\"),\n        (0xFF39, \"M\", \"y\"),\n        (0xFF3A, \"M\", \"z\"),\n        (0xFF3B, \"3\", \"[\"),\n        (0xFF3C, \"3\", \"\\\\\"),\n        (0xFF3D, \"3\", \"]\"),\n        (0xFF3E, \"3\", \"^\"),\n        (0xFF3F, \"3\", \"_\"),\n        (0xFF40, \"3\", \"`\"),\n        (0xFF41, \"M\", \"a\"),\n        (0xFF42, \"M\", \"b\"),\n        (0xFF43, \"M\", \"c\"),\n        (0xFF44, \"M\", \"d\"),\n        (0xFF45, \"M\", \"e\"),\n        (0xFF46, \"M\", \"f\"),\n        (0xFF47, \"M\", \"g\"),\n        (0xFF48, \"M\", \"h\"),\n        (0xFF49, \"M\", \"i\"),\n        (0xFF4A, \"M\", \"j\"),\n        (0xFF4B, \"M\", \"k\"),\n        (0xFF4C, \"M\", \"l\"),\n        (0xFF4D, \"M\", \"m\"),\n        (0xFF4E, \"M\", \"n\"),\n        (0xFF4F, \"M\", \"o\"),\n        (0xFF50, \"M\", \"p\"),\n        (0xFF51, \"M\", \"q\"),\n        (0xFF52, \"M\", \"r\"),\n        (0xFF53, \"M\", \"s\"),\n        (0xFF54, \"M\", \"t\"),\n        (0xFF55, \"M\", \"u\"),\n        (0xFF56, \"M\", \"v\"),\n        (0xFF57, \"M\", \"w\"),\n        (0xFF58, \"M\", \"x\"),\n        (0xFF59, \"M\", \"y\"),\n        (0xFF5A, \"M\", \"z\"),\n        (0xFF5B, \"3\", \"{\"),\n        (0xFF5C, \"3\", \"|\"),\n        (0xFF5D, \"3\", \"}\"),\n        (0xFF5E, \"3\", \"~\"),\n        (0xFF5F, \"M\", \"\"),\n        (0xFF60, \"M\", \"\"),\n        (0xFF61, \"M\", \".\"),\n        (0xFF62, \"M\", \"\"),\n        (0xFF63, \"M\", \"\"),\n        (0xFF64, \"M\", \"\"),\n        (0xFF65, \"M\", \"\"),\n        (0xFF66, \"M\", \"\"),\n        (0xFF67, \"M\", \"\"),\n        (0xFF68, \"M\", \"\"),\n        (0xFF69, \"M\", \"\"),\n        (0xFF6A, \"M\", \"\"),\n        (0xFF6B, \"M\", \"\"),\n        (0xFF6C, \"M\", \"\"),\n        (0xFF6D, \"M\", \"\"),\n        (0xFF6E, \"M\", \"\"),\n        (0xFF6F, \"M\", \"\"),\n        (0xFF70, \"M\", \"\"),\n        (0xFF71, \"M\", \"\"),\n        (0xFF72, \"M\", \"\"),\n        (0xFF73, \"M\", \"\"),\n        (0xFF74, \"M\", \"\"),\n        (0xFF75, \"M\", \"\"),\n        (0xFF76, \"M\", \"\"),\n        (0xFF77, \"M\", \"\"),\n        (0xFF78, \"M\", \"\"),\n        (0xFF79, \"M\", \"\"),\n        (0xFF7A, \"M\", \"\"),\n        (0xFF7B, \"M\", \"\"),\n        (0xFF7C, \"M\", \"\"),\n        (0xFF7D, \"M\", \"\"),\n        (0xFF7E, \"M\", \"\"),\n        (0xFF7F, \"M\", \"\"),\n        (0xFF80, \"M\", \"\"),\n        (0xFF81, \"M\", \"\"),\n        (0xFF82, \"M\", \"\"),\n    ]\n\n\ndef _seg_52() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xFF83, \"M\", \"\"),\n        (0xFF84, \"M\", \"\"),\n        (0xFF85, \"M\", \"\"),\n        (0xFF86, \"M\", \"\"),\n        (0xFF87, \"M\", \"\"),\n        (0xFF88, \"M\", \"\"),\n        (0xFF89, \"M\", \"\"),\n        (0xFF8A, \"M\", \"\"),\n        (0xFF8B, \"M\", \"\"),\n        (0xFF8C, \"M\", \"\"),\n        (0xFF8D, \"M\", \"\"),\n        (0xFF8E, \"M\", \"\"),\n        (0xFF8F, \"M\", \"\"),\n        (0xFF90, \"M\", \"\"),\n        (0xFF91, \"M\", \"\"),\n        (0xFF92, \"M\", \"\"),\n        (0xFF93, \"M\", \"\"),\n        (0xFF94, \"M\", \"\"),\n        (0xFF95, \"M\", \"\"),\n        (0xFF96, \"M\", \"\"),\n        (0xFF97, \"M\", \"\"),\n        (0xFF98, \"M\", \"\"),\n        (0xFF99, \"M\", \"\"),\n        (0xFF9A, \"M\", \"\"),\n        (0xFF9B, \"M\", \"\"),\n        (0xFF9C, \"M\", \"\"),\n        (0xFF9D, \"M\", \"\"),\n        (0xFF9E, \"M\", \"\"),\n        (0xFF9F, \"M\", \"\"),\n        (0xFFA0, \"X\"),\n        (0xFFA1, \"M\", \"\"),\n        (0xFFA2, \"M\", \"\"),\n        (0xFFA3, \"M\", \"\"),\n        (0xFFA4, \"M\", \"\"),\n        (0xFFA5, \"M\", \"\"),\n        (0xFFA6, \"M\", \"\"),\n        (0xFFA7, \"M\", \"\"),\n        (0xFFA8, \"M\", \"\"),\n        (0xFFA9, \"M\", \"\"),\n        (0xFFAA, \"M\", \"\"),\n        (0xFFAB, \"M\", \"\"),\n        (0xFFAC, \"M\", \"\"),\n        (0xFFAD, \"M\", \"\"),\n        (0xFFAE, \"M\", \"\"),\n        (0xFFAF, \"M\", \"\"),\n        (0xFFB0, \"M\", \"\"),\n        (0xFFB1, \"M\", \"\"),\n        (0xFFB2, \"M\", \"\"),\n        (0xFFB3, \"M\", \"\"),\n        (0xFFB4, \"M\", \"\"),\n        (0xFFB5, \"M\", \"\"),\n        (0xFFB6, \"M\", \"\"),\n        (0xFFB7, \"M\", \"\"),\n        (0xFFB8, \"M\", \"\"),\n        (0xFFB9, \"M\", \"\"),\n        (0xFFBA, \"M\", \"\"),\n        (0xFFBB, \"M\", \"\"),\n        (0xFFBC, \"M\", \"\"),\n        (0xFFBD, \"M\", \"\"),\n        (0xFFBE, \"M\", \"\"),\n        (0xFFBF, \"X\"),\n        (0xFFC2, \"M\", \"\"),\n        (0xFFC3, \"M\", \"\"),\n        (0xFFC4, \"M\", \"\"),\n        (0xFFC5, \"M\", \"\"),\n        (0xFFC6, \"M\", \"\"),\n        (0xFFC7, \"M\", \"\"),\n        (0xFFC8, \"X\"),\n        (0xFFCA, \"M\", \"\"),\n        (0xFFCB, \"M\", \"\"),\n        (0xFFCC, \"M\", \"\"),\n        (0xFFCD, \"M\", \"\"),\n        (0xFFCE, \"M\", \"\"),\n        (0xFFCF, \"M\", \"\"),\n        (0xFFD0, \"X\"),\n        (0xFFD2, \"M\", \"\"),\n        (0xFFD3, \"M\", \"\"),\n        (0xFFD4, \"M\", \"\"),\n        (0xFFD5, \"M\", \"\"),\n        (0xFFD6, \"M\", \"\"),\n        (0xFFD7, \"M\", \"\"),\n        (0xFFD8, \"X\"),\n        (0xFFDA, \"M\", \"\"),\n        (0xFFDB, \"M\", \"\"),\n        (0xFFDC, \"M\", \"\"),\n        (0xFFDD, \"X\"),\n        (0xFFE0, \"M\", \"\"),\n        (0xFFE1, \"M\", \"\"),\n        (0xFFE2, \"M\", \"\"),\n        (0xFFE3, \"3\", \" \"),\n        (0xFFE4, \"M\", \"\"),\n        (0xFFE5, \"M\", \"\"),\n        (0xFFE6, \"M\", \"\"),\n        (0xFFE7, \"X\"),\n        (0xFFE8, \"M\", \"\"),\n        (0xFFE9, \"M\", \"\"),\n        (0xFFEA, \"M\", \"\"),\n        (0xFFEB, \"M\", \"\"),\n        (0xFFEC, \"M\", \"\"),\n        (0xFFED, \"M\", \"\"),\n    ]\n\n\ndef _seg_53() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0xFFEE, \"M\", \"\"),\n        (0xFFEF, \"X\"),\n        (0x10000, \"V\"),\n        (0x1000C, \"X\"),\n        (0x1000D, \"V\"),\n        (0x10027, \"X\"),\n        (0x10028, \"V\"),\n        (0x1003B, \"X\"),\n        (0x1003C, \"V\"),\n        (0x1003E, \"X\"),\n        (0x1003F, \"V\"),\n        (0x1004E, \"X\"),\n        (0x10050, \"V\"),\n        (0x1005E, \"X\"),\n        (0x10080, \"V\"),\n        (0x100FB, \"X\"),\n        (0x10100, \"V\"),\n        (0x10103, \"X\"),\n        (0x10107, \"V\"),\n        (0x10134, \"X\"),\n        (0x10137, \"V\"),\n        (0x1018F, \"X\"),\n        (0x10190, \"V\"),\n        (0x1019D, \"X\"),\n        (0x101A0, \"V\"),\n        (0x101A1, \"X\"),\n        (0x101D0, \"V\"),\n        (0x101FE, \"X\"),\n        (0x10280, \"V\"),\n        (0x1029D, \"X\"),\n        (0x102A0, \"V\"),\n        (0x102D1, \"X\"),\n        (0x102E0, \"V\"),\n        (0x102FC, \"X\"),\n        (0x10300, \"V\"),\n        (0x10324, \"X\"),\n        (0x1032D, \"V\"),\n        (0x1034B, \"X\"),\n        (0x10350, \"V\"),\n        (0x1037B, \"X\"),\n        (0x10380, \"V\"),\n        (0x1039E, \"X\"),\n        (0x1039F, \"V\"),\n        (0x103C4, \"X\"),\n        (0x103C8, \"V\"),\n        (0x103D6, \"X\"),\n        (0x10400, \"M\", \"\"),\n        (0x10401, \"M\", \"\"),\n        (0x10402, \"M\", \"\"),\n        (0x10403, \"M\", \"\"),\n        (0x10404, \"M\", \"\"),\n        (0x10405, \"M\", \"\"),\n        (0x10406, \"M\", \"\"),\n        (0x10407, \"M\", \"\"),\n        (0x10408, \"M\", \"\"),\n        (0x10409, \"M\", \"\"),\n        (0x1040A, \"M\", \"\"),\n        (0x1040B, \"M\", \"\"),\n        (0x1040C, \"M\", \"\"),\n        (0x1040D, \"M\", \"\"),\n        (0x1040E, \"M\", \"\"),\n        (0x1040F, \"M\", \"\"),\n        (0x10410, \"M\", \"\"),\n        (0x10411, \"M\", \"\"),\n        (0x10412, \"M\", \"\"),\n        (0x10413, \"M\", \"\"),\n        (0x10414, \"M\", \"\"),\n        (0x10415, \"M\", \"\"),\n        (0x10416, \"M\", \"\"),\n        (0x10417, \"M\", \"\"),\n        (0x10418, \"M\", \"\"),\n        (0x10419, \"M\", \"\"),\n        (0x1041A, \"M\", \"\"),\n        (0x1041B, \"M\", \"\"),\n        (0x1041C, \"M\", \"\"),\n        (0x1041D, \"M\", \"\"),\n        (0x1041E, \"M\", \"\"),\n        (0x1041F, \"M\", \"\"),\n        (0x10420, \"M\", \"\"),\n        (0x10421, \"M\", \"\"),\n        (0x10422, \"M\", \"\"),\n        (0x10423, \"M\", \"\"),\n        (0x10424, \"M\", \"\"),\n        (0x10425, \"M\", \"\"),\n        (0x10426, \"M\", \"\"),\n        (0x10427, \"M\", \"\"),\n        (0x10428, \"V\"),\n        (0x1049E, \"X\"),\n        (0x104A0, \"V\"),\n        (0x104AA, \"X\"),\n        (0x104B0, \"M\", \"\"),\n        (0x104B1, \"M\", \"\"),\n        (0x104B2, \"M\", \"\"),\n        (0x104B3, \"M\", \"\"),\n        (0x104B4, \"M\", \"\"),\n        (0x104B5, \"M\", \"\"),\n        (0x104B6, \"M\", \"\"),\n        (0x104B7, \"M\", \"\"),\n        (0x104B8, \"M\", \"\"),\n        (0x104B9, \"M\", \"\"),\n    ]\n\n\ndef _seg_54() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x104BA, \"M\", \"\"),\n        (0x104BB, \"M\", \"\"),\n        (0x104BC, \"M\", \"\"),\n        (0x104BD, \"M\", \"\"),\n        (0x104BE, \"M\", \"\"),\n        (0x104BF, \"M\", \"\"),\n        (0x104C0, \"M\", \"\"),\n        (0x104C1, \"M\", \"\"),\n        (0x104C2, \"M\", \"\"),\n        (0x104C3, \"M\", \"\"),\n        (0x104C4, \"M\", \"\"),\n        (0x104C5, \"M\", \"\"),\n        (0x104C6, \"M\", \"\"),\n        (0x104C7, \"M\", \"\"),\n        (0x104C8, \"M\", \"\"),\n        (0x104C9, \"M\", \"\"),\n        (0x104CA, \"M\", \"\"),\n        (0x104CB, \"M\", \"\"),\n        (0x104CC, \"M\", \"\"),\n        (0x104CD, \"M\", \"\"),\n        (0x104CE, \"M\", \"\"),\n        (0x104CF, \"M\", \"\"),\n        (0x104D0, \"M\", \"\"),\n        (0x104D1, \"M\", \"\"),\n        (0x104D2, \"M\", \"\"),\n        (0x104D3, \"M\", \"\"),\n        (0x104D4, \"X\"),\n        (0x104D8, \"V\"),\n        (0x104FC, \"X\"),\n        (0x10500, \"V\"),\n        (0x10528, \"X\"),\n        (0x10530, \"V\"),\n        (0x10564, \"X\"),\n        (0x1056F, \"V\"),\n        (0x10570, \"M\", \"\"),\n        (0x10571, \"M\", \"\"),\n        (0x10572, \"M\", \"\"),\n        (0x10573, \"M\", \"\"),\n        (0x10574, \"M\", \"\"),\n        (0x10575, \"M\", \"\"),\n        (0x10576, \"M\", \"\"),\n        (0x10577, \"M\", \"\"),\n        (0x10578, \"M\", \"\"),\n        (0x10579, \"M\", \"\"),\n        (0x1057A, \"M\", \"\"),\n        (0x1057B, \"X\"),\n        (0x1057C, \"M\", \"\"),\n        (0x1057D, \"M\", \"\"),\n        (0x1057E, \"M\", \"\"),\n        (0x1057F, \"M\", \"\"),\n        (0x10580, \"M\", \"\"),\n        (0x10581, \"M\", \"\"),\n        (0x10582, \"M\", \"\"),\n        (0x10583, \"M\", \"\"),\n        (0x10584, \"M\", \"\"),\n        (0x10585, \"M\", \"\"),\n        (0x10586, \"M\", \"\"),\n        (0x10587, \"M\", \"\"),\n        (0x10588, \"M\", \"\"),\n        (0x10589, \"M\", \"\"),\n        (0x1058A, \"M\", \"\"),\n        (0x1058B, \"X\"),\n        (0x1058C, \"M\", \"\"),\n        (0x1058D, \"M\", \"\"),\n        (0x1058E, \"M\", \"\"),\n        (0x1058F, \"M\", \"\"),\n        (0x10590, \"M\", \"\"),\n        (0x10591, \"M\", \"\"),\n        (0x10592, \"M\", \"\"),\n        (0x10593, \"X\"),\n        (0x10594, \"M\", \"\"),\n        (0x10595, \"M\", \"\"),\n        (0x10596, \"X\"),\n        (0x10597, \"V\"),\n        (0x105A2, \"X\"),\n        (0x105A3, \"V\"),\n        (0x105B2, \"X\"),\n        (0x105B3, \"V\"),\n        (0x105BA, \"X\"),\n        (0x105BB, \"V\"),\n        (0x105BD, \"X\"),\n        (0x10600, \"V\"),\n        (0x10737, \"X\"),\n        (0x10740, \"V\"),\n        (0x10756, \"X\"),\n        (0x10760, \"V\"),\n        (0x10768, \"X\"),\n        (0x10780, \"V\"),\n        (0x10781, \"M\", \"\"),\n        (0x10782, \"M\", \"\"),\n        (0x10783, \"M\", \"\"),\n        (0x10784, \"M\", \"\"),\n        (0x10785, \"M\", \"\"),\n        (0x10786, \"X\"),\n        (0x10787, \"M\", \"\"),\n        (0x10788, \"M\", \"\"),\n        (0x10789, \"M\", \"\"),\n        (0x1078A, \"M\", \"\"),\n        (0x1078B, \"M\", \"\"),\n        (0x1078C, \"M\", \"\"),\n    ]\n\n\ndef _seg_55() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1078D, \"M\", \"\"),\n        (0x1078E, \"M\", \"\"),\n        (0x1078F, \"M\", \"\"),\n        (0x10790, \"M\", \"\"),\n        (0x10791, \"M\", \"\"),\n        (0x10792, \"M\", \"\"),\n        (0x10793, \"M\", \"\"),\n        (0x10794, \"M\", \"\"),\n        (0x10795, \"M\", \"\"),\n        (0x10796, \"M\", \"\"),\n        (0x10797, \"M\", \"\"),\n        (0x10798, \"M\", \"\"),\n        (0x10799, \"M\", \"\"),\n        (0x1079A, \"M\", \"\"),\n        (0x1079B, \"M\", \"\"),\n        (0x1079C, \"M\", \"\"),\n        (0x1079D, \"M\", \"\"),\n        (0x1079E, \"M\", \"\"),\n        (0x1079F, \"M\", \"\"),\n        (0x107A0, \"M\", \"\"),\n        (0x107A1, \"M\", \"\"),\n        (0x107A2, \"M\", \"\"),\n        (0x107A3, \"M\", \"\"),\n        (0x107A4, \"M\", \"\"),\n        (0x107A5, \"M\", \"q\"),\n        (0x107A6, \"M\", \"\"),\n        (0x107A7, \"M\", \"\"),\n        (0x107A8, \"M\", \"\"),\n        (0x107A9, \"M\", \"\"),\n        (0x107AA, \"M\", \"\"),\n        (0x107AB, \"M\", \"\"),\n        (0x107AC, \"M\", \"\"),\n        (0x107AD, \"M\", \"\"),\n        (0x107AE, \"M\", \"\"),\n        (0x107AF, \"M\", \"\"),\n        (0x107B0, \"M\", \"\"),\n        (0x107B1, \"X\"),\n        (0x107B2, \"M\", \"\"),\n        (0x107B3, \"M\", \"\"),\n        (0x107B4, \"M\", \"\"),\n        (0x107B5, \"M\", \"\"),\n        (0x107B6, \"M\", \"\"),\n        (0x107B7, \"M\", \"\"),\n        (0x107B8, \"M\", \"\"),\n        (0x107B9, \"M\", \"\"),\n        (0x107BA, \"M\", \"\"),\n        (0x107BB, \"X\"),\n        (0x10800, \"V\"),\n        (0x10806, \"X\"),\n        (0x10808, \"V\"),\n        (0x10809, \"X\"),\n        (0x1080A, \"V\"),\n        (0x10836, \"X\"),\n        (0x10837, \"V\"),\n        (0x10839, \"X\"),\n        (0x1083C, \"V\"),\n        (0x1083D, \"X\"),\n        (0x1083F, \"V\"),\n        (0x10856, \"X\"),\n        (0x10857, \"V\"),\n        (0x1089F, \"X\"),\n        (0x108A7, \"V\"),\n        (0x108B0, \"X\"),\n        (0x108E0, \"V\"),\n        (0x108F3, \"X\"),\n        (0x108F4, \"V\"),\n        (0x108F6, \"X\"),\n        (0x108FB, \"V\"),\n        (0x1091C, \"X\"),\n        (0x1091F, \"V\"),\n        (0x1093A, \"X\"),\n        (0x1093F, \"V\"),\n        (0x10940, \"X\"),\n        (0x10980, \"V\"),\n        (0x109B8, \"X\"),\n        (0x109BC, \"V\"),\n        (0x109D0, \"X\"),\n        (0x109D2, \"V\"),\n        (0x10A04, \"X\"),\n        (0x10A05, \"V\"),\n        (0x10A07, \"X\"),\n        (0x10A0C, \"V\"),\n        (0x10A14, \"X\"),\n        (0x10A15, \"V\"),\n        (0x10A18, \"X\"),\n        (0x10A19, \"V\"),\n        (0x10A36, \"X\"),\n        (0x10A38, \"V\"),\n        (0x10A3B, \"X\"),\n        (0x10A3F, \"V\"),\n        (0x10A49, \"X\"),\n        (0x10A50, \"V\"),\n        (0x10A59, \"X\"),\n        (0x10A60, \"V\"),\n        (0x10AA0, \"X\"),\n        (0x10AC0, \"V\"),\n        (0x10AE7, \"X\"),\n        (0x10AEB, \"V\"),\n        (0x10AF7, \"X\"),\n        (0x10B00, \"V\"),\n    ]\n\n\ndef _seg_56() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x10B36, \"X\"),\n        (0x10B39, \"V\"),\n        (0x10B56, \"X\"),\n        (0x10B58, \"V\"),\n        (0x10B73, \"X\"),\n        (0x10B78, \"V\"),\n        (0x10B92, \"X\"),\n        (0x10B99, \"V\"),\n        (0x10B9D, \"X\"),\n        (0x10BA9, \"V\"),\n        (0x10BB0, \"X\"),\n        (0x10C00, \"V\"),\n        (0x10C49, \"X\"),\n        (0x10C80, \"M\", \"\"),\n        (0x10C81, \"M\", \"\"),\n        (0x10C82, \"M\", \"\"),\n        (0x10C83, \"M\", \"\"),\n        (0x10C84, \"M\", \"\"),\n        (0x10C85, \"M\", \"\"),\n        (0x10C86, \"M\", \"\"),\n        (0x10C87, \"M\", \"\"),\n        (0x10C88, \"M\", \"\"),\n        (0x10C89, \"M\", \"\"),\n        (0x10C8A, \"M\", \"\"),\n        (0x10C8B, \"M\", \"\"),\n        (0x10C8C, \"M\", \"\"),\n        (0x10C8D, \"M\", \"\"),\n        (0x10C8E, \"M\", \"\"),\n        (0x10C8F, \"M\", \"\"),\n        (0x10C90, \"M\", \"\"),\n        (0x10C91, \"M\", \"\"),\n        (0x10C92, \"M\", \"\"),\n        (0x10C93, \"M\", \"\"),\n        (0x10C94, \"M\", \"\"),\n        (0x10C95, \"M\", \"\"),\n        (0x10C96, \"M\", \"\"),\n        (0x10C97, \"M\", \"\"),\n        (0x10C98, \"M\", \"\"),\n        (0x10C99, \"M\", \"\"),\n        (0x10C9A, \"M\", \"\"),\n        (0x10C9B, \"M\", \"\"),\n        (0x10C9C, \"M\", \"\"),\n        (0x10C9D, \"M\", \"\"),\n        (0x10C9E, \"M\", \"\"),\n        (0x10C9F, \"M\", \"\"),\n        (0x10CA0, \"M\", \"\"),\n        (0x10CA1, \"M\", \"\"),\n        (0x10CA2, \"M\", \"\"),\n        (0x10CA3, \"M\", \"\"),\n        (0x10CA4, \"M\", \"\"),\n        (0x10CA5, \"M\", \"\"),\n        (0x10CA6, \"M\", \"\"),\n        (0x10CA7, \"M\", \"\"),\n        (0x10CA8, \"M\", \"\"),\n        (0x10CA9, \"M\", \"\"),\n        (0x10CAA, \"M\", \"\"),\n        (0x10CAB, \"M\", \"\"),\n        (0x10CAC, \"M\", \"\"),\n        (0x10CAD, \"M\", \"\"),\n        (0x10CAE, \"M\", \"\"),\n        (0x10CAF, \"M\", \"\"),\n        (0x10CB0, \"M\", \"\"),\n        (0x10CB1, \"M\", \"\"),\n        (0x10CB2, \"M\", \"\"),\n        (0x10CB3, \"X\"),\n        (0x10CC0, \"V\"),\n        (0x10CF3, \"X\"),\n        (0x10CFA, \"V\"),\n        (0x10D28, \"X\"),\n        (0x10D30, \"V\"),\n        (0x10D3A, \"X\"),\n        (0x10E60, \"V\"),\n        (0x10E7F, \"X\"),\n        (0x10E80, \"V\"),\n        (0x10EAA, \"X\"),\n        (0x10EAB, \"V\"),\n        (0x10EAE, \"X\"),\n        (0x10EB0, \"V\"),\n        (0x10EB2, \"X\"),\n        (0x10EFD, \"V\"),\n        (0x10F28, \"X\"),\n        (0x10F30, \"V\"),\n        (0x10F5A, \"X\"),\n        (0x10F70, \"V\"),\n        (0x10F8A, \"X\"),\n        (0x10FB0, \"V\"),\n        (0x10FCC, \"X\"),\n        (0x10FE0, \"V\"),\n        (0x10FF7, \"X\"),\n        (0x11000, \"V\"),\n        (0x1104E, \"X\"),\n        (0x11052, \"V\"),\n        (0x11076, \"X\"),\n        (0x1107F, \"V\"),\n        (0x110BD, \"X\"),\n        (0x110BE, \"V\"),\n        (0x110C3, \"X\"),\n        (0x110D0, \"V\"),\n        (0x110E9, \"X\"),\n        (0x110F0, \"V\"),\n    ]\n\n\ndef _seg_57() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x110FA, \"X\"),\n        (0x11100, \"V\"),\n        (0x11135, \"X\"),\n        (0x11136, \"V\"),\n        (0x11148, \"X\"),\n        (0x11150, \"V\"),\n        (0x11177, \"X\"),\n        (0x11180, \"V\"),\n        (0x111E0, \"X\"),\n        (0x111E1, \"V\"),\n        (0x111F5, \"X\"),\n        (0x11200, \"V\"),\n        (0x11212, \"X\"),\n        (0x11213, \"V\"),\n        (0x11242, \"X\"),\n        (0x11280, \"V\"),\n        (0x11287, \"X\"),\n        (0x11288, \"V\"),\n        (0x11289, \"X\"),\n        (0x1128A, \"V\"),\n        (0x1128E, \"X\"),\n        (0x1128F, \"V\"),\n        (0x1129E, \"X\"),\n        (0x1129F, \"V\"),\n        (0x112AA, \"X\"),\n        (0x112B0, \"V\"),\n        (0x112EB, \"X\"),\n        (0x112F0, \"V\"),\n        (0x112FA, \"X\"),\n        (0x11300, \"V\"),\n        (0x11304, \"X\"),\n        (0x11305, \"V\"),\n        (0x1130D, \"X\"),\n        (0x1130F, \"V\"),\n        (0x11311, \"X\"),\n        (0x11313, \"V\"),\n        (0x11329, \"X\"),\n        (0x1132A, \"V\"),\n        (0x11331, \"X\"),\n        (0x11332, \"V\"),\n        (0x11334, \"X\"),\n        (0x11335, \"V\"),\n        (0x1133A, \"X\"),\n        (0x1133B, \"V\"),\n        (0x11345, \"X\"),\n        (0x11347, \"V\"),\n        (0x11349, \"X\"),\n        (0x1134B, \"V\"),\n        (0x1134E, \"X\"),\n        (0x11350, \"V\"),\n        (0x11351, \"X\"),\n        (0x11357, \"V\"),\n        (0x11358, \"X\"),\n        (0x1135D, \"V\"),\n        (0x11364, \"X\"),\n        (0x11366, \"V\"),\n        (0x1136D, \"X\"),\n        (0x11370, \"V\"),\n        (0x11375, \"X\"),\n        (0x11400, \"V\"),\n        (0x1145C, \"X\"),\n        (0x1145D, \"V\"),\n        (0x11462, \"X\"),\n        (0x11480, \"V\"),\n        (0x114C8, \"X\"),\n        (0x114D0, \"V\"),\n        (0x114DA, \"X\"),\n        (0x11580, \"V\"),\n        (0x115B6, \"X\"),\n        (0x115B8, \"V\"),\n        (0x115DE, \"X\"),\n        (0x11600, \"V\"),\n        (0x11645, \"X\"),\n        (0x11650, \"V\"),\n        (0x1165A, \"X\"),\n        (0x11660, \"V\"),\n        (0x1166D, \"X\"),\n        (0x11680, \"V\"),\n        (0x116BA, \"X\"),\n        (0x116C0, \"V\"),\n        (0x116CA, \"X\"),\n        (0x11700, \"V\"),\n        (0x1171B, \"X\"),\n        (0x1171D, \"V\"),\n        (0x1172C, \"X\"),\n        (0x11730, \"V\"),\n        (0x11747, \"X\"),\n        (0x11800, \"V\"),\n        (0x1183C, \"X\"),\n        (0x118A0, \"M\", \"\"),\n        (0x118A1, \"M\", \"\"),\n        (0x118A2, \"M\", \"\"),\n        (0x118A3, \"M\", \"\"),\n        (0x118A4, \"M\", \"\"),\n        (0x118A5, \"M\", \"\"),\n        (0x118A6, \"M\", \"\"),\n        (0x118A7, \"M\", \"\"),\n        (0x118A8, \"M\", \"\"),\n        (0x118A9, \"M\", \"\"),\n        (0x118AA, \"M\", \"\"),\n    ]\n\n\ndef _seg_58() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x118AB, \"M\", \"\"),\n        (0x118AC, \"M\", \"\"),\n        (0x118AD, \"M\", \"\"),\n        (0x118AE, \"M\", \"\"),\n        (0x118AF, \"M\", \"\"),\n        (0x118B0, \"M\", \"\"),\n        (0x118B1, \"M\", \"\"),\n        (0x118B2, \"M\", \"\"),\n        (0x118B3, \"M\", \"\"),\n        (0x118B4, \"M\", \"\"),\n        (0x118B5, \"M\", \"\"),\n        (0x118B6, \"M\", \"\"),\n        (0x118B7, \"M\", \"\"),\n        (0x118B8, \"M\", \"\"),\n        (0x118B9, \"M\", \"\"),\n        (0x118BA, \"M\", \"\"),\n        (0x118BB, \"M\", \"\"),\n        (0x118BC, \"M\", \"\"),\n        (0x118BD, \"M\", \"\"),\n        (0x118BE, \"M\", \"\"),\n        (0x118BF, \"M\", \"\"),\n        (0x118C0, \"V\"),\n        (0x118F3, \"X\"),\n        (0x118FF, \"V\"),\n        (0x11907, \"X\"),\n        (0x11909, \"V\"),\n        (0x1190A, \"X\"),\n        (0x1190C, \"V\"),\n        (0x11914, \"X\"),\n        (0x11915, \"V\"),\n        (0x11917, \"X\"),\n        (0x11918, \"V\"),\n        (0x11936, \"X\"),\n        (0x11937, \"V\"),\n        (0x11939, \"X\"),\n        (0x1193B, \"V\"),\n        (0x11947, \"X\"),\n        (0x11950, \"V\"),\n        (0x1195A, \"X\"),\n        (0x119A0, \"V\"),\n        (0x119A8, \"X\"),\n        (0x119AA, \"V\"),\n        (0x119D8, \"X\"),\n        (0x119DA, \"V\"),\n        (0x119E5, \"X\"),\n        (0x11A00, \"V\"),\n        (0x11A48, \"X\"),\n        (0x11A50, \"V\"),\n        (0x11AA3, \"X\"),\n        (0x11AB0, \"V\"),\n        (0x11AF9, \"X\"),\n        (0x11B00, \"V\"),\n        (0x11B0A, \"X\"),\n        (0x11C00, \"V\"),\n        (0x11C09, \"X\"),\n        (0x11C0A, \"V\"),\n        (0x11C37, \"X\"),\n        (0x11C38, \"V\"),\n        (0x11C46, \"X\"),\n        (0x11C50, \"V\"),\n        (0x11C6D, \"X\"),\n        (0x11C70, \"V\"),\n        (0x11C90, \"X\"),\n        (0x11C92, \"V\"),\n        (0x11CA8, \"X\"),\n        (0x11CA9, \"V\"),\n        (0x11CB7, \"X\"),\n        (0x11D00, \"V\"),\n        (0x11D07, \"X\"),\n        (0x11D08, \"V\"),\n        (0x11D0A, \"X\"),\n        (0x11D0B, \"V\"),\n        (0x11D37, \"X\"),\n        (0x11D3A, \"V\"),\n        (0x11D3B, \"X\"),\n        (0x11D3C, \"V\"),\n        (0x11D3E, \"X\"),\n        (0x11D3F, \"V\"),\n        (0x11D48, \"X\"),\n        (0x11D50, \"V\"),\n        (0x11D5A, \"X\"),\n        (0x11D60, \"V\"),\n        (0x11D66, \"X\"),\n        (0x11D67, \"V\"),\n        (0x11D69, \"X\"),\n        (0x11D6A, \"V\"),\n        (0x11D8F, \"X\"),\n        (0x11D90, \"V\"),\n        (0x11D92, \"X\"),\n        (0x11D93, \"V\"),\n        (0x11D99, \"X\"),\n        (0x11DA0, \"V\"),\n        (0x11DAA, \"X\"),\n        (0x11EE0, \"V\"),\n        (0x11EF9, \"X\"),\n        (0x11F00, \"V\"),\n        (0x11F11, \"X\"),\n        (0x11F12, \"V\"),\n        (0x11F3B, \"X\"),\n        (0x11F3E, \"V\"),\n    ]\n\n\ndef _seg_59() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x11F5A, \"X\"),\n        (0x11FB0, \"V\"),\n        (0x11FB1, \"X\"),\n        (0x11FC0, \"V\"),\n        (0x11FF2, \"X\"),\n        (0x11FFF, \"V\"),\n        (0x1239A, \"X\"),\n        (0x12400, \"V\"),\n        (0x1246F, \"X\"),\n        (0x12470, \"V\"),\n        (0x12475, \"X\"),\n        (0x12480, \"V\"),\n        (0x12544, \"X\"),\n        (0x12F90, \"V\"),\n        (0x12FF3, \"X\"),\n        (0x13000, \"V\"),\n        (0x13430, \"X\"),\n        (0x13440, \"V\"),\n        (0x13456, \"X\"),\n        (0x14400, \"V\"),\n        (0x14647, \"X\"),\n        (0x16800, \"V\"),\n        (0x16A39, \"X\"),\n        (0x16A40, \"V\"),\n        (0x16A5F, \"X\"),\n        (0x16A60, \"V\"),\n        (0x16A6A, \"X\"),\n        (0x16A6E, \"V\"),\n        (0x16ABF, \"X\"),\n        (0x16AC0, \"V\"),\n        (0x16ACA, \"X\"),\n        (0x16AD0, \"V\"),\n        (0x16AEE, \"X\"),\n        (0x16AF0, \"V\"),\n        (0x16AF6, \"X\"),\n        (0x16B00, \"V\"),\n        (0x16B46, \"X\"),\n        (0x16B50, \"V\"),\n        (0x16B5A, \"X\"),\n        (0x16B5B, \"V\"),\n        (0x16B62, \"X\"),\n        (0x16B63, \"V\"),\n        (0x16B78, \"X\"),\n        (0x16B7D, \"V\"),\n        (0x16B90, \"X\"),\n        (0x16E40, \"M\", \"\"),\n        (0x16E41, \"M\", \"\"),\n        (0x16E42, \"M\", \"\"),\n        (0x16E43, \"M\", \"\"),\n        (0x16E44, \"M\", \"\"),\n        (0x16E45, \"M\", \"\"),\n        (0x16E46, \"M\", \"\"),\n        (0x16E47, \"M\", \"\"),\n        (0x16E48, \"M\", \"\"),\n        (0x16E49, \"M\", \"\"),\n        (0x16E4A, \"M\", \"\"),\n        (0x16E4B, \"M\", \"\"),\n        (0x16E4C, \"M\", \"\"),\n        (0x16E4D, \"M\", \"\"),\n        (0x16E4E, \"M\", \"\"),\n        (0x16E4F, \"M\", \"\"),\n        (0x16E50, \"M\", \"\"),\n        (0x16E51, \"M\", \"\"),\n        (0x16E52, \"M\", \"\"),\n        (0x16E53, \"M\", \"\"),\n        (0x16E54, \"M\", \"\"),\n        (0x16E55, \"M\", \"\"),\n        (0x16E56, \"M\", \"\"),\n        (0x16E57, \"M\", \"\"),\n        (0x16E58, \"M\", \"\"),\n        (0x16E59, \"M\", \"\"),\n        (0x16E5A, \"M\", \"\"),\n        (0x16E5B, \"M\", \"\"),\n        (0x16E5C, \"M\", \"\"),\n        (0x16E5D, \"M\", \"\"),\n        (0x16E5E, \"M\", \"\"),\n        (0x16E5F, \"M\", \"\"),\n        (0x16E60, \"V\"),\n        (0x16E9B, \"X\"),\n        (0x16F00, \"V\"),\n        (0x16F4B, \"X\"),\n        (0x16F4F, \"V\"),\n        (0x16F88, \"X\"),\n        (0x16F8F, \"V\"),\n        (0x16FA0, \"X\"),\n        (0x16FE0, \"V\"),\n        (0x16FE5, \"X\"),\n        (0x16FF0, \"V\"),\n        (0x16FF2, \"X\"),\n        (0x17000, \"V\"),\n        (0x187F8, \"X\"),\n        (0x18800, \"V\"),\n        (0x18CD6, \"X\"),\n        (0x18D00, \"V\"),\n        (0x18D09, \"X\"),\n        (0x1AFF0, \"V\"),\n        (0x1AFF4, \"X\"),\n        (0x1AFF5, \"V\"),\n        (0x1AFFC, \"X\"),\n        (0x1AFFD, \"V\"),\n    ]\n\n\ndef _seg_60() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1AFFF, \"X\"),\n        (0x1B000, \"V\"),\n        (0x1B123, \"X\"),\n        (0x1B132, \"V\"),\n        (0x1B133, \"X\"),\n        (0x1B150, \"V\"),\n        (0x1B153, \"X\"),\n        (0x1B155, \"V\"),\n        (0x1B156, \"X\"),\n        (0x1B164, \"V\"),\n        (0x1B168, \"X\"),\n        (0x1B170, \"V\"),\n        (0x1B2FC, \"X\"),\n        (0x1BC00, \"V\"),\n        (0x1BC6B, \"X\"),\n        (0x1BC70, \"V\"),\n        (0x1BC7D, \"X\"),\n        (0x1BC80, \"V\"),\n        (0x1BC89, \"X\"),\n        (0x1BC90, \"V\"),\n        (0x1BC9A, \"X\"),\n        (0x1BC9C, \"V\"),\n        (0x1BCA0, \"I\"),\n        (0x1BCA4, \"X\"),\n        (0x1CF00, \"V\"),\n        (0x1CF2E, \"X\"),\n        (0x1CF30, \"V\"),\n        (0x1CF47, \"X\"),\n        (0x1CF50, \"V\"),\n        (0x1CFC4, \"X\"),\n        (0x1D000, \"V\"),\n        (0x1D0F6, \"X\"),\n        (0x1D100, \"V\"),\n        (0x1D127, \"X\"),\n        (0x1D129, \"V\"),\n        (0x1D15E, \"M\", \"\"),\n        (0x1D15F, \"M\", \"\"),\n        (0x1D160, \"M\", \"\"),\n        (0x1D161, \"M\", \"\"),\n        (0x1D162, \"M\", \"\"),\n        (0x1D163, \"M\", \"\"),\n        (0x1D164, \"M\", \"\"),\n        (0x1D165, \"V\"),\n        (0x1D173, \"X\"),\n        (0x1D17B, \"V\"),\n        (0x1D1BB, \"M\", \"\"),\n        (0x1D1BC, \"M\", \"\"),\n        (0x1D1BD, \"M\", \"\"),\n        (0x1D1BE, \"M\", \"\"),\n        (0x1D1BF, \"M\", \"\"),\n        (0x1D1C0, \"M\", \"\"),\n        (0x1D1C1, \"V\"),\n        (0x1D1EB, \"X\"),\n        (0x1D200, \"V\"),\n        (0x1D246, \"X\"),\n        (0x1D2C0, \"V\"),\n        (0x1D2D4, \"X\"),\n        (0x1D2E0, \"V\"),\n        (0x1D2F4, \"X\"),\n        (0x1D300, \"V\"),\n        (0x1D357, \"X\"),\n        (0x1D360, \"V\"),\n        (0x1D379, \"X\"),\n        (0x1D400, \"M\", \"a\"),\n        (0x1D401, \"M\", \"b\"),\n        (0x1D402, \"M\", \"c\"),\n        (0x1D403, \"M\", \"d\"),\n        (0x1D404, \"M\", \"e\"),\n        (0x1D405, \"M\", \"f\"),\n        (0x1D406, \"M\", \"g\"),\n        (0x1D407, \"M\", \"h\"),\n        (0x1D408, \"M\", \"i\"),\n        (0x1D409, \"M\", \"j\"),\n        (0x1D40A, \"M\", \"k\"),\n        (0x1D40B, \"M\", \"l\"),\n        (0x1D40C, \"M\", \"m\"),\n        (0x1D40D, \"M\", \"n\"),\n        (0x1D40E, \"M\", \"o\"),\n        (0x1D40F, \"M\", \"p\"),\n        (0x1D410, \"M\", \"q\"),\n        (0x1D411, \"M\", \"r\"),\n        (0x1D412, \"M\", \"s\"),\n        (0x1D413, \"M\", \"t\"),\n        (0x1D414, \"M\", \"u\"),\n        (0x1D415, \"M\", \"v\"),\n        (0x1D416, \"M\", \"w\"),\n        (0x1D417, \"M\", \"x\"),\n        (0x1D418, \"M\", \"y\"),\n        (0x1D419, \"M\", \"z\"),\n        (0x1D41A, \"M\", \"a\"),\n        (0x1D41B, \"M\", \"b\"),\n        (0x1D41C, \"M\", \"c\"),\n        (0x1D41D, \"M\", \"d\"),\n        (0x1D41E, \"M\", \"e\"),\n        (0x1D41F, \"M\", \"f\"),\n        (0x1D420, \"M\", \"g\"),\n        (0x1D421, \"M\", \"h\"),\n        (0x1D422, \"M\", \"i\"),\n        (0x1D423, \"M\", \"j\"),\n        (0x1D424, \"M\", \"k\"),\n    ]\n\n\ndef _seg_61() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1D425, \"M\", \"l\"),\n        (0x1D426, \"M\", \"m\"),\n        (0x1D427, \"M\", \"n\"),\n        (0x1D428, \"M\", \"o\"),\n        (0x1D429, \"M\", \"p\"),\n        (0x1D42A, \"M\", \"q\"),\n        (0x1D42B, \"M\", \"r\"),\n        (0x1D42C, \"M\", \"s\"),\n        (0x1D42D, \"M\", \"t\"),\n        (0x1D42E, \"M\", \"u\"),\n        (0x1D42F, \"M\", \"v\"),\n        (0x1D430, \"M\", \"w\"),\n        (0x1D431, \"M\", \"x\"),\n        (0x1D432, \"M\", \"y\"),\n        (0x1D433, \"M\", \"z\"),\n        (0x1D434, \"M\", \"a\"),\n        (0x1D435, \"M\", \"b\"),\n        (0x1D436, \"M\", \"c\"),\n        (0x1D437, \"M\", \"d\"),\n        (0x1D438, \"M\", \"e\"),\n        (0x1D439, \"M\", \"f\"),\n        (0x1D43A, \"M\", \"g\"),\n        (0x1D43B, \"M\", \"h\"),\n        (0x1D43C, \"M\", \"i\"),\n        (0x1D43D, \"M\", \"j\"),\n        (0x1D43E, \"M\", \"k\"),\n        (0x1D43F, \"M\", \"l\"),\n        (0x1D440, \"M\", \"m\"),\n        (0x1D441, \"M\", \"n\"),\n        (0x1D442, \"M\", \"o\"),\n        (0x1D443, \"M\", \"p\"),\n        (0x1D444, \"M\", \"q\"),\n        (0x1D445, \"M\", \"r\"),\n        (0x1D446, \"M\", \"s\"),\n        (0x1D447, \"M\", \"t\"),\n        (0x1D448, \"M\", \"u\"),\n        (0x1D449, \"M\", \"v\"),\n        (0x1D44A, \"M\", \"w\"),\n        (0x1D44B, \"M\", \"x\"),\n        (0x1D44C, \"M\", \"y\"),\n        (0x1D44D, \"M\", \"z\"),\n        (0x1D44E, \"M\", \"a\"),\n        (0x1D44F, \"M\", \"b\"),\n        (0x1D450, \"M\", \"c\"),\n        (0x1D451, \"M\", \"d\"),\n        (0x1D452, \"M\", \"e\"),\n        (0x1D453, \"M\", \"f\"),\n        (0x1D454, \"M\", \"g\"),\n        (0x1D455, \"X\"),\n        (0x1D456, \"M\", \"i\"),\n        (0x1D457, \"M\", \"j\"),\n        (0x1D458, \"M\", \"k\"),\n        (0x1D459, \"M\", \"l\"),\n        (0x1D45A, \"M\", \"m\"),\n        (0x1D45B, \"M\", \"n\"),\n        (0x1D45C, \"M\", \"o\"),\n        (0x1D45D, \"M\", \"p\"),\n        (0x1D45E, \"M\", \"q\"),\n        (0x1D45F, \"M\", \"r\"),\n        (0x1D460, \"M\", \"s\"),\n        (0x1D461, \"M\", \"t\"),\n        (0x1D462, \"M\", \"u\"),\n        (0x1D463, \"M\", \"v\"),\n        (0x1D464, \"M\", \"w\"),\n        (0x1D465, \"M\", \"x\"),\n        (0x1D466, \"M\", \"y\"),\n        (0x1D467, \"M\", \"z\"),\n        (0x1D468, \"M\", \"a\"),\n        (0x1D469, \"M\", \"b\"),\n        (0x1D46A, \"M\", \"c\"),\n        (0x1D46B, \"M\", \"d\"),\n        (0x1D46C, \"M\", \"e\"),\n        (0x1D46D, \"M\", \"f\"),\n        (0x1D46E, \"M\", \"g\"),\n        (0x1D46F, \"M\", \"h\"),\n        (0x1D470, \"M\", \"i\"),\n        (0x1D471, \"M\", \"j\"),\n        (0x1D472, \"M\", \"k\"),\n        (0x1D473, \"M\", \"l\"),\n        (0x1D474, \"M\", \"m\"),\n        (0x1D475, \"M\", \"n\"),\n        (0x1D476, \"M\", \"o\"),\n        (0x1D477, \"M\", \"p\"),\n        (0x1D478, \"M\", \"q\"),\n        (0x1D479, \"M\", \"r\"),\n        (0x1D47A, \"M\", \"s\"),\n        (0x1D47B, \"M\", \"t\"),\n        (0x1D47C, \"M\", \"u\"),\n        (0x1D47D, \"M\", \"v\"),\n        (0x1D47E, \"M\", \"w\"),\n        (0x1D47F, \"M\", \"x\"),\n        (0x1D480, \"M\", \"y\"),\n        (0x1D481, \"M\", \"z\"),\n        (0x1D482, \"M\", \"a\"),\n        (0x1D483, \"M\", \"b\"),\n        (0x1D484, \"M\", \"c\"),\n        (0x1D485, \"M\", \"d\"),\n        (0x1D486, \"M\", \"e\"),\n        (0x1D487, \"M\", \"f\"),\n        (0x1D488, \"M\", \"g\"),\n    ]\n\n\ndef _seg_62() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1D489, \"M\", \"h\"),\n        (0x1D48A, \"M\", \"i\"),\n        (0x1D48B, \"M\", \"j\"),\n        (0x1D48C, \"M\", \"k\"),\n        (0x1D48D, \"M\", \"l\"),\n        (0x1D48E, \"M\", \"m\"),\n        (0x1D48F, \"M\", \"n\"),\n        (0x1D490, \"M\", \"o\"),\n        (0x1D491, \"M\", \"p\"),\n        (0x1D492, \"M\", \"q\"),\n        (0x1D493, \"M\", \"r\"),\n        (0x1D494, \"M\", \"s\"),\n        (0x1D495, \"M\", \"t\"),\n        (0x1D496, \"M\", \"u\"),\n        (0x1D497, \"M\", \"v\"),\n        (0x1D498, \"M\", \"w\"),\n        (0x1D499, \"M\", \"x\"),\n        (0x1D49A, \"M\", \"y\"),\n        (0x1D49B, \"M\", \"z\"),\n        (0x1D49C, \"M\", \"a\"),\n        (0x1D49D, \"X\"),\n        (0x1D49E, \"M\", \"c\"),\n        (0x1D49F, \"M\", \"d\"),\n        (0x1D4A0, \"X\"),\n        (0x1D4A2, \"M\", \"g\"),\n        (0x1D4A3, \"X\"),\n        (0x1D4A5, \"M\", \"j\"),\n        (0x1D4A6, \"M\", \"k\"),\n        (0x1D4A7, \"X\"),\n        (0x1D4A9, \"M\", \"n\"),\n        (0x1D4AA, \"M\", \"o\"),\n        (0x1D4AB, \"M\", \"p\"),\n        (0x1D4AC, \"M\", \"q\"),\n        (0x1D4AD, \"X\"),\n        (0x1D4AE, \"M\", \"s\"),\n        (0x1D4AF, \"M\", \"t\"),\n        (0x1D4B0, \"M\", \"u\"),\n        (0x1D4B1, \"M\", \"v\"),\n        (0x1D4B2, \"M\", \"w\"),\n        (0x1D4B3, \"M\", \"x\"),\n        (0x1D4B4, \"M\", \"y\"),\n        (0x1D4B5, \"M\", \"z\"),\n        (0x1D4B6, \"M\", \"a\"),\n        (0x1D4B7, \"M\", \"b\"),\n        (0x1D4B8, \"M\", \"c\"),\n        (0x1D4B9, \"M\", \"d\"),\n        (0x1D4BA, \"X\"),\n        (0x1D4BB, \"M\", \"f\"),\n        (0x1D4BC, \"X\"),\n        (0x1D4BD, \"M\", \"h\"),\n        (0x1D4BE, \"M\", \"i\"),\n        (0x1D4BF, \"M\", \"j\"),\n        (0x1D4C0, \"M\", \"k\"),\n        (0x1D4C1, \"M\", \"l\"),\n        (0x1D4C2, \"M\", \"m\"),\n        (0x1D4C3, \"M\", \"n\"),\n        (0x1D4C4, \"X\"),\n        (0x1D4C5, \"M\", \"p\"),\n        (0x1D4C6, \"M\", \"q\"),\n        (0x1D4C7, \"M\", \"r\"),\n        (0x1D4C8, \"M\", \"s\"),\n        (0x1D4C9, \"M\", \"t\"),\n        (0x1D4CA, \"M\", \"u\"),\n        (0x1D4CB, \"M\", \"v\"),\n        (0x1D4CC, \"M\", \"w\"),\n        (0x1D4CD, \"M\", \"x\"),\n        (0x1D4CE, \"M\", \"y\"),\n        (0x1D4CF, \"M\", \"z\"),\n        (0x1D4D0, \"M\", \"a\"),\n        (0x1D4D1, \"M\", \"b\"),\n        (0x1D4D2, \"M\", \"c\"),\n        (0x1D4D3, \"M\", \"d\"),\n        (0x1D4D4, \"M\", \"e\"),\n        (0x1D4D5, \"M\", \"f\"),\n        (0x1D4D6, \"M\", \"g\"),\n        (0x1D4D7, \"M\", \"h\"),\n        (0x1D4D8, \"M\", \"i\"),\n        (0x1D4D9, \"M\", \"j\"),\n        (0x1D4DA, \"M\", \"k\"),\n        (0x1D4DB, \"M\", \"l\"),\n        (0x1D4DC, \"M\", \"m\"),\n        (0x1D4DD, \"M\", \"n\"),\n        (0x1D4DE, \"M\", \"o\"),\n        (0x1D4DF, \"M\", \"p\"),\n        (0x1D4E0, \"M\", \"q\"),\n        (0x1D4E1, \"M\", \"r\"),\n        (0x1D4E2, \"M\", \"s\"),\n        (0x1D4E3, \"M\", \"t\"),\n        (0x1D4E4, \"M\", \"u\"),\n        (0x1D4E5, \"M\", \"v\"),\n        (0x1D4E6, \"M\", \"w\"),\n        (0x1D4E7, \"M\", \"x\"),\n        (0x1D4E8, \"M\", \"y\"),\n        (0x1D4E9, \"M\", \"z\"),\n        (0x1D4EA, \"M\", \"a\"),\n        (0x1D4EB, \"M\", \"b\"),\n        (0x1D4EC, \"M\", \"c\"),\n        (0x1D4ED, \"M\", \"d\"),\n        (0x1D4EE, \"M\", \"e\"),\n        (0x1D4EF, \"M\", \"f\"),\n    ]\n\n\ndef _seg_63() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1D4F0, \"M\", \"g\"),\n        (0x1D4F1, \"M\", \"h\"),\n        (0x1D4F2, \"M\", \"i\"),\n        (0x1D4F3, \"M\", \"j\"),\n        (0x1D4F4, \"M\", \"k\"),\n        (0x1D4F5, \"M\", \"l\"),\n        (0x1D4F6, \"M\", \"m\"),\n        (0x1D4F7, \"M\", \"n\"),\n        (0x1D4F8, \"M\", \"o\"),\n        (0x1D4F9, \"M\", \"p\"),\n        (0x1D4FA, \"M\", \"q\"),\n        (0x1D4FB, \"M\", \"r\"),\n        (0x1D4FC, \"M\", \"s\"),\n        (0x1D4FD, \"M\", \"t\"),\n        (0x1D4FE, \"M\", \"u\"),\n        (0x1D4FF, \"M\", \"v\"),\n        (0x1D500, \"M\", \"w\"),\n        (0x1D501, \"M\", \"x\"),\n        (0x1D502, \"M\", \"y\"),\n        (0x1D503, \"M\", \"z\"),\n        (0x1D504, \"M\", \"a\"),\n        (0x1D505, \"M\", \"b\"),\n        (0x1D506, \"X\"),\n        (0x1D507, \"M\", \"d\"),\n        (0x1D508, \"M\", \"e\"),\n        (0x1D509, \"M\", \"f\"),\n        (0x1D50A, \"M\", \"g\"),\n        (0x1D50B, \"X\"),\n        (0x1D50D, \"M\", \"j\"),\n        (0x1D50E, \"M\", \"k\"),\n        (0x1D50F, \"M\", \"l\"),\n        (0x1D510, \"M\", \"m\"),\n        (0x1D511, \"M\", \"n\"),\n        (0x1D512, \"M\", \"o\"),\n        (0x1D513, \"M\", \"p\"),\n        (0x1D514, \"M\", \"q\"),\n        (0x1D515, \"X\"),\n        (0x1D516, \"M\", \"s\"),\n        (0x1D517, \"M\", \"t\"),\n        (0x1D518, \"M\", \"u\"),\n        (0x1D519, \"M\", \"v\"),\n        (0x1D51A, \"M\", \"w\"),\n        (0x1D51B, \"M\", \"x\"),\n        (0x1D51C, \"M\", \"y\"),\n        (0x1D51D, \"X\"),\n        (0x1D51E, \"M\", \"a\"),\n        (0x1D51F, \"M\", \"b\"),\n        (0x1D520, \"M\", \"c\"),\n        (0x1D521, \"M\", \"d\"),\n        (0x1D522, \"M\", \"e\"),\n        (0x1D523, \"M\", \"f\"),\n        (0x1D524, \"M\", \"g\"),\n        (0x1D525, \"M\", \"h\"),\n        (0x1D526, \"M\", \"i\"),\n        (0x1D527, \"M\", \"j\"),\n        (0x1D528, \"M\", \"k\"),\n        (0x1D529, \"M\", \"l\"),\n        (0x1D52A, \"M\", \"m\"),\n        (0x1D52B, \"M\", \"n\"),\n        (0x1D52C, \"M\", \"o\"),\n        (0x1D52D, \"M\", \"p\"),\n        (0x1D52E, \"M\", \"q\"),\n        (0x1D52F, \"M\", \"r\"),\n        (0x1D530, \"M\", \"s\"),\n        (0x1D531, \"M\", \"t\"),\n        (0x1D532, \"M\", \"u\"),\n        (0x1D533, \"M\", \"v\"),\n        (0x1D534, \"M\", \"w\"),\n        (0x1D535, \"M\", \"x\"),\n        (0x1D536, \"M\", \"y\"),\n        (0x1D537, \"M\", \"z\"),\n        (0x1D538, \"M\", \"a\"),\n        (0x1D539, \"M\", \"b\"),\n        (0x1D53A, \"X\"),\n        (0x1D53B, \"M\", \"d\"),\n        (0x1D53C, \"M\", \"e\"),\n        (0x1D53D, \"M\", \"f\"),\n        (0x1D53E, \"M\", \"g\"),\n        (0x1D53F, \"X\"),\n        (0x1D540, \"M\", \"i\"),\n        (0x1D541, \"M\", \"j\"),\n        (0x1D542, \"M\", \"k\"),\n        (0x1D543, \"M\", \"l\"),\n        (0x1D544, \"M\", \"m\"),\n        (0x1D545, \"X\"),\n        (0x1D546, \"M\", \"o\"),\n        (0x1D547, \"X\"),\n        (0x1D54A, \"M\", \"s\"),\n        (0x1D54B, \"M\", \"t\"),\n        (0x1D54C, \"M\", \"u\"),\n        (0x1D54D, \"M\", \"v\"),\n        (0x1D54E, \"M\", \"w\"),\n        (0x1D54F, \"M\", \"x\"),\n        (0x1D550, \"M\", \"y\"),\n        (0x1D551, \"X\"),\n        (0x1D552, \"M\", \"a\"),\n        (0x1D553, \"M\", \"b\"),\n        (0x1D554, \"M\", \"c\"),\n        (0x1D555, \"M\", \"d\"),\n        (0x1D556, \"M\", \"e\"),\n    ]\n\n\ndef _seg_64() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1D557, \"M\", \"f\"),\n        (0x1D558, \"M\", \"g\"),\n        (0x1D559, \"M\", \"h\"),\n        (0x1D55A, \"M\", \"i\"),\n        (0x1D55B, \"M\", \"j\"),\n        (0x1D55C, \"M\", \"k\"),\n        (0x1D55D, \"M\", \"l\"),\n        (0x1D55E, \"M\", \"m\"),\n        (0x1D55F, \"M\", \"n\"),\n        (0x1D560, \"M\", \"o\"),\n        (0x1D561, \"M\", \"p\"),\n        (0x1D562, \"M\", \"q\"),\n        (0x1D563, \"M\", \"r\"),\n        (0x1D564, \"M\", \"s\"),\n        (0x1D565, \"M\", \"t\"),\n        (0x1D566, \"M\", \"u\"),\n        (0x1D567, \"M\", \"v\"),\n        (0x1D568, \"M\", \"w\"),\n        (0x1D569, \"M\", \"x\"),\n        (0x1D56A, \"M\", \"y\"),\n        (0x1D56B, \"M\", \"z\"),\n        (0x1D56C, \"M\", \"a\"),\n        (0x1D56D, \"M\", \"b\"),\n        (0x1D56E, \"M\", \"c\"),\n        (0x1D56F, \"M\", \"d\"),\n        (0x1D570, \"M\", \"e\"),\n        (0x1D571, \"M\", \"f\"),\n        (0x1D572, \"M\", \"g\"),\n        (0x1D573, \"M\", \"h\"),\n        (0x1D574, \"M\", \"i\"),\n        (0x1D575, \"M\", \"j\"),\n        (0x1D576, \"M\", \"k\"),\n        (0x1D577, \"M\", \"l\"),\n        (0x1D578, \"M\", \"m\"),\n        (0x1D579, \"M\", \"n\"),\n        (0x1D57A, \"M\", \"o\"),\n        (0x1D57B, \"M\", \"p\"),\n        (0x1D57C, \"M\", \"q\"),\n        (0x1D57D, \"M\", \"r\"),\n        (0x1D57E, \"M\", \"s\"),\n        (0x1D57F, \"M\", \"t\"),\n        (0x1D580, \"M\", \"u\"),\n        (0x1D581, \"M\", \"v\"),\n        (0x1D582, \"M\", \"w\"),\n        (0x1D583, \"M\", \"x\"),\n        (0x1D584, \"M\", \"y\"),\n        (0x1D585, \"M\", \"z\"),\n        (0x1D586, \"M\", \"a\"),\n        (0x1D587, \"M\", \"b\"),\n        (0x1D588, \"M\", \"c\"),\n        (0x1D589, \"M\", \"d\"),\n        (0x1D58A, \"M\", \"e\"),\n        (0x1D58B, \"M\", \"f\"),\n        (0x1D58C, \"M\", \"g\"),\n        (0x1D58D, \"M\", \"h\"),\n        (0x1D58E, \"M\", \"i\"),\n        (0x1D58F, \"M\", \"j\"),\n        (0x1D590, \"M\", \"k\"),\n        (0x1D591, \"M\", \"l\"),\n        (0x1D592, \"M\", \"m\"),\n        (0x1D593, \"M\", \"n\"),\n        (0x1D594, \"M\", \"o\"),\n        (0x1D595, \"M\", \"p\"),\n        (0x1D596, \"M\", \"q\"),\n        (0x1D597, \"M\", \"r\"),\n        (0x1D598, \"M\", \"s\"),\n        (0x1D599, \"M\", \"t\"),\n        (0x1D59A, \"M\", \"u\"),\n        (0x1D59B, \"M\", \"v\"),\n        (0x1D59C, \"M\", \"w\"),\n        (0x1D59D, \"M\", \"x\"),\n        (0x1D59E, \"M\", \"y\"),\n        (0x1D59F, \"M\", \"z\"),\n        (0x1D5A0, \"M\", \"a\"),\n        (0x1D5A1, \"M\", \"b\"),\n        (0x1D5A2, \"M\", \"c\"),\n        (0x1D5A3, \"M\", \"d\"),\n        (0x1D5A4, \"M\", \"e\"),\n        (0x1D5A5, \"M\", \"f\"),\n        (0x1D5A6, \"M\", \"g\"),\n        (0x1D5A7, \"M\", \"h\"),\n        (0x1D5A8, \"M\", \"i\"),\n        (0x1D5A9, \"M\", \"j\"),\n        (0x1D5AA, \"M\", \"k\"),\n        (0x1D5AB, \"M\", \"l\"),\n        (0x1D5AC, \"M\", \"m\"),\n        (0x1D5AD, \"M\", \"n\"),\n        (0x1D5AE, \"M\", \"o\"),\n        (0x1D5AF, \"M\", \"p\"),\n        (0x1D5B0, \"M\", \"q\"),\n        (0x1D5B1, \"M\", \"r\"),\n        (0x1D5B2, \"M\", \"s\"),\n        (0x1D5B3, \"M\", \"t\"),\n        (0x1D5B4, \"M\", \"u\"),\n        (0x1D5B5, \"M\", \"v\"),\n        (0x1D5B6, \"M\", \"w\"),\n        (0x1D5B7, \"M\", \"x\"),\n        (0x1D5B8, \"M\", \"y\"),\n        (0x1D5B9, \"M\", \"z\"),\n        (0x1D5BA, \"M\", \"a\"),\n    ]\n\n\ndef _seg_65() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1D5BB, \"M\", \"b\"),\n        (0x1D5BC, \"M\", \"c\"),\n        (0x1D5BD, \"M\", \"d\"),\n        (0x1D5BE, \"M\", \"e\"),\n        (0x1D5BF, \"M\", \"f\"),\n        (0x1D5C0, \"M\", \"g\"),\n        (0x1D5C1, \"M\", \"h\"),\n        (0x1D5C2, \"M\", \"i\"),\n        (0x1D5C3, \"M\", \"j\"),\n        (0x1D5C4, \"M\", \"k\"),\n        (0x1D5C5, \"M\", \"l\"),\n        (0x1D5C6, \"M\", \"m\"),\n        (0x1D5C7, \"M\", \"n\"),\n        (0x1D5C8, \"M\", \"o\"),\n        (0x1D5C9, \"M\", \"p\"),\n        (0x1D5CA, \"M\", \"q\"),\n        (0x1D5CB, \"M\", \"r\"),\n        (0x1D5CC, \"M\", \"s\"),\n        (0x1D5CD, \"M\", \"t\"),\n        (0x1D5CE, \"M\", \"u\"),\n        (0x1D5CF, \"M\", \"v\"),\n        (0x1D5D0, \"M\", \"w\"),\n        (0x1D5D1, \"M\", \"x\"),\n        (0x1D5D2, \"M\", \"y\"),\n        (0x1D5D3, \"M\", \"z\"),\n        (0x1D5D4, \"M\", \"a\"),\n        (0x1D5D5, \"M\", \"b\"),\n        (0x1D5D6, \"M\", \"c\"),\n        (0x1D5D7, \"M\", \"d\"),\n        (0x1D5D8, \"M\", \"e\"),\n        (0x1D5D9, \"M\", \"f\"),\n        (0x1D5DA, \"M\", \"g\"),\n        (0x1D5DB, \"M\", \"h\"),\n        (0x1D5DC, \"M\", \"i\"),\n        (0x1D5DD, \"M\", \"j\"),\n        (0x1D5DE, \"M\", \"k\"),\n        (0x1D5DF, \"M\", \"l\"),\n        (0x1D5E0, \"M\", \"m\"),\n        (0x1D5E1, \"M\", \"n\"),\n        (0x1D5E2, \"M\", \"o\"),\n        (0x1D5E3, \"M\", \"p\"),\n        (0x1D5E4, \"M\", \"q\"),\n        (0x1D5E5, \"M\", \"r\"),\n        (0x1D5E6, \"M\", \"s\"),\n        (0x1D5E7, \"M\", \"t\"),\n        (0x1D5E8, \"M\", \"u\"),\n        (0x1D5E9, \"M\", \"v\"),\n        (0x1D5EA, \"M\", \"w\"),\n        (0x1D5EB, \"M\", \"x\"),\n        (0x1D5EC, \"M\", \"y\"),\n        (0x1D5ED, \"M\", \"z\"),\n        (0x1D5EE, \"M\", \"a\"),\n        (0x1D5EF, \"M\", \"b\"),\n        (0x1D5F0, \"M\", \"c\"),\n        (0x1D5F1, \"M\", \"d\"),\n        (0x1D5F2, \"M\", \"e\"),\n        (0x1D5F3, \"M\", \"f\"),\n        (0x1D5F4, \"M\", \"g\"),\n        (0x1D5F5, \"M\", \"h\"),\n        (0x1D5F6, \"M\", \"i\"),\n        (0x1D5F7, \"M\", \"j\"),\n        (0x1D5F8, \"M\", \"k\"),\n        (0x1D5F9, \"M\", \"l\"),\n        (0x1D5FA, \"M\", \"m\"),\n        (0x1D5FB, \"M\", \"n\"),\n        (0x1D5FC, \"M\", \"o\"),\n        (0x1D5FD, \"M\", \"p\"),\n        (0x1D5FE, \"M\", \"q\"),\n        (0x1D5FF, \"M\", \"r\"),\n        (0x1D600, \"M\", \"s\"),\n        (0x1D601, \"M\", \"t\"),\n        (0x1D602, \"M\", \"u\"),\n        (0x1D603, \"M\", \"v\"),\n        (0x1D604, \"M\", \"w\"),\n        (0x1D605, \"M\", \"x\"),\n        (0x1D606, \"M\", \"y\"),\n        (0x1D607, \"M\", \"z\"),\n        (0x1D608, \"M\", \"a\"),\n        (0x1D609, \"M\", \"b\"),\n        (0x1D60A, \"M\", \"c\"),\n        (0x1D60B, \"M\", \"d\"),\n        (0x1D60C, \"M\", \"e\"),\n        (0x1D60D, \"M\", \"f\"),\n        (0x1D60E, \"M\", \"g\"),\n        (0x1D60F, \"M\", \"h\"),\n        (0x1D610, \"M\", \"i\"),\n        (0x1D611, \"M\", \"j\"),\n        (0x1D612, \"M\", \"k\"),\n        (0x1D613, \"M\", \"l\"),\n        (0x1D614, \"M\", \"m\"),\n        (0x1D615, \"M\", \"n\"),\n        (0x1D616, \"M\", \"o\"),\n        (0x1D617, \"M\", \"p\"),\n        (0x1D618, \"M\", \"q\"),\n        (0x1D619, \"M\", \"r\"),\n        (0x1D61A, \"M\", \"s\"),\n        (0x1D61B, \"M\", \"t\"),\n        (0x1D61C, \"M\", \"u\"),\n        (0x1D61D, \"M\", \"v\"),\n        (0x1D61E, \"M\", \"w\"),\n    ]\n\n\ndef _seg_66() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1D61F, \"M\", \"x\"),\n        (0x1D620, \"M\", \"y\"),\n        (0x1D621, \"M\", \"z\"),\n        (0x1D622, \"M\", \"a\"),\n        (0x1D623, \"M\", \"b\"),\n        (0x1D624, \"M\", \"c\"),\n        (0x1D625, \"M\", \"d\"),\n        (0x1D626, \"M\", \"e\"),\n        (0x1D627, \"M\", \"f\"),\n        (0x1D628, \"M\", \"g\"),\n        (0x1D629, \"M\", \"h\"),\n        (0x1D62A, \"M\", \"i\"),\n        (0x1D62B, \"M\", \"j\"),\n        (0x1D62C, \"M\", \"k\"),\n        (0x1D62D, \"M\", \"l\"),\n        (0x1D62E, \"M\", \"m\"),\n        (0x1D62F, \"M\", \"n\"),\n        (0x1D630, \"M\", \"o\"),\n        (0x1D631, \"M\", \"p\"),\n        (0x1D632, \"M\", \"q\"),\n        (0x1D633, \"M\", \"r\"),\n        (0x1D634, \"M\", \"s\"),\n        (0x1D635, \"M\", \"t\"),\n        (0x1D636, \"M\", \"u\"),\n        (0x1D637, \"M\", \"v\"),\n        (0x1D638, \"M\", \"w\"),\n        (0x1D639, \"M\", \"x\"),\n        (0x1D63A, \"M\", \"y\"),\n        (0x1D63B, \"M\", \"z\"),\n        (0x1D63C, \"M\", \"a\"),\n        (0x1D63D, \"M\", \"b\"),\n        (0x1D63E, \"M\", \"c\"),\n        (0x1D63F, \"M\", \"d\"),\n        (0x1D640, \"M\", \"e\"),\n        (0x1D641, \"M\", \"f\"),\n        (0x1D642, \"M\", \"g\"),\n        (0x1D643, \"M\", \"h\"),\n        (0x1D644, \"M\", \"i\"),\n        (0x1D645, \"M\", \"j\"),\n        (0x1D646, \"M\", \"k\"),\n        (0x1D647, \"M\", \"l\"),\n        (0x1D648, \"M\", \"m\"),\n        (0x1D649, \"M\", \"n\"),\n        (0x1D64A, \"M\", \"o\"),\n        (0x1D64B, \"M\", \"p\"),\n        (0x1D64C, \"M\", \"q\"),\n        (0x1D64D, \"M\", \"r\"),\n        (0x1D64E, \"M\", \"s\"),\n        (0x1D64F, \"M\", \"t\"),\n        (0x1D650, \"M\", \"u\"),\n        (0x1D651, \"M\", \"v\"),\n        (0x1D652, \"M\", \"w\"),\n        (0x1D653, \"M\", \"x\"),\n        (0x1D654, \"M\", \"y\"),\n        (0x1D655, \"M\", \"z\"),\n        (0x1D656, \"M\", \"a\"),\n        (0x1D657, \"M\", \"b\"),\n        (0x1D658, \"M\", \"c\"),\n        (0x1D659, \"M\", \"d\"),\n        (0x1D65A, \"M\", \"e\"),\n        (0x1D65B, \"M\", \"f\"),\n        (0x1D65C, \"M\", \"g\"),\n        (0x1D65D, \"M\", \"h\"),\n        (0x1D65E, \"M\", \"i\"),\n        (0x1D65F, \"M\", \"j\"),\n        (0x1D660, \"M\", \"k\"),\n        (0x1D661, \"M\", \"l\"),\n        (0x1D662, \"M\", \"m\"),\n        (0x1D663, \"M\", \"n\"),\n        (0x1D664, \"M\", \"o\"),\n        (0x1D665, \"M\", \"p\"),\n        (0x1D666, \"M\", \"q\"),\n        (0x1D667, \"M\", \"r\"),\n        (0x1D668, \"M\", \"s\"),\n        (0x1D669, \"M\", \"t\"),\n        (0x1D66A, \"M\", \"u\"),\n        (0x1D66B, \"M\", \"v\"),\n        (0x1D66C, \"M\", \"w\"),\n        (0x1D66D, \"M\", \"x\"),\n        (0x1D66E, \"M\", \"y\"),\n        (0x1D66F, \"M\", \"z\"),\n        (0x1D670, \"M\", \"a\"),\n        (0x1D671, \"M\", \"b\"),\n        (0x1D672, \"M\", \"c\"),\n        (0x1D673, \"M\", \"d\"),\n        (0x1D674, \"M\", \"e\"),\n        (0x1D675, \"M\", \"f\"),\n        (0x1D676, \"M\", \"g\"),\n        (0x1D677, \"M\", \"h\"),\n        (0x1D678, \"M\", \"i\"),\n        (0x1D679, \"M\", \"j\"),\n        (0x1D67A, \"M\", \"k\"),\n        (0x1D67B, \"M\", \"l\"),\n        (0x1D67C, \"M\", \"m\"),\n        (0x1D67D, \"M\", \"n\"),\n        (0x1D67E, \"M\", \"o\"),\n        (0x1D67F, \"M\", \"p\"),\n        (0x1D680, \"M\", \"q\"),\n        (0x1D681, \"M\", \"r\"),\n        (0x1D682, \"M\", \"s\"),\n    ]\n\n\ndef _seg_67() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1D683, \"M\", \"t\"),\n        (0x1D684, \"M\", \"u\"),\n        (0x1D685, \"M\", \"v\"),\n        (0x1D686, \"M\", \"w\"),\n        (0x1D687, \"M\", \"x\"),\n        (0x1D688, \"M\", \"y\"),\n        (0x1D689, \"M\", \"z\"),\n        (0x1D68A, \"M\", \"a\"),\n        (0x1D68B, \"M\", \"b\"),\n        (0x1D68C, \"M\", \"c\"),\n        (0x1D68D, \"M\", \"d\"),\n        (0x1D68E, \"M\", \"e\"),\n        (0x1D68F, \"M\", \"f\"),\n        (0x1D690, \"M\", \"g\"),\n        (0x1D691, \"M\", \"h\"),\n        (0x1D692, \"M\", \"i\"),\n        (0x1D693, \"M\", \"j\"),\n        (0x1D694, \"M\", \"k\"),\n        (0x1D695, \"M\", \"l\"),\n        (0x1D696, \"M\", \"m\"),\n        (0x1D697, \"M\", \"n\"),\n        (0x1D698, \"M\", \"o\"),\n        (0x1D699, \"M\", \"p\"),\n        (0x1D69A, \"M\", \"q\"),\n        (0x1D69B, \"M\", \"r\"),\n        (0x1D69C, \"M\", \"s\"),\n        (0x1D69D, \"M\", \"t\"),\n        (0x1D69E, \"M\", \"u\"),\n        (0x1D69F, \"M\", \"v\"),\n        (0x1D6A0, \"M\", \"w\"),\n        (0x1D6A1, \"M\", \"x\"),\n        (0x1D6A2, \"M\", \"y\"),\n        (0x1D6A3, \"M\", \"z\"),\n        (0x1D6A4, \"M\", \"\"),\n        (0x1D6A5, \"M\", \"\"),\n        (0x1D6A6, \"X\"),\n        (0x1D6A8, \"M\", \"\"),\n        (0x1D6A9, \"M\", \"\"),\n        (0x1D6AA, \"M\", \"\"),\n        (0x1D6AB, \"M\", \"\"),\n        (0x1D6AC, \"M\", \"\"),\n        (0x1D6AD, \"M\", \"\"),\n        (0x1D6AE, \"M\", \"\"),\n        (0x1D6AF, \"M\", \"\"),\n        (0x1D6B0, \"M\", \"\"),\n        (0x1D6B1, \"M\", \"\"),\n        (0x1D6B2, \"M\", \"\"),\n        (0x1D6B3, \"M\", \"\"),\n        (0x1D6B4, \"M\", \"\"),\n        (0x1D6B5, \"M\", \"\"),\n        (0x1D6B6, \"M\", \"\"),\n        (0x1D6B7, \"M\", \"\"),\n        (0x1D6B8, \"M\", \"\"),\n        (0x1D6B9, \"M\", \"\"),\n        (0x1D6BA, \"M\", \"\"),\n        (0x1D6BB, \"M\", \"\"),\n        (0x1D6BC, \"M\", \"\"),\n        (0x1D6BD, \"M\", \"\"),\n        (0x1D6BE, \"M\", \"\"),\n        (0x1D6BF, \"M\", \"\"),\n        (0x1D6C0, \"M\", \"\"),\n        (0x1D6C1, \"M\", \"\"),\n        (0x1D6C2, \"M\", \"\"),\n        (0x1D6C3, \"M\", \"\"),\n        (0x1D6C4, \"M\", \"\"),\n        (0x1D6C5, \"M\", \"\"),\n        (0x1D6C6, \"M\", \"\"),\n        (0x1D6C7, \"M\", \"\"),\n        (0x1D6C8, \"M\", \"\"),\n        (0x1D6C9, \"M\", \"\"),\n        (0x1D6CA, \"M\", \"\"),\n        (0x1D6CB, \"M\", \"\"),\n        (0x1D6CC, \"M\", \"\"),\n        (0x1D6CD, \"M\", \"\"),\n        (0x1D6CE, \"M\", \"\"),\n        (0x1D6CF, \"M\", \"\"),\n        (0x1D6D0, \"M\", \"\"),\n        (0x1D6D1, \"M\", \"\"),\n        (0x1D6D2, \"M\", \"\"),\n        (0x1D6D3, \"M\", \"\"),\n        (0x1D6D5, \"M\", \"\"),\n        (0x1D6D6, \"M\", \"\"),\n        (0x1D6D7, \"M\", \"\"),\n        (0x1D6D8, \"M\", \"\"),\n        (0x1D6D9, \"M\", \"\"),\n        (0x1D6DA, \"M\", \"\"),\n        (0x1D6DB, \"M\", \"\"),\n        (0x1D6DC, \"M\", \"\"),\n        (0x1D6DD, \"M\", \"\"),\n        (0x1D6DE, \"M\", \"\"),\n        (0x1D6DF, \"M\", \"\"),\n        (0x1D6E0, \"M\", \"\"),\n        (0x1D6E1, \"M\", \"\"),\n        (0x1D6E2, \"M\", \"\"),\n        (0x1D6E3, \"M\", \"\"),\n        (0x1D6E4, \"M\", \"\"),\n        (0x1D6E5, \"M\", \"\"),\n        (0x1D6E6, \"M\", \"\"),\n        (0x1D6E7, \"M\", \"\"),\n        (0x1D6E8, \"M\", \"\"),\n    ]\n\n\ndef _seg_68() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1D6E9, \"M\", \"\"),\n        (0x1D6EA, \"M\", \"\"),\n        (0x1D6EB, \"M\", \"\"),\n        (0x1D6EC, \"M\", \"\"),\n        (0x1D6ED, \"M\", \"\"),\n        (0x1D6EE, \"M\", \"\"),\n        (0x1D6EF, \"M\", \"\"),\n        (0x1D6F0, \"M\", \"\"),\n        (0x1D6F1, \"M\", \"\"),\n        (0x1D6F2, \"M\", \"\"),\n        (0x1D6F3, \"M\", \"\"),\n        (0x1D6F4, \"M\", \"\"),\n        (0x1D6F5, \"M\", \"\"),\n        (0x1D6F6, \"M\", \"\"),\n        (0x1D6F7, \"M\", \"\"),\n        (0x1D6F8, \"M\", \"\"),\n        (0x1D6F9, \"M\", \"\"),\n        (0x1D6FA, \"M\", \"\"),\n        (0x1D6FB, \"M\", \"\"),\n        (0x1D6FC, \"M\", \"\"),\n        (0x1D6FD, \"M\", \"\"),\n        (0x1D6FE, \"M\", \"\"),\n        (0x1D6FF, \"M\", \"\"),\n        (0x1D700, \"M\", \"\"),\n        (0x1D701, \"M\", \"\"),\n        (0x1D702, \"M\", \"\"),\n        (0x1D703, \"M\", \"\"),\n        (0x1D704, \"M\", \"\"),\n        (0x1D705, \"M\", \"\"),\n        (0x1D706, \"M\", \"\"),\n        (0x1D707, \"M\", \"\"),\n        (0x1D708, \"M\", \"\"),\n        (0x1D709, \"M\", \"\"),\n        (0x1D70A, \"M\", \"\"),\n        (0x1D70B, \"M\", \"\"),\n        (0x1D70C, \"M\", \"\"),\n        (0x1D70D, \"M\", \"\"),\n        (0x1D70F, \"M\", \"\"),\n        (0x1D710, \"M\", \"\"),\n        (0x1D711, \"M\", \"\"),\n        (0x1D712, \"M\", \"\"),\n        (0x1D713, \"M\", \"\"),\n        (0x1D714, \"M\", \"\"),\n        (0x1D715, \"M\", \"\"),\n        (0x1D716, \"M\", \"\"),\n        (0x1D717, \"M\", \"\"),\n        (0x1D718, \"M\", \"\"),\n        (0x1D719, \"M\", \"\"),\n        (0x1D71A, \"M\", \"\"),\n        (0x1D71B, \"M\", \"\"),\n        (0x1D71C, \"M\", \"\"),\n        (0x1D71D, \"M\", \"\"),\n        (0x1D71E, \"M\", \"\"),\n        (0x1D71F, \"M\", \"\"),\n        (0x1D720, \"M\", \"\"),\n        (0x1D721, \"M\", \"\"),\n        (0x1D722, \"M\", \"\"),\n        (0x1D723, \"M\", \"\"),\n        (0x1D724, \"M\", \"\"),\n        (0x1D725, \"M\", \"\"),\n        (0x1D726, \"M\", \"\"),\n        (0x1D727, \"M\", \"\"),\n        (0x1D728, \"M\", \"\"),\n        (0x1D729, \"M\", \"\"),\n        (0x1D72A, \"M\", \"\"),\n        (0x1D72B, \"M\", \"\"),\n        (0x1D72C, \"M\", \"\"),\n        (0x1D72D, \"M\", \"\"),\n        (0x1D72E, \"M\", \"\"),\n        (0x1D72F, \"M\", \"\"),\n        (0x1D730, \"M\", \"\"),\n        (0x1D731, \"M\", \"\"),\n        (0x1D732, \"M\", \"\"),\n        (0x1D733, \"M\", \"\"),\n        (0x1D734, \"M\", \"\"),\n        (0x1D735, \"M\", \"\"),\n        (0x1D736, \"M\", \"\"),\n        (0x1D737, \"M\", \"\"),\n        (0x1D738, \"M\", \"\"),\n        (0x1D739, \"M\", \"\"),\n        (0x1D73A, \"M\", \"\"),\n        (0x1D73B, \"M\", \"\"),\n        (0x1D73C, \"M\", \"\"),\n        (0x1D73D, \"M\", \"\"),\n        (0x1D73E, \"M\", \"\"),\n        (0x1D73F, \"M\", \"\"),\n        (0x1D740, \"M\", \"\"),\n        (0x1D741, \"M\", \"\"),\n        (0x1D742, \"M\", \"\"),\n        (0x1D743, \"M\", \"\"),\n        (0x1D744, \"M\", \"\"),\n        (0x1D745, \"M\", \"\"),\n        (0x1D746, \"M\", \"\"),\n        (0x1D747, \"M\", \"\"),\n        (0x1D749, \"M\", \"\"),\n        (0x1D74A, \"M\", \"\"),\n        (0x1D74B, \"M\", \"\"),\n        (0x1D74C, \"M\", \"\"),\n        (0x1D74D, \"M\", \"\"),\n        (0x1D74E, \"M\", \"\"),\n    ]\n\n\ndef _seg_69() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1D74F, \"M\", \"\"),\n        (0x1D750, \"M\", \"\"),\n        (0x1D751, \"M\", \"\"),\n        (0x1D752, \"M\", \"\"),\n        (0x1D753, \"M\", \"\"),\n        (0x1D754, \"M\", \"\"),\n        (0x1D755, \"M\", \"\"),\n        (0x1D756, \"M\", \"\"),\n        (0x1D757, \"M\", \"\"),\n        (0x1D758, \"M\", \"\"),\n        (0x1D759, \"M\", \"\"),\n        (0x1D75A, \"M\", \"\"),\n        (0x1D75B, \"M\", \"\"),\n        (0x1D75C, \"M\", \"\"),\n        (0x1D75D, \"M\", \"\"),\n        (0x1D75E, \"M\", \"\"),\n        (0x1D75F, \"M\", \"\"),\n        (0x1D760, \"M\", \"\"),\n        (0x1D761, \"M\", \"\"),\n        (0x1D762, \"M\", \"\"),\n        (0x1D763, \"M\", \"\"),\n        (0x1D764, \"M\", \"\"),\n        (0x1D765, \"M\", \"\"),\n        (0x1D766, \"M\", \"\"),\n        (0x1D767, \"M\", \"\"),\n        (0x1D768, \"M\", \"\"),\n        (0x1D769, \"M\", \"\"),\n        (0x1D76A, \"M\", \"\"),\n        (0x1D76B, \"M\", \"\"),\n        (0x1D76C, \"M\", \"\"),\n        (0x1D76D, \"M\", \"\"),\n        (0x1D76E, \"M\", \"\"),\n        (0x1D76F, \"M\", \"\"),\n        (0x1D770, \"M\", \"\"),\n        (0x1D771, \"M\", \"\"),\n        (0x1D772, \"M\", \"\"),\n        (0x1D773, \"M\", \"\"),\n        (0x1D774, \"M\", \"\"),\n        (0x1D775, \"M\", \"\"),\n        (0x1D776, \"M\", \"\"),\n        (0x1D777, \"M\", \"\"),\n        (0x1D778, \"M\", \"\"),\n        (0x1D779, \"M\", \"\"),\n        (0x1D77A, \"M\", \"\"),\n        (0x1D77B, \"M\", \"\"),\n        (0x1D77C, \"M\", \"\"),\n        (0x1D77D, \"M\", \"\"),\n        (0x1D77E, \"M\", \"\"),\n        (0x1D77F, \"M\", \"\"),\n        (0x1D780, \"M\", \"\"),\n        (0x1D781, \"M\", \"\"),\n        (0x1D783, \"M\", \"\"),\n        (0x1D784, \"M\", \"\"),\n        (0x1D785, \"M\", \"\"),\n        (0x1D786, \"M\", \"\"),\n        (0x1D787, \"M\", \"\"),\n        (0x1D788, \"M\", \"\"),\n        (0x1D789, \"M\", \"\"),\n        (0x1D78A, \"M\", \"\"),\n        (0x1D78B, \"M\", \"\"),\n        (0x1D78C, \"M\", \"\"),\n        (0x1D78D, \"M\", \"\"),\n        (0x1D78E, \"M\", \"\"),\n        (0x1D78F, \"M\", \"\"),\n        (0x1D790, \"M\", \"\"),\n        (0x1D791, \"M\", \"\"),\n        (0x1D792, \"M\", \"\"),\n        (0x1D793, \"M\", \"\"),\n        (0x1D794, \"M\", \"\"),\n        (0x1D795, \"M\", \"\"),\n        (0x1D796, \"M\", \"\"),\n        (0x1D797, \"M\", \"\"),\n        (0x1D798, \"M\", \"\"),\n        (0x1D799, \"M\", \"\"),\n        (0x1D79A, \"M\", \"\"),\n        (0x1D79B, \"M\", \"\"),\n        (0x1D79C, \"M\", \"\"),\n        (0x1D79D, \"M\", \"\"),\n        (0x1D79E, \"M\", \"\"),\n        (0x1D79F, \"M\", \"\"),\n        (0x1D7A0, \"M\", \"\"),\n        (0x1D7A1, \"M\", \"\"),\n        (0x1D7A2, \"M\", \"\"),\n        (0x1D7A3, \"M\", \"\"),\n        (0x1D7A4, \"M\", \"\"),\n        (0x1D7A5, \"M\", \"\"),\n        (0x1D7A6, \"M\", \"\"),\n        (0x1D7A7, \"M\", \"\"),\n        (0x1D7A8, \"M\", \"\"),\n        (0x1D7A9, \"M\", \"\"),\n        (0x1D7AA, \"M\", \"\"),\n        (0x1D7AB, \"M\", \"\"),\n        (0x1D7AC, \"M\", \"\"),\n        (0x1D7AD, \"M\", \"\"),\n        (0x1D7AE, \"M\", \"\"),\n        (0x1D7AF, \"M\", \"\"),\n        (0x1D7B0, \"M\", \"\"),\n        (0x1D7B1, \"M\", \"\"),\n        (0x1D7B2, \"M\", \"\"),\n        (0x1D7B3, \"M\", \"\"),\n    ]\n\n\ndef _seg_70() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1D7B4, \"M\", \"\"),\n        (0x1D7B5, \"M\", \"\"),\n        (0x1D7B6, \"M\", \"\"),\n        (0x1D7B7, \"M\", \"\"),\n        (0x1D7B8, \"M\", \"\"),\n        (0x1D7B9, \"M\", \"\"),\n        (0x1D7BA, \"M\", \"\"),\n        (0x1D7BB, \"M\", \"\"),\n        (0x1D7BD, \"M\", \"\"),\n        (0x1D7BE, \"M\", \"\"),\n        (0x1D7BF, \"M\", \"\"),\n        (0x1D7C0, \"M\", \"\"),\n        (0x1D7C1, \"M\", \"\"),\n        (0x1D7C2, \"M\", \"\"),\n        (0x1D7C3, \"M\", \"\"),\n        (0x1D7C4, \"M\", \"\"),\n        (0x1D7C5, \"M\", \"\"),\n        (0x1D7C6, \"M\", \"\"),\n        (0x1D7C7, \"M\", \"\"),\n        (0x1D7C8, \"M\", \"\"),\n        (0x1D7C9, \"M\", \"\"),\n        (0x1D7CA, \"M\", \"\"),\n        (0x1D7CC, \"X\"),\n        (0x1D7CE, \"M\", \"0\"),\n        (0x1D7CF, \"M\", \"1\"),\n        (0x1D7D0, \"M\", \"2\"),\n        (0x1D7D1, \"M\", \"3\"),\n        (0x1D7D2, \"M\", \"4\"),\n        (0x1D7D3, \"M\", \"5\"),\n        (0x1D7D4, \"M\", \"6\"),\n        (0x1D7D5, \"M\", \"7\"),\n        (0x1D7D6, \"M\", \"8\"),\n        (0x1D7D7, \"M\", \"9\"),\n        (0x1D7D8, \"M\", \"0\"),\n        (0x1D7D9, \"M\", \"1\"),\n        (0x1D7DA, \"M\", \"2\"),\n        (0x1D7DB, \"M\", \"3\"),\n        (0x1D7DC, \"M\", \"4\"),\n        (0x1D7DD, \"M\", \"5\"),\n        (0x1D7DE, \"M\", \"6\"),\n        (0x1D7DF, \"M\", \"7\"),\n        (0x1D7E0, \"M\", \"8\"),\n        (0x1D7E1, \"M\", \"9\"),\n        (0x1D7E2, \"M\", \"0\"),\n        (0x1D7E3, \"M\", \"1\"),\n        (0x1D7E4, \"M\", \"2\"),\n        (0x1D7E5, \"M\", \"3\"),\n        (0x1D7E6, \"M\", \"4\"),\n        (0x1D7E7, \"M\", \"5\"),\n        (0x1D7E8, \"M\", \"6\"),\n        (0x1D7E9, \"M\", \"7\"),\n        (0x1D7EA, \"M\", \"8\"),\n        (0x1D7EB, \"M\", \"9\"),\n        (0x1D7EC, \"M\", \"0\"),\n        (0x1D7ED, \"M\", \"1\"),\n        (0x1D7EE, \"M\", \"2\"),\n        (0x1D7EF, \"M\", \"3\"),\n        (0x1D7F0, \"M\", \"4\"),\n        (0x1D7F1, \"M\", \"5\"),\n        (0x1D7F2, \"M\", \"6\"),\n        (0x1D7F3, \"M\", \"7\"),\n        (0x1D7F4, \"M\", \"8\"),\n        (0x1D7F5, \"M\", \"9\"),\n        (0x1D7F6, \"M\", \"0\"),\n        (0x1D7F7, \"M\", \"1\"),\n        (0x1D7F8, \"M\", \"2\"),\n        (0x1D7F9, \"M\", \"3\"),\n        (0x1D7FA, \"M\", \"4\"),\n        (0x1D7FB, \"M\", \"5\"),\n        (0x1D7FC, \"M\", \"6\"),\n        (0x1D7FD, \"M\", \"7\"),\n        (0x1D7FE, \"M\", \"8\"),\n        (0x1D7FF, \"M\", \"9\"),\n        (0x1D800, \"V\"),\n        (0x1DA8C, \"X\"),\n        (0x1DA9B, \"V\"),\n        (0x1DAA0, \"X\"),\n        (0x1DAA1, \"V\"),\n        (0x1DAB0, \"X\"),\n        (0x1DF00, \"V\"),\n        (0x1DF1F, \"X\"),\n        (0x1DF25, \"V\"),\n        (0x1DF2B, \"X\"),\n        (0x1E000, \"V\"),\n        (0x1E007, \"X\"),\n        (0x1E008, \"V\"),\n        (0x1E019, \"X\"),\n        (0x1E01B, \"V\"),\n        (0x1E022, \"X\"),\n        (0x1E023, \"V\"),\n        (0x1E025, \"X\"),\n        (0x1E026, \"V\"),\n        (0x1E02B, \"X\"),\n        (0x1E030, \"M\", \"\"),\n        (0x1E031, \"M\", \"\"),\n        (0x1E032, \"M\", \"\"),\n        (0x1E033, \"M\", \"\"),\n        (0x1E034, \"M\", \"\"),\n        (0x1E035, \"M\", \"\"),\n        (0x1E036, \"M\", \"\"),\n    ]\n\n\ndef _seg_71() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1E037, \"M\", \"\"),\n        (0x1E038, \"M\", \"\"),\n        (0x1E039, \"M\", \"\"),\n        (0x1E03A, \"M\", \"\"),\n        (0x1E03B, \"M\", \"\"),\n        (0x1E03C, \"M\", \"\"),\n        (0x1E03D, \"M\", \"\"),\n        (0x1E03E, \"M\", \"\"),\n        (0x1E03F, \"M\", \"\"),\n        (0x1E040, \"M\", \"\"),\n        (0x1E041, \"M\", \"\"),\n        (0x1E042, \"M\", \"\"),\n        (0x1E043, \"M\", \"\"),\n        (0x1E044, \"M\", \"\"),\n        (0x1E045, \"M\", \"\"),\n        (0x1E046, \"M\", \"\"),\n        (0x1E047, \"M\", \"\"),\n        (0x1E048, \"M\", \"\"),\n        (0x1E049, \"M\", \"\"),\n        (0x1E04A, \"M\", \"\"),\n        (0x1E04B, \"M\", \"\"),\n        (0x1E04C, \"M\", \"\"),\n        (0x1E04D, \"M\", \"\"),\n        (0x1E04E, \"M\", \"\"),\n        (0x1E04F, \"M\", \"\"),\n        (0x1E050, \"M\", \"\"),\n        (0x1E051, \"M\", \"\"),\n        (0x1E052, \"M\", \"\"),\n        (0x1E053, \"M\", \"\"),\n        (0x1E054, \"M\", \"\"),\n        (0x1E055, \"M\", \"\"),\n        (0x1E056, \"M\", \"\"),\n        (0x1E057, \"M\", \"\"),\n        (0x1E058, \"M\", \"\"),\n        (0x1E059, \"M\", \"\"),\n        (0x1E05A, \"M\", \"\"),\n        (0x1E05B, \"M\", \"\"),\n        (0x1E05C, \"M\", \"\"),\n        (0x1E05D, \"M\", \"\"),\n        (0x1E05E, \"M\", \"\"),\n        (0x1E05F, \"M\", \"\"),\n        (0x1E060, \"M\", \"\"),\n        (0x1E061, \"M\", \"\"),\n        (0x1E062, \"M\", \"\"),\n        (0x1E063, \"M\", \"\"),\n        (0x1E064, \"M\", \"\"),\n        (0x1E065, \"M\", \"\"),\n        (0x1E066, \"M\", \"\"),\n        (0x1E067, \"M\", \"\"),\n        (0x1E068, \"M\", \"\"),\n        (0x1E069, \"M\", \"\"),\n        (0x1E06A, \"M\", \"\"),\n        (0x1E06B, \"M\", \"\"),\n        (0x1E06C, \"M\", \"\"),\n        (0x1E06D, \"M\", \"\"),\n        (0x1E06E, \"X\"),\n        (0x1E08F, \"V\"),\n        (0x1E090, \"X\"),\n        (0x1E100, \"V\"),\n        (0x1E12D, \"X\"),\n        (0x1E130, \"V\"),\n        (0x1E13E, \"X\"),\n        (0x1E140, \"V\"),\n        (0x1E14A, \"X\"),\n        (0x1E14E, \"V\"),\n        (0x1E150, \"X\"),\n        (0x1E290, \"V\"),\n        (0x1E2AF, \"X\"),\n        (0x1E2C0, \"V\"),\n        (0x1E2FA, \"X\"),\n        (0x1E2FF, \"V\"),\n        (0x1E300, \"X\"),\n        (0x1E4D0, \"V\"),\n        (0x1E4FA, \"X\"),\n        (0x1E7E0, \"V\"),\n        (0x1E7E7, \"X\"),\n        (0x1E7E8, \"V\"),\n        (0x1E7EC, \"X\"),\n        (0x1E7ED, \"V\"),\n        (0x1E7EF, \"X\"),\n        (0x1E7F0, \"V\"),\n        (0x1E7FF, \"X\"),\n        (0x1E800, \"V\"),\n        (0x1E8C5, \"X\"),\n        (0x1E8C7, \"V\"),\n        (0x1E8D7, \"X\"),\n        (0x1E900, \"M\", \"\"),\n        (0x1E901, \"M\", \"\"),\n        (0x1E902, \"M\", \"\"),\n        (0x1E903, \"M\", \"\"),\n        (0x1E904, \"M\", \"\"),\n        (0x1E905, \"M\", \"\"),\n        (0x1E906, \"M\", \"\"),\n        (0x1E907, \"M\", \"\"),\n        (0x1E908, \"M\", \"\"),\n        (0x1E909, \"M\", \"\"),\n        (0x1E90A, \"M\", \"\"),\n        (0x1E90B, \"M\", \"\"),\n        (0x1E90C, \"M\", \"\"),\n        (0x1E90D, \"M\", \"\"),\n    ]\n\n\ndef _seg_72() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1E90E, \"M\", \"\"),\n        (0x1E90F, \"M\", \"\"),\n        (0x1E910, \"M\", \"\"),\n        (0x1E911, \"M\", \"\"),\n        (0x1E912, \"M\", \"\"),\n        (0x1E913, \"M\", \"\"),\n        (0x1E914, \"M\", \"\"),\n        (0x1E915, \"M\", \"\"),\n        (0x1E916, \"M\", \"\"),\n        (0x1E917, \"M\", \"\"),\n        (0x1E918, \"M\", \"\"),\n        (0x1E919, \"M\", \"\"),\n        (0x1E91A, \"M\", \"\"),\n        (0x1E91B, \"M\", \"\"),\n        (0x1E91C, \"M\", \"\"),\n        (0x1E91D, \"M\", \"\"),\n        (0x1E91E, \"M\", \"\"),\n        (0x1E91F, \"M\", \"\"),\n        (0x1E920, \"M\", \"\"),\n        (0x1E921, \"M\", \"\"),\n        (0x1E922, \"V\"),\n        (0x1E94C, \"X\"),\n        (0x1E950, \"V\"),\n        (0x1E95A, \"X\"),\n        (0x1E95E, \"V\"),\n        (0x1E960, \"X\"),\n        (0x1EC71, \"V\"),\n        (0x1ECB5, \"X\"),\n        (0x1ED01, \"V\"),\n        (0x1ED3E, \"X\"),\n        (0x1EE00, \"M\", \"\"),\n        (0x1EE01, \"M\", \"\"),\n        (0x1EE02, \"M\", \"\"),\n        (0x1EE03, \"M\", \"\"),\n        (0x1EE04, \"X\"),\n        (0x1EE05, \"M\", \"\"),\n        (0x1EE06, \"M\", \"\"),\n        (0x1EE07, \"M\", \"\"),\n        (0x1EE08, \"M\", \"\"),\n        (0x1EE09, \"M\", \"\"),\n        (0x1EE0A, \"M\", \"\"),\n        (0x1EE0B, \"M\", \"\"),\n        (0x1EE0C, \"M\", \"\"),\n        (0x1EE0D, \"M\", \"\"),\n        (0x1EE0E, \"M\", \"\"),\n        (0x1EE0F, \"M\", \"\"),\n        (0x1EE10, \"M\", \"\"),\n        (0x1EE11, \"M\", \"\"),\n        (0x1EE12, \"M\", \"\"),\n        (0x1EE13, \"M\", \"\"),\n        (0x1EE14, \"M\", \"\"),\n        (0x1EE15, \"M\", \"\"),\n        (0x1EE16, \"M\", \"\"),\n        (0x1EE17, \"M\", \"\"),\n        (0x1EE18, \"M\", \"\"),\n        (0x1EE19, \"M\", \"\"),\n        (0x1EE1A, \"M\", \"\"),\n        (0x1EE1B, \"M\", \"\"),\n        (0x1EE1C, \"M\", \"\"),\n        (0x1EE1D, \"M\", \"\"),\n        (0x1EE1E, \"M\", \"\"),\n        (0x1EE1F, \"M\", \"\"),\n        (0x1EE20, \"X\"),\n        (0x1EE21, \"M\", \"\"),\n        (0x1EE22, \"M\", \"\"),\n        (0x1EE23, \"X\"),\n        (0x1EE24, \"M\", \"\"),\n        (0x1EE25, \"X\"),\n        (0x1EE27, \"M\", \"\"),\n        (0x1EE28, \"X\"),\n        (0x1EE29, \"M\", \"\"),\n        (0x1EE2A, \"M\", \"\"),\n        (0x1EE2B, \"M\", \"\"),\n        (0x1EE2C, \"M\", \"\"),\n        (0x1EE2D, \"M\", \"\"),\n        (0x1EE2E, \"M\", \"\"),\n        (0x1EE2F, \"M\", \"\"),\n        (0x1EE30, \"M\", \"\"),\n        (0x1EE31, \"M\", \"\"),\n        (0x1EE32, \"M\", \"\"),\n        (0x1EE33, \"X\"),\n        (0x1EE34, \"M\", \"\"),\n        (0x1EE35, \"M\", \"\"),\n        (0x1EE36, \"M\", \"\"),\n        (0x1EE37, \"M\", \"\"),\n        (0x1EE38, \"X\"),\n        (0x1EE39, \"M\", \"\"),\n        (0x1EE3A, \"X\"),\n        (0x1EE3B, \"M\", \"\"),\n        (0x1EE3C, \"X\"),\n        (0x1EE42, \"M\", \"\"),\n        (0x1EE43, \"X\"),\n        (0x1EE47, \"M\", \"\"),\n        (0x1EE48, \"X\"),\n        (0x1EE49, \"M\", \"\"),\n        (0x1EE4A, \"X\"),\n        (0x1EE4B, \"M\", \"\"),\n        (0x1EE4C, \"X\"),\n        (0x1EE4D, \"M\", \"\"),\n        (0x1EE4E, \"M\", \"\"),\n    ]\n\n\ndef _seg_73() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1EE4F, \"M\", \"\"),\n        (0x1EE50, \"X\"),\n        (0x1EE51, \"M\", \"\"),\n        (0x1EE52, \"M\", \"\"),\n        (0x1EE53, \"X\"),\n        (0x1EE54, \"M\", \"\"),\n        (0x1EE55, \"X\"),\n        (0x1EE57, \"M\", \"\"),\n        (0x1EE58, \"X\"),\n        (0x1EE59, \"M\", \"\"),\n        (0x1EE5A, \"X\"),\n        (0x1EE5B, \"M\", \"\"),\n        (0x1EE5C, \"X\"),\n        (0x1EE5D, \"M\", \"\"),\n        (0x1EE5E, \"X\"),\n        (0x1EE5F, \"M\", \"\"),\n        (0x1EE60, \"X\"),\n        (0x1EE61, \"M\", \"\"),\n        (0x1EE62, \"M\", \"\"),\n        (0x1EE63, \"X\"),\n        (0x1EE64, \"M\", \"\"),\n        (0x1EE65, \"X\"),\n        (0x1EE67, \"M\", \"\"),\n        (0x1EE68, \"M\", \"\"),\n        (0x1EE69, \"M\", \"\"),\n        (0x1EE6A, \"M\", \"\"),\n        (0x1EE6B, \"X\"),\n        (0x1EE6C, \"M\", \"\"),\n        (0x1EE6D, \"M\", \"\"),\n        (0x1EE6E, \"M\", \"\"),\n        (0x1EE6F, \"M\", \"\"),\n        (0x1EE70, \"M\", \"\"),\n        (0x1EE71, \"M\", \"\"),\n        (0x1EE72, \"M\", \"\"),\n        (0x1EE73, \"X\"),\n        (0x1EE74, \"M\", \"\"),\n        (0x1EE75, \"M\", \"\"),\n        (0x1EE76, \"M\", \"\"),\n        (0x1EE77, \"M\", \"\"),\n        (0x1EE78, \"X\"),\n        (0x1EE79, \"M\", \"\"),\n        (0x1EE7A, \"M\", \"\"),\n        (0x1EE7B, \"M\", \"\"),\n        (0x1EE7C, \"M\", \"\"),\n        (0x1EE7D, \"X\"),\n        (0x1EE7E, \"M\", \"\"),\n        (0x1EE7F, \"X\"),\n        (0x1EE80, \"M\", \"\"),\n        (0x1EE81, \"M\", \"\"),\n        (0x1EE82, \"M\", \"\"),\n        (0x1EE83, \"M\", \"\"),\n        (0x1EE84, \"M\", \"\"),\n        (0x1EE85, \"M\", \"\"),\n        (0x1EE86, \"M\", \"\"),\n        (0x1EE87, \"M\", \"\"),\n        (0x1EE88, \"M\", \"\"),\n        (0x1EE89, \"M\", \"\"),\n        (0x1EE8A, \"X\"),\n        (0x1EE8B, \"M\", \"\"),\n        (0x1EE8C, \"M\", \"\"),\n        (0x1EE8D, \"M\", \"\"),\n        (0x1EE8E, \"M\", \"\"),\n        (0x1EE8F, \"M\", \"\"),\n        (0x1EE90, \"M\", \"\"),\n        (0x1EE91, \"M\", \"\"),\n        (0x1EE92, \"M\", \"\"),\n        (0x1EE93, \"M\", \"\"),\n        (0x1EE94, \"M\", \"\"),\n        (0x1EE95, \"M\", \"\"),\n        (0x1EE96, \"M\", \"\"),\n        (0x1EE97, \"M\", \"\"),\n        (0x1EE98, \"M\", \"\"),\n        (0x1EE99, \"M\", \"\"),\n        (0x1EE9A, \"M\", \"\"),\n        (0x1EE9B, \"M\", \"\"),\n        (0x1EE9C, \"X\"),\n        (0x1EEA1, \"M\", \"\"),\n        (0x1EEA2, \"M\", \"\"),\n        (0x1EEA3, \"M\", \"\"),\n        (0x1EEA4, \"X\"),\n        (0x1EEA5, \"M\", \"\"),\n        (0x1EEA6, \"M\", \"\"),\n        (0x1EEA7, \"M\", \"\"),\n        (0x1EEA8, \"M\", \"\"),\n        (0x1EEA9, \"M\", \"\"),\n        (0x1EEAA, \"X\"),\n        (0x1EEAB, \"M\", \"\"),\n        (0x1EEAC, \"M\", \"\"),\n        (0x1EEAD, \"M\", \"\"),\n        (0x1EEAE, \"M\", \"\"),\n        (0x1EEAF, \"M\", \"\"),\n        (0x1EEB0, \"M\", \"\"),\n        (0x1EEB1, \"M\", \"\"),\n        (0x1EEB2, \"M\", \"\"),\n        (0x1EEB3, \"M\", \"\"),\n        (0x1EEB4, \"M\", \"\"),\n        (0x1EEB5, \"M\", \"\"),\n        (0x1EEB6, \"M\", \"\"),\n        (0x1EEB7, \"M\", \"\"),\n        (0x1EEB8, \"M\", \"\"),\n    ]\n\n\ndef _seg_74() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1EEB9, \"M\", \"\"),\n        (0x1EEBA, \"M\", \"\"),\n        (0x1EEBB, \"M\", \"\"),\n        (0x1EEBC, \"X\"),\n        (0x1EEF0, \"V\"),\n        (0x1EEF2, \"X\"),\n        (0x1F000, \"V\"),\n        (0x1F02C, \"X\"),\n        (0x1F030, \"V\"),\n        (0x1F094, \"X\"),\n        (0x1F0A0, \"V\"),\n        (0x1F0AF, \"X\"),\n        (0x1F0B1, \"V\"),\n        (0x1F0C0, \"X\"),\n        (0x1F0C1, \"V\"),\n        (0x1F0D0, \"X\"),\n        (0x1F0D1, \"V\"),\n        (0x1F0F6, \"X\"),\n        (0x1F101, \"3\", \"0,\"),\n        (0x1F102, \"3\", \"1,\"),\n        (0x1F103, \"3\", \"2,\"),\n        (0x1F104, \"3\", \"3,\"),\n        (0x1F105, \"3\", \"4,\"),\n        (0x1F106, \"3\", \"5,\"),\n        (0x1F107, \"3\", \"6,\"),\n        (0x1F108, \"3\", \"7,\"),\n        (0x1F109, \"3\", \"8,\"),\n        (0x1F10A, \"3\", \"9,\"),\n        (0x1F10B, \"V\"),\n        (0x1F110, \"3\", \"(a)\"),\n        (0x1F111, \"3\", \"(b)\"),\n        (0x1F112, \"3\", \"(c)\"),\n        (0x1F113, \"3\", \"(d)\"),\n        (0x1F114, \"3\", \"(e)\"),\n        (0x1F115, \"3\", \"(f)\"),\n        (0x1F116, \"3\", \"(g)\"),\n        (0x1F117, \"3\", \"(h)\"),\n        (0x1F118, \"3\", \"(i)\"),\n        (0x1F119, \"3\", \"(j)\"),\n        (0x1F11A, \"3\", \"(k)\"),\n        (0x1F11B, \"3\", \"(l)\"),\n        (0x1F11C, \"3\", \"(m)\"),\n        (0x1F11D, \"3\", \"(n)\"),\n        (0x1F11E, \"3\", \"(o)\"),\n        (0x1F11F, \"3\", \"(p)\"),\n        (0x1F120, \"3\", \"(q)\"),\n        (0x1F121, \"3\", \"(r)\"),\n        (0x1F122, \"3\", \"(s)\"),\n        (0x1F123, \"3\", \"(t)\"),\n        (0x1F124, \"3\", \"(u)\"),\n        (0x1F125, \"3\", \"(v)\"),\n        (0x1F126, \"3\", \"(w)\"),\n        (0x1F127, \"3\", \"(x)\"),\n        (0x1F128, \"3\", \"(y)\"),\n        (0x1F129, \"3\", \"(z)\"),\n        (0x1F12A, \"M\", \"s\"),\n        (0x1F12B, \"M\", \"c\"),\n        (0x1F12C, \"M\", \"r\"),\n        (0x1F12D, \"M\", \"cd\"),\n        (0x1F12E, \"M\", \"wz\"),\n        (0x1F12F, \"V\"),\n        (0x1F130, \"M\", \"a\"),\n        (0x1F131, \"M\", \"b\"),\n        (0x1F132, \"M\", \"c\"),\n        (0x1F133, \"M\", \"d\"),\n        (0x1F134, \"M\", \"e\"),\n        (0x1F135, \"M\", \"f\"),\n        (0x1F136, \"M\", \"g\"),\n        (0x1F137, \"M\", \"h\"),\n        (0x1F138, \"M\", \"i\"),\n        (0x1F139, \"M\", \"j\"),\n        (0x1F13A, \"M\", \"k\"),\n        (0x1F13B, \"M\", \"l\"),\n        (0x1F13C, \"M\", \"m\"),\n        (0x1F13D, \"M\", \"n\"),\n        (0x1F13E, \"M\", \"o\"),\n        (0x1F13F, \"M\", \"p\"),\n        (0x1F140, \"M\", \"q\"),\n        (0x1F141, \"M\", \"r\"),\n        (0x1F142, \"M\", \"s\"),\n        (0x1F143, \"M\", \"t\"),\n        (0x1F144, \"M\", \"u\"),\n        (0x1F145, \"M\", \"v\"),\n        (0x1F146, \"M\", \"w\"),\n        (0x1F147, \"M\", \"x\"),\n        (0x1F148, \"M\", \"y\"),\n        (0x1F149, \"M\", \"z\"),\n        (0x1F14A, \"M\", \"hv\"),\n        (0x1F14B, \"M\", \"mv\"),\n        (0x1F14C, \"M\", \"sd\"),\n        (0x1F14D, \"M\", \"ss\"),\n        (0x1F14E, \"M\", \"ppv\"),\n        (0x1F14F, \"M\", \"wc\"),\n        (0x1F150, \"V\"),\n        (0x1F16A, \"M\", \"mc\"),\n        (0x1F16B, \"M\", \"md\"),\n        (0x1F16C, \"M\", \"mr\"),\n        (0x1F16D, \"V\"),\n        (0x1F190, \"M\", \"dj\"),\n        (0x1F191, \"V\"),\n    ]\n\n\ndef _seg_75() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1F1AE, \"X\"),\n        (0x1F1E6, \"V\"),\n        (0x1F200, \"M\", \"\"),\n        (0x1F201, \"M\", \"\"),\n        (0x1F202, \"M\", \"\"),\n        (0x1F203, \"X\"),\n        (0x1F210, \"M\", \"\"),\n        (0x1F211, \"M\", \"\"),\n        (0x1F212, \"M\", \"\"),\n        (0x1F213, \"M\", \"\"),\n        (0x1F214, \"M\", \"\"),\n        (0x1F215, \"M\", \"\"),\n        (0x1F216, \"M\", \"\"),\n        (0x1F217, \"M\", \"\"),\n        (0x1F218, \"M\", \"\"),\n        (0x1F219, \"M\", \"\"),\n        (0x1F21A, \"M\", \"\"),\n        (0x1F21B, \"M\", \"\"),\n        (0x1F21C, \"M\", \"\"),\n        (0x1F21D, \"M\", \"\"),\n        (0x1F21E, \"M\", \"\"),\n        (0x1F21F, \"M\", \"\"),\n        (0x1F220, \"M\", \"\"),\n        (0x1F221, \"M\", \"\"),\n        (0x1F222, \"M\", \"\"),\n        (0x1F223, \"M\", \"\"),\n        (0x1F224, \"M\", \"\"),\n        (0x1F225, \"M\", \"\"),\n        (0x1F226, \"M\", \"\"),\n        (0x1F227, \"M\", \"\"),\n        (0x1F228, \"M\", \"\"),\n        (0x1F229, \"M\", \"\"),\n        (0x1F22A, \"M\", \"\"),\n        (0x1F22B, \"M\", \"\"),\n        (0x1F22C, \"M\", \"\"),\n        (0x1F22D, \"M\", \"\"),\n        (0x1F22E, \"M\", \"\"),\n        (0x1F22F, \"M\", \"\"),\n        (0x1F230, \"M\", \"\"),\n        (0x1F231, \"M\", \"\"),\n        (0x1F232, \"M\", \"\"),\n        (0x1F233, \"M\", \"\"),\n        (0x1F234, \"M\", \"\"),\n        (0x1F235, \"M\", \"\"),\n        (0x1F236, \"M\", \"\"),\n        (0x1F237, \"M\", \"\"),\n        (0x1F238, \"M\", \"\"),\n        (0x1F239, \"M\", \"\"),\n        (0x1F23A, \"M\", \"\"),\n        (0x1F23B, \"M\", \"\"),\n        (0x1F23C, \"X\"),\n        (0x1F240, \"M\", \"\"),\n        (0x1F241, \"M\", \"\"),\n        (0x1F242, \"M\", \"\"),\n        (0x1F243, \"M\", \"\"),\n        (0x1F244, \"M\", \"\"),\n        (0x1F245, \"M\", \"\"),\n        (0x1F246, \"M\", \"\"),\n        (0x1F247, \"M\", \"\"),\n        (0x1F248, \"M\", \"\"),\n        (0x1F249, \"X\"),\n        (0x1F250, \"M\", \"\"),\n        (0x1F251, \"M\", \"\"),\n        (0x1F252, \"X\"),\n        (0x1F260, \"V\"),\n        (0x1F266, \"X\"),\n        (0x1F300, \"V\"),\n        (0x1F6D8, \"X\"),\n        (0x1F6DC, \"V\"),\n        (0x1F6ED, \"X\"),\n        (0x1F6F0, \"V\"),\n        (0x1F6FD, \"X\"),\n        (0x1F700, \"V\"),\n        (0x1F777, \"X\"),\n        (0x1F77B, \"V\"),\n        (0x1F7DA, \"X\"),\n        (0x1F7E0, \"V\"),\n        (0x1F7EC, \"X\"),\n        (0x1F7F0, \"V\"),\n        (0x1F7F1, \"X\"),\n        (0x1F800, \"V\"),\n        (0x1F80C, \"X\"),\n        (0x1F810, \"V\"),\n        (0x1F848, \"X\"),\n        (0x1F850, \"V\"),\n        (0x1F85A, \"X\"),\n        (0x1F860, \"V\"),\n        (0x1F888, \"X\"),\n        (0x1F890, \"V\"),\n        (0x1F8AE, \"X\"),\n        (0x1F8B0, \"V\"),\n        (0x1F8B2, \"X\"),\n        (0x1F900, \"V\"),\n        (0x1FA54, \"X\"),\n        (0x1FA60, \"V\"),\n        (0x1FA6E, \"X\"),\n        (0x1FA70, \"V\"),\n        (0x1FA7D, \"X\"),\n        (0x1FA80, \"V\"),\n        (0x1FA89, \"X\"),\n    ]\n\n\ndef _seg_76() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x1FA90, \"V\"),\n        (0x1FABE, \"X\"),\n        (0x1FABF, \"V\"),\n        (0x1FAC6, \"X\"),\n        (0x1FACE, \"V\"),\n        (0x1FADC, \"X\"),\n        (0x1FAE0, \"V\"),\n        (0x1FAE9, \"X\"),\n        (0x1FAF0, \"V\"),\n        (0x1FAF9, \"X\"),\n        (0x1FB00, \"V\"),\n        (0x1FB93, \"X\"),\n        (0x1FB94, \"V\"),\n        (0x1FBCB, \"X\"),\n        (0x1FBF0, \"M\", \"0\"),\n        (0x1FBF1, \"M\", \"1\"),\n        (0x1FBF2, \"M\", \"2\"),\n        (0x1FBF3, \"M\", \"3\"),\n        (0x1FBF4, \"M\", \"4\"),\n        (0x1FBF5, \"M\", \"5\"),\n        (0x1FBF6, \"M\", \"6\"),\n        (0x1FBF7, \"M\", \"7\"),\n        (0x1FBF8, \"M\", \"8\"),\n        (0x1FBF9, \"M\", \"9\"),\n        (0x1FBFA, \"X\"),\n        (0x20000, \"V\"),\n        (0x2A6E0, \"X\"),\n        (0x2A700, \"V\"),\n        (0x2B73A, \"X\"),\n        (0x2B740, \"V\"),\n        (0x2B81E, \"X\"),\n        (0x2B820, \"V\"),\n        (0x2CEA2, \"X\"),\n        (0x2CEB0, \"V\"),\n        (0x2EBE1, \"X\"),\n        (0x2EBF0, \"V\"),\n        (0x2EE5E, \"X\"),\n        (0x2F800, \"M\", \"\"),\n        (0x2F801, \"M\", \"\"),\n        (0x2F802, \"M\", \"\"),\n        (0x2F803, \"M\", \"\"),\n        (0x2F804, \"M\", \"\"),\n        (0x2F805, \"M\", \"\"),\n        (0x2F806, \"M\", \"\"),\n        (0x2F807, \"M\", \"\"),\n        (0x2F808, \"M\", \"\"),\n        (0x2F809, \"M\", \"\"),\n        (0x2F80A, \"M\", \"\"),\n        (0x2F80B, \"M\", \"\"),\n        (0x2F80C, \"M\", \"\"),\n        (0x2F80D, \"M\", \"\"),\n        (0x2F80E, \"M\", \"\"),\n        (0x2F80F, \"M\", \"\"),\n        (0x2F810, \"M\", \"\"),\n        (0x2F811, \"M\", \"\"),\n        (0x2F812, \"M\", \"\"),\n        (0x2F813, \"M\", \"\"),\n        (0x2F814, \"M\", \"\"),\n        (0x2F815, \"M\", \"\"),\n        (0x2F816, \"M\", \"\"),\n        (0x2F817, \"M\", \"\"),\n        (0x2F818, \"M\", \"\"),\n        (0x2F819, \"M\", \"\"),\n        (0x2F81A, \"M\", \"\"),\n        (0x2F81B, \"M\", \"\"),\n        (0x2F81C, \"M\", \"\"),\n        (0x2F81D, \"M\", \"\"),\n        (0x2F81E, \"M\", \"\"),\n        (0x2F81F, \"M\", \"\"),\n        (0x2F820, \"M\", \"\"),\n        (0x2F821, \"M\", \"\"),\n        (0x2F822, \"M\", \"\"),\n        (0x2F823, \"M\", \"\"),\n        (0x2F824, \"M\", \"\"),\n        (0x2F825, \"M\", \"\"),\n        (0x2F826, \"M\", \"\"),\n        (0x2F827, \"M\", \"\"),\n        (0x2F828, \"M\", \"\"),\n        (0x2F829, \"M\", \"\"),\n        (0x2F82A, \"M\", \"\"),\n        (0x2F82B, \"M\", \"\"),\n        (0x2F82C, \"M\", \"\"),\n        (0x2F82D, \"M\", \"\"),\n        (0x2F82E, \"M\", \"\"),\n        (0x2F82F, \"M\", \"\"),\n        (0x2F830, \"M\", \"\"),\n        (0x2F831, \"M\", \"\"),\n        (0x2F834, \"M\", \"\"),\n        (0x2F835, \"M\", \"\"),\n        (0x2F836, \"M\", \"\"),\n        (0x2F837, \"M\", \"\"),\n        (0x2F838, \"M\", \"\"),\n        (0x2F839, \"M\", \"\"),\n        (0x2F83A, \"M\", \"\"),\n        (0x2F83B, \"M\", \"\"),\n        (0x2F83C, \"M\", \"\"),\n        (0x2F83D, \"M\", \"\"),\n        (0x2F83E, \"M\", \"\"),\n        (0x2F83F, \"M\", \"\"),\n        (0x2F840, \"M\", \"\"),\n    ]\n\n\ndef _seg_77() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x2F841, \"M\", \"\"),\n        (0x2F842, \"M\", \"\"),\n        (0x2F843, \"M\", \"\"),\n        (0x2F844, \"M\", \"\"),\n        (0x2F845, \"M\", \"\"),\n        (0x2F847, \"M\", \"\"),\n        (0x2F848, \"M\", \"\"),\n        (0x2F849, \"M\", \"\"),\n        (0x2F84A, \"M\", \"\"),\n        (0x2F84B, \"M\", \"\"),\n        (0x2F84C, \"M\", \"\"),\n        (0x2F84D, \"M\", \"\"),\n        (0x2F84E, \"M\", \"\"),\n        (0x2F84F, \"M\", \"\"),\n        (0x2F850, \"M\", \"\"),\n        (0x2F851, \"M\", \"\"),\n        (0x2F852, \"M\", \"\"),\n        (0x2F853, \"M\", \"\"),\n        (0x2F854, \"M\", \"\"),\n        (0x2F855, \"M\", \"\"),\n        (0x2F856, \"M\", \"\"),\n        (0x2F857, \"M\", \"\"),\n        (0x2F858, \"M\", \"\"),\n        (0x2F859, \"M\", \"\"),\n        (0x2F85A, \"M\", \"\"),\n        (0x2F85B, \"M\", \"\"),\n        (0x2F85C, \"M\", \"\"),\n        (0x2F85D, \"M\", \"\"),\n        (0x2F85E, \"M\", \"\"),\n        (0x2F85F, \"M\", \"\"),\n        (0x2F860, \"M\", \"\"),\n        (0x2F861, \"M\", \"\"),\n        (0x2F862, \"M\", \"\"),\n        (0x2F863, \"M\", \"\"),\n        (0x2F864, \"M\", \"\"),\n        (0x2F865, \"M\", \"\"),\n        (0x2F866, \"M\", \"\"),\n        (0x2F867, \"M\", \"\"),\n        (0x2F868, \"X\"),\n        (0x2F869, \"M\", \"\"),\n        (0x2F86A, \"M\", \"\"),\n        (0x2F86C, \"M\", \"\"),\n        (0x2F86D, \"M\", \"\"),\n        (0x2F86E, \"M\", \"\"),\n        (0x2F86F, \"M\", \"\"),\n        (0x2F870, \"M\", \"\"),\n        (0x2F871, \"M\", \"\"),\n        (0x2F872, \"M\", \"\"),\n        (0x2F873, \"M\", \"\"),\n        (0x2F874, \"X\"),\n        (0x2F875, \"M\", \"\"),\n        (0x2F876, \"M\", \"\"),\n        (0x2F877, \"M\", \"\"),\n        (0x2F878, \"M\", \"\"),\n        (0x2F879, \"M\", \"\"),\n        (0x2F87A, \"M\", \"\"),\n        (0x2F87B, \"M\", \"\"),\n        (0x2F87C, \"M\", \"\"),\n        (0x2F87D, \"M\", \"\"),\n        (0x2F87E, \"M\", \"\"),\n        (0x2F87F, \"M\", \"\"),\n        (0x2F880, \"M\", \"\"),\n        (0x2F881, \"M\", \"\"),\n        (0x2F882, \"M\", \"\"),\n        (0x2F883, \"M\", \"\"),\n        (0x2F884, \"M\", \"\"),\n        (0x2F885, \"M\", \"\"),\n        (0x2F886, \"M\", \"\"),\n        (0x2F887, \"M\", \"\"),\n        (0x2F888, \"M\", \"\"),\n        (0x2F889, \"M\", \"\"),\n        (0x2F88A, \"M\", \"\"),\n        (0x2F88B, \"M\", \"\"),\n        (0x2F88C, \"M\", \"\"),\n        (0x2F88D, \"M\", \"\"),\n        (0x2F88E, \"M\", \"\"),\n        (0x2F88F, \"M\", \"\"),\n        (0x2F890, \"M\", \"\"),\n        (0x2F891, \"M\", \"\"),\n        (0x2F893, \"M\", \"\"),\n        (0x2F894, \"M\", \"\"),\n        (0x2F896, \"M\", \"\"),\n        (0x2F897, \"M\", \"\"),\n        (0x2F898, \"M\", \"\"),\n        (0x2F899, \"M\", \"\"),\n        (0x2F89A, \"M\", \"\"),\n        (0x2F89B, \"M\", \"\"),\n        (0x2F89C, \"M\", \"\"),\n        (0x2F89D, \"M\", \"\"),\n        (0x2F89E, \"M\", \"\"),\n        (0x2F89F, \"M\", \"\"),\n        (0x2F8A0, \"M\", \"\"),\n        (0x2F8A1, \"M\", \"\"),\n        (0x2F8A2, \"M\", \"\"),\n        (0x2F8A3, \"M\", \"\"),\n        (0x2F8A4, \"M\", \"\"),\n        (0x2F8A5, \"M\", \"\"),\n        (0x2F8A6, \"M\", \"\"),\n        (0x2F8A7, \"M\", \"\"),\n        (0x2F8A8, \"M\", \"\"),\n    ]\n\n\ndef _seg_78() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x2F8A9, \"M\", \"\"),\n        (0x2F8AA, \"M\", \"\"),\n        (0x2F8AB, \"M\", \"\"),\n        (0x2F8AC, \"M\", \"\"),\n        (0x2F8AD, \"M\", \"\"),\n        (0x2F8AE, \"M\", \"\"),\n        (0x2F8AF, \"M\", \"\"),\n        (0x2F8B0, \"M\", \"\"),\n        (0x2F8B1, \"M\", \"\"),\n        (0x2F8B2, \"M\", \"\"),\n        (0x2F8B3, \"M\", \"\"),\n        (0x2F8B4, \"M\", \"\"),\n        (0x2F8B5, \"M\", \"\"),\n        (0x2F8B6, \"M\", \"\"),\n        (0x2F8B7, \"M\", \"\"),\n        (0x2F8B8, \"M\", \"\"),\n        (0x2F8B9, \"M\", \"\"),\n        (0x2F8BA, \"M\", \"\"),\n        (0x2F8BB, \"M\", \"\"),\n        (0x2F8BC, \"M\", \"\"),\n        (0x2F8BD, \"M\", \"\"),\n        (0x2F8BE, \"M\", \"\"),\n        (0x2F8BF, \"M\", \"\"),\n        (0x2F8C0, \"M\", \"\"),\n        (0x2F8C1, \"M\", \"\"),\n        (0x2F8C2, \"M\", \"\"),\n        (0x2F8C3, \"M\", \"\"),\n        (0x2F8C4, \"M\", \"\"),\n        (0x2F8C5, \"M\", \"\"),\n        (0x2F8C6, \"M\", \"\"),\n        (0x2F8C7, \"M\", \"\"),\n        (0x2F8C8, \"M\", \"\"),\n        (0x2F8C9, \"M\", \"\"),\n        (0x2F8CA, \"M\", \"\"),\n        (0x2F8CB, \"M\", \"\"),\n        (0x2F8CC, \"M\", \"\"),\n        (0x2F8CD, \"M\", \"\"),\n        (0x2F8CE, \"M\", \"\"),\n        (0x2F8CF, \"M\", \"\"),\n        (0x2F8D0, \"M\", \"\"),\n        (0x2F8D1, \"M\", \"\"),\n        (0x2F8D2, \"M\", \"\"),\n        (0x2F8D3, \"M\", \"\"),\n        (0x2F8D4, \"M\", \"\"),\n        (0x2F8D5, \"M\", \"\"),\n        (0x2F8D6, \"M\", \"\"),\n        (0x2F8D7, \"M\", \"\"),\n        (0x2F8D8, \"M\", \"\"),\n        (0x2F8D9, \"M\", \"\"),\n        (0x2F8DA, \"M\", \"\"),\n        (0x2F8DB, \"M\", \"\"),\n        (0x2F8DC, \"M\", \"\"),\n        (0x2F8DD, \"M\", \"\"),\n        (0x2F8DE, \"M\", \"\"),\n        (0x2F8DF, \"M\", \"\"),\n        (0x2F8E0, \"M\", \"\"),\n        (0x2F8E1, \"M\", \"\"),\n        (0x2F8E2, \"M\", \"\"),\n        (0x2F8E3, \"M\", \"\"),\n        (0x2F8E4, \"M\", \"\"),\n        (0x2F8E5, \"M\", \"\"),\n        (0x2F8E6, \"M\", \"\"),\n        (0x2F8E7, \"M\", \"\"),\n        (0x2F8E8, \"M\", \"\"),\n        (0x2F8E9, \"M\", \"\"),\n        (0x2F8EA, \"M\", \"\"),\n        (0x2F8EB, \"M\", \"\"),\n        (0x2F8EC, \"M\", \"\"),\n        (0x2F8ED, \"M\", \"\"),\n        (0x2F8EE, \"M\", \"\"),\n        (0x2F8EF, \"M\", \"\"),\n        (0x2F8F0, \"M\", \"\"),\n        (0x2F8F1, \"M\", \"\"),\n        (0x2F8F2, \"M\", \"\"),\n        (0x2F8F3, \"M\", \"\"),\n        (0x2F8F4, \"M\", \"\"),\n        (0x2F8F5, \"M\", \"\"),\n        (0x2F8F6, \"M\", \"\"),\n        (0x2F8F7, \"M\", \"\"),\n        (0x2F8F8, \"M\", \"\"),\n        (0x2F8F9, \"M\", \"\"),\n        (0x2F8FA, \"M\", \"\"),\n        (0x2F8FB, \"M\", \"\"),\n        (0x2F8FC, \"M\", \"\"),\n        (0x2F8FD, \"M\", \"\"),\n        (0x2F8FE, \"M\", \"\"),\n        (0x2F8FF, \"M\", \"\"),\n        (0x2F900, \"M\", \"\"),\n        (0x2F901, \"M\", \"\"),\n        (0x2F902, \"M\", \"\"),\n        (0x2F903, \"M\", \"\"),\n        (0x2F904, \"M\", \"\"),\n        (0x2F905, \"M\", \"\"),\n        (0x2F906, \"M\", \"\"),\n        (0x2F907, \"M\", \"\"),\n        (0x2F908, \"M\", \"\"),\n        (0x2F909, \"M\", \"\"),\n        (0x2F90A, \"M\", \"\"),\n        (0x2F90B, \"M\", \"\"),\n        (0x2F90C, \"M\", \"\"),\n    ]\n\n\ndef _seg_79() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x2F90D, \"M\", \"\"),\n        (0x2F90E, \"M\", \"\"),\n        (0x2F90F, \"M\", \"\"),\n        (0x2F910, \"M\", \"\"),\n        (0x2F911, \"M\", \"\"),\n        (0x2F912, \"M\", \"\"),\n        (0x2F913, \"M\", \"\"),\n        (0x2F914, \"M\", \"\"),\n        (0x2F915, \"M\", \"\"),\n        (0x2F916, \"M\", \"\"),\n        (0x2F917, \"M\", \"\"),\n        (0x2F918, \"M\", \"\"),\n        (0x2F919, \"M\", \"\"),\n        (0x2F91A, \"M\", \"\"),\n        (0x2F91B, \"M\", \"\"),\n        (0x2F91C, \"M\", \"\"),\n        (0x2F91D, \"M\", \"\"),\n        (0x2F91E, \"M\", \"\"),\n        (0x2F91F, \"X\"),\n        (0x2F920, \"M\", \"\"),\n        (0x2F921, \"M\", \"\"),\n        (0x2F922, \"M\", \"\"),\n        (0x2F923, \"M\", \"\"),\n        (0x2F924, \"M\", \"\"),\n        (0x2F925, \"M\", \"\"),\n        (0x2F926, \"M\", \"\"),\n        (0x2F927, \"M\", \"\"),\n        (0x2F928, \"M\", \"\"),\n        (0x2F929, \"M\", \"\"),\n        (0x2F92A, \"M\", \"\"),\n        (0x2F92B, \"M\", \"\"),\n        (0x2F92C, \"M\", \"\"),\n        (0x2F92E, \"M\", \"\"),\n        (0x2F92F, \"M\", \"\"),\n        (0x2F930, \"M\", \"\"),\n        (0x2F931, \"M\", \"\"),\n        (0x2F932, \"M\", \"\"),\n        (0x2F933, \"M\", \"\"),\n        (0x2F934, \"M\", \"\"),\n        (0x2F935, \"M\", \"\"),\n        (0x2F936, \"M\", \"\"),\n        (0x2F937, \"M\", \"\"),\n        (0x2F938, \"M\", \"\"),\n        (0x2F939, \"M\", \"\"),\n        (0x2F93A, \"M\", \"\"),\n        (0x2F93B, \"M\", \"\"),\n        (0x2F93C, \"M\", \"\"),\n        (0x2F93D, \"M\", \"\"),\n        (0x2F93E, \"M\", \"\"),\n        (0x2F93F, \"M\", \"\"),\n        (0x2F940, \"M\", \"\"),\n        (0x2F941, \"M\", \"\"),\n        (0x2F942, \"M\", \"\"),\n        (0x2F943, \"M\", \"\"),\n        (0x2F944, \"M\", \"\"),\n        (0x2F945, \"M\", \"\"),\n        (0x2F946, \"M\", \"\"),\n        (0x2F948, \"M\", \"\"),\n        (0x2F949, \"M\", \"\"),\n        (0x2F94A, \"M\", \"\"),\n        (0x2F94B, \"M\", \"\"),\n        (0x2F94C, \"M\", \"\"),\n        (0x2F94D, \"M\", \"\"),\n        (0x2F94E, \"M\", \"\"),\n        (0x2F94F, \"M\", \"\"),\n        (0x2F950, \"M\", \"\"),\n        (0x2F951, \"M\", \"\"),\n        (0x2F952, \"M\", \"\"),\n        (0x2F953, \"M\", \"\"),\n        (0x2F954, \"M\", \"\"),\n        (0x2F955, \"M\", \"\"),\n        (0x2F956, \"M\", \"\"),\n        (0x2F957, \"M\", \"\"),\n        (0x2F958, \"M\", \"\"),\n        (0x2F959, \"M\", \"\"),\n        (0x2F95A, \"M\", \"\"),\n        (0x2F95B, \"M\", \"\"),\n        (0x2F95C, \"M\", \"\"),\n        (0x2F95D, \"M\", \"\"),\n        (0x2F95F, \"X\"),\n        (0x2F960, \"M\", \"\"),\n        (0x2F961, \"M\", \"\"),\n        (0x2F962, \"M\", \"\"),\n        (0x2F963, \"M\", \"\"),\n        (0x2F964, \"M\", \"\"),\n        (0x2F965, \"M\", \"\"),\n        (0x2F966, \"M\", \"\"),\n        (0x2F967, \"M\", \"\"),\n        (0x2F968, \"M\", \"\"),\n        (0x2F969, \"M\", \"\"),\n        (0x2F96A, \"M\", \"\"),\n        (0x2F96B, \"M\", \"\"),\n        (0x2F96C, \"M\", \"\"),\n        (0x2F96D, \"M\", \"\"),\n        (0x2F96E, \"M\", \"\"),\n        (0x2F96F, \"M\", \"\"),\n        (0x2F970, \"M\", \"\"),\n        (0x2F971, \"M\", \"\"),\n        (0x2F972, \"M\", \"\"),\n        (0x2F973, \"M\", \"\"),\n    ]\n\n\ndef _seg_80() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x2F974, \"M\", \"\"),\n        (0x2F975, \"M\", \"\"),\n        (0x2F976, \"M\", \"\"),\n        (0x2F977, \"M\", \"\"),\n        (0x2F978, \"M\", \"\"),\n        (0x2F979, \"M\", \"\"),\n        (0x2F97A, \"M\", \"\"),\n        (0x2F97B, \"M\", \"\"),\n        (0x2F97C, \"M\", \"\"),\n        (0x2F97D, \"M\", \"\"),\n        (0x2F97E, \"M\", \"\"),\n        (0x2F97F, \"M\", \"\"),\n        (0x2F980, \"M\", \"\"),\n        (0x2F981, \"M\", \"\"),\n        (0x2F982, \"M\", \"\"),\n        (0x2F983, \"M\", \"\"),\n        (0x2F984, \"M\", \"\"),\n        (0x2F985, \"M\", \"\"),\n        (0x2F986, \"M\", \"\"),\n        (0x2F987, \"M\", \"\"),\n        (0x2F988, \"M\", \"\"),\n        (0x2F989, \"M\", \"\"),\n        (0x2F98A, \"M\", \"\"),\n        (0x2F98B, \"M\", \"\"),\n        (0x2F98C, \"M\", \"\"),\n        (0x2F98D, \"M\", \"\"),\n        (0x2F98E, \"M\", \"\"),\n        (0x2F98F, \"M\", \"\"),\n        (0x2F990, \"M\", \"\"),\n        (0x2F991, \"M\", \"\"),\n        (0x2F992, \"M\", \"\"),\n        (0x2F993, \"M\", \"\"),\n        (0x2F994, \"M\", \"\"),\n        (0x2F995, \"M\", \"\"),\n        (0x2F996, \"M\", \"\"),\n        (0x2F997, \"M\", \"\"),\n        (0x2F998, \"M\", \"\"),\n        (0x2F999, \"M\", \"\"),\n        (0x2F99A, \"M\", \"\"),\n        (0x2F99B, \"M\", \"\"),\n        (0x2F99C, \"M\", \"\"),\n        (0x2F99D, \"M\", \"\"),\n        (0x2F99E, \"M\", \"\"),\n        (0x2F99F, \"M\", \"\"),\n        (0x2F9A0, \"M\", \"\"),\n        (0x2F9A1, \"M\", \"\"),\n        (0x2F9A2, \"M\", \"\"),\n        (0x2F9A3, \"M\", \"\"),\n        (0x2F9A4, \"M\", \"\"),\n        (0x2F9A5, \"M\", \"\"),\n        (0x2F9A6, \"M\", \"\"),\n        (0x2F9A7, \"M\", \"\"),\n        (0x2F9A8, \"M\", \"\"),\n        (0x2F9A9, \"M\", \"\"),\n        (0x2F9AA, \"M\", \"\"),\n        (0x2F9AB, \"M\", \"\"),\n        (0x2F9AC, \"M\", \"\"),\n        (0x2F9AD, \"M\", \"\"),\n        (0x2F9AE, \"M\", \"\"),\n        (0x2F9AF, \"M\", \"\"),\n        (0x2F9B0, \"M\", \"\"),\n        (0x2F9B1, \"M\", \"\"),\n        (0x2F9B2, \"M\", \"\"),\n        (0x2F9B3, \"M\", \"\"),\n        (0x2F9B4, \"M\", \"\"),\n        (0x2F9B5, \"M\", \"\"),\n        (0x2F9B6, \"M\", \"\"),\n        (0x2F9B7, \"M\", \"\"),\n        (0x2F9B8, \"M\", \"\"),\n        (0x2F9B9, \"M\", \"\"),\n        (0x2F9BA, \"M\", \"\"),\n        (0x2F9BB, \"M\", \"\"),\n        (0x2F9BC, \"M\", \"\"),\n        (0x2F9BD, \"M\", \"\"),\n        (0x2F9BE, \"M\", \"\"),\n        (0x2F9BF, \"X\"),\n        (0x2F9C0, \"M\", \"\"),\n        (0x2F9C1, \"M\", \"\"),\n        (0x2F9C2, \"M\", \"\"),\n        (0x2F9C3, \"M\", \"\"),\n        (0x2F9C4, \"M\", \"\"),\n        (0x2F9C5, \"M\", \"\"),\n        (0x2F9C6, \"M\", \"\"),\n        (0x2F9C7, \"M\", \"\"),\n        (0x2F9C8, \"M\", \"\"),\n        (0x2F9C9, \"M\", \"\"),\n        (0x2F9CA, \"M\", \"\"),\n        (0x2F9CB, \"M\", \"\"),\n        (0x2F9CC, \"M\", \"\"),\n        (0x2F9CD, \"M\", \"\"),\n        (0x2F9CE, \"M\", \"\"),\n        (0x2F9CF, \"M\", \"\"),\n        (0x2F9D0, \"M\", \"\"),\n        (0x2F9D1, \"M\", \"\"),\n        (0x2F9D2, \"M\", \"\"),\n        (0x2F9D3, \"M\", \"\"),\n        (0x2F9D4, \"M\", \"\"),\n        (0x2F9D5, \"M\", \"\"),\n        (0x2F9D6, \"M\", \"\"),\n        (0x2F9D7, \"M\", \"\"),\n    ]\n\n\ndef _seg_81() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:\n    return [\n        (0x2F9D8, \"M\", \"\"),\n        (0x2F9D9, \"M\", \"\"),\n        (0x2F9DA, \"M\", \"\"),\n        (0x2F9DB, \"M\", \"\"),\n        (0x2F9DC, \"M\", \"\"),\n        (0x2F9DD, \"M\", \"\"),\n        (0x2F9DE, \"M\", \"\"),\n        (0x2F9DF, \"M\", \"\"),\n        (0x2F9E0, \"M\", \"\"),\n        (0x2F9E1, \"M\", \"\"),\n        (0x2F9E2, \"M\", \"\"),\n        (0x2F9E3, \"M\", \"\"),\n        (0x2F9E4, \"M\", \"\"),\n        (0x2F9E5, \"M\", \"\"),\n        (0x2F9E6, \"M\", \"\"),\n        (0x2F9E7, \"M\", \"\"),\n        (0x2F9E8, \"M\", \"\"),\n        (0x2F9E9, \"M\", \"\"),\n        (0x2F9EA, \"M\", \"\"),\n        (0x2F9EB, \"M\", \"\"),\n        (0x2F9EC, \"M\", \"\"),\n        (0x2F9ED, \"M\", \"\"),\n        (0x2F9EE, \"M\", \"\"),\n        (0x2F9EF, \"M\", \"\"),\n        (0x2F9F0, \"M\", \"\"),\n        (0x2F9F1, \"M\", \"\"),\n        (0x2F9F2, \"M\", \"\"),\n        (0x2F9F3, \"M\", \"\"),\n        (0x2F9F4, \"M\", \"\"),\n        (0x2F9F5, \"M\", \"\"),\n        (0x2F9F6, \"M\", \"\"),\n        (0x2F9F7, \"M\", \"\"),\n        (0x2F9F8, \"M\", \"\"),\n        (0x2F9F9, \"M\", \"\"),\n        (0x2F9FA, \"M\", \"\"),\n        (0x2F9FB, \"M\", \"\"),\n        (0x2F9FC, \"M\", \"\"),\n        (0x2F9FD, \"M\", \"\"),\n        (0x2F9FE, \"M\", \"\"),\n        (0x2FA00, \"M\", \"\"),\n        (0x2FA01, \"M\", \"\"),\n        (0x2FA02, \"M\", \"\"),\n        (0x2FA03, \"M\", \"\"),\n        (0x2FA04, \"M\", \"\"),\n        (0x2FA05, \"M\", \"\"),\n        (0x2FA06, \"M\", \"\"),\n        (0x2FA07, \"M\", \"\"),\n        (0x2FA08, \"M\", \"\"),\n        (0x2FA09, \"M\", \"\"),\n        (0x2FA0A, \"M\", \"\"),\n        (0x2FA0B, \"M\", \"\"),\n        (0x2FA0C, \"M\", \"\"),\n        (0x2FA0D, \"M\", \"\"),\n        (0x2FA0E, \"M\", \"\"),\n        (0x2FA0F, \"M\", \"\"),\n        (0x2FA10, \"M\", \"\"),\n        (0x2FA11, \"M\", \"\"),\n        (0x2FA12, \"M\", \"\"),\n        (0x2FA13, \"M\", \"\"),\n        (0x2FA14, \"M\", \"\"),\n        (0x2FA15, \"M\", \"\"),\n        (0x2FA16, \"M\", \"\"),\n        (0x2FA17, \"M\", \"\"),\n        (0x2FA18, \"M\", \"\"),\n        (0x2FA19, \"M\", \"\"),\n        (0x2FA1A, \"M\", \"\"),\n        (0x2FA1B, \"M\", \"\"),\n        (0x2FA1C, \"M\", \"\"),\n        (0x2FA1D, \"M\", \"\"),\n        (0x2FA1E, \"X\"),\n        (0x30000, \"V\"),\n        (0x3134B, \"X\"),\n        (0x31350, \"V\"),\n        (0x323B0, \"X\"),\n        (0xE0100, \"I\"),\n        (0xE01F0, \"X\"),\n    ]\n\n\nuts46data = tuple(\n    _seg_0()\n    + _seg_1()\n    + _seg_2()\n    + _seg_3()\n    + _seg_4()\n    + _seg_5()\n    + _seg_6()\n    + _seg_7()\n    + _seg_8()\n    + _seg_9()\n    + _seg_10()\n    + _seg_11()\n    + _seg_12()\n    + _seg_13()\n    + _seg_14()\n    + _seg_15()\n    + _seg_16()\n    + _seg_17()\n    + _seg_18()\n    + _seg_19()\n    + _seg_20()\n    + _seg_21()\n    + _seg_22()\n    + _seg_23()\n    + _seg_24()\n    + _seg_25()\n    + _seg_26()\n    + _seg_27()\n    + _seg_28()\n    + _seg_29()\n    + _seg_30()\n    + _seg_31()\n    + _seg_32()\n    + _seg_33()\n    + _seg_34()\n    + _seg_35()\n    + _seg_36()\n    + _seg_37()\n    + _seg_38()\n    + _seg_39()\n    + _seg_40()\n    + _seg_41()\n    + _seg_42()\n    + _seg_43()\n    + _seg_44()\n    + _seg_45()\n    + _seg_46()\n    + _seg_47()\n    + _seg_48()\n    + _seg_49()\n    + _seg_50()\n    + _seg_51()\n    + _seg_52()\n    + _seg_53()\n    + _seg_54()\n    + _seg_55()\n    + _seg_56()\n    + _seg_57()\n    + _seg_58()\n    + _seg_59()\n    + _seg_60()\n    + _seg_61()\n    + _seg_62()\n    + _seg_63()\n    + _seg_64()\n    + _seg_65()\n    + _seg_66()\n    + _seg_67()\n    + _seg_68()\n    + _seg_69()\n    + _seg_70()\n    + _seg_71()\n    + _seg_72()\n    + _seg_73()\n    + _seg_74()\n    + _seg_75()\n    + _seg_76()\n    + _seg_77()\n    + _seg_78()\n    + _seg_79()\n    + _seg_80()\n    + _seg_81()\n)  # type: Tuple[Union[Tuple[int, str], Tuple[int, str, str]], ...]\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/msgpack/__init__.py","size":1109,"sha1":"82af82668d0f8323133bbcf1254d46fea0aad575","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# ruff: noqa: F401\nimport os\n\nfrom .exceptions import *  # noqa: F403\nfrom .ext import ExtType, Timestamp\n\nversion = (1, 1, 0)\n__version__ = \"1.1.0\"\n\n\nif os.environ.get(\"MSGPACK_PUREPYTHON\"):\n    from .fallback import Packer, Unpacker, unpackb\nelse:\n    try:\n        from ._cmsgpack import Packer, Unpacker, unpackb\n    except ImportError:\n        from .fallback import Packer, Unpacker, unpackb\n\n\ndef pack(o, stream, **kwargs):\n    \"\"\"\n    Pack object `o` and write it to `stream`\n\n    See :class:`Packer` for options.\n    \"\"\"\n    packer = Packer(**kwargs)\n    stream.write(packer.pack(o))\n\n\ndef packb(o, **kwargs):\n    \"\"\"\n    Pack object `o` and return packed bytes\n\n    See :class:`Packer` for options.\n    \"\"\"\n    return Packer(**kwargs).pack(o)\n\n\ndef unpack(stream, **kwargs):\n    \"\"\"\n    Unpack an object from `stream`.\n\n    Raises `ExtraData` when `stream` contains extra bytes.\n    See :class:`Unpacker` for options.\n    \"\"\"\n    data = stream.read()\n    return unpackb(data, **kwargs)\n\n\n# alias for compatibility to simplejson/marshal/pickle.\nload = unpack\nloads = unpackb\n\ndump = pack\ndumps = packb\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/msgpack/exceptions.py","size":1081,"sha1":"4ceae08460a40acdf926dbb2908ff87ab6309e4e","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"class UnpackException(Exception):\n    \"\"\"Base class for some exceptions raised while unpacking.\n\n    NOTE: unpack may raise exception other than subclass of\n    UnpackException.  If you want to catch all error, catch\n    Exception instead.\n    \"\"\"\n\n\nclass BufferFull(UnpackException):\n    pass\n\n\nclass OutOfData(UnpackException):\n    pass\n\n\nclass FormatError(ValueError, UnpackException):\n    \"\"\"Invalid msgpack format\"\"\"\n\n\nclass StackError(ValueError, UnpackException):\n    \"\"\"Too nested\"\"\"\n\n\n# Deprecated.  Use ValueError instead\nUnpackValueError = ValueError\n\n\nclass ExtraData(UnpackValueError):\n    \"\"\"ExtraData is raised when there is trailing data.\n\n    This exception is raised while only one-shot (not streaming)\n    unpack.\n    \"\"\"\n\n    def __init__(self, unpacked, extra):\n        self.unpacked = unpacked\n        self.extra = extra\n\n    def __str__(self):\n        return \"unpack(b) received extra data.\"\n\n\n# Deprecated.  Use Exception instead to catch all exception during packing.\nPackException = Exception\nPackValueError = ValueError\nPackOverflowError = OverflowError\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/msgpack/ext.py","size":5726,"sha1":"eca62dc33fe19e2fd3c3635f63a01c67bb282d6d","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import datetime\nimport struct\nfrom collections import namedtuple\n\n\nclass ExtType(namedtuple(\"ExtType\", \"code data\")):\n    \"\"\"ExtType represents ext type in msgpack.\"\"\"\n\n    def __new__(cls, code, data):\n        if not isinstance(code, int):\n            raise TypeError(\"code must be int\")\n        if not isinstance(data, bytes):\n            raise TypeError(\"data must be bytes\")\n        if not 0 <= code <= 127:\n            raise ValueError(\"code must be 0~127\")\n        return super().__new__(cls, code, data)\n\n\nclass Timestamp:\n    \"\"\"Timestamp represents the Timestamp extension type in msgpack.\n\n    When built with Cython, msgpack uses C methods to pack and unpack `Timestamp`.\n    When using pure-Python msgpack, :func:`to_bytes` and :func:`from_bytes` are used to pack and\n    unpack `Timestamp`.\n\n    This class is immutable: Do not override seconds and nanoseconds.\n    \"\"\"\n\n    __slots__ = [\"seconds\", \"nanoseconds\"]\n\n    def __init__(self, seconds, nanoseconds=0):\n        \"\"\"Initialize a Timestamp object.\n\n        :param int seconds:\n            Number of seconds since the UNIX epoch (00:00:00 UTC Jan 1 1970, minus leap seconds).\n            May be negative.\n\n        :param int nanoseconds:\n            Number of nanoseconds to add to `seconds` to get fractional time.\n            Maximum is 999_999_999.  Default is 0.\n\n        Note: Negative times (before the UNIX epoch) are represented as neg. seconds + pos. ns.\n        \"\"\"\n        if not isinstance(seconds, int):\n            raise TypeError(\"seconds must be an integer\")\n        if not isinstance(nanoseconds, int):\n            raise TypeError(\"nanoseconds must be an integer\")\n        if not (0 <= nanoseconds < 10**9):\n            raise ValueError(\"nanoseconds must be a non-negative integer less than 999999999.\")\n        self.seconds = seconds\n        self.nanoseconds = nanoseconds\n\n    def __repr__(self):\n        \"\"\"String representation of Timestamp.\"\"\"\n        return f\"Timestamp(seconds={self.seconds}, nanoseconds={self.nanoseconds})\"\n\n    def __eq__(self, other):\n        \"\"\"Check for equality with another Timestamp object\"\"\"\n        if type(other) is self.__class__:\n            return self.seconds == other.seconds and self.nanoseconds == other.nanoseconds\n        return False\n\n    def __ne__(self, other):\n        \"\"\"not-equals method (see :func:`__eq__()`)\"\"\"\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        return hash((self.seconds, self.nanoseconds))\n\n    @staticmethod\n    def from_bytes(b):\n        \"\"\"Unpack bytes into a `Timestamp` object.\n\n        Used for pure-Python msgpack unpacking.\n\n        :param b: Payload from msgpack ext message with code -1\n        :type b: bytes\n\n        :returns: Timestamp object unpacked from msgpack ext payload\n        :rtype: Timestamp\n        \"\"\"\n        if len(b) == 4:\n            seconds = struct.unpack(\"!L\", b)[0]\n            nanoseconds = 0\n        elif len(b) == 8:\n            data64 = struct.unpack(\"!Q\", b)[0]\n            seconds = data64 & 0x00000003FFFFFFFF\n            nanoseconds = data64 >> 34\n        elif len(b) == 12:\n            nanoseconds, seconds = struct.unpack(\"!Iq\", b)\n        else:\n            raise ValueError(\n                \"Timestamp type can only be created from 32, 64, or 96-bit byte objects\"\n            )\n        return Timestamp(seconds, nanoseconds)\n\n    def to_bytes(self):\n        \"\"\"Pack this Timestamp object into bytes.\n\n        Used for pure-Python msgpack packing.\n\n        :returns data: Payload for EXT message with code -1 (timestamp type)\n        :rtype: bytes\n        \"\"\"\n        if (self.seconds >> 34) == 0:  # seconds is non-negative and fits in 34 bits\n            data64 = self.nanoseconds << 34 | self.seconds\n            if data64 & 0xFFFFFFFF00000000 == 0:\n                # nanoseconds is zero and seconds < 2**32, so timestamp 32\n                data = struct.pack(\"!L\", data64)\n            else:\n                # timestamp 64\n                data = struct.pack(\"!Q\", data64)\n        else:\n            # timestamp 96\n            data = struct.pack(\"!Iq\", self.nanoseconds, self.seconds)\n        return data\n\n    @staticmethod\n    def from_unix(unix_sec):\n        \"\"\"Create a Timestamp from posix timestamp in seconds.\n\n        :param unix_float: Posix timestamp in seconds.\n        :type unix_float: int or float\n        \"\"\"\n        seconds = int(unix_sec // 1)\n        nanoseconds = int((unix_sec % 1) * 10**9)\n        return Timestamp(seconds, nanoseconds)\n\n    def to_unix(self):\n        \"\"\"Get the timestamp as a floating-point value.\n\n        :returns: posix timestamp\n        :rtype: float\n        \"\"\"\n        return self.seconds + self.nanoseconds / 1e9\n\n    @staticmethod\n    def from_unix_nano(unix_ns):\n        \"\"\"Create a Timestamp from posix timestamp in nanoseconds.\n\n        :param int unix_ns: Posix timestamp in nanoseconds.\n        :rtype: Timestamp\n        \"\"\"\n        return Timestamp(*divmod(unix_ns, 10**9))\n\n    def to_unix_nano(self):\n        \"\"\"Get the timestamp as a unixtime in nanoseconds.\n\n        :returns: posix timestamp in nanoseconds\n        :rtype: int\n        \"\"\"\n        return self.seconds * 10**9 + self.nanoseconds\n\n    def to_datetime(self):\n        \"\"\"Get the timestamp as a UTC datetime.\n\n        :rtype: `datetime.datetime`\n        \"\"\"\n        utc = datetime.timezone.utc\n        return datetime.datetime.fromtimestamp(0, utc) + datetime.timedelta(\n            seconds=self.seconds, microseconds=self.nanoseconds // 1000\n        )\n\n    @staticmethod\n    def from_datetime(dt):\n        \"\"\"Create a Timestamp from datetime with tzinfo.\n\n        :rtype: Timestamp\n        \"\"\"\n        return Timestamp(seconds=int(dt.timestamp()), nanoseconds=dt.microsecond * 1000)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/msgpack/fallback.py","size":32390,"sha1":"6598daab9910b12f1b272091126da5f09b6026a8","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Fallback pure Python implementation of msgpack\"\"\"\n\nimport struct\nimport sys\nfrom datetime import datetime as _DateTime\n\nif hasattr(sys, \"pypy_version_info\"):\n    from __pypy__ import newlist_hint\n    from __pypy__.builders import BytesBuilder\n\n    _USING_STRINGBUILDER = True\n\n    class BytesIO:\n        def __init__(self, s=b\"\"):\n            if s:\n                self.builder = BytesBuilder(len(s))\n                self.builder.append(s)\n            else:\n                self.builder = BytesBuilder()\n\n        def write(self, s):\n            if isinstance(s, memoryview):\n                s = s.tobytes()\n            elif isinstance(s, bytearray):\n                s = bytes(s)\n            self.builder.append(s)\n\n        def getvalue(self):\n            return self.builder.build()\n\nelse:\n    from io import BytesIO\n\n    _USING_STRINGBUILDER = False\n\n    def newlist_hint(size):\n        return []\n\n\nfrom .exceptions import BufferFull, ExtraData, FormatError, OutOfData, StackError\nfrom .ext import ExtType, Timestamp\n\nEX_SKIP = 0\nEX_CONSTRUCT = 1\nEX_READ_ARRAY_HEADER = 2\nEX_READ_MAP_HEADER = 3\n\nTYPE_IMMEDIATE = 0\nTYPE_ARRAY = 1\nTYPE_MAP = 2\nTYPE_RAW = 3\nTYPE_BIN = 4\nTYPE_EXT = 5\n\nDEFAULT_RECURSE_LIMIT = 511\n\n\ndef _check_type_strict(obj, t, type=type, tuple=tuple):\n    if type(t) is tuple:\n        return type(obj) in t\n    else:\n        return type(obj) is t\n\n\ndef _get_data_from_buffer(obj):\n    view = memoryview(obj)\n    if view.itemsize != 1:\n        raise ValueError(\"cannot unpack from multi-byte object\")\n    return view\n\n\ndef unpackb(packed, **kwargs):\n    \"\"\"\n    Unpack an object from `packed`.\n\n    Raises ``ExtraData`` when *packed* contains extra bytes.\n    Raises ``ValueError`` when *packed* is incomplete.\n    Raises ``FormatError`` when *packed* is not valid msgpack.\n    Raises ``StackError`` when *packed* contains too nested.\n    Other exceptions can be raised during unpacking.\n\n    See :class:`Unpacker` for options.\n    \"\"\"\n    unpacker = Unpacker(None, max_buffer_size=len(packed), **kwargs)\n    unpacker.feed(packed)\n    try:\n        ret = unpacker._unpack()\n    except OutOfData:\n        raise ValueError(\"Unpack failed: incomplete input\")\n    except RecursionError:\n        raise StackError\n    if unpacker._got_extradata():\n        raise ExtraData(ret, unpacker._get_extradata())\n    return ret\n\n\n_NO_FORMAT_USED = \"\"\n_MSGPACK_HEADERS = {\n    0xC4: (1, _NO_FORMAT_USED, TYPE_BIN),\n    0xC5: (2, \">H\", TYPE_BIN),\n    0xC6: (4, \">I\", TYPE_BIN),\n    0xC7: (2, \"Bb\", TYPE_EXT),\n    0xC8: (3, \">Hb\", TYPE_EXT),\n    0xC9: (5, \">Ib\", TYPE_EXT),\n    0xCA: (4, \">f\"),\n    0xCB: (8, \">d\"),\n    0xCC: (1, _NO_FORMAT_USED),\n    0xCD: (2, \">H\"),\n    0xCE: (4, \">I\"),\n    0xCF: (8, \">Q\"),\n    0xD0: (1, \"b\"),\n    0xD1: (2, \">h\"),\n    0xD2: (4, \">i\"),\n    0xD3: (8, \">q\"),\n    0xD4: (1, \"b1s\", TYPE_EXT),\n    0xD5: (2, \"b2s\", TYPE_EXT),\n    0xD6: (4, \"b4s\", TYPE_EXT),\n    0xD7: (8, \"b8s\", TYPE_EXT),\n    0xD8: (16, \"b16s\", TYPE_EXT),\n    0xD9: (1, _NO_FORMAT_USED, TYPE_RAW),\n    0xDA: (2, \">H\", TYPE_RAW),\n    0xDB: (4, \">I\", TYPE_RAW),\n    0xDC: (2, \">H\", TYPE_ARRAY),\n    0xDD: (4, \">I\", TYPE_ARRAY),\n    0xDE: (2, \">H\", TYPE_MAP),\n    0xDF: (4, \">I\", TYPE_MAP),\n}\n\n\nclass Unpacker:\n    \"\"\"Streaming unpacker.\n\n    Arguments:\n\n    :param file_like:\n        File-like object having `.read(n)` method.\n        If specified, unpacker reads serialized data from it and `.feed()` is not usable.\n\n    :param int read_size:\n        Used as `file_like.read(read_size)`. (default: `min(16*1024, max_buffer_size)`)\n\n    :param bool use_list:\n        If true, unpack msgpack array to Python list.\n        Otherwise, unpack to Python tuple. (default: True)\n\n    :param bool raw:\n        If true, unpack msgpack raw to Python bytes.\n        Otherwise, unpack to Python str by decoding with UTF-8 encoding (default).\n\n    :param int timestamp:\n        Control how timestamp type is unpacked:\n\n            0 - Timestamp\n            1 - float  (Seconds from the EPOCH)\n            2 - int  (Nanoseconds from the EPOCH)\n            3 - datetime.datetime  (UTC).\n\n    :param bool strict_map_key:\n        If true (default), only str or bytes are accepted for map (dict) keys.\n\n    :param object_hook:\n        When specified, it should be callable.\n        Unpacker calls it with a dict argument after unpacking msgpack map.\n        (See also simplejson)\n\n    :param object_pairs_hook:\n        When specified, it should be callable.\n        Unpacker calls it with a list of key-value pairs after unpacking msgpack map.\n        (See also simplejson)\n\n    :param str unicode_errors:\n        The error handler for decoding unicode. (default: 'strict')\n        This option should be used only when you have msgpack data which\n        contains invalid UTF-8 string.\n\n    :param int max_buffer_size:\n        Limits size of data waiting unpacked.  0 means 2**32-1.\n        The default value is 100*1024*1024 (100MiB).\n        Raises `BufferFull` exception when it is insufficient.\n        You should set this parameter when unpacking data from untrusted source.\n\n    :param int max_str_len:\n        Deprecated, use *max_buffer_size* instead.\n        Limits max length of str. (default: max_buffer_size)\n\n    :param int max_bin_len:\n        Deprecated, use *max_buffer_size* instead.\n        Limits max length of bin. (default: max_buffer_size)\n\n    :param int max_array_len:\n        Limits max length of array.\n        (default: max_buffer_size)\n\n    :param int max_map_len:\n        Limits max length of map.\n        (default: max_buffer_size//2)\n\n    :param int max_ext_len:\n        Deprecated, use *max_buffer_size* instead.\n        Limits max size of ext type.  (default: max_buffer_size)\n\n    Example of streaming deserialize from file-like object::\n\n        unpacker = Unpacker(file_like)\n        for o in unpacker:\n            process(o)\n\n    Example of streaming deserialize from socket::\n\n        unpacker = Unpacker()\n        while True:\n            buf = sock.recv(1024**2)\n            if not buf:\n                break\n            unpacker.feed(buf)\n            for o in unpacker:\n                process(o)\n\n    Raises ``ExtraData`` when *packed* contains extra bytes.\n    Raises ``OutOfData`` when *packed* is incomplete.\n    Raises ``FormatError`` when *packed* is not valid msgpack.\n    Raises ``StackError`` when *packed* contains too nested.\n    Other exceptions can be raised during unpacking.\n    \"\"\"\n\n    def __init__(\n        self,\n        file_like=None,\n        *,\n        read_size=0,\n        use_list=True,\n        raw=False,\n        timestamp=0,\n        strict_map_key=True,\n        object_hook=None,\n        object_pairs_hook=None,\n        list_hook=None,\n        unicode_errors=None,\n        max_buffer_size=100 * 1024 * 1024,\n        ext_hook=ExtType,\n        max_str_len=-1,\n        max_bin_len=-1,\n        max_array_len=-1,\n        max_map_len=-1,\n        max_ext_len=-1,\n    ):\n        if unicode_errors is None:\n            unicode_errors = \"strict\"\n\n        if file_like is None:\n            self._feeding = True\n        else:\n            if not callable(file_like.read):\n                raise TypeError(\"`file_like.read` must be callable\")\n            self.file_like = file_like\n            self._feeding = False\n\n        #: array of bytes fed.\n        self._buffer = bytearray()\n        #: Which position we currently reads\n        self._buff_i = 0\n\n        # When Unpacker is used as an iterable, between the calls to next(),\n        # the buffer is not \"consumed\" completely, for efficiency sake.\n        # Instead, it is done sloppily.  To make sure we raise BufferFull at\n        # the correct moments, we have to keep track of how sloppy we were.\n        # Furthermore, when the buffer is incomplete (that is: in the case\n        # we raise an OutOfData) we need to rollback the buffer to the correct\n        # state, which _buf_checkpoint records.\n        self._buf_checkpoint = 0\n\n        if not max_buffer_size:\n            max_buffer_size = 2**31 - 1\n        if max_str_len == -1:\n            max_str_len = max_buffer_size\n        if max_bin_len == -1:\n            max_bin_len = max_buffer_size\n        if max_array_len == -1:\n            max_array_len = max_buffer_size\n        if max_map_len == -1:\n            max_map_len = max_buffer_size // 2\n        if max_ext_len == -1:\n            max_ext_len = max_buffer_size\n\n        self._max_buffer_size = max_buffer_size\n        if read_size > self._max_buffer_size:\n            raise ValueError(\"read_size must be smaller than max_buffer_size\")\n        self._read_size = read_size or min(self._max_buffer_size, 16 * 1024)\n        self._raw = bool(raw)\n        self._strict_map_key = bool(strict_map_key)\n        self._unicode_errors = unicode_errors\n        self._use_list = use_list\n        if not (0 <= timestamp <= 3):\n            raise ValueError(\"timestamp must be 0..3\")\n        self._timestamp = timestamp\n        self._list_hook = list_hook\n        self._object_hook = object_hook\n        self._object_pairs_hook = object_pairs_hook\n        self._ext_hook = ext_hook\n        self._max_str_len = max_str_len\n        self._max_bin_len = max_bin_len\n        self._max_array_len = max_array_len\n        self._max_map_len = max_map_len\n        self._max_ext_len = max_ext_len\n        self._stream_offset = 0\n\n        if list_hook is not None and not callable(list_hook):\n            raise TypeError(\"`list_hook` is not callable\")\n        if object_hook is not None and not callable(object_hook):\n            raise TypeError(\"`object_hook` is not callable\")\n        if object_pairs_hook is not None and not callable(object_pairs_hook):\n            raise TypeError(\"`object_pairs_hook` is not callable\")\n        if object_hook is not None and object_pairs_hook is not None:\n            raise TypeError(\"object_pairs_hook and object_hook are mutually exclusive\")\n        if not callable(ext_hook):\n            raise TypeError(\"`ext_hook` is not callable\")\n\n    def feed(self, next_bytes):\n        assert self._feeding\n        view = _get_data_from_buffer(next_bytes)\n        if len(self._buffer) - self._buff_i + len(view) > self._max_buffer_size:\n            raise BufferFull\n\n        # Strip buffer before checkpoint before reading file.\n        if self._buf_checkpoint > 0:\n            del self._buffer[: self._buf_checkpoint]\n            self._buff_i -= self._buf_checkpoint\n            self._buf_checkpoint = 0\n\n        # Use extend here: INPLACE_ADD += doesn't reliably typecast memoryview in jython\n        self._buffer.extend(view)\n        view.release()\n\n    def _consume(self):\n        \"\"\"Gets rid of the used parts of the buffer.\"\"\"\n        self._stream_offset += self._buff_i - self._buf_checkpoint\n        self._buf_checkpoint = self._buff_i\n\n    def _got_extradata(self):\n        return self._buff_i < len(self._buffer)\n\n    def _get_extradata(self):\n        return self._buffer[self._buff_i :]\n\n    def read_bytes(self, n):\n        ret = self._read(n, raise_outofdata=False)\n        self._consume()\n        return ret\n\n    def _read(self, n, raise_outofdata=True):\n        # (int) -> bytearray\n        self._reserve(n, raise_outofdata=raise_outofdata)\n        i = self._buff_i\n        ret = self._buffer[i : i + n]\n        self._buff_i = i + len(ret)\n        return ret\n\n    def _reserve(self, n, raise_outofdata=True):\n        remain_bytes = len(self._buffer) - self._buff_i - n\n\n        # Fast path: buffer has n bytes already\n        if remain_bytes >= 0:\n            return\n\n        if self._feeding:\n            self._buff_i = self._buf_checkpoint\n            raise OutOfData\n\n        # Strip buffer before checkpoint before reading file.\n        if self._buf_checkpoint > 0:\n            del self._buffer[: self._buf_checkpoint]\n            self._buff_i -= self._buf_checkpoint\n            self._buf_checkpoint = 0\n\n        # Read from file\n        remain_bytes = -remain_bytes\n        if remain_bytes + len(self._buffer) > self._max_buffer_size:\n            raise BufferFull\n        while remain_bytes > 0:\n            to_read_bytes = max(self._read_size, remain_bytes)\n            read_data = self.file_like.read(to_read_bytes)\n            if not read_data:\n                break\n            assert isinstance(read_data, bytes)\n            self._buffer += read_data\n            remain_bytes -= len(read_data)\n\n        if len(self._buffer) < n + self._buff_i and raise_outofdata:\n            self._buff_i = 0  # rollback\n            raise OutOfData\n\n    def _read_header(self):\n        typ = TYPE_IMMEDIATE\n        n = 0\n        obj = None\n        self._reserve(1)\n        b = self._buffer[self._buff_i]\n        self._buff_i += 1\n        if b & 0b10000000 == 0:\n            obj = b\n        elif b & 0b11100000 == 0b11100000:\n            obj = -1 - (b ^ 0xFF)\n        elif b & 0b11100000 == 0b10100000:\n            n = b & 0b00011111\n            typ = TYPE_RAW\n            if n > self._max_str_len:\n                raise ValueError(f\"{n} exceeds max_str_len({self._max_str_len})\")\n            obj = self._read(n)\n        elif b & 0b11110000 == 0b10010000:\n            n = b & 0b00001111\n            typ = TYPE_ARRAY\n            if n > self._max_array_len:\n                raise ValueError(f\"{n} exceeds max_array_len({self._max_array_len})\")\n        elif b & 0b11110000 == 0b10000000:\n            n = b & 0b00001111\n            typ = TYPE_MAP\n            if n > self._max_map_len:\n                raise ValueError(f\"{n} exceeds max_map_len({self._max_map_len})\")\n        elif b == 0xC0:\n            obj = None\n        elif b == 0xC2:\n            obj = False\n        elif b == 0xC3:\n            obj = True\n        elif 0xC4 <= b <= 0xC6:\n            size, fmt, typ = _MSGPACK_HEADERS[b]\n            self._reserve(size)\n            if len(fmt) > 0:\n                n = struct.unpack_from(fmt, self._buffer, self._buff_i)[0]\n            else:\n                n = self._buffer[self._buff_i]\n            self._buff_i += size\n            if n > self._max_bin_len:\n                raise ValueError(f\"{n} exceeds max_bin_len({self._max_bin_len})\")\n            obj = self._read(n)\n        elif 0xC7 <= b <= 0xC9:\n            size, fmt, typ = _MSGPACK_HEADERS[b]\n            self._reserve(size)\n            L, n = struct.unpack_from(fmt, self._buffer, self._buff_i)\n            self._buff_i += size\n            if L > self._max_ext_len:\n                raise ValueError(f\"{L} exceeds max_ext_len({self._max_ext_len})\")\n            obj = self._read(L)\n        elif 0xCA <= b <= 0xD3:\n            size, fmt = _MSGPACK_HEADERS[b]\n            self._reserve(size)\n            if len(fmt) > 0:\n                obj = struct.unpack_from(fmt, self._buffer, self._buff_i)[0]\n            else:\n                obj = self._buffer[self._buff_i]\n            self._buff_i += size\n        elif 0xD4 <= b <= 0xD8:\n            size, fmt, typ = _MSGPACK_HEADERS[b]\n            if self._max_ext_len < size:\n                raise ValueError(f\"{size} exceeds max_ext_len({self._max_ext_len})\")\n            self._reserve(size + 1)\n            n, obj = struct.unpack_from(fmt, self._buffer, self._buff_i)\n            self._buff_i += size + 1\n        elif 0xD9 <= b <= 0xDB:\n            size, fmt, typ = _MSGPACK_HEADERS[b]\n            self._reserve(size)\n            if len(fmt) > 0:\n                (n,) = struct.unpack_from(fmt, self._buffer, self._buff_i)\n            else:\n                n = self._buffer[self._buff_i]\n            self._buff_i += size\n            if n > self._max_str_len:\n                raise ValueError(f\"{n} exceeds max_str_len({self._max_str_len})\")\n            obj = self._read(n)\n        elif 0xDC <= b <= 0xDD:\n            size, fmt, typ = _MSGPACK_HEADERS[b]\n            self._reserve(size)\n            (n,) = struct.unpack_from(fmt, self._buffer, self._buff_i)\n            self._buff_i += size\n            if n > self._max_array_len:\n                raise ValueError(f\"{n} exceeds max_array_len({self._max_array_len})\")\n        elif 0xDE <= b <= 0xDF:\n            size, fmt, typ = _MSGPACK_HEADERS[b]\n            self._reserve(size)\n            (n,) = struct.unpack_from(fmt, self._buffer, self._buff_i)\n            self._buff_i += size\n            if n > self._max_map_len:\n                raise ValueError(f\"{n} exceeds max_map_len({self._max_map_len})\")\n        else:\n            raise FormatError(\"Unknown header: 0x%x\" % b)\n        return typ, n, obj\n\n    def _unpack(self, execute=EX_CONSTRUCT):\n        typ, n, obj = self._read_header()\n\n        if execute == EX_READ_ARRAY_HEADER:\n            if typ != TYPE_ARRAY:\n                raise ValueError(\"Expected array\")\n            return n\n        if execute == EX_READ_MAP_HEADER:\n            if typ != TYPE_MAP:\n                raise ValueError(\"Expected map\")\n            return n\n        # TODO should we eliminate the recursion?\n        if typ == TYPE_ARRAY:\n            if execute == EX_SKIP:\n                for i in range(n):\n                    # TODO check whether we need to call `list_hook`\n                    self._unpack(EX_SKIP)\n                return\n            ret = newlist_hint(n)\n            for i in range(n):\n                ret.append(self._unpack(EX_CONSTRUCT))\n            if self._list_hook is not None:\n                ret = self._list_hook(ret)\n            # TODO is the interaction between `list_hook` and `use_list` ok?\n            return ret if self._use_list else tuple(ret)\n        if typ == TYPE_MAP:\n            if execute == EX_SKIP:\n                for i in range(n):\n                    # TODO check whether we need to call hooks\n                    self._unpack(EX_SKIP)\n                    self._unpack(EX_SKIP)\n                return\n            if self._object_pairs_hook is not None:\n                ret = self._object_pairs_hook(\n                    (self._unpack(EX_CONSTRUCT), self._unpack(EX_CONSTRUCT)) for _ in range(n)\n                )\n            else:\n                ret = {}\n                for _ in range(n):\n                    key = self._unpack(EX_CONSTRUCT)\n                    if self._strict_map_key and type(key) not in (str, bytes):\n                        raise ValueError(\"%s is not allowed for map key\" % str(type(key)))\n                    if isinstance(key, str):\n                        key = sys.intern(key)\n                    ret[key] = self._unpack(EX_CONSTRUCT)\n                if self._object_hook is not None:\n                    ret = self._object_hook(ret)\n            return ret\n        if execute == EX_SKIP:\n            return\n        if typ == TYPE_RAW:\n            if self._raw:\n                obj = bytes(obj)\n            else:\n                obj = obj.decode(\"utf_8\", self._unicode_errors)\n            return obj\n        if typ == TYPE_BIN:\n            return bytes(obj)\n        if typ == TYPE_EXT:\n            if n == -1:  # timestamp\n                ts = Timestamp.from_bytes(bytes(obj))\n                if self._timestamp == 1:\n                    return ts.to_unix()\n                elif self._timestamp == 2:\n                    return ts.to_unix_nano()\n                elif self._timestamp == 3:\n                    return ts.to_datetime()\n                else:\n                    return ts\n            else:\n                return self._ext_hook(n, bytes(obj))\n        assert typ == TYPE_IMMEDIATE\n        return obj\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        try:\n            ret = self._unpack(EX_CONSTRUCT)\n            self._consume()\n            return ret\n        except OutOfData:\n            self._consume()\n            raise StopIteration\n        except RecursionError:\n            raise StackError\n\n    next = __next__\n\n    def skip(self):\n        self._unpack(EX_SKIP)\n        self._consume()\n\n    def unpack(self):\n        try:\n            ret = self._unpack(EX_CONSTRUCT)\n        except RecursionError:\n            raise StackError\n        self._consume()\n        return ret\n\n    def read_array_header(self):\n        ret = self._unpack(EX_READ_ARRAY_HEADER)\n        self._consume()\n        return ret\n\n    def read_map_header(self):\n        ret = self._unpack(EX_READ_MAP_HEADER)\n        self._consume()\n        return ret\n\n    def tell(self):\n        return self._stream_offset\n\n\nclass Packer:\n    \"\"\"\n    MessagePack Packer\n\n    Usage::\n\n        packer = Packer()\n        astream.write(packer.pack(a))\n        astream.write(packer.pack(b))\n\n    Packer's constructor has some keyword arguments:\n\n    :param default:\n        When specified, it should be callable.\n        Convert user type to builtin type that Packer supports.\n        See also simplejson's document.\n\n    :param bool use_single_float:\n        Use single precision float type for float. (default: False)\n\n    :param bool autoreset:\n        Reset buffer after each pack and return its content as `bytes`. (default: True).\n        If set this to false, use `bytes()` to get content and `.reset()` to clear buffer.\n\n    :param bool use_bin_type:\n        Use bin type introduced in msgpack spec 2.0 for bytes.\n        It also enables str8 type for unicode. (default: True)\n\n    :param bool strict_types:\n        If set to true, types will be checked to be exact. Derived classes\n        from serializable types will not be serialized and will be\n        treated as unsupported type and forwarded to default.\n        Additionally tuples will not be serialized as lists.\n        This is useful when trying to implement accurate serialization\n        for python types.\n\n    :param bool datetime:\n        If set to true, datetime with tzinfo is packed into Timestamp type.\n        Note that the tzinfo is stripped in the timestamp.\n        You can get UTC datetime with `timestamp=3` option of the Unpacker.\n\n    :param str unicode_errors:\n        The error handler for encoding unicode. (default: 'strict')\n        DO NOT USE THIS!!  This option is kept for very specific usage.\n\n    :param int buf_size:\n        Internal buffer size. This option is used only for C implementation.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        default=None,\n        use_single_float=False,\n        autoreset=True,\n        use_bin_type=True,\n        strict_types=False,\n        datetime=False,\n        unicode_errors=None,\n        buf_size=None,\n    ):\n        self._strict_types = strict_types\n        self._use_float = use_single_float\n        self._autoreset = autoreset\n        self._use_bin_type = use_bin_type\n        self._buffer = BytesIO()\n        self._datetime = bool(datetime)\n        self._unicode_errors = unicode_errors or \"strict\"\n        if default is not None and not callable(default):\n            raise TypeError(\"default must be callable\")\n        self._default = default\n\n    def _pack(\n        self,\n        obj,\n        nest_limit=DEFAULT_RECURSE_LIMIT,\n        check=isinstance,\n        check_type_strict=_check_type_strict,\n    ):\n        default_used = False\n        if self._strict_types:\n            check = check_type_strict\n            list_types = list\n        else:\n            list_types = (list, tuple)\n        while True:\n            if nest_limit < 0:\n                raise ValueError(\"recursion limit exceeded\")\n            if obj is None:\n                return self._buffer.write(b\"\\xc0\")\n            if check(obj, bool):\n                if obj:\n                    return self._buffer.write(b\"\\xc3\")\n                return self._buffer.write(b\"\\xc2\")\n            if check(obj, int):\n                if 0 <= obj < 0x80:\n                    return self._buffer.write(struct.pack(\"B\", obj))\n                if -0x20 <= obj < 0:\n                    return self._buffer.write(struct.pack(\"b\", obj))\n                if 0x80 <= obj <= 0xFF:\n                    return self._buffer.write(struct.pack(\"BB\", 0xCC, obj))\n                if -0x80 <= obj < 0:\n                    return self._buffer.write(struct.pack(\">Bb\", 0xD0, obj))\n                if 0xFF < obj <= 0xFFFF:\n                    return self._buffer.write(struct.pack(\">BH\", 0xCD, obj))\n                if -0x8000 <= obj < -0x80:\n                    return self._buffer.write(struct.pack(\">Bh\", 0xD1, obj))\n                if 0xFFFF < obj <= 0xFFFFFFFF:\n                    return self._buffer.write(struct.pack(\">BI\", 0xCE, obj))\n                if -0x80000000 <= obj < -0x8000:\n                    return self._buffer.write(struct.pack(\">Bi\", 0xD2, obj))\n                if 0xFFFFFFFF < obj <= 0xFFFFFFFFFFFFFFFF:\n                    return self._buffer.write(struct.pack(\">BQ\", 0xCF, obj))\n                if -0x8000000000000000 <= obj < -0x80000000:\n                    return self._buffer.write(struct.pack(\">Bq\", 0xD3, obj))\n                if not default_used and self._default is not None:\n                    obj = self._default(obj)\n                    default_used = True\n                    continue\n                raise OverflowError(\"Integer value out of range\")\n            if check(obj, (bytes, bytearray)):\n                n = len(obj)\n                if n >= 2**32:\n                    raise ValueError(\"%s is too large\" % type(obj).__name__)\n                self._pack_bin_header(n)\n                return self._buffer.write(obj)\n            if check(obj, str):\n                obj = obj.encode(\"utf-8\", self._unicode_errors)\n                n = len(obj)\n                if n >= 2**32:\n                    raise ValueError(\"String is too large\")\n                self._pack_raw_header(n)\n                return self._buffer.write(obj)\n            if check(obj, memoryview):\n                n = obj.nbytes\n                if n >= 2**32:\n                    raise ValueError(\"Memoryview is too large\")\n                self._pack_bin_header(n)\n                return self._buffer.write(obj)\n            if check(obj, float):\n                if self._use_float:\n                    return self._buffer.write(struct.pack(\">Bf\", 0xCA, obj))\n                return self._buffer.write(struct.pack(\">Bd\", 0xCB, obj))\n            if check(obj, (ExtType, Timestamp)):\n                if check(obj, Timestamp):\n                    code = -1\n                    data = obj.to_bytes()\n                else:\n                    code = obj.code\n                    data = obj.data\n                assert isinstance(code, int)\n                assert isinstance(data, bytes)\n                L = len(data)\n                if L == 1:\n                    self._buffer.write(b\"\\xd4\")\n                elif L == 2:\n                    self._buffer.write(b\"\\xd5\")\n                elif L == 4:\n                    self._buffer.write(b\"\\xd6\")\n                elif L == 8:\n                    self._buffer.write(b\"\\xd7\")\n                elif L == 16:\n                    self._buffer.write(b\"\\xd8\")\n                elif L <= 0xFF:\n                    self._buffer.write(struct.pack(\">BB\", 0xC7, L))\n                elif L <= 0xFFFF:\n                    self._buffer.write(struct.pack(\">BH\", 0xC8, L))\n                else:\n                    self._buffer.write(struct.pack(\">BI\", 0xC9, L))\n                self._buffer.write(struct.pack(\"b\", code))\n                self._buffer.write(data)\n                return\n            if check(obj, list_types):\n                n = len(obj)\n                self._pack_array_header(n)\n                for i in range(n):\n                    self._pack(obj[i], nest_limit - 1)\n                return\n            if check(obj, dict):\n                return self._pack_map_pairs(len(obj), obj.items(), nest_limit - 1)\n\n            if self._datetime and check(obj, _DateTime) and obj.tzinfo is not None:\n                obj = Timestamp.from_datetime(obj)\n                default_used = 1\n                continue\n\n            if not default_used and self._default is not None:\n                obj = self._default(obj)\n                default_used = 1\n                continue\n\n            if self._datetime and check(obj, _DateTime):\n                raise ValueError(f\"Cannot serialize {obj!r} where tzinfo=None\")\n\n            raise TypeError(f\"Cannot serialize {obj!r}\")\n\n    def pack(self, obj):\n        try:\n            self._pack(obj)\n        except:\n            self._buffer = BytesIO()  # force reset\n            raise\n        if self._autoreset:\n            ret = self._buffer.getvalue()\n            self._buffer = BytesIO()\n            return ret\n\n    def pack_map_pairs(self, pairs):\n        self._pack_map_pairs(len(pairs), pairs)\n        if self._autoreset:\n            ret = self._buffer.getvalue()\n            self._buffer = BytesIO()\n            return ret\n\n    def pack_array_header(self, n):\n        if n >= 2**32:\n            raise ValueError\n        self._pack_array_header(n)\n        if self._autoreset:\n            ret = self._buffer.getvalue()\n            self._buffer = BytesIO()\n            return ret\n\n    def pack_map_header(self, n):\n        if n >= 2**32:\n            raise ValueError\n        self._pack_map_header(n)\n        if self._autoreset:\n            ret = self._buffer.getvalue()\n            self._buffer = BytesIO()\n            return ret\n\n    def pack_ext_type(self, typecode, data):\n        if not isinstance(typecode, int):\n            raise TypeError(\"typecode must have int type.\")\n        if not 0 <= typecode <= 127:\n            raise ValueError(\"typecode should be 0-127\")\n        if not isinstance(data, bytes):\n            raise TypeError(\"data must have bytes type\")\n        L = len(data)\n        if L > 0xFFFFFFFF:\n            raise ValueError(\"Too large data\")\n        if L == 1:\n            self._buffer.write(b\"\\xd4\")\n        elif L == 2:\n            self._buffer.write(b\"\\xd5\")\n        elif L == 4:\n            self._buffer.write(b\"\\xd6\")\n        elif L == 8:\n            self._buffer.write(b\"\\xd7\")\n        elif L == 16:\n            self._buffer.write(b\"\\xd8\")\n        elif L <= 0xFF:\n            self._buffer.write(b\"\\xc7\" + struct.pack(\"B\", L))\n        elif L <= 0xFFFF:\n            self._buffer.write(b\"\\xc8\" + struct.pack(\">H\", L))\n        else:\n            self._buffer.write(b\"\\xc9\" + struct.pack(\">I\", L))\n        self._buffer.write(struct.pack(\"B\", typecode))\n        self._buffer.write(data)\n\n    def _pack_array_header(self, n):\n        if n <= 0x0F:\n            return self._buffer.write(struct.pack(\"B\", 0x90 + n))\n        if n <= 0xFFFF:\n            return self._buffer.write(struct.pack(\">BH\", 0xDC, n))\n        if n <= 0xFFFFFFFF:\n            return self._buffer.write(struct.pack(\">BI\", 0xDD, n))\n        raise ValueError(\"Array is too large\")\n\n    def _pack_map_header(self, n):\n        if n <= 0x0F:\n            return self._buffer.write(struct.pack(\"B\", 0x80 + n))\n        if n <= 0xFFFF:\n            return self._buffer.write(struct.pack(\">BH\", 0xDE, n))\n        if n <= 0xFFFFFFFF:\n            return self._buffer.write(struct.pack(\">BI\", 0xDF, n))\n        raise ValueError(\"Dict is too large\")\n\n    def _pack_map_pairs(self, n, pairs, nest_limit=DEFAULT_RECURSE_LIMIT):\n        self._pack_map_header(n)\n        for k, v in pairs:\n            self._pack(k, nest_limit - 1)\n            self._pack(v, nest_limit - 1)\n\n    def _pack_raw_header(self, n):\n        if n <= 0x1F:\n            self._buffer.write(struct.pack(\"B\", 0xA0 + n))\n        elif self._use_bin_type and n <= 0xFF:\n            self._buffer.write(struct.pack(\">BB\", 0xD9, n))\n        elif n <= 0xFFFF:\n            self._buffer.write(struct.pack(\">BH\", 0xDA, n))\n        elif n <= 0xFFFFFFFF:\n            self._buffer.write(struct.pack(\">BI\", 0xDB, n))\n        else:\n            raise ValueError(\"Raw is too large\")\n\n    def _pack_bin_header(self, n):\n        if not self._use_bin_type:\n            return self._pack_raw_header(n)\n        elif n <= 0xFF:\n            return self._buffer.write(struct.pack(\">BB\", 0xC4, n))\n        elif n <= 0xFFFF:\n            return self._buffer.write(struct.pack(\">BH\", 0xC5, n))\n        elif n <= 0xFFFFFFFF:\n            return self._buffer.write(struct.pack(\">BI\", 0xC6, n))\n        else:\n            raise ValueError(\"Bin is too large\")\n\n    def bytes(self):\n        \"\"\"Return internal buffer contents as bytes object\"\"\"\n        return self._buffer.getvalue()\n\n    def reset(self):\n        \"\"\"Reset internal buffer.\n\n        This method is useful only when autoreset=False.\n        \"\"\"\n        self._buffer = BytesIO()\n\n    def getbuffer(self):\n        \"\"\"Return view of internal buffer.\"\"\"\n        if _USING_STRINGBUILDER:\n            return memoryview(self.bytes())\n        else:\n            return self._buffer.getbuffer()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/packaging/__init__.py","size":494,"sha1":"50bac0ee902e35d450fe345de5d6c13f5517c687","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n__title__ = \"packaging\"\n__summary__ = \"Core utilities for Python packages\"\n__uri__ = \"https://github.com/pypa/packaging\"\n\n__version__ = \"24.2\"\n\n__author__ = \"Donald Stufft and individual contributors\"\n__email__ = \"donald@stufft.io\"\n\n__license__ = \"BSD-2-Clause or Apache-2.0\"\n__copyright__ = f\"2014 {__author__}\"\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/packaging/_elffile.py","size":3306,"sha1":"dc3c25ff49ee9eb6a37daad8fd6f6664768d7f5a","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nELF file parser.\n\nThis provides a class ``ELFFile`` that parses an ELF executable in a similar\ninterface to ``ZipFile``. Only the read interface is implemented.\n\nBased on: https://gist.github.com/lyssdod/f51579ae8d93c8657a5564aefc2ffbca\nELF header: https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html\n\"\"\"\n\nfrom __future__ import annotations\n\nimport enum\nimport os\nimport struct\nfrom typing import IO\n\n\nclass ELFInvalid(ValueError):\n    pass\n\n\nclass EIClass(enum.IntEnum):\n    C32 = 1\n    C64 = 2\n\n\nclass EIData(enum.IntEnum):\n    Lsb = 1\n    Msb = 2\n\n\nclass EMachine(enum.IntEnum):\n    I386 = 3\n    S390 = 22\n    Arm = 40\n    X8664 = 62\n    AArc64 = 183\n\n\nclass ELFFile:\n    \"\"\"\n    Representation of an ELF executable.\n    \"\"\"\n\n    def __init__(self, f: IO[bytes]) -> None:\n        self._f = f\n\n        try:\n            ident = self._read(\"16B\")\n        except struct.error as e:\n            raise ELFInvalid(\"unable to parse identification\") from e\n        magic = bytes(ident[:4])\n        if magic != b\"\\x7fELF\":\n            raise ELFInvalid(f\"invalid magic: {magic!r}\")\n\n        self.capacity = ident[4]  # Format for program header (bitness).\n        self.encoding = ident[5]  # Data structure encoding (endianness).\n\n        try:\n            # e_fmt: Format for program header.\n            # p_fmt: Format for section header.\n            # p_idx: Indexes to find p_type, p_offset, and p_filesz.\n            e_fmt, self._p_fmt, self._p_idx = {\n                (1, 1): (\"<HHIIIIIHHH\", \"<IIIIIIII\", (0, 1, 4)),  # 32-bit LSB.\n                (1, 2): (\">HHIIIIIHHH\", \">IIIIIIII\", (0, 1, 4)),  # 32-bit MSB.\n                (2, 1): (\"<HHIQQQIHHH\", \"<IIQQQQQQ\", (0, 2, 5)),  # 64-bit LSB.\n                (2, 2): (\">HHIQQQIHHH\", \">IIQQQQQQ\", (0, 2, 5)),  # 64-bit MSB.\n            }[(self.capacity, self.encoding)]\n        except KeyError as e:\n            raise ELFInvalid(\n                f\"unrecognized capacity ({self.capacity}) or \"\n                f\"encoding ({self.encoding})\"\n            ) from e\n\n        try:\n            (\n                _,\n                self.machine,  # Architecture type.\n                _,\n                _,\n                self._e_phoff,  # Offset of program header.\n                _,\n                self.flags,  # Processor-specific flags.\n                _,\n                self._e_phentsize,  # Size of section.\n                self._e_phnum,  # Number of sections.\n            ) = self._read(e_fmt)\n        except struct.error as e:\n            raise ELFInvalid(\"unable to parse machine and section information\") from e\n\n    def _read(self, fmt: str) -> tuple[int, ...]:\n        return struct.unpack(fmt, self._f.read(struct.calcsize(fmt)))\n\n    @property\n    def interpreter(self) -> str | None:\n        \"\"\"\n        The path recorded in the ``PT_INTERP`` section header.\n        \"\"\"\n        for index in range(self._e_phnum):\n            self._f.seek(self._e_phoff + self._e_phentsize * index)\n            try:\n                data = self._read(self._p_fmt)\n            except struct.error:\n                continue\n            if data[self._p_idx[0]] != 3:  # Not PT_INTERP.\n                continue\n            self._f.seek(data[self._p_idx[1]])\n            return os.fsdecode(self._f.read(data[self._p_idx[2]])).strip(\"\\0\")\n        return None\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/packaging/_manylinux.py","size":9612,"sha1":"b1eff66f27c5033317c724bd4b9ac57a0727f271","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport collections\nimport contextlib\nimport functools\nimport os\nimport re\nimport sys\nimport warnings\nfrom typing import Generator, Iterator, NamedTuple, Sequence\n\nfrom ._elffile import EIClass, EIData, ELFFile, EMachine\n\nEF_ARM_ABIMASK = 0xFF000000\nEF_ARM_ABI_VER5 = 0x05000000\nEF_ARM_ABI_FLOAT_HARD = 0x00000400\n\n\n# `os.PathLike` not a generic type until Python 3.9, so sticking with `str`\n# as the type for `path` until then.\n@contextlib.contextmanager\ndef _parse_elf(path: str) -> Generator[ELFFile | None, None, None]:\n    try:\n        with open(path, \"rb\") as f:\n            yield ELFFile(f)\n    except (OSError, TypeError, ValueError):\n        yield None\n\n\ndef _is_linux_armhf(executable: str) -> bool:\n    # hard-float ABI can be detected from the ELF header of the running\n    # process\n    # https://static.docs.arm.com/ihi0044/g/aaelf32.pdf\n    with _parse_elf(executable) as f:\n        return (\n            f is not None\n            and f.capacity == EIClass.C32\n            and f.encoding == EIData.Lsb\n            and f.machine == EMachine.Arm\n            and f.flags & EF_ARM_ABIMASK == EF_ARM_ABI_VER5\n            and f.flags & EF_ARM_ABI_FLOAT_HARD == EF_ARM_ABI_FLOAT_HARD\n        )\n\n\ndef _is_linux_i686(executable: str) -> bool:\n    with _parse_elf(executable) as f:\n        return (\n            f is not None\n            and f.capacity == EIClass.C32\n            and f.encoding == EIData.Lsb\n            and f.machine == EMachine.I386\n        )\n\n\ndef _have_compatible_abi(executable: str, archs: Sequence[str]) -> bool:\n    if \"armv7l\" in archs:\n        return _is_linux_armhf(executable)\n    if \"i686\" in archs:\n        return _is_linux_i686(executable)\n    allowed_archs = {\n        \"x86_64\",\n        \"aarch64\",\n        \"ppc64\",\n        \"ppc64le\",\n        \"s390x\",\n        \"loongarch64\",\n        \"riscv64\",\n    }\n    return any(arch in allowed_archs for arch in archs)\n\n\n# If glibc ever changes its major version, we need to know what the last\n# minor version was, so we can build the complete list of all versions.\n# For now, guess what the highest minor version might be, assume it will\n# be 50 for testing. Once this actually happens, update the dictionary\n# with the actual value.\n_LAST_GLIBC_MINOR: dict[int, int] = collections.defaultdict(lambda: 50)\n\n\nclass _GLibCVersion(NamedTuple):\n    major: int\n    minor: int\n\n\ndef _glibc_version_string_confstr() -> str | None:\n    \"\"\"\n    Primary implementation of glibc_version_string using os.confstr.\n    \"\"\"\n    # os.confstr is quite a bit faster than ctypes.DLL. It's also less likely\n    # to be broken or missing. This strategy is used in the standard library\n    # platform module.\n    # https://github.com/python/cpython/blob/fcf1d003bf4f0100c/Lib/platform.py#L175-L183\n    try:\n        # Should be a string like \"glibc 2.17\".\n        version_string: str | None = os.confstr(\"CS_GNU_LIBC_VERSION\")\n        assert version_string is not None\n        _, version = version_string.rsplit()\n    except (AssertionError, AttributeError, OSError, ValueError):\n        # os.confstr() or CS_GNU_LIBC_VERSION not available (or a bad value)...\n        return None\n    return version\n\n\ndef _glibc_version_string_ctypes() -> str | None:\n    \"\"\"\n    Fallback implementation of glibc_version_string using ctypes.\n    \"\"\"\n    try:\n        import ctypes\n    except ImportError:\n        return None\n\n    # ctypes.CDLL(None) internally calls dlopen(NULL), and as the dlopen\n    # manpage says, \"If filename is NULL, then the returned handle is for the\n    # main program\". This way we can let the linker do the work to figure out\n    # which libc our process is actually using.\n    #\n    # We must also handle the special case where the executable is not a\n    # dynamically linked executable. This can occur when using musl libc,\n    # for example. In this situation, dlopen() will error, leading to an\n    # OSError. Interestingly, at least in the case of musl, there is no\n    # errno set on the OSError. The single string argument used to construct\n    # OSError comes from libc itself and is therefore not portable to\n    # hard code here. In any case, failure to call dlopen() means we\n    # can proceed, so we bail on our attempt.\n    try:\n        process_namespace = ctypes.CDLL(None)\n    except OSError:\n        return None\n\n    try:\n        gnu_get_libc_version = process_namespace.gnu_get_libc_version\n    except AttributeError:\n        # Symbol doesn't exist -> therefore, we are not linked to\n        # glibc.\n        return None\n\n    # Call gnu_get_libc_version, which returns a string like \"2.5\"\n    gnu_get_libc_version.restype = ctypes.c_char_p\n    version_str: str = gnu_get_libc_version()\n    # py2 / py3 compatibility:\n    if not isinstance(version_str, str):\n        version_str = version_str.decode(\"ascii\")\n\n    return version_str\n\n\ndef _glibc_version_string() -> str | None:\n    \"\"\"Returns glibc version string, or None if not using glibc.\"\"\"\n    return _glibc_version_string_confstr() or _glibc_version_string_ctypes()\n\n\ndef _parse_glibc_version(version_str: str) -> tuple[int, int]:\n    \"\"\"Parse glibc version.\n\n    We use a regexp instead of str.split because we want to discard any\n    random junk that might come after the minor version -- this might happen\n    in patched/forked versions of glibc (e.g. Linaro's version of glibc\n    uses version strings like \"2.20-2014.11\"). See gh-3588.\n    \"\"\"\n    m = re.match(r\"(?P<major>[0-9]+)\\.(?P<minor>[0-9]+)\", version_str)\n    if not m:\n        warnings.warn(\n            f\"Expected glibc version with 2 components major.minor,\"\n            f\" got: {version_str}\",\n            RuntimeWarning,\n            stacklevel=2,\n        )\n        return -1, -1\n    return int(m.group(\"major\")), int(m.group(\"minor\"))\n\n\n@functools.lru_cache\ndef _get_glibc_version() -> tuple[int, int]:\n    version_str = _glibc_version_string()\n    if version_str is None:\n        return (-1, -1)\n    return _parse_glibc_version(version_str)\n\n\n# From PEP 513, PEP 600\ndef _is_compatible(arch: str, version: _GLibCVersion) -> bool:\n    sys_glibc = _get_glibc_version()\n    if sys_glibc < version:\n        return False\n    # Check for presence of _manylinux module.\n    try:\n        import _manylinux\n    except ImportError:\n        return True\n    if hasattr(_manylinux, \"manylinux_compatible\"):\n        result = _manylinux.manylinux_compatible(version[0], version[1], arch)\n        if result is not None:\n            return bool(result)\n        return True\n    if version == _GLibCVersion(2, 5):\n        if hasattr(_manylinux, \"manylinux1_compatible\"):\n            return bool(_manylinux.manylinux1_compatible)\n    if version == _GLibCVersion(2, 12):\n        if hasattr(_manylinux, \"manylinux2010_compatible\"):\n            return bool(_manylinux.manylinux2010_compatible)\n    if version == _GLibCVersion(2, 17):\n        if hasattr(_manylinux, \"manylinux2014_compatible\"):\n            return bool(_manylinux.manylinux2014_compatible)\n    return True\n\n\n_LEGACY_MANYLINUX_MAP = {\n    # CentOS 7 w/ glibc 2.17 (PEP 599)\n    (2, 17): \"manylinux2014\",\n    # CentOS 6 w/ glibc 2.12 (PEP 571)\n    (2, 12): \"manylinux2010\",\n    # CentOS 5 w/ glibc 2.5 (PEP 513)\n    (2, 5): \"manylinux1\",\n}\n\n\ndef platform_tags(archs: Sequence[str]) -> Iterator[str]:\n    \"\"\"Generate manylinux tags compatible to the current platform.\n\n    :param archs: Sequence of compatible architectures.\n        The first one shall be the closest to the actual architecture and be the part of\n        platform tag after the ``linux_`` prefix, e.g. ``x86_64``.\n        The ``linux_`` prefix is assumed as a prerequisite for the current platform to\n        be manylinux-compatible.\n\n    :returns: An iterator of compatible manylinux tags.\n    \"\"\"\n    if not _have_compatible_abi(sys.executable, archs):\n        return\n    # Oldest glibc to be supported regardless of architecture is (2, 17).\n    too_old_glibc2 = _GLibCVersion(2, 16)\n    if set(archs) & {\"x86_64\", \"i686\"}:\n        # On x86/i686 also oldest glibc to be supported is (2, 5).\n        too_old_glibc2 = _GLibCVersion(2, 4)\n    current_glibc = _GLibCVersion(*_get_glibc_version())\n    glibc_max_list = [current_glibc]\n    # We can assume compatibility across glibc major versions.\n    # https://sourceware.org/bugzilla/show_bug.cgi?id=24636\n    #\n    # Build a list of maximum glibc versions so that we can\n    # output the canonical list of all glibc from current_glibc\n    # down to too_old_glibc2, including all intermediary versions.\n    for glibc_major in range(current_glibc.major - 1, 1, -1):\n        glibc_minor = _LAST_GLIBC_MINOR[glibc_major]\n        glibc_max_list.append(_GLibCVersion(glibc_major, glibc_minor))\n    for arch in archs:\n        for glibc_max in glibc_max_list:\n            if glibc_max.major == too_old_glibc2.major:\n                min_minor = too_old_glibc2.minor\n            else:\n                # For other glibc major versions oldest supported is (x, 0).\n                min_minor = -1\n            for glibc_minor in range(glibc_max.minor, min_minor, -1):\n                glibc_version = _GLibCVersion(glibc_max.major, glibc_minor)\n                tag = \"manylinux_{}_{}\".format(*glibc_version)\n                if _is_compatible(arch, glibc_version):\n                    yield f\"{tag}_{arch}\"\n                # Handle the legacy manylinux1, manylinux2010, manylinux2014 tags.\n                if glibc_version in _LEGACY_MANYLINUX_MAP:\n                    legacy_tag = _LEGACY_MANYLINUX_MAP[glibc_version]\n                    if _is_compatible(arch, glibc_version):\n                        yield f\"{legacy_tag}_{arch}\"\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/packaging/_musllinux.py","size":2694,"sha1":"7d4819fd7cc78fa2acec97cdbd23939ff45f12b8","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"PEP 656 support.\n\nThis module implements logic to detect if the currently running Python is\nlinked against musl, and what musl version is used.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport functools\nimport re\nimport subprocess\nimport sys\nfrom typing import Iterator, NamedTuple, Sequence\n\nfrom ._elffile import ELFFile\n\n\nclass _MuslVersion(NamedTuple):\n    major: int\n    minor: int\n\n\ndef _parse_musl_version(output: str) -> _MuslVersion | None:\n    lines = [n for n in (n.strip() for n in output.splitlines()) if n]\n    if len(lines) < 2 or lines[0][:4] != \"musl\":\n        return None\n    m = re.match(r\"Version (\\d+)\\.(\\d+)\", lines[1])\n    if not m:\n        return None\n    return _MuslVersion(major=int(m.group(1)), minor=int(m.group(2)))\n\n\n@functools.lru_cache\ndef _get_musl_version(executable: str) -> _MuslVersion | None:\n    \"\"\"Detect currently-running musl runtime version.\n\n    This is done by checking the specified executable's dynamic linking\n    information, and invoking the loader to parse its output for a version\n    string. If the loader is musl, the output would be something like::\n\n        musl libc (x86_64)\n        Version 1.2.2\n        Dynamic Program Loader\n    \"\"\"\n    try:\n        with open(executable, \"rb\") as f:\n            ld = ELFFile(f).interpreter\n    except (OSError, TypeError, ValueError):\n        return None\n    if ld is None or \"musl\" not in ld:\n        return None\n    proc = subprocess.run([ld], stderr=subprocess.PIPE, text=True)\n    return _parse_musl_version(proc.stderr)\n\n\ndef platform_tags(archs: Sequence[str]) -> Iterator[str]:\n    \"\"\"Generate musllinux tags compatible to the current platform.\n\n    :param archs: Sequence of compatible architectures.\n        The first one shall be the closest to the actual architecture and be the part of\n        platform tag after the ``linux_`` prefix, e.g. ``x86_64``.\n        The ``linux_`` prefix is assumed as a prerequisite for the current platform to\n        be musllinux-compatible.\n\n    :returns: An iterator of compatible musllinux tags.\n    \"\"\"\n    sys_musl = _get_musl_version(sys.executable)\n    if sys_musl is None:  # Python not dynamically linked against musl.\n        return\n    for arch in archs:\n        for minor in range(sys_musl.minor, -1, -1):\n            yield f\"musllinux_{sys_musl.major}_{minor}_{arch}\"\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    import sysconfig\n\n    plat = sysconfig.get_platform()\n    assert plat.startswith(\"linux-\"), \"not linux\"\n\n    print(\"plat:\", plat)\n    print(\"musl:\", _get_musl_version(sys.executable))\n    print(\"tags:\", end=\" \")\n    for t in platform_tags(re.sub(r\"[.-]\", \"_\", plat.split(\"-\", 1)[-1])):\n        print(t, end=\"\\n      \")\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/packaging/_parser.py","size":10236,"sha1":"bba6fb5dd1e66f6622a7c9ffeafa127b510d8e30","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Handwritten parser of dependency specifiers.\n\nThe docstring for each __parse_* function contains EBNF-inspired grammar representing\nthe implementation.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport ast\nfrom typing import NamedTuple, Sequence, Tuple, Union\n\nfrom ._tokenizer import DEFAULT_RULES, Tokenizer\n\n\nclass Node:\n    def __init__(self, value: str) -> None:\n        self.value = value\n\n    def __str__(self) -> str:\n        return self.value\n\n    def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__}('{self}')>\"\n\n    def serialize(self) -> str:\n        raise NotImplementedError\n\n\nclass Variable(Node):\n    def serialize(self) -> str:\n        return str(self)\n\n\nclass Value(Node):\n    def serialize(self) -> str:\n        return f'\"{self}\"'\n\n\nclass Op(Node):\n    def serialize(self) -> str:\n        return str(self)\n\n\nMarkerVar = Union[Variable, Value]\nMarkerItem = Tuple[MarkerVar, Op, MarkerVar]\nMarkerAtom = Union[MarkerItem, Sequence[\"MarkerAtom\"]]\nMarkerList = Sequence[Union[\"MarkerList\", MarkerAtom, str]]\n\n\nclass ParsedRequirement(NamedTuple):\n    name: str\n    url: str\n    extras: list[str]\n    specifier: str\n    marker: MarkerList | None\n\n\n# --------------------------------------------------------------------------------------\n# Recursive descent parser for dependency specifier\n# --------------------------------------------------------------------------------------\ndef parse_requirement(source: str) -> ParsedRequirement:\n    return _parse_requirement(Tokenizer(source, rules=DEFAULT_RULES))\n\n\ndef _parse_requirement(tokenizer: Tokenizer) -> ParsedRequirement:\n    \"\"\"\n    requirement = WS? IDENTIFIER WS? extras WS? requirement_details\n    \"\"\"\n    tokenizer.consume(\"WS\")\n\n    name_token = tokenizer.expect(\n        \"IDENTIFIER\", expected=\"package name at the start of dependency specifier\"\n    )\n    name = name_token.text\n    tokenizer.consume(\"WS\")\n\n    extras = _parse_extras(tokenizer)\n    tokenizer.consume(\"WS\")\n\n    url, specifier, marker = _parse_requirement_details(tokenizer)\n    tokenizer.expect(\"END\", expected=\"end of dependency specifier\")\n\n    return ParsedRequirement(name, url, extras, specifier, marker)\n\n\ndef _parse_requirement_details(\n    tokenizer: Tokenizer,\n) -> tuple[str, str, MarkerList | None]:\n    \"\"\"\n    requirement_details = AT URL (WS requirement_marker?)?\n                        | specifier WS? (requirement_marker)?\n    \"\"\"\n\n    specifier = \"\"\n    url = \"\"\n    marker = None\n\n    if tokenizer.check(\"AT\"):\n        tokenizer.read()\n        tokenizer.consume(\"WS\")\n\n        url_start = tokenizer.position\n        url = tokenizer.expect(\"URL\", expected=\"URL after @\").text\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        tokenizer.expect(\"WS\", expected=\"whitespace after URL\")\n\n        # The input might end after whitespace.\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        marker = _parse_requirement_marker(\n            tokenizer, span_start=url_start, after=\"URL and whitespace\"\n        )\n    else:\n        specifier_start = tokenizer.position\n        specifier = _parse_specifier(tokenizer)\n        tokenizer.consume(\"WS\")\n\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        marker = _parse_requirement_marker(\n            tokenizer,\n            span_start=specifier_start,\n            after=(\n                \"version specifier\"\n                if specifier\n                else \"name and no valid version specifier\"\n            ),\n        )\n\n    return (url, specifier, marker)\n\n\ndef _parse_requirement_marker(\n    tokenizer: Tokenizer, *, span_start: int, after: str\n) -> MarkerList:\n    \"\"\"\n    requirement_marker = SEMICOLON marker WS?\n    \"\"\"\n\n    if not tokenizer.check(\"SEMICOLON\"):\n        tokenizer.raise_syntax_error(\n            f\"Expected end or semicolon (after {after})\",\n            span_start=span_start,\n        )\n    tokenizer.read()\n\n    marker = _parse_marker(tokenizer)\n    tokenizer.consume(\"WS\")\n\n    return marker\n\n\ndef _parse_extras(tokenizer: Tokenizer) -> list[str]:\n    \"\"\"\n    extras = (LEFT_BRACKET wsp* extras_list? wsp* RIGHT_BRACKET)?\n    \"\"\"\n    if not tokenizer.check(\"LEFT_BRACKET\", peek=True):\n        return []\n\n    with tokenizer.enclosing_tokens(\n        \"LEFT_BRACKET\",\n        \"RIGHT_BRACKET\",\n        around=\"extras\",\n    ):\n        tokenizer.consume(\"WS\")\n        extras = _parse_extras_list(tokenizer)\n        tokenizer.consume(\"WS\")\n\n    return extras\n\n\ndef _parse_extras_list(tokenizer: Tokenizer) -> list[str]:\n    \"\"\"\n    extras_list = identifier (wsp* ',' wsp* identifier)*\n    \"\"\"\n    extras: list[str] = []\n\n    if not tokenizer.check(\"IDENTIFIER\"):\n        return extras\n\n    extras.append(tokenizer.read().text)\n\n    while True:\n        tokenizer.consume(\"WS\")\n        if tokenizer.check(\"IDENTIFIER\", peek=True):\n            tokenizer.raise_syntax_error(\"Expected comma between extra names\")\n        elif not tokenizer.check(\"COMMA\"):\n            break\n\n        tokenizer.read()\n        tokenizer.consume(\"WS\")\n\n        extra_token = tokenizer.expect(\"IDENTIFIER\", expected=\"extra name after comma\")\n        extras.append(extra_token.text)\n\n    return extras\n\n\ndef _parse_specifier(tokenizer: Tokenizer) -> str:\n    \"\"\"\n    specifier = LEFT_PARENTHESIS WS? version_many WS? RIGHT_PARENTHESIS\n              | WS? version_many WS?\n    \"\"\"\n    with tokenizer.enclosing_tokens(\n        \"LEFT_PARENTHESIS\",\n        \"RIGHT_PARENTHESIS\",\n        around=\"version specifier\",\n    ):\n        tokenizer.consume(\"WS\")\n        parsed_specifiers = _parse_version_many(tokenizer)\n        tokenizer.consume(\"WS\")\n\n    return parsed_specifiers\n\n\ndef _parse_version_many(tokenizer: Tokenizer) -> str:\n    \"\"\"\n    version_many = (SPECIFIER (WS? COMMA WS? SPECIFIER)*)?\n    \"\"\"\n    parsed_specifiers = \"\"\n    while tokenizer.check(\"SPECIFIER\"):\n        span_start = tokenizer.position\n        parsed_specifiers += tokenizer.read().text\n        if tokenizer.check(\"VERSION_PREFIX_TRAIL\", peek=True):\n            tokenizer.raise_syntax_error(\n                \".* suffix can only be used with `==` or `!=` operators\",\n                span_start=span_start,\n                span_end=tokenizer.position + 1,\n            )\n        if tokenizer.check(\"VERSION_LOCAL_LABEL_TRAIL\", peek=True):\n            tokenizer.raise_syntax_error(\n                \"Local version label can only be used with `==` or `!=` operators\",\n                span_start=span_start,\n                span_end=tokenizer.position,\n            )\n        tokenizer.consume(\"WS\")\n        if not tokenizer.check(\"COMMA\"):\n            break\n        parsed_specifiers += tokenizer.read().text\n        tokenizer.consume(\"WS\")\n\n    return parsed_specifiers\n\n\n# --------------------------------------------------------------------------------------\n# Recursive descent parser for marker expression\n# --------------------------------------------------------------------------------------\ndef parse_marker(source: str) -> MarkerList:\n    return _parse_full_marker(Tokenizer(source, rules=DEFAULT_RULES))\n\n\ndef _parse_full_marker(tokenizer: Tokenizer) -> MarkerList:\n    retval = _parse_marker(tokenizer)\n    tokenizer.expect(\"END\", expected=\"end of marker expression\")\n    return retval\n\n\ndef _parse_marker(tokenizer: Tokenizer) -> MarkerList:\n    \"\"\"\n    marker = marker_atom (BOOLOP marker_atom)+\n    \"\"\"\n    expression = [_parse_marker_atom(tokenizer)]\n    while tokenizer.check(\"BOOLOP\"):\n        token = tokenizer.read()\n        expr_right = _parse_marker_atom(tokenizer)\n        expression.extend((token.text, expr_right))\n    return expression\n\n\ndef _parse_marker_atom(tokenizer: Tokenizer) -> MarkerAtom:\n    \"\"\"\n    marker_atom = WS? LEFT_PARENTHESIS WS? marker WS? RIGHT_PARENTHESIS WS?\n                | WS? marker_item WS?\n    \"\"\"\n\n    tokenizer.consume(\"WS\")\n    if tokenizer.check(\"LEFT_PARENTHESIS\", peek=True):\n        with tokenizer.enclosing_tokens(\n            \"LEFT_PARENTHESIS\",\n            \"RIGHT_PARENTHESIS\",\n            around=\"marker expression\",\n        ):\n            tokenizer.consume(\"WS\")\n            marker: MarkerAtom = _parse_marker(tokenizer)\n            tokenizer.consume(\"WS\")\n    else:\n        marker = _parse_marker_item(tokenizer)\n    tokenizer.consume(\"WS\")\n    return marker\n\n\ndef _parse_marker_item(tokenizer: Tokenizer) -> MarkerItem:\n    \"\"\"\n    marker_item = WS? marker_var WS? marker_op WS? marker_var WS?\n    \"\"\"\n    tokenizer.consume(\"WS\")\n    marker_var_left = _parse_marker_var(tokenizer)\n    tokenizer.consume(\"WS\")\n    marker_op = _parse_marker_op(tokenizer)\n    tokenizer.consume(\"WS\")\n    marker_var_right = _parse_marker_var(tokenizer)\n    tokenizer.consume(\"WS\")\n    return (marker_var_left, marker_op, marker_var_right)\n\n\ndef _parse_marker_var(tokenizer: Tokenizer) -> MarkerVar:\n    \"\"\"\n    marker_var = VARIABLE | QUOTED_STRING\n    \"\"\"\n    if tokenizer.check(\"VARIABLE\"):\n        return process_env_var(tokenizer.read().text.replace(\".\", \"_\"))\n    elif tokenizer.check(\"QUOTED_STRING\"):\n        return process_python_str(tokenizer.read().text)\n    else:\n        tokenizer.raise_syntax_error(\n            message=\"Expected a marker variable or quoted string\"\n        )\n\n\ndef process_env_var(env_var: str) -> Variable:\n    if env_var in (\"platform_python_implementation\", \"python_implementation\"):\n        return Variable(\"platform_python_implementation\")\n    else:\n        return Variable(env_var)\n\n\ndef process_python_str(python_str: str) -> Value:\n    value = ast.literal_eval(python_str)\n    return Value(str(value))\n\n\ndef _parse_marker_op(tokenizer: Tokenizer) -> Op:\n    \"\"\"\n    marker_op = IN | NOT IN | OP\n    \"\"\"\n    if tokenizer.check(\"IN\"):\n        tokenizer.read()\n        return Op(\"in\")\n    elif tokenizer.check(\"NOT\"):\n        tokenizer.read()\n        tokenizer.expect(\"WS\", expected=\"whitespace after 'not'\")\n        tokenizer.expect(\"IN\", expected=\"'in' after 'not'\")\n        return Op(\"not in\")\n    elif tokenizer.check(\"OP\"):\n        return Op(tokenizer.read().text)\n    else:\n        return tokenizer.raise_syntax_error(\n            \"Expected marker operator, one of \"\n            \"<=, <, !=, ==, >=, >, ~=, ===, in, not in\"\n        )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/packaging/_structures.py","size":1431,"sha1":"fe0c3747cf14e696276cb6806c6775503de002b8","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nclass InfinityType:\n    def __repr__(self) -> str:\n        return \"Infinity\"\n\n    def __hash__(self) -> int:\n        return hash(repr(self))\n\n    def __lt__(self, other: object) -> bool:\n        return False\n\n    def __le__(self, other: object) -> bool:\n        return False\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__)\n\n    def __gt__(self, other: object) -> bool:\n        return True\n\n    def __ge__(self, other: object) -> bool:\n        return True\n\n    def __neg__(self: object) -> \"NegativeInfinityType\":\n        return NegativeInfinity\n\n\nInfinity = InfinityType()\n\n\nclass NegativeInfinityType:\n    def __repr__(self) -> str:\n        return \"-Infinity\"\n\n    def __hash__(self) -> int:\n        return hash(repr(self))\n\n    def __lt__(self, other: object) -> bool:\n        return True\n\n    def __le__(self, other: object) -> bool:\n        return True\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__)\n\n    def __gt__(self, other: object) -> bool:\n        return False\n\n    def __ge__(self, other: object) -> bool:\n        return False\n\n    def __neg__(self: object) -> InfinityType:\n        return Infinity\n\n\nNegativeInfinity = NegativeInfinityType()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/packaging/_tokenizer.py","size":5273,"sha1":"575e0d0d9f6bae73faccb96833494626bd81fbef","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport contextlib\nimport re\nfrom dataclasses import dataclass\nfrom typing import Iterator, NoReturn\n\nfrom .specifiers import Specifier\n\n\n@dataclass\nclass Token:\n    name: str\n    text: str\n    position: int\n\n\nclass ParserSyntaxError(Exception):\n    \"\"\"The provided source text could not be parsed correctly.\"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        *,\n        source: str,\n        span: tuple[int, int],\n    ) -> None:\n        self.span = span\n        self.message = message\n        self.source = source\n\n        super().__init__()\n\n    def __str__(self) -> str:\n        marker = \" \" * self.span[0] + \"~\" * (self.span[1] - self.span[0]) + \"^\"\n        return \"\\n    \".join([self.message, self.source, marker])\n\n\nDEFAULT_RULES: dict[str, str | re.Pattern[str]] = {\n    \"LEFT_PARENTHESIS\": r\"\\(\",\n    \"RIGHT_PARENTHESIS\": r\"\\)\",\n    \"LEFT_BRACKET\": r\"\\[\",\n    \"RIGHT_BRACKET\": r\"\\]\",\n    \"SEMICOLON\": r\";\",\n    \"COMMA\": r\",\",\n    \"QUOTED_STRING\": re.compile(\n        r\"\"\"\n            (\n                ('[^']*')\n                |\n                (\"[^\"]*\")\n            )\n        \"\"\",\n        re.VERBOSE,\n    ),\n    \"OP\": r\"(===|==|~=|!=|<=|>=|<|>)\",\n    \"BOOLOP\": r\"\\b(or|and)\\b\",\n    \"IN\": r\"\\bin\\b\",\n    \"NOT\": r\"\\bnot\\b\",\n    \"VARIABLE\": re.compile(\n        r\"\"\"\n            \\b(\n                python_version\n                |python_full_version\n                |os[._]name\n                |sys[._]platform\n                |platform_(release|system)\n                |platform[._](version|machine|python_implementation)\n                |python_implementation\n                |implementation_(name|version)\n                |extra\n            )\\b\n        \"\"\",\n        re.VERBOSE,\n    ),\n    \"SPECIFIER\": re.compile(\n        Specifier._operator_regex_str + Specifier._version_regex_str,\n        re.VERBOSE | re.IGNORECASE,\n    ),\n    \"AT\": r\"\\@\",\n    \"URL\": r\"[^ \\t]+\",\n    \"IDENTIFIER\": r\"\\b[a-zA-Z0-9][a-zA-Z0-9._-]*\\b\",\n    \"VERSION_PREFIX_TRAIL\": r\"\\.\\*\",\n    \"VERSION_LOCAL_LABEL_TRAIL\": r\"\\+[a-z0-9]+(?:[-_\\.][a-z0-9]+)*\",\n    \"WS\": r\"[ \\t]+\",\n    \"END\": r\"$\",\n}\n\n\nclass Tokenizer:\n    \"\"\"Context-sensitive token parsing.\n\n    Provides methods to examine the input stream to check whether the next token\n    matches.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: str,\n        *,\n        rules: dict[str, str | re.Pattern[str]],\n    ) -> None:\n        self.source = source\n        self.rules: dict[str, re.Pattern[str]] = {\n            name: re.compile(pattern) for name, pattern in rules.items()\n        }\n        self.next_token: Token | None = None\n        self.position = 0\n\n    def consume(self, name: str) -> None:\n        \"\"\"Move beyond provided token name, if at current position.\"\"\"\n        if self.check(name):\n            self.read()\n\n    def check(self, name: str, *, peek: bool = False) -> bool:\n        \"\"\"Check whether the next token has the provided name.\n\n        By default, if the check succeeds, the token *must* be read before\n        another check. If `peek` is set to `True`, the token is not loaded and\n        would need to be checked again.\n        \"\"\"\n        assert (\n            self.next_token is None\n        ), f\"Cannot check for {name!r}, already have {self.next_token!r}\"\n        assert name in self.rules, f\"Unknown token name: {name!r}\"\n\n        expression = self.rules[name]\n\n        match = expression.match(self.source, self.position)\n        if match is None:\n            return False\n        if not peek:\n            self.next_token = Token(name, match[0], self.position)\n        return True\n\n    def expect(self, name: str, *, expected: str) -> Token:\n        \"\"\"Expect a certain token name next, failing with a syntax error otherwise.\n\n        The token is *not* read.\n        \"\"\"\n        if not self.check(name):\n            raise self.raise_syntax_error(f\"Expected {expected}\")\n        return self.read()\n\n    def read(self) -> Token:\n        \"\"\"Consume the next token and return it.\"\"\"\n        token = self.next_token\n        assert token is not None\n\n        self.position += len(token.text)\n        self.next_token = None\n\n        return token\n\n    def raise_syntax_error(\n        self,\n        message: str,\n        *,\n        span_start: int | None = None,\n        span_end: int | None = None,\n    ) -> NoReturn:\n        \"\"\"Raise ParserSyntaxError at the given position.\"\"\"\n        span = (\n            self.position if span_start is None else span_start,\n            self.position if span_end is None else span_end,\n        )\n        raise ParserSyntaxError(\n            message,\n            source=self.source,\n            span=span,\n        )\n\n    @contextlib.contextmanager\n    def enclosing_tokens(\n        self, open_token: str, close_token: str, *, around: str\n    ) -> Iterator[None]:\n        if self.check(open_token):\n            open_position = self.position\n            self.read()\n        else:\n            open_position = None\n\n        yield\n\n        if open_position is None:\n            return\n\n        if not self.check(close_token):\n            self.raise_syntax_error(\n                f\"Expected matching {close_token} for {open_token}, after {around}\",\n                span_start=open_position,\n            )\n\n        self.read()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/packaging/licenses/__init__.py","size":5727,"sha1":"437086b2bb9f3aae9abc33f66dff2b1e726af521","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"#######################################################################################\n#\n# Adapted from:\n#  https://github.com/pypa/hatch/blob/5352e44/backend/src/hatchling/licenses/parse.py\n#\n# MIT License\n#\n# Copyright (c) 2017-present Ofek Lev <oss@ofek.dev>\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy of this\n# software and associated documentation files (the \"Software\"), to deal in the Software\n# without restriction, including without limitation the rights to use, copy, modify,\n# merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to the following\n# conditions:\n#\n# The above copyright notice and this permission notice shall be included in all copies\n# or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#\n#\n# With additional allowance of arbitrary `LicenseRef-` identifiers, not just\n# `LicenseRef-Public-Domain` and `LicenseRef-Proprietary`.\n#\n#######################################################################################\nfrom __future__ import annotations\n\nimport re\nfrom typing import NewType, cast\n\nfrom pip._vendor.packaging.licenses._spdx import EXCEPTIONS, LICENSES\n\n__all__ = [\n    \"NormalizedLicenseExpression\",\n    \"InvalidLicenseExpression\",\n    \"canonicalize_license_expression\",\n]\n\nlicense_ref_allowed = re.compile(\"^[A-Za-z0-9.-]*$\")\n\nNormalizedLicenseExpression = NewType(\"NormalizedLicenseExpression\", str)\n\n\nclass InvalidLicenseExpression(ValueError):\n    \"\"\"Raised when a license-expression string is invalid\n\n    >>> canonicalize_license_expression(\"invalid\")\n    Traceback (most recent call last):\n        ...\n    packaging.licenses.InvalidLicenseExpression: Invalid license expression: 'invalid'\n    \"\"\"\n\n\ndef canonicalize_license_expression(\n    raw_license_expression: str,\n) -> NormalizedLicenseExpression:\n    if not raw_license_expression:\n        message = f\"Invalid license expression: {raw_license_expression!r}\"\n        raise InvalidLicenseExpression(message)\n\n    # Pad any parentheses so tokenization can be achieved by merely splitting on\n    # whitespace.\n    license_expression = raw_license_expression.replace(\"(\", \" ( \").replace(\")\", \" ) \")\n    licenseref_prefix = \"LicenseRef-\"\n    license_refs = {\n        ref.lower(): \"LicenseRef-\" + ref[len(licenseref_prefix) :]\n        for ref in license_expression.split()\n        if ref.lower().startswith(licenseref_prefix.lower())\n    }\n\n    # Normalize to lower case so we can look up licenses/exceptions\n    # and so boolean operators are Python-compatible.\n    license_expression = license_expression.lower()\n\n    tokens = license_expression.split()\n\n    # Rather than implementing boolean logic, we create an expression that Python can\n    # parse. Everything that is not involved with the grammar itself is treated as\n    # `False` and the expression should evaluate as such.\n    python_tokens = []\n    for token in tokens:\n        if token not in {\"or\", \"and\", \"with\", \"(\", \")\"}:\n            python_tokens.append(\"False\")\n        elif token == \"with\":\n            python_tokens.append(\"or\")\n        elif token == \"(\" and python_tokens and python_tokens[-1] not in {\"or\", \"and\"}:\n            message = f\"Invalid license expression: {raw_license_expression!r}\"\n            raise InvalidLicenseExpression(message)\n        else:\n            python_tokens.append(token)\n\n    python_expression = \" \".join(python_tokens)\n    try:\n        invalid = eval(python_expression, globals(), locals())\n    except Exception:\n        invalid = True\n\n    if invalid is not False:\n        message = f\"Invalid license expression: {raw_license_expression!r}\"\n        raise InvalidLicenseExpression(message) from None\n\n    # Take a final pass to check for unknown licenses/exceptions.\n    normalized_tokens = []\n    for token in tokens:\n        if token in {\"or\", \"and\", \"with\", \"(\", \")\"}:\n            normalized_tokens.append(token.upper())\n            continue\n\n        if normalized_tokens and normalized_tokens[-1] == \"WITH\":\n            if token not in EXCEPTIONS:\n                message = f\"Unknown license exception: {token!r}\"\n                raise InvalidLicenseExpression(message)\n\n            normalized_tokens.append(EXCEPTIONS[token][\"id\"])\n        else:\n            if token.endswith(\"+\"):\n                final_token = token[:-1]\n                suffix = \"+\"\n            else:\n                final_token = token\n                suffix = \"\"\n\n            if final_token.startswith(\"licenseref-\"):\n                if not license_ref_allowed.match(final_token):\n                    message = f\"Invalid licenseref: {final_token!r}\"\n                    raise InvalidLicenseExpression(message)\n                normalized_tokens.append(license_refs[final_token] + suffix)\n            else:\n                if final_token not in LICENSES:\n                    message = f\"Unknown license: {final_token!r}\"\n                    raise InvalidLicenseExpression(message)\n                normalized_tokens.append(LICENSES[final_token][\"id\"] + suffix)\n\n    normalized_expression = \" \".join(normalized_tokens)\n\n    return cast(\n        NormalizedLicenseExpression,\n        normalized_expression.replace(\"( \", \"(\").replace(\" )\", \")\"),\n    )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/packaging/licenses/_spdx.py","size":48398,"sha1":"ebf0b2cfba0cef0c64c1094323f97f7c40f0fc73","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\nfrom __future__ import annotations\n\nfrom typing import TypedDict\n\nclass SPDXLicense(TypedDict):\n    id: str\n    deprecated: bool\n\nclass SPDXException(TypedDict):\n    id: str\n    deprecated: bool\n\n\nVERSION = '3.25.0'\n\nLICENSES: dict[str, SPDXLicense] = {\n    '0bsd': {'id': '0BSD', 'deprecated': False},\n    '3d-slicer-1.0': {'id': '3D-Slicer-1.0', 'deprecated': False},\n    'aal': {'id': 'AAL', 'deprecated': False},\n    'abstyles': {'id': 'Abstyles', 'deprecated': False},\n    'adacore-doc': {'id': 'AdaCore-doc', 'deprecated': False},\n    'adobe-2006': {'id': 'Adobe-2006', 'deprecated': False},\n    'adobe-display-postscript': {'id': 'Adobe-Display-PostScript', 'deprecated': False},\n    'adobe-glyph': {'id': 'Adobe-Glyph', 'deprecated': False},\n    'adobe-utopia': {'id': 'Adobe-Utopia', 'deprecated': False},\n    'adsl': {'id': 'ADSL', 'deprecated': False},\n    'afl-1.1': {'id': 'AFL-1.1', 'deprecated': False},\n    'afl-1.2': {'id': 'AFL-1.2', 'deprecated': False},\n    'afl-2.0': {'id': 'AFL-2.0', 'deprecated': False},\n    'afl-2.1': {'id': 'AFL-2.1', 'deprecated': False},\n    'afl-3.0': {'id': 'AFL-3.0', 'deprecated': False},\n    'afmparse': {'id': 'Afmparse', 'deprecated': False},\n    'agpl-1.0': {'id': 'AGPL-1.0', 'deprecated': True},\n    'agpl-1.0-only': {'id': 'AGPL-1.0-only', 'deprecated': False},\n    'agpl-1.0-or-later': {'id': 'AGPL-1.0-or-later', 'deprecated': False},\n    'agpl-3.0': {'id': 'AGPL-3.0', 'deprecated': True},\n    'agpl-3.0-only': {'id': 'AGPL-3.0-only', 'deprecated': False},\n    'agpl-3.0-or-later': {'id': 'AGPL-3.0-or-later', 'deprecated': False},\n    'aladdin': {'id': 'Aladdin', 'deprecated': False},\n    'amd-newlib': {'id': 'AMD-newlib', 'deprecated': False},\n    'amdplpa': {'id': 'AMDPLPA', 'deprecated': False},\n    'aml': {'id': 'AML', 'deprecated': False},\n    'aml-glslang': {'id': 'AML-glslang', 'deprecated': False},\n    'ampas': {'id': 'AMPAS', 'deprecated': False},\n    'antlr-pd': {'id': 'ANTLR-PD', 'deprecated': False},\n    'antlr-pd-fallback': {'id': 'ANTLR-PD-fallback', 'deprecated': False},\n    'any-osi': {'id': 'any-OSI', 'deprecated': False},\n    'apache-1.0': {'id': 'Apache-1.0', 'deprecated': False},\n    'apache-1.1': {'id': 'Apache-1.1', 'deprecated': False},\n    'apache-2.0': {'id': 'Apache-2.0', 'deprecated': False},\n    'apafml': {'id': 'APAFML', 'deprecated': False},\n    'apl-1.0': {'id': 'APL-1.0', 'deprecated': False},\n    'app-s2p': {'id': 'App-s2p', 'deprecated': False},\n    'apsl-1.0': {'id': 'APSL-1.0', 'deprecated': False},\n    'apsl-1.1': {'id': 'APSL-1.1', 'deprecated': False},\n    'apsl-1.2': {'id': 'APSL-1.2', 'deprecated': False},\n    'apsl-2.0': {'id': 'APSL-2.0', 'deprecated': False},\n    'arphic-1999': {'id': 'Arphic-1999', 'deprecated': False},\n    'artistic-1.0': {'id': 'Artistic-1.0', 'deprecated': False},\n    'artistic-1.0-cl8': {'id': 'Artistic-1.0-cl8', 'deprecated': False},\n    'artistic-1.0-perl': {'id': 'Artistic-1.0-Perl', 'deprecated': False},\n    'artistic-2.0': {'id': 'Artistic-2.0', 'deprecated': False},\n    'aswf-digital-assets-1.0': {'id': 'ASWF-Digital-Assets-1.0', 'deprecated': False},\n    'aswf-digital-assets-1.1': {'id': 'ASWF-Digital-Assets-1.1', 'deprecated': False},\n    'baekmuk': {'id': 'Baekmuk', 'deprecated': False},\n    'bahyph': {'id': 'Bahyph', 'deprecated': False},\n    'barr': {'id': 'Barr', 'deprecated': False},\n    'bcrypt-solar-designer': {'id': 'bcrypt-Solar-Designer', 'deprecated': False},\n    'beerware': {'id': 'Beerware', 'deprecated': False},\n    'bitstream-charter': {'id': 'Bitstream-Charter', 'deprecated': False},\n    'bitstream-vera': {'id': 'Bitstream-Vera', 'deprecated': False},\n    'bittorrent-1.0': {'id': 'BitTorrent-1.0', 'deprecated': False},\n    'bittorrent-1.1': {'id': 'BitTorrent-1.1', 'deprecated': False},\n    'blessing': {'id': 'blessing', 'deprecated': False},\n    'blueoak-1.0.0': {'id': 'BlueOak-1.0.0', 'deprecated': False},\n    'boehm-gc': {'id': 'Boehm-GC', 'deprecated': False},\n    'borceux': {'id': 'Borceux', 'deprecated': False},\n    'brian-gladman-2-clause': {'id': 'Brian-Gladman-2-Clause', 'deprecated': False},\n    'brian-gladman-3-clause': {'id': 'Brian-Gladman-3-Clause', 'deprecated': False},\n    'bsd-1-clause': {'id': 'BSD-1-Clause', 'deprecated': False},\n    'bsd-2-clause': {'id': 'BSD-2-Clause', 'deprecated': False},\n    'bsd-2-clause-darwin': {'id': 'BSD-2-Clause-Darwin', 'deprecated': False},\n    'bsd-2-clause-first-lines': {'id': 'BSD-2-Clause-first-lines', 'deprecated': False},\n    'bsd-2-clause-freebsd': {'id': 'BSD-2-Clause-FreeBSD', 'deprecated': True},\n    'bsd-2-clause-netbsd': {'id': 'BSD-2-Clause-NetBSD', 'deprecated': True},\n    'bsd-2-clause-patent': {'id': 'BSD-2-Clause-Patent', 'deprecated': False},\n    'bsd-2-clause-views': {'id': 'BSD-2-Clause-Views', 'deprecated': False},\n    'bsd-3-clause': {'id': 'BSD-3-Clause', 'deprecated': False},\n    'bsd-3-clause-acpica': {'id': 'BSD-3-Clause-acpica', 'deprecated': False},\n    'bsd-3-clause-attribution': {'id': 'BSD-3-Clause-Attribution', 'deprecated': False},\n    'bsd-3-clause-clear': {'id': 'BSD-3-Clause-Clear', 'deprecated': False},\n    'bsd-3-clause-flex': {'id': 'BSD-3-Clause-flex', 'deprecated': False},\n    'bsd-3-clause-hp': {'id': 'BSD-3-Clause-HP', 'deprecated': False},\n    'bsd-3-clause-lbnl': {'id': 'BSD-3-Clause-LBNL', 'deprecated': False},\n    'bsd-3-clause-modification': {'id': 'BSD-3-Clause-Modification', 'deprecated': False},\n    'bsd-3-clause-no-military-license': {'id': 'BSD-3-Clause-No-Military-License', 'deprecated': False},\n    'bsd-3-clause-no-nuclear-license': {'id': 'BSD-3-Clause-No-Nuclear-License', 'deprecated': False},\n    'bsd-3-clause-no-nuclear-license-2014': {'id': 'BSD-3-Clause-No-Nuclear-License-2014', 'deprecated': False},\n    'bsd-3-clause-no-nuclear-warranty': {'id': 'BSD-3-Clause-No-Nuclear-Warranty', 'deprecated': False},\n    'bsd-3-clause-open-mpi': {'id': 'BSD-3-Clause-Open-MPI', 'deprecated': False},\n    'bsd-3-clause-sun': {'id': 'BSD-3-Clause-Sun', 'deprecated': False},\n    'bsd-4-clause': {'id': 'BSD-4-Clause', 'deprecated': False},\n    'bsd-4-clause-shortened': {'id': 'BSD-4-Clause-Shortened', 'deprecated': False},\n    'bsd-4-clause-uc': {'id': 'BSD-4-Clause-UC', 'deprecated': False},\n    'bsd-4.3reno': {'id': 'BSD-4.3RENO', 'deprecated': False},\n    'bsd-4.3tahoe': {'id': 'BSD-4.3TAHOE', 'deprecated': False},\n    'bsd-advertising-acknowledgement': {'id': 'BSD-Advertising-Acknowledgement', 'deprecated': False},\n    'bsd-attribution-hpnd-disclaimer': {'id': 'BSD-Attribution-HPND-disclaimer', 'deprecated': False},\n    'bsd-inferno-nettverk': {'id': 'BSD-Inferno-Nettverk', 'deprecated': False},\n    'bsd-protection': {'id': 'BSD-Protection', 'deprecated': False},\n    'bsd-source-beginning-file': {'id': 'BSD-Source-beginning-file', 'deprecated': False},\n    'bsd-source-code': {'id': 'BSD-Source-Code', 'deprecated': False},\n    'bsd-systemics': {'id': 'BSD-Systemics', 'deprecated': False},\n    'bsd-systemics-w3works': {'id': 'BSD-Systemics-W3Works', 'deprecated': False},\n    'bsl-1.0': {'id': 'BSL-1.0', 'deprecated': False},\n    'busl-1.1': {'id': 'BUSL-1.1', 'deprecated': False},\n    'bzip2-1.0.5': {'id': 'bzip2-1.0.5', 'deprecated': True},\n    'bzip2-1.0.6': {'id': 'bzip2-1.0.6', 'deprecated': False},\n    'c-uda-1.0': {'id': 'C-UDA-1.0', 'deprecated': False},\n    'cal-1.0': {'id': 'CAL-1.0', 'deprecated': False},\n    'cal-1.0-combined-work-exception': {'id': 'CAL-1.0-Combined-Work-Exception', 'deprecated': False},\n    'caldera': {'id': 'Caldera', 'deprecated': False},\n    'caldera-no-preamble': {'id': 'Caldera-no-preamble', 'deprecated': False},\n    'catharon': {'id': 'Catharon', 'deprecated': False},\n    'catosl-1.1': {'id': 'CATOSL-1.1', 'deprecated': False},\n    'cc-by-1.0': {'id': 'CC-BY-1.0', 'deprecated': False},\n    'cc-by-2.0': {'id': 'CC-BY-2.0', 'deprecated': False},\n    'cc-by-2.5': {'id': 'CC-BY-2.5', 'deprecated': False},\n    'cc-by-2.5-au': {'id': 'CC-BY-2.5-AU', 'deprecated': False},\n    'cc-by-3.0': {'id': 'CC-BY-3.0', 'deprecated': False},\n    'cc-by-3.0-at': {'id': 'CC-BY-3.0-AT', 'deprecated': False},\n    'cc-by-3.0-au': {'id': 'CC-BY-3.0-AU', 'deprecated': False},\n    'cc-by-3.0-de': {'id': 'CC-BY-3.0-DE', 'deprecated': False},\n    'cc-by-3.0-igo': {'id': 'CC-BY-3.0-IGO', 'deprecated': False},\n    'cc-by-3.0-nl': {'id': 'CC-BY-3.0-NL', 'deprecated': False},\n    'cc-by-3.0-us': {'id': 'CC-BY-3.0-US', 'deprecated': False},\n    'cc-by-4.0': {'id': 'CC-BY-4.0', 'deprecated': False},\n    'cc-by-nc-1.0': {'id': 'CC-BY-NC-1.0', 'deprecated': False},\n    'cc-by-nc-2.0': {'id': 'CC-BY-NC-2.0', 'deprecated': False},\n    'cc-by-nc-2.5': {'id': 'CC-BY-NC-2.5', 'deprecated': False},\n    'cc-by-nc-3.0': {'id': 'CC-BY-NC-3.0', 'deprecated': False},\n    'cc-by-nc-3.0-de': {'id': 'CC-BY-NC-3.0-DE', 'deprecated': False},\n    'cc-by-nc-4.0': {'id': 'CC-BY-NC-4.0', 'deprecated': False},\n    'cc-by-nc-nd-1.0': {'id': 'CC-BY-NC-ND-1.0', 'deprecated': False},\n    'cc-by-nc-nd-2.0': {'id': 'CC-BY-NC-ND-2.0', 'deprecated': False},\n    'cc-by-nc-nd-2.5': {'id': 'CC-BY-NC-ND-2.5', 'deprecated': False},\n    'cc-by-nc-nd-3.0': {'id': 'CC-BY-NC-ND-3.0', 'deprecated': False},\n    'cc-by-nc-nd-3.0-de': {'id': 'CC-BY-NC-ND-3.0-DE', 'deprecated': False},\n    'cc-by-nc-nd-3.0-igo': {'id': 'CC-BY-NC-ND-3.0-IGO', 'deprecated': False},\n    'cc-by-nc-nd-4.0': {'id': 'CC-BY-NC-ND-4.0', 'deprecated': False},\n    'cc-by-nc-sa-1.0': {'id': 'CC-BY-NC-SA-1.0', 'deprecated': False},\n    'cc-by-nc-sa-2.0': {'id': 'CC-BY-NC-SA-2.0', 'deprecated': False},\n    'cc-by-nc-sa-2.0-de': {'id': 'CC-BY-NC-SA-2.0-DE', 'deprecated': False},\n    'cc-by-nc-sa-2.0-fr': {'id': 'CC-BY-NC-SA-2.0-FR', 'deprecated': False},\n    'cc-by-nc-sa-2.0-uk': {'id': 'CC-BY-NC-SA-2.0-UK', 'deprecated': False},\n    'cc-by-nc-sa-2.5': {'id': 'CC-BY-NC-SA-2.5', 'deprecated': False},\n    'cc-by-nc-sa-3.0': {'id': 'CC-BY-NC-SA-3.0', 'deprecated': False},\n    'cc-by-nc-sa-3.0-de': {'id': 'CC-BY-NC-SA-3.0-DE', 'deprecated': False},\n    'cc-by-nc-sa-3.0-igo': {'id': 'CC-BY-NC-SA-3.0-IGO', 'deprecated': False},\n    'cc-by-nc-sa-4.0': {'id': 'CC-BY-NC-SA-4.0', 'deprecated': False},\n    'cc-by-nd-1.0': {'id': 'CC-BY-ND-1.0', 'deprecated': False},\n    'cc-by-nd-2.0': {'id': 'CC-BY-ND-2.0', 'deprecated': False},\n    'cc-by-nd-2.5': {'id': 'CC-BY-ND-2.5', 'deprecated': False},\n    'cc-by-nd-3.0': {'id': 'CC-BY-ND-3.0', 'deprecated': False},\n    'cc-by-nd-3.0-de': {'id': 'CC-BY-ND-3.0-DE', 'deprecated': False},\n    'cc-by-nd-4.0': {'id': 'CC-BY-ND-4.0', 'deprecated': False},\n    'cc-by-sa-1.0': {'id': 'CC-BY-SA-1.0', 'deprecated': False},\n    'cc-by-sa-2.0': {'id': 'CC-BY-SA-2.0', 'deprecated': False},\n    'cc-by-sa-2.0-uk': {'id': 'CC-BY-SA-2.0-UK', 'deprecated': False},\n    'cc-by-sa-2.1-jp': {'id': 'CC-BY-SA-2.1-JP', 'deprecated': False},\n    'cc-by-sa-2.5': {'id': 'CC-BY-SA-2.5', 'deprecated': False},\n    'cc-by-sa-3.0': {'id': 'CC-BY-SA-3.0', 'deprecated': False},\n    'cc-by-sa-3.0-at': {'id': 'CC-BY-SA-3.0-AT', 'deprecated': False},\n    'cc-by-sa-3.0-de': {'id': 'CC-BY-SA-3.0-DE', 'deprecated': False},\n    'cc-by-sa-3.0-igo': {'id': 'CC-BY-SA-3.0-IGO', 'deprecated': False},\n    'cc-by-sa-4.0': {'id': 'CC-BY-SA-4.0', 'deprecated': False},\n    'cc-pddc': {'id': 'CC-PDDC', 'deprecated': False},\n    'cc0-1.0': {'id': 'CC0-1.0', 'deprecated': False},\n    'cddl-1.0': {'id': 'CDDL-1.0', 'deprecated': False},\n    'cddl-1.1': {'id': 'CDDL-1.1', 'deprecated': False},\n    'cdl-1.0': {'id': 'CDL-1.0', 'deprecated': False},\n    'cdla-permissive-1.0': {'id': 'CDLA-Permissive-1.0', 'deprecated': False},\n    'cdla-permissive-2.0': {'id': 'CDLA-Permissive-2.0', 'deprecated': False},\n    'cdla-sharing-1.0': {'id': 'CDLA-Sharing-1.0', 'deprecated': False},\n    'cecill-1.0': {'id': 'CECILL-1.0', 'deprecated': False},\n    'cecill-1.1': {'id': 'CECILL-1.1', 'deprecated': False},\n    'cecill-2.0': {'id': 'CECILL-2.0', 'deprecated': False},\n    'cecill-2.1': {'id': 'CECILL-2.1', 'deprecated': False},\n    'cecill-b': {'id': 'CECILL-B', 'deprecated': False},\n    'cecill-c': {'id': 'CECILL-C', 'deprecated': False},\n    'cern-ohl-1.1': {'id': 'CERN-OHL-1.1', 'deprecated': False},\n    'cern-ohl-1.2': {'id': 'CERN-OHL-1.2', 'deprecated': False},\n    'cern-ohl-p-2.0': {'id': 'CERN-OHL-P-2.0', 'deprecated': False},\n    'cern-ohl-s-2.0': {'id': 'CERN-OHL-S-2.0', 'deprecated': False},\n    'cern-ohl-w-2.0': {'id': 'CERN-OHL-W-2.0', 'deprecated': False},\n    'cfitsio': {'id': 'CFITSIO', 'deprecated': False},\n    'check-cvs': {'id': 'check-cvs', 'deprecated': False},\n    'checkmk': {'id': 'checkmk', 'deprecated': False},\n    'clartistic': {'id': 'ClArtistic', 'deprecated': False},\n    'clips': {'id': 'Clips', 'deprecated': False},\n    'cmu-mach': {'id': 'CMU-Mach', 'deprecated': False},\n    'cmu-mach-nodoc': {'id': 'CMU-Mach-nodoc', 'deprecated': False},\n    'cnri-jython': {'id': 'CNRI-Jython', 'deprecated': False},\n    'cnri-python': {'id': 'CNRI-Python', 'deprecated': False},\n    'cnri-python-gpl-compatible': {'id': 'CNRI-Python-GPL-Compatible', 'deprecated': False},\n    'coil-1.0': {'id': 'COIL-1.0', 'deprecated': False},\n    'community-spec-1.0': {'id': 'Community-Spec-1.0', 'deprecated': False},\n    'condor-1.1': {'id': 'Condor-1.1', 'deprecated': False},\n    'copyleft-next-0.3.0': {'id': 'copyleft-next-0.3.0', 'deprecated': False},\n    'copyleft-next-0.3.1': {'id': 'copyleft-next-0.3.1', 'deprecated': False},\n    'cornell-lossless-jpeg': {'id': 'Cornell-Lossless-JPEG', 'deprecated': False},\n    'cpal-1.0': {'id': 'CPAL-1.0', 'deprecated': False},\n    'cpl-1.0': {'id': 'CPL-1.0', 'deprecated': False},\n    'cpol-1.02': {'id': 'CPOL-1.02', 'deprecated': False},\n    'cronyx': {'id': 'Cronyx', 'deprecated': False},\n    'crossword': {'id': 'Crossword', 'deprecated': False},\n    'crystalstacker': {'id': 'CrystalStacker', 'deprecated': False},\n    'cua-opl-1.0': {'id': 'CUA-OPL-1.0', 'deprecated': False},\n    'cube': {'id': 'Cube', 'deprecated': False},\n    'curl': {'id': 'curl', 'deprecated': False},\n    'cve-tou': {'id': 'cve-tou', 'deprecated': False},\n    'd-fsl-1.0': {'id': 'D-FSL-1.0', 'deprecated': False},\n    'dec-3-clause': {'id': 'DEC-3-Clause', 'deprecated': False},\n    'diffmark': {'id': 'diffmark', 'deprecated': False},\n    'dl-de-by-2.0': {'id': 'DL-DE-BY-2.0', 'deprecated': False},\n    'dl-de-zero-2.0': {'id': 'DL-DE-ZERO-2.0', 'deprecated': False},\n    'doc': {'id': 'DOC', 'deprecated': False},\n    'docbook-schema': {'id': 'DocBook-Schema', 'deprecated': False},\n    'docbook-xml': {'id': 'DocBook-XML', 'deprecated': False},\n    'dotseqn': {'id': 'Dotseqn', 'deprecated': False},\n    'drl-1.0': {'id': 'DRL-1.0', 'deprecated': False},\n    'drl-1.1': {'id': 'DRL-1.1', 'deprecated': False},\n    'dsdp': {'id': 'DSDP', 'deprecated': False},\n    'dtoa': {'id': 'dtoa', 'deprecated': False},\n    'dvipdfm': {'id': 'dvipdfm', 'deprecated': False},\n    'ecl-1.0': {'id': 'ECL-1.0', 'deprecated': False},\n    'ecl-2.0': {'id': 'ECL-2.0', 'deprecated': False},\n    'ecos-2.0': {'id': 'eCos-2.0', 'deprecated': True},\n    'efl-1.0': {'id': 'EFL-1.0', 'deprecated': False},\n    'efl-2.0': {'id': 'EFL-2.0', 'deprecated': False},\n    'egenix': {'id': 'eGenix', 'deprecated': False},\n    'elastic-2.0': {'id': 'Elastic-2.0', 'deprecated': False},\n    'entessa': {'id': 'Entessa', 'deprecated': False},\n    'epics': {'id': 'EPICS', 'deprecated': False},\n    'epl-1.0': {'id': 'EPL-1.0', 'deprecated': False},\n    'epl-2.0': {'id': 'EPL-2.0', 'deprecated': False},\n    'erlpl-1.1': {'id': 'ErlPL-1.1', 'deprecated': False},\n    'etalab-2.0': {'id': 'etalab-2.0', 'deprecated': False},\n    'eudatagrid': {'id': 'EUDatagrid', 'deprecated': False},\n    'eupl-1.0': {'id': 'EUPL-1.0', 'deprecated': False},\n    'eupl-1.1': {'id': 'EUPL-1.1', 'deprecated': False},\n    'eupl-1.2': {'id': 'EUPL-1.2', 'deprecated': False},\n    'eurosym': {'id': 'Eurosym', 'deprecated': False},\n    'fair': {'id': 'Fair', 'deprecated': False},\n    'fbm': {'id': 'FBM', 'deprecated': False},\n    'fdk-aac': {'id': 'FDK-AAC', 'deprecated': False},\n    'ferguson-twofish': {'id': 'Ferguson-Twofish', 'deprecated': False},\n    'frameworx-1.0': {'id': 'Frameworx-1.0', 'deprecated': False},\n    'freebsd-doc': {'id': 'FreeBSD-DOC', 'deprecated': False},\n    'freeimage': {'id': 'FreeImage', 'deprecated': False},\n    'fsfap': {'id': 'FSFAP', 'deprecated': False},\n    'fsfap-no-warranty-disclaimer': {'id': 'FSFAP-no-warranty-disclaimer', 'deprecated': False},\n    'fsful': {'id': 'FSFUL', 'deprecated': False},\n    'fsfullr': {'id': 'FSFULLR', 'deprecated': False},\n    'fsfullrwd': {'id': 'FSFULLRWD', 'deprecated': False},\n    'ftl': {'id': 'FTL', 'deprecated': False},\n    'furuseth': {'id': 'Furuseth', 'deprecated': False},\n    'fwlw': {'id': 'fwlw', 'deprecated': False},\n    'gcr-docs': {'id': 'GCR-docs', 'deprecated': False},\n    'gd': {'id': 'GD', 'deprecated': False},\n    'gfdl-1.1': {'id': 'GFDL-1.1', 'deprecated': True},\n    'gfdl-1.1-invariants-only': {'id': 'GFDL-1.1-invariants-only', 'deprecated': False},\n    'gfdl-1.1-invariants-or-later': {'id': 'GFDL-1.1-invariants-or-later', 'deprecated': False},\n    'gfdl-1.1-no-invariants-only': {'id': 'GFDL-1.1-no-invariants-only', 'deprecated': False},\n    'gfdl-1.1-no-invariants-or-later': {'id': 'GFDL-1.1-no-invariants-or-later', 'deprecated': False},\n    'gfdl-1.1-only': {'id': 'GFDL-1.1-only', 'deprecated': False},\n    'gfdl-1.1-or-later': {'id': 'GFDL-1.1-or-later', 'deprecated': False},\n    'gfdl-1.2': {'id': 'GFDL-1.2', 'deprecated': True},\n    'gfdl-1.2-invariants-only': {'id': 'GFDL-1.2-invariants-only', 'deprecated': False},\n    'gfdl-1.2-invariants-or-later': {'id': 'GFDL-1.2-invariants-or-later', 'deprecated': False},\n    'gfdl-1.2-no-invariants-only': {'id': 'GFDL-1.2-no-invariants-only', 'deprecated': False},\n    'gfdl-1.2-no-invariants-or-later': {'id': 'GFDL-1.2-no-invariants-or-later', 'deprecated': False},\n    'gfdl-1.2-only': {'id': 'GFDL-1.2-only', 'deprecated': False},\n    'gfdl-1.2-or-later': {'id': 'GFDL-1.2-or-later', 'deprecated': False},\n    'gfdl-1.3': {'id': 'GFDL-1.3', 'deprecated': True},\n    'gfdl-1.3-invariants-only': {'id': 'GFDL-1.3-invariants-only', 'deprecated': False},\n    'gfdl-1.3-invariants-or-later': {'id': 'GFDL-1.3-invariants-or-later', 'deprecated': False},\n    'gfdl-1.3-no-invariants-only': {'id': 'GFDL-1.3-no-invariants-only', 'deprecated': False},\n    'gfdl-1.3-no-invariants-or-later': {'id': 'GFDL-1.3-no-invariants-or-later', 'deprecated': False},\n    'gfdl-1.3-only': {'id': 'GFDL-1.3-only', 'deprecated': False},\n    'gfdl-1.3-or-later': {'id': 'GFDL-1.3-or-later', 'deprecated': False},\n    'giftware': {'id': 'Giftware', 'deprecated': False},\n    'gl2ps': {'id': 'GL2PS', 'deprecated': False},\n    'glide': {'id': 'Glide', 'deprecated': False},\n    'glulxe': {'id': 'Glulxe', 'deprecated': False},\n    'glwtpl': {'id': 'GLWTPL', 'deprecated': False},\n    'gnuplot': {'id': 'gnuplot', 'deprecated': False},\n    'gpl-1.0': {'id': 'GPL-1.0', 'deprecated': True},\n    'gpl-1.0+': {'id': 'GPL-1.0+', 'deprecated': True},\n    'gpl-1.0-only': {'id': 'GPL-1.0-only', 'deprecated': False},\n    'gpl-1.0-or-later': {'id': 'GPL-1.0-or-later', 'deprecated': False},\n    'gpl-2.0': {'id': 'GPL-2.0', 'deprecated': True},\n    'gpl-2.0+': {'id': 'GPL-2.0+', 'deprecated': True},\n    'gpl-2.0-only': {'id': 'GPL-2.0-only', 'deprecated': False},\n    'gpl-2.0-or-later': {'id': 'GPL-2.0-or-later', 'deprecated': False},\n    'gpl-2.0-with-autoconf-exception': {'id': 'GPL-2.0-with-autoconf-exception', 'deprecated': True},\n    'gpl-2.0-with-bison-exception': {'id': 'GPL-2.0-with-bison-exception', 'deprecated': True},\n    'gpl-2.0-with-classpath-exception': {'id': 'GPL-2.0-with-classpath-exception', 'deprecated': True},\n    'gpl-2.0-with-font-exception': {'id': 'GPL-2.0-with-font-exception', 'deprecated': True},\n    'gpl-2.0-with-gcc-exception': {'id': 'GPL-2.0-with-GCC-exception', 'deprecated': True},\n    'gpl-3.0': {'id': 'GPL-3.0', 'deprecated': True},\n    'gpl-3.0+': {'id': 'GPL-3.0+', 'deprecated': True},\n    'gpl-3.0-only': {'id': 'GPL-3.0-only', 'deprecated': False},\n    'gpl-3.0-or-later': {'id': 'GPL-3.0-or-later', 'deprecated': False},\n    'gpl-3.0-with-autoconf-exception': {'id': 'GPL-3.0-with-autoconf-exception', 'deprecated': True},\n    'gpl-3.0-with-gcc-exception': {'id': 'GPL-3.0-with-GCC-exception', 'deprecated': True},\n    'graphics-gems': {'id': 'Graphics-Gems', 'deprecated': False},\n    'gsoap-1.3b': {'id': 'gSOAP-1.3b', 'deprecated': False},\n    'gtkbook': {'id': 'gtkbook', 'deprecated': False},\n    'gutmann': {'id': 'Gutmann', 'deprecated': False},\n    'haskellreport': {'id': 'HaskellReport', 'deprecated': False},\n    'hdparm': {'id': 'hdparm', 'deprecated': False},\n    'hidapi': {'id': 'HIDAPI', 'deprecated': False},\n    'hippocratic-2.1': {'id': 'Hippocratic-2.1', 'deprecated': False},\n    'hp-1986': {'id': 'HP-1986', 'deprecated': False},\n    'hp-1989': {'id': 'HP-1989', 'deprecated': False},\n    'hpnd': {'id': 'HPND', 'deprecated': False},\n    'hpnd-dec': {'id': 'HPND-DEC', 'deprecated': False},\n    'hpnd-doc': {'id': 'HPND-doc', 'deprecated': False},\n    'hpnd-doc-sell': {'id': 'HPND-doc-sell', 'deprecated': False},\n    'hpnd-export-us': {'id': 'HPND-export-US', 'deprecated': False},\n    'hpnd-export-us-acknowledgement': {'id': 'HPND-export-US-acknowledgement', 'deprecated': False},\n    'hpnd-export-us-modify': {'id': 'HPND-export-US-modify', 'deprecated': False},\n    'hpnd-export2-us': {'id': 'HPND-export2-US', 'deprecated': False},\n    'hpnd-fenneberg-livingston': {'id': 'HPND-Fenneberg-Livingston', 'deprecated': False},\n    'hpnd-inria-imag': {'id': 'HPND-INRIA-IMAG', 'deprecated': False},\n    'hpnd-intel': {'id': 'HPND-Intel', 'deprecated': False},\n    'hpnd-kevlin-henney': {'id': 'HPND-Kevlin-Henney', 'deprecated': False},\n    'hpnd-markus-kuhn': {'id': 'HPND-Markus-Kuhn', 'deprecated': False},\n    'hpnd-merchantability-variant': {'id': 'HPND-merchantability-variant', 'deprecated': False},\n    'hpnd-mit-disclaimer': {'id': 'HPND-MIT-disclaimer', 'deprecated': False},\n    'hpnd-netrek': {'id': 'HPND-Netrek', 'deprecated': False},\n    'hpnd-pbmplus': {'id': 'HPND-Pbmplus', 'deprecated': False},\n    'hpnd-sell-mit-disclaimer-xserver': {'id': 'HPND-sell-MIT-disclaimer-xserver', 'deprecated': False},\n    'hpnd-sell-regexpr': {'id': 'HPND-sell-regexpr', 'deprecated': False},\n    'hpnd-sell-variant': {'id': 'HPND-sell-variant', 'deprecated': False},\n    'hpnd-sell-variant-mit-disclaimer': {'id': 'HPND-sell-variant-MIT-disclaimer', 'deprecated': False},\n    'hpnd-sell-variant-mit-disclaimer-rev': {'id': 'HPND-sell-variant-MIT-disclaimer-rev', 'deprecated': False},\n    'hpnd-uc': {'id': 'HPND-UC', 'deprecated': False},\n    'hpnd-uc-export-us': {'id': 'HPND-UC-export-US', 'deprecated': False},\n    'htmltidy': {'id': 'HTMLTIDY', 'deprecated': False},\n    'ibm-pibs': {'id': 'IBM-pibs', 'deprecated': False},\n    'icu': {'id': 'ICU', 'deprecated': False},\n    'iec-code-components-eula': {'id': 'IEC-Code-Components-EULA', 'deprecated': False},\n    'ijg': {'id': 'IJG', 'deprecated': False},\n    'ijg-short': {'id': 'IJG-short', 'deprecated': False},\n    'imagemagick': {'id': 'ImageMagick', 'deprecated': False},\n    'imatix': {'id': 'iMatix', 'deprecated': False},\n    'imlib2': {'id': 'Imlib2', 'deprecated': False},\n    'info-zip': {'id': 'Info-ZIP', 'deprecated': False},\n    'inner-net-2.0': {'id': 'Inner-Net-2.0', 'deprecated': False},\n    'intel': {'id': 'Intel', 'deprecated': False},\n    'intel-acpi': {'id': 'Intel-ACPI', 'deprecated': False},\n    'interbase-1.0': {'id': 'Interbase-1.0', 'deprecated': False},\n    'ipa': {'id': 'IPA', 'deprecated': False},\n    'ipl-1.0': {'id': 'IPL-1.0', 'deprecated': False},\n    'isc': {'id': 'ISC', 'deprecated': False},\n    'isc-veillard': {'id': 'ISC-Veillard', 'deprecated': False},\n    'jam': {'id': 'Jam', 'deprecated': False},\n    'jasper-2.0': {'id': 'JasPer-2.0', 'deprecated': False},\n    'jpl-image': {'id': 'JPL-image', 'deprecated': False},\n    'jpnic': {'id': 'JPNIC', 'deprecated': False},\n    'json': {'id': 'JSON', 'deprecated': False},\n    'kastrup': {'id': 'Kastrup', 'deprecated': False},\n    'kazlib': {'id': 'Kazlib', 'deprecated': False},\n    'knuth-ctan': {'id': 'Knuth-CTAN', 'deprecated': False},\n    'lal-1.2': {'id': 'LAL-1.2', 'deprecated': False},\n    'lal-1.3': {'id': 'LAL-1.3', 'deprecated': False},\n    'latex2e': {'id': 'Latex2e', 'deprecated': False},\n    'latex2e-translated-notice': {'id': 'Latex2e-translated-notice', 'deprecated': False},\n    'leptonica': {'id': 'Leptonica', 'deprecated': False},\n    'lgpl-2.0': {'id': 'LGPL-2.0', 'deprecated': True},\n    'lgpl-2.0+': {'id': 'LGPL-2.0+', 'deprecated': True},\n    'lgpl-2.0-only': {'id': 'LGPL-2.0-only', 'deprecated': False},\n    'lgpl-2.0-or-later': {'id': 'LGPL-2.0-or-later', 'deprecated': False},\n    'lgpl-2.1': {'id': 'LGPL-2.1', 'deprecated': True},\n    'lgpl-2.1+': {'id': 'LGPL-2.1+', 'deprecated': True},\n    'lgpl-2.1-only': {'id': 'LGPL-2.1-only', 'deprecated': False},\n    'lgpl-2.1-or-later': {'id': 'LGPL-2.1-or-later', 'deprecated': False},\n    'lgpl-3.0': {'id': 'LGPL-3.0', 'deprecated': True},\n    'lgpl-3.0+': {'id': 'LGPL-3.0+', 'deprecated': True},\n    'lgpl-3.0-only': {'id': 'LGPL-3.0-only', 'deprecated': False},\n    'lgpl-3.0-or-later': {'id': 'LGPL-3.0-or-later', 'deprecated': False},\n    'lgpllr': {'id': 'LGPLLR', 'deprecated': False},\n    'libpng': {'id': 'Libpng', 'deprecated': False},\n    'libpng-2.0': {'id': 'libpng-2.0', 'deprecated': False},\n    'libselinux-1.0': {'id': 'libselinux-1.0', 'deprecated': False},\n    'libtiff': {'id': 'libtiff', 'deprecated': False},\n    'libutil-david-nugent': {'id': 'libutil-David-Nugent', 'deprecated': False},\n    'liliq-p-1.1': {'id': 'LiLiQ-P-1.1', 'deprecated': False},\n    'liliq-r-1.1': {'id': 'LiLiQ-R-1.1', 'deprecated': False},\n    'liliq-rplus-1.1': {'id': 'LiLiQ-Rplus-1.1', 'deprecated': False},\n    'linux-man-pages-1-para': {'id': 'Linux-man-pages-1-para', 'deprecated': False},\n    'linux-man-pages-copyleft': {'id': 'Linux-man-pages-copyleft', 'deprecated': False},\n    'linux-man-pages-copyleft-2-para': {'id': 'Linux-man-pages-copyleft-2-para', 'deprecated': False},\n    'linux-man-pages-copyleft-var': {'id': 'Linux-man-pages-copyleft-var', 'deprecated': False},\n    'linux-openib': {'id': 'Linux-OpenIB', 'deprecated': False},\n    'loop': {'id': 'LOOP', 'deprecated': False},\n    'lpd-document': {'id': 'LPD-document', 'deprecated': False},\n    'lpl-1.0': {'id': 'LPL-1.0', 'deprecated': False},\n    'lpl-1.02': {'id': 'LPL-1.02', 'deprecated': False},\n    'lppl-1.0': {'id': 'LPPL-1.0', 'deprecated': False},\n    'lppl-1.1': {'id': 'LPPL-1.1', 'deprecated': False},\n    'lppl-1.2': {'id': 'LPPL-1.2', 'deprecated': False},\n    'lppl-1.3a': {'id': 'LPPL-1.3a', 'deprecated': False},\n    'lppl-1.3c': {'id': 'LPPL-1.3c', 'deprecated': False},\n    'lsof': {'id': 'lsof', 'deprecated': False},\n    'lucida-bitmap-fonts': {'id': 'Lucida-Bitmap-Fonts', 'deprecated': False},\n    'lzma-sdk-9.11-to-9.20': {'id': 'LZMA-SDK-9.11-to-9.20', 'deprecated': False},\n    'lzma-sdk-9.22': {'id': 'LZMA-SDK-9.22', 'deprecated': False},\n    'mackerras-3-clause': {'id': 'Mackerras-3-Clause', 'deprecated': False},\n    'mackerras-3-clause-acknowledgment': {'id': 'Mackerras-3-Clause-acknowledgment', 'deprecated': False},\n    'magaz': {'id': 'magaz', 'deprecated': False},\n    'mailprio': {'id': 'mailprio', 'deprecated': False},\n    'makeindex': {'id': 'MakeIndex', 'deprecated': False},\n    'martin-birgmeier': {'id': 'Martin-Birgmeier', 'deprecated': False},\n    'mcphee-slideshow': {'id': 'McPhee-slideshow', 'deprecated': False},\n    'metamail': {'id': 'metamail', 'deprecated': False},\n    'minpack': {'id': 'Minpack', 'deprecated': False},\n    'miros': {'id': 'MirOS', 'deprecated': False},\n    'mit': {'id': 'MIT', 'deprecated': False},\n    'mit-0': {'id': 'MIT-0', 'deprecated': False},\n    'mit-advertising': {'id': 'MIT-advertising', 'deprecated': False},\n    'mit-cmu': {'id': 'MIT-CMU', 'deprecated': False},\n    'mit-enna': {'id': 'MIT-enna', 'deprecated': False},\n    'mit-feh': {'id': 'MIT-feh', 'deprecated': False},\n    'mit-festival': {'id': 'MIT-Festival', 'deprecated': False},\n    'mit-khronos-old': {'id': 'MIT-Khronos-old', 'deprecated': False},\n    'mit-modern-variant': {'id': 'MIT-Modern-Variant', 'deprecated': False},\n    'mit-open-group': {'id': 'MIT-open-group', 'deprecated': False},\n    'mit-testregex': {'id': 'MIT-testregex', 'deprecated': False},\n    'mit-wu': {'id': 'MIT-Wu', 'deprecated': False},\n    'mitnfa': {'id': 'MITNFA', 'deprecated': False},\n    'mmixware': {'id': 'MMIXware', 'deprecated': False},\n    'motosoto': {'id': 'Motosoto', 'deprecated': False},\n    'mpeg-ssg': {'id': 'MPEG-SSG', 'deprecated': False},\n    'mpi-permissive': {'id': 'mpi-permissive', 'deprecated': False},\n    'mpich2': {'id': 'mpich2', 'deprecated': False},\n    'mpl-1.0': {'id': 'MPL-1.0', 'deprecated': False},\n    'mpl-1.1': {'id': 'MPL-1.1', 'deprecated': False},\n    'mpl-2.0': {'id': 'MPL-2.0', 'deprecated': False},\n    'mpl-2.0-no-copyleft-exception': {'id': 'MPL-2.0-no-copyleft-exception', 'deprecated': False},\n    'mplus': {'id': 'mplus', 'deprecated': False},\n    'ms-lpl': {'id': 'MS-LPL', 'deprecated': False},\n    'ms-pl': {'id': 'MS-PL', 'deprecated': False},\n    'ms-rl': {'id': 'MS-RL', 'deprecated': False},\n    'mtll': {'id': 'MTLL', 'deprecated': False},\n    'mulanpsl-1.0': {'id': 'MulanPSL-1.0', 'deprecated': False},\n    'mulanpsl-2.0': {'id': 'MulanPSL-2.0', 'deprecated': False},\n    'multics': {'id': 'Multics', 'deprecated': False},\n    'mup': {'id': 'Mup', 'deprecated': False},\n    'naist-2003': {'id': 'NAIST-2003', 'deprecated': False},\n    'nasa-1.3': {'id': 'NASA-1.3', 'deprecated': False},\n    'naumen': {'id': 'Naumen', 'deprecated': False},\n    'nbpl-1.0': {'id': 'NBPL-1.0', 'deprecated': False},\n    'ncbi-pd': {'id': 'NCBI-PD', 'deprecated': False},\n    'ncgl-uk-2.0': {'id': 'NCGL-UK-2.0', 'deprecated': False},\n    'ncl': {'id': 'NCL', 'deprecated': False},\n    'ncsa': {'id': 'NCSA', 'deprecated': False},\n    'net-snmp': {'id': 'Net-SNMP', 'deprecated': True},\n    'netcdf': {'id': 'NetCDF', 'deprecated': False},\n    'newsletr': {'id': 'Newsletr', 'deprecated': False},\n    'ngpl': {'id': 'NGPL', 'deprecated': False},\n    'nicta-1.0': {'id': 'NICTA-1.0', 'deprecated': False},\n    'nist-pd': {'id': 'NIST-PD', 'deprecated': False},\n    'nist-pd-fallback': {'id': 'NIST-PD-fallback', 'deprecated': False},\n    'nist-software': {'id': 'NIST-Software', 'deprecated': False},\n    'nlod-1.0': {'id': 'NLOD-1.0', 'deprecated': False},\n    'nlod-2.0': {'id': 'NLOD-2.0', 'deprecated': False},\n    'nlpl': {'id': 'NLPL', 'deprecated': False},\n    'nokia': {'id': 'Nokia', 'deprecated': False},\n    'nosl': {'id': 'NOSL', 'deprecated': False},\n    'noweb': {'id': 'Noweb', 'deprecated': False},\n    'npl-1.0': {'id': 'NPL-1.0', 'deprecated': False},\n    'npl-1.1': {'id': 'NPL-1.1', 'deprecated': False},\n    'nposl-3.0': {'id': 'NPOSL-3.0', 'deprecated': False},\n    'nrl': {'id': 'NRL', 'deprecated': False},\n    'ntp': {'id': 'NTP', 'deprecated': False},\n    'ntp-0': {'id': 'NTP-0', 'deprecated': False},\n    'nunit': {'id': 'Nunit', 'deprecated': True},\n    'o-uda-1.0': {'id': 'O-UDA-1.0', 'deprecated': False},\n    'oar': {'id': 'OAR', 'deprecated': False},\n    'occt-pl': {'id': 'OCCT-PL', 'deprecated': False},\n    'oclc-2.0': {'id': 'OCLC-2.0', 'deprecated': False},\n    'odbl-1.0': {'id': 'ODbL-1.0', 'deprecated': False},\n    'odc-by-1.0': {'id': 'ODC-By-1.0', 'deprecated': False},\n    'offis': {'id': 'OFFIS', 'deprecated': False},\n    'ofl-1.0': {'id': 'OFL-1.0', 'deprecated': False},\n    'ofl-1.0-no-rfn': {'id': 'OFL-1.0-no-RFN', 'deprecated': False},\n    'ofl-1.0-rfn': {'id': 'OFL-1.0-RFN', 'deprecated': False},\n    'ofl-1.1': {'id': 'OFL-1.1', 'deprecated': False},\n    'ofl-1.1-no-rfn': {'id': 'OFL-1.1-no-RFN', 'deprecated': False},\n    'ofl-1.1-rfn': {'id': 'OFL-1.1-RFN', 'deprecated': False},\n    'ogc-1.0': {'id': 'OGC-1.0', 'deprecated': False},\n    'ogdl-taiwan-1.0': {'id': 'OGDL-Taiwan-1.0', 'deprecated': False},\n    'ogl-canada-2.0': {'id': 'OGL-Canada-2.0', 'deprecated': False},\n    'ogl-uk-1.0': {'id': 'OGL-UK-1.0', 'deprecated': False},\n    'ogl-uk-2.0': {'id': 'OGL-UK-2.0', 'deprecated': False},\n    'ogl-uk-3.0': {'id': 'OGL-UK-3.0', 'deprecated': False},\n    'ogtsl': {'id': 'OGTSL', 'deprecated': False},\n    'oldap-1.1': {'id': 'OLDAP-1.1', 'deprecated': False},\n    'oldap-1.2': {'id': 'OLDAP-1.2', 'deprecated': False},\n    'oldap-1.3': {'id': 'OLDAP-1.3', 'deprecated': False},\n    'oldap-1.4': {'id': 'OLDAP-1.4', 'deprecated': False},\n    'oldap-2.0': {'id': 'OLDAP-2.0', 'deprecated': False},\n    'oldap-2.0.1': {'id': 'OLDAP-2.0.1', 'deprecated': False},\n    'oldap-2.1': {'id': 'OLDAP-2.1', 'deprecated': False},\n    'oldap-2.2': {'id': 'OLDAP-2.2', 'deprecated': False},\n    'oldap-2.2.1': {'id': 'OLDAP-2.2.1', 'deprecated': False},\n    'oldap-2.2.2': {'id': 'OLDAP-2.2.2', 'deprecated': False},\n    'oldap-2.3': {'id': 'OLDAP-2.3', 'deprecated': False},\n    'oldap-2.4': {'id': 'OLDAP-2.4', 'deprecated': False},\n    'oldap-2.5': {'id': 'OLDAP-2.5', 'deprecated': False},\n    'oldap-2.6': {'id': 'OLDAP-2.6', 'deprecated': False},\n    'oldap-2.7': {'id': 'OLDAP-2.7', 'deprecated': False},\n    'oldap-2.8': {'id': 'OLDAP-2.8', 'deprecated': False},\n    'olfl-1.3': {'id': 'OLFL-1.3', 'deprecated': False},\n    'oml': {'id': 'OML', 'deprecated': False},\n    'openpbs-2.3': {'id': 'OpenPBS-2.3', 'deprecated': False},\n    'openssl': {'id': 'OpenSSL', 'deprecated': False},\n    'openssl-standalone': {'id': 'OpenSSL-standalone', 'deprecated': False},\n    'openvision': {'id': 'OpenVision', 'deprecated': False},\n    'opl-1.0': {'id': 'OPL-1.0', 'deprecated': False},\n    'opl-uk-3.0': {'id': 'OPL-UK-3.0', 'deprecated': False},\n    'opubl-1.0': {'id': 'OPUBL-1.0', 'deprecated': False},\n    'oset-pl-2.1': {'id': 'OSET-PL-2.1', 'deprecated': False},\n    'osl-1.0': {'id': 'OSL-1.0', 'deprecated': False},\n    'osl-1.1': {'id': 'OSL-1.1', 'deprecated': False},\n    'osl-2.0': {'id': 'OSL-2.0', 'deprecated': False},\n    'osl-2.1': {'id': 'OSL-2.1', 'deprecated': False},\n    'osl-3.0': {'id': 'OSL-3.0', 'deprecated': False},\n    'padl': {'id': 'PADL', 'deprecated': False},\n    'parity-6.0.0': {'id': 'Parity-6.0.0', 'deprecated': False},\n    'parity-7.0.0': {'id': 'Parity-7.0.0', 'deprecated': False},\n    'pddl-1.0': {'id': 'PDDL-1.0', 'deprecated': False},\n    'php-3.0': {'id': 'PHP-3.0', 'deprecated': False},\n    'php-3.01': {'id': 'PHP-3.01', 'deprecated': False},\n    'pixar': {'id': 'Pixar', 'deprecated': False},\n    'pkgconf': {'id': 'pkgconf', 'deprecated': False},\n    'plexus': {'id': 'Plexus', 'deprecated': False},\n    'pnmstitch': {'id': 'pnmstitch', 'deprecated': False},\n    'polyform-noncommercial-1.0.0': {'id': 'PolyForm-Noncommercial-1.0.0', 'deprecated': False},\n    'polyform-small-business-1.0.0': {'id': 'PolyForm-Small-Business-1.0.0', 'deprecated': False},\n    'postgresql': {'id': 'PostgreSQL', 'deprecated': False},\n    'ppl': {'id': 'PPL', 'deprecated': False},\n    'psf-2.0': {'id': 'PSF-2.0', 'deprecated': False},\n    'psfrag': {'id': 'psfrag', 'deprecated': False},\n    'psutils': {'id': 'psutils', 'deprecated': False},\n    'python-2.0': {'id': 'Python-2.0', 'deprecated': False},\n    'python-2.0.1': {'id': 'Python-2.0.1', 'deprecated': False},\n    'python-ldap': {'id': 'python-ldap', 'deprecated': False},\n    'qhull': {'id': 'Qhull', 'deprecated': False},\n    'qpl-1.0': {'id': 'QPL-1.0', 'deprecated': False},\n    'qpl-1.0-inria-2004': {'id': 'QPL-1.0-INRIA-2004', 'deprecated': False},\n    'radvd': {'id': 'radvd', 'deprecated': False},\n    'rdisc': {'id': 'Rdisc', 'deprecated': False},\n    'rhecos-1.1': {'id': 'RHeCos-1.1', 'deprecated': False},\n    'rpl-1.1': {'id': 'RPL-1.1', 'deprecated': False},\n    'rpl-1.5': {'id': 'RPL-1.5', 'deprecated': False},\n    'rpsl-1.0': {'id': 'RPSL-1.0', 'deprecated': False},\n    'rsa-md': {'id': 'RSA-MD', 'deprecated': False},\n    'rscpl': {'id': 'RSCPL', 'deprecated': False},\n    'ruby': {'id': 'Ruby', 'deprecated': False},\n    'ruby-pty': {'id': 'Ruby-pty', 'deprecated': False},\n    'sax-pd': {'id': 'SAX-PD', 'deprecated': False},\n    'sax-pd-2.0': {'id': 'SAX-PD-2.0', 'deprecated': False},\n    'saxpath': {'id': 'Saxpath', 'deprecated': False},\n    'scea': {'id': 'SCEA', 'deprecated': False},\n    'schemereport': {'id': 'SchemeReport', 'deprecated': False},\n    'sendmail': {'id': 'Sendmail', 'deprecated': False},\n    'sendmail-8.23': {'id': 'Sendmail-8.23', 'deprecated': False},\n    'sgi-b-1.0': {'id': 'SGI-B-1.0', 'deprecated': False},\n    'sgi-b-1.1': {'id': 'SGI-B-1.1', 'deprecated': False},\n    'sgi-b-2.0': {'id': 'SGI-B-2.0', 'deprecated': False},\n    'sgi-opengl': {'id': 'SGI-OpenGL', 'deprecated': False},\n    'sgp4': {'id': 'SGP4', 'deprecated': False},\n    'shl-0.5': {'id': 'SHL-0.5', 'deprecated': False},\n    'shl-0.51': {'id': 'SHL-0.51', 'deprecated': False},\n    'simpl-2.0': {'id': 'SimPL-2.0', 'deprecated': False},\n    'sissl': {'id': 'SISSL', 'deprecated': False},\n    'sissl-1.2': {'id': 'SISSL-1.2', 'deprecated': False},\n    'sl': {'id': 'SL', 'deprecated': False},\n    'sleepycat': {'id': 'Sleepycat', 'deprecated': False},\n    'smlnj': {'id': 'SMLNJ', 'deprecated': False},\n    'smppl': {'id': 'SMPPL', 'deprecated': False},\n    'snia': {'id': 'SNIA', 'deprecated': False},\n    'snprintf': {'id': 'snprintf', 'deprecated': False},\n    'softsurfer': {'id': 'softSurfer', 'deprecated': False},\n    'soundex': {'id': 'Soundex', 'deprecated': False},\n    'spencer-86': {'id': 'Spencer-86', 'deprecated': False},\n    'spencer-94': {'id': 'Spencer-94', 'deprecated': False},\n    'spencer-99': {'id': 'Spencer-99', 'deprecated': False},\n    'spl-1.0': {'id': 'SPL-1.0', 'deprecated': False},\n    'ssh-keyscan': {'id': 'ssh-keyscan', 'deprecated': False},\n    'ssh-openssh': {'id': 'SSH-OpenSSH', 'deprecated': False},\n    'ssh-short': {'id': 'SSH-short', 'deprecated': False},\n    'ssleay-standalone': {'id': 'SSLeay-standalone', 'deprecated': False},\n    'sspl-1.0': {'id': 'SSPL-1.0', 'deprecated': False},\n    'standardml-nj': {'id': 'StandardML-NJ', 'deprecated': True},\n    'sugarcrm-1.1.3': {'id': 'SugarCRM-1.1.3', 'deprecated': False},\n    'sun-ppp': {'id': 'Sun-PPP', 'deprecated': False},\n    'sun-ppp-2000': {'id': 'Sun-PPP-2000', 'deprecated': False},\n    'sunpro': {'id': 'SunPro', 'deprecated': False},\n    'swl': {'id': 'SWL', 'deprecated': False},\n    'swrule': {'id': 'swrule', 'deprecated': False},\n    'symlinks': {'id': 'Symlinks', 'deprecated': False},\n    'tapr-ohl-1.0': {'id': 'TAPR-OHL-1.0', 'deprecated': False},\n    'tcl': {'id': 'TCL', 'deprecated': False},\n    'tcp-wrappers': {'id': 'TCP-wrappers', 'deprecated': False},\n    'termreadkey': {'id': 'TermReadKey', 'deprecated': False},\n    'tgppl-1.0': {'id': 'TGPPL-1.0', 'deprecated': False},\n    'threeparttable': {'id': 'threeparttable', 'deprecated': False},\n    'tmate': {'id': 'TMate', 'deprecated': False},\n    'torque-1.1': {'id': 'TORQUE-1.1', 'deprecated': False},\n    'tosl': {'id': 'TOSL', 'deprecated': False},\n    'tpdl': {'id': 'TPDL', 'deprecated': False},\n    'tpl-1.0': {'id': 'TPL-1.0', 'deprecated': False},\n    'ttwl': {'id': 'TTWL', 'deprecated': False},\n    'ttyp0': {'id': 'TTYP0', 'deprecated': False},\n    'tu-berlin-1.0': {'id': 'TU-Berlin-1.0', 'deprecated': False},\n    'tu-berlin-2.0': {'id': 'TU-Berlin-2.0', 'deprecated': False},\n    'ubuntu-font-1.0': {'id': 'Ubuntu-font-1.0', 'deprecated': False},\n    'ucar': {'id': 'UCAR', 'deprecated': False},\n    'ucl-1.0': {'id': 'UCL-1.0', 'deprecated': False},\n    'ulem': {'id': 'ulem', 'deprecated': False},\n    'umich-merit': {'id': 'UMich-Merit', 'deprecated': False},\n    'unicode-3.0': {'id': 'Unicode-3.0', 'deprecated': False},\n    'unicode-dfs-2015': {'id': 'Unicode-DFS-2015', 'deprecated': False},\n    'unicode-dfs-2016': {'id': 'Unicode-DFS-2016', 'deprecated': False},\n    'unicode-tou': {'id': 'Unicode-TOU', 'deprecated': False},\n    'unixcrypt': {'id': 'UnixCrypt', 'deprecated': False},\n    'unlicense': {'id': 'Unlicense', 'deprecated': False},\n    'upl-1.0': {'id': 'UPL-1.0', 'deprecated': False},\n    'urt-rle': {'id': 'URT-RLE', 'deprecated': False},\n    'vim': {'id': 'Vim', 'deprecated': False},\n    'vostrom': {'id': 'VOSTROM', 'deprecated': False},\n    'vsl-1.0': {'id': 'VSL-1.0', 'deprecated': False},\n    'w3c': {'id': 'W3C', 'deprecated': False},\n    'w3c-19980720': {'id': 'W3C-19980720', 'deprecated': False},\n    'w3c-20150513': {'id': 'W3C-20150513', 'deprecated': False},\n    'w3m': {'id': 'w3m', 'deprecated': False},\n    'watcom-1.0': {'id': 'Watcom-1.0', 'deprecated': False},\n    'widget-workshop': {'id': 'Widget-Workshop', 'deprecated': False},\n    'wsuipa': {'id': 'Wsuipa', 'deprecated': False},\n    'wtfpl': {'id': 'WTFPL', 'deprecated': False},\n    'wxwindows': {'id': 'wxWindows', 'deprecated': True},\n    'x11': {'id': 'X11', 'deprecated': False},\n    'x11-distribute-modifications-variant': {'id': 'X11-distribute-modifications-variant', 'deprecated': False},\n    'x11-swapped': {'id': 'X11-swapped', 'deprecated': False},\n    'xdebug-1.03': {'id': 'Xdebug-1.03', 'deprecated': False},\n    'xerox': {'id': 'Xerox', 'deprecated': False},\n    'xfig': {'id': 'Xfig', 'deprecated': False},\n    'xfree86-1.1': {'id': 'XFree86-1.1', 'deprecated': False},\n    'xinetd': {'id': 'xinetd', 'deprecated': False},\n    'xkeyboard-config-zinoviev': {'id': 'xkeyboard-config-Zinoviev', 'deprecated': False},\n    'xlock': {'id': 'xlock', 'deprecated': False},\n    'xnet': {'id': 'Xnet', 'deprecated': False},\n    'xpp': {'id': 'xpp', 'deprecated': False},\n    'xskat': {'id': 'XSkat', 'deprecated': False},\n    'xzoom': {'id': 'xzoom', 'deprecated': False},\n    'ypl-1.0': {'id': 'YPL-1.0', 'deprecated': False},\n    'ypl-1.1': {'id': 'YPL-1.1', 'deprecated': False},\n    'zed': {'id': 'Zed', 'deprecated': False},\n    'zeeff': {'id': 'Zeeff', 'deprecated': False},\n    'zend-2.0': {'id': 'Zend-2.0', 'deprecated': False},\n    'zimbra-1.3': {'id': 'Zimbra-1.3', 'deprecated': False},\n    'zimbra-1.4': {'id': 'Zimbra-1.4', 'deprecated': False},\n    'zlib': {'id': 'Zlib', 'deprecated': False},\n    'zlib-acknowledgement': {'id': 'zlib-acknowledgement', 'deprecated': False},\n    'zpl-1.1': {'id': 'ZPL-1.1', 'deprecated': False},\n    'zpl-2.0': {'id': 'ZPL-2.0', 'deprecated': False},\n    'zpl-2.1': {'id': 'ZPL-2.1', 'deprecated': False},\n}\n\nEXCEPTIONS: dict[str, SPDXException] = {\n    '389-exception': {'id': '389-exception', 'deprecated': False},\n    'asterisk-exception': {'id': 'Asterisk-exception', 'deprecated': False},\n    'asterisk-linking-protocols-exception': {'id': 'Asterisk-linking-protocols-exception', 'deprecated': False},\n    'autoconf-exception-2.0': {'id': 'Autoconf-exception-2.0', 'deprecated': False},\n    'autoconf-exception-3.0': {'id': 'Autoconf-exception-3.0', 'deprecated': False},\n    'autoconf-exception-generic': {'id': 'Autoconf-exception-generic', 'deprecated': False},\n    'autoconf-exception-generic-3.0': {'id': 'Autoconf-exception-generic-3.0', 'deprecated': False},\n    'autoconf-exception-macro': {'id': 'Autoconf-exception-macro', 'deprecated': False},\n    'bison-exception-1.24': {'id': 'Bison-exception-1.24', 'deprecated': False},\n    'bison-exception-2.2': {'id': 'Bison-exception-2.2', 'deprecated': False},\n    'bootloader-exception': {'id': 'Bootloader-exception', 'deprecated': False},\n    'classpath-exception-2.0': {'id': 'Classpath-exception-2.0', 'deprecated': False},\n    'clisp-exception-2.0': {'id': 'CLISP-exception-2.0', 'deprecated': False},\n    'cryptsetup-openssl-exception': {'id': 'cryptsetup-OpenSSL-exception', 'deprecated': False},\n    'digirule-foss-exception': {'id': 'DigiRule-FOSS-exception', 'deprecated': False},\n    'ecos-exception-2.0': {'id': 'eCos-exception-2.0', 'deprecated': False},\n    'erlang-otp-linking-exception': {'id': 'erlang-otp-linking-exception', 'deprecated': False},\n    'fawkes-runtime-exception': {'id': 'Fawkes-Runtime-exception', 'deprecated': False},\n    'fltk-exception': {'id': 'FLTK-exception', 'deprecated': False},\n    'fmt-exception': {'id': 'fmt-exception', 'deprecated': False},\n    'font-exception-2.0': {'id': 'Font-exception-2.0', 'deprecated': False},\n    'freertos-exception-2.0': {'id': 'freertos-exception-2.0', 'deprecated': False},\n    'gcc-exception-2.0': {'id': 'GCC-exception-2.0', 'deprecated': False},\n    'gcc-exception-2.0-note': {'id': 'GCC-exception-2.0-note', 'deprecated': False},\n    'gcc-exception-3.1': {'id': 'GCC-exception-3.1', 'deprecated': False},\n    'gmsh-exception': {'id': 'Gmsh-exception', 'deprecated': False},\n    'gnat-exception': {'id': 'GNAT-exception', 'deprecated': False},\n    'gnome-examples-exception': {'id': 'GNOME-examples-exception', 'deprecated': False},\n    'gnu-compiler-exception': {'id': 'GNU-compiler-exception', 'deprecated': False},\n    'gnu-javamail-exception': {'id': 'gnu-javamail-exception', 'deprecated': False},\n    'gpl-3.0-interface-exception': {'id': 'GPL-3.0-interface-exception', 'deprecated': False},\n    'gpl-3.0-linking-exception': {'id': 'GPL-3.0-linking-exception', 'deprecated': False},\n    'gpl-3.0-linking-source-exception': {'id': 'GPL-3.0-linking-source-exception', 'deprecated': False},\n    'gpl-cc-1.0': {'id': 'GPL-CC-1.0', 'deprecated': False},\n    'gstreamer-exception-2005': {'id': 'GStreamer-exception-2005', 'deprecated': False},\n    'gstreamer-exception-2008': {'id': 'GStreamer-exception-2008', 'deprecated': False},\n    'i2p-gpl-java-exception': {'id': 'i2p-gpl-java-exception', 'deprecated': False},\n    'kicad-libraries-exception': {'id': 'KiCad-libraries-exception', 'deprecated': False},\n    'lgpl-3.0-linking-exception': {'id': 'LGPL-3.0-linking-exception', 'deprecated': False},\n    'libpri-openh323-exception': {'id': 'libpri-OpenH323-exception', 'deprecated': False},\n    'libtool-exception': {'id': 'Libtool-exception', 'deprecated': False},\n    'linux-syscall-note': {'id': 'Linux-syscall-note', 'deprecated': False},\n    'llgpl': {'id': 'LLGPL', 'deprecated': False},\n    'llvm-exception': {'id': 'LLVM-exception', 'deprecated': False},\n    'lzma-exception': {'id': 'LZMA-exception', 'deprecated': False},\n    'mif-exception': {'id': 'mif-exception', 'deprecated': False},\n    'nokia-qt-exception-1.1': {'id': 'Nokia-Qt-exception-1.1', 'deprecated': True},\n    'ocaml-lgpl-linking-exception': {'id': 'OCaml-LGPL-linking-exception', 'deprecated': False},\n    'occt-exception-1.0': {'id': 'OCCT-exception-1.0', 'deprecated': False},\n    'openjdk-assembly-exception-1.0': {'id': 'OpenJDK-assembly-exception-1.0', 'deprecated': False},\n    'openvpn-openssl-exception': {'id': 'openvpn-openssl-exception', 'deprecated': False},\n    'pcre2-exception': {'id': 'PCRE2-exception', 'deprecated': False},\n    'ps-or-pdf-font-exception-20170817': {'id': 'PS-or-PDF-font-exception-20170817', 'deprecated': False},\n    'qpl-1.0-inria-2004-exception': {'id': 'QPL-1.0-INRIA-2004-exception', 'deprecated': False},\n    'qt-gpl-exception-1.0': {'id': 'Qt-GPL-exception-1.0', 'deprecated': False},\n    'qt-lgpl-exception-1.1': {'id': 'Qt-LGPL-exception-1.1', 'deprecated': False},\n    'qwt-exception-1.0': {'id': 'Qwt-exception-1.0', 'deprecated': False},\n    'romic-exception': {'id': 'romic-exception', 'deprecated': False},\n    'rrdtool-floss-exception-2.0': {'id': 'RRDtool-FLOSS-exception-2.0', 'deprecated': False},\n    'sane-exception': {'id': 'SANE-exception', 'deprecated': False},\n    'shl-2.0': {'id': 'SHL-2.0', 'deprecated': False},\n    'shl-2.1': {'id': 'SHL-2.1', 'deprecated': False},\n    'stunnel-exception': {'id': 'stunnel-exception', 'deprecated': False},\n    'swi-exception': {'id': 'SWI-exception', 'deprecated': False},\n    'swift-exception': {'id': 'Swift-exception', 'deprecated': False},\n    'texinfo-exception': {'id': 'Texinfo-exception', 'deprecated': False},\n    'u-boot-exception-2.0': {'id': 'u-boot-exception-2.0', 'deprecated': False},\n    'ubdl-exception': {'id': 'UBDL-exception', 'deprecated': False},\n    'universal-foss-exception-1.0': {'id': 'Universal-FOSS-exception-1.0', 'deprecated': False},\n    'vsftpd-openssl-exception': {'id': 'vsftpd-openssl-exception', 'deprecated': False},\n    'wxwindows-exception-3.1': {'id': 'WxWindows-exception-3.1', 'deprecated': False},\n    'x11vnc-openssl-exception': {'id': 'x11vnc-openssl-exception', 'deprecated': False},\n}\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/packaging/markers.py","size":10561,"sha1":"a33df2510a351b7d15c64b751007a742068602b2","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport operator\nimport os\nimport platform\nimport sys\nfrom typing import Any, Callable, TypedDict, cast\n\nfrom ._parser import MarkerAtom, MarkerList, Op, Value, Variable\nfrom ._parser import parse_marker as _parse_marker\nfrom ._tokenizer import ParserSyntaxError\nfrom .specifiers import InvalidSpecifier, Specifier\nfrom .utils import canonicalize_name\n\n__all__ = [\n    \"InvalidMarker\",\n    \"Marker\",\n    \"UndefinedComparison\",\n    \"UndefinedEnvironmentName\",\n    \"default_environment\",\n]\n\nOperator = Callable[[str, str], bool]\n\n\nclass InvalidMarker(ValueError):\n    \"\"\"\n    An invalid marker was found, users should refer to PEP 508.\n    \"\"\"\n\n\nclass UndefinedComparison(ValueError):\n    \"\"\"\n    An invalid operation was attempted on a value that doesn't support it.\n    \"\"\"\n\n\nclass UndefinedEnvironmentName(ValueError):\n    \"\"\"\n    A name was attempted to be used that does not exist inside of the\n    environment.\n    \"\"\"\n\n\nclass Environment(TypedDict):\n    implementation_name: str\n    \"\"\"The implementation's identifier, e.g. ``'cpython'``.\"\"\"\n\n    implementation_version: str\n    \"\"\"\n    The implementation's version, e.g. ``'3.13.0a2'`` for CPython 3.13.0a2, or\n    ``'7.3.13'`` for PyPy3.10 v7.3.13.\n    \"\"\"\n\n    os_name: str\n    \"\"\"\n    The value of :py:data:`os.name`. The name of the operating system dependent module\n    imported, e.g. ``'posix'``.\n    \"\"\"\n\n    platform_machine: str\n    \"\"\"\n    Returns the machine type, e.g. ``'i386'``.\n\n    An empty string if the value cannot be determined.\n    \"\"\"\n\n    platform_release: str\n    \"\"\"\n    The system's release, e.g. ``'2.2.0'`` or ``'NT'``.\n\n    An empty string if the value cannot be determined.\n    \"\"\"\n\n    platform_system: str\n    \"\"\"\n    The system/OS name, e.g. ``'Linux'``, ``'Windows'`` or ``'Java'``.\n\n    An empty string if the value cannot be determined.\n    \"\"\"\n\n    platform_version: str\n    \"\"\"\n    The system's release version, e.g. ``'#3 on degas'``.\n\n    An empty string if the value cannot be determined.\n    \"\"\"\n\n    python_full_version: str\n    \"\"\"\n    The Python version as string ``'major.minor.patchlevel'``.\n\n    Note that unlike the Python :py:data:`sys.version`, this value will always include\n    the patchlevel (it defaults to 0).\n    \"\"\"\n\n    platform_python_implementation: str\n    \"\"\"\n    A string identifying the Python implementation, e.g. ``'CPython'``.\n    \"\"\"\n\n    python_version: str\n    \"\"\"The Python version as string ``'major.minor'``.\"\"\"\n\n    sys_platform: str\n    \"\"\"\n    This string contains a platform identifier that can be used to append\n    platform-specific components to :py:data:`sys.path`, for instance.\n\n    For Unix systems, except on Linux and AIX, this is the lowercased OS name as\n    returned by ``uname -s`` with the first part of the version as returned by\n    ``uname -r`` appended, e.g. ``'sunos5'`` or ``'freebsd8'``, at the time when Python\n    was built.\n    \"\"\"\n\n\ndef _normalize_extra_values(results: Any) -> Any:\n    \"\"\"\n    Normalize extra values.\n    \"\"\"\n    if isinstance(results[0], tuple):\n        lhs, op, rhs = results[0]\n        if isinstance(lhs, Variable) and lhs.value == \"extra\":\n            normalized_extra = canonicalize_name(rhs.value)\n            rhs = Value(normalized_extra)\n        elif isinstance(rhs, Variable) and rhs.value == \"extra\":\n            normalized_extra = canonicalize_name(lhs.value)\n            lhs = Value(normalized_extra)\n        results[0] = lhs, op, rhs\n    return results\n\n\ndef _format_marker(\n    marker: list[str] | MarkerAtom | str, first: bool | None = True\n) -> str:\n    assert isinstance(marker, (list, tuple, str))\n\n    # Sometimes we have a structure like [[...]] which is a single item list\n    # where the single item is itself it's own list. In that case we want skip\n    # the rest of this function so that we don't get extraneous () on the\n    # outside.\n    if (\n        isinstance(marker, list)\n        and len(marker) == 1\n        and isinstance(marker[0], (list, tuple))\n    ):\n        return _format_marker(marker[0])\n\n    if isinstance(marker, list):\n        inner = (_format_marker(m, first=False) for m in marker)\n        if first:\n            return \" \".join(inner)\n        else:\n            return \"(\" + \" \".join(inner) + \")\"\n    elif isinstance(marker, tuple):\n        return \" \".join([m.serialize() for m in marker])\n    else:\n        return marker\n\n\n_operators: dict[str, Operator] = {\n    \"in\": lambda lhs, rhs: lhs in rhs,\n    \"not in\": lambda lhs, rhs: lhs not in rhs,\n    \"<\": operator.lt,\n    \"<=\": operator.le,\n    \"==\": operator.eq,\n    \"!=\": operator.ne,\n    \">=\": operator.ge,\n    \">\": operator.gt,\n}\n\n\ndef _eval_op(lhs: str, op: Op, rhs: str) -> bool:\n    try:\n        spec = Specifier(\"\".join([op.serialize(), rhs]))\n    except InvalidSpecifier:\n        pass\n    else:\n        return spec.contains(lhs, prereleases=True)\n\n    oper: Operator | None = _operators.get(op.serialize())\n    if oper is None:\n        raise UndefinedComparison(f\"Undefined {op!r} on {lhs!r} and {rhs!r}.\")\n\n    return oper(lhs, rhs)\n\n\ndef _normalize(*values: str, key: str) -> tuple[str, ...]:\n    # PEP 685  Comparison of extra names for optional distribution dependencies\n    # https://peps.python.org/pep-0685/\n    # > When comparing extra names, tools MUST normalize the names being\n    # > compared using the semantics outlined in PEP 503 for names\n    if key == \"extra\":\n        return tuple(canonicalize_name(v) for v in values)\n\n    # other environment markers don't have such standards\n    return values\n\n\ndef _evaluate_markers(markers: MarkerList, environment: dict[str, str]) -> bool:\n    groups: list[list[bool]] = [[]]\n\n    for marker in markers:\n        assert isinstance(marker, (list, tuple, str))\n\n        if isinstance(marker, list):\n            groups[-1].append(_evaluate_markers(marker, environment))\n        elif isinstance(marker, tuple):\n            lhs, op, rhs = marker\n\n            if isinstance(lhs, Variable):\n                environment_key = lhs.value\n                lhs_value = environment[environment_key]\n                rhs_value = rhs.value\n            else:\n                lhs_value = lhs.value\n                environment_key = rhs.value\n                rhs_value = environment[environment_key]\n\n            lhs_value, rhs_value = _normalize(lhs_value, rhs_value, key=environment_key)\n            groups[-1].append(_eval_op(lhs_value, op, rhs_value))\n        else:\n            assert marker in [\"and\", \"or\"]\n            if marker == \"or\":\n                groups.append([])\n\n    return any(all(item) for item in groups)\n\n\ndef format_full_version(info: sys._version_info) -> str:\n    version = f\"{info.major}.{info.minor}.{info.micro}\"\n    kind = info.releaselevel\n    if kind != \"final\":\n        version += kind[0] + str(info.serial)\n    return version\n\n\ndef default_environment() -> Environment:\n    iver = format_full_version(sys.implementation.version)\n    implementation_name = sys.implementation.name\n    return {\n        \"implementation_name\": implementation_name,\n        \"implementation_version\": iver,\n        \"os_name\": os.name,\n        \"platform_machine\": platform.machine(),\n        \"platform_release\": platform.release(),\n        \"platform_system\": platform.system(),\n        \"platform_version\": platform.version(),\n        \"python_full_version\": platform.python_version(),\n        \"platform_python_implementation\": platform.python_implementation(),\n        \"python_version\": \".\".join(platform.python_version_tuple()[:2]),\n        \"sys_platform\": sys.platform,\n    }\n\n\nclass Marker:\n    def __init__(self, marker: str) -> None:\n        # Note: We create a Marker object without calling this constructor in\n        #       packaging.requirements.Requirement. If any additional logic is\n        #       added here, make sure to mirror/adapt Requirement.\n        try:\n            self._markers = _normalize_extra_values(_parse_marker(marker))\n            # The attribute `_markers` can be described in terms of a recursive type:\n            # MarkerList = List[Union[Tuple[Node, ...], str, MarkerList]]\n            #\n            # For example, the following expression:\n            # python_version > \"3.6\" or (python_version == \"3.6\" and os_name == \"unix\")\n            #\n            # is parsed into:\n            # [\n            #     (<Variable('python_version')>, <Op('>')>, <Value('3.6')>),\n            #     'and',\n            #     [\n            #         (<Variable('python_version')>, <Op('==')>, <Value('3.6')>),\n            #         'or',\n            #         (<Variable('os_name')>, <Op('==')>, <Value('unix')>)\n            #     ]\n            # ]\n        except ParserSyntaxError as e:\n            raise InvalidMarker(str(e)) from e\n\n    def __str__(self) -> str:\n        return _format_marker(self._markers)\n\n    def __repr__(self) -> str:\n        return f\"<Marker('{self}')>\"\n\n    def __hash__(self) -> int:\n        return hash((self.__class__.__name__, str(self)))\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, Marker):\n            return NotImplemented\n\n        return str(self) == str(other)\n\n    def evaluate(self, environment: dict[str, str] | None = None) -> bool:\n        \"\"\"Evaluate a marker.\n\n        Return the boolean from evaluating the given marker against the\n        environment. environment is an optional argument to override all or\n        part of the determined environment.\n\n        The environment is determined from the current Python process.\n        \"\"\"\n        current_environment = cast(\"dict[str, str]\", default_environment())\n        current_environment[\"extra\"] = \"\"\n        if environment is not None:\n            current_environment.update(environment)\n            # The API used to allow setting extra to None. We need to handle this\n            # case for backwards compatibility.\n            if current_environment[\"extra\"] is None:\n                current_environment[\"extra\"] = \"\"\n\n        return _evaluate_markers(\n            self._markers, _repair_python_full_version(current_environment)\n        )\n\n\ndef _repair_python_full_version(env: dict[str, str]) -> dict[str, str]:\n    \"\"\"\n    Work around platform.python_version() returning something that is not PEP 440\n    compliant for non-tagged Python builds.\n    \"\"\"\n    if env[\"python_full_version\"].endswith(\"+\"):\n        env[\"python_full_version\"] += \"local\"\n    return env\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/packaging/metadata.py","size":34762,"sha1":"451a6a39253694900b7113e5cb7ba228b4aaf0bb","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport email.feedparser\nimport email.header\nimport email.message\nimport email.parser\nimport email.policy\nimport pathlib\nimport sys\nimport typing\nfrom typing import (\n    Any,\n    Callable,\n    Generic,\n    Literal,\n    TypedDict,\n    cast,\n)\n\nfrom . import licenses, requirements, specifiers, utils\nfrom . import version as version_module\nfrom .licenses import NormalizedLicenseExpression\n\nT = typing.TypeVar(\"T\")\n\n\nif sys.version_info >= (3, 11):  # pragma: no cover\n    ExceptionGroup = ExceptionGroup\nelse:  # pragma: no cover\n\n    class ExceptionGroup(Exception):\n        \"\"\"A minimal implementation of :external:exc:`ExceptionGroup` from Python 3.11.\n\n        If :external:exc:`ExceptionGroup` is already defined by Python itself,\n        that version is used instead.\n        \"\"\"\n\n        message: str\n        exceptions: list[Exception]\n\n        def __init__(self, message: str, exceptions: list[Exception]) -> None:\n            self.message = message\n            self.exceptions = exceptions\n\n        def __repr__(self) -> str:\n            return f\"{self.__class__.__name__}({self.message!r}, {self.exceptions!r})\"\n\n\nclass InvalidMetadata(ValueError):\n    \"\"\"A metadata field contains invalid data.\"\"\"\n\n    field: str\n    \"\"\"The name of the field that contains invalid data.\"\"\"\n\n    def __init__(self, field: str, message: str) -> None:\n        self.field = field\n        super().__init__(message)\n\n\n# The RawMetadata class attempts to make as few assumptions about the underlying\n# serialization formats as possible. The idea is that as long as a serialization\n# formats offer some very basic primitives in *some* way then we can support\n# serializing to and from that format.\nclass RawMetadata(TypedDict, total=False):\n    \"\"\"A dictionary of raw core metadata.\n\n    Each field in core metadata maps to a key of this dictionary (when data is\n    provided). The key is lower-case and underscores are used instead of dashes\n    compared to the equivalent core metadata field. Any core metadata field that\n    can be specified multiple times or can hold multiple values in a single\n    field have a key with a plural name. See :class:`Metadata` whose attributes\n    match the keys of this dictionary.\n\n    Core metadata fields that can be specified multiple times are stored as a\n    list or dict depending on which is appropriate for the field. Any fields\n    which hold multiple values in a single field are stored as a list.\n\n    \"\"\"\n\n    # Metadata 1.0 - PEP 241\n    metadata_version: str\n    name: str\n    version: str\n    platforms: list[str]\n    summary: str\n    description: str\n    keywords: list[str]\n    home_page: str\n    author: str\n    author_email: str\n    license: str\n\n    # Metadata 1.1 - PEP 314\n    supported_platforms: list[str]\n    download_url: str\n    classifiers: list[str]\n    requires: list[str]\n    provides: list[str]\n    obsoletes: list[str]\n\n    # Metadata 1.2 - PEP 345\n    maintainer: str\n    maintainer_email: str\n    requires_dist: list[str]\n    provides_dist: list[str]\n    obsoletes_dist: list[str]\n    requires_python: str\n    requires_external: list[str]\n    project_urls: dict[str, str]\n\n    # Metadata 2.0\n    # PEP 426 attempted to completely revamp the metadata format\n    # but got stuck without ever being able to build consensus on\n    # it and ultimately ended up withdrawn.\n    #\n    # However, a number of tools had started emitting METADATA with\n    # `2.0` Metadata-Version, so for historical reasons, this version\n    # was skipped.\n\n    # Metadata 2.1 - PEP 566\n    description_content_type: str\n    provides_extra: list[str]\n\n    # Metadata 2.2 - PEP 643\n    dynamic: list[str]\n\n    # Metadata 2.3 - PEP 685\n    # No new fields were added in PEP 685, just some edge case were\n    # tightened up to provide better interoptability.\n\n    # Metadata 2.4 - PEP 639\n    license_expression: str\n    license_files: list[str]\n\n\n_STRING_FIELDS = {\n    \"author\",\n    \"author_email\",\n    \"description\",\n    \"description_content_type\",\n    \"download_url\",\n    \"home_page\",\n    \"license\",\n    \"license_expression\",\n    \"maintainer\",\n    \"maintainer_email\",\n    \"metadata_version\",\n    \"name\",\n    \"requires_python\",\n    \"summary\",\n    \"version\",\n}\n\n_LIST_FIELDS = {\n    \"classifiers\",\n    \"dynamic\",\n    \"license_files\",\n    \"obsoletes\",\n    \"obsoletes_dist\",\n    \"platforms\",\n    \"provides\",\n    \"provides_dist\",\n    \"provides_extra\",\n    \"requires\",\n    \"requires_dist\",\n    \"requires_external\",\n    \"supported_platforms\",\n}\n\n_DICT_FIELDS = {\n    \"project_urls\",\n}\n\n\ndef _parse_keywords(data: str) -> list[str]:\n    \"\"\"Split a string of comma-separated keywords into a list of keywords.\"\"\"\n    return [k.strip() for k in data.split(\",\")]\n\n\ndef _parse_project_urls(data: list[str]) -> dict[str, str]:\n    \"\"\"Parse a list of label/URL string pairings separated by a comma.\"\"\"\n    urls = {}\n    for pair in data:\n        # Our logic is slightly tricky here as we want to try and do\n        # *something* reasonable with malformed data.\n        #\n        # The main thing that we have to worry about, is data that does\n        # not have a ',' at all to split the label from the Value. There\n        # isn't a singular right answer here, and we will fail validation\n        # later on (if the caller is validating) so it doesn't *really*\n        # matter, but since the missing value has to be an empty str\n        # and our return value is dict[str, str], if we let the key\n        # be the missing value, then they'd have multiple '' values that\n        # overwrite each other in a accumulating dict.\n        #\n        # The other potentional issue is that it's possible to have the\n        # same label multiple times in the metadata, with no solid \"right\"\n        # answer with what to do in that case. As such, we'll do the only\n        # thing we can, which is treat the field as unparseable and add it\n        # to our list of unparsed fields.\n        parts = [p.strip() for p in pair.split(\",\", 1)]\n        parts.extend([\"\"] * (max(0, 2 - len(parts))))  # Ensure 2 items\n\n        # TODO: The spec doesn't say anything about if the keys should be\n        #       considered case sensitive or not... logically they should\n        #       be case-preserving and case-insensitive, but doing that\n        #       would open up more cases where we might have duplicate\n        #       entries.\n        label, url = parts\n        if label in urls:\n            # The label already exists in our set of urls, so this field\n            # is unparseable, and we can just add the whole thing to our\n            # unparseable data and stop processing it.\n            raise KeyError(\"duplicate labels in project urls\")\n        urls[label] = url\n\n    return urls\n\n\ndef _get_payload(msg: email.message.Message, source: bytes | str) -> str:\n    \"\"\"Get the body of the message.\"\"\"\n    # If our source is a str, then our caller has managed encodings for us,\n    # and we don't need to deal with it.\n    if isinstance(source, str):\n        payload = msg.get_payload()\n        assert isinstance(payload, str)\n        return payload\n    # If our source is a bytes, then we're managing the encoding and we need\n    # to deal with it.\n    else:\n        bpayload = msg.get_payload(decode=True)\n        assert isinstance(bpayload, bytes)\n        try:\n            return bpayload.decode(\"utf8\", \"strict\")\n        except UnicodeDecodeError as exc:\n            raise ValueError(\"payload in an invalid encoding\") from exc\n\n\n# The various parse_FORMAT functions here are intended to be as lenient as\n# possible in their parsing, while still returning a correctly typed\n# RawMetadata.\n#\n# To aid in this, we also generally want to do as little touching of the\n# data as possible, except where there are possibly some historic holdovers\n# that make valid data awkward to work with.\n#\n# While this is a lower level, intermediate format than our ``Metadata``\n# class, some light touch ups can make a massive difference in usability.\n\n# Map METADATA fields to RawMetadata.\n_EMAIL_TO_RAW_MAPPING = {\n    \"author\": \"author\",\n    \"author-email\": \"author_email\",\n    \"classifier\": \"classifiers\",\n    \"description\": \"description\",\n    \"description-content-type\": \"description_content_type\",\n    \"download-url\": \"download_url\",\n    \"dynamic\": \"dynamic\",\n    \"home-page\": \"home_page\",\n    \"keywords\": \"keywords\",\n    \"license\": \"license\",\n    \"license-expression\": \"license_expression\",\n    \"license-file\": \"license_files\",\n    \"maintainer\": \"maintainer\",\n    \"maintainer-email\": \"maintainer_email\",\n    \"metadata-version\": \"metadata_version\",\n    \"name\": \"name\",\n    \"obsoletes\": \"obsoletes\",\n    \"obsoletes-dist\": \"obsoletes_dist\",\n    \"platform\": \"platforms\",\n    \"project-url\": \"project_urls\",\n    \"provides\": \"provides\",\n    \"provides-dist\": \"provides_dist\",\n    \"provides-extra\": \"provides_extra\",\n    \"requires\": \"requires\",\n    \"requires-dist\": \"requires_dist\",\n    \"requires-external\": \"requires_external\",\n    \"requires-python\": \"requires_python\",\n    \"summary\": \"summary\",\n    \"supported-platform\": \"supported_platforms\",\n    \"version\": \"version\",\n}\n_RAW_TO_EMAIL_MAPPING = {raw: email for email, raw in _EMAIL_TO_RAW_MAPPING.items()}\n\n\ndef parse_email(data: bytes | str) -> tuple[RawMetadata, dict[str, list[str]]]:\n    \"\"\"Parse a distribution's metadata stored as email headers (e.g. from ``METADATA``).\n\n    This function returns a two-item tuple of dicts. The first dict is of\n    recognized fields from the core metadata specification. Fields that can be\n    parsed and translated into Python's built-in types are converted\n    appropriately. All other fields are left as-is. Fields that are allowed to\n    appear multiple times are stored as lists.\n\n    The second dict contains all other fields from the metadata. This includes\n    any unrecognized fields. It also includes any fields which are expected to\n    be parsed into a built-in type but were not formatted appropriately. Finally,\n    any fields that are expected to appear only once but are repeated are\n    included in this dict.\n\n    \"\"\"\n    raw: dict[str, str | list[str] | dict[str, str]] = {}\n    unparsed: dict[str, list[str]] = {}\n\n    if isinstance(data, str):\n        parsed = email.parser.Parser(policy=email.policy.compat32).parsestr(data)\n    else:\n        parsed = email.parser.BytesParser(policy=email.policy.compat32).parsebytes(data)\n\n    # We have to wrap parsed.keys() in a set, because in the case of multiple\n    # values for a key (a list), the key will appear multiple times in the\n    # list of keys, but we're avoiding that by using get_all().\n    for name in frozenset(parsed.keys()):\n        # Header names in RFC are case insensitive, so we'll normalize to all\n        # lower case to make comparisons easier.\n        name = name.lower()\n\n        # We use get_all() here, even for fields that aren't multiple use,\n        # because otherwise someone could have e.g. two Name fields, and we\n        # would just silently ignore it rather than doing something about it.\n        headers = parsed.get_all(name) or []\n\n        # The way the email module works when parsing bytes is that it\n        # unconditionally decodes the bytes as ascii using the surrogateescape\n        # handler. When you pull that data back out (such as with get_all() ),\n        # it looks to see if the str has any surrogate escapes, and if it does\n        # it wraps it in a Header object instead of returning the string.\n        #\n        # As such, we'll look for those Header objects, and fix up the encoding.\n        value = []\n        # Flag if we have run into any issues processing the headers, thus\n        # signalling that the data belongs in 'unparsed'.\n        valid_encoding = True\n        for h in headers:\n            # It's unclear if this can return more types than just a Header or\n            # a str, so we'll just assert here to make sure.\n            assert isinstance(h, (email.header.Header, str))\n\n            # If it's a header object, we need to do our little dance to get\n            # the real data out of it. In cases where there is invalid data\n            # we're going to end up with mojibake, but there's no obvious, good\n            # way around that without reimplementing parts of the Header object\n            # ourselves.\n            #\n            # That should be fine since, if mojibacked happens, this key is\n            # going into the unparsed dict anyways.\n            if isinstance(h, email.header.Header):\n                # The Header object stores it's data as chunks, and each chunk\n                # can be independently encoded, so we'll need to check each\n                # of them.\n                chunks: list[tuple[bytes, str | None]] = []\n                for bin, encoding in email.header.decode_header(h):\n                    try:\n                        bin.decode(\"utf8\", \"strict\")\n                    except UnicodeDecodeError:\n                        # Enable mojibake.\n                        encoding = \"latin1\"\n                        valid_encoding = False\n                    else:\n                        encoding = \"utf8\"\n                    chunks.append((bin, encoding))\n\n                # Turn our chunks back into a Header object, then let that\n                # Header object do the right thing to turn them into a\n                # string for us.\n                value.append(str(email.header.make_header(chunks)))\n            # This is already a string, so just add it.\n            else:\n                value.append(h)\n\n        # We've processed all of our values to get them into a list of str,\n        # but we may have mojibake data, in which case this is an unparsed\n        # field.\n        if not valid_encoding:\n            unparsed[name] = value\n            continue\n\n        raw_name = _EMAIL_TO_RAW_MAPPING.get(name)\n        if raw_name is None:\n            # This is a bit of a weird situation, we've encountered a key that\n            # we don't know what it means, so we don't know whether it's meant\n            # to be a list or not.\n            #\n            # Since we can't really tell one way or another, we'll just leave it\n            # as a list, even though it may be a single item list, because that's\n            # what makes the most sense for email headers.\n            unparsed[name] = value\n            continue\n\n        # If this is one of our string fields, then we'll check to see if our\n        # value is a list of a single item. If it is then we'll assume that\n        # it was emitted as a single string, and unwrap the str from inside\n        # the list.\n        #\n        # If it's any other kind of data, then we haven't the faintest clue\n        # what we should parse it as, and we have to just add it to our list\n        # of unparsed stuff.\n        if raw_name in _STRING_FIELDS and len(value) == 1:\n            raw[raw_name] = value[0]\n        # If this is one of our list of string fields, then we can just assign\n        # the value, since email *only* has strings, and our get_all() call\n        # above ensures that this is a list.\n        elif raw_name in _LIST_FIELDS:\n            raw[raw_name] = value\n        # Special Case: Keywords\n        # The keywords field is implemented in the metadata spec as a str,\n        # but it conceptually is a list of strings, and is serialized using\n        # \", \".join(keywords), so we'll do some light data massaging to turn\n        # this into what it logically is.\n        elif raw_name == \"keywords\" and len(value) == 1:\n            raw[raw_name] = _parse_keywords(value[0])\n        # Special Case: Project-URL\n        # The project urls is implemented in the metadata spec as a list of\n        # specially-formatted strings that represent a key and a value, which\n        # is fundamentally a mapping, however the email format doesn't support\n        # mappings in a sane way, so it was crammed into a list of strings\n        # instead.\n        #\n        # We will do a little light data massaging to turn this into a map as\n        # it logically should be.\n        elif raw_name == \"project_urls\":\n            try:\n                raw[raw_name] = _parse_project_urls(value)\n            except KeyError:\n                unparsed[name] = value\n        # Nothing that we've done has managed to parse this, so it'll just\n        # throw it in our unparseable data and move on.\n        else:\n            unparsed[name] = value\n\n    # We need to support getting the Description from the message payload in\n    # addition to getting it from the the headers. This does mean, though, there\n    # is the possibility of it being set both ways, in which case we put both\n    # in 'unparsed' since we don't know which is right.\n    try:\n        payload = _get_payload(parsed, data)\n    except ValueError:\n        unparsed.setdefault(\"description\", []).append(\n            parsed.get_payload(decode=isinstance(data, bytes))  # type: ignore[call-overload]\n        )\n    else:\n        if payload:\n            # Check to see if we've already got a description, if so then both\n            # it, and this body move to unparseable.\n            if \"description\" in raw:\n                description_header = cast(str, raw.pop(\"description\"))\n                unparsed.setdefault(\"description\", []).extend(\n                    [description_header, payload]\n                )\n            elif \"description\" in unparsed:\n                unparsed[\"description\"].append(payload)\n            else:\n                raw[\"description\"] = payload\n\n    # We need to cast our `raw` to a metadata, because a TypedDict only support\n    # literal key names, but we're computing our key names on purpose, but the\n    # way this function is implemented, our `TypedDict` can only have valid key\n    # names.\n    return cast(RawMetadata, raw), unparsed\n\n\n_NOT_FOUND = object()\n\n\n# Keep the two values in sync.\n_VALID_METADATA_VERSIONS = [\"1.0\", \"1.1\", \"1.2\", \"2.1\", \"2.2\", \"2.3\", \"2.4\"]\n_MetadataVersion = Literal[\"1.0\", \"1.1\", \"1.2\", \"2.1\", \"2.2\", \"2.3\", \"2.4\"]\n\n_REQUIRED_ATTRS = frozenset([\"metadata_version\", \"name\", \"version\"])\n\n\nclass _Validator(Generic[T]):\n    \"\"\"Validate a metadata field.\n\n    All _process_*() methods correspond to a core metadata field. The method is\n    called with the field's raw value. If the raw value is valid it is returned\n    in its \"enriched\" form (e.g. ``version.Version`` for the ``Version`` field).\n    If the raw value is invalid, :exc:`InvalidMetadata` is raised (with a cause\n    as appropriate).\n    \"\"\"\n\n    name: str\n    raw_name: str\n    added: _MetadataVersion\n\n    def __init__(\n        self,\n        *,\n        added: _MetadataVersion = \"1.0\",\n    ) -> None:\n        self.added = added\n\n    def __set_name__(self, _owner: Metadata, name: str) -> None:\n        self.name = name\n        self.raw_name = _RAW_TO_EMAIL_MAPPING[name]\n\n    def __get__(self, instance: Metadata, _owner: type[Metadata]) -> T:\n        # With Python 3.8, the caching can be replaced with functools.cached_property().\n        # No need to check the cache as attribute lookup will resolve into the\n        # instance's __dict__ before __get__ is called.\n        cache = instance.__dict__\n        value = instance._raw.get(self.name)\n\n        # To make the _process_* methods easier, we'll check if the value is None\n        # and if this field is NOT a required attribute, and if both of those\n        # things are true, we'll skip the the converter. This will mean that the\n        # converters never have to deal with the None union.\n        if self.name in _REQUIRED_ATTRS or value is not None:\n            try:\n                converter: Callable[[Any], T] = getattr(self, f\"_process_{self.name}\")\n            except AttributeError:\n                pass\n            else:\n                value = converter(value)\n\n        cache[self.name] = value\n        try:\n            del instance._raw[self.name]  # type: ignore[misc]\n        except KeyError:\n            pass\n\n        return cast(T, value)\n\n    def _invalid_metadata(\n        self, msg: str, cause: Exception | None = None\n    ) -> InvalidMetadata:\n        exc = InvalidMetadata(\n            self.raw_name, msg.format_map({\"field\": repr(self.raw_name)})\n        )\n        exc.__cause__ = cause\n        return exc\n\n    def _process_metadata_version(self, value: str) -> _MetadataVersion:\n        # Implicitly makes Metadata-Version required.\n        if value not in _VALID_METADATA_VERSIONS:\n            raise self._invalid_metadata(f\"{value!r} is not a valid metadata version\")\n        return cast(_MetadataVersion, value)\n\n    def _process_name(self, value: str) -> str:\n        if not value:\n            raise self._invalid_metadata(\"{field} is a required field\")\n        # Validate the name as a side-effect.\n        try:\n            utils.canonicalize_name(value, validate=True)\n        except utils.InvalidName as exc:\n            raise self._invalid_metadata(\n                f\"{value!r} is invalid for {{field}}\", cause=exc\n            ) from exc\n        else:\n            return value\n\n    def _process_version(self, value: str) -> version_module.Version:\n        if not value:\n            raise self._invalid_metadata(\"{field} is a required field\")\n        try:\n            return version_module.parse(value)\n        except version_module.InvalidVersion as exc:\n            raise self._invalid_metadata(\n                f\"{value!r} is invalid for {{field}}\", cause=exc\n            ) from exc\n\n    def _process_summary(self, value: str) -> str:\n        \"\"\"Check the field contains no newlines.\"\"\"\n        if \"\\n\" in value:\n            raise self._invalid_metadata(\"{field} must be a single line\")\n        return value\n\n    def _process_description_content_type(self, value: str) -> str:\n        content_types = {\"text/plain\", \"text/x-rst\", \"text/markdown\"}\n        message = email.message.EmailMessage()\n        message[\"content-type\"] = value\n\n        content_type, parameters = (\n            # Defaults to `text/plain` if parsing failed.\n            message.get_content_type().lower(),\n            message[\"content-type\"].params,\n        )\n        # Check if content-type is valid or defaulted to `text/plain` and thus was\n        # not parseable.\n        if content_type not in content_types or content_type not in value.lower():\n            raise self._invalid_metadata(\n                f\"{{field}} must be one of {list(content_types)}, not {value!r}\"\n            )\n\n        charset = parameters.get(\"charset\", \"UTF-8\")\n        if charset != \"UTF-8\":\n            raise self._invalid_metadata(\n                f\"{{field}} can only specify the UTF-8 charset, not {list(charset)}\"\n            )\n\n        markdown_variants = {\"GFM\", \"CommonMark\"}\n        variant = parameters.get(\"variant\", \"GFM\")  # Use an acceptable default.\n        if content_type == \"text/markdown\" and variant not in markdown_variants:\n            raise self._invalid_metadata(\n                f\"valid Markdown variants for {{field}} are {list(markdown_variants)}, \"\n                f\"not {variant!r}\",\n            )\n        return value\n\n    def _process_dynamic(self, value: list[str]) -> list[str]:\n        for dynamic_field in map(str.lower, value):\n            if dynamic_field in {\"name\", \"version\", \"metadata-version\"}:\n                raise self._invalid_metadata(\n                    f\"{dynamic_field!r} is not allowed as a dynamic field\"\n                )\n            elif dynamic_field not in _EMAIL_TO_RAW_MAPPING:\n                raise self._invalid_metadata(\n                    f\"{dynamic_field!r} is not a valid dynamic field\"\n                )\n        return list(map(str.lower, value))\n\n    def _process_provides_extra(\n        self,\n        value: list[str],\n    ) -> list[utils.NormalizedName]:\n        normalized_names = []\n        try:\n            for name in value:\n                normalized_names.append(utils.canonicalize_name(name, validate=True))\n        except utils.InvalidName as exc:\n            raise self._invalid_metadata(\n                f\"{name!r} is invalid for {{field}}\", cause=exc\n            ) from exc\n        else:\n            return normalized_names\n\n    def _process_requires_python(self, value: str) -> specifiers.SpecifierSet:\n        try:\n            return specifiers.SpecifierSet(value)\n        except specifiers.InvalidSpecifier as exc:\n            raise self._invalid_metadata(\n                f\"{value!r} is invalid for {{field}}\", cause=exc\n            ) from exc\n\n    def _process_requires_dist(\n        self,\n        value: list[str],\n    ) -> list[requirements.Requirement]:\n        reqs = []\n        try:\n            for req in value:\n                reqs.append(requirements.Requirement(req))\n        except requirements.InvalidRequirement as exc:\n            raise self._invalid_metadata(\n                f\"{req!r} is invalid for {{field}}\", cause=exc\n            ) from exc\n        else:\n            return reqs\n\n    def _process_license_expression(\n        self, value: str\n    ) -> NormalizedLicenseExpression | None:\n        try:\n            return licenses.canonicalize_license_expression(value)\n        except ValueError as exc:\n            raise self._invalid_metadata(\n                f\"{value!r} is invalid for {{field}}\", cause=exc\n            ) from exc\n\n    def _process_license_files(self, value: list[str]) -> list[str]:\n        paths = []\n        for path in value:\n            if \"..\" in path:\n                raise self._invalid_metadata(\n                    f\"{path!r} is invalid for {{field}}, \"\n                    \"parent directory indicators are not allowed\"\n                )\n            if \"*\" in path:\n                raise self._invalid_metadata(\n                    f\"{path!r} is invalid for {{field}}, paths must be resolved\"\n                )\n            if (\n                pathlib.PurePosixPath(path).is_absolute()\n                or pathlib.PureWindowsPath(path).is_absolute()\n            ):\n                raise self._invalid_metadata(\n                    f\"{path!r} is invalid for {{field}}, paths must be relative\"\n                )\n            if pathlib.PureWindowsPath(path).as_posix() != path:\n                raise self._invalid_metadata(\n                    f\"{path!r} is invalid for {{field}}, \"\n                    \"paths must use '/' delimiter\"\n                )\n            paths.append(path)\n        return paths\n\n\nclass Metadata:\n    \"\"\"Representation of distribution metadata.\n\n    Compared to :class:`RawMetadata`, this class provides objects representing\n    metadata fields instead of only using built-in types. Any invalid metadata\n    will cause :exc:`InvalidMetadata` to be raised (with a\n    :py:attr:`~BaseException.__cause__` attribute as appropriate).\n    \"\"\"\n\n    _raw: RawMetadata\n\n    @classmethod\n    def from_raw(cls, data: RawMetadata, *, validate: bool = True) -> Metadata:\n        \"\"\"Create an instance from :class:`RawMetadata`.\n\n        If *validate* is true, all metadata will be validated. All exceptions\n        related to validation will be gathered and raised as an :class:`ExceptionGroup`.\n        \"\"\"\n        ins = cls()\n        ins._raw = data.copy()  # Mutations occur due to caching enriched values.\n\n        if validate:\n            exceptions: list[Exception] = []\n            try:\n                metadata_version = ins.metadata_version\n                metadata_age = _VALID_METADATA_VERSIONS.index(metadata_version)\n            except InvalidMetadata as metadata_version_exc:\n                exceptions.append(metadata_version_exc)\n                metadata_version = None\n\n            # Make sure to check for the fields that are present, the required\n            # fields (so their absence can be reported).\n            fields_to_check = frozenset(ins._raw) | _REQUIRED_ATTRS\n            # Remove fields that have already been checked.\n            fields_to_check -= {\"metadata_version\"}\n\n            for key in fields_to_check:\n                try:\n                    if metadata_version:\n                        # Can't use getattr() as that triggers descriptor protocol which\n                        # will fail due to no value for the instance argument.\n                        try:\n                            field_metadata_version = cls.__dict__[key].added\n                        except KeyError:\n                            exc = InvalidMetadata(key, f\"unrecognized field: {key!r}\")\n                            exceptions.append(exc)\n                            continue\n                        field_age = _VALID_METADATA_VERSIONS.index(\n                            field_metadata_version\n                        )\n                        if field_age > metadata_age:\n                            field = _RAW_TO_EMAIL_MAPPING[key]\n                            exc = InvalidMetadata(\n                                field,\n                                f\"{field} introduced in metadata version \"\n                                f\"{field_metadata_version}, not {metadata_version}\",\n                            )\n                            exceptions.append(exc)\n                            continue\n                    getattr(ins, key)\n                except InvalidMetadata as exc:\n                    exceptions.append(exc)\n\n            if exceptions:\n                raise ExceptionGroup(\"invalid metadata\", exceptions)\n\n        return ins\n\n    @classmethod\n    def from_email(cls, data: bytes | str, *, validate: bool = True) -> Metadata:\n        \"\"\"Parse metadata from email headers.\n\n        If *validate* is true, the metadata will be validated. All exceptions\n        related to validation will be gathered and raised as an :class:`ExceptionGroup`.\n        \"\"\"\n        raw, unparsed = parse_email(data)\n\n        if validate:\n            exceptions: list[Exception] = []\n            for unparsed_key in unparsed:\n                if unparsed_key in _EMAIL_TO_RAW_MAPPING:\n                    message = f\"{unparsed_key!r} has invalid data\"\n                else:\n                    message = f\"unrecognized field: {unparsed_key!r}\"\n                exceptions.append(InvalidMetadata(unparsed_key, message))\n\n            if exceptions:\n                raise ExceptionGroup(\"unparsed\", exceptions)\n\n        try:\n            return cls.from_raw(raw, validate=validate)\n        except ExceptionGroup as exc_group:\n            raise ExceptionGroup(\n                \"invalid or unparsed metadata\", exc_group.exceptions\n            ) from None\n\n    metadata_version: _Validator[_MetadataVersion] = _Validator()\n    \"\"\":external:ref:`core-metadata-metadata-version`\n    (required; validated to be a valid metadata version)\"\"\"\n    # `name` is not normalized/typed to NormalizedName so as to provide access to\n    # the original/raw name.\n    name: _Validator[str] = _Validator()\n    \"\"\":external:ref:`core-metadata-name`\n    (required; validated using :func:`~packaging.utils.canonicalize_name` and its\n    *validate* parameter)\"\"\"\n    version: _Validator[version_module.Version] = _Validator()\n    \"\"\":external:ref:`core-metadata-version` (required)\"\"\"\n    dynamic: _Validator[list[str] | None] = _Validator(\n        added=\"2.2\",\n    )\n    \"\"\":external:ref:`core-metadata-dynamic`\n    (validated against core metadata field names and lowercased)\"\"\"\n    platforms: _Validator[list[str] | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-platform`\"\"\"\n    supported_platforms: _Validator[list[str] | None] = _Validator(added=\"1.1\")\n    \"\"\":external:ref:`core-metadata-supported-platform`\"\"\"\n    summary: _Validator[str | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-summary` (validated to contain no newlines)\"\"\"\n    description: _Validator[str | None] = _Validator()  # TODO 2.1: can be in body\n    \"\"\":external:ref:`core-metadata-description`\"\"\"\n    description_content_type: _Validator[str | None] = _Validator(added=\"2.1\")\n    \"\"\":external:ref:`core-metadata-description-content-type` (validated)\"\"\"\n    keywords: _Validator[list[str] | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-keywords`\"\"\"\n    home_page: _Validator[str | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-home-page`\"\"\"\n    download_url: _Validator[str | None] = _Validator(added=\"1.1\")\n    \"\"\":external:ref:`core-metadata-download-url`\"\"\"\n    author: _Validator[str | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-author`\"\"\"\n    author_email: _Validator[str | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-author-email`\"\"\"\n    maintainer: _Validator[str | None] = _Validator(added=\"1.2\")\n    \"\"\":external:ref:`core-metadata-maintainer`\"\"\"\n    maintainer_email: _Validator[str | None] = _Validator(added=\"1.2\")\n    \"\"\":external:ref:`core-metadata-maintainer-email`\"\"\"\n    license: _Validator[str | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-license`\"\"\"\n    license_expression: _Validator[NormalizedLicenseExpression | None] = _Validator(\n        added=\"2.4\"\n    )\n    \"\"\":external:ref:`core-metadata-license-expression`\"\"\"\n    license_files: _Validator[list[str] | None] = _Validator(added=\"2.4\")\n    \"\"\":external:ref:`core-metadata-license-file`\"\"\"\n    classifiers: _Validator[list[str] | None] = _Validator(added=\"1.1\")\n    \"\"\":external:ref:`core-metadata-classifier`\"\"\"\n    requires_dist: _Validator[list[requirements.Requirement] | None] = _Validator(\n        added=\"1.2\"\n    )\n    \"\"\":external:ref:`core-metadata-requires-dist`\"\"\"\n    requires_python: _Validator[specifiers.SpecifierSet | None] = _Validator(\n        added=\"1.2\"\n    )\n    \"\"\":external:ref:`core-metadata-requires-python`\"\"\"\n    # Because `Requires-External` allows for non-PEP 440 version specifiers, we\n    # don't do any processing on the values.\n    requires_external: _Validator[list[str] | None] = _Validator(added=\"1.2\")\n    \"\"\":external:ref:`core-metadata-requires-external`\"\"\"\n    project_urls: _Validator[dict[str, str] | None] = _Validator(added=\"1.2\")\n    \"\"\":external:ref:`core-metadata-project-url`\"\"\"\n    # PEP 685 lets us raise an error if an extra doesn't pass `Name` validation\n    # regardless of metadata version.\n    provides_extra: _Validator[list[utils.NormalizedName] | None] = _Validator(\n        added=\"2.1\",\n    )\n    \"\"\":external:ref:`core-metadata-provides-extra`\"\"\"\n    provides_dist: _Validator[list[str] | None] = _Validator(added=\"1.2\")\n    \"\"\":external:ref:`core-metadata-provides-dist`\"\"\"\n    obsoletes_dist: _Validator[list[str] | None] = _Validator(added=\"1.2\")\n    \"\"\":external:ref:`core-metadata-obsoletes-dist`\"\"\"\n    requires: _Validator[list[str] | None] = _Validator(added=\"1.1\")\n    \"\"\"``Requires`` (deprecated)\"\"\"\n    provides: _Validator[list[str] | None] = _Validator(added=\"1.1\")\n    \"\"\"``Provides`` (deprecated)\"\"\"\n    obsoletes: _Validator[list[str] | None] = _Validator(added=\"1.1\")\n    \"\"\"``Obsoletes`` (deprecated)\"\"\"\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/packaging/requirements.py","size":2947,"sha1":"1c36b3e629a0f04f56cfcd9854e23639f2c6a639","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\nfrom __future__ import annotations\n\nfrom typing import Any, Iterator\n\nfrom ._parser import parse_requirement as _parse_requirement\nfrom ._tokenizer import ParserSyntaxError\nfrom .markers import Marker, _normalize_extra_values\nfrom .specifiers import SpecifierSet\nfrom .utils import canonicalize_name\n\n\nclass InvalidRequirement(ValueError):\n    \"\"\"\n    An invalid requirement was found, users should refer to PEP 508.\n    \"\"\"\n\n\nclass Requirement:\n    \"\"\"Parse a requirement.\n\n    Parse a given requirement string into its parts, such as name, specifier,\n    URL, and extras. Raises InvalidRequirement on a badly-formed requirement\n    string.\n    \"\"\"\n\n    # TODO: Can we test whether something is contained within a requirement?\n    #       If so how do we do that? Do we need to test against the _name_ of\n    #       the thing as well as the version? What about the markers?\n    # TODO: Can we normalize the name and extra name?\n\n    def __init__(self, requirement_string: str) -> None:\n        try:\n            parsed = _parse_requirement(requirement_string)\n        except ParserSyntaxError as e:\n            raise InvalidRequirement(str(e)) from e\n\n        self.name: str = parsed.name\n        self.url: str | None = parsed.url or None\n        self.extras: set[str] = set(parsed.extras or [])\n        self.specifier: SpecifierSet = SpecifierSet(parsed.specifier)\n        self.marker: Marker | None = None\n        if parsed.marker is not None:\n            self.marker = Marker.__new__(Marker)\n            self.marker._markers = _normalize_extra_values(parsed.marker)\n\n    def _iter_parts(self, name: str) -> Iterator[str]:\n        yield name\n\n        if self.extras:\n            formatted_extras = \",\".join(sorted(self.extras))\n            yield f\"[{formatted_extras}]\"\n\n        if self.specifier:\n            yield str(self.specifier)\n\n        if self.url:\n            yield f\"@ {self.url}\"\n            if self.marker:\n                yield \" \"\n\n        if self.marker:\n            yield f\"; {self.marker}\"\n\n    def __str__(self) -> str:\n        return \"\".join(self._iter_parts(self.name))\n\n    def __repr__(self) -> str:\n        return f\"<Requirement('{self}')>\"\n\n    def __hash__(self) -> int:\n        return hash(\n            (\n                self.__class__.__name__,\n                *self._iter_parts(canonicalize_name(self.name)),\n            )\n        )\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, Requirement):\n            return NotImplemented\n\n        return (\n            canonicalize_name(self.name) == canonicalize_name(other.name)\n            and self.extras == other.extras\n            and self.specifier == other.specifier\n            and self.url == other.url\n            and self.marker == other.marker\n        )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/packaging/specifiers.py","size":40098,"sha1":"219b71e6d5d0855d979e017f7f3f972ae4c5c18e","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\"\"\"\n.. testsetup::\n\n    from pip._vendor.packaging.specifiers import Specifier, SpecifierSet, InvalidSpecifier\n    from pip._vendor.packaging.version import Version\n\"\"\"\n\nfrom __future__ import annotations\n\nimport abc\nimport itertools\nimport re\nfrom typing import Callable, Iterable, Iterator, TypeVar, Union\n\nfrom .utils import canonicalize_version\nfrom .version import Version\n\nUnparsedVersion = Union[Version, str]\nUnparsedVersionVar = TypeVar(\"UnparsedVersionVar\", bound=UnparsedVersion)\nCallableOperator = Callable[[Version, str], bool]\n\n\ndef _coerce_version(version: UnparsedVersion) -> Version:\n    if not isinstance(version, Version):\n        version = Version(version)\n    return version\n\n\nclass InvalidSpecifier(ValueError):\n    \"\"\"\n    Raised when attempting to create a :class:`Specifier` with a specifier\n    string that is invalid.\n\n    >>> Specifier(\"lolwat\")\n    Traceback (most recent call last):\n        ...\n    packaging.specifiers.InvalidSpecifier: Invalid specifier: 'lolwat'\n    \"\"\"\n\n\nclass BaseSpecifier(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __str__(self) -> str:\n        \"\"\"\n        Returns the str representation of this Specifier-like object. This\n        should be representative of the Specifier itself.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __hash__(self) -> int:\n        \"\"\"\n        Returns a hash value for this Specifier-like object.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Returns a boolean representing whether or not the two Specifier-like\n        objects are equal.\n\n        :param other: The other object to check against.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def prereleases(self) -> bool | None:\n        \"\"\"Whether or not pre-releases as a whole are allowed.\n\n        This can be set to either ``True`` or ``False`` to explicitly enable or disable\n        prereleases or it can be set to ``None`` (the default) to use default semantics.\n        \"\"\"\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        \"\"\"Setter for :attr:`prereleases`.\n\n        :param value: The value to set.\n        \"\"\"\n\n    @abc.abstractmethod\n    def contains(self, item: str, prereleases: bool | None = None) -> bool:\n        \"\"\"\n        Determines if the given item is contained within this specifier.\n        \"\"\"\n\n    @abc.abstractmethod\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: bool | None = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"\n        Takes an iterable of items and filters them so that only items which\n        are contained within this specifier are allowed in it.\n        \"\"\"\n\n\nclass Specifier(BaseSpecifier):\n    \"\"\"This class abstracts handling of version specifiers.\n\n    .. tip::\n\n        It is generally not required to instantiate this manually. You should instead\n        prefer to work with :class:`SpecifierSet` instead, which can parse\n        comma-separated version specifiers (which is what package metadata contains).\n    \"\"\"\n\n    _operator_regex_str = r\"\"\"\n        (?P<operator>(~=|==|!=|<=|>=|<|>|===))\n        \"\"\"\n    _version_regex_str = r\"\"\"\n        (?P<version>\n            (?:\n                # The identity operators allow for an escape hatch that will\n                # do an exact string match of the version you wish to install.\n                # This will not be parsed by PEP 440 and we cannot determine\n                # any semantic meaning from it. This operator is discouraged\n                # but included entirely as an escape hatch.\n                (?<====)  # Only match for the identity operator\n                \\s*\n                [^\\s;)]*  # The arbitrary version can be just about anything,\n                          # we match everything except for whitespace, a\n                          # semi-colon for marker support, and a closing paren\n                          # since versions can be enclosed in them.\n            )\n            |\n            (?:\n                # The (non)equality operators allow for wild card and local\n                # versions to be specified so we have to define these two\n                # operators separately to enable that.\n                (?<===|!=)            # Only match for equals and not equals\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)*   # release\n\n                # You cannot use a wild card and a pre-release, post-release, a dev or\n                # local version together so group them with a | and make them optional.\n                (?:\n                    \\.\\*  # Wild card syntax of .*\n                    |\n                    (?:                                  # pre release\n                        [-_\\.]?\n                        (alpha|beta|preview|pre|a|b|c|rc)\n                        [-_\\.]?\n                        [0-9]*\n                    )?\n                    (?:                                  # post release\n                        (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                    )?\n                    (?:[-_\\.]?dev[-_\\.]?[0-9]*)?         # dev release\n                    (?:\\+[a-z0-9]+(?:[-_\\.][a-z0-9]+)*)? # local\n                )?\n            )\n            |\n            (?:\n                # The compatible operator requires at least two digits in the\n                # release segment.\n                (?<=~=)               # Only match for the compatible operator\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)+   # release  (We have a + instead of a *)\n                (?:                   # pre release\n                    [-_\\.]?\n                    (alpha|beta|preview|pre|a|b|c|rc)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n                (?:[-_\\.]?dev[-_\\.]?[0-9]*)?          # dev release\n            )\n            |\n            (?:\n                # All other operators only allow a sub set of what the\n                # (non)equality operators do. Specifically they do not allow\n                # local versions to be specified nor do they allow the prefix\n                # matching wild cards.\n                (?<!==|!=|~=)         # We have special cases for these\n                                      # operators so we want to make sure they\n                                      # don't match here.\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)*   # release\n                (?:                   # pre release\n                    [-_\\.]?\n                    (alpha|beta|preview|pre|a|b|c|rc)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n                (?:[-_\\.]?dev[-_\\.]?[0-9]*)?          # dev release\n            )\n        )\n        \"\"\"\n\n    _regex = re.compile(\n        r\"^\\s*\" + _operator_regex_str + _version_regex_str + r\"\\s*$\",\n        re.VERBOSE | re.IGNORECASE,\n    )\n\n    _operators = {\n        \"~=\": \"compatible\",\n        \"==\": \"equal\",\n        \"!=\": \"not_equal\",\n        \"<=\": \"less_than_equal\",\n        \">=\": \"greater_than_equal\",\n        \"<\": \"less_than\",\n        \">\": \"greater_than\",\n        \"===\": \"arbitrary\",\n    }\n\n    def __init__(self, spec: str = \"\", prereleases: bool | None = None) -> None:\n        \"\"\"Initialize a Specifier instance.\n\n        :param spec:\n            The string representation of a specifier which will be parsed and\n            normalized before use.\n        :param prereleases:\n            This tells the specifier if it should accept prerelease versions if\n            applicable or not. The default of ``None`` will autodetect it from the\n            given specifiers.\n        :raises InvalidSpecifier:\n            If the given specifier is invalid (i.e. bad syntax).\n        \"\"\"\n        match = self._regex.search(spec)\n        if not match:\n            raise InvalidSpecifier(f\"Invalid specifier: {spec!r}\")\n\n        self._spec: tuple[str, str] = (\n            match.group(\"operator\").strip(),\n            match.group(\"version\").strip(),\n        )\n\n        # Store whether or not this Specifier should accept prereleases\n        self._prereleases = prereleases\n\n    # https://github.com/python/mypy/pull/13475#pullrequestreview-1079784515\n    @property  # type: ignore[override]\n    def prereleases(self) -> bool:\n        # If there is an explicit prereleases set for this, then we'll just\n        # blindly use that.\n        if self._prereleases is not None:\n            return self._prereleases\n\n        # Look at all of our specifiers and determine if they are inclusive\n        # operators, and if they are if they are including an explicit\n        # prerelease.\n        operator, version = self._spec\n        if operator in [\"==\", \">=\", \"<=\", \"~=\", \"===\", \">\", \"<\"]:\n            # The == specifier can include a trailing .*, if it does we\n            # want to remove before parsing.\n            if operator == \"==\" and version.endswith(\".*\"):\n                version = version[:-2]\n\n            # Parse the version, and if it is a pre-release than this\n            # specifier allows pre-releases.\n            if Version(version).is_prerelease:\n                return True\n\n        return False\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        self._prereleases = value\n\n    @property\n    def operator(self) -> str:\n        \"\"\"The operator of this specifier.\n\n        >>> Specifier(\"==1.2.3\").operator\n        '=='\n        \"\"\"\n        return self._spec[0]\n\n    @property\n    def version(self) -> str:\n        \"\"\"The version of this specifier.\n\n        >>> Specifier(\"==1.2.3\").version\n        '1.2.3'\n        \"\"\"\n        return self._spec[1]\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the Specifier that shows all internal state.\n\n        >>> Specifier('>=1.0.0')\n        <Specifier('>=1.0.0')>\n        >>> Specifier('>=1.0.0', prereleases=False)\n        <Specifier('>=1.0.0', prereleases=False)>\n        >>> Specifier('>=1.0.0', prereleases=True)\n        <Specifier('>=1.0.0', prereleases=True)>\n        \"\"\"\n        pre = (\n            f\", prereleases={self.prereleases!r}\"\n            if self._prereleases is not None\n            else \"\"\n        )\n\n        return f\"<{self.__class__.__name__}({str(self)!r}{pre})>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the Specifier that can be round-tripped.\n\n        >>> str(Specifier('>=1.0.0'))\n        '>=1.0.0'\n        >>> str(Specifier('>=1.0.0', prereleases=False))\n        '>=1.0.0'\n        \"\"\"\n        return \"{}{}\".format(*self._spec)\n\n    @property\n    def _canonical_spec(self) -> tuple[str, str]:\n        canonical_version = canonicalize_version(\n            self._spec[1],\n            strip_trailing_zero=(self._spec[0] != \"~=\"),\n        )\n        return self._spec[0], canonical_version\n\n    def __hash__(self) -> int:\n        return hash(self._canonical_spec)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Whether or not the two Specifier-like objects are equal.\n\n        :param other: The other object to check against.\n\n        The value of :attr:`prereleases` is ignored.\n\n        >>> Specifier(\"==1.2.3\") == Specifier(\"== 1.2.3.0\")\n        True\n        >>> (Specifier(\"==1.2.3\", prereleases=False) ==\n        ...  Specifier(\"==1.2.3\", prereleases=True))\n        True\n        >>> Specifier(\"==1.2.3\") == \"==1.2.3\"\n        True\n        >>> Specifier(\"==1.2.3\") == Specifier(\"==1.2.4\")\n        False\n        >>> Specifier(\"==1.2.3\") == Specifier(\"~=1.2.3\")\n        False\n        \"\"\"\n        if isinstance(other, str):\n            try:\n                other = self.__class__(str(other))\n            except InvalidSpecifier:\n                return NotImplemented\n        elif not isinstance(other, self.__class__):\n            return NotImplemented\n\n        return self._canonical_spec == other._canonical_spec\n\n    def _get_operator(self, op: str) -> CallableOperator:\n        operator_callable: CallableOperator = getattr(\n            self, f\"_compare_{self._operators[op]}\"\n        )\n        return operator_callable\n\n    def _compare_compatible(self, prospective: Version, spec: str) -> bool:\n        # Compatible releases have an equivalent combination of >= and ==. That\n        # is that ~=2.2 is equivalent to >=2.2,==2.*. This allows us to\n        # implement this in terms of the other specifiers instead of\n        # implementing it ourselves. The only thing we need to do is construct\n        # the other specifiers.\n\n        # We want everything but the last item in the version, but we want to\n        # ignore suffix segments.\n        prefix = _version_join(\n            list(itertools.takewhile(_is_not_suffix, _version_split(spec)))[:-1]\n        )\n\n        # Add the prefix notation to the end of our string\n        prefix += \".*\"\n\n        return self._get_operator(\">=\")(prospective, spec) and self._get_operator(\"==\")(\n            prospective, prefix\n        )\n\n    def _compare_equal(self, prospective: Version, spec: str) -> bool:\n        # We need special logic to handle prefix matching\n        if spec.endswith(\".*\"):\n            # In the case of prefix matching we want to ignore local segment.\n            normalized_prospective = canonicalize_version(\n                prospective.public, strip_trailing_zero=False\n            )\n            # Get the normalized version string ignoring the trailing .*\n            normalized_spec = canonicalize_version(spec[:-2], strip_trailing_zero=False)\n            # Split the spec out by bangs and dots, and pretend that there is\n            # an implicit dot in between a release segment and a pre-release segment.\n            split_spec = _version_split(normalized_spec)\n\n            # Split the prospective version out by bangs and dots, and pretend\n            # that there is an implicit dot in between a release segment and\n            # a pre-release segment.\n            split_prospective = _version_split(normalized_prospective)\n\n            # 0-pad the prospective version before shortening it to get the correct\n            # shortened version.\n            padded_prospective, _ = _pad_version(split_prospective, split_spec)\n\n            # Shorten the prospective version to be the same length as the spec\n            # so that we can determine if the specifier is a prefix of the\n            # prospective version or not.\n            shortened_prospective = padded_prospective[: len(split_spec)]\n\n            return shortened_prospective == split_spec\n        else:\n            # Convert our spec string into a Version\n            spec_version = Version(spec)\n\n            # If the specifier does not have a local segment, then we want to\n            # act as if the prospective version also does not have a local\n            # segment.\n            if not spec_version.local:\n                prospective = Version(prospective.public)\n\n            return prospective == spec_version\n\n    def _compare_not_equal(self, prospective: Version, spec: str) -> bool:\n        return not self._compare_equal(prospective, spec)\n\n    def _compare_less_than_equal(self, prospective: Version, spec: str) -> bool:\n        # NB: Local version identifiers are NOT permitted in the version\n        # specifier, so local version labels can be universally removed from\n        # the prospective version.\n        return Version(prospective.public) <= Version(spec)\n\n    def _compare_greater_than_equal(self, prospective: Version, spec: str) -> bool:\n        # NB: Local version identifiers are NOT permitted in the version\n        # specifier, so local version labels can be universally removed from\n        # the prospective version.\n        return Version(prospective.public) >= Version(spec)\n\n    def _compare_less_than(self, prospective: Version, spec_str: str) -> bool:\n        # Convert our spec to a Version instance, since we'll want to work with\n        # it as a version.\n        spec = Version(spec_str)\n\n        # Check to see if the prospective version is less than the spec\n        # version. If it's not we can short circuit and just return False now\n        # instead of doing extra unneeded work.\n        if not prospective < spec:\n            return False\n\n        # This special case is here so that, unless the specifier itself\n        # includes is a pre-release version, that we do not accept pre-release\n        # versions for the version mentioned in the specifier (e.g. <3.1 should\n        # not match 3.1.dev0, but should match 3.0.dev0).\n        if not spec.is_prerelease and prospective.is_prerelease:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # If we've gotten to here, it means that prospective version is both\n        # less than the spec version *and* it's not a pre-release of the same\n        # version in the spec.\n        return True\n\n    def _compare_greater_than(self, prospective: Version, spec_str: str) -> bool:\n        # Convert our spec to a Version instance, since we'll want to work with\n        # it as a version.\n        spec = Version(spec_str)\n\n        # Check to see if the prospective version is greater than the spec\n        # version. If it's not we can short circuit and just return False now\n        # instead of doing extra unneeded work.\n        if not prospective > spec:\n            return False\n\n        # This special case is here so that, unless the specifier itself\n        # includes is a post-release version, that we do not accept\n        # post-release versions for the version mentioned in the specifier\n        # (e.g. >3.1 should not match 3.0.post0, but should match 3.2.post0).\n        if not spec.is_postrelease and prospective.is_postrelease:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # Ensure that we do not allow a local version of the version mentioned\n        # in the specifier, which is technically greater than, to match.\n        if prospective.local is not None:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # If we've gotten to here, it means that prospective version is both\n        # greater than the spec version *and* it's not a pre-release of the\n        # same version in the spec.\n        return True\n\n    def _compare_arbitrary(self, prospective: Version, spec: str) -> bool:\n        return str(prospective).lower() == str(spec).lower()\n\n    def __contains__(self, item: str | Version) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item: The item to check for.\n\n        This is used for the ``in`` operator and behaves the same as\n        :meth:`contains` with no ``prereleases`` argument passed.\n\n        >>> \"1.2.3\" in Specifier(\">=1.2.3\")\n        True\n        >>> Version(\"1.2.3\") in Specifier(\">=1.2.3\")\n        True\n        >>> \"1.0.0\" in Specifier(\">=1.2.3\")\n        False\n        >>> \"1.3.0a1\" in Specifier(\">=1.2.3\")\n        False\n        >>> \"1.3.0a1\" in Specifier(\">=1.2.3\", prereleases=True)\n        True\n        \"\"\"\n        return self.contains(item)\n\n    def contains(self, item: UnparsedVersion, prereleases: bool | None = None) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item:\n            The item to check for, which can be a version string or a\n            :class:`Version` instance.\n        :param prereleases:\n            Whether or not to match prereleases with this Specifier. If set to\n            ``None`` (the default), it uses :attr:`prereleases` to determine\n            whether or not prereleases are allowed.\n\n        >>> Specifier(\">=1.2.3\").contains(\"1.2.3\")\n        True\n        >>> Specifier(\">=1.2.3\").contains(Version(\"1.2.3\"))\n        True\n        >>> Specifier(\">=1.2.3\").contains(\"1.0.0\")\n        False\n        >>> Specifier(\">=1.2.3\").contains(\"1.3.0a1\")\n        False\n        >>> Specifier(\">=1.2.3\", prereleases=True).contains(\"1.3.0a1\")\n        True\n        >>> Specifier(\">=1.2.3\").contains(\"1.3.0a1\", prereleases=True)\n        True\n        \"\"\"\n\n        # Determine if prereleases are to be allowed or not.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # Normalize item to a Version, this allows us to have a shortcut for\n        # \"2.0\" in Specifier(\">=2\")\n        normalized_item = _coerce_version(item)\n\n        # Determine if we should be supporting prereleases in this specifier\n        # or not, if we do not support prereleases than we can short circuit\n        # logic if this version is a prereleases.\n        if normalized_item.is_prerelease and not prereleases:\n            return False\n\n        # Actually do the comparison to determine if this item is contained\n        # within this Specifier or not.\n        operator_callable: CallableOperator = self._get_operator(self.operator)\n        return operator_callable(normalized_item, self.version)\n\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: bool | None = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"Filter items in the given iterable, that match the specifier.\n\n        :param iterable:\n            An iterable that can contain version strings and :class:`Version` instances.\n            The items in the iterable will be filtered according to the specifier.\n        :param prereleases:\n            Whether or not to allow prereleases in the returned iterator. If set to\n            ``None`` (the default), it will be intelligently decide whether to allow\n            prereleases or not (based on the :attr:`prereleases` attribute, and\n            whether the only versions matching are prereleases).\n\n        This method is smarter than just ``filter(Specifier().contains, [...])``\n        because it implements the rule from :pep:`440` that a prerelease item\n        SHOULD be accepted if no other versions match the given specifier.\n\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.2.3\", \"1.3\", Version(\"1.4\")]))\n        ['1.2.3', '1.3', <Version('1.4')>]\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.5a1\"]))\n        ['1.5a1']\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        >>> list(Specifier(\">=1.2.3\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n        \"\"\"\n\n        yielded = False\n        found_prereleases = []\n\n        kw = {\"prereleases\": prereleases if prereleases is not None else True}\n\n        # Attempt to iterate over all the values in the iterable and if any of\n        # them match, yield them.\n        for version in iterable:\n            parsed_version = _coerce_version(version)\n\n            if self.contains(parsed_version, **kw):\n                # If our version is a prerelease, and we were not set to allow\n                # prereleases, then we'll store it for later in case nothing\n                # else matches this specifier.\n                if parsed_version.is_prerelease and not (\n                    prereleases or self.prereleases\n                ):\n                    found_prereleases.append(version)\n                # Either this is not a prerelease, or we should have been\n                # accepting prereleases from the beginning.\n                else:\n                    yielded = True\n                    yield version\n\n        # Now that we've iterated over everything, determine if we've yielded\n        # any values, and if we have not and we have any prereleases stored up\n        # then we will go ahead and yield the prereleases.\n        if not yielded and found_prereleases:\n            for version in found_prereleases:\n                yield version\n\n\n_prefix_regex = re.compile(r\"^([0-9]+)((?:a|b|c|rc)[0-9]+)$\")\n\n\ndef _version_split(version: str) -> list[str]:\n    \"\"\"Split version into components.\n\n    The split components are intended for version comparison. The logic does\n    not attempt to retain the original version string, so joining the\n    components back with :func:`_version_join` may not produce the original\n    version string.\n    \"\"\"\n    result: list[str] = []\n\n    epoch, _, rest = version.rpartition(\"!\")\n    result.append(epoch or \"0\")\n\n    for item in rest.split(\".\"):\n        match = _prefix_regex.search(item)\n        if match:\n            result.extend(match.groups())\n        else:\n            result.append(item)\n    return result\n\n\ndef _version_join(components: list[str]) -> str:\n    \"\"\"Join split version components into a version string.\n\n    This function assumes the input came from :func:`_version_split`, where the\n    first component must be the epoch (either empty or numeric), and all other\n    components numeric.\n    \"\"\"\n    epoch, *rest = components\n    return f\"{epoch}!{'.'.join(rest)}\"\n\n\ndef _is_not_suffix(segment: str) -> bool:\n    return not any(\n        segment.startswith(prefix) for prefix in (\"dev\", \"a\", \"b\", \"rc\", \"post\")\n    )\n\n\ndef _pad_version(left: list[str], right: list[str]) -> tuple[list[str], list[str]]:\n    left_split, right_split = [], []\n\n    # Get the release segment of our versions\n    left_split.append(list(itertools.takewhile(lambda x: x.isdigit(), left)))\n    right_split.append(list(itertools.takewhile(lambda x: x.isdigit(), right)))\n\n    # Get the rest of our versions\n    left_split.append(left[len(left_split[0]) :])\n    right_split.append(right[len(right_split[0]) :])\n\n    # Insert our padding\n    left_split.insert(1, [\"0\"] * max(0, len(right_split[0]) - len(left_split[0])))\n    right_split.insert(1, [\"0\"] * max(0, len(left_split[0]) - len(right_split[0])))\n\n    return (\n        list(itertools.chain.from_iterable(left_split)),\n        list(itertools.chain.from_iterable(right_split)),\n    )\n\n\nclass SpecifierSet(BaseSpecifier):\n    \"\"\"This class abstracts handling of a set of version specifiers.\n\n    It can be passed a single specifier (``>=3.0``), a comma-separated list of\n    specifiers (``>=3.0,!=3.1``), or no specifier at all.\n    \"\"\"\n\n    def __init__(\n        self,\n        specifiers: str | Iterable[Specifier] = \"\",\n        prereleases: bool | None = None,\n    ) -> None:\n        \"\"\"Initialize a SpecifierSet instance.\n\n        :param specifiers:\n            The string representation of a specifier or a comma-separated list of\n            specifiers which will be parsed and normalized before use.\n            May also be an iterable of ``Specifier`` instances, which will be used\n            as is.\n        :param prereleases:\n            This tells the SpecifierSet if it should accept prerelease versions if\n            applicable or not. The default of ``None`` will autodetect it from the\n            given specifiers.\n\n        :raises InvalidSpecifier:\n            If the given ``specifiers`` are not parseable than this exception will be\n            raised.\n        \"\"\"\n\n        if isinstance(specifiers, str):\n            # Split on `,` to break each individual specifier into its own item, and\n            # strip each item to remove leading/trailing whitespace.\n            split_specifiers = [s.strip() for s in specifiers.split(\",\") if s.strip()]\n\n            # Make each individual specifier a Specifier and save in a frozen set\n            # for later.\n            self._specs = frozenset(map(Specifier, split_specifiers))\n        else:\n            # Save the supplied specifiers in a frozen set.\n            self._specs = frozenset(specifiers)\n\n        # Store our prereleases value so we can use it later to determine if\n        # we accept prereleases or not.\n        self._prereleases = prereleases\n\n    @property\n    def prereleases(self) -> bool | None:\n        # If we have been given an explicit prerelease modifier, then we'll\n        # pass that through here.\n        if self._prereleases is not None:\n            return self._prereleases\n\n        # If we don't have any specifiers, and we don't have a forced value,\n        # then we'll just return None since we don't know if this should have\n        # pre-releases or not.\n        if not self._specs:\n            return None\n\n        # Otherwise we'll see if any of the given specifiers accept\n        # prereleases, if any of them do we'll return True, otherwise False.\n        return any(s.prereleases for s in self._specs)\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        self._prereleases = value\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the specifier set that shows all internal state.\n\n        Note that the ordering of the individual specifiers within the set may not\n        match the input string.\n\n        >>> SpecifierSet('>=1.0.0,!=2.0.0')\n        <SpecifierSet('!=2.0.0,>=1.0.0')>\n        >>> SpecifierSet('>=1.0.0,!=2.0.0', prereleases=False)\n        <SpecifierSet('!=2.0.0,>=1.0.0', prereleases=False)>\n        >>> SpecifierSet('>=1.0.0,!=2.0.0', prereleases=True)\n        <SpecifierSet('!=2.0.0,>=1.0.0', prereleases=True)>\n        \"\"\"\n        pre = (\n            f\", prereleases={self.prereleases!r}\"\n            if self._prereleases is not None\n            else \"\"\n        )\n\n        return f\"<SpecifierSet({str(self)!r}{pre})>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the specifier set that can be round-tripped.\n\n        Note that the ordering of the individual specifiers within the set may not\n        match the input string.\n\n        >>> str(SpecifierSet(\">=1.0.0,!=1.0.1\"))\n        '!=1.0.1,>=1.0.0'\n        >>> str(SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=False))\n        '!=1.0.1,>=1.0.0'\n        \"\"\"\n        return \",\".join(sorted(str(s) for s in self._specs))\n\n    def __hash__(self) -> int:\n        return hash(self._specs)\n\n    def __and__(self, other: SpecifierSet | str) -> SpecifierSet:\n        \"\"\"Return a SpecifierSet which is a combination of the two sets.\n\n        :param other: The other object to combine with.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") & '<=2.0.0,!=2.0.1'\n        <SpecifierSet('!=1.0.1,!=2.0.1,<=2.0.0,>=1.0.0')>\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") & SpecifierSet('<=2.0.0,!=2.0.1')\n        <SpecifierSet('!=1.0.1,!=2.0.1,<=2.0.0,>=1.0.0')>\n        \"\"\"\n        if isinstance(other, str):\n            other = SpecifierSet(other)\n        elif not isinstance(other, SpecifierSet):\n            return NotImplemented\n\n        specifier = SpecifierSet()\n        specifier._specs = frozenset(self._specs | other._specs)\n\n        if self._prereleases is None and other._prereleases is not None:\n            specifier._prereleases = other._prereleases\n        elif self._prereleases is not None and other._prereleases is None:\n            specifier._prereleases = self._prereleases\n        elif self._prereleases == other._prereleases:\n            specifier._prereleases = self._prereleases\n        else:\n            raise ValueError(\n                \"Cannot combine SpecifierSets with True and False prerelease \"\n                \"overrides.\"\n            )\n\n        return specifier\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Whether or not the two SpecifierSet-like objects are equal.\n\n        :param other: The other object to check against.\n\n        The value of :attr:`prereleases` is ignored.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> (SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=False) ==\n        ...  SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True))\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == \">=1.0.0,!=1.0.1\"\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0,!=1.0.2\")\n        False\n        \"\"\"\n        if isinstance(other, (str, Specifier)):\n            other = SpecifierSet(str(other))\n        elif not isinstance(other, SpecifierSet):\n            return NotImplemented\n\n        return self._specs == other._specs\n\n    def __len__(self) -> int:\n        \"\"\"Returns the number of specifiers in this specifier set.\"\"\"\n        return len(self._specs)\n\n    def __iter__(self) -> Iterator[Specifier]:\n        \"\"\"\n        Returns an iterator over all the underlying :class:`Specifier` instances\n        in this specifier set.\n\n        >>> sorted(SpecifierSet(\">=1.0.0,!=1.0.1\"), key=str)\n        [<Specifier('!=1.0.1')>, <Specifier('>=1.0.0')>]\n        \"\"\"\n        return iter(self._specs)\n\n    def __contains__(self, item: UnparsedVersion) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item: The item to check for.\n\n        This is used for the ``in`` operator and behaves the same as\n        :meth:`contains` with no ``prereleases`` argument passed.\n\n        >>> \"1.2.3\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> Version(\"1.2.3\") in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> \"1.0.1\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        False\n        >>> \"1.3.0a1\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        False\n        >>> \"1.3.0a1\" in SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True)\n        True\n        \"\"\"\n        return self.contains(item)\n\n    def contains(\n        self,\n        item: UnparsedVersion,\n        prereleases: bool | None = None,\n        installed: bool | None = None,\n    ) -> bool:\n        \"\"\"Return whether or not the item is contained in this SpecifierSet.\n\n        :param item:\n            The item to check for, which can be a version string or a\n            :class:`Version` instance.\n        :param prereleases:\n            Whether or not to match prereleases with this SpecifierSet. If set to\n            ``None`` (the default), it uses :attr:`prereleases` to determine\n            whether or not prereleases are allowed.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.2.3\")\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(Version(\"1.2.3\"))\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.0.1\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.3.0a1\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True).contains(\"1.3.0a1\")\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.3.0a1\", prereleases=True)\n        True\n        \"\"\"\n        # Ensure that our item is a Version instance.\n        if not isinstance(item, Version):\n            item = Version(item)\n\n        # Determine if we're forcing a prerelease or not, if we're not forcing\n        # one for this particular filter call, then we'll use whatever the\n        # SpecifierSet thinks for whether or not we should support prereleases.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # We can determine if we're going to allow pre-releases by looking to\n        # see if any of the underlying items supports them. If none of them do\n        # and this item is a pre-release then we do not allow it and we can\n        # short circuit that here.\n        # Note: This means that 1.0.dev1 would not be contained in something\n        #       like >=1.0.devabc however it would be in >=1.0.debabc,>0.0.dev0\n        if not prereleases and item.is_prerelease:\n            return False\n\n        if installed and item.is_prerelease:\n            item = Version(item.base_version)\n\n        # We simply dispatch to the underlying specs here to make sure that the\n        # given version is contained within all of them.\n        # Note: This use of all() here means that an empty set of specifiers\n        #       will always return True, this is an explicit design decision.\n        return all(s.contains(item, prereleases=prereleases) for s in self._specs)\n\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: bool | None = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"Filter items in the given iterable, that match the specifiers in this set.\n\n        :param iterable:\n            An iterable that can contain version strings and :class:`Version` instances.\n            The items in the iterable will be filtered according to the specifier.\n        :param prereleases:\n            Whether or not to allow prereleases in the returned iterator. If set to\n            ``None`` (the default), it will be intelligently decide whether to allow\n            prereleases or not (based on the :attr:`prereleases` attribute, and\n            whether the only versions matching are prereleases).\n\n        This method is smarter than just ``filter(SpecifierSet(...).contains, [...])``\n        because it implements the rule from :pep:`440` that a prerelease item\n        SHOULD be accepted if no other versions match the given specifier.\n\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.3\", Version(\"1.4\")]))\n        ['1.3', <Version('1.4')>]\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.5a1\"]))\n        []\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        >>> list(SpecifierSet(\">=1.2.3\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n\n        An \"empty\" SpecifierSet will filter items based on the presence of prerelease\n        versions in the set.\n\n        >>> list(SpecifierSet(\"\").filter([\"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(SpecifierSet(\"\").filter([\"1.5a1\"]))\n        ['1.5a1']\n        >>> list(SpecifierSet(\"\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n        >>> list(SpecifierSet(\"\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        \"\"\"\n        # Determine if we're forcing a prerelease or not, if we're not forcing\n        # one for this particular filter call, then we'll use whatever the\n        # SpecifierSet thinks for whether or not we should support prereleases.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # If we have any specifiers, then we want to wrap our iterable in the\n        # filter method for each one, this will act as a logical AND amongst\n        # each specifier.\n        if self._specs:\n            for spec in self._specs:\n                iterable = spec.filter(iterable, prereleases=bool(prereleases))\n            return iter(iterable)\n        # If we do not have any specifiers, then we need to have a rough filter\n        # which will filter out any pre-releases, unless there are no final\n        # releases.\n        else:\n            filtered: list[UnparsedVersionVar] = []\n            found_prereleases: list[UnparsedVersionVar] = []\n\n            for item in iterable:\n                parsed_version = _coerce_version(item)\n\n                # Store any item which is a pre-release for later unless we've\n                # already found a final version or we are accepting prereleases\n                if parsed_version.is_prerelease and not prereleases:\n                    if not filtered:\n                        found_prereleases.append(item)\n                else:\n                    filtered.append(item)\n\n            # If we've found no items except for pre-releases, then we'll go\n            # ahead and use the pre-releases\n            if not filtered and found_prereleases and prereleases is None:\n                return iter(found_prereleases)\n\n            return iter(filtered)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/packaging/tags.py","size":21014,"sha1":"ad4f459a2d715ce2cec9612ae2c5e4ed05a8cc4f","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport logging\nimport platform\nimport re\nimport struct\nimport subprocess\nimport sys\nimport sysconfig\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom typing import (\n    Iterable,\n    Iterator,\n    Sequence,\n    Tuple,\n    cast,\n)\n\nfrom . import _manylinux, _musllinux\n\nlogger = logging.getLogger(__name__)\n\nPythonVersion = Sequence[int]\nAppleVersion = Tuple[int, int]\n\nINTERPRETER_SHORT_NAMES: dict[str, str] = {\n    \"python\": \"py\",  # Generic.\n    \"cpython\": \"cp\",\n    \"pypy\": \"pp\",\n    \"ironpython\": \"ip\",\n    \"jython\": \"jy\",\n}\n\n\n_32_BIT_INTERPRETER = struct.calcsize(\"P\") == 4\n\n\nclass Tag:\n    \"\"\"\n    A representation of the tag triple for a wheel.\n\n    Instances are considered immutable and thus are hashable. Equality checking\n    is also supported.\n    \"\"\"\n\n    __slots__ = [\"_abi\", \"_hash\", \"_interpreter\", \"_platform\"]\n\n    def __init__(self, interpreter: str, abi: str, platform: str) -> None:\n        self._interpreter = interpreter.lower()\n        self._abi = abi.lower()\n        self._platform = platform.lower()\n        # The __hash__ of every single element in a Set[Tag] will be evaluated each time\n        # that a set calls its `.disjoint()` method, which may be called hundreds of\n        # times when scanning a page of links for packages with tags matching that\n        # Set[Tag]. Pre-computing the value here produces significant speedups for\n        # downstream consumers.\n        self._hash = hash((self._interpreter, self._abi, self._platform))\n\n    @property\n    def interpreter(self) -> str:\n        return self._interpreter\n\n    @property\n    def abi(self) -> str:\n        return self._abi\n\n    @property\n    def platform(self) -> str:\n        return self._platform\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Tag):\n            return NotImplemented\n\n        return (\n            (self._hash == other._hash)  # Short-circuit ASAP for perf reasons.\n            and (self._platform == other._platform)\n            and (self._abi == other._abi)\n            and (self._interpreter == other._interpreter)\n        )\n\n    def __hash__(self) -> int:\n        return self._hash\n\n    def __str__(self) -> str:\n        return f\"{self._interpreter}-{self._abi}-{self._platform}\"\n\n    def __repr__(self) -> str:\n        return f\"<{self} @ {id(self)}>\"\n\n\ndef parse_tag(tag: str) -> frozenset[Tag]:\n    \"\"\"\n    Parses the provided tag (e.g. `py3-none-any`) into a frozenset of Tag instances.\n\n    Returning a set is required due to the possibility that the tag is a\n    compressed tag set.\n    \"\"\"\n    tags = set()\n    interpreters, abis, platforms = tag.split(\"-\")\n    for interpreter in interpreters.split(\".\"):\n        for abi in abis.split(\".\"):\n            for platform_ in platforms.split(\".\"):\n                tags.add(Tag(interpreter, abi, platform_))\n    return frozenset(tags)\n\n\ndef _get_config_var(name: str, warn: bool = False) -> int | str | None:\n    value: int | str | None = sysconfig.get_config_var(name)\n    if value is None and warn:\n        logger.debug(\n            \"Config variable '%s' is unset, Python ABI tag may be incorrect\", name\n        )\n    return value\n\n\ndef _normalize_string(string: str) -> str:\n    return string.replace(\".\", \"_\").replace(\"-\", \"_\").replace(\" \", \"_\")\n\n\ndef _is_threaded_cpython(abis: list[str]) -> bool:\n    \"\"\"\n    Determine if the ABI corresponds to a threaded (`--disable-gil`) build.\n\n    The threaded builds are indicated by a \"t\" in the abiflags.\n    \"\"\"\n    if len(abis) == 0:\n        return False\n    # expect e.g., cp313\n    m = re.match(r\"cp\\d+(.*)\", abis[0])\n    if not m:\n        return False\n    abiflags = m.group(1)\n    return \"t\" in abiflags\n\n\ndef _abi3_applies(python_version: PythonVersion, threading: bool) -> bool:\n    \"\"\"\n    Determine if the Python version supports abi3.\n\n    PEP 384 was first implemented in Python 3.2. The threaded (`--disable-gil`)\n    builds do not support abi3.\n    \"\"\"\n    return len(python_version) > 1 and tuple(python_version) >= (3, 2) and not threading\n\n\ndef _cpython_abis(py_version: PythonVersion, warn: bool = False) -> list[str]:\n    py_version = tuple(py_version)  # To allow for version comparison.\n    abis = []\n    version = _version_nodot(py_version[:2])\n    threading = debug = pymalloc = ucs4 = \"\"\n    with_debug = _get_config_var(\"Py_DEBUG\", warn)\n    has_refcount = hasattr(sys, \"gettotalrefcount\")\n    # Windows doesn't set Py_DEBUG, so checking for support of debug-compiled\n    # extension modules is the best option.\n    # https://github.com/pypa/pip/issues/3383#issuecomment-173267692\n    has_ext = \"_d.pyd\" in EXTENSION_SUFFIXES\n    if with_debug or (with_debug is None and (has_refcount or has_ext)):\n        debug = \"d\"\n    if py_version >= (3, 13) and _get_config_var(\"Py_GIL_DISABLED\", warn):\n        threading = \"t\"\n    if py_version < (3, 8):\n        with_pymalloc = _get_config_var(\"WITH_PYMALLOC\", warn)\n        if with_pymalloc or with_pymalloc is None:\n            pymalloc = \"m\"\n        if py_version < (3, 3):\n            unicode_size = _get_config_var(\"Py_UNICODE_SIZE\", warn)\n            if unicode_size == 4 or (\n                unicode_size is None and sys.maxunicode == 0x10FFFF\n            ):\n                ucs4 = \"u\"\n    elif debug:\n        # Debug builds can also load \"normal\" extension modules.\n        # We can also assume no UCS-4 or pymalloc requirement.\n        abis.append(f\"cp{version}{threading}\")\n    abis.insert(0, f\"cp{version}{threading}{debug}{pymalloc}{ucs4}\")\n    return abis\n\n\ndef cpython_tags(\n    python_version: PythonVersion | None = None,\n    abis: Iterable[str] | None = None,\n    platforms: Iterable[str] | None = None,\n    *,\n    warn: bool = False,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the tags for a CPython interpreter.\n\n    The tags consist of:\n    - cp<python_version>-<abi>-<platform>\n    - cp<python_version>-abi3-<platform>\n    - cp<python_version>-none-<platform>\n    - cp<less than python_version>-abi3-<platform>  # Older Python versions down to 3.2.\n\n    If python_version only specifies a major version then user-provided ABIs and\n    the 'none' ABItag will be used.\n\n    If 'abi3' or 'none' are specified in 'abis' then they will be yielded at\n    their normal position and not at the beginning.\n    \"\"\"\n    if not python_version:\n        python_version = sys.version_info[:2]\n\n    interpreter = f\"cp{_version_nodot(python_version[:2])}\"\n\n    if abis is None:\n        if len(python_version) > 1:\n            abis = _cpython_abis(python_version, warn)\n        else:\n            abis = []\n    abis = list(abis)\n    # 'abi3' and 'none' are explicitly handled later.\n    for explicit_abi in (\"abi3\", \"none\"):\n        try:\n            abis.remove(explicit_abi)\n        except ValueError:\n            pass\n\n    platforms = list(platforms or platform_tags())\n    for abi in abis:\n        for platform_ in platforms:\n            yield Tag(interpreter, abi, platform_)\n\n    threading = _is_threaded_cpython(abis)\n    use_abi3 = _abi3_applies(python_version, threading)\n    if use_abi3:\n        yield from (Tag(interpreter, \"abi3\", platform_) for platform_ in platforms)\n    yield from (Tag(interpreter, \"none\", platform_) for platform_ in platforms)\n\n    if use_abi3:\n        for minor_version in range(python_version[1] - 1, 1, -1):\n            for platform_ in platforms:\n                version = _version_nodot((python_version[0], minor_version))\n                interpreter = f\"cp{version}\"\n                yield Tag(interpreter, \"abi3\", platform_)\n\n\ndef _generic_abi() -> list[str]:\n    \"\"\"\n    Return the ABI tag based on EXT_SUFFIX.\n    \"\"\"\n    # The following are examples of `EXT_SUFFIX`.\n    # We want to keep the parts which are related to the ABI and remove the\n    # parts which are related to the platform:\n    # - linux:   '.cpython-310-x86_64-linux-gnu.so' => cp310\n    # - mac:     '.cpython-310-darwin.so'           => cp310\n    # - win:     '.cp310-win_amd64.pyd'             => cp310\n    # - win:     '.pyd'                             => cp37 (uses _cpython_abis())\n    # - pypy:    '.pypy38-pp73-x86_64-linux-gnu.so' => pypy38_pp73\n    # - graalpy: '.graalpy-38-native-x86_64-darwin.dylib'\n    #                                               => graalpy_38_native\n\n    ext_suffix = _get_config_var(\"EXT_SUFFIX\", warn=True)\n    if not isinstance(ext_suffix, str) or ext_suffix[0] != \".\":\n        raise SystemError(\"invalid sysconfig.get_config_var('EXT_SUFFIX')\")\n    parts = ext_suffix.split(\".\")\n    if len(parts) < 3:\n        # CPython3.7 and earlier uses \".pyd\" on Windows.\n        return _cpython_abis(sys.version_info[:2])\n    soabi = parts[1]\n    if soabi.startswith(\"cpython\"):\n        # non-windows\n        abi = \"cp\" + soabi.split(\"-\")[1]\n    elif soabi.startswith(\"cp\"):\n        # windows\n        abi = soabi.split(\"-\")[0]\n    elif soabi.startswith(\"pypy\"):\n        abi = \"-\".join(soabi.split(\"-\")[:2])\n    elif soabi.startswith(\"graalpy\"):\n        abi = \"-\".join(soabi.split(\"-\")[:3])\n    elif soabi:\n        # pyston, ironpython, others?\n        abi = soabi\n    else:\n        return []\n    return [_normalize_string(abi)]\n\n\ndef generic_tags(\n    interpreter: str | None = None,\n    abis: Iterable[str] | None = None,\n    platforms: Iterable[str] | None = None,\n    *,\n    warn: bool = False,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the tags for a generic interpreter.\n\n    The tags consist of:\n    - <interpreter>-<abi>-<platform>\n\n    The \"none\" ABI will be added if it was not explicitly provided.\n    \"\"\"\n    if not interpreter:\n        interp_name = interpreter_name()\n        interp_version = interpreter_version(warn=warn)\n        interpreter = \"\".join([interp_name, interp_version])\n    if abis is None:\n        abis = _generic_abi()\n    else:\n        abis = list(abis)\n    platforms = list(platforms or platform_tags())\n    if \"none\" not in abis:\n        abis.append(\"none\")\n    for abi in abis:\n        for platform_ in platforms:\n            yield Tag(interpreter, abi, platform_)\n\n\ndef _py_interpreter_range(py_version: PythonVersion) -> Iterator[str]:\n    \"\"\"\n    Yields Python versions in descending order.\n\n    After the latest version, the major-only version will be yielded, and then\n    all previous versions of that major version.\n    \"\"\"\n    if len(py_version) > 1:\n        yield f\"py{_version_nodot(py_version[:2])}\"\n    yield f\"py{py_version[0]}\"\n    if len(py_version) > 1:\n        for minor in range(py_version[1] - 1, -1, -1):\n            yield f\"py{_version_nodot((py_version[0], minor))}\"\n\n\ndef compatible_tags(\n    python_version: PythonVersion | None = None,\n    interpreter: str | None = None,\n    platforms: Iterable[str] | None = None,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the sequence of tags that are compatible with a specific version of Python.\n\n    The tags consist of:\n    - py*-none-<platform>\n    - <interpreter>-none-any  # ... if `interpreter` is provided.\n    - py*-none-any\n    \"\"\"\n    if not python_version:\n        python_version = sys.version_info[:2]\n    platforms = list(platforms or platform_tags())\n    for version in _py_interpreter_range(python_version):\n        for platform_ in platforms:\n            yield Tag(version, \"none\", platform_)\n    if interpreter:\n        yield Tag(interpreter, \"none\", \"any\")\n    for version in _py_interpreter_range(python_version):\n        yield Tag(version, \"none\", \"any\")\n\n\ndef _mac_arch(arch: str, is_32bit: bool = _32_BIT_INTERPRETER) -> str:\n    if not is_32bit:\n        return arch\n\n    if arch.startswith(\"ppc\"):\n        return \"ppc\"\n\n    return \"i386\"\n\n\ndef _mac_binary_formats(version: AppleVersion, cpu_arch: str) -> list[str]:\n    formats = [cpu_arch]\n    if cpu_arch == \"x86_64\":\n        if version < (10, 4):\n            return []\n        formats.extend([\"intel\", \"fat64\", \"fat32\"])\n\n    elif cpu_arch == \"i386\":\n        if version < (10, 4):\n            return []\n        formats.extend([\"intel\", \"fat32\", \"fat\"])\n\n    elif cpu_arch == \"ppc64\":\n        # TODO: Need to care about 32-bit PPC for ppc64 through 10.2?\n        if version > (10, 5) or version < (10, 4):\n            return []\n        formats.append(\"fat64\")\n\n    elif cpu_arch == \"ppc\":\n        if version > (10, 6):\n            return []\n        formats.extend([\"fat32\", \"fat\"])\n\n    if cpu_arch in {\"arm64\", \"x86_64\"}:\n        formats.append(\"universal2\")\n\n    if cpu_arch in {\"x86_64\", \"i386\", \"ppc64\", \"ppc\", \"intel\"}:\n        formats.append(\"universal\")\n\n    return formats\n\n\ndef mac_platforms(\n    version: AppleVersion | None = None, arch: str | None = None\n) -> Iterator[str]:\n    \"\"\"\n    Yields the platform tags for a macOS system.\n\n    The `version` parameter is a two-item tuple specifying the macOS version to\n    generate platform tags for. The `arch` parameter is the CPU architecture to\n    generate platform tags for. Both parameters default to the appropriate value\n    for the current system.\n    \"\"\"\n    version_str, _, cpu_arch = platform.mac_ver()\n    if version is None:\n        version = cast(\"AppleVersion\", tuple(map(int, version_str.split(\".\")[:2])))\n        if version == (10, 16):\n            # When built against an older macOS SDK, Python will report macOS 10.16\n            # instead of the real version.\n            version_str = subprocess.run(\n                [\n                    sys.executable,\n                    \"-sS\",\n                    \"-c\",\n                    \"import platform; print(platform.mac_ver()[0])\",\n                ],\n                check=True,\n                env={\"SYSTEM_VERSION_COMPAT\": \"0\"},\n                stdout=subprocess.PIPE,\n                text=True,\n            ).stdout\n            version = cast(\"AppleVersion\", tuple(map(int, version_str.split(\".\")[:2])))\n    else:\n        version = version\n    if arch is None:\n        arch = _mac_arch(cpu_arch)\n    else:\n        arch = arch\n\n    if (10, 0) <= version and version < (11, 0):\n        # Prior to Mac OS 11, each yearly release of Mac OS bumped the\n        # \"minor\" version number.  The major version was always 10.\n        major_version = 10\n        for minor_version in range(version[1], -1, -1):\n            compat_version = major_version, minor_version\n            binary_formats = _mac_binary_formats(compat_version, arch)\n            for binary_format in binary_formats:\n                yield f\"macosx_{major_version}_{minor_version}_{binary_format}\"\n\n    if version >= (11, 0):\n        # Starting with Mac OS 11, each yearly release bumps the major version\n        # number.   The minor versions are now the midyear updates.\n        minor_version = 0\n        for major_version in range(version[0], 10, -1):\n            compat_version = major_version, minor_version\n            binary_formats = _mac_binary_formats(compat_version, arch)\n            for binary_format in binary_formats:\n                yield f\"macosx_{major_version}_{minor_version}_{binary_format}\"\n\n    if version >= (11, 0):\n        # Mac OS 11 on x86_64 is compatible with binaries from previous releases.\n        # Arm64 support was introduced in 11.0, so no Arm binaries from previous\n        # releases exist.\n        #\n        # However, the \"universal2\" binary format can have a\n        # macOS version earlier than 11.0 when the x86_64 part of the binary supports\n        # that version of macOS.\n        major_version = 10\n        if arch == \"x86_64\":\n            for minor_version in range(16, 3, -1):\n                compat_version = major_version, minor_version\n                binary_formats = _mac_binary_formats(compat_version, arch)\n                for binary_format in binary_formats:\n                    yield f\"macosx_{major_version}_{minor_version}_{binary_format}\"\n        else:\n            for minor_version in range(16, 3, -1):\n                compat_version = major_version, minor_version\n                binary_format = \"universal2\"\n                yield f\"macosx_{major_version}_{minor_version}_{binary_format}\"\n\n\ndef ios_platforms(\n    version: AppleVersion | None = None, multiarch: str | None = None\n) -> Iterator[str]:\n    \"\"\"\n    Yields the platform tags for an iOS system.\n\n    :param version: A two-item tuple specifying the iOS version to generate\n        platform tags for. Defaults to the current iOS version.\n    :param multiarch: The CPU architecture+ABI to generate platform tags for -\n        (the value used by `sys.implementation._multiarch` e.g.,\n        `arm64_iphoneos` or `x84_64_iphonesimulator`). Defaults to the current\n        multiarch value.\n    \"\"\"\n    if version is None:\n        # if iOS is the current platform, ios_ver *must* be defined. However,\n        # it won't exist for CPython versions before 3.13, which causes a mypy\n        # error.\n        _, release, _, _ = platform.ios_ver()  # type: ignore[attr-defined, unused-ignore]\n        version = cast(\"AppleVersion\", tuple(map(int, release.split(\".\")[:2])))\n\n    if multiarch is None:\n        multiarch = sys.implementation._multiarch\n    multiarch = multiarch.replace(\"-\", \"_\")\n\n    ios_platform_template = \"ios_{major}_{minor}_{multiarch}\"\n\n    # Consider any iOS major.minor version from the version requested, down to\n    # 12.0. 12.0 is the first iOS version that is known to have enough features\n    # to support CPython. Consider every possible minor release up to X.9. There\n    # highest the minor has ever gone is 8 (14.8 and 15.8) but having some extra\n    # candidates that won't ever match doesn't really hurt, and it saves us from\n    # having to keep an explicit list of known iOS versions in the code. Return\n    # the results descending order of version number.\n\n    # If the requested major version is less than 12, there won't be any matches.\n    if version[0] < 12:\n        return\n\n    # Consider the actual X.Y version that was requested.\n    yield ios_platform_template.format(\n        major=version[0], minor=version[1], multiarch=multiarch\n    )\n\n    # Consider every minor version from X.0 to the minor version prior to the\n    # version requested by the platform.\n    for minor in range(version[1] - 1, -1, -1):\n        yield ios_platform_template.format(\n            major=version[0], minor=minor, multiarch=multiarch\n        )\n\n    for major in range(version[0] - 1, 11, -1):\n        for minor in range(9, -1, -1):\n            yield ios_platform_template.format(\n                major=major, minor=minor, multiarch=multiarch\n            )\n\n\ndef _linux_platforms(is_32bit: bool = _32_BIT_INTERPRETER) -> Iterator[str]:\n    linux = _normalize_string(sysconfig.get_platform())\n    if not linux.startswith(\"linux_\"):\n        # we should never be here, just yield the sysconfig one and return\n        yield linux\n        return\n    if is_32bit:\n        if linux == \"linux_x86_64\":\n            linux = \"linux_i686\"\n        elif linux == \"linux_aarch64\":\n            linux = \"linux_armv8l\"\n    _, arch = linux.split(\"_\", 1)\n    archs = {\"armv8l\": [\"armv8l\", \"armv7l\"]}.get(arch, [arch])\n    yield from _manylinux.platform_tags(archs)\n    yield from _musllinux.platform_tags(archs)\n    for arch in archs:\n        yield f\"linux_{arch}\"\n\n\ndef _generic_platforms() -> Iterator[str]:\n    yield _normalize_string(sysconfig.get_platform())\n\n\ndef platform_tags() -> Iterator[str]:\n    \"\"\"\n    Provides the platform tags for this installation.\n    \"\"\"\n    if platform.system() == \"Darwin\":\n        return mac_platforms()\n    elif platform.system() == \"iOS\":\n        return ios_platforms()\n    elif platform.system() == \"Linux\":\n        return _linux_platforms()\n    else:\n        return _generic_platforms()\n\n\ndef interpreter_name() -> str:\n    \"\"\"\n    Returns the name of the running interpreter.\n\n    Some implementations have a reserved, two-letter abbreviation which will\n    be returned when appropriate.\n    \"\"\"\n    name = sys.implementation.name\n    return INTERPRETER_SHORT_NAMES.get(name) or name\n\n\ndef interpreter_version(*, warn: bool = False) -> str:\n    \"\"\"\n    Returns the version of the running interpreter.\n    \"\"\"\n    version = _get_config_var(\"py_version_nodot\", warn=warn)\n    if version:\n        version = str(version)\n    else:\n        version = _version_nodot(sys.version_info[:2])\n    return version\n\n\ndef _version_nodot(version: PythonVersion) -> str:\n    return \"\".join(map(str, version))\n\n\ndef sys_tags(*, warn: bool = False) -> Iterator[Tag]:\n    \"\"\"\n    Returns the sequence of tag triples for the running interpreter.\n\n    The order of the sequence corresponds to priority order for the\n    interpreter, from most to least important.\n    \"\"\"\n\n    interp_name = interpreter_name()\n    if interp_name == \"cp\":\n        yield from cpython_tags(warn=warn)\n    else:\n        yield from generic_tags()\n\n    if interp_name == \"pp\":\n        interp = \"pp3\"\n    elif interp_name == \"cp\":\n        interp = \"cp\" + interpreter_version(warn=warn)\n    else:\n        interp = None\n    yield from compatible_tags(interpreter=interp)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/packaging/utils.py","size":5050,"sha1":"a5dd9d67bec31aae3ad6701553031b0f19292cc8","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport functools\nimport re\nfrom typing import NewType, Tuple, Union, cast\n\nfrom .tags import Tag, parse_tag\nfrom .version import InvalidVersion, Version, _TrimmedRelease\n\nBuildTag = Union[Tuple[()], Tuple[int, str]]\nNormalizedName = NewType(\"NormalizedName\", str)\n\n\nclass InvalidName(ValueError):\n    \"\"\"\n    An invalid distribution name; users should refer to the packaging user guide.\n    \"\"\"\n\n\nclass InvalidWheelFilename(ValueError):\n    \"\"\"\n    An invalid wheel filename was found, users should refer to PEP 427.\n    \"\"\"\n\n\nclass InvalidSdistFilename(ValueError):\n    \"\"\"\n    An invalid sdist filename was found, users should refer to the packaging user guide.\n    \"\"\"\n\n\n# Core metadata spec for `Name`\n_validate_regex = re.compile(\n    r\"^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$\", re.IGNORECASE\n)\n_canonicalize_regex = re.compile(r\"[-_.]+\")\n_normalized_regex = re.compile(r\"^([a-z0-9]|[a-z0-9]([a-z0-9-](?!--))*[a-z0-9])$\")\n# PEP 427: The build number must start with a digit.\n_build_tag_regex = re.compile(r\"(\\d+)(.*)\")\n\n\ndef canonicalize_name(name: str, *, validate: bool = False) -> NormalizedName:\n    if validate and not _validate_regex.match(name):\n        raise InvalidName(f\"name is invalid: {name!r}\")\n    # This is taken from PEP 503.\n    value = _canonicalize_regex.sub(\"-\", name).lower()\n    return cast(NormalizedName, value)\n\n\ndef is_normalized_name(name: str) -> bool:\n    return _normalized_regex.match(name) is not None\n\n\n@functools.singledispatch\ndef canonicalize_version(\n    version: Version | str, *, strip_trailing_zero: bool = True\n) -> str:\n    \"\"\"\n    Return a canonical form of a version as a string.\n\n    >>> canonicalize_version('1.0.1')\n    '1.0.1'\n\n    Per PEP 625, versions may have multiple canonical forms, differing\n    only by trailing zeros.\n\n    >>> canonicalize_version('1.0.0')\n    '1'\n    >>> canonicalize_version('1.0.0', strip_trailing_zero=False)\n    '1.0.0'\n\n    Invalid versions are returned unaltered.\n\n    >>> canonicalize_version('foo bar baz')\n    'foo bar baz'\n    \"\"\"\n    return str(_TrimmedRelease(str(version)) if strip_trailing_zero else version)\n\n\n@canonicalize_version.register\ndef _(version: str, *, strip_trailing_zero: bool = True) -> str:\n    try:\n        parsed = Version(version)\n    except InvalidVersion:\n        # Legacy versions cannot be normalized\n        return version\n    return canonicalize_version(parsed, strip_trailing_zero=strip_trailing_zero)\n\n\ndef parse_wheel_filename(\n    filename: str,\n) -> tuple[NormalizedName, Version, BuildTag, frozenset[Tag]]:\n    if not filename.endswith(\".whl\"):\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (extension must be '.whl'): {filename!r}\"\n        )\n\n    filename = filename[:-4]\n    dashes = filename.count(\"-\")\n    if dashes not in (4, 5):\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (wrong number of parts): {filename!r}\"\n        )\n\n    parts = filename.split(\"-\", dashes - 2)\n    name_part = parts[0]\n    # See PEP 427 for the rules on escaping the project name.\n    if \"__\" in name_part or re.match(r\"^[\\w\\d._]*$\", name_part, re.UNICODE) is None:\n        raise InvalidWheelFilename(f\"Invalid project name: {filename!r}\")\n    name = canonicalize_name(name_part)\n\n    try:\n        version = Version(parts[1])\n    except InvalidVersion as e:\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (invalid version): {filename!r}\"\n        ) from e\n\n    if dashes == 5:\n        build_part = parts[2]\n        build_match = _build_tag_regex.match(build_part)\n        if build_match is None:\n            raise InvalidWheelFilename(\n                f\"Invalid build number: {build_part} in {filename!r}\"\n            )\n        build = cast(BuildTag, (int(build_match.group(1)), build_match.group(2)))\n    else:\n        build = ()\n    tags = parse_tag(parts[-1])\n    return (name, version, build, tags)\n\n\ndef parse_sdist_filename(filename: str) -> tuple[NormalizedName, Version]:\n    if filename.endswith(\".tar.gz\"):\n        file_stem = filename[: -len(\".tar.gz\")]\n    elif filename.endswith(\".zip\"):\n        file_stem = filename[: -len(\".zip\")]\n    else:\n        raise InvalidSdistFilename(\n            f\"Invalid sdist filename (extension must be '.tar.gz' or '.zip'):\"\n            f\" {filename!r}\"\n        )\n\n    # We are requiring a PEP 440 version, which cannot contain dashes,\n    # so we split on the last dash.\n    name_part, sep, version_part = file_stem.rpartition(\"-\")\n    if not sep:\n        raise InvalidSdistFilename(f\"Invalid sdist filename: {filename!r}\")\n\n    name = canonicalize_name(name_part)\n\n    try:\n        version = Version(version_part)\n    except InvalidVersion as e:\n        raise InvalidSdistFilename(\n            f\"Invalid sdist filename (invalid version): {filename!r}\"\n        ) from e\n\n    return (name, version)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/packaging/version.py","size":16688,"sha1":"1468fbad399c468e6c78b67367b36cd48f49810b","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\"\"\"\n.. testsetup::\n\n    from pip._vendor.packaging.version import parse, Version\n\"\"\"\n\nfrom __future__ import annotations\n\nimport itertools\nimport re\nfrom typing import Any, Callable, NamedTuple, SupportsInt, Tuple, Union\n\nfrom ._structures import Infinity, InfinityType, NegativeInfinity, NegativeInfinityType\n\n__all__ = [\"VERSION_PATTERN\", \"InvalidVersion\", \"Version\", \"parse\"]\n\nLocalType = Tuple[Union[int, str], ...]\n\nCmpPrePostDevType = Union[InfinityType, NegativeInfinityType, Tuple[str, int]]\nCmpLocalType = Union[\n    NegativeInfinityType,\n    Tuple[Union[Tuple[int, str], Tuple[NegativeInfinityType, Union[int, str]]], ...],\n]\nCmpKey = Tuple[\n    int,\n    Tuple[int, ...],\n    CmpPrePostDevType,\n    CmpPrePostDevType,\n    CmpPrePostDevType,\n    CmpLocalType,\n]\nVersionComparisonMethod = Callable[[CmpKey, CmpKey], bool]\n\n\nclass _Version(NamedTuple):\n    epoch: int\n    release: tuple[int, ...]\n    dev: tuple[str, int] | None\n    pre: tuple[str, int] | None\n    post: tuple[str, int] | None\n    local: LocalType | None\n\n\ndef parse(version: str) -> Version:\n    \"\"\"Parse the given version string.\n\n    >>> parse('1.0.dev1')\n    <Version('1.0.dev1')>\n\n    :param version: The version string to parse.\n    :raises InvalidVersion: When the version string is not a valid version.\n    \"\"\"\n    return Version(version)\n\n\nclass InvalidVersion(ValueError):\n    \"\"\"Raised when a version string is not a valid version.\n\n    >>> Version(\"invalid\")\n    Traceback (most recent call last):\n        ...\n    packaging.version.InvalidVersion: Invalid version: 'invalid'\n    \"\"\"\n\n\nclass _BaseVersion:\n    _key: tuple[Any, ...]\n\n    def __hash__(self) -> int:\n        return hash(self._key)\n\n    # Please keep the duplicated `isinstance` check\n    # in the six comparisons hereunder\n    # unless you find a way to avoid adding overhead function calls.\n    def __lt__(self, other: _BaseVersion) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key < other._key\n\n    def __le__(self, other: _BaseVersion) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key <= other._key\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key == other._key\n\n    def __ge__(self, other: _BaseVersion) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key >= other._key\n\n    def __gt__(self, other: _BaseVersion) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key > other._key\n\n    def __ne__(self, other: object) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key != other._key\n\n\n# Deliberately not anchored to the start and end of the string, to make it\n# easier for 3rd party code to reuse\n_VERSION_PATTERN = r\"\"\"\n    v?\n    (?:\n        (?:(?P<epoch>[0-9]+)!)?                           # epoch\n        (?P<release>[0-9]+(?:\\.[0-9]+)*)                  # release segment\n        (?P<pre>                                          # pre-release\n            [-_\\.]?\n            (?P<pre_l>alpha|a|beta|b|preview|pre|c|rc)\n            [-_\\.]?\n            (?P<pre_n>[0-9]+)?\n        )?\n        (?P<post>                                         # post release\n            (?:-(?P<post_n1>[0-9]+))\n            |\n            (?:\n                [-_\\.]?\n                (?P<post_l>post|rev|r)\n                [-_\\.]?\n                (?P<post_n2>[0-9]+)?\n            )\n        )?\n        (?P<dev>                                          # dev release\n            [-_\\.]?\n            (?P<dev_l>dev)\n            [-_\\.]?\n            (?P<dev_n>[0-9]+)?\n        )?\n    )\n    (?:\\+(?P<local>[a-z0-9]+(?:[-_\\.][a-z0-9]+)*))?       # local version\n\"\"\"\n\nVERSION_PATTERN = _VERSION_PATTERN\n\"\"\"\nA string containing the regular expression used to match a valid version.\n\nThe pattern is not anchored at either end, and is intended for embedding in larger\nexpressions (for example, matching a version number as part of a file name). The\nregular expression should be compiled with the ``re.VERBOSE`` and ``re.IGNORECASE``\nflags set.\n\n:meta hide-value:\n\"\"\"\n\n\nclass Version(_BaseVersion):\n    \"\"\"This class abstracts handling of a project's versions.\n\n    A :class:`Version` instance is comparison aware and can be compared and\n    sorted using the standard Python interfaces.\n\n    >>> v1 = Version(\"1.0a5\")\n    >>> v2 = Version(\"1.0\")\n    >>> v1\n    <Version('1.0a5')>\n    >>> v2\n    <Version('1.0')>\n    >>> v1 < v2\n    True\n    >>> v1 == v2\n    False\n    >>> v1 > v2\n    False\n    >>> v1 >= v2\n    False\n    >>> v1 <= v2\n    True\n    \"\"\"\n\n    _regex = re.compile(r\"^\\s*\" + VERSION_PATTERN + r\"\\s*$\", re.VERBOSE | re.IGNORECASE)\n    _key: CmpKey\n\n    def __init__(self, version: str) -> None:\n        \"\"\"Initialize a Version object.\n\n        :param version:\n            The string representation of a version which will be parsed and normalized\n            before use.\n        :raises InvalidVersion:\n            If the ``version`` does not conform to PEP 440 in any way then this\n            exception will be raised.\n        \"\"\"\n\n        # Validate the version and parse it into pieces\n        match = self._regex.search(version)\n        if not match:\n            raise InvalidVersion(f\"Invalid version: {version!r}\")\n\n        # Store the parsed out pieces of the version\n        self._version = _Version(\n            epoch=int(match.group(\"epoch\")) if match.group(\"epoch\") else 0,\n            release=tuple(int(i) for i in match.group(\"release\").split(\".\")),\n            pre=_parse_letter_version(match.group(\"pre_l\"), match.group(\"pre_n\")),\n            post=_parse_letter_version(\n                match.group(\"post_l\"), match.group(\"post_n1\") or match.group(\"post_n2\")\n            ),\n            dev=_parse_letter_version(match.group(\"dev_l\"), match.group(\"dev_n\")),\n            local=_parse_local_version(match.group(\"local\")),\n        )\n\n        # Generate a key which will be used for sorting\n        self._key = _cmpkey(\n            self._version.epoch,\n            self._version.release,\n            self._version.pre,\n            self._version.post,\n            self._version.dev,\n            self._version.local,\n        )\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the Version that shows all internal state.\n\n        >>> Version('1.0.0')\n        <Version('1.0.0')>\n        \"\"\"\n        return f\"<Version('{self}')>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the version that can be round-tripped.\n\n        >>> str(Version(\"1.0a5\"))\n        '1.0a5'\n        \"\"\"\n        parts = []\n\n        # Epoch\n        if self.epoch != 0:\n            parts.append(f\"{self.epoch}!\")\n\n        # Release segment\n        parts.append(\".\".join(str(x) for x in self.release))\n\n        # Pre-release\n        if self.pre is not None:\n            parts.append(\"\".join(str(x) for x in self.pre))\n\n        # Post-release\n        if self.post is not None:\n            parts.append(f\".post{self.post}\")\n\n        # Development release\n        if self.dev is not None:\n            parts.append(f\".dev{self.dev}\")\n\n        # Local version segment\n        if self.local is not None:\n            parts.append(f\"+{self.local}\")\n\n        return \"\".join(parts)\n\n    @property\n    def epoch(self) -> int:\n        \"\"\"The epoch of the version.\n\n        >>> Version(\"2.0.0\").epoch\n        0\n        >>> Version(\"1!2.0.0\").epoch\n        1\n        \"\"\"\n        return self._version.epoch\n\n    @property\n    def release(self) -> tuple[int, ...]:\n        \"\"\"The components of the \"release\" segment of the version.\n\n        >>> Version(\"1.2.3\").release\n        (1, 2, 3)\n        >>> Version(\"2.0.0\").release\n        (2, 0, 0)\n        >>> Version(\"1!2.0.0.post0\").release\n        (2, 0, 0)\n\n        Includes trailing zeroes but not the epoch or any pre-release / development /\n        post-release suffixes.\n        \"\"\"\n        return self._version.release\n\n    @property\n    def pre(self) -> tuple[str, int] | None:\n        \"\"\"The pre-release segment of the version.\n\n        >>> print(Version(\"1.2.3\").pre)\n        None\n        >>> Version(\"1.2.3a1\").pre\n        ('a', 1)\n        >>> Version(\"1.2.3b1\").pre\n        ('b', 1)\n        >>> Version(\"1.2.3rc1\").pre\n        ('rc', 1)\n        \"\"\"\n        return self._version.pre\n\n    @property\n    def post(self) -> int | None:\n        \"\"\"The post-release number of the version.\n\n        >>> print(Version(\"1.2.3\").post)\n        None\n        >>> Version(\"1.2.3.post1\").post\n        1\n        \"\"\"\n        return self._version.post[1] if self._version.post else None\n\n    @property\n    def dev(self) -> int | None:\n        \"\"\"The development number of the version.\n\n        >>> print(Version(\"1.2.3\").dev)\n        None\n        >>> Version(\"1.2.3.dev1\").dev\n        1\n        \"\"\"\n        return self._version.dev[1] if self._version.dev else None\n\n    @property\n    def local(self) -> str | None:\n        \"\"\"The local version segment of the version.\n\n        >>> print(Version(\"1.2.3\").local)\n        None\n        >>> Version(\"1.2.3+abc\").local\n        'abc'\n        \"\"\"\n        if self._version.local:\n            return \".\".join(str(x) for x in self._version.local)\n        else:\n            return None\n\n    @property\n    def public(self) -> str:\n        \"\"\"The public portion of the version.\n\n        >>> Version(\"1.2.3\").public\n        '1.2.3'\n        >>> Version(\"1.2.3+abc\").public\n        '1.2.3'\n        >>> Version(\"1!1.2.3dev1+abc\").public\n        '1!1.2.3.dev1'\n        \"\"\"\n        return str(self).split(\"+\", 1)[0]\n\n    @property\n    def base_version(self) -> str:\n        \"\"\"The \"base version\" of the version.\n\n        >>> Version(\"1.2.3\").base_version\n        '1.2.3'\n        >>> Version(\"1.2.3+abc\").base_version\n        '1.2.3'\n        >>> Version(\"1!1.2.3dev1+abc\").base_version\n        '1!1.2.3'\n\n        The \"base version\" is the public version of the project without any pre or post\n        release markers.\n        \"\"\"\n        parts = []\n\n        # Epoch\n        if self.epoch != 0:\n            parts.append(f\"{self.epoch}!\")\n\n        # Release segment\n        parts.append(\".\".join(str(x) for x in self.release))\n\n        return \"\".join(parts)\n\n    @property\n    def is_prerelease(self) -> bool:\n        \"\"\"Whether this version is a pre-release.\n\n        >>> Version(\"1.2.3\").is_prerelease\n        False\n        >>> Version(\"1.2.3a1\").is_prerelease\n        True\n        >>> Version(\"1.2.3b1\").is_prerelease\n        True\n        >>> Version(\"1.2.3rc1\").is_prerelease\n        True\n        >>> Version(\"1.2.3dev1\").is_prerelease\n        True\n        \"\"\"\n        return self.dev is not None or self.pre is not None\n\n    @property\n    def is_postrelease(self) -> bool:\n        \"\"\"Whether this version is a post-release.\n\n        >>> Version(\"1.2.3\").is_postrelease\n        False\n        >>> Version(\"1.2.3.post1\").is_postrelease\n        True\n        \"\"\"\n        return self.post is not None\n\n    @property\n    def is_devrelease(self) -> bool:\n        \"\"\"Whether this version is a development release.\n\n        >>> Version(\"1.2.3\").is_devrelease\n        False\n        >>> Version(\"1.2.3.dev1\").is_devrelease\n        True\n        \"\"\"\n        return self.dev is not None\n\n    @property\n    def major(self) -> int:\n        \"\"\"The first item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").major\n        1\n        \"\"\"\n        return self.release[0] if len(self.release) >= 1 else 0\n\n    @property\n    def minor(self) -> int:\n        \"\"\"The second item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").minor\n        2\n        >>> Version(\"1\").minor\n        0\n        \"\"\"\n        return self.release[1] if len(self.release) >= 2 else 0\n\n    @property\n    def micro(self) -> int:\n        \"\"\"The third item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").micro\n        3\n        >>> Version(\"1\").micro\n        0\n        \"\"\"\n        return self.release[2] if len(self.release) >= 3 else 0\n\n\nclass _TrimmedRelease(Version):\n    @property\n    def release(self) -> tuple[int, ...]:\n        \"\"\"\n        Release segment without any trailing zeros.\n\n        >>> _TrimmedRelease('1.0.0').release\n        (1,)\n        >>> _TrimmedRelease('0.0').release\n        (0,)\n        \"\"\"\n        rel = super().release\n        nonzeros = (index for index, val in enumerate(rel) if val)\n        last_nonzero = max(nonzeros, default=0)\n        return rel[: last_nonzero + 1]\n\n\ndef _parse_letter_version(\n    letter: str | None, number: str | bytes | SupportsInt | None\n) -> tuple[str, int] | None:\n    if letter:\n        # We consider there to be an implicit 0 in a pre-release if there is\n        # not a numeral associated with it.\n        if number is None:\n            number = 0\n\n        # We normalize any letters to their lower case form\n        letter = letter.lower()\n\n        # We consider some words to be alternate spellings of other words and\n        # in those cases we want to normalize the spellings to our preferred\n        # spelling.\n        if letter == \"alpha\":\n            letter = \"a\"\n        elif letter == \"beta\":\n            letter = \"b\"\n        elif letter in [\"c\", \"pre\", \"preview\"]:\n            letter = \"rc\"\n        elif letter in [\"rev\", \"r\"]:\n            letter = \"post\"\n\n        return letter, int(number)\n\n    assert not letter\n    if number:\n        # We assume if we are given a number, but we are not given a letter\n        # then this is using the implicit post release syntax (e.g. 1.0-1)\n        letter = \"post\"\n\n        return letter, int(number)\n\n    return None\n\n\n_local_version_separators = re.compile(r\"[\\._-]\")\n\n\ndef _parse_local_version(local: str | None) -> LocalType | None:\n    \"\"\"\n    Takes a string like abc.1.twelve and turns it into (\"abc\", 1, \"twelve\").\n    \"\"\"\n    if local is not None:\n        return tuple(\n            part.lower() if not part.isdigit() else int(part)\n            for part in _local_version_separators.split(local)\n        )\n    return None\n\n\ndef _cmpkey(\n    epoch: int,\n    release: tuple[int, ...],\n    pre: tuple[str, int] | None,\n    post: tuple[str, int] | None,\n    dev: tuple[str, int] | None,\n    local: LocalType | None,\n) -> CmpKey:\n    # When we compare a release version, we want to compare it with all of the\n    # trailing zeros removed. So we'll use a reverse the list, drop all the now\n    # leading zeros until we come to something non zero, then take the rest\n    # re-reverse it back into the correct order and make it a tuple and use\n    # that for our sorting key.\n    _release = tuple(\n        reversed(list(itertools.dropwhile(lambda x: x == 0, reversed(release))))\n    )\n\n    # We need to \"trick\" the sorting algorithm to put 1.0.dev0 before 1.0a0.\n    # We'll do this by abusing the pre segment, but we _only_ want to do this\n    # if there is not a pre or a post segment. If we have one of those then\n    # the normal sorting rules will handle this case correctly.\n    if pre is None and post is None and dev is not None:\n        _pre: CmpPrePostDevType = NegativeInfinity\n    # Versions without a pre-release (except as noted above) should sort after\n    # those with one.\n    elif pre is None:\n        _pre = Infinity\n    else:\n        _pre = pre\n\n    # Versions without a post segment should sort before those with one.\n    if post is None:\n        _post: CmpPrePostDevType = NegativeInfinity\n\n    else:\n        _post = post\n\n    # Versions without a development segment should sort after those with one.\n    if dev is None:\n        _dev: CmpPrePostDevType = Infinity\n\n    else:\n        _dev = dev\n\n    if local is None:\n        # Versions without a local segment should sort before those with one.\n        _local: CmpLocalType = NegativeInfinity\n    else:\n        # Versions with a local segment need that segment parsed to implement\n        # the sorting rules in PEP440.\n        # - Alpha numeric segments sort before numeric segments\n        # - Alpha numeric segments sort lexicographically\n        # - Numeric segments sort numerically\n        # - Shorter versions sort before longer versions when the prefixes\n        #   match exactly\n        _local = tuple(\n            (i, \"\") if isinstance(i, int) else (NegativeInfinity, i) for i in local\n        )\n\n    return epoch, _release, _pre, _post, _dev, _local\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/pkg_resources/__init__.py","size":124463,"sha1":"4f42afb0433851b15d6c2d6c1744ea21433b78e2","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# TODO: Add Generic type annotations to initialized collections.\n# For now we'd simply use implicit Any/Unknown which would add redundant annotations\n# mypy: disable-error-code=\"var-annotated\"\n\"\"\"\nPackage resource API\n--------------------\n\nA resource is a logical file contained within a package, or a logical\nsubdirectory thereof.  The package resource API expects resource names\nto have their path parts separated with ``/``, *not* whatever the local\npath separator is.  Do not use os.path operations to manipulate resource\nnames being passed into the API.\n\nThe package resource API is designed to work with normal filesystem packages,\n.egg files, and unpacked .egg files.  It can also work in a limited way with\n.zip files and with custom PEP 302 loaders that support the ``get_data()``\nmethod.\n\nThis module is deprecated. Users are directed to :mod:`importlib.resources`,\n:mod:`importlib.metadata` and :pypi:`packaging` instead.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\n\nif sys.version_info < (3, 8):  # noqa: UP036 # Check for unsupported versions\n    raise RuntimeError(\"Python 3.8 or later is required\")\n\nimport os\nimport io\nimport time\nimport re\nimport types\nfrom typing import (\n    Any,\n    Literal,\n    Dict,\n    Iterator,\n    Mapping,\n    MutableSequence,\n    NamedTuple,\n    NoReturn,\n    Tuple,\n    Union,\n    TYPE_CHECKING,\n    Protocol,\n    Callable,\n    Iterable,\n    TypeVar,\n    overload,\n)\nimport zipfile\nimport zipimport\nimport warnings\nimport stat\nimport functools\nimport pkgutil\nimport operator\nimport platform\nimport collections\nimport plistlib\nimport email.parser\nimport errno\nimport tempfile\nimport textwrap\nimport inspect\nimport ntpath\nimport posixpath\nimport importlib\nimport importlib.abc\nimport importlib.machinery\nfrom pkgutil import get_importer\n\nimport _imp\n\n# capture these to bypass sandboxing\nfrom os import utime\nfrom os import open as os_open\nfrom os.path import isdir, split\n\ntry:\n    from os import mkdir, rename, unlink\n\n    WRITE_SUPPORT = True\nexcept ImportError:\n    # no write support, probably under GAE\n    WRITE_SUPPORT = False\n\nfrom pip._internal.utils._jaraco_text import (\n    yield_lines,\n    drop_comment,\n    join_continuation,\n)\nfrom pip._vendor.packaging import markers as _packaging_markers\nfrom pip._vendor.packaging import requirements as _packaging_requirements\nfrom pip._vendor.packaging import utils as _packaging_utils\nfrom pip._vendor.packaging import version as _packaging_version\nfrom pip._vendor.platformdirs import user_cache_dir as _user_cache_dir\n\nif TYPE_CHECKING:\n    from _typeshed import BytesPath, StrPath, StrOrBytesPath\n    from pip._vendor.typing_extensions import Self\n\n\n# Patch: Remove deprecation warning from vendored pkg_resources.\n# Setting PYTHONWARNINGS=error to verify builds produce no warnings\n# causes immediate exceptions.\n# See https://github.com/pypa/pip/issues/12243\n\n\n_T = TypeVar(\"_T\")\n_DistributionT = TypeVar(\"_DistributionT\", bound=\"Distribution\")\n# Type aliases\n_NestedStr = Union[str, Iterable[Union[str, Iterable[\"_NestedStr\"]]]]\n_InstallerTypeT = Callable[[\"Requirement\"], \"_DistributionT\"]\n_InstallerType = Callable[[\"Requirement\"], Union[\"Distribution\", None]]\n_PkgReqType = Union[str, \"Requirement\"]\n_EPDistType = Union[\"Distribution\", _PkgReqType]\n_MetadataType = Union[\"IResourceProvider\", None]\n_ResolvedEntryPoint = Any  # Can be any attribute in the module\n_ResourceStream = Any  # TODO / Incomplete: A readable file-like object\n# Any object works, but let's indicate we expect something like a module (optionally has __loader__ or __file__)\n_ModuleLike = Union[object, types.ModuleType]\n# Any: Should be _ModuleLike but we end up with issues where _ModuleLike doesn't have _ZipLoaderModule's __loader__\n_ProviderFactoryType = Callable[[Any], \"IResourceProvider\"]\n_DistFinderType = Callable[[_T, str, bool], Iterable[\"Distribution\"]]\n_NSHandlerType = Callable[[_T, str, str, types.ModuleType], Union[str, None]]\n_AdapterT = TypeVar(\n    \"_AdapterT\", _DistFinderType[Any], _ProviderFactoryType, _NSHandlerType[Any]\n)\n\n\n# Use _typeshed.importlib.LoaderProtocol once available https://github.com/python/typeshed/pull/11890\nclass _LoaderProtocol(Protocol):\n    def load_module(self, fullname: str, /) -> types.ModuleType: ...\n\n\nclass _ZipLoaderModule(Protocol):\n    __loader__: zipimport.zipimporter\n\n\n_PEP440_FALLBACK = re.compile(r\"^v?(?P<safe>(?:[0-9]+!)?[0-9]+(?:\\.[0-9]+)*)\", re.I)\n\n\nclass PEP440Warning(RuntimeWarning):\n    \"\"\"\n    Used when there is an issue with a version or specifier not complying with\n    PEP 440.\n    \"\"\"\n\n\nparse_version = _packaging_version.Version\n\n\n_state_vars: dict[str, str] = {}\n\n\ndef _declare_state(vartype: str, varname: str, initial_value: _T) -> _T:\n    _state_vars[varname] = vartype\n    return initial_value\n\n\ndef __getstate__() -> dict[str, Any]:\n    state = {}\n    g = globals()\n    for k, v in _state_vars.items():\n        state[k] = g['_sget_' + v](g[k])\n    return state\n\n\ndef __setstate__(state: dict[str, Any]) -> dict[str, Any]:\n    g = globals()\n    for k, v in state.items():\n        g['_sset_' + _state_vars[k]](k, g[k], v)\n    return state\n\n\ndef _sget_dict(val):\n    return val.copy()\n\n\ndef _sset_dict(key, ob, state):\n    ob.clear()\n    ob.update(state)\n\n\ndef _sget_object(val):\n    return val.__getstate__()\n\n\ndef _sset_object(key, ob, state):\n    ob.__setstate__(state)\n\n\n_sget_none = _sset_none = lambda *args: None\n\n\ndef get_supported_platform():\n    \"\"\"Return this platform's maximum compatible version.\n\n    distutils.util.get_platform() normally reports the minimum version\n    of macOS that would be required to *use* extensions produced by\n    distutils.  But what we want when checking compatibility is to know the\n    version of macOS that we are *running*.  To allow usage of packages that\n    explicitly require a newer version of macOS, we must also know the\n    current version of the OS.\n\n    If this condition occurs for any other platform with a version in its\n    platform strings, this function should be extended accordingly.\n    \"\"\"\n    plat = get_build_platform()\n    m = macosVersionString.match(plat)\n    if m is not None and sys.platform == \"darwin\":\n        try:\n            plat = 'macosx-%s-%s' % ('.'.join(_macos_vers()[:2]), m.group(3))\n        except ValueError:\n            # not macOS\n            pass\n    return plat\n\n\n__all__ = [\n    # Basic resource access and distribution/entry point discovery\n    'require',\n    'run_script',\n    'get_provider',\n    'get_distribution',\n    'load_entry_point',\n    'get_entry_map',\n    'get_entry_info',\n    'iter_entry_points',\n    'resource_string',\n    'resource_stream',\n    'resource_filename',\n    'resource_listdir',\n    'resource_exists',\n    'resource_isdir',\n    # Environmental control\n    'declare_namespace',\n    'working_set',\n    'add_activation_listener',\n    'find_distributions',\n    'set_extraction_path',\n    'cleanup_resources',\n    'get_default_cache',\n    # Primary implementation classes\n    'Environment',\n    'WorkingSet',\n    'ResourceManager',\n    'Distribution',\n    'Requirement',\n    'EntryPoint',\n    # Exceptions\n    'ResolutionError',\n    'VersionConflict',\n    'DistributionNotFound',\n    'UnknownExtra',\n    'ExtractionError',\n    # Warnings\n    'PEP440Warning',\n    # Parsing functions and string utilities\n    'parse_requirements',\n    'parse_version',\n    'safe_name',\n    'safe_version',\n    'get_platform',\n    'compatible_platforms',\n    'yield_lines',\n    'split_sections',\n    'safe_extra',\n    'to_filename',\n    'invalid_marker',\n    'evaluate_marker',\n    # filesystem utilities\n    'ensure_directory',\n    'normalize_path',\n    # Distribution \"precedence\" constants\n    'EGG_DIST',\n    'BINARY_DIST',\n    'SOURCE_DIST',\n    'CHECKOUT_DIST',\n    'DEVELOP_DIST',\n    # \"Provider\" interfaces, implementations, and registration/lookup APIs\n    'IMetadataProvider',\n    'IResourceProvider',\n    'FileMetadata',\n    'PathMetadata',\n    'EggMetadata',\n    'EmptyProvider',\n    'empty_provider',\n    'NullProvider',\n    'EggProvider',\n    'DefaultProvider',\n    'ZipProvider',\n    'register_finder',\n    'register_namespace_handler',\n    'register_loader_type',\n    'fixup_namespace_packages',\n    'get_importer',\n    # Warnings\n    'PkgResourcesDeprecationWarning',\n    # Deprecated/backward compatibility only\n    'run_main',\n    'AvailableDistributions',\n]\n\n\nclass ResolutionError(Exception):\n    \"\"\"Abstract base for dependency resolution errors\"\"\"\n\n    def __repr__(self):\n        return self.__class__.__name__ + repr(self.args)\n\n\nclass VersionConflict(ResolutionError):\n    \"\"\"\n    An already-installed version conflicts with the requested version.\n\n    Should be initialized with the installed Distribution and the requested\n    Requirement.\n    \"\"\"\n\n    _template = \"{self.dist} is installed but {self.req} is required\"\n\n    @property\n    def dist(self) -> Distribution:\n        return self.args[0]\n\n    @property\n    def req(self) -> Requirement:\n        return self.args[1]\n\n    def report(self):\n        return self._template.format(**locals())\n\n    def with_context(self, required_by: set[Distribution | str]):\n        \"\"\"\n        If required_by is non-empty, return a version of self that is a\n        ContextualVersionConflict.\n        \"\"\"\n        if not required_by:\n            return self\n        args = self.args + (required_by,)\n        return ContextualVersionConflict(*args)\n\n\nclass ContextualVersionConflict(VersionConflict):\n    \"\"\"\n    A VersionConflict that accepts a third parameter, the set of the\n    requirements that required the installed Distribution.\n    \"\"\"\n\n    _template = VersionConflict._template + ' by {self.required_by}'\n\n    @property\n    def required_by(self) -> set[str]:\n        return self.args[2]\n\n\nclass DistributionNotFound(ResolutionError):\n    \"\"\"A requested distribution was not found\"\"\"\n\n    _template = (\n        \"The '{self.req}' distribution was not found \"\n        \"and is required by {self.requirers_str}\"\n    )\n\n    @property\n    def req(self) -> Requirement:\n        return self.args[0]\n\n    @property\n    def requirers(self) -> set[str] | None:\n        return self.args[1]\n\n    @property\n    def requirers_str(self):\n        if not self.requirers:\n            return 'the application'\n        return ', '.join(self.requirers)\n\n    def report(self):\n        return self._template.format(**locals())\n\n    def __str__(self):\n        return self.report()\n\n\nclass UnknownExtra(ResolutionError):\n    \"\"\"Distribution doesn't have an \"extra feature\" of the given name\"\"\"\n\n\n_provider_factories: dict[type[_ModuleLike], _ProviderFactoryType] = {}\n\nPY_MAJOR = '{}.{}'.format(*sys.version_info)\nEGG_DIST = 3\nBINARY_DIST = 2\nSOURCE_DIST = 1\nCHECKOUT_DIST = 0\nDEVELOP_DIST = -1\n\n\ndef register_loader_type(\n    loader_type: type[_ModuleLike], provider_factory: _ProviderFactoryType\n):\n    \"\"\"Register `provider_factory` to make providers for `loader_type`\n\n    `loader_type` is the type or class of a PEP 302 ``module.__loader__``,\n    and `provider_factory` is a function that, passed a *module* object,\n    returns an ``IResourceProvider`` for that module.\n    \"\"\"\n    _provider_factories[loader_type] = provider_factory\n\n\n@overload\ndef get_provider(moduleOrReq: str) -> IResourceProvider: ...\n@overload\ndef get_provider(moduleOrReq: Requirement) -> Distribution: ...\ndef get_provider(moduleOrReq: str | Requirement) -> IResourceProvider | Distribution:\n    \"\"\"Return an IResourceProvider for the named module or requirement\"\"\"\n    if isinstance(moduleOrReq, Requirement):\n        return working_set.find(moduleOrReq) or require(str(moduleOrReq))[0]\n    try:\n        module = sys.modules[moduleOrReq]\n    except KeyError:\n        __import__(moduleOrReq)\n        module = sys.modules[moduleOrReq]\n    loader = getattr(module, '__loader__', None)\n    return _find_adapter(_provider_factories, loader)(module)\n\n\n@functools.lru_cache(maxsize=None)\ndef _macos_vers():\n    version = platform.mac_ver()[0]\n    # fallback for MacPorts\n    if version == '':\n        plist = '/System/Library/CoreServices/SystemVersion.plist'\n        if os.path.exists(plist):\n            with open(plist, 'rb') as fh:\n                plist_content = plistlib.load(fh)\n            if 'ProductVersion' in plist_content:\n                version = plist_content['ProductVersion']\n    return version.split('.')\n\n\ndef _macos_arch(machine):\n    return {'PowerPC': 'ppc', 'Power_Macintosh': 'ppc'}.get(machine, machine)\n\n\ndef get_build_platform():\n    \"\"\"Return this platform's string for platform-specific distributions\n\n    XXX Currently this is the same as ``distutils.util.get_platform()``, but it\n    needs some hacks for Linux and macOS.\n    \"\"\"\n    from sysconfig import get_platform\n\n    plat = get_platform()\n    if sys.platform == \"darwin\" and not plat.startswith('macosx-'):\n        try:\n            version = _macos_vers()\n            machine = os.uname()[4].replace(\" \", \"_\")\n            return \"macosx-%d.%d-%s\" % (\n                int(version[0]),\n                int(version[1]),\n                _macos_arch(machine),\n            )\n        except ValueError:\n            # if someone is running a non-Mac darwin system, this will fall\n            # through to the default implementation\n            pass\n    return plat\n\n\nmacosVersionString = re.compile(r\"macosx-(\\d+)\\.(\\d+)-(.*)\")\ndarwinVersionString = re.compile(r\"darwin-(\\d+)\\.(\\d+)\\.(\\d+)-(.*)\")\n# XXX backward compat\nget_platform = get_build_platform\n\n\ndef compatible_platforms(provided: str | None, required: str | None):\n    \"\"\"Can code for the `provided` platform run on the `required` platform?\n\n    Returns true if either platform is ``None``, or the platforms are equal.\n\n    XXX Needs compatibility checks for Linux and other unixy OSes.\n    \"\"\"\n    if provided is None or required is None or provided == required:\n        # easy case\n        return True\n\n    # macOS special cases\n    reqMac = macosVersionString.match(required)\n    if reqMac:\n        provMac = macosVersionString.match(provided)\n\n        # is this a Mac package?\n        if not provMac:\n            # this is backwards compatibility for packages built before\n            # setuptools 0.6. All packages built after this point will\n            # use the new macOS designation.\n            provDarwin = darwinVersionString.match(provided)\n            if provDarwin:\n                dversion = int(provDarwin.group(1))\n                macosversion = \"%s.%s\" % (reqMac.group(1), reqMac.group(2))\n                if (\n                    dversion == 7\n                    and macosversion >= \"10.3\"\n                    or dversion == 8\n                    and macosversion >= \"10.4\"\n                ):\n                    return True\n            # egg isn't macOS or legacy darwin\n            return False\n\n        # are they the same major version and machine type?\n        if provMac.group(1) != reqMac.group(1) or provMac.group(3) != reqMac.group(3):\n            return False\n\n        # is the required OS major update >= the provided one?\n        if int(provMac.group(2)) > int(reqMac.group(2)):\n            return False\n\n        return True\n\n    # XXX Linux and other platforms' special cases should go here\n    return False\n\n\n@overload\ndef get_distribution(dist: _DistributionT) -> _DistributionT: ...\n@overload\ndef get_distribution(dist: _PkgReqType) -> Distribution: ...\ndef get_distribution(dist: Distribution | _PkgReqType) -> Distribution:\n    \"\"\"Return a current distribution object for a Requirement or string\"\"\"\n    if isinstance(dist, str):\n        dist = Requirement.parse(dist)\n    if isinstance(dist, Requirement):\n        # Bad type narrowing, dist has to be a Requirement here, so get_provider has to return Distribution\n        dist = get_provider(dist)  # type: ignore[assignment]\n    if not isinstance(dist, Distribution):\n        raise TypeError(\"Expected str, Requirement, or Distribution\", dist)\n    return dist\n\n\ndef load_entry_point(dist: _EPDistType, group: str, name: str) -> _ResolvedEntryPoint:\n    \"\"\"Return `name` entry point of `group` for `dist` or raise ImportError\"\"\"\n    return get_distribution(dist).load_entry_point(group, name)\n\n\n@overload\ndef get_entry_map(\n    dist: _EPDistType, group: None = None\n) -> dict[str, dict[str, EntryPoint]]: ...\n@overload\ndef get_entry_map(dist: _EPDistType, group: str) -> dict[str, EntryPoint]: ...\ndef get_entry_map(dist: _EPDistType, group: str | None = None):\n    \"\"\"Return the entry point map for `group`, or the full entry map\"\"\"\n    return get_distribution(dist).get_entry_map(group)\n\n\ndef get_entry_info(dist: _EPDistType, group: str, name: str):\n    \"\"\"Return the EntryPoint object for `group`+`name`, or ``None``\"\"\"\n    return get_distribution(dist).get_entry_info(group, name)\n\n\nclass IMetadataProvider(Protocol):\n    def has_metadata(self, name: str) -> bool:\n        \"\"\"Does the package's distribution contain the named metadata?\"\"\"\n\n    def get_metadata(self, name: str) -> str:\n        \"\"\"The named metadata resource as a string\"\"\"\n\n    def get_metadata_lines(self, name: str) -> Iterator[str]:\n        \"\"\"Yield named metadata resource as list of non-blank non-comment lines\n\n        Leading and trailing whitespace is stripped from each line, and lines\n        with ``#`` as the first non-blank character are omitted.\"\"\"\n\n    def metadata_isdir(self, name: str) -> bool:\n        \"\"\"Is the named metadata a directory?  (like ``os.path.isdir()``)\"\"\"\n\n    def metadata_listdir(self, name: str) -> list[str]:\n        \"\"\"List of metadata names in the directory (like ``os.listdir()``)\"\"\"\n\n    def run_script(self, script_name: str, namespace: dict[str, Any]) -> None:\n        \"\"\"Execute the named script in the supplied namespace dictionary\"\"\"\n\n\nclass IResourceProvider(IMetadataProvider, Protocol):\n    \"\"\"An object that provides access to package resources\"\"\"\n\n    def get_resource_filename(\n        self, manager: ResourceManager, resource_name: str\n    ) -> str:\n        \"\"\"Return a true filesystem path for `resource_name`\n\n        `manager` must be a ``ResourceManager``\"\"\"\n\n    def get_resource_stream(\n        self, manager: ResourceManager, resource_name: str\n    ) -> _ResourceStream:\n        \"\"\"Return a readable file-like object for `resource_name`\n\n        `manager` must be a ``ResourceManager``\"\"\"\n\n    def get_resource_string(\n        self, manager: ResourceManager, resource_name: str\n    ) -> bytes:\n        \"\"\"Return the contents of `resource_name` as :obj:`bytes`\n\n        `manager` must be a ``ResourceManager``\"\"\"\n\n    def has_resource(self, resource_name: str) -> bool:\n        \"\"\"Does the package contain the named resource?\"\"\"\n\n    def resource_isdir(self, resource_name: str) -> bool:\n        \"\"\"Is the named resource a directory?  (like ``os.path.isdir()``)\"\"\"\n\n    def resource_listdir(self, resource_name: str) -> list[str]:\n        \"\"\"List of resource names in the directory (like ``os.listdir()``)\"\"\"\n\n\nclass WorkingSet:\n    \"\"\"A collection of active distributions on sys.path (or a similar list)\"\"\"\n\n    def __init__(self, entries: Iterable[str] | None = None):\n        \"\"\"Create working set from list of path entries (default=sys.path)\"\"\"\n        self.entries: list[str] = []\n        self.entry_keys = {}\n        self.by_key = {}\n        self.normalized_to_canonical_keys = {}\n        self.callbacks = []\n\n        if entries is None:\n            entries = sys.path\n\n        for entry in entries:\n            self.add_entry(entry)\n\n    @classmethod\n    def _build_master(cls):\n        \"\"\"\n        Prepare the master working set.\n        \"\"\"\n        ws = cls()\n        try:\n            from __main__ import __requires__\n        except ImportError:\n            # The main program does not list any requirements\n            return ws\n\n        # ensure the requirements are met\n        try:\n            ws.require(__requires__)\n        except VersionConflict:\n            return cls._build_from_requirements(__requires__)\n\n        return ws\n\n    @classmethod\n    def _build_from_requirements(cls, req_spec):\n        \"\"\"\n        Build a working set from a requirement spec. Rewrites sys.path.\n        \"\"\"\n        # try it without defaults already on sys.path\n        # by starting with an empty path\n        ws = cls([])\n        reqs = parse_requirements(req_spec)\n        dists = ws.resolve(reqs, Environment())\n        for dist in dists:\n            ws.add(dist)\n\n        # add any missing entries from sys.path\n        for entry in sys.path:\n            if entry not in ws.entries:\n                ws.add_entry(entry)\n\n        # then copy back to sys.path\n        sys.path[:] = ws.entries\n        return ws\n\n    def add_entry(self, entry: str):\n        \"\"\"Add a path item to ``.entries``, finding any distributions on it\n\n        ``find_distributions(entry, True)`` is used to find distributions\n        corresponding to the path entry, and they are added.  `entry` is\n        always appended to ``.entries``, even if it is already present.\n        (This is because ``sys.path`` can contain the same value more than\n        once, and the ``.entries`` of the ``sys.path`` WorkingSet should always\n        equal ``sys.path``.)\n        \"\"\"\n        self.entry_keys.setdefault(entry, [])\n        self.entries.append(entry)\n        for dist in find_distributions(entry, True):\n            self.add(dist, entry, False)\n\n    def __contains__(self, dist: Distribution) -> bool:\n        \"\"\"True if `dist` is the active distribution for its project\"\"\"\n        return self.by_key.get(dist.key) == dist\n\n    def find(self, req: Requirement) -> Distribution | None:\n        \"\"\"Find a distribution matching requirement `req`\n\n        If there is an active distribution for the requested project, this\n        returns it as long as it meets the version requirement specified by\n        `req`.  But, if there is an active distribution for the project and it\n        does *not* meet the `req` requirement, ``VersionConflict`` is raised.\n        If there is no active distribution for the requested project, ``None``\n        is returned.\n        \"\"\"\n        dist = self.by_key.get(req.key)\n\n        if dist is None:\n            canonical_key = self.normalized_to_canonical_keys.get(req.key)\n\n            if canonical_key is not None:\n                req.key = canonical_key\n                dist = self.by_key.get(canonical_key)\n\n        if dist is not None and dist not in req:\n            # XXX add more info\n            raise VersionConflict(dist, req)\n        return dist\n\n    def iter_entry_points(self, group: str, name: str | None = None):\n        \"\"\"Yield entry point objects from `group` matching `name`\n\n        If `name` is None, yields all entry points in `group` from all\n        distributions in the working set, otherwise only ones matching\n        both `group` and `name` are yielded (in distribution order).\n        \"\"\"\n        return (\n            entry\n            for dist in self\n            for entry in dist.get_entry_map(group).values()\n            if name is None or name == entry.name\n        )\n\n    def run_script(self, requires: str, script_name: str):\n        \"\"\"Locate distribution for `requires` and run `script_name` script\"\"\"\n        ns = sys._getframe(1).f_globals\n        name = ns['__name__']\n        ns.clear()\n        ns['__name__'] = name\n        self.require(requires)[0].run_script(script_name, ns)\n\n    def __iter__(self) -> Iterator[Distribution]:\n        \"\"\"Yield distributions for non-duplicate projects in the working set\n\n        The yield order is the order in which the items' path entries were\n        added to the working set.\n        \"\"\"\n        seen = set()\n        for item in self.entries:\n            if item not in self.entry_keys:\n                # workaround a cache issue\n                continue\n\n            for key in self.entry_keys[item]:\n                if key not in seen:\n                    seen.add(key)\n                    yield self.by_key[key]\n\n    def add(\n        self,\n        dist: Distribution,\n        entry: str | None = None,\n        insert: bool = True,\n        replace: bool = False,\n    ):\n        \"\"\"Add `dist` to working set, associated with `entry`\n\n        If `entry` is unspecified, it defaults to the ``.location`` of `dist`.\n        On exit from this routine, `entry` is added to the end of the working\n        set's ``.entries`` (if it wasn't already present).\n\n        `dist` is only added to the working set if it's for a project that\n        doesn't already have a distribution in the set, unless `replace=True`.\n        If it's added, any callbacks registered with the ``subscribe()`` method\n        will be called.\n        \"\"\"\n        if insert:\n            dist.insert_on(self.entries, entry, replace=replace)\n\n        if entry is None:\n            entry = dist.location\n        keys = self.entry_keys.setdefault(entry, [])\n        keys2 = self.entry_keys.setdefault(dist.location, [])\n        if not replace and dist.key in self.by_key:\n            # ignore hidden distros\n            return\n\n        self.by_key[dist.key] = dist\n        normalized_name = _packaging_utils.canonicalize_name(dist.key)\n        self.normalized_to_canonical_keys[normalized_name] = dist.key\n        if dist.key not in keys:\n            keys.append(dist.key)\n        if dist.key not in keys2:\n            keys2.append(dist.key)\n        self._added_new(dist)\n\n    @overload\n    def resolve(\n        self,\n        requirements: Iterable[Requirement],\n        env: Environment | None,\n        installer: _InstallerTypeT[_DistributionT],\n        replace_conflicting: bool = False,\n        extras: tuple[str, ...] | None = None,\n    ) -> list[_DistributionT]: ...\n    @overload\n    def resolve(\n        self,\n        requirements: Iterable[Requirement],\n        env: Environment | None = None,\n        *,\n        installer: _InstallerTypeT[_DistributionT],\n        replace_conflicting: bool = False,\n        extras: tuple[str, ...] | None = None,\n    ) -> list[_DistributionT]: ...\n    @overload\n    def resolve(\n        self,\n        requirements: Iterable[Requirement],\n        env: Environment | None = None,\n        installer: _InstallerType | None = None,\n        replace_conflicting: bool = False,\n        extras: tuple[str, ...] | None = None,\n    ) -> list[Distribution]: ...\n    def resolve(\n        self,\n        requirements: Iterable[Requirement],\n        env: Environment | None = None,\n        installer: _InstallerType | None | _InstallerTypeT[_DistributionT] = None,\n        replace_conflicting: bool = False,\n        extras: tuple[str, ...] | None = None,\n    ) -> list[Distribution] | list[_DistributionT]:\n        \"\"\"List all distributions needed to (recursively) meet `requirements`\n\n        `requirements` must be a sequence of ``Requirement`` objects.  `env`,\n        if supplied, should be an ``Environment`` instance.  If\n        not supplied, it defaults to all distributions available within any\n        entry or distribution in the working set.  `installer`, if supplied,\n        will be invoked with each requirement that cannot be met by an\n        already-installed distribution; it should return a ``Distribution`` or\n        ``None``.\n\n        Unless `replace_conflicting=True`, raises a VersionConflict exception\n        if\n        any requirements are found on the path that have the correct name but\n        the wrong version.  Otherwise, if an `installer` is supplied it will be\n        invoked to obtain the correct version of the requirement and activate\n        it.\n\n        `extras` is a list of the extras to be used with these requirements.\n        This is important because extra requirements may look like `my_req;\n        extra = \"my_extra\"`, which would otherwise be interpreted as a purely\n        optional requirement.  Instead, we want to be able to assert that these\n        requirements are truly required.\n        \"\"\"\n\n        # set up the stack\n        requirements = list(requirements)[::-1]\n        # set of processed requirements\n        processed = set()\n        # key -> dist\n        best = {}\n        to_activate = []\n\n        req_extras = _ReqExtras()\n\n        # Mapping of requirement to set of distributions that required it;\n        # useful for reporting info about conflicts.\n        required_by = collections.defaultdict(set)\n\n        while requirements:\n            # process dependencies breadth-first\n            req = requirements.pop(0)\n            if req in processed:\n                # Ignore cyclic or redundant dependencies\n                continue\n\n            if not req_extras.markers_pass(req, extras):\n                continue\n\n            dist = self._resolve_dist(\n                req, best, replace_conflicting, env, installer, required_by, to_activate\n            )\n\n            # push the new requirements onto the stack\n            new_requirements = dist.requires(req.extras)[::-1]\n            requirements.extend(new_requirements)\n\n            # Register the new requirements needed by req\n            for new_requirement in new_requirements:\n                required_by[new_requirement].add(req.project_name)\n                req_extras[new_requirement] = req.extras\n\n            processed.add(req)\n\n        # return list of distros to activate\n        return to_activate\n\n    def _resolve_dist(\n        self, req, best, replace_conflicting, env, installer, required_by, to_activate\n    ) -> Distribution:\n        dist = best.get(req.key)\n        if dist is None:\n            # Find the best distribution and add it to the map\n            dist = self.by_key.get(req.key)\n            if dist is None or (dist not in req and replace_conflicting):\n                ws = self\n                if env is None:\n                    if dist is None:\n                        env = Environment(self.entries)\n                    else:\n                        # Use an empty environment and workingset to avoid\n                        # any further conflicts with the conflicting\n                        # distribution\n                        env = Environment([])\n                        ws = WorkingSet([])\n                dist = best[req.key] = env.best_match(\n                    req, ws, installer, replace_conflicting=replace_conflicting\n                )\n                if dist is None:\n                    requirers = required_by.get(req, None)\n                    raise DistributionNotFound(req, requirers)\n            to_activate.append(dist)\n        if dist not in req:\n            # Oops, the \"best\" so far conflicts with a dependency\n            dependent_req = required_by[req]\n            raise VersionConflict(dist, req).with_context(dependent_req)\n        return dist\n\n    @overload\n    def find_plugins(\n        self,\n        plugin_env: Environment,\n        full_env: Environment | None,\n        installer: _InstallerTypeT[_DistributionT],\n        fallback: bool = True,\n    ) -> tuple[list[_DistributionT], dict[Distribution, Exception]]: ...\n    @overload\n    def find_plugins(\n        self,\n        plugin_env: Environment,\n        full_env: Environment | None = None,\n        *,\n        installer: _InstallerTypeT[_DistributionT],\n        fallback: bool = True,\n    ) -> tuple[list[_DistributionT], dict[Distribution, Exception]]: ...\n    @overload\n    def find_plugins(\n        self,\n        plugin_env: Environment,\n        full_env: Environment | None = None,\n        installer: _InstallerType | None = None,\n        fallback: bool = True,\n    ) -> tuple[list[Distribution], dict[Distribution, Exception]]: ...\n    def find_plugins(\n        self,\n        plugin_env: Environment,\n        full_env: Environment | None = None,\n        installer: _InstallerType | None | _InstallerTypeT[_DistributionT] = None,\n        fallback: bool = True,\n    ) -> tuple[\n        list[Distribution] | list[_DistributionT],\n        dict[Distribution, Exception],\n    ]:\n        \"\"\"Find all activatable distributions in `plugin_env`\n\n        Example usage::\n\n            distributions, errors = working_set.find_plugins(\n                Environment(plugin_dirlist)\n            )\n            # add plugins+libs to sys.path\n            map(working_set.add, distributions)\n            # display errors\n            print('Could not load', errors)\n\n        The `plugin_env` should be an ``Environment`` instance that contains\n        only distributions that are in the project's \"plugin directory\" or\n        directories. The `full_env`, if supplied, should be an ``Environment``\n        contains all currently-available distributions.  If `full_env` is not\n        supplied, one is created automatically from the ``WorkingSet`` this\n        method is called on, which will typically mean that every directory on\n        ``sys.path`` will be scanned for distributions.\n\n        `installer` is a standard installer callback as used by the\n        ``resolve()`` method. The `fallback` flag indicates whether we should\n        attempt to resolve older versions of a plugin if the newest version\n        cannot be resolved.\n\n        This method returns a 2-tuple: (`distributions`, `error_info`), where\n        `distributions` is a list of the distributions found in `plugin_env`\n        that were loadable, along with any other distributions that are needed\n        to resolve their dependencies.  `error_info` is a dictionary mapping\n        unloadable plugin distributions to an exception instance describing the\n        error that occurred. Usually this will be a ``DistributionNotFound`` or\n        ``VersionConflict`` instance.\n        \"\"\"\n\n        plugin_projects = list(plugin_env)\n        # scan project names in alphabetic order\n        plugin_projects.sort()\n\n        error_info: dict[Distribution, Exception] = {}\n        distributions: dict[Distribution, Exception | None] = {}\n\n        if full_env is None:\n            env = Environment(self.entries)\n            env += plugin_env\n        else:\n            env = full_env + plugin_env\n\n        shadow_set = self.__class__([])\n        # put all our entries in shadow_set\n        list(map(shadow_set.add, self))\n\n        for project_name in plugin_projects:\n            for dist in plugin_env[project_name]:\n                req = [dist.as_requirement()]\n\n                try:\n                    resolvees = shadow_set.resolve(req, env, installer)\n\n                except ResolutionError as v:\n                    # save error info\n                    error_info[dist] = v\n                    if fallback:\n                        # try the next older version of project\n                        continue\n                    else:\n                        # give up on this project, keep going\n                        break\n\n                else:\n                    list(map(shadow_set.add, resolvees))\n                    distributions.update(dict.fromkeys(resolvees))\n\n                    # success, no need to try any more versions of this project\n                    break\n\n        sorted_distributions = list(distributions)\n        sorted_distributions.sort()\n\n        return sorted_distributions, error_info\n\n    def require(self, *requirements: _NestedStr):\n        \"\"\"Ensure that distributions matching `requirements` are activated\n\n        `requirements` must be a string or a (possibly-nested) sequence\n        thereof, specifying the distributions and versions required.  The\n        return value is a sequence of the distributions that needed to be\n        activated to fulfill the requirements; all relevant distributions are\n        included, even if they were already activated in this working set.\n        \"\"\"\n        needed = self.resolve(parse_requirements(requirements))\n\n        for dist in needed:\n            self.add(dist)\n\n        return needed\n\n    def subscribe(\n        self, callback: Callable[[Distribution], object], existing: bool = True\n    ):\n        \"\"\"Invoke `callback` for all distributions\n\n        If `existing=True` (default),\n        call on all existing ones, as well.\n        \"\"\"\n        if callback in self.callbacks:\n            return\n        self.callbacks.append(callback)\n        if not existing:\n            return\n        for dist in self:\n            callback(dist)\n\n    def _added_new(self, dist):\n        for callback in self.callbacks:\n            callback(dist)\n\n    def __getstate__(self):\n        return (\n            self.entries[:],\n            self.entry_keys.copy(),\n            self.by_key.copy(),\n            self.normalized_to_canonical_keys.copy(),\n            self.callbacks[:],\n        )\n\n    def __setstate__(self, e_k_b_n_c):\n        entries, keys, by_key, normalized_to_canonical_keys, callbacks = e_k_b_n_c\n        self.entries = entries[:]\n        self.entry_keys = keys.copy()\n        self.by_key = by_key.copy()\n        self.normalized_to_canonical_keys = normalized_to_canonical_keys.copy()\n        self.callbacks = callbacks[:]\n\n\nclass _ReqExtras(Dict[\"Requirement\", Tuple[str, ...]]):\n    \"\"\"\n    Map each requirement to the extras that demanded it.\n    \"\"\"\n\n    def markers_pass(self, req: Requirement, extras: tuple[str, ...] | None = None):\n        \"\"\"\n        Evaluate markers for req against each extra that\n        demanded it.\n\n        Return False if the req has a marker and fails\n        evaluation. Otherwise, return True.\n        \"\"\"\n        extra_evals = (\n            req.marker.evaluate({'extra': extra})\n            for extra in self.get(req, ()) + (extras or (None,))\n        )\n        return not req.marker or any(extra_evals)\n\n\nclass Environment:\n    \"\"\"Searchable snapshot of distributions on a search path\"\"\"\n\n    def __init__(\n        self,\n        search_path: Iterable[str] | None = None,\n        platform: str | None = get_supported_platform(),\n        python: str | None = PY_MAJOR,\n    ):\n        \"\"\"Snapshot distributions available on a search path\n\n        Any distributions found on `search_path` are added to the environment.\n        `search_path` should be a sequence of ``sys.path`` items.  If not\n        supplied, ``sys.path`` is used.\n\n        `platform` is an optional string specifying the name of the platform\n        that platform-specific distributions must be compatible with.  If\n        unspecified, it defaults to the current platform.  `python` is an\n        optional string naming the desired version of Python (e.g. ``'3.6'``);\n        it defaults to the current version.\n\n        You may explicitly set `platform` (and/or `python`) to ``None`` if you\n        wish to map *all* distributions, not just those compatible with the\n        running platform or Python version.\n        \"\"\"\n        self._distmap = {}\n        self.platform = platform\n        self.python = python\n        self.scan(search_path)\n\n    def can_add(self, dist: Distribution):\n        \"\"\"Is distribution `dist` acceptable for this environment?\n\n        The distribution must match the platform and python version\n        requirements specified when this environment was created, or False\n        is returned.\n        \"\"\"\n        py_compat = (\n            self.python is None\n            or dist.py_version is None\n            or dist.py_version == self.python\n        )\n        return py_compat and compatible_platforms(dist.platform, self.platform)\n\n    def remove(self, dist: Distribution):\n        \"\"\"Remove `dist` from the environment\"\"\"\n        self._distmap[dist.key].remove(dist)\n\n    def scan(self, search_path: Iterable[str] | None = None):\n        \"\"\"Scan `search_path` for distributions usable in this environment\n\n        Any distributions found are added to the environment.\n        `search_path` should be a sequence of ``sys.path`` items.  If not\n        supplied, ``sys.path`` is used.  Only distributions conforming to\n        the platform/python version defined at initialization are added.\n        \"\"\"\n        if search_path is None:\n            search_path = sys.path\n\n        for item in search_path:\n            for dist in find_distributions(item):\n                self.add(dist)\n\n    def __getitem__(self, project_name: str) -> list[Distribution]:\n        \"\"\"Return a newest-to-oldest list of distributions for `project_name`\n\n        Uses case-insensitive `project_name` comparison, assuming all the\n        project's distributions use their project's name converted to all\n        lowercase as their key.\n\n        \"\"\"\n        distribution_key = project_name.lower()\n        return self._distmap.get(distribution_key, [])\n\n    def add(self, dist: Distribution):\n        \"\"\"Add `dist` if we ``can_add()`` it and it has not already been added\"\"\"\n        if self.can_add(dist) and dist.has_version():\n            dists = self._distmap.setdefault(dist.key, [])\n            if dist not in dists:\n                dists.append(dist)\n                dists.sort(key=operator.attrgetter('hashcmp'), reverse=True)\n\n    @overload\n    def best_match(\n        self,\n        req: Requirement,\n        working_set: WorkingSet,\n        installer: _InstallerTypeT[_DistributionT],\n        replace_conflicting: bool = False,\n    ) -> _DistributionT: ...\n    @overload\n    def best_match(\n        self,\n        req: Requirement,\n        working_set: WorkingSet,\n        installer: _InstallerType | None = None,\n        replace_conflicting: bool = False,\n    ) -> Distribution | None: ...\n    def best_match(\n        self,\n        req: Requirement,\n        working_set: WorkingSet,\n        installer: _InstallerType | None | _InstallerTypeT[_DistributionT] = None,\n        replace_conflicting: bool = False,\n    ) -> Distribution | None:\n        \"\"\"Find distribution best matching `req` and usable on `working_set`\n\n        This calls the ``find(req)`` method of the `working_set` to see if a\n        suitable distribution is already active.  (This may raise\n        ``VersionConflict`` if an unsuitable version of the project is already\n        active in the specified `working_set`.)  If a suitable distribution\n        isn't active, this method returns the newest distribution in the\n        environment that meets the ``Requirement`` in `req`.  If no suitable\n        distribution is found, and `installer` is supplied, then the result of\n        calling the environment's ``obtain(req, installer)`` method will be\n        returned.\n        \"\"\"\n        try:\n            dist = working_set.find(req)\n        except VersionConflict:\n            if not replace_conflicting:\n                raise\n            dist = None\n        if dist is not None:\n            return dist\n        for dist in self[req.key]:\n            if dist in req:\n                return dist\n        # try to download/install\n        return self.obtain(req, installer)\n\n    @overload\n    def obtain(\n        self,\n        requirement: Requirement,\n        installer: _InstallerTypeT[_DistributionT],\n    ) -> _DistributionT: ...\n    @overload\n    def obtain(\n        self,\n        requirement: Requirement,\n        installer: Callable[[Requirement], None] | None = None,\n    ) -> None: ...\n    @overload\n    def obtain(\n        self,\n        requirement: Requirement,\n        installer: _InstallerType | None = None,\n    ) -> Distribution | None: ...\n    def obtain(\n        self,\n        requirement: Requirement,\n        installer: Callable[[Requirement], None]\n        | _InstallerType\n        | None\n        | _InstallerTypeT[_DistributionT] = None,\n    ) -> Distribution | None:\n        \"\"\"Obtain a distribution matching `requirement` (e.g. via download)\n\n        Obtain a distro that matches requirement (e.g. via download).  In the\n        base ``Environment`` class, this routine just returns\n        ``installer(requirement)``, unless `installer` is None, in which case\n        None is returned instead.  This method is a hook that allows subclasses\n        to attempt other ways of obtaining a distribution before falling back\n        to the `installer` argument.\"\"\"\n        return installer(requirement) if installer else None\n\n    def __iter__(self) -> Iterator[str]:\n        \"\"\"Yield the unique project names of the available distributions\"\"\"\n        for key in self._distmap.keys():\n            if self[key]:\n                yield key\n\n    def __iadd__(self, other: Distribution | Environment):\n        \"\"\"In-place addition of a distribution or environment\"\"\"\n        if isinstance(other, Distribution):\n            self.add(other)\n        elif isinstance(other, Environment):\n            for project in other:\n                for dist in other[project]:\n                    self.add(dist)\n        else:\n            raise TypeError(\"Can't add %r to environment\" % (other,))\n        return self\n\n    def __add__(self, other: Distribution | Environment):\n        \"\"\"Add an environment or distribution to an environment\"\"\"\n        new = self.__class__([], platform=None, python=None)\n        for env in self, other:\n            new += env\n        return new\n\n\n# XXX backward compatibility\nAvailableDistributions = Environment\n\n\nclass ExtractionError(RuntimeError):\n    \"\"\"An error occurred extracting a resource\n\n    The following attributes are available from instances of this exception:\n\n    manager\n        The resource manager that raised this exception\n\n    cache_path\n        The base directory for resource extraction\n\n    original_error\n        The exception instance that caused extraction to fail\n    \"\"\"\n\n    manager: ResourceManager\n    cache_path: str\n    original_error: BaseException | None\n\n\nclass ResourceManager:\n    \"\"\"Manage resource extraction and packages\"\"\"\n\n    extraction_path: str | None = None\n\n    def __init__(self):\n        self.cached_files = {}\n\n    def resource_exists(self, package_or_requirement: _PkgReqType, resource_name: str):\n        \"\"\"Does the named resource exist?\"\"\"\n        return get_provider(package_or_requirement).has_resource(resource_name)\n\n    def resource_isdir(self, package_or_requirement: _PkgReqType, resource_name: str):\n        \"\"\"Is the named resource an existing directory?\"\"\"\n        return get_provider(package_or_requirement).resource_isdir(resource_name)\n\n    def resource_filename(\n        self, package_or_requirement: _PkgReqType, resource_name: str\n    ):\n        \"\"\"Return a true filesystem path for specified resource\"\"\"\n        return get_provider(package_or_requirement).get_resource_filename(\n            self, resource_name\n        )\n\n    def resource_stream(self, package_or_requirement: _PkgReqType, resource_name: str):\n        \"\"\"Return a readable file-like object for specified resource\"\"\"\n        return get_provider(package_or_requirement).get_resource_stream(\n            self, resource_name\n        )\n\n    def resource_string(\n        self, package_or_requirement: _PkgReqType, resource_name: str\n    ) -> bytes:\n        \"\"\"Return specified resource as :obj:`bytes`\"\"\"\n        return get_provider(package_or_requirement).get_resource_string(\n            self, resource_name\n        )\n\n    def resource_listdir(self, package_or_requirement: _PkgReqType, resource_name: str):\n        \"\"\"List the contents of the named resource directory\"\"\"\n        return get_provider(package_or_requirement).resource_listdir(resource_name)\n\n    def extraction_error(self) -> NoReturn:\n        \"\"\"Give an error message for problems extracting file(s)\"\"\"\n\n        old_exc = sys.exc_info()[1]\n        cache_path = self.extraction_path or get_default_cache()\n\n        tmpl = textwrap.dedent(\n            \"\"\"\n            Can't extract file(s) to egg cache\n\n            The following error occurred while trying to extract file(s)\n            to the Python egg cache:\n\n              {old_exc}\n\n            The Python egg cache directory is currently set to:\n\n              {cache_path}\n\n            Perhaps your account does not have write access to this directory?\n            You can change the cache directory by setting the PYTHON_EGG_CACHE\n            environment variable to point to an accessible directory.\n            \"\"\"\n        ).lstrip()\n        err = ExtractionError(tmpl.format(**locals()))\n        err.manager = self\n        err.cache_path = cache_path\n        err.original_error = old_exc\n        raise err\n\n    def get_cache_path(self, archive_name: str, names: Iterable[StrPath] = ()):\n        \"\"\"Return absolute location in cache for `archive_name` and `names`\n\n        The parent directory of the resulting path will be created if it does\n        not already exist.  `archive_name` should be the base filename of the\n        enclosing egg (which may not be the name of the enclosing zipfile!),\n        including its \".egg\" extension.  `names`, if provided, should be a\n        sequence of path name parts \"under\" the egg's extraction location.\n\n        This method should only be called by resource providers that need to\n        obtain an extraction location, and only for names they intend to\n        extract, as it tracks the generated names for possible cleanup later.\n        \"\"\"\n        extract_path = self.extraction_path or get_default_cache()\n        target_path = os.path.join(extract_path, archive_name + '-tmp', *names)\n        try:\n            _bypass_ensure_directory(target_path)\n        except Exception:\n            self.extraction_error()\n\n        self._warn_unsafe_extraction_path(extract_path)\n\n        self.cached_files[target_path] = True\n        return target_path\n\n    @staticmethod\n    def _warn_unsafe_extraction_path(path):\n        \"\"\"\n        If the default extraction path is overridden and set to an insecure\n        location, such as /tmp, it opens up an opportunity for an attacker to\n        replace an extracted file with an unauthorized payload. Warn the user\n        if a known insecure location is used.\n\n        See Distribute #375 for more details.\n        \"\"\"\n        if os.name == 'nt' and not path.startswith(os.environ['windir']):\n            # On Windows, permissions are generally restrictive by default\n            #  and temp directories are not writable by other users, so\n            #  bypass the warning.\n            return\n        mode = os.stat(path).st_mode\n        if mode & stat.S_IWOTH or mode & stat.S_IWGRP:\n            msg = (\n                \"Extraction path is writable by group/others \"\n                \"and vulnerable to attack when \"\n                \"used with get_resource_filename ({path}). \"\n                \"Consider a more secure \"\n                \"location (set with .set_extraction_path or the \"\n                \"PYTHON_EGG_CACHE environment variable).\"\n            ).format(**locals())\n            warnings.warn(msg, UserWarning)\n\n    def postprocess(self, tempname: StrOrBytesPath, filename: StrOrBytesPath):\n        \"\"\"Perform any platform-specific postprocessing of `tempname`\n\n        This is where Mac header rewrites should be done; other platforms don't\n        have anything special they should do.\n\n        Resource providers should call this method ONLY after successfully\n        extracting a compressed resource.  They must NOT call it on resources\n        that are already in the filesystem.\n\n        `tempname` is the current (temporary) name of the file, and `filename`\n        is the name it will be renamed to by the caller after this routine\n        returns.\n        \"\"\"\n\n        if os.name == 'posix':\n            # Make the resource executable\n            mode = ((os.stat(tempname).st_mode) | 0o555) & 0o7777\n            os.chmod(tempname, mode)\n\n    def set_extraction_path(self, path: str):\n        \"\"\"Set the base path where resources will be extracted to, if needed.\n\n        If you do not call this routine before any extractions take place, the\n        path defaults to the return value of ``get_default_cache()``.  (Which\n        is based on the ``PYTHON_EGG_CACHE`` environment variable, with various\n        platform-specific fallbacks.  See that routine's documentation for more\n        details.)\n\n        Resources are extracted to subdirectories of this path based upon\n        information given by the ``IResourceProvider``.  You may set this to a\n        temporary directory, but then you must call ``cleanup_resources()`` to\n        delete the extracted files when done.  There is no guarantee that\n        ``cleanup_resources()`` will be able to remove all extracted files.\n\n        (Note: you may not change the extraction path for a given resource\n        manager once resources have been extracted, unless you first call\n        ``cleanup_resources()``.)\n        \"\"\"\n        if self.cached_files:\n            raise ValueError(\"Can't change extraction path, files already extracted\")\n\n        self.extraction_path = path\n\n    def cleanup_resources(self, force: bool = False) -> list[str]:\n        \"\"\"\n        Delete all extracted resource files and directories, returning a list\n        of the file and directory names that could not be successfully removed.\n        This function does not have any concurrency protection, so it should\n        generally only be called when the extraction path is a temporary\n        directory exclusive to a single process.  This method is not\n        automatically called; you must call it explicitly or register it as an\n        ``atexit`` function if you wish to ensure cleanup of a temporary\n        directory used for extractions.\n        \"\"\"\n        # XXX\n        return []\n\n\ndef get_default_cache() -> str:\n    \"\"\"\n    Return the ``PYTHON_EGG_CACHE`` environment variable\n    or a platform-relevant user cache dir for an app\n    named \"Python-Eggs\".\n    \"\"\"\n    return os.environ.get('PYTHON_EGG_CACHE') or _user_cache_dir(appname='Python-Eggs')\n\n\ndef safe_name(name: str):\n    \"\"\"Convert an arbitrary string to a standard distribution name\n\n    Any runs of non-alphanumeric/. characters are replaced with a single '-'.\n    \"\"\"\n    return re.sub('[^A-Za-z0-9.]+', '-', name)\n\n\ndef safe_version(version: str):\n    \"\"\"\n    Convert an arbitrary string to a standard version string\n    \"\"\"\n    try:\n        # normalize the version\n        return str(_packaging_version.Version(version))\n    except _packaging_version.InvalidVersion:\n        version = version.replace(' ', '.')\n        return re.sub('[^A-Za-z0-9.]+', '-', version)\n\n\ndef _forgiving_version(version):\n    \"\"\"Fallback when ``safe_version`` is not safe enough\n    >>> parse_version(_forgiving_version('0.23ubuntu1'))\n    <Version('0.23.dev0+sanitized.ubuntu1')>\n    >>> parse_version(_forgiving_version('0.23-'))\n    <Version('0.23.dev0+sanitized')>\n    >>> parse_version(_forgiving_version('0.-_'))\n    <Version('0.dev0+sanitized')>\n    >>> parse_version(_forgiving_version('42.+?1'))\n    <Version('42.dev0+sanitized.1')>\n    >>> parse_version(_forgiving_version('hello world'))\n    <Version('0.dev0+sanitized.hello.world')>\n    \"\"\"\n    version = version.replace(' ', '.')\n    match = _PEP440_FALLBACK.search(version)\n    if match:\n        safe = match[\"safe\"]\n        rest = version[len(safe) :]\n    else:\n        safe = \"0\"\n        rest = version\n    local = f\"sanitized.{_safe_segment(rest)}\".strip(\".\")\n    return f\"{safe}.dev0+{local}\"\n\n\ndef _safe_segment(segment):\n    \"\"\"Convert an arbitrary string into a safe segment\"\"\"\n    segment = re.sub('[^A-Za-z0-9.]+', '-', segment)\n    segment = re.sub('-[^A-Za-z0-9]+', '-', segment)\n    return re.sub(r'\\.[^A-Za-z0-9]+', '.', segment).strip(\".-\")\n\n\ndef safe_extra(extra: str):\n    \"\"\"Convert an arbitrary string to a standard 'extra' name\n\n    Any runs of non-alphanumeric characters are replaced with a single '_',\n    and the result is always lowercased.\n    \"\"\"\n    return re.sub('[^A-Za-z0-9.-]+', '_', extra).lower()\n\n\ndef to_filename(name: str):\n    \"\"\"Convert a project or version name to its filename-escaped form\n\n    Any '-' characters are currently replaced with '_'.\n    \"\"\"\n    return name.replace('-', '_')\n\n\ndef invalid_marker(text: str):\n    \"\"\"\n    Validate text as a PEP 508 environment marker; return an exception\n    if invalid or False otherwise.\n    \"\"\"\n    try:\n        evaluate_marker(text)\n    except SyntaxError as e:\n        e.filename = None\n        e.lineno = None\n        return e\n    return False\n\n\ndef evaluate_marker(text: str, extra: str | None = None) -> bool:\n    \"\"\"\n    Evaluate a PEP 508 environment marker.\n    Return a boolean indicating the marker result in this environment.\n    Raise SyntaxError if marker is invalid.\n\n    This implementation uses the 'pyparsing' module.\n    \"\"\"\n    try:\n        marker = _packaging_markers.Marker(text)\n        return marker.evaluate()\n    except _packaging_markers.InvalidMarker as e:\n        raise SyntaxError(e) from e\n\n\nclass NullProvider:\n    \"\"\"Try to implement resources and metadata for arbitrary PEP 302 loaders\"\"\"\n\n    egg_name: str | None = None\n    egg_info: str | None = None\n    loader: _LoaderProtocol | None = None\n\n    def __init__(self, module: _ModuleLike):\n        self.loader = getattr(module, '__loader__', None)\n        self.module_path = os.path.dirname(getattr(module, '__file__', ''))\n\n    def get_resource_filename(self, manager: ResourceManager, resource_name: str):\n        return self._fn(self.module_path, resource_name)\n\n    def get_resource_stream(self, manager: ResourceManager, resource_name: str):\n        return io.BytesIO(self.get_resource_string(manager, resource_name))\n\n    def get_resource_string(\n        self, manager: ResourceManager, resource_name: str\n    ) -> bytes:\n        return self._get(self._fn(self.module_path, resource_name))\n\n    def has_resource(self, resource_name: str):\n        return self._has(self._fn(self.module_path, resource_name))\n\n    def _get_metadata_path(self, name):\n        return self._fn(self.egg_info, name)\n\n    def has_metadata(self, name: str) -> bool:\n        if not self.egg_info:\n            return False\n\n        path = self._get_metadata_path(name)\n        return self._has(path)\n\n    def get_metadata(self, name: str):\n        if not self.egg_info:\n            return \"\"\n        path = self._get_metadata_path(name)\n        value = self._get(path)\n        try:\n            return value.decode('utf-8')\n        except UnicodeDecodeError as exc:\n            # Include the path in the error message to simplify\n            # troubleshooting, and without changing the exception type.\n            exc.reason += ' in {} file at path: {}'.format(name, path)\n            raise\n\n    def get_metadata_lines(self, name: str) -> Iterator[str]:\n        return yield_lines(self.get_metadata(name))\n\n    def resource_isdir(self, resource_name: str):\n        return self._isdir(self._fn(self.module_path, resource_name))\n\n    def metadata_isdir(self, name: str) -> bool:\n        return bool(self.egg_info and self._isdir(self._fn(self.egg_info, name)))\n\n    def resource_listdir(self, resource_name: str):\n        return self._listdir(self._fn(self.module_path, resource_name))\n\n    def metadata_listdir(self, name: str) -> list[str]:\n        if self.egg_info:\n            return self._listdir(self._fn(self.egg_info, name))\n        return []\n\n    def run_script(self, script_name: str, namespace: dict[str, Any]):\n        script = 'scripts/' + script_name\n        if not self.has_metadata(script):\n            raise ResolutionError(\n                \"Script {script!r} not found in metadata at {self.egg_info!r}\".format(\n                    **locals()\n                ),\n            )\n\n        script_text = self.get_metadata(script).replace('\\r\\n', '\\n')\n        script_text = script_text.replace('\\r', '\\n')\n        script_filename = self._fn(self.egg_info, script)\n        namespace['__file__'] = script_filename\n        if os.path.exists(script_filename):\n            source = _read_utf8_with_fallback(script_filename)\n            code = compile(source, script_filename, 'exec')\n            exec(code, namespace, namespace)\n        else:\n            from linecache import cache\n\n            cache[script_filename] = (\n                len(script_text),\n                0,\n                script_text.split('\\n'),\n                script_filename,\n            )\n            script_code = compile(script_text, script_filename, 'exec')\n            exec(script_code, namespace, namespace)\n\n    def _has(self, path) -> bool:\n        raise NotImplementedError(\n            \"Can't perform this operation for unregistered loader type\"\n        )\n\n    def _isdir(self, path) -> bool:\n        raise NotImplementedError(\n            \"Can't perform this operation for unregistered loader type\"\n        )\n\n    def _listdir(self, path) -> list[str]:\n        raise NotImplementedError(\n            \"Can't perform this operation for unregistered loader type\"\n        )\n\n    def _fn(self, base: str | None, resource_name: str):\n        if base is None:\n            raise TypeError(\n                \"`base` parameter in `_fn` is `None`. Either override this method or check the parameter first.\"\n            )\n        self._validate_resource_path(resource_name)\n        if resource_name:\n            return os.path.join(base, *resource_name.split('/'))\n        return base\n\n    @staticmethod\n    def _validate_resource_path(path):\n        \"\"\"\n        Validate the resource paths according to the docs.\n        https://setuptools.pypa.io/en/latest/pkg_resources.html#basic-resource-access\n\n        >>> warned = getfixture('recwarn')\n        >>> warnings.simplefilter('always')\n        >>> vrp = NullProvider._validate_resource_path\n        >>> vrp('foo/bar.txt')\n        >>> bool(warned)\n        False\n        >>> vrp('../foo/bar.txt')\n        >>> bool(warned)\n        True\n        >>> warned.clear()\n        >>> vrp('/foo/bar.txt')\n        >>> bool(warned)\n        True\n        >>> vrp('foo/../../bar.txt')\n        >>> bool(warned)\n        True\n        >>> warned.clear()\n        >>> vrp('foo/f../bar.txt')\n        >>> bool(warned)\n        False\n\n        Windows path separators are straight-up disallowed.\n        >>> vrp(r'\\\\foo/bar.txt')\n        Traceback (most recent call last):\n        ...\n        ValueError: Use of .. or absolute path in a resource path \\\nis not allowed.\n\n        >>> vrp(r'C:\\\\foo/bar.txt')\n        Traceback (most recent call last):\n        ...\n        ValueError: Use of .. or absolute path in a resource path \\\nis not allowed.\n\n        Blank values are allowed\n\n        >>> vrp('')\n        >>> bool(warned)\n        False\n\n        Non-string values are not.\n\n        >>> vrp(None)\n        Traceback (most recent call last):\n        ...\n        AttributeError: ...\n        \"\"\"\n        invalid = (\n            os.path.pardir in path.split(posixpath.sep)\n            or posixpath.isabs(path)\n            or ntpath.isabs(path)\n            or path.startswith(\"\\\\\")\n        )\n        if not invalid:\n            return\n\n        msg = \"Use of .. or absolute path in a resource path is not allowed.\"\n\n        # Aggressively disallow Windows absolute paths\n        if (path.startswith(\"\\\\\") or ntpath.isabs(path)) and not posixpath.isabs(path):\n            raise ValueError(msg)\n\n        # for compatibility, warn; in future\n        # raise ValueError(msg)\n        issue_warning(\n            msg[:-1] + \" and will raise exceptions in a future release.\",\n            DeprecationWarning,\n        )\n\n    def _get(self, path) -> bytes:\n        if hasattr(self.loader, 'get_data') and self.loader:\n            # Already checked get_data exists\n            return self.loader.get_data(path)  # type: ignore[attr-defined]\n        raise NotImplementedError(\n            \"Can't perform this operation for loaders without 'get_data()'\"\n        )\n\n\nregister_loader_type(object, NullProvider)\n\n\ndef _parents(path):\n    \"\"\"\n    yield all parents of path including path\n    \"\"\"\n    last = None\n    while path != last:\n        yield path\n        last = path\n        path, _ = os.path.split(path)\n\n\nclass EggProvider(NullProvider):\n    \"\"\"Provider based on a virtual filesystem\"\"\"\n\n    def __init__(self, module: _ModuleLike):\n        super().__init__(module)\n        self._setup_prefix()\n\n    def _setup_prefix(self):\n        # Assume that metadata may be nested inside a \"basket\"\n        # of multiple eggs and use module_path instead of .archive.\n        eggs = filter(_is_egg_path, _parents(self.module_path))\n        egg = next(eggs, None)\n        egg and self._set_egg(egg)\n\n    def _set_egg(self, path: str):\n        self.egg_name = os.path.basename(path)\n        self.egg_info = os.path.join(path, 'EGG-INFO')\n        self.egg_root = path\n\n\nclass DefaultProvider(EggProvider):\n    \"\"\"Provides access to package resources in the filesystem\"\"\"\n\n    def _has(self, path) -> bool:\n        return os.path.exists(path)\n\n    def _isdir(self, path) -> bool:\n        return os.path.isdir(path)\n\n    def _listdir(self, path):\n        return os.listdir(path)\n\n    def get_resource_stream(self, manager: object, resource_name: str):\n        return open(self._fn(self.module_path, resource_name), 'rb')\n\n    def _get(self, path) -> bytes:\n        with open(path, 'rb') as stream:\n            return stream.read()\n\n    @classmethod\n    def _register(cls):\n        loader_names = (\n            'SourceFileLoader',\n            'SourcelessFileLoader',\n        )\n        for name in loader_names:\n            loader_cls = getattr(importlib.machinery, name, type(None))\n            register_loader_type(loader_cls, cls)\n\n\nDefaultProvider._register()\n\n\nclass EmptyProvider(NullProvider):\n    \"\"\"Provider that returns nothing for all requests\"\"\"\n\n    # A special case, we don't want all Providers inheriting from NullProvider to have a potentially None module_path\n    module_path: str | None = None  # type: ignore[assignment]\n\n    _isdir = _has = lambda self, path: False\n\n    def _get(self, path) -> bytes:\n        return b''\n\n    def _listdir(self, path):\n        return []\n\n    def __init__(self):\n        pass\n\n\nempty_provider = EmptyProvider()\n\n\nclass ZipManifests(Dict[str, \"MemoizedZipManifests.manifest_mod\"]):\n    \"\"\"\n    zip manifest builder\n    \"\"\"\n\n    # `path` could be `StrPath | IO[bytes]` but that violates the LSP for `MemoizedZipManifests.load`\n    @classmethod\n    def build(cls, path: str):\n        \"\"\"\n        Build a dictionary similar to the zipimport directory\n        caches, except instead of tuples, store ZipInfo objects.\n\n        Use a platform-specific path separator (os.sep) for the path keys\n        for compatibility with pypy on Windows.\n        \"\"\"\n        with zipfile.ZipFile(path) as zfile:\n            items = (\n                (\n                    name.replace('/', os.sep),\n                    zfile.getinfo(name),\n                )\n                for name in zfile.namelist()\n            )\n            return dict(items)\n\n    load = build\n\n\nclass MemoizedZipManifests(ZipManifests):\n    \"\"\"\n    Memoized zipfile manifests.\n    \"\"\"\n\n    class manifest_mod(NamedTuple):\n        manifest: dict[str, zipfile.ZipInfo]\n        mtime: float\n\n    def load(self, path: str) -> dict[str, zipfile.ZipInfo]:  # type: ignore[override] # ZipManifests.load is a classmethod\n        \"\"\"\n        Load a manifest at path or return a suitable manifest already loaded.\n        \"\"\"\n        path = os.path.normpath(path)\n        mtime = os.stat(path).st_mtime\n\n        if path not in self or self[path].mtime != mtime:\n            manifest = self.build(path)\n            self[path] = self.manifest_mod(manifest, mtime)\n\n        return self[path].manifest\n\n\nclass ZipProvider(EggProvider):\n    \"\"\"Resource support for zips and eggs\"\"\"\n\n    eagers: list[str] | None = None\n    _zip_manifests = MemoizedZipManifests()\n    # ZipProvider's loader should always be a zipimporter or equivalent\n    loader: zipimport.zipimporter\n\n    def __init__(self, module: _ZipLoaderModule):\n        super().__init__(module)\n        self.zip_pre = self.loader.archive + os.sep\n\n    def _zipinfo_name(self, fspath):\n        # Convert a virtual filename (full path to file) into a zipfile subpath\n        # usable with the zipimport directory cache for our target archive\n        fspath = fspath.rstrip(os.sep)\n        if fspath == self.loader.archive:\n            return ''\n        if fspath.startswith(self.zip_pre):\n            return fspath[len(self.zip_pre) :]\n        raise AssertionError(\"%s is not a subpath of %s\" % (fspath, self.zip_pre))\n\n    def _parts(self, zip_path):\n        # Convert a zipfile subpath into an egg-relative path part list.\n        # pseudo-fs path\n        fspath = self.zip_pre + zip_path\n        if fspath.startswith(self.egg_root + os.sep):\n            return fspath[len(self.egg_root) + 1 :].split(os.sep)\n        raise AssertionError(\"%s is not a subpath of %s\" % (fspath, self.egg_root))\n\n    @property\n    def zipinfo(self):\n        return self._zip_manifests.load(self.loader.archive)\n\n    def get_resource_filename(self, manager: ResourceManager, resource_name: str):\n        if not self.egg_name:\n            raise NotImplementedError(\n                \"resource_filename() only supported for .egg, not .zip\"\n            )\n        # no need to lock for extraction, since we use temp names\n        zip_path = self._resource_to_zip(resource_name)\n        eagers = self._get_eager_resources()\n        if '/'.join(self._parts(zip_path)) in eagers:\n            for name in eagers:\n                self._extract_resource(manager, self._eager_to_zip(name))\n        return self._extract_resource(manager, zip_path)\n\n    @staticmethod\n    def _get_date_and_size(zip_stat):\n        size = zip_stat.file_size\n        # ymdhms+wday, yday, dst\n        date_time = zip_stat.date_time + (0, 0, -1)\n        # 1980 offset already done\n        timestamp = time.mktime(date_time)\n        return timestamp, size\n\n    # FIXME: 'ZipProvider._extract_resource' is too complex (12)\n    def _extract_resource(self, manager: ResourceManager, zip_path) -> str:  # noqa: C901\n        if zip_path in self._index():\n            for name in self._index()[zip_path]:\n                last = self._extract_resource(manager, os.path.join(zip_path, name))\n            # return the extracted directory name\n            return os.path.dirname(last)\n\n        timestamp, size = self._get_date_and_size(self.zipinfo[zip_path])\n\n        if not WRITE_SUPPORT:\n            raise OSError(\n                '\"os.rename\" and \"os.unlink\" are not supported on this platform'\n            )\n        try:\n            if not self.egg_name:\n                raise OSError(\n                    '\"egg_name\" is empty. This likely means no egg could be found from the \"module_path\".'\n                )\n            real_path = manager.get_cache_path(self.egg_name, self._parts(zip_path))\n\n            if self._is_current(real_path, zip_path):\n                return real_path\n\n            outf, tmpnam = _mkstemp(\n                \".$extract\",\n                dir=os.path.dirname(real_path),\n            )\n            os.write(outf, self.loader.get_data(zip_path))\n            os.close(outf)\n            utime(tmpnam, (timestamp, timestamp))\n            manager.postprocess(tmpnam, real_path)\n\n            try:\n                rename(tmpnam, real_path)\n\n            except OSError:\n                if os.path.isfile(real_path):\n                    if self._is_current(real_path, zip_path):\n                        # the file became current since it was checked above,\n                        #  so proceed.\n                        return real_path\n                    # Windows, del old file and retry\n                    elif os.name == 'nt':\n                        unlink(real_path)\n                        rename(tmpnam, real_path)\n                        return real_path\n                raise\n\n        except OSError:\n            # report a user-friendly error\n            manager.extraction_error()\n\n        return real_path\n\n    def _is_current(self, file_path, zip_path):\n        \"\"\"\n        Return True if the file_path is current for this zip_path\n        \"\"\"\n        timestamp, size = self._get_date_and_size(self.zipinfo[zip_path])\n        if not os.path.isfile(file_path):\n            return False\n        stat = os.stat(file_path)\n        if stat.st_size != size or stat.st_mtime != timestamp:\n            return False\n        # check that the contents match\n        zip_contents = self.loader.get_data(zip_path)\n        with open(file_path, 'rb') as f:\n            file_contents = f.read()\n        return zip_contents == file_contents\n\n    def _get_eager_resources(self):\n        if self.eagers is None:\n            eagers = []\n            for name in ('native_libs.txt', 'eager_resources.txt'):\n                if self.has_metadata(name):\n                    eagers.extend(self.get_metadata_lines(name))\n            self.eagers = eagers\n        return self.eagers\n\n    def _index(self):\n        try:\n            return self._dirindex\n        except AttributeError:\n            ind = {}\n            for path in self.zipinfo:\n                parts = path.split(os.sep)\n                while parts:\n                    parent = os.sep.join(parts[:-1])\n                    if parent in ind:\n                        ind[parent].append(parts[-1])\n                        break\n                    else:\n                        ind[parent] = [parts.pop()]\n            self._dirindex = ind\n            return ind\n\n    def _has(self, fspath) -> bool:\n        zip_path = self._zipinfo_name(fspath)\n        return zip_path in self.zipinfo or zip_path in self._index()\n\n    def _isdir(self, fspath) -> bool:\n        return self._zipinfo_name(fspath) in self._index()\n\n    def _listdir(self, fspath):\n        return list(self._index().get(self._zipinfo_name(fspath), ()))\n\n    def _eager_to_zip(self, resource_name: str):\n        return self._zipinfo_name(self._fn(self.egg_root, resource_name))\n\n    def _resource_to_zip(self, resource_name: str):\n        return self._zipinfo_name(self._fn(self.module_path, resource_name))\n\n\nregister_loader_type(zipimport.zipimporter, ZipProvider)\n\n\nclass FileMetadata(EmptyProvider):\n    \"\"\"Metadata handler for standalone PKG-INFO files\n\n    Usage::\n\n        metadata = FileMetadata(\"/path/to/PKG-INFO\")\n\n    This provider rejects all data and metadata requests except for PKG-INFO,\n    which is treated as existing, and will be the contents of the file at\n    the provided location.\n    \"\"\"\n\n    def __init__(self, path: StrPath):\n        self.path = path\n\n    def _get_metadata_path(self, name):\n        return self.path\n\n    def has_metadata(self, name: str) -> bool:\n        return name == 'PKG-INFO' and os.path.isfile(self.path)\n\n    def get_metadata(self, name: str):\n        if name != 'PKG-INFO':\n            raise KeyError(\"No metadata except PKG-INFO is available\")\n\n        with open(self.path, encoding='utf-8', errors=\"replace\") as f:\n            metadata = f.read()\n        self._warn_on_replacement(metadata)\n        return metadata\n\n    def _warn_on_replacement(self, metadata):\n        replacement_char = ''\n        if replacement_char in metadata:\n            tmpl = \"{self.path} could not be properly decoded in UTF-8\"\n            msg = tmpl.format(**locals())\n            warnings.warn(msg)\n\n    def get_metadata_lines(self, name: str) -> Iterator[str]:\n        return yield_lines(self.get_metadata(name))\n\n\nclass PathMetadata(DefaultProvider):\n    \"\"\"Metadata provider for egg directories\n\n    Usage::\n\n        # Development eggs:\n\n        egg_info = \"/path/to/PackageName.egg-info\"\n        base_dir = os.path.dirname(egg_info)\n        metadata = PathMetadata(base_dir, egg_info)\n        dist_name = os.path.splitext(os.path.basename(egg_info))[0]\n        dist = Distribution(basedir, project_name=dist_name, metadata=metadata)\n\n        # Unpacked egg directories:\n\n        egg_path = \"/path/to/PackageName-ver-pyver-etc.egg\"\n        metadata = PathMetadata(egg_path, os.path.join(egg_path,'EGG-INFO'))\n        dist = Distribution.from_filename(egg_path, metadata=metadata)\n    \"\"\"\n\n    def __init__(self, path: str, egg_info: str):\n        self.module_path = path\n        self.egg_info = egg_info\n\n\nclass EggMetadata(ZipProvider):\n    \"\"\"Metadata provider for .egg files\"\"\"\n\n    def __init__(self, importer: zipimport.zipimporter):\n        \"\"\"Create a metadata provider from a zipimporter\"\"\"\n\n        self.zip_pre = importer.archive + os.sep\n        self.loader = importer\n        if importer.prefix:\n            self.module_path = os.path.join(importer.archive, importer.prefix)\n        else:\n            self.module_path = importer.archive\n        self._setup_prefix()\n\n\n_distribution_finders: dict[type, _DistFinderType[Any]] = _declare_state(\n    'dict', '_distribution_finders', {}\n)\n\n\ndef register_finder(importer_type: type[_T], distribution_finder: _DistFinderType[_T]):\n    \"\"\"Register `distribution_finder` to find distributions in sys.path items\n\n    `importer_type` is the type or class of a PEP 302 \"Importer\" (sys.path item\n    handler), and `distribution_finder` is a callable that, passed a path\n    item and the importer instance, yields ``Distribution`` instances found on\n    that path item.  See ``pkg_resources.find_on_path`` for an example.\"\"\"\n    _distribution_finders[importer_type] = distribution_finder\n\n\ndef find_distributions(path_item: str, only: bool = False):\n    \"\"\"Yield distributions accessible via `path_item`\"\"\"\n    importer = get_importer(path_item)\n    finder = _find_adapter(_distribution_finders, importer)\n    return finder(importer, path_item, only)\n\n\ndef find_eggs_in_zip(\n    importer: zipimport.zipimporter, path_item: str, only: bool = False\n) -> Iterator[Distribution]:\n    \"\"\"\n    Find eggs in zip files; possibly multiple nested eggs.\n    \"\"\"\n    if importer.archive.endswith('.whl'):\n        # wheels are not supported with this finder\n        # they don't have PKG-INFO metadata, and won't ever contain eggs\n        return\n    metadata = EggMetadata(importer)\n    if metadata.has_metadata('PKG-INFO'):\n        yield Distribution.from_filename(path_item, metadata=metadata)\n    if only:\n        # don't yield nested distros\n        return\n    for subitem in metadata.resource_listdir(''):\n        if _is_egg_path(subitem):\n            subpath = os.path.join(path_item, subitem)\n            dists = find_eggs_in_zip(zipimport.zipimporter(subpath), subpath)\n            yield from dists\n        elif subitem.lower().endswith(('.dist-info', '.egg-info')):\n            subpath = os.path.join(path_item, subitem)\n            submeta = EggMetadata(zipimport.zipimporter(subpath))\n            submeta.egg_info = subpath\n            yield Distribution.from_location(path_item, subitem, submeta)\n\n\nregister_finder(zipimport.zipimporter, find_eggs_in_zip)\n\n\ndef find_nothing(\n    importer: object | None, path_item: str | None, only: bool | None = False\n):\n    return ()\n\n\nregister_finder(object, find_nothing)\n\n\ndef find_on_path(importer: object | None, path_item, only=False):\n    \"\"\"Yield distributions accessible on a sys.path directory\"\"\"\n    path_item = _normalize_cached(path_item)\n\n    if _is_unpacked_egg(path_item):\n        yield Distribution.from_filename(\n            path_item,\n            metadata=PathMetadata(path_item, os.path.join(path_item, 'EGG-INFO')),\n        )\n        return\n\n    entries = (os.path.join(path_item, child) for child in safe_listdir(path_item))\n\n    # scan for .egg and .egg-info in directory\n    for entry in sorted(entries):\n        fullpath = os.path.join(path_item, entry)\n        factory = dist_factory(path_item, entry, only)\n        yield from factory(fullpath)\n\n\ndef dist_factory(path_item, entry, only):\n    \"\"\"Return a dist_factory for the given entry.\"\"\"\n    lower = entry.lower()\n    is_egg_info = lower.endswith('.egg-info')\n    is_dist_info = lower.endswith('.dist-info') and os.path.isdir(\n        os.path.join(path_item, entry)\n    )\n    is_meta = is_egg_info or is_dist_info\n    return (\n        distributions_from_metadata\n        if is_meta\n        else find_distributions\n        if not only and _is_egg_path(entry)\n        else resolve_egg_link\n        if not only and lower.endswith('.egg-link')\n        else NoDists()\n    )\n\n\nclass NoDists:\n    \"\"\"\n    >>> bool(NoDists())\n    False\n\n    >>> list(NoDists()('anything'))\n    []\n    \"\"\"\n\n    def __bool__(self):\n        return False\n\n    def __call__(self, fullpath):\n        return iter(())\n\n\ndef safe_listdir(path: StrOrBytesPath):\n    \"\"\"\n    Attempt to list contents of path, but suppress some exceptions.\n    \"\"\"\n    try:\n        return os.listdir(path)\n    except (PermissionError, NotADirectoryError):\n        pass\n    except OSError as e:\n        # Ignore the directory if does not exist, not a directory or\n        # permission denied\n        if e.errno not in (errno.ENOTDIR, errno.EACCES, errno.ENOENT):\n            raise\n    return ()\n\n\ndef distributions_from_metadata(path: str):\n    root = os.path.dirname(path)\n    if os.path.isdir(path):\n        if len(os.listdir(path)) == 0:\n            # empty metadata dir; skip\n            return\n        metadata: _MetadataType = PathMetadata(root, path)\n    else:\n        metadata = FileMetadata(path)\n    entry = os.path.basename(path)\n    yield Distribution.from_location(\n        root,\n        entry,\n        metadata,\n        precedence=DEVELOP_DIST,\n    )\n\n\ndef non_empty_lines(path):\n    \"\"\"\n    Yield non-empty lines from file at path\n    \"\"\"\n    for line in _read_utf8_with_fallback(path).splitlines():\n        line = line.strip()\n        if line:\n            yield line\n\n\ndef resolve_egg_link(path):\n    \"\"\"\n    Given a path to an .egg-link, resolve distributions\n    present in the referenced path.\n    \"\"\"\n    referenced_paths = non_empty_lines(path)\n    resolved_paths = (\n        os.path.join(os.path.dirname(path), ref) for ref in referenced_paths\n    )\n    dist_groups = map(find_distributions, resolved_paths)\n    return next(dist_groups, ())\n\n\nif hasattr(pkgutil, 'ImpImporter'):\n    register_finder(pkgutil.ImpImporter, find_on_path)\n\nregister_finder(importlib.machinery.FileFinder, find_on_path)\n\n_namespace_handlers: dict[type, _NSHandlerType[Any]] = _declare_state(\n    'dict', '_namespace_handlers', {}\n)\n_namespace_packages: dict[str | None, list[str]] = _declare_state(\n    'dict', '_namespace_packages', {}\n)\n\n\ndef register_namespace_handler(\n    importer_type: type[_T], namespace_handler: _NSHandlerType[_T]\n):\n    \"\"\"Register `namespace_handler` to declare namespace packages\n\n    `importer_type` is the type or class of a PEP 302 \"Importer\" (sys.path item\n    handler), and `namespace_handler` is a callable like this::\n\n        def namespace_handler(importer, path_entry, moduleName, module):\n            # return a path_entry to use for child packages\n\n    Namespace handlers are only called if the importer object has already\n    agreed that it can handle the relevant path item, and they should only\n    return a subpath if the module __path__ does not already contain an\n    equivalent subpath.  For an example namespace handler, see\n    ``pkg_resources.file_ns_handler``.\n    \"\"\"\n    _namespace_handlers[importer_type] = namespace_handler\n\n\ndef _handle_ns(packageName, path_item):\n    \"\"\"Ensure that named package includes a subpath of path_item (if needed)\"\"\"\n\n    importer = get_importer(path_item)\n    if importer is None:\n        return None\n\n    # use find_spec (PEP 451) and fall-back to find_module (PEP 302)\n    try:\n        spec = importer.find_spec(packageName)\n    except AttributeError:\n        # capture warnings due to #1111\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            loader = importer.find_module(packageName)\n    else:\n        loader = spec.loader if spec else None\n\n    if loader is None:\n        return None\n    module = sys.modules.get(packageName)\n    if module is None:\n        module = sys.modules[packageName] = types.ModuleType(packageName)\n        module.__path__ = []\n        _set_parent_ns(packageName)\n    elif not hasattr(module, '__path__'):\n        raise TypeError(\"Not a package:\", packageName)\n    handler = _find_adapter(_namespace_handlers, importer)\n    subpath = handler(importer, path_item, packageName, module)\n    if subpath is not None:\n        path = module.__path__\n        path.append(subpath)\n        importlib.import_module(packageName)\n        _rebuild_mod_path(path, packageName, module)\n    return subpath\n\n\ndef _rebuild_mod_path(orig_path, package_name, module: types.ModuleType):\n    \"\"\"\n    Rebuild module.__path__ ensuring that all entries are ordered\n    corresponding to their sys.path order\n    \"\"\"\n    sys_path = [_normalize_cached(p) for p in sys.path]\n\n    def safe_sys_path_index(entry):\n        \"\"\"\n        Workaround for #520 and #513.\n        \"\"\"\n        try:\n            return sys_path.index(entry)\n        except ValueError:\n            return float('inf')\n\n    def position_in_sys_path(path):\n        \"\"\"\n        Return the ordinal of the path based on its position in sys.path\n        \"\"\"\n        path_parts = path.split(os.sep)\n        module_parts = package_name.count('.') + 1\n        parts = path_parts[:-module_parts]\n        return safe_sys_path_index(_normalize_cached(os.sep.join(parts)))\n\n    new_path = sorted(orig_path, key=position_in_sys_path)\n    new_path = [_normalize_cached(p) for p in new_path]\n\n    if isinstance(module.__path__, list):\n        module.__path__[:] = new_path\n    else:\n        module.__path__ = new_path\n\n\ndef declare_namespace(packageName: str):\n    \"\"\"Declare that package 'packageName' is a namespace package\"\"\"\n\n    msg = (\n        f\"Deprecated call to `pkg_resources.declare_namespace({packageName!r})`.\\n\"\n        \"Implementing implicit namespace packages (as specified in PEP 420) \"\n        \"is preferred to `pkg_resources.declare_namespace`. \"\n        \"See https://setuptools.pypa.io/en/latest/references/\"\n        \"keywords.html#keyword-namespace-packages\"\n    )\n    warnings.warn(msg, DeprecationWarning, stacklevel=2)\n\n    _imp.acquire_lock()\n    try:\n        if packageName in _namespace_packages:\n            return\n\n        path: MutableSequence[str] = sys.path\n        parent, _, _ = packageName.rpartition('.')\n\n        if parent:\n            declare_namespace(parent)\n            if parent not in _namespace_packages:\n                __import__(parent)\n            try:\n                path = sys.modules[parent].__path__\n            except AttributeError as e:\n                raise TypeError(\"Not a package:\", parent) from e\n\n        # Track what packages are namespaces, so when new path items are added,\n        # they can be updated\n        _namespace_packages.setdefault(parent or None, []).append(packageName)\n        _namespace_packages.setdefault(packageName, [])\n\n        for path_item in path:\n            # Ensure all the parent's path items are reflected in the child,\n            # if they apply\n            _handle_ns(packageName, path_item)\n\n    finally:\n        _imp.release_lock()\n\n\ndef fixup_namespace_packages(path_item: str, parent: str | None = None):\n    \"\"\"Ensure that previously-declared namespace packages include path_item\"\"\"\n    _imp.acquire_lock()\n    try:\n        for package in _namespace_packages.get(parent, ()):\n            subpath = _handle_ns(package, path_item)\n            if subpath:\n                fixup_namespace_packages(subpath, package)\n    finally:\n        _imp.release_lock()\n\n\ndef file_ns_handler(\n    importer: object,\n    path_item: StrPath,\n    packageName: str,\n    module: types.ModuleType,\n):\n    \"\"\"Compute an ns-package subpath for a filesystem or zipfile importer\"\"\"\n\n    subpath = os.path.join(path_item, packageName.split('.')[-1])\n    normalized = _normalize_cached(subpath)\n    for item in module.__path__:\n        if _normalize_cached(item) == normalized:\n            break\n    else:\n        # Only return the path if it's not already there\n        return subpath\n\n\nif hasattr(pkgutil, 'ImpImporter'):\n    register_namespace_handler(pkgutil.ImpImporter, file_ns_handler)\n\nregister_namespace_handler(zipimport.zipimporter, file_ns_handler)\nregister_namespace_handler(importlib.machinery.FileFinder, file_ns_handler)\n\n\ndef null_ns_handler(\n    importer: object,\n    path_item: str | None,\n    packageName: str | None,\n    module: _ModuleLike | None,\n):\n    return None\n\n\nregister_namespace_handler(object, null_ns_handler)\n\n\n@overload\ndef normalize_path(filename: StrPath) -> str: ...\n@overload\ndef normalize_path(filename: BytesPath) -> bytes: ...\ndef normalize_path(filename: StrOrBytesPath):\n    \"\"\"Normalize a file/dir name for comparison purposes\"\"\"\n    return os.path.normcase(os.path.realpath(os.path.normpath(_cygwin_patch(filename))))\n\n\ndef _cygwin_patch(filename: StrOrBytesPath):  # pragma: nocover\n    \"\"\"\n    Contrary to POSIX 2008, on Cygwin, getcwd (3) contains\n    symlink components. Using\n    os.path.abspath() works around this limitation. A fix in os.getcwd()\n    would probably better, in Cygwin even more so, except\n    that this seems to be by design...\n    \"\"\"\n    return os.path.abspath(filename) if sys.platform == 'cygwin' else filename\n\n\nif TYPE_CHECKING:\n    # https://github.com/python/mypy/issues/16261\n    # https://github.com/python/typeshed/issues/6347\n    @overload\n    def _normalize_cached(filename: StrPath) -> str: ...\n    @overload\n    def _normalize_cached(filename: BytesPath) -> bytes: ...\n    def _normalize_cached(filename: StrOrBytesPath) -> str | bytes: ...\nelse:\n\n    @functools.lru_cache(maxsize=None)\n    def _normalize_cached(filename):\n        return normalize_path(filename)\n\n\ndef _is_egg_path(path):\n    \"\"\"\n    Determine if given path appears to be an egg.\n    \"\"\"\n    return _is_zip_egg(path) or _is_unpacked_egg(path)\n\n\ndef _is_zip_egg(path):\n    return (\n        path.lower().endswith('.egg')\n        and os.path.isfile(path)\n        and zipfile.is_zipfile(path)\n    )\n\n\ndef _is_unpacked_egg(path):\n    \"\"\"\n    Determine if given path appears to be an unpacked egg.\n    \"\"\"\n    return path.lower().endswith('.egg') and os.path.isfile(\n        os.path.join(path, 'EGG-INFO', 'PKG-INFO')\n    )\n\n\ndef _set_parent_ns(packageName):\n    parts = packageName.split('.')\n    name = parts.pop()\n    if parts:\n        parent = '.'.join(parts)\n        setattr(sys.modules[parent], name, sys.modules[packageName])\n\n\nMODULE = re.compile(r\"\\w+(\\.\\w+)*$\").match\nEGG_NAME = re.compile(\n    r\"\"\"\n    (?P<name>[^-]+) (\n        -(?P<ver>[^-]+) (\n            -py(?P<pyver>[^-]+) (\n                -(?P<plat>.+)\n            )?\n        )?\n    )?\n    \"\"\",\n    re.VERBOSE | re.IGNORECASE,\n).match\n\n\nclass EntryPoint:\n    \"\"\"Object representing an advertised importable object\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        module_name: str,\n        attrs: Iterable[str] = (),\n        extras: Iterable[str] = (),\n        dist: Distribution | None = None,\n    ):\n        if not MODULE(module_name):\n            raise ValueError(\"Invalid module name\", module_name)\n        self.name = name\n        self.module_name = module_name\n        self.attrs = tuple(attrs)\n        self.extras = tuple(extras)\n        self.dist = dist\n\n    def __str__(self):\n        s = \"%s = %s\" % (self.name, self.module_name)\n        if self.attrs:\n            s += ':' + '.'.join(self.attrs)\n        if self.extras:\n            s += ' [%s]' % ','.join(self.extras)\n        return s\n\n    def __repr__(self):\n        return \"EntryPoint.parse(%r)\" % str(self)\n\n    @overload\n    def load(\n        self,\n        require: Literal[True] = True,\n        env: Environment | None = None,\n        installer: _InstallerType | None = None,\n    ) -> _ResolvedEntryPoint: ...\n    @overload\n    def load(\n        self,\n        require: Literal[False],\n        *args: Any,\n        **kwargs: Any,\n    ) -> _ResolvedEntryPoint: ...\n    def load(\n        self,\n        require: bool = True,\n        *args: Environment | _InstallerType | None,\n        **kwargs: Environment | _InstallerType | None,\n    ) -> _ResolvedEntryPoint:\n        \"\"\"\n        Require packages for this EntryPoint, then resolve it.\n        \"\"\"\n        if not require or args or kwargs:\n            warnings.warn(\n                \"Parameters to load are deprecated.  Call .resolve and \"\n                \".require separately.\",\n                PkgResourcesDeprecationWarning,\n                stacklevel=2,\n            )\n        if require:\n            # We could pass `env` and `installer` directly,\n            # but keeping `*args` and `**kwargs` for backwards compatibility\n            self.require(*args, **kwargs)  # type: ignore\n        return self.resolve()\n\n    def resolve(self) -> _ResolvedEntryPoint:\n        \"\"\"\n        Resolve the entry point from its module and attrs.\n        \"\"\"\n        module = __import__(self.module_name, fromlist=['__name__'], level=0)\n        try:\n            return functools.reduce(getattr, self.attrs, module)\n        except AttributeError as exc:\n            raise ImportError(str(exc)) from exc\n\n    def require(\n        self,\n        env: Environment | None = None,\n        installer: _InstallerType | None = None,\n    ):\n        if not self.dist:\n            error_cls = UnknownExtra if self.extras else AttributeError\n            raise error_cls(\"Can't require() without a distribution\", self)\n\n        # Get the requirements for this entry point with all its extras and\n        # then resolve them. We have to pass `extras` along when resolving so\n        # that the working set knows what extras we want. Otherwise, for\n        # dist-info distributions, the working set will assume that the\n        # requirements for that extra are purely optional and skip over them.\n        reqs = self.dist.requires(self.extras)\n        items = working_set.resolve(reqs, env, installer, extras=self.extras)\n        list(map(working_set.add, items))\n\n    pattern = re.compile(\n        r'\\s*'\n        r'(?P<name>.+?)\\s*'\n        r'=\\s*'\n        r'(?P<module>[\\w.]+)\\s*'\n        r'(:\\s*(?P<attr>[\\w.]+))?\\s*'\n        r'(?P<extras>\\[.*\\])?\\s*$'\n    )\n\n    @classmethod\n    def parse(cls, src: str, dist: Distribution | None = None):\n        \"\"\"Parse a single entry point from string `src`\n\n        Entry point syntax follows the form::\n\n            name = some.module:some.attr [extra1, extra2]\n\n        The entry name and module name are required, but the ``:attrs`` and\n        ``[extras]`` parts are optional\n        \"\"\"\n        m = cls.pattern.match(src)\n        if not m:\n            msg = \"EntryPoint must be in 'name=module:attrs [extras]' format\"\n            raise ValueError(msg, src)\n        res = m.groupdict()\n        extras = cls._parse_extras(res['extras'])\n        attrs = res['attr'].split('.') if res['attr'] else ()\n        return cls(res['name'], res['module'], attrs, extras, dist)\n\n    @classmethod\n    def _parse_extras(cls, extras_spec):\n        if not extras_spec:\n            return ()\n        req = Requirement.parse('x' + extras_spec)\n        if req.specs:\n            raise ValueError\n        return req.extras\n\n    @classmethod\n    def parse_group(\n        cls,\n        group: str,\n        lines: _NestedStr,\n        dist: Distribution | None = None,\n    ):\n        \"\"\"Parse an entry point group\"\"\"\n        if not MODULE(group):\n            raise ValueError(\"Invalid group name\", group)\n        this: dict[str, Self] = {}\n        for line in yield_lines(lines):\n            ep = cls.parse(line, dist)\n            if ep.name in this:\n                raise ValueError(\"Duplicate entry point\", group, ep.name)\n            this[ep.name] = ep\n        return this\n\n    @classmethod\n    def parse_map(\n        cls,\n        data: str | Iterable[str] | dict[str, str | Iterable[str]],\n        dist: Distribution | None = None,\n    ):\n        \"\"\"Parse a map of entry point groups\"\"\"\n        _data: Iterable[tuple[str | None, str | Iterable[str]]]\n        if isinstance(data, dict):\n            _data = data.items()\n        else:\n            _data = split_sections(data)\n        maps: dict[str, dict[str, Self]] = {}\n        for group, lines in _data:\n            if group is None:\n                if not lines:\n                    continue\n                raise ValueError(\"Entry points must be listed in groups\")\n            group = group.strip()\n            if group in maps:\n                raise ValueError(\"Duplicate group name\", group)\n            maps[group] = cls.parse_group(group, lines, dist)\n        return maps\n\n\ndef _version_from_file(lines):\n    \"\"\"\n    Given an iterable of lines from a Metadata file, return\n    the value of the Version field, if present, or None otherwise.\n    \"\"\"\n\n    def is_version_line(line):\n        return line.lower().startswith('version:')\n\n    version_lines = filter(is_version_line, lines)\n    line = next(iter(version_lines), '')\n    _, _, value = line.partition(':')\n    return safe_version(value.strip()) or None\n\n\nclass Distribution:\n    \"\"\"Wrap an actual or potential sys.path entry w/metadata\"\"\"\n\n    PKG_INFO = 'PKG-INFO'\n\n    def __init__(\n        self,\n        location: str | None = None,\n        metadata: _MetadataType = None,\n        project_name: str | None = None,\n        version: str | None = None,\n        py_version: str | None = PY_MAJOR,\n        platform: str | None = None,\n        precedence: int = EGG_DIST,\n    ):\n        self.project_name = safe_name(project_name or 'Unknown')\n        if version is not None:\n            self._version = safe_version(version)\n        self.py_version = py_version\n        self.platform = platform\n        self.location = location\n        self.precedence = precedence\n        self._provider = metadata or empty_provider\n\n    @classmethod\n    def from_location(\n        cls,\n        location: str,\n        basename: StrPath,\n        metadata: _MetadataType = None,\n        **kw: int,  # We could set `precedence` explicitly, but keeping this as `**kw` for full backwards and subclassing compatibility\n    ) -> Distribution:\n        project_name, version, py_version, platform = [None] * 4\n        basename, ext = os.path.splitext(basename)\n        if ext.lower() in _distributionImpl:\n            cls = _distributionImpl[ext.lower()]\n\n            match = EGG_NAME(basename)\n            if match:\n                project_name, version, py_version, platform = match.group(\n                    'name', 'ver', 'pyver', 'plat'\n                )\n        return cls(\n            location,\n            metadata,\n            project_name=project_name,\n            version=version,\n            py_version=py_version,\n            platform=platform,\n            **kw,\n        )._reload_version()\n\n    def _reload_version(self):\n        return self\n\n    @property\n    def hashcmp(self):\n        return (\n            self._forgiving_parsed_version,\n            self.precedence,\n            self.key,\n            self.location,\n            self.py_version or '',\n            self.platform or '',\n        )\n\n    def __hash__(self):\n        return hash(self.hashcmp)\n\n    def __lt__(self, other: Distribution):\n        return self.hashcmp < other.hashcmp\n\n    def __le__(self, other: Distribution):\n        return self.hashcmp <= other.hashcmp\n\n    def __gt__(self, other: Distribution):\n        return self.hashcmp > other.hashcmp\n\n    def __ge__(self, other: Distribution):\n        return self.hashcmp >= other.hashcmp\n\n    def __eq__(self, other: object):\n        if not isinstance(other, self.__class__):\n            # It's not a Distribution, so they are not equal\n            return False\n        return self.hashcmp == other.hashcmp\n\n    def __ne__(self, other: object):\n        return not self == other\n\n    # These properties have to be lazy so that we don't have to load any\n    # metadata until/unless it's actually needed.  (i.e., some distributions\n    # may not know their name or version without loading PKG-INFO)\n\n    @property\n    def key(self):\n        try:\n            return self._key\n        except AttributeError:\n            self._key = key = self.project_name.lower()\n            return key\n\n    @property\n    def parsed_version(self):\n        if not hasattr(self, \"_parsed_version\"):\n            try:\n                self._parsed_version = parse_version(self.version)\n            except _packaging_version.InvalidVersion as ex:\n                info = f\"(package: {self.project_name})\"\n                if hasattr(ex, \"add_note\"):\n                    ex.add_note(info)  # PEP 678\n                    raise\n                raise _packaging_version.InvalidVersion(f\"{str(ex)} {info}\") from None\n\n        return self._parsed_version\n\n    @property\n    def _forgiving_parsed_version(self):\n        try:\n            return self.parsed_version\n        except _packaging_version.InvalidVersion as ex:\n            self._parsed_version = parse_version(_forgiving_version(self.version))\n\n            notes = \"\\n\".join(getattr(ex, \"__notes__\", []))  # PEP 678\n            msg = f\"\"\"!!\\n\\n\n            *************************************************************************\n            {str(ex)}\\n{notes}\n\n            This is a long overdue deprecation.\n            For the time being, `pkg_resources` will use `{self._parsed_version}`\n            as a replacement to avoid breaking existing environments,\n            but no future compatibility is guaranteed.\n\n            If you maintain package {self.project_name} you should implement\n            the relevant changes to adequate the project to PEP 440 immediately.\n            *************************************************************************\n            \\n\\n!!\n            \"\"\"\n            warnings.warn(msg, DeprecationWarning)\n\n            return self._parsed_version\n\n    @property\n    def version(self):\n        try:\n            return self._version\n        except AttributeError as e:\n            version = self._get_version()\n            if version is None:\n                path = self._get_metadata_path_for_display(self.PKG_INFO)\n                msg = (\"Missing 'Version:' header and/or {} file at path: {}\").format(\n                    self.PKG_INFO, path\n                )\n                raise ValueError(msg, self) from e\n\n            return version\n\n    @property\n    def _dep_map(self):\n        \"\"\"\n        A map of extra to its list of (direct) requirements\n        for this distribution, including the null extra.\n        \"\"\"\n        try:\n            return self.__dep_map\n        except AttributeError:\n            self.__dep_map = self._filter_extras(self._build_dep_map())\n        return self.__dep_map\n\n    @staticmethod\n    def _filter_extras(dm: dict[str | None, list[Requirement]]):\n        \"\"\"\n        Given a mapping of extras to dependencies, strip off\n        environment markers and filter out any dependencies\n        not matching the markers.\n        \"\"\"\n        for extra in list(filter(None, dm)):\n            new_extra: str | None = extra\n            reqs = dm.pop(extra)\n            new_extra, _, marker = extra.partition(':')\n            fails_marker = marker and (\n                invalid_marker(marker) or not evaluate_marker(marker)\n            )\n            if fails_marker:\n                reqs = []\n            new_extra = safe_extra(new_extra) or None\n\n            dm.setdefault(new_extra, []).extend(reqs)\n        return dm\n\n    def _build_dep_map(self):\n        dm = {}\n        for name in 'requires.txt', 'depends.txt':\n            for extra, reqs in split_sections(self._get_metadata(name)):\n                dm.setdefault(extra, []).extend(parse_requirements(reqs))\n        return dm\n\n    def requires(self, extras: Iterable[str] = ()):\n        \"\"\"List of Requirements needed for this distro if `extras` are used\"\"\"\n        dm = self._dep_map\n        deps: list[Requirement] = []\n        deps.extend(dm.get(None, ()))\n        for ext in extras:\n            try:\n                deps.extend(dm[safe_extra(ext)])\n            except KeyError as e:\n                raise UnknownExtra(\n                    \"%s has no such extra feature %r\" % (self, ext)\n                ) from e\n        return deps\n\n    def _get_metadata_path_for_display(self, name):\n        \"\"\"\n        Return the path to the given metadata file, if available.\n        \"\"\"\n        try:\n            # We need to access _get_metadata_path() on the provider object\n            # directly rather than through this class's __getattr__()\n            # since _get_metadata_path() is marked private.\n            path = self._provider._get_metadata_path(name)\n\n        # Handle exceptions e.g. in case the distribution's metadata\n        # provider doesn't support _get_metadata_path().\n        except Exception:\n            return '[could not detect]'\n\n        return path\n\n    def _get_metadata(self, name):\n        if self.has_metadata(name):\n            yield from self.get_metadata_lines(name)\n\n    def _get_version(self):\n        lines = self._get_metadata(self.PKG_INFO)\n        return _version_from_file(lines)\n\n    def activate(self, path: list[str] | None = None, replace: bool = False):\n        \"\"\"Ensure distribution is importable on `path` (default=sys.path)\"\"\"\n        if path is None:\n            path = sys.path\n        self.insert_on(path, replace=replace)\n        if path is sys.path and self.location is not None:\n            fixup_namespace_packages(self.location)\n            for pkg in self._get_metadata('namespace_packages.txt'):\n                if pkg in sys.modules:\n                    declare_namespace(pkg)\n\n    def egg_name(self):\n        \"\"\"Return what this distribution's standard .egg filename should be\"\"\"\n        filename = \"%s-%s-py%s\" % (\n            to_filename(self.project_name),\n            to_filename(self.version),\n            self.py_version or PY_MAJOR,\n        )\n\n        if self.platform:\n            filename += '-' + self.platform\n        return filename\n\n    def __repr__(self):\n        if self.location:\n            return \"%s (%s)\" % (self, self.location)\n        else:\n            return str(self)\n\n    def __str__(self):\n        try:\n            version = getattr(self, 'version', None)\n        except ValueError:\n            version = None\n        version = version or \"[unknown version]\"\n        return \"%s %s\" % (self.project_name, version)\n\n    def __getattr__(self, attr):\n        \"\"\"Delegate all unrecognized public attributes to .metadata provider\"\"\"\n        if attr.startswith('_'):\n            raise AttributeError(attr)\n        return getattr(self._provider, attr)\n\n    def __dir__(self):\n        return list(\n            set(super().__dir__())\n            | set(attr for attr in self._provider.__dir__() if not attr.startswith('_'))\n        )\n\n    @classmethod\n    def from_filename(\n        cls,\n        filename: StrPath,\n        metadata: _MetadataType = None,\n        **kw: int,  # We could set `precedence` explicitly, but keeping this as `**kw` for full backwards and subclassing compatibility\n    ):\n        return cls.from_location(\n            _normalize_cached(filename), os.path.basename(filename), metadata, **kw\n        )\n\n    def as_requirement(self):\n        \"\"\"Return a ``Requirement`` that matches this distribution exactly\"\"\"\n        if isinstance(self.parsed_version, _packaging_version.Version):\n            spec = \"%s==%s\" % (self.project_name, self.parsed_version)\n        else:\n            spec = \"%s===%s\" % (self.project_name, self.parsed_version)\n\n        return Requirement.parse(spec)\n\n    def load_entry_point(self, group: str, name: str) -> _ResolvedEntryPoint:\n        \"\"\"Return the `name` entry point of `group` or raise ImportError\"\"\"\n        ep = self.get_entry_info(group, name)\n        if ep is None:\n            raise ImportError(\"Entry point %r not found\" % ((group, name),))\n        return ep.load()\n\n    @overload\n    def get_entry_map(self, group: None = None) -> dict[str, dict[str, EntryPoint]]: ...\n    @overload\n    def get_entry_map(self, group: str) -> dict[str, EntryPoint]: ...\n    def get_entry_map(self, group: str | None = None):\n        \"\"\"Return the entry point map for `group`, or the full entry map\"\"\"\n        if not hasattr(self, \"_ep_map\"):\n            self._ep_map = EntryPoint.parse_map(\n                self._get_metadata('entry_points.txt'), self\n            )\n        if group is not None:\n            return self._ep_map.get(group, {})\n        return self._ep_map\n\n    def get_entry_info(self, group: str, name: str):\n        \"\"\"Return the EntryPoint object for `group`+`name`, or ``None``\"\"\"\n        return self.get_entry_map(group).get(name)\n\n    # FIXME: 'Distribution.insert_on' is too complex (13)\n    def insert_on(  # noqa: C901\n        self,\n        path: list[str],\n        loc=None,\n        replace: bool = False,\n    ):\n        \"\"\"Ensure self.location is on path\n\n        If replace=False (default):\n            - If location is already in path anywhere, do nothing.\n            - Else:\n              - If it's an egg and its parent directory is on path,\n                insert just ahead of the parent.\n              - Else: add to the end of path.\n        If replace=True:\n            - If location is already on path anywhere (not eggs)\n              or higher priority than its parent (eggs)\n              do nothing.\n            - Else:\n              - If it's an egg and its parent directory is on path,\n                insert just ahead of the parent,\n                removing any lower-priority entries.\n              - Else: add it to the front of path.\n        \"\"\"\n\n        loc = loc or self.location\n        if not loc:\n            return\n\n        nloc = _normalize_cached(loc)\n        bdir = os.path.dirname(nloc)\n        npath = [(p and _normalize_cached(p) or p) for p in path]\n\n        for p, item in enumerate(npath):\n            if item == nloc:\n                if replace:\n                    break\n                else:\n                    # don't modify path (even removing duplicates) if\n                    # found and not replace\n                    return\n            elif item == bdir and self.precedence == EGG_DIST:\n                # if it's an .egg, give it precedence over its directory\n                # UNLESS it's already been added to sys.path and replace=False\n                if (not replace) and nloc in npath[p:]:\n                    return\n                if path is sys.path:\n                    self.check_version_conflict()\n                path.insert(p, loc)\n                npath.insert(p, nloc)\n                break\n        else:\n            if path is sys.path:\n                self.check_version_conflict()\n            if replace:\n                path.insert(0, loc)\n            else:\n                path.append(loc)\n            return\n\n        # p is the spot where we found or inserted loc; now remove duplicates\n        while True:\n            try:\n                np = npath.index(nloc, p + 1)\n            except ValueError:\n                break\n            else:\n                del npath[np], path[np]\n                # ha!\n                p = np\n\n        return\n\n    def check_version_conflict(self):\n        if self.key == 'setuptools':\n            # ignore the inevitable setuptools self-conflicts  :(\n            return\n\n        nsp = dict.fromkeys(self._get_metadata('namespace_packages.txt'))\n        loc = normalize_path(self.location)\n        for modname in self._get_metadata('top_level.txt'):\n            if (\n                modname not in sys.modules\n                or modname in nsp\n                or modname in _namespace_packages\n            ):\n                continue\n            if modname in ('pkg_resources', 'setuptools', 'site'):\n                continue\n            fn = getattr(sys.modules[modname], '__file__', None)\n            if fn and (\n                normalize_path(fn).startswith(loc) or fn.startswith(self.location)\n            ):\n                continue\n            issue_warning(\n                \"Module %s was already imported from %s, but %s is being added\"\n                \" to sys.path\" % (modname, fn, self.location),\n            )\n\n    def has_version(self):\n        try:\n            self.version\n        except ValueError:\n            issue_warning(\"Unbuilt egg for \" + repr(self))\n            return False\n        except SystemError:\n            # TODO: remove this except clause when python/cpython#103632 is fixed.\n            return False\n        return True\n\n    def clone(self, **kw: str | int | IResourceProvider | None):\n        \"\"\"Copy this distribution, substituting in any changed keyword args\"\"\"\n        names = 'project_name version py_version platform location precedence'\n        for attr in names.split():\n            kw.setdefault(attr, getattr(self, attr, None))\n        kw.setdefault('metadata', self._provider)\n        # Unsafely unpacking. But keeping **kw for backwards and subclassing compatibility\n        return self.__class__(**kw)  # type:ignore[arg-type]\n\n    @property\n    def extras(self):\n        return [dep for dep in self._dep_map if dep]\n\n\nclass EggInfoDistribution(Distribution):\n    def _reload_version(self):\n        \"\"\"\n        Packages installed by distutils (e.g. numpy or scipy),\n        which uses an old safe_version, and so\n        their version numbers can get mangled when\n        converted to filenames (e.g., 1.11.0.dev0+2329eae to\n        1.11.0.dev0_2329eae). These distributions will not be\n        parsed properly\n        downstream by Distribution and safe_version, so\n        take an extra step and try to get the version number from\n        the metadata file itself instead of the filename.\n        \"\"\"\n        md_version = self._get_version()\n        if md_version:\n            self._version = md_version\n        return self\n\n\nclass DistInfoDistribution(Distribution):\n    \"\"\"\n    Wrap an actual or potential sys.path entry\n    w/metadata, .dist-info style.\n    \"\"\"\n\n    PKG_INFO = 'METADATA'\n    EQEQ = re.compile(r\"([\\(,])\\s*(\\d.*?)\\s*([,\\)])\")\n\n    @property\n    def _parsed_pkg_info(self):\n        \"\"\"Parse and cache metadata\"\"\"\n        try:\n            return self._pkg_info\n        except AttributeError:\n            metadata = self.get_metadata(self.PKG_INFO)\n            self._pkg_info = email.parser.Parser().parsestr(metadata)\n            return self._pkg_info\n\n    @property\n    def _dep_map(self):\n        try:\n            return self.__dep_map\n        except AttributeError:\n            self.__dep_map = self._compute_dependencies()\n            return self.__dep_map\n\n    def _compute_dependencies(self) -> dict[str | None, list[Requirement]]:\n        \"\"\"Recompute this distribution's dependencies.\"\"\"\n        self.__dep_map: dict[str | None, list[Requirement]] = {None: []}\n\n        reqs: list[Requirement] = []\n        # Including any condition expressions\n        for req in self._parsed_pkg_info.get_all('Requires-Dist') or []:\n            reqs.extend(parse_requirements(req))\n\n        def reqs_for_extra(extra):\n            for req in reqs:\n                if not req.marker or req.marker.evaluate({'extra': extra}):\n                    yield req\n\n        common = types.MappingProxyType(dict.fromkeys(reqs_for_extra(None)))\n        self.__dep_map[None].extend(common)\n\n        for extra in self._parsed_pkg_info.get_all('Provides-Extra') or []:\n            s_extra = safe_extra(extra.strip())\n            self.__dep_map[s_extra] = [\n                r for r in reqs_for_extra(extra) if r not in common\n            ]\n\n        return self.__dep_map\n\n\n_distributionImpl = {\n    '.egg': Distribution,\n    '.egg-info': EggInfoDistribution,\n    '.dist-info': DistInfoDistribution,\n}\n\n\ndef issue_warning(*args, **kw):\n    level = 1\n    g = globals()\n    try:\n        # find the first stack frame that is *not* code in\n        # the pkg_resources module, to use for the warning\n        while sys._getframe(level).f_globals is g:\n            level += 1\n    except ValueError:\n        pass\n    warnings.warn(stacklevel=level + 1, *args, **kw)\n\n\ndef parse_requirements(strs: _NestedStr):\n    \"\"\"\n    Yield ``Requirement`` objects for each specification in `strs`.\n\n    `strs` must be a string, or a (possibly-nested) iterable thereof.\n    \"\"\"\n    return map(Requirement, join_continuation(map(drop_comment, yield_lines(strs))))\n\n\nclass RequirementParseError(_packaging_requirements.InvalidRequirement):\n    \"Compatibility wrapper for InvalidRequirement\"\n\n\nclass Requirement(_packaging_requirements.Requirement):\n    def __init__(self, requirement_string: str):\n        \"\"\"DO NOT CALL THIS UNDOCUMENTED METHOD; use Requirement.parse()!\"\"\"\n        super().__init__(requirement_string)\n        self.unsafe_name = self.name\n        project_name = safe_name(self.name)\n        self.project_name, self.key = project_name, project_name.lower()\n        self.specs = [(spec.operator, spec.version) for spec in self.specifier]\n        # packaging.requirements.Requirement uses a set for its extras. We use a variable-length tuple\n        self.extras: tuple[str] = tuple(map(safe_extra, self.extras))\n        self.hashCmp = (\n            self.key,\n            self.url,\n            self.specifier,\n            frozenset(self.extras),\n            str(self.marker) if self.marker else None,\n        )\n        self.__hash = hash(self.hashCmp)\n\n    def __eq__(self, other: object):\n        return isinstance(other, Requirement) and self.hashCmp == other.hashCmp\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __contains__(self, item: Distribution | str | tuple[str, ...]) -> bool:\n        if isinstance(item, Distribution):\n            if item.key != self.key:\n                return False\n\n            item = item.version\n\n        # Allow prereleases always in order to match the previous behavior of\n        # this method. In the future this should be smarter and follow PEP 440\n        # more accurately.\n        return self.specifier.contains(item, prereleases=True)\n\n    def __hash__(self):\n        return self.__hash\n\n    def __repr__(self):\n        return \"Requirement.parse(%r)\" % str(self)\n\n    @staticmethod\n    def parse(s: str | Iterable[str]):\n        (req,) = parse_requirements(s)\n        return req\n\n\ndef _always_object(classes):\n    \"\"\"\n    Ensure object appears in the mro even\n    for old-style classes.\n    \"\"\"\n    if object not in classes:\n        return classes + (object,)\n    return classes\n\n\ndef _find_adapter(registry: Mapping[type, _AdapterT], ob: object) -> _AdapterT:\n    \"\"\"Return an adapter factory for `ob` from `registry`\"\"\"\n    types = _always_object(inspect.getmro(getattr(ob, '__class__', type(ob))))\n    for t in types:\n        if t in registry:\n            return registry[t]\n    # _find_adapter would previously return None, and immediately be called.\n    # So we're raising a TypeError to keep backward compatibility if anyone depended on that behaviour.\n    raise TypeError(f\"Could not find adapter for {registry} and {ob}\")\n\n\ndef ensure_directory(path: StrOrBytesPath):\n    \"\"\"Ensure that the parent directory of `path` exists\"\"\"\n    dirname = os.path.dirname(path)\n    os.makedirs(dirname, exist_ok=True)\n\n\ndef _bypass_ensure_directory(path):\n    \"\"\"Sandbox-bypassing version of ensure_directory()\"\"\"\n    if not WRITE_SUPPORT:\n        raise OSError('\"os.mkdir\" not supported on this platform.')\n    dirname, filename = split(path)\n    if dirname and filename and not isdir(dirname):\n        _bypass_ensure_directory(dirname)\n        try:\n            mkdir(dirname, 0o755)\n        except FileExistsError:\n            pass\n\n\ndef split_sections(s: _NestedStr) -> Iterator[tuple[str | None, list[str]]]:\n    \"\"\"Split a string or iterable thereof into (section, content) pairs\n\n    Each ``section`` is a stripped version of the section header (\"[section]\")\n    and each ``content`` is a list of stripped lines excluding blank lines and\n    comment-only lines.  If there are any such lines before the first section\n    header, they're returned in a first ``section`` of ``None``.\n    \"\"\"\n    section = None\n    content = []\n    for line in yield_lines(s):\n        if line.startswith(\"[\"):\n            if line.endswith(\"]\"):\n                if section or content:\n                    yield section, content\n                section = line[1:-1].strip()\n                content = []\n            else:\n                raise ValueError(\"Invalid section heading\", line)\n        else:\n            content.append(line)\n\n    # wrap up last segment\n    yield section, content\n\n\ndef _mkstemp(*args, **kw):\n    old_open = os.open\n    try:\n        # temporarily bypass sandboxing\n        os.open = os_open\n        return tempfile.mkstemp(*args, **kw)\n    finally:\n        # and then put it back\n        os.open = old_open\n\n\n# Silence the PEP440Warning by default, so that end users don't get hit by it\n# randomly just because they use pkg_resources. We want to append the rule\n# because we want earlier uses of filterwarnings to take precedence over this\n# one.\nwarnings.filterwarnings(\"ignore\", category=PEP440Warning, append=True)\n\n\nclass PkgResourcesDeprecationWarning(Warning):\n    \"\"\"\n    Base class for warning about deprecations in ``pkg_resources``\n\n    This class is not derived from ``DeprecationWarning``, and as such is\n    visible by default.\n    \"\"\"\n\n\n# Ported from ``setuptools`` to avoid introducing an import inter-dependency:\n_LOCALE_ENCODING = \"locale\" if sys.version_info >= (3, 10) else None\n\n\ndef _read_utf8_with_fallback(file: str, fallback_encoding=_LOCALE_ENCODING) -> str:\n    \"\"\"See setuptools.unicode_utils._read_utf8_with_fallback\"\"\"\n    try:\n        with open(file, \"r\", encoding=\"utf-8\") as f:\n            return f.read()\n    except UnicodeDecodeError:  # pragma: no cover\n        msg = f\"\"\"\\\n        ********************************************************************************\n        `encoding=\"utf-8\"` fails with {file!r}, trying `encoding={fallback_encoding!r}`.\n\n        This fallback behaviour is considered **deprecated** and future versions of\n        `setuptools/pkg_resources` may not implement it.\n\n        Please encode {file!r} with \"utf-8\" to ensure future builds will succeed.\n\n        If this file was produced by `setuptools` itself, cleaning up the cached files\n        and re-building/re-installing the package with a newer version of `setuptools`\n        (e.g. by updating `build-system.requires` in its `pyproject.toml`)\n        might solve the problem.\n        ********************************************************************************\n        \"\"\"\n        # TODO: Add a deadline?\n        #       See comment in setuptools.unicode_utils._Utf8EncodingNeeded\n        warnings.warn(msg, PkgResourcesDeprecationWarning, stacklevel=2)\n        with open(file, \"r\", encoding=fallback_encoding) as f:\n            return f.read()\n\n\n# from jaraco.functools 1.3\ndef _call_aside(f, *args, **kwargs):\n    f(*args, **kwargs)\n    return f\n\n\n@_call_aside\ndef _initialize(g=globals()):\n    \"Set up global resource manager (deliberately not state-saved)\"\n    manager = ResourceManager()\n    g['_manager'] = manager\n    g.update(\n        (name, getattr(manager, name))\n        for name in dir(manager)\n        if not name.startswith('_')\n    )\n\n\n@_call_aside\ndef _initialize_master_working_set():\n    \"\"\"\n    Prepare the master working set and make the ``require()``\n    API available.\n\n    This function has explicit effects on the global state\n    of pkg_resources. It is intended to be invoked once at\n    the initialization of this module.\n\n    Invocation by other packages is unsupported and done\n    at their own risk.\n    \"\"\"\n    working_set = _declare_state('object', 'working_set', WorkingSet._build_master())\n\n    require = working_set.require\n    iter_entry_points = working_set.iter_entry_points\n    add_activation_listener = working_set.subscribe\n    run_script = working_set.run_script\n    # backward compatibility\n    run_main = run_script\n    # Activate all distributions already on sys.path with replace=False and\n    # ensure that all distributions added to the working set in the future\n    # (e.g. by calling ``require()``) will get activated as well,\n    # with higher priority (replace=True).\n    tuple(dist.activate(replace=False) for dist in working_set)\n    add_activation_listener(\n        lambda dist: dist.activate(replace=True),\n        existing=False,\n    )\n    working_set.entries = []\n    # match order\n    list(map(working_set.add_entry, sys.path))\n    globals().update(locals())\n\n\nif TYPE_CHECKING:\n    # All of these are set by the @_call_aside methods above\n    __resource_manager = ResourceManager()  # Won't exist at runtime\n    resource_exists = __resource_manager.resource_exists\n    resource_isdir = __resource_manager.resource_isdir\n    resource_filename = __resource_manager.resource_filename\n    resource_stream = __resource_manager.resource_stream\n    resource_string = __resource_manager.resource_string\n    resource_listdir = __resource_manager.resource_listdir\n    set_extraction_path = __resource_manager.set_extraction_path\n    cleanup_resources = __resource_manager.cleanup_resources\n\n    working_set = WorkingSet()\n    require = working_set.require\n    iter_entry_points = working_set.iter_entry_points\n    add_activation_listener = working_set.subscribe\n    run_script = working_set.run_script\n    run_main = run_script\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/platformdirs/__init__.py","size":22344,"sha1":"dec3b1bad50bb11b9a72d163c3f86420f3a083da","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nUtilities for determining application-specific dirs.\n\nSee <https://github.com/platformdirs/platformdirs> for details and usage.\n\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport sys\nfrom typing import TYPE_CHECKING\n\nfrom .api import PlatformDirsABC\nfrom .version import __version__\nfrom .version import __version_tuple__ as __version_info__\n\nif TYPE_CHECKING:\n    from pathlib import Path\n    from typing import Literal\n\nif sys.platform == \"win32\":\n    from pip._vendor.platformdirs.windows import Windows as _Result\nelif sys.platform == \"darwin\":\n    from pip._vendor.platformdirs.macos import MacOS as _Result\nelse:\n    from pip._vendor.platformdirs.unix import Unix as _Result\n\n\ndef _set_platform_dir_class() -> type[PlatformDirsABC]:\n    if os.getenv(\"ANDROID_DATA\") == \"/data\" and os.getenv(\"ANDROID_ROOT\") == \"/system\":\n        if os.getenv(\"SHELL\") or os.getenv(\"PREFIX\"):\n            return _Result\n\n        from pip._vendor.platformdirs.android import _android_folder  # noqa: PLC0415\n\n        if _android_folder() is not None:\n            from pip._vendor.platformdirs.android import Android  # noqa: PLC0415\n\n            return Android  # return to avoid redefinition of a result\n\n    return _Result\n\n\nif TYPE_CHECKING:\n    # Work around mypy issue: https://github.com/python/mypy/issues/10962\n    PlatformDirs = _Result\nelse:\n    PlatformDirs = _set_platform_dir_class()  #: Currently active platform\nAppDirs = PlatformDirs  #: Backwards compatibility with appdirs\n\n\ndef user_data_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: data directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        roaming=roaming,\n        ensure_exists=ensure_exists,\n    ).user_data_dir\n\n\ndef site_data_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    multipath: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param multipath: See `roaming <platformdirs.api.PlatformDirsABC.multipath>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: data directory shared by users\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        multipath=multipath,\n        ensure_exists=ensure_exists,\n    ).site_data_dir\n\n\ndef user_config_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: config directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        roaming=roaming,\n        ensure_exists=ensure_exists,\n    ).user_config_dir\n\n\ndef site_config_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    multipath: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param multipath: See `roaming <platformdirs.api.PlatformDirsABC.multipath>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: config directory shared by the users\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        multipath=multipath,\n        ensure_exists=ensure_exists,\n    ).site_config_dir\n\n\ndef user_cache_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `roaming <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: cache directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).user_cache_dir\n\n\ndef site_cache_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: cache directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).site_cache_dir\n\n\ndef user_state_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: state directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        roaming=roaming,\n        ensure_exists=ensure_exists,\n    ).user_state_dir\n\n\ndef user_log_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `roaming <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: log directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).user_log_dir\n\n\ndef user_documents_dir() -> str:\n    \"\"\":returns: documents directory tied to the user\"\"\"\n    return PlatformDirs().user_documents_dir\n\n\ndef user_downloads_dir() -> str:\n    \"\"\":returns: downloads directory tied to the user\"\"\"\n    return PlatformDirs().user_downloads_dir\n\n\ndef user_pictures_dir() -> str:\n    \"\"\":returns: pictures directory tied to the user\"\"\"\n    return PlatformDirs().user_pictures_dir\n\n\ndef user_videos_dir() -> str:\n    \"\"\":returns: videos directory tied to the user\"\"\"\n    return PlatformDirs().user_videos_dir\n\n\ndef user_music_dir() -> str:\n    \"\"\":returns: music directory tied to the user\"\"\"\n    return PlatformDirs().user_music_dir\n\n\ndef user_desktop_dir() -> str:\n    \"\"\":returns: desktop directory tied to the user\"\"\"\n    return PlatformDirs().user_desktop_dir\n\n\ndef user_runtime_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: runtime directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).user_runtime_dir\n\n\ndef site_runtime_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: runtime directory shared by users\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).site_runtime_dir\n\n\ndef user_data_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: data path tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        roaming=roaming,\n        ensure_exists=ensure_exists,\n    ).user_data_path\n\n\ndef site_data_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    multipath: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param multipath: See `multipath <platformdirs.api.PlatformDirsABC.multipath>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: data path shared by users\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        multipath=multipath,\n        ensure_exists=ensure_exists,\n    ).site_data_path\n\n\ndef user_config_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: config path tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        roaming=roaming,\n        ensure_exists=ensure_exists,\n    ).user_config_path\n\n\ndef site_config_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    multipath: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param multipath: See `roaming <platformdirs.api.PlatformDirsABC.multipath>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: config path shared by the users\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        multipath=multipath,\n        ensure_exists=ensure_exists,\n    ).site_config_path\n\n\ndef site_cache_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: cache directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).site_cache_path\n\n\ndef user_cache_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `roaming <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: cache path tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).user_cache_path\n\n\ndef user_state_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: state path tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        roaming=roaming,\n        ensure_exists=ensure_exists,\n    ).user_state_path\n\n\ndef user_log_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `roaming <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: log path tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).user_log_path\n\n\ndef user_documents_path() -> Path:\n    \"\"\":returns: documents a path tied to the user\"\"\"\n    return PlatformDirs().user_documents_path\n\n\ndef user_downloads_path() -> Path:\n    \"\"\":returns: downloads path tied to the user\"\"\"\n    return PlatformDirs().user_downloads_path\n\n\ndef user_pictures_path() -> Path:\n    \"\"\":returns: pictures path tied to the user\"\"\"\n    return PlatformDirs().user_pictures_path\n\n\ndef user_videos_path() -> Path:\n    \"\"\":returns: videos path tied to the user\"\"\"\n    return PlatformDirs().user_videos_path\n\n\ndef user_music_path() -> Path:\n    \"\"\":returns: music path tied to the user\"\"\"\n    return PlatformDirs().user_music_path\n\n\ndef user_desktop_path() -> Path:\n    \"\"\":returns: desktop path tied to the user\"\"\"\n    return PlatformDirs().user_desktop_path\n\n\ndef user_runtime_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: runtime path tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).user_runtime_path\n\n\ndef site_runtime_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: runtime path shared by users\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).site_runtime_path\n\n\n__all__ = [\n    \"AppDirs\",\n    \"PlatformDirs\",\n    \"PlatformDirsABC\",\n    \"__version__\",\n    \"__version_info__\",\n    \"site_cache_dir\",\n    \"site_cache_path\",\n    \"site_config_dir\",\n    \"site_config_path\",\n    \"site_data_dir\",\n    \"site_data_path\",\n    \"site_runtime_dir\",\n    \"site_runtime_path\",\n    \"user_cache_dir\",\n    \"user_cache_path\",\n    \"user_config_dir\",\n    \"user_config_path\",\n    \"user_data_dir\",\n    \"user_data_path\",\n    \"user_desktop_dir\",\n    \"user_desktop_path\",\n    \"user_documents_dir\",\n    \"user_documents_path\",\n    \"user_downloads_dir\",\n    \"user_downloads_path\",\n    \"user_log_dir\",\n    \"user_log_path\",\n    \"user_music_dir\",\n    \"user_music_path\",\n    \"user_pictures_dir\",\n    \"user_pictures_path\",\n    \"user_runtime_dir\",\n    \"user_runtime_path\",\n    \"user_state_dir\",\n    \"user_state_path\",\n    \"user_videos_dir\",\n    \"user_videos_path\",\n]\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/platformdirs/__main__.py","size":1505,"sha1":"214809a801ca11368ef00a3a97fa5fd8f07b0a50","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Main entry point.\"\"\"\n\nfrom __future__ import annotations\n\nfrom pip._vendor.platformdirs import PlatformDirs, __version__\n\nPROPS = (\n    \"user_data_dir\",\n    \"user_config_dir\",\n    \"user_cache_dir\",\n    \"user_state_dir\",\n    \"user_log_dir\",\n    \"user_documents_dir\",\n    \"user_downloads_dir\",\n    \"user_pictures_dir\",\n    \"user_videos_dir\",\n    \"user_music_dir\",\n    \"user_runtime_dir\",\n    \"site_data_dir\",\n    \"site_config_dir\",\n    \"site_cache_dir\",\n    \"site_runtime_dir\",\n)\n\n\ndef main() -> None:\n    \"\"\"Run the main entry point.\"\"\"\n    app_name = \"MyApp\"\n    app_author = \"MyCompany\"\n\n    print(f\"-- platformdirs {__version__} --\")  # noqa: T201\n\n    print(\"-- app dirs (with optional 'version')\")  # noqa: T201\n    dirs = PlatformDirs(app_name, app_author, version=\"1.0\")\n    for prop in PROPS:\n        print(f\"{prop}: {getattr(dirs, prop)}\")  # noqa: T201\n\n    print(\"\\n-- app dirs (without optional 'version')\")  # noqa: T201\n    dirs = PlatformDirs(app_name, app_author)\n    for prop in PROPS:\n        print(f\"{prop}: {getattr(dirs, prop)}\")  # noqa: T201\n\n    print(\"\\n-- app dirs (without optional 'appauthor')\")  # noqa: T201\n    dirs = PlatformDirs(app_name)\n    for prop in PROPS:\n        print(f\"{prop}: {getattr(dirs, prop)}\")  # noqa: T201\n\n    print(\"\\n-- app dirs (with disabled 'appauthor')\")  # noqa: T201\n    dirs = PlatformDirs(app_name, appauthor=False)\n    for prop in PROPS:\n        print(f\"{prop}: {getattr(dirs, prop)}\")  # noqa: T201\n\n\nif __name__ == \"__main__\":\n    main()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/platformdirs/android.py","size":9007,"sha1":"420b31584b6f01931c8c7d9ffa0fafba7f65984c","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Android.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport re\nimport sys\nfrom functools import lru_cache\nfrom typing import TYPE_CHECKING, cast\n\nfrom .api import PlatformDirsABC\n\n\nclass Android(PlatformDirsABC):\n    \"\"\"\n    Follows the guidance `from here <https://android.stackexchange.com/a/216132>`_.\n\n    Makes use of the `appname <platformdirs.api.PlatformDirsABC.appname>`, `version\n    <platformdirs.api.PlatformDirsABC.version>`, `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n\n    \"\"\"\n\n    @property\n    def user_data_dir(self) -> str:\n        \"\"\":return: data directory tied to the user, e.g. ``/data/user/<userid>/<packagename>/files/<AppName>``\"\"\"\n        return self._append_app_name_and_version(cast(str, _android_folder()), \"files\")\n\n    @property\n    def site_data_dir(self) -> str:\n        \"\"\":return: data directory shared by users, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def user_config_dir(self) -> str:\n        \"\"\"\n        :return: config directory tied to the user, e.g. \\\n        ``/data/user/<userid>/<packagename>/shared_prefs/<AppName>``\n        \"\"\"\n        return self._append_app_name_and_version(cast(str, _android_folder()), \"shared_prefs\")\n\n    @property\n    def site_config_dir(self) -> str:\n        \"\"\":return: config directory shared by the users, same as `user_config_dir`\"\"\"\n        return self.user_config_dir\n\n    @property\n    def user_cache_dir(self) -> str:\n        \"\"\":return: cache directory tied to the user, e.g.,``/data/user/<userid>/<packagename>/cache/<AppName>``\"\"\"\n        return self._append_app_name_and_version(cast(str, _android_folder()), \"cache\")\n\n    @property\n    def site_cache_dir(self) -> str:\n        \"\"\":return: cache directory shared by users, same as `user_cache_dir`\"\"\"\n        return self.user_cache_dir\n\n    @property\n    def user_state_dir(self) -> str:\n        \"\"\":return: state directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def user_log_dir(self) -> str:\n        \"\"\"\n        :return: log directory tied to the user, same as `user_cache_dir` if not opinionated else ``log`` in it,\n          e.g. ``/data/user/<userid>/<packagename>/cache/<AppName>/log``\n        \"\"\"\n        path = self.user_cache_dir\n        if self.opinion:\n            path = os.path.join(path, \"log\")  # noqa: PTH118\n        return path\n\n    @property\n    def user_documents_dir(self) -> str:\n        \"\"\":return: documents directory tied to the user e.g. ``/storage/emulated/0/Documents``\"\"\"\n        return _android_documents_folder()\n\n    @property\n    def user_downloads_dir(self) -> str:\n        \"\"\":return: downloads directory tied to the user e.g. ``/storage/emulated/0/Downloads``\"\"\"\n        return _android_downloads_folder()\n\n    @property\n    def user_pictures_dir(self) -> str:\n        \"\"\":return: pictures directory tied to the user e.g. ``/storage/emulated/0/Pictures``\"\"\"\n        return _android_pictures_folder()\n\n    @property\n    def user_videos_dir(self) -> str:\n        \"\"\":return: videos directory tied to the user e.g. ``/storage/emulated/0/DCIM/Camera``\"\"\"\n        return _android_videos_folder()\n\n    @property\n    def user_music_dir(self) -> str:\n        \"\"\":return: music directory tied to the user e.g. ``/storage/emulated/0/Music``\"\"\"\n        return _android_music_folder()\n\n    @property\n    def user_desktop_dir(self) -> str:\n        \"\"\":return: desktop directory tied to the user e.g. ``/storage/emulated/0/Desktop``\"\"\"\n        return \"/storage/emulated/0/Desktop\"\n\n    @property\n    def user_runtime_dir(self) -> str:\n        \"\"\"\n        :return: runtime directory tied to the user, same as `user_cache_dir` if not opinionated else ``tmp`` in it,\n          e.g. ``/data/user/<userid>/<packagename>/cache/<AppName>/tmp``\n        \"\"\"\n        path = self.user_cache_dir\n        if self.opinion:\n            path = os.path.join(path, \"tmp\")  # noqa: PTH118\n        return path\n\n    @property\n    def site_runtime_dir(self) -> str:\n        \"\"\":return: runtime directory shared by users, same as `user_runtime_dir`\"\"\"\n        return self.user_runtime_dir\n\n\n@lru_cache(maxsize=1)\ndef _android_folder() -> str | None:  # noqa: C901\n    \"\"\":return: base folder for the Android OS or None if it cannot be found\"\"\"\n    result: str | None = None\n    # type checker isn't happy with our \"import android\", just don't do this when type checking see\n    # https://stackoverflow.com/a/61394121\n    if not TYPE_CHECKING:\n        try:\n            # First try to get a path to android app using python4android (if available)...\n            from android import mActivity  # noqa: PLC0415\n\n            context = cast(\"android.content.Context\", mActivity.getApplicationContext())  # noqa: F821\n            result = context.getFilesDir().getParentFile().getAbsolutePath()\n        except Exception:  # noqa: BLE001\n            result = None\n    if result is None:\n        try:\n            # ...and fall back to using plain pyjnius, if python4android isn't available or doesn't deliver any useful\n            # result...\n            from jnius import autoclass  # noqa: PLC0415\n\n            context = autoclass(\"android.content.Context\")\n            result = context.getFilesDir().getParentFile().getAbsolutePath()\n        except Exception:  # noqa: BLE001\n            result = None\n    if result is None:\n        # and if that fails, too, find an android folder looking at path on the sys.path\n        # warning: only works for apps installed under /data, not adopted storage etc.\n        pattern = re.compile(r\"/data/(data|user/\\d+)/(.+)/files\")\n        for path in sys.path:\n            if pattern.match(path):\n                result = path.split(\"/files\")[0]\n                break\n        else:\n            result = None\n    if result is None:\n        # one last try: find an android folder looking at path on the sys.path taking adopted storage paths into\n        # account\n        pattern = re.compile(r\"/mnt/expand/[a-fA-F0-9-]{36}/(data|user/\\d+)/(.+)/files\")\n        for path in sys.path:\n            if pattern.match(path):\n                result = path.split(\"/files\")[0]\n                break\n        else:\n            result = None\n    return result\n\n\n@lru_cache(maxsize=1)\ndef _android_documents_folder() -> str:\n    \"\"\":return: documents folder for the Android OS\"\"\"\n    # Get directories with pyjnius\n    try:\n        from jnius import autoclass  # noqa: PLC0415\n\n        context = autoclass(\"android.content.Context\")\n        environment = autoclass(\"android.os.Environment\")\n        documents_dir: str = context.getExternalFilesDir(environment.DIRECTORY_DOCUMENTS).getAbsolutePath()\n    except Exception:  # noqa: BLE001\n        documents_dir = \"/storage/emulated/0/Documents\"\n\n    return documents_dir\n\n\n@lru_cache(maxsize=1)\ndef _android_downloads_folder() -> str:\n    \"\"\":return: downloads folder for the Android OS\"\"\"\n    # Get directories with pyjnius\n    try:\n        from jnius import autoclass  # noqa: PLC0415\n\n        context = autoclass(\"android.content.Context\")\n        environment = autoclass(\"android.os.Environment\")\n        downloads_dir: str = context.getExternalFilesDir(environment.DIRECTORY_DOWNLOADS).getAbsolutePath()\n    except Exception:  # noqa: BLE001\n        downloads_dir = \"/storage/emulated/0/Downloads\"\n\n    return downloads_dir\n\n\n@lru_cache(maxsize=1)\ndef _android_pictures_folder() -> str:\n    \"\"\":return: pictures folder for the Android OS\"\"\"\n    # Get directories with pyjnius\n    try:\n        from jnius import autoclass  # noqa: PLC0415\n\n        context = autoclass(\"android.content.Context\")\n        environment = autoclass(\"android.os.Environment\")\n        pictures_dir: str = context.getExternalFilesDir(environment.DIRECTORY_PICTURES).getAbsolutePath()\n    except Exception:  # noqa: BLE001\n        pictures_dir = \"/storage/emulated/0/Pictures\"\n\n    return pictures_dir\n\n\n@lru_cache(maxsize=1)\ndef _android_videos_folder() -> str:\n    \"\"\":return: videos folder for the Android OS\"\"\"\n    # Get directories with pyjnius\n    try:\n        from jnius import autoclass  # noqa: PLC0415\n\n        context = autoclass(\"android.content.Context\")\n        environment = autoclass(\"android.os.Environment\")\n        videos_dir: str = context.getExternalFilesDir(environment.DIRECTORY_DCIM).getAbsolutePath()\n    except Exception:  # noqa: BLE001\n        videos_dir = \"/storage/emulated/0/DCIM/Camera\"\n\n    return videos_dir\n\n\n@lru_cache(maxsize=1)\ndef _android_music_folder() -> str:\n    \"\"\":return: music folder for the Android OS\"\"\"\n    # Get directories with pyjnius\n    try:\n        from jnius import autoclass  # noqa: PLC0415\n\n        context = autoclass(\"android.content.Context\")\n        environment = autoclass(\"android.os.Environment\")\n        music_dir: str = context.getExternalFilesDir(environment.DIRECTORY_MUSIC).getAbsolutePath()\n    except Exception:  # noqa: BLE001\n        music_dir = \"/storage/emulated/0/Music\"\n\n    return music_dir\n\n\n__all__ = [\n    \"Android\",\n]\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/platformdirs/api.py","size":9246,"sha1":"4f5a21defedaa7ef90cee1d531e9751f0414b9fa","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Base API.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom abc import ABC, abstractmethod\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from typing import Iterator, Literal\n\n\nclass PlatformDirsABC(ABC):  # noqa: PLR0904\n    \"\"\"Abstract base class for platform directories.\"\"\"\n\n    def __init__(  # noqa: PLR0913, PLR0917\n        self,\n        appname: str | None = None,\n        appauthor: str | None | Literal[False] = None,\n        version: str | None = None,\n        roaming: bool = False,  # noqa: FBT001, FBT002\n        multipath: bool = False,  # noqa: FBT001, FBT002\n        opinion: bool = True,  # noqa: FBT001, FBT002\n        ensure_exists: bool = False,  # noqa: FBT001, FBT002\n    ) -> None:\n        \"\"\"\n        Create a new platform directory.\n\n        :param appname: See `appname`.\n        :param appauthor: See `appauthor`.\n        :param version: See `version`.\n        :param roaming: See `roaming`.\n        :param multipath: See `multipath`.\n        :param opinion: See `opinion`.\n        :param ensure_exists: See `ensure_exists`.\n\n        \"\"\"\n        self.appname = appname  #: The name of application.\n        self.appauthor = appauthor\n        \"\"\"\n        The name of the app author or distributing body for this application.\n\n        Typically, it is the owning company name. Defaults to `appname`. You may pass ``False`` to disable it.\n\n        \"\"\"\n        self.version = version\n        \"\"\"\n        An optional version path element to append to the path.\n\n        You might want to use this if you want multiple versions of your app to be able to run independently. If used,\n        this would typically be ``<major>.<minor>``.\n\n        \"\"\"\n        self.roaming = roaming\n        \"\"\"\n        Whether to use the roaming appdata directory on Windows.\n\n        That means that for users on a Windows network setup for roaming profiles, this user data will be synced on\n        login (see\n        `here <https://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx>`_).\n\n        \"\"\"\n        self.multipath = multipath\n        \"\"\"\n        An optional parameter which indicates that the entire list of data dirs should be returned.\n\n        By default, the first item would only be returned.\n\n        \"\"\"\n        self.opinion = opinion  #: A flag to indicating to use opinionated values.\n        self.ensure_exists = ensure_exists\n        \"\"\"\n        Optionally create the directory (and any missing parents) upon access if it does not exist.\n\n        By default, no directories are created.\n\n        \"\"\"\n\n    def _append_app_name_and_version(self, *base: str) -> str:\n        params = list(base[1:])\n        if self.appname:\n            params.append(self.appname)\n            if self.version:\n                params.append(self.version)\n        path = os.path.join(base[0], *params)  # noqa: PTH118\n        self._optionally_create_directory(path)\n        return path\n\n    def _optionally_create_directory(self, path: str) -> None:\n        if self.ensure_exists:\n            Path(path).mkdir(parents=True, exist_ok=True)\n\n    def _first_item_as_path_if_multipath(self, directory: str) -> Path:\n        if self.multipath:\n            # If multipath is True, the first path is returned.\n            directory = directory.split(os.pathsep)[0]\n        return Path(directory)\n\n    @property\n    @abstractmethod\n    def user_data_dir(self) -> str:\n        \"\"\":return: data directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def site_data_dir(self) -> str:\n        \"\"\":return: data directory shared by users\"\"\"\n\n    @property\n    @abstractmethod\n    def user_config_dir(self) -> str:\n        \"\"\":return: config directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def site_config_dir(self) -> str:\n        \"\"\":return: config directory shared by the users\"\"\"\n\n    @property\n    @abstractmethod\n    def user_cache_dir(self) -> str:\n        \"\"\":return: cache directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def site_cache_dir(self) -> str:\n        \"\"\":return: cache directory shared by users\"\"\"\n\n    @property\n    @abstractmethod\n    def user_state_dir(self) -> str:\n        \"\"\":return: state directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_log_dir(self) -> str:\n        \"\"\":return: log directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_documents_dir(self) -> str:\n        \"\"\":return: documents directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_downloads_dir(self) -> str:\n        \"\"\":return: downloads directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_pictures_dir(self) -> str:\n        \"\"\":return: pictures directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_videos_dir(self) -> str:\n        \"\"\":return: videos directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_music_dir(self) -> str:\n        \"\"\":return: music directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_desktop_dir(self) -> str:\n        \"\"\":return: desktop directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_runtime_dir(self) -> str:\n        \"\"\":return: runtime directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def site_runtime_dir(self) -> str:\n        \"\"\":return: runtime directory shared by users\"\"\"\n\n    @property\n    def user_data_path(self) -> Path:\n        \"\"\":return: data path tied to the user\"\"\"\n        return Path(self.user_data_dir)\n\n    @property\n    def site_data_path(self) -> Path:\n        \"\"\":return: data path shared by users\"\"\"\n        return Path(self.site_data_dir)\n\n    @property\n    def user_config_path(self) -> Path:\n        \"\"\":return: config path tied to the user\"\"\"\n        return Path(self.user_config_dir)\n\n    @property\n    def site_config_path(self) -> Path:\n        \"\"\":return: config path shared by the users\"\"\"\n        return Path(self.site_config_dir)\n\n    @property\n    def user_cache_path(self) -> Path:\n        \"\"\":return: cache path tied to the user\"\"\"\n        return Path(self.user_cache_dir)\n\n    @property\n    def site_cache_path(self) -> Path:\n        \"\"\":return: cache path shared by users\"\"\"\n        return Path(self.site_cache_dir)\n\n    @property\n    def user_state_path(self) -> Path:\n        \"\"\":return: state path tied to the user\"\"\"\n        return Path(self.user_state_dir)\n\n    @property\n    def user_log_path(self) -> Path:\n        \"\"\":return: log path tied to the user\"\"\"\n        return Path(self.user_log_dir)\n\n    @property\n    def user_documents_path(self) -> Path:\n        \"\"\":return: documents a path tied to the user\"\"\"\n        return Path(self.user_documents_dir)\n\n    @property\n    def user_downloads_path(self) -> Path:\n        \"\"\":return: downloads path tied to the user\"\"\"\n        return Path(self.user_downloads_dir)\n\n    @property\n    def user_pictures_path(self) -> Path:\n        \"\"\":return: pictures path tied to the user\"\"\"\n        return Path(self.user_pictures_dir)\n\n    @property\n    def user_videos_path(self) -> Path:\n        \"\"\":return: videos path tied to the user\"\"\"\n        return Path(self.user_videos_dir)\n\n    @property\n    def user_music_path(self) -> Path:\n        \"\"\":return: music path tied to the user\"\"\"\n        return Path(self.user_music_dir)\n\n    @property\n    def user_desktop_path(self) -> Path:\n        \"\"\":return: desktop path tied to the user\"\"\"\n        return Path(self.user_desktop_dir)\n\n    @property\n    def user_runtime_path(self) -> Path:\n        \"\"\":return: runtime path tied to the user\"\"\"\n        return Path(self.user_runtime_dir)\n\n    @property\n    def site_runtime_path(self) -> Path:\n        \"\"\":return: runtime path shared by users\"\"\"\n        return Path(self.site_runtime_dir)\n\n    def iter_config_dirs(self) -> Iterator[str]:\n        \"\"\":yield: all user and site configuration directories.\"\"\"\n        yield self.user_config_dir\n        yield self.site_config_dir\n\n    def iter_data_dirs(self) -> Iterator[str]:\n        \"\"\":yield: all user and site data directories.\"\"\"\n        yield self.user_data_dir\n        yield self.site_data_dir\n\n    def iter_cache_dirs(self) -> Iterator[str]:\n        \"\"\":yield: all user and site cache directories.\"\"\"\n        yield self.user_cache_dir\n        yield self.site_cache_dir\n\n    def iter_runtime_dirs(self) -> Iterator[str]:\n        \"\"\":yield: all user and site runtime directories.\"\"\"\n        yield self.user_runtime_dir\n        yield self.site_runtime_dir\n\n    def iter_config_paths(self) -> Iterator[Path]:\n        \"\"\":yield: all user and site configuration paths.\"\"\"\n        for path in self.iter_config_dirs():\n            yield Path(path)\n\n    def iter_data_paths(self) -> Iterator[Path]:\n        \"\"\":yield: all user and site data paths.\"\"\"\n        for path in self.iter_data_dirs():\n            yield Path(path)\n\n    def iter_cache_paths(self) -> Iterator[Path]:\n        \"\"\":yield: all user and site cache paths.\"\"\"\n        for path in self.iter_cache_dirs():\n            yield Path(path)\n\n    def iter_runtime_paths(self) -> Iterator[Path]:\n        \"\"\":yield: all user and site runtime paths.\"\"\"\n        for path in self.iter_runtime_dirs():\n            yield Path(path)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/platformdirs/macos.py","size":6154,"sha1":"1754b1fd09cb07f8f0dc3426689357b6ac41665a","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"macOS.\"\"\"\n\nfrom __future__ import annotations\n\nimport os.path\nimport sys\nfrom typing import TYPE_CHECKING\n\nfrom .api import PlatformDirsABC\n\nif TYPE_CHECKING:\n    from pathlib import Path\n\n\nclass MacOS(PlatformDirsABC):\n    \"\"\"\n    Platform directories for the macOS operating system.\n\n    Follows the guidance from\n    `Apple documentation <https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/MacOSXDirectories/MacOSXDirectories.html>`_.\n    Makes use of the `appname <platformdirs.api.PlatformDirsABC.appname>`,\n    `version <platformdirs.api.PlatformDirsABC.version>`,\n    `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n\n    \"\"\"\n\n    @property\n    def user_data_dir(self) -> str:\n        \"\"\":return: data directory tied to the user, e.g. ``~/Library/Application Support/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(os.path.expanduser(\"~/Library/Application Support\"))  # noqa: PTH111\n\n    @property\n    def site_data_dir(self) -> str:\n        \"\"\"\n        :return: data directory shared by users, e.g. ``/Library/Application Support/$appname/$version``.\n          If we're using a Python binary managed by `Homebrew <https://brew.sh>`_, the directory\n          will be under the Homebrew prefix, e.g. ``/opt/homebrew/share/$appname/$version``.\n          If `multipath <platformdirs.api.PlatformDirsABC.multipath>` is enabled, and we're in Homebrew,\n          the response is a multi-path string separated by \":\", e.g.\n          ``/opt/homebrew/share/$appname/$version:/Library/Application Support/$appname/$version``\n        \"\"\"\n        is_homebrew = sys.prefix.startswith(\"/opt/homebrew\")\n        path_list = [self._append_app_name_and_version(\"/opt/homebrew/share\")] if is_homebrew else []\n        path_list.append(self._append_app_name_and_version(\"/Library/Application Support\"))\n        if self.multipath:\n            return os.pathsep.join(path_list)\n        return path_list[0]\n\n    @property\n    def site_data_path(self) -> Path:\n        \"\"\":return: data path shared by users. Only return the first item, even if ``multipath`` is set to ``True``\"\"\"\n        return self._first_item_as_path_if_multipath(self.site_data_dir)\n\n    @property\n    def user_config_dir(self) -> str:\n        \"\"\":return: config directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def site_config_dir(self) -> str:\n        \"\"\":return: config directory shared by the users, same as `site_data_dir`\"\"\"\n        return self.site_data_dir\n\n    @property\n    def user_cache_dir(self) -> str:\n        \"\"\":return: cache directory tied to the user, e.g. ``~/Library/Caches/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(os.path.expanduser(\"~/Library/Caches\"))  # noqa: PTH111\n\n    @property\n    def site_cache_dir(self) -> str:\n        \"\"\"\n        :return: cache directory shared by users, e.g. ``/Library/Caches/$appname/$version``.\n          If we're using a Python binary managed by `Homebrew <https://brew.sh>`_, the directory\n          will be under the Homebrew prefix, e.g. ``/opt/homebrew/var/cache/$appname/$version``.\n          If `multipath <platformdirs.api.PlatformDirsABC.multipath>` is enabled, and we're in Homebrew,\n          the response is a multi-path string separated by \":\", e.g.\n          ``/opt/homebrew/var/cache/$appname/$version:/Library/Caches/$appname/$version``\n        \"\"\"\n        is_homebrew = sys.prefix.startswith(\"/opt/homebrew\")\n        path_list = [self._append_app_name_and_version(\"/opt/homebrew/var/cache\")] if is_homebrew else []\n        path_list.append(self._append_app_name_and_version(\"/Library/Caches\"))\n        if self.multipath:\n            return os.pathsep.join(path_list)\n        return path_list[0]\n\n    @property\n    def site_cache_path(self) -> Path:\n        \"\"\":return: cache path shared by users. Only return the first item, even if ``multipath`` is set to ``True``\"\"\"\n        return self._first_item_as_path_if_multipath(self.site_cache_dir)\n\n    @property\n    def user_state_dir(self) -> str:\n        \"\"\":return: state directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def user_log_dir(self) -> str:\n        \"\"\":return: log directory tied to the user, e.g. ``~/Library/Logs/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(os.path.expanduser(\"~/Library/Logs\"))  # noqa: PTH111\n\n    @property\n    def user_documents_dir(self) -> str:\n        \"\"\":return: documents directory tied to the user, e.g. ``~/Documents``\"\"\"\n        return os.path.expanduser(\"~/Documents\")  # noqa: PTH111\n\n    @property\n    def user_downloads_dir(self) -> str:\n        \"\"\":return: downloads directory tied to the user, e.g. ``~/Downloads``\"\"\"\n        return os.path.expanduser(\"~/Downloads\")  # noqa: PTH111\n\n    @property\n    def user_pictures_dir(self) -> str:\n        \"\"\":return: pictures directory tied to the user, e.g. ``~/Pictures``\"\"\"\n        return os.path.expanduser(\"~/Pictures\")  # noqa: PTH111\n\n    @property\n    def user_videos_dir(self) -> str:\n        \"\"\":return: videos directory tied to the user, e.g. ``~/Movies``\"\"\"\n        return os.path.expanduser(\"~/Movies\")  # noqa: PTH111\n\n    @property\n    def user_music_dir(self) -> str:\n        \"\"\":return: music directory tied to the user, e.g. ``~/Music``\"\"\"\n        return os.path.expanduser(\"~/Music\")  # noqa: PTH111\n\n    @property\n    def user_desktop_dir(self) -> str:\n        \"\"\":return: desktop directory tied to the user, e.g. ``~/Desktop``\"\"\"\n        return os.path.expanduser(\"~/Desktop\")  # noqa: PTH111\n\n    @property\n    def user_runtime_dir(self) -> str:\n        \"\"\":return: runtime directory tied to the user, e.g. ``~/Library/Caches/TemporaryItems/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(os.path.expanduser(\"~/Library/Caches/TemporaryItems\"))  # noqa: PTH111\n\n    @property\n    def site_runtime_dir(self) -> str:\n        \"\"\":return: runtime directory shared by users, same as `user_runtime_dir`\"\"\"\n        return self.user_runtime_dir\n\n\n__all__ = [\n    \"MacOS\",\n]\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/platformdirs/unix.py","size":10393,"sha1":"e9ad39a66a10bac2803fb2bb763718e82d17dd88","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Unix.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport sys\nfrom configparser import ConfigParser\nfrom pathlib import Path\nfrom typing import Iterator, NoReturn\n\nfrom .api import PlatformDirsABC\n\nif sys.platform == \"win32\":\n\n    def getuid() -> NoReturn:\n        msg = \"should only be used on Unix\"\n        raise RuntimeError(msg)\n\nelse:\n    from os import getuid\n\n\nclass Unix(PlatformDirsABC):  # noqa: PLR0904\n    \"\"\"\n    On Unix/Linux, we follow the `XDG Basedir Spec <https://specifications.freedesktop.org/basedir-spec/basedir-spec-\n    latest.html>`_.\n\n    The spec allows overriding directories with environment variables. The examples shown are the default values,\n    alongside the name of the environment variable that overrides them. Makes use of the `appname\n    <platformdirs.api.PlatformDirsABC.appname>`, `version <platformdirs.api.PlatformDirsABC.version>`, `multipath\n    <platformdirs.api.PlatformDirsABC.multipath>`, `opinion <platformdirs.api.PlatformDirsABC.opinion>`, `ensure_exists\n    <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n\n    \"\"\"\n\n    @property\n    def user_data_dir(self) -> str:\n        \"\"\"\n        :return: data directory tied to the user, e.g. ``~/.local/share/$appname/$version`` or\n         ``$XDG_DATA_HOME/$appname/$version``\n        \"\"\"\n        path = os.environ.get(\"XDG_DATA_HOME\", \"\")\n        if not path.strip():\n            path = os.path.expanduser(\"~/.local/share\")  # noqa: PTH111\n        return self._append_app_name_and_version(path)\n\n    @property\n    def _site_data_dirs(self) -> list[str]:\n        path = os.environ.get(\"XDG_DATA_DIRS\", \"\")\n        if not path.strip():\n            path = f\"/usr/local/share{os.pathsep}/usr/share\"\n        return [self._append_app_name_and_version(p) for p in path.split(os.pathsep)]\n\n    @property\n    def site_data_dir(self) -> str:\n        \"\"\"\n        :return: data directories shared by users (if `multipath <platformdirs.api.PlatformDirsABC.multipath>` is\n         enabled and ``XDG_DATA_DIRS`` is set and a multi path the response is also a multi path separated by the\n         OS path separator), e.g. ``/usr/local/share/$appname/$version`` or ``/usr/share/$appname/$version``\n        \"\"\"\n        # XDG default for $XDG_DATA_DIRS; only first, if multipath is False\n        dirs = self._site_data_dirs\n        if not self.multipath:\n            return dirs[0]\n        return os.pathsep.join(dirs)\n\n    @property\n    def user_config_dir(self) -> str:\n        \"\"\"\n        :return: config directory tied to the user, e.g. ``~/.config/$appname/$version`` or\n         ``$XDG_CONFIG_HOME/$appname/$version``\n        \"\"\"\n        path = os.environ.get(\"XDG_CONFIG_HOME\", \"\")\n        if not path.strip():\n            path = os.path.expanduser(\"~/.config\")  # noqa: PTH111\n        return self._append_app_name_and_version(path)\n\n    @property\n    def _site_config_dirs(self) -> list[str]:\n        path = os.environ.get(\"XDG_CONFIG_DIRS\", \"\")\n        if not path.strip():\n            path = \"/etc/xdg\"\n        return [self._append_app_name_and_version(p) for p in path.split(os.pathsep)]\n\n    @property\n    def site_config_dir(self) -> str:\n        \"\"\"\n        :return: config directories shared by users (if `multipath <platformdirs.api.PlatformDirsABC.multipath>`\n         is enabled and ``XDG_CONFIG_DIRS`` is set and a multi path the response is also a multi path separated by\n         the OS path separator), e.g. ``/etc/xdg/$appname/$version``\n        \"\"\"\n        # XDG default for $XDG_CONFIG_DIRS only first, if multipath is False\n        dirs = self._site_config_dirs\n        if not self.multipath:\n            return dirs[0]\n        return os.pathsep.join(dirs)\n\n    @property\n    def user_cache_dir(self) -> str:\n        \"\"\"\n        :return: cache directory tied to the user, e.g. ``~/.cache/$appname/$version`` or\n         ``~/$XDG_CACHE_HOME/$appname/$version``\n        \"\"\"\n        path = os.environ.get(\"XDG_CACHE_HOME\", \"\")\n        if not path.strip():\n            path = os.path.expanduser(\"~/.cache\")  # noqa: PTH111\n        return self._append_app_name_and_version(path)\n\n    @property\n    def site_cache_dir(self) -> str:\n        \"\"\":return: cache directory shared by users, e.g. ``/var/cache/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(\"/var/cache\")\n\n    @property\n    def user_state_dir(self) -> str:\n        \"\"\"\n        :return: state directory tied to the user, e.g. ``~/.local/state/$appname/$version`` or\n         ``$XDG_STATE_HOME/$appname/$version``\n        \"\"\"\n        path = os.environ.get(\"XDG_STATE_HOME\", \"\")\n        if not path.strip():\n            path = os.path.expanduser(\"~/.local/state\")  # noqa: PTH111\n        return self._append_app_name_and_version(path)\n\n    @property\n    def user_log_dir(self) -> str:\n        \"\"\":return: log directory tied to the user, same as `user_state_dir` if not opinionated else ``log`` in it\"\"\"\n        path = self.user_state_dir\n        if self.opinion:\n            path = os.path.join(path, \"log\")  # noqa: PTH118\n            self._optionally_create_directory(path)\n        return path\n\n    @property\n    def user_documents_dir(self) -> str:\n        \"\"\":return: documents directory tied to the user, e.g. ``~/Documents``\"\"\"\n        return _get_user_media_dir(\"XDG_DOCUMENTS_DIR\", \"~/Documents\")\n\n    @property\n    def user_downloads_dir(self) -> str:\n        \"\"\":return: downloads directory tied to the user, e.g. ``~/Downloads``\"\"\"\n        return _get_user_media_dir(\"XDG_DOWNLOAD_DIR\", \"~/Downloads\")\n\n    @property\n    def user_pictures_dir(self) -> str:\n        \"\"\":return: pictures directory tied to the user, e.g. ``~/Pictures``\"\"\"\n        return _get_user_media_dir(\"XDG_PICTURES_DIR\", \"~/Pictures\")\n\n    @property\n    def user_videos_dir(self) -> str:\n        \"\"\":return: videos directory tied to the user, e.g. ``~/Videos``\"\"\"\n        return _get_user_media_dir(\"XDG_VIDEOS_DIR\", \"~/Videos\")\n\n    @property\n    def user_music_dir(self) -> str:\n        \"\"\":return: music directory tied to the user, e.g. ``~/Music``\"\"\"\n        return _get_user_media_dir(\"XDG_MUSIC_DIR\", \"~/Music\")\n\n    @property\n    def user_desktop_dir(self) -> str:\n        \"\"\":return: desktop directory tied to the user, e.g. ``~/Desktop``\"\"\"\n        return _get_user_media_dir(\"XDG_DESKTOP_DIR\", \"~/Desktop\")\n\n    @property\n    def user_runtime_dir(self) -> str:\n        \"\"\"\n        :return: runtime directory tied to the user, e.g. ``/run/user/$(id -u)/$appname/$version`` or\n         ``$XDG_RUNTIME_DIR/$appname/$version``.\n\n         For FreeBSD/OpenBSD/NetBSD, it would return ``/var/run/user/$(id -u)/$appname/$version`` if\n         exists, otherwise ``/tmp/runtime-$(id -u)/$appname/$version``, if``$XDG_RUNTIME_DIR``\n         is not set.\n        \"\"\"\n        path = os.environ.get(\"XDG_RUNTIME_DIR\", \"\")\n        if not path.strip():\n            if sys.platform.startswith((\"freebsd\", \"openbsd\", \"netbsd\")):\n                path = f\"/var/run/user/{getuid()}\"\n                if not Path(path).exists():\n                    path = f\"/tmp/runtime-{getuid()}\"  # noqa: S108\n            else:\n                path = f\"/run/user/{getuid()}\"\n        return self._append_app_name_and_version(path)\n\n    @property\n    def site_runtime_dir(self) -> str:\n        \"\"\"\n        :return: runtime directory shared by users, e.g. ``/run/$appname/$version`` or \\\n        ``$XDG_RUNTIME_DIR/$appname/$version``.\n\n        Note that this behaves almost exactly like `user_runtime_dir` if ``$XDG_RUNTIME_DIR`` is set, but will\n        fall back to paths associated to the root user instead of a regular logged-in user if it's not set.\n\n        If you wish to ensure that a logged-in root user path is returned e.g. ``/run/user/0``, use `user_runtime_dir`\n        instead.\n\n        For FreeBSD/OpenBSD/NetBSD, it would return ``/var/run/$appname/$version`` if ``$XDG_RUNTIME_DIR`` is not set.\n        \"\"\"\n        path = os.environ.get(\"XDG_RUNTIME_DIR\", \"\")\n        if not path.strip():\n            if sys.platform.startswith((\"freebsd\", \"openbsd\", \"netbsd\")):\n                path = \"/var/run\"\n            else:\n                path = \"/run\"\n        return self._append_app_name_and_version(path)\n\n    @property\n    def site_data_path(self) -> Path:\n        \"\"\":return: data path shared by users. Only return the first item, even if ``multipath`` is set to ``True``\"\"\"\n        return self._first_item_as_path_if_multipath(self.site_data_dir)\n\n    @property\n    def site_config_path(self) -> Path:\n        \"\"\":return: config path shared by the users, returns the first item, even if ``multipath`` is set to ``True``\"\"\"\n        return self._first_item_as_path_if_multipath(self.site_config_dir)\n\n    @property\n    def site_cache_path(self) -> Path:\n        \"\"\":return: cache path shared by users. Only return the first item, even if ``multipath`` is set to ``True``\"\"\"\n        return self._first_item_as_path_if_multipath(self.site_cache_dir)\n\n    def iter_config_dirs(self) -> Iterator[str]:\n        \"\"\":yield: all user and site configuration directories.\"\"\"\n        yield self.user_config_dir\n        yield from self._site_config_dirs\n\n    def iter_data_dirs(self) -> Iterator[str]:\n        \"\"\":yield: all user and site data directories.\"\"\"\n        yield self.user_data_dir\n        yield from self._site_data_dirs\n\n\ndef _get_user_media_dir(env_var: str, fallback_tilde_path: str) -> str:\n    media_dir = _get_user_dirs_folder(env_var)\n    if media_dir is None:\n        media_dir = os.environ.get(env_var, \"\").strip()\n        if not media_dir:\n            media_dir = os.path.expanduser(fallback_tilde_path)  # noqa: PTH111\n\n    return media_dir\n\n\ndef _get_user_dirs_folder(key: str) -> str | None:\n    \"\"\"\n    Return directory from user-dirs.dirs config file.\n\n    See https://freedesktop.org/wiki/Software/xdg-user-dirs/.\n\n    \"\"\"\n    user_dirs_config_path = Path(Unix().user_config_dir) / \"user-dirs.dirs\"\n    if user_dirs_config_path.exists():\n        parser = ConfigParser()\n\n        with user_dirs_config_path.open() as stream:\n            # Add fake section header, so ConfigParser doesn't complain\n            parser.read_string(f\"[top]\\n{stream.read()}\")\n\n        if key not in parser[\"top\"]:\n            return None\n\n        path = parser[\"top\"][key].strip('\"')\n        # Handle relative home paths\n        return path.replace(\"$HOME\", os.path.expanduser(\"~\"))  # noqa: PTH111\n\n    return None\n\n\n__all__ = [\n    \"Unix\",\n]\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/platformdirs/version.py","size":411,"sha1":"5bd9b70657a43666bdf234e22280d7a9358e0f66","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# file generated by setuptools_scm\n# don't change, don't track in version control\nTYPE_CHECKING = False\nif TYPE_CHECKING:\n    from typing import Tuple, Union\n    VERSION_TUPLE = Tuple[Union[int, str], ...]\nelse:\n    VERSION_TUPLE = object\n\nversion: str\n__version__: str\n__version_tuple__: VERSION_TUPLE\nversion_tuple: VERSION_TUPLE\n\n__version__ = version = '4.3.6'\n__version_tuple__ = version_tuple = (4, 3, 6)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/platformdirs/windows.py","size":10125,"sha1":"920d92beeaa289b22c86911d1bbb942ca79cc167","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Windows.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport sys\nfrom functools import lru_cache\nfrom typing import TYPE_CHECKING\n\nfrom .api import PlatformDirsABC\n\nif TYPE_CHECKING:\n    from collections.abc import Callable\n\n\nclass Windows(PlatformDirsABC):\n    \"\"\"\n    `MSDN on where to store app data files <https://learn.microsoft.com/en-us/windows/win32/shell/knownfolderid>`_.\n\n    Makes use of the `appname <platformdirs.api.PlatformDirsABC.appname>`, `appauthor\n    <platformdirs.api.PlatformDirsABC.appauthor>`, `version <platformdirs.api.PlatformDirsABC.version>`, `roaming\n    <platformdirs.api.PlatformDirsABC.roaming>`, `opinion <platformdirs.api.PlatformDirsABC.opinion>`, `ensure_exists\n    <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n\n    \"\"\"\n\n    @property\n    def user_data_dir(self) -> str:\n        \"\"\"\n        :return: data directory tied to the user, e.g.\n         ``%USERPROFILE%\\\\AppData\\\\Local\\\\$appauthor\\\\$appname`` (not roaming) or\n         ``%USERPROFILE%\\\\AppData\\\\Roaming\\\\$appauthor\\\\$appname`` (roaming)\n        \"\"\"\n        const = \"CSIDL_APPDATA\" if self.roaming else \"CSIDL_LOCAL_APPDATA\"\n        path = os.path.normpath(get_win_folder(const))\n        return self._append_parts(path)\n\n    def _append_parts(self, path: str, *, opinion_value: str | None = None) -> str:\n        params = []\n        if self.appname:\n            if self.appauthor is not False:\n                author = self.appauthor or self.appname\n                params.append(author)\n            params.append(self.appname)\n            if opinion_value is not None and self.opinion:\n                params.append(opinion_value)\n            if self.version:\n                params.append(self.version)\n        path = os.path.join(path, *params)  # noqa: PTH118\n        self._optionally_create_directory(path)\n        return path\n\n    @property\n    def site_data_dir(self) -> str:\n        \"\"\":return: data directory shared by users, e.g. ``C:\\\\ProgramData\\\\$appauthor\\\\$appname``\"\"\"\n        path = os.path.normpath(get_win_folder(\"CSIDL_COMMON_APPDATA\"))\n        return self._append_parts(path)\n\n    @property\n    def user_config_dir(self) -> str:\n        \"\"\":return: config directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def site_config_dir(self) -> str:\n        \"\"\":return: config directory shared by the users, same as `site_data_dir`\"\"\"\n        return self.site_data_dir\n\n    @property\n    def user_cache_dir(self) -> str:\n        \"\"\"\n        :return: cache directory tied to the user (if opinionated with ``Cache`` folder within ``$appname``) e.g.\n         ``%USERPROFILE%\\\\AppData\\\\Local\\\\$appauthor\\\\$appname\\\\Cache\\\\$version``\n        \"\"\"\n        path = os.path.normpath(get_win_folder(\"CSIDL_LOCAL_APPDATA\"))\n        return self._append_parts(path, opinion_value=\"Cache\")\n\n    @property\n    def site_cache_dir(self) -> str:\n        \"\"\":return: cache directory shared by users, e.g. ``C:\\\\ProgramData\\\\$appauthor\\\\$appname\\\\Cache\\\\$version``\"\"\"\n        path = os.path.normpath(get_win_folder(\"CSIDL_COMMON_APPDATA\"))\n        return self._append_parts(path, opinion_value=\"Cache\")\n\n    @property\n    def user_state_dir(self) -> str:\n        \"\"\":return: state directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def user_log_dir(self) -> str:\n        \"\"\":return: log directory tied to the user, same as `user_data_dir` if not opinionated else ``Logs`` in it\"\"\"\n        path = self.user_data_dir\n        if self.opinion:\n            path = os.path.join(path, \"Logs\")  # noqa: PTH118\n            self._optionally_create_directory(path)\n        return path\n\n    @property\n    def user_documents_dir(self) -> str:\n        \"\"\":return: documents directory tied to the user e.g. ``%USERPROFILE%\\\\Documents``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_PERSONAL\"))\n\n    @property\n    def user_downloads_dir(self) -> str:\n        \"\"\":return: downloads directory tied to the user e.g. ``%USERPROFILE%\\\\Downloads``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_DOWNLOADS\"))\n\n    @property\n    def user_pictures_dir(self) -> str:\n        \"\"\":return: pictures directory tied to the user e.g. ``%USERPROFILE%\\\\Pictures``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_MYPICTURES\"))\n\n    @property\n    def user_videos_dir(self) -> str:\n        \"\"\":return: videos directory tied to the user e.g. ``%USERPROFILE%\\\\Videos``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_MYVIDEO\"))\n\n    @property\n    def user_music_dir(self) -> str:\n        \"\"\":return: music directory tied to the user e.g. ``%USERPROFILE%\\\\Music``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_MYMUSIC\"))\n\n    @property\n    def user_desktop_dir(self) -> str:\n        \"\"\":return: desktop directory tied to the user, e.g. ``%USERPROFILE%\\\\Desktop``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_DESKTOPDIRECTORY\"))\n\n    @property\n    def user_runtime_dir(self) -> str:\n        \"\"\"\n        :return: runtime directory tied to the user, e.g.\n         ``%USERPROFILE%\\\\AppData\\\\Local\\\\Temp\\\\$appauthor\\\\$appname``\n        \"\"\"\n        path = os.path.normpath(os.path.join(get_win_folder(\"CSIDL_LOCAL_APPDATA\"), \"Temp\"))  # noqa: PTH118\n        return self._append_parts(path)\n\n    @property\n    def site_runtime_dir(self) -> str:\n        \"\"\":return: runtime directory shared by users, same as `user_runtime_dir`\"\"\"\n        return self.user_runtime_dir\n\n\ndef get_win_folder_from_env_vars(csidl_name: str) -> str:\n    \"\"\"Get folder from environment variables.\"\"\"\n    result = get_win_folder_if_csidl_name_not_env_var(csidl_name)\n    if result is not None:\n        return result\n\n    env_var_name = {\n        \"CSIDL_APPDATA\": \"APPDATA\",\n        \"CSIDL_COMMON_APPDATA\": \"ALLUSERSPROFILE\",\n        \"CSIDL_LOCAL_APPDATA\": \"LOCALAPPDATA\",\n    }.get(csidl_name)\n    if env_var_name is None:\n        msg = f\"Unknown CSIDL name: {csidl_name}\"\n        raise ValueError(msg)\n    result = os.environ.get(env_var_name)\n    if result is None:\n        msg = f\"Unset environment variable: {env_var_name}\"\n        raise ValueError(msg)\n    return result\n\n\ndef get_win_folder_if_csidl_name_not_env_var(csidl_name: str) -> str | None:\n    \"\"\"Get a folder for a CSIDL name that does not exist as an environment variable.\"\"\"\n    if csidl_name == \"CSIDL_PERSONAL\":\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Documents\")  # noqa: PTH118\n\n    if csidl_name == \"CSIDL_DOWNLOADS\":\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Downloads\")  # noqa: PTH118\n\n    if csidl_name == \"CSIDL_MYPICTURES\":\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Pictures\")  # noqa: PTH118\n\n    if csidl_name == \"CSIDL_MYVIDEO\":\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Videos\")  # noqa: PTH118\n\n    if csidl_name == \"CSIDL_MYMUSIC\":\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Music\")  # noqa: PTH118\n    return None\n\n\ndef get_win_folder_from_registry(csidl_name: str) -> str:\n    \"\"\"\n    Get folder from the registry.\n\n    This is a fallback technique at best. I'm not sure if using the registry for these guarantees us the correct answer\n    for all CSIDL_* names.\n\n    \"\"\"\n    shell_folder_name = {\n        \"CSIDL_APPDATA\": \"AppData\",\n        \"CSIDL_COMMON_APPDATA\": \"Common AppData\",\n        \"CSIDL_LOCAL_APPDATA\": \"Local AppData\",\n        \"CSIDL_PERSONAL\": \"Personal\",\n        \"CSIDL_DOWNLOADS\": \"{374DE290-123F-4565-9164-39C4925E467B}\",\n        \"CSIDL_MYPICTURES\": \"My Pictures\",\n        \"CSIDL_MYVIDEO\": \"My Video\",\n        \"CSIDL_MYMUSIC\": \"My Music\",\n    }.get(csidl_name)\n    if shell_folder_name is None:\n        msg = f\"Unknown CSIDL name: {csidl_name}\"\n        raise ValueError(msg)\n    if sys.platform != \"win32\":  # only needed for mypy type checker to know that this code runs only on Windows\n        raise NotImplementedError\n    import winreg  # noqa: PLC0415\n\n    key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r\"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\")\n    directory, _ = winreg.QueryValueEx(key, shell_folder_name)\n    return str(directory)\n\n\ndef get_win_folder_via_ctypes(csidl_name: str) -> str:\n    \"\"\"Get folder with ctypes.\"\"\"\n    # There is no 'CSIDL_DOWNLOADS'.\n    # Use 'CSIDL_PROFILE' (40) and append the default folder 'Downloads' instead.\n    # https://learn.microsoft.com/en-us/windows/win32/shell/knownfolderid\n\n    import ctypes  # noqa: PLC0415\n\n    csidl_const = {\n        \"CSIDL_APPDATA\": 26,\n        \"CSIDL_COMMON_APPDATA\": 35,\n        \"CSIDL_LOCAL_APPDATA\": 28,\n        \"CSIDL_PERSONAL\": 5,\n        \"CSIDL_MYPICTURES\": 39,\n        \"CSIDL_MYVIDEO\": 14,\n        \"CSIDL_MYMUSIC\": 13,\n        \"CSIDL_DOWNLOADS\": 40,\n        \"CSIDL_DESKTOPDIRECTORY\": 16,\n    }.get(csidl_name)\n    if csidl_const is None:\n        msg = f\"Unknown CSIDL name: {csidl_name}\"\n        raise ValueError(msg)\n\n    buf = ctypes.create_unicode_buffer(1024)\n    windll = getattr(ctypes, \"windll\")  # noqa: B009 # using getattr to avoid false positive with mypy type checker\n    windll.shell32.SHGetFolderPathW(None, csidl_const, None, 0, buf)\n\n    # Downgrade to short path name if it has high-bit chars.\n    if any(ord(c) > 255 for c in buf):  # noqa: PLR2004\n        buf2 = ctypes.create_unicode_buffer(1024)\n        if windll.kernel32.GetShortPathNameW(buf.value, buf2, 1024):\n            buf = buf2\n\n    if csidl_name == \"CSIDL_DOWNLOADS\":\n        return os.path.join(buf.value, \"Downloads\")  # noqa: PTH118\n\n    return buf.value\n\n\ndef _pick_get_win_folder() -> Callable[[str], str]:\n    try:\n        import ctypes  # noqa: PLC0415\n    except ImportError:\n        pass\n    else:\n        if hasattr(ctypes, \"windll\"):\n            return get_win_folder_via_ctypes\n    try:\n        import winreg  # noqa: PLC0415, F401\n    except ImportError:\n        return get_win_folder_from_env_vars\n    else:\n        return get_win_folder_from_registry\n\n\nget_win_folder = lru_cache(maxsize=None)(_pick_get_win_folder())\n\n__all__ = [\n    \"Windows\",\n]\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/pygments/__init__.py","size":2983,"sha1":"40a7d3e4642ba18dbf22fe4a83270ee4c1d8afa3","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\n    Pygments\n    ~~~~~~~~\n\n    Pygments is a syntax highlighting package written in Python.\n\n    It is a generic syntax highlighter for general use in all kinds of software\n    such as forum systems, wikis or other applications that need to prettify\n    source code. Highlights are:\n\n    * a wide range of common languages and markup formats is supported\n    * special attention is paid to details, increasing quality by a fair amount\n    * support for new languages and formats are added easily\n    * a number of output formats, presently HTML, LaTeX, RTF, SVG, all image\n      formats that PIL supports, and ANSI sequences\n    * it is usable as a command-line tool and as a library\n    * ... and it highlights even Brainfuck!\n\n    The `Pygments master branch`_ is installable with ``easy_install Pygments==dev``.\n\n    .. _Pygments master branch:\n       https://github.com/pygments/pygments/archive/master.zip#egg=Pygments-dev\n\n    :copyright: Copyright 2006-2024 by the Pygments team, see AUTHORS.\n    :license: BSD, see LICENSE for details.\n\"\"\"\nfrom io import StringIO, BytesIO\n\n__version__ = '2.18.0'\n__docformat__ = 'restructuredtext'\n\n__all__ = ['lex', 'format', 'highlight']\n\n\ndef lex(code, lexer):\n    \"\"\"\n    Lex `code` with the `lexer` (must be a `Lexer` instance)\n    and return an iterable of tokens. Currently, this only calls\n    `lexer.get_tokens()`.\n    \"\"\"\n    try:\n        return lexer.get_tokens(code)\n    except TypeError:\n        # Heuristic to catch a common mistake.\n        from pip._vendor.pygments.lexer import RegexLexer\n        if isinstance(lexer, type) and issubclass(lexer, RegexLexer):\n            raise TypeError('lex() argument must be a lexer instance, '\n                            'not a class')\n        raise\n\n\ndef format(tokens, formatter, outfile=None):  # pylint: disable=redefined-builtin\n    \"\"\"\n    Format ``tokens`` (an iterable of tokens) with the formatter ``formatter``\n    (a `Formatter` instance).\n\n    If ``outfile`` is given and a valid file object (an object with a\n    ``write`` method), the result will be written to it, otherwise it\n    is returned as a string.\n    \"\"\"\n    try:\n        if not outfile:\n            realoutfile = getattr(formatter, 'encoding', None) and BytesIO() or StringIO()\n            formatter.format(tokens, realoutfile)\n            return realoutfile.getvalue()\n        else:\n            formatter.format(tokens, outfile)\n    except TypeError:\n        # Heuristic to catch a common mistake.\n        from pip._vendor.pygments.formatter import Formatter\n        if isinstance(formatter, type) and issubclass(formatter, Formatter):\n            raise TypeError('format() argument must be a formatter instance, '\n                            'not a class')\n        raise\n\n\ndef highlight(code, lexer, formatter, outfile=None):\n    \"\"\"\n    This is the most high-level highlighting function. It combines `lex` and\n    `format` in one function.\n    \"\"\"\n    return format(lex(code, lexer), formatter, outfile)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/pygments/__main__.py","size":353,"sha1":"7b671d8c8b1ef03e5a2c14d576c22e98d7fb02e2","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\n    pygments.__main__\n    ~~~~~~~~~~~~~~~~~\n\n    Main entry point for ``python -m pygments``.\n\n    :copyright: Copyright 2006-2024 by the Pygments team, see AUTHORS.\n    :license: BSD, see LICENSE for details.\n\"\"\"\n\nimport sys\nfrom pip._vendor.pygments.cmdline import main\n\ntry:\n    sys.exit(main(sys.argv))\nexcept KeyboardInterrupt:\n    sys.exit(1)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/pygments/cmdline.py","size":23656,"sha1":"94dfe4a002158ffd6e92a3a0d08d6df5f29e3923","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\n    pygments.cmdline\n    ~~~~~~~~~~~~~~~~\n\n    Command line interface.\n\n    :copyright: Copyright 2006-2024 by the Pygments team, see AUTHORS.\n    :license: BSD, see LICENSE for details.\n\"\"\"\n\nimport os\nimport sys\nimport shutil\nimport argparse\nfrom textwrap import dedent\n\nfrom pip._vendor.pygments import __version__, highlight\nfrom pip._vendor.pygments.util import ClassNotFound, OptionError, docstring_headline, \\\n    guess_decode, guess_decode_from_terminal, terminal_encoding, \\\n    UnclosingTextIOWrapper\nfrom pip._vendor.pygments.lexers import get_all_lexers, get_lexer_by_name, guess_lexer, \\\n    load_lexer_from_file, get_lexer_for_filename, find_lexer_class_for_filename\nfrom pip._vendor.pygments.lexers.special import TextLexer\nfrom pip._vendor.pygments.formatters.latex import LatexEmbeddedLexer, LatexFormatter\nfrom pip._vendor.pygments.formatters import get_all_formatters, get_formatter_by_name, \\\n    load_formatter_from_file, get_formatter_for_filename, find_formatter_class\nfrom pip._vendor.pygments.formatters.terminal import TerminalFormatter\nfrom pip._vendor.pygments.formatters.terminal256 import Terminal256Formatter, TerminalTrueColorFormatter\nfrom pip._vendor.pygments.filters import get_all_filters, find_filter_class\nfrom pip._vendor.pygments.styles import get_all_styles, get_style_by_name\n\n\ndef _parse_options(o_strs):\n    opts = {}\n    if not o_strs:\n        return opts\n    for o_str in o_strs:\n        if not o_str.strip():\n            continue\n        o_args = o_str.split(',')\n        for o_arg in o_args:\n            o_arg = o_arg.strip()\n            try:\n                o_key, o_val = o_arg.split('=', 1)\n                o_key = o_key.strip()\n                o_val = o_val.strip()\n            except ValueError:\n                opts[o_arg] = True\n            else:\n                opts[o_key] = o_val\n    return opts\n\n\ndef _parse_filters(f_strs):\n    filters = []\n    if not f_strs:\n        return filters\n    for f_str in f_strs:\n        if ':' in f_str:\n            fname, fopts = f_str.split(':', 1)\n            filters.append((fname, _parse_options([fopts])))\n        else:\n            filters.append((f_str, {}))\n    return filters\n\n\ndef _print_help(what, name):\n    try:\n        if what == 'lexer':\n            cls = get_lexer_by_name(name)\n            print(f\"Help on the {cls.name} lexer:\")\n            print(dedent(cls.__doc__))\n        elif what == 'formatter':\n            cls = find_formatter_class(name)\n            print(f\"Help on the {cls.name} formatter:\")\n            print(dedent(cls.__doc__))\n        elif what == 'filter':\n            cls = find_filter_class(name)\n            print(f\"Help on the {name} filter:\")\n            print(dedent(cls.__doc__))\n        return 0\n    except (AttributeError, ValueError):\n        print(f\"{what} not found!\", file=sys.stderr)\n        return 1\n\n\ndef _print_list(what):\n    if what == 'lexer':\n        print()\n        print(\"Lexers:\")\n        print(\"~~~~~~~\")\n\n        info = []\n        for fullname, names, exts, _ in get_all_lexers():\n            tup = (', '.join(names)+':', fullname,\n                   exts and '(filenames ' + ', '.join(exts) + ')' or '')\n            info.append(tup)\n        info.sort()\n        for i in info:\n            print(('* {}\\n    {} {}').format(*i))\n\n    elif what == 'formatter':\n        print()\n        print(\"Formatters:\")\n        print(\"~~~~~~~~~~~\")\n\n        info = []\n        for cls in get_all_formatters():\n            doc = docstring_headline(cls)\n            tup = (', '.join(cls.aliases) + ':', doc, cls.filenames and\n                   '(filenames ' + ', '.join(cls.filenames) + ')' or '')\n            info.append(tup)\n        info.sort()\n        for i in info:\n            print(('* {}\\n    {} {}').format(*i))\n\n    elif what == 'filter':\n        print()\n        print(\"Filters:\")\n        print(\"~~~~~~~~\")\n\n        for name in get_all_filters():\n            cls = find_filter_class(name)\n            print(\"* \" + name + ':')\n            print(f\"    {docstring_headline(cls)}\")\n\n    elif what == 'style':\n        print()\n        print(\"Styles:\")\n        print(\"~~~~~~~\")\n\n        for name in get_all_styles():\n            cls = get_style_by_name(name)\n            print(\"* \" + name + ':')\n            print(f\"    {docstring_headline(cls)}\")\n\n\ndef _print_list_as_json(requested_items):\n    import json\n    result = {}\n    if 'lexer' in requested_items:\n        info = {}\n        for fullname, names, filenames, mimetypes in get_all_lexers():\n            info[fullname] = {\n                'aliases': names,\n                'filenames': filenames,\n                'mimetypes': mimetypes\n            }\n        result['lexers'] = info\n\n    if 'formatter' in requested_items:\n        info = {}\n        for cls in get_all_formatters():\n            doc = docstring_headline(cls)\n            info[cls.name] = {\n                'aliases': cls.aliases,\n                'filenames': cls.filenames,\n                'doc': doc\n            }\n        result['formatters'] = info\n\n    if 'filter' in requested_items:\n        info = {}\n        for name in get_all_filters():\n            cls = find_filter_class(name)\n            info[name] = {\n                'doc': docstring_headline(cls)\n            }\n        result['filters'] = info\n\n    if 'style' in requested_items:\n        info = {}\n        for name in get_all_styles():\n            cls = get_style_by_name(name)\n            info[name] = {\n                'doc': docstring_headline(cls)\n            }\n        result['styles'] = info\n\n    json.dump(result, sys.stdout)\n\ndef main_inner(parser, argns):\n    if argns.help:\n        parser.print_help()\n        return 0\n\n    if argns.V:\n        print(f'Pygments version {__version__}, (c) 2006-2024 by Georg Brandl, Matthus '\n              'Chajdas and contributors.')\n        return 0\n\n    def is_only_option(opt):\n        return not any(v for (k, v) in vars(argns).items() if k != opt)\n\n    # handle ``pygmentize -L``\n    if argns.L is not None:\n        arg_set = set()\n        for k, v in vars(argns).items():\n            if v:\n                arg_set.add(k)\n\n        arg_set.discard('L')\n        arg_set.discard('json')\n\n        if arg_set:\n            parser.print_help(sys.stderr)\n            return 2\n\n        # print version\n        if not argns.json:\n            main(['', '-V'])\n        allowed_types = {'lexer', 'formatter', 'filter', 'style'}\n        largs = [arg.rstrip('s') for arg in argns.L]\n        if any(arg not in allowed_types for arg in largs):\n            parser.print_help(sys.stderr)\n            return 0\n        if not largs:\n            largs = allowed_types\n        if not argns.json:\n            for arg in largs:\n                _print_list(arg)\n        else:\n            _print_list_as_json(largs)\n        return 0\n\n    # handle ``pygmentize -H``\n    if argns.H:\n        if not is_only_option('H'):\n            parser.print_help(sys.stderr)\n            return 2\n        what, name = argns.H\n        if what not in ('lexer', 'formatter', 'filter'):\n            parser.print_help(sys.stderr)\n            return 2\n        return _print_help(what, name)\n\n    # parse -O options\n    parsed_opts = _parse_options(argns.O or [])\n\n    # parse -P options\n    for p_opt in argns.P or []:\n        try:\n            name, value = p_opt.split('=', 1)\n        except ValueError:\n            parsed_opts[p_opt] = True\n        else:\n            parsed_opts[name] = value\n\n    # encodings\n    inencoding = parsed_opts.get('inencoding', parsed_opts.get('encoding'))\n    outencoding = parsed_opts.get('outencoding', parsed_opts.get('encoding'))\n\n    # handle ``pygmentize -N``\n    if argns.N:\n        lexer = find_lexer_class_for_filename(argns.N)\n        if lexer is None:\n            lexer = TextLexer\n\n        print(lexer.aliases[0])\n        return 0\n\n    # handle ``pygmentize -C``\n    if argns.C:\n        inp = sys.stdin.buffer.read()\n        try:\n            lexer = guess_lexer(inp, inencoding=inencoding)\n        except ClassNotFound:\n            lexer = TextLexer\n\n        print(lexer.aliases[0])\n        return 0\n\n    # handle ``pygmentize -S``\n    S_opt = argns.S\n    a_opt = argns.a\n    if S_opt is not None:\n        f_opt = argns.f\n        if not f_opt:\n            parser.print_help(sys.stderr)\n            return 2\n        if argns.l or argns.INPUTFILE:\n            parser.print_help(sys.stderr)\n            return 2\n\n        try:\n            parsed_opts['style'] = S_opt\n            fmter = get_formatter_by_name(f_opt, **parsed_opts)\n        except ClassNotFound as err:\n            print(err, file=sys.stderr)\n            return 1\n\n        print(fmter.get_style_defs(a_opt or ''))\n        return 0\n\n    # if no -S is given, -a is not allowed\n    if argns.a is not None:\n        parser.print_help(sys.stderr)\n        return 2\n\n    # parse -F options\n    F_opts = _parse_filters(argns.F or [])\n\n    # -x: allow custom (eXternal) lexers and formatters\n    allow_custom_lexer_formatter = bool(argns.x)\n\n    # select lexer\n    lexer = None\n\n    # given by name?\n    lexername = argns.l\n    if lexername:\n        # custom lexer, located relative to user's cwd\n        if allow_custom_lexer_formatter and '.py' in lexername:\n            try:\n                filename = None\n                name = None\n                if ':' in lexername:\n                    filename, name = lexername.rsplit(':', 1)\n\n                    if '.py' in name:\n                        # This can happen on Windows: If the lexername is\n                        # C:\\lexer.py -- return to normal load path in that case\n                        name = None\n\n                if filename and name:\n                    lexer = load_lexer_from_file(filename, name,\n                                                 **parsed_opts)\n                else:\n                    lexer = load_lexer_from_file(lexername, **parsed_opts)\n            except ClassNotFound as err:\n                print('Error:', err, file=sys.stderr)\n                return 1\n        else:\n            try:\n                lexer = get_lexer_by_name(lexername, **parsed_opts)\n            except (OptionError, ClassNotFound) as err:\n                print('Error:', err, file=sys.stderr)\n                return 1\n\n    # read input code\n    code = None\n\n    if argns.INPUTFILE:\n        if argns.s:\n            print('Error: -s option not usable when input file specified',\n                  file=sys.stderr)\n            return 2\n\n        infn = argns.INPUTFILE\n        try:\n            with open(infn, 'rb') as infp:\n                code = infp.read()\n        except Exception as err:\n            print('Error: cannot read infile:', err, file=sys.stderr)\n            return 1\n        if not inencoding:\n            code, inencoding = guess_decode(code)\n\n        # do we have to guess the lexer?\n        if not lexer:\n            try:\n                lexer = get_lexer_for_filename(infn, code, **parsed_opts)\n            except ClassNotFound as err:\n                if argns.g:\n                    try:\n                        lexer = guess_lexer(code, **parsed_opts)\n                    except ClassNotFound:\n                        lexer = TextLexer(**parsed_opts)\n                else:\n                    print('Error:', err, file=sys.stderr)\n                    return 1\n            except OptionError as err:\n                print('Error:', err, file=sys.stderr)\n                return 1\n\n    elif not argns.s:  # treat stdin as full file (-s support is later)\n        # read code from terminal, always in binary mode since we want to\n        # decode ourselves and be tolerant with it\n        code = sys.stdin.buffer.read()  # use .buffer to get a binary stream\n        if not inencoding:\n            code, inencoding = guess_decode_from_terminal(code, sys.stdin)\n            # else the lexer will do the decoding\n        if not lexer:\n            try:\n                lexer = guess_lexer(code, **parsed_opts)\n            except ClassNotFound:\n                lexer = TextLexer(**parsed_opts)\n\n    else:  # -s option needs a lexer with -l\n        if not lexer:\n            print('Error: when using -s a lexer has to be selected with -l',\n                  file=sys.stderr)\n            return 2\n\n    # process filters\n    for fname, fopts in F_opts:\n        try:\n            lexer.add_filter(fname, **fopts)\n        except ClassNotFound as err:\n            print('Error:', err, file=sys.stderr)\n            return 1\n\n    # select formatter\n    outfn = argns.o\n    fmter = argns.f\n    if fmter:\n        # custom formatter, located relative to user's cwd\n        if allow_custom_lexer_formatter and '.py' in fmter:\n            try:\n                filename = None\n                name = None\n                if ':' in fmter:\n                    # Same logic as above for custom lexer\n                    filename, name = fmter.rsplit(':', 1)\n\n                    if '.py' in name:\n                        name = None\n\n                if filename and name:\n                    fmter = load_formatter_from_file(filename, name,\n                                                     **parsed_opts)\n                else:\n                    fmter = load_formatter_from_file(fmter, **parsed_opts)\n            except ClassNotFound as err:\n                print('Error:', err, file=sys.stderr)\n                return 1\n        else:\n            try:\n                fmter = get_formatter_by_name(fmter, **parsed_opts)\n            except (OptionError, ClassNotFound) as err:\n                print('Error:', err, file=sys.stderr)\n                return 1\n\n    if outfn:\n        if not fmter:\n            try:\n                fmter = get_formatter_for_filename(outfn, **parsed_opts)\n            except (OptionError, ClassNotFound) as err:\n                print('Error:', err, file=sys.stderr)\n                return 1\n        try:\n            outfile = open(outfn, 'wb')\n        except Exception as err:\n            print('Error: cannot open outfile:', err, file=sys.stderr)\n            return 1\n    else:\n        if not fmter:\n            if os.environ.get('COLORTERM','') in ('truecolor', '24bit'):\n                fmter = TerminalTrueColorFormatter(**parsed_opts)\n            elif '256' in os.environ.get('TERM', ''):\n                fmter = Terminal256Formatter(**parsed_opts)\n            else:\n                fmter = TerminalFormatter(**parsed_opts)\n        outfile = sys.stdout.buffer\n\n    # determine output encoding if not explicitly selected\n    if not outencoding:\n        if outfn:\n            # output file? use lexer encoding for now (can still be None)\n            fmter.encoding = inencoding\n        else:\n            # else use terminal encoding\n            fmter.encoding = terminal_encoding(sys.stdout)\n\n    # provide coloring under Windows, if possible\n    if not outfn and sys.platform in ('win32', 'cygwin') and \\\n       fmter.name in ('Terminal', 'Terminal256'):  # pragma: no cover\n        # unfortunately colorama doesn't support binary streams on Py3\n        outfile = UnclosingTextIOWrapper(outfile, encoding=fmter.encoding)\n        fmter.encoding = None\n        try:\n            import colorama.initialise\n        except ImportError:\n            pass\n        else:\n            outfile = colorama.initialise.wrap_stream(\n                outfile, convert=None, strip=None, autoreset=False, wrap=True)\n\n    # When using the LaTeX formatter and the option `escapeinside` is\n    # specified, we need a special lexer which collects escaped text\n    # before running the chosen language lexer.\n    escapeinside = parsed_opts.get('escapeinside', '')\n    if len(escapeinside) == 2 and isinstance(fmter, LatexFormatter):\n        left = escapeinside[0]\n        right = escapeinside[1]\n        lexer = LatexEmbeddedLexer(left, right, lexer)\n\n    # ... and do it!\n    if not argns.s:\n        # process whole input as per normal...\n        try:\n            highlight(code, lexer, fmter, outfile)\n        finally:\n            if outfn:\n                outfile.close()\n        return 0\n    else:\n        # line by line processing of stdin (eg: for 'tail -f')...\n        try:\n            while 1:\n                line = sys.stdin.buffer.readline()\n                if not line:\n                    break\n                if not inencoding:\n                    line = guess_decode_from_terminal(line, sys.stdin)[0]\n                highlight(line, lexer, fmter, outfile)\n                if hasattr(outfile, 'flush'):\n                    outfile.flush()\n            return 0\n        except KeyboardInterrupt:  # pragma: no cover\n            return 0\n        finally:\n            if outfn:\n                outfile.close()\n\n\nclass HelpFormatter(argparse.HelpFormatter):\n    def __init__(self, prog, indent_increment=2, max_help_position=16, width=None):\n        if width is None:\n            try:\n                width = shutil.get_terminal_size().columns - 2\n            except Exception:\n                pass\n        argparse.HelpFormatter.__init__(self, prog, indent_increment,\n                                        max_help_position, width)\n\n\ndef main(args=sys.argv):\n    \"\"\"\n    Main command line entry point.\n    \"\"\"\n    desc = \"Highlight an input file and write the result to an output file.\"\n    parser = argparse.ArgumentParser(description=desc, add_help=False,\n                                     formatter_class=HelpFormatter)\n\n    operation = parser.add_argument_group('Main operation')\n    lexersel = operation.add_mutually_exclusive_group()\n    lexersel.add_argument(\n        '-l', metavar='LEXER',\n        help='Specify the lexer to use.  (Query names with -L.)  If not '\n        'given and -g is not present, the lexer is guessed from the filename.')\n    lexersel.add_argument(\n        '-g', action='store_true',\n        help='Guess the lexer from the file contents, or pass through '\n        'as plain text if nothing can be guessed.')\n    operation.add_argument(\n        '-F', metavar='FILTER[:options]', action='append',\n        help='Add a filter to the token stream.  (Query names with -L.) '\n        'Filter options are given after a colon if necessary.')\n    operation.add_argument(\n        '-f', metavar='FORMATTER',\n        help='Specify the formatter to use.  (Query names with -L.) '\n        'If not given, the formatter is guessed from the output filename, '\n        'and defaults to the terminal formatter if the output is to the '\n        'terminal or an unknown file extension.')\n    operation.add_argument(\n        '-O', metavar='OPTION=value[,OPTION=value,...]', action='append',\n        help='Give options to the lexer and formatter as a comma-separated '\n        'list of key-value pairs. '\n        'Example: `-O bg=light,python=cool`.')\n    operation.add_argument(\n        '-P', metavar='OPTION=value', action='append',\n        help='Give a single option to the lexer and formatter - with this '\n        'you can pass options whose value contains commas and equal signs. '\n        'Example: `-P \"heading=Pygments, the Python highlighter\"`.')\n    operation.add_argument(\n        '-o', metavar='OUTPUTFILE',\n        help='Where to write the output.  Defaults to standard output.')\n\n    operation.add_argument(\n        'INPUTFILE', nargs='?',\n        help='Where to read the input.  Defaults to standard input.')\n\n    flags = parser.add_argument_group('Operation flags')\n    flags.add_argument(\n        '-v', action='store_true',\n        help='Print a detailed traceback on unhandled exceptions, which '\n        'is useful for debugging and bug reports.')\n    flags.add_argument(\n        '-s', action='store_true',\n        help='Process lines one at a time until EOF, rather than waiting to '\n        'process the entire file.  This only works for stdin, only for lexers '\n        'with no line-spanning constructs, and is intended for streaming '\n        'input such as you get from `tail -f`. '\n        'Example usage: `tail -f sql.log | pygmentize -s -l sql`.')\n    flags.add_argument(\n        '-x', action='store_true',\n        help='Allow custom lexers and formatters to be loaded from a .py file '\n        'relative to the current working directory. For example, '\n        '`-l ./customlexer.py -x`. By default, this option expects a file '\n        'with a class named CustomLexer or CustomFormatter; you can also '\n        'specify your own class name with a colon (`-l ./lexer.py:MyLexer`). '\n        'Users should be very careful not to use this option with untrusted '\n        'files, because it will import and run them.')\n    flags.add_argument('--json', help='Output as JSON. This can '\n        'be only used in conjunction with -L.',\n        default=False,\n        action='store_true')\n\n    special_modes_group = parser.add_argument_group(\n        'Special modes - do not do any highlighting')\n    special_modes = special_modes_group.add_mutually_exclusive_group()\n    special_modes.add_argument(\n        '-S', metavar='STYLE -f formatter',\n        help='Print style definitions for STYLE for a formatter '\n        'given with -f. The argument given by -a is formatter '\n        'dependent.')\n    special_modes.add_argument(\n        '-L', nargs='*', metavar='WHAT',\n        help='List lexers, formatters, styles or filters -- '\n        'give additional arguments for the thing(s) you want to list '\n        '(e.g. \"styles\"), or omit them to list everything.')\n    special_modes.add_argument(\n        '-N', metavar='FILENAME',\n        help='Guess and print out a lexer name based solely on the given '\n        'filename. Does not take input or highlight anything. If no specific '\n        'lexer can be determined, \"text\" is printed.')\n    special_modes.add_argument(\n        '-C', action='store_true',\n        help='Like -N, but print out a lexer name based solely on '\n        'a given content from standard input.')\n    special_modes.add_argument(\n        '-H', action='store', nargs=2, metavar=('NAME', 'TYPE'),\n        help='Print detailed help for the object <name> of type <type>, '\n        'where <type> is one of \"lexer\", \"formatter\" or \"filter\".')\n    special_modes.add_argument(\n        '-V', action='store_true',\n        help='Print the package version.')\n    special_modes.add_argument(\n        '-h', '--help', action='store_true',\n        help='Print this help.')\n    special_modes_group.add_argument(\n        '-a', metavar='ARG',\n        help='Formatter-specific additional argument for the -S (print '\n        'style sheet) mode.')\n\n    argns = parser.parse_args(args[1:])\n\n    try:\n        return main_inner(parser, argns)\n    except BrokenPipeError:\n        # someone closed our stdout, e.g. by quitting a pager.\n        return 0\n    except Exception:\n        if argns.v:\n            print(file=sys.stderr)\n            print('*' * 65, file=sys.stderr)\n            print('An unhandled exception occurred while highlighting.',\n                  file=sys.stderr)\n            print('Please report the whole traceback to the issue tracker at',\n                  file=sys.stderr)\n            print('<https://github.com/pygments/pygments/issues>.',\n                  file=sys.stderr)\n            print('*' * 65, file=sys.stderr)\n            print(file=sys.stderr)\n            raise\n        import traceback\n        info = traceback.format_exception(*sys.exc_info())\n        msg = info[-1].strip()\n        if len(info) >= 3:\n            # extract relevant file and position info\n            msg += '\\n   (f{})'.format(info[-2].split('\\n')[0].strip()[1:])\n        print(file=sys.stderr)\n        print('*** Error while highlighting:', file=sys.stderr)\n        print(msg, file=sys.stderr)\n        print('*** If this is a bug you want to report, please rerun with -v.',\n              file=sys.stderr)\n        return 1\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/pygments/console.py","size":1718,"sha1":"cdbac78da7cfe684c72f1ea38943a1e66e173c07","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\n    pygments.console\n    ~~~~~~~~~~~~~~~~\n\n    Format colored console output.\n\n    :copyright: Copyright 2006-2024 by the Pygments team, see AUTHORS.\n    :license: BSD, see LICENSE for details.\n\"\"\"\n\nesc = \"\\x1b[\"\n\ncodes = {}\ncodes[\"\"] = \"\"\ncodes[\"reset\"] = esc + \"39;49;00m\"\n\ncodes[\"bold\"] = esc + \"01m\"\ncodes[\"faint\"] = esc + \"02m\"\ncodes[\"standout\"] = esc + \"03m\"\ncodes[\"underline\"] = esc + \"04m\"\ncodes[\"blink\"] = esc + \"05m\"\ncodes[\"overline\"] = esc + \"06m\"\n\ndark_colors = [\"black\", \"red\", \"green\", \"yellow\", \"blue\",\n               \"magenta\", \"cyan\", \"gray\"]\nlight_colors = [\"brightblack\", \"brightred\", \"brightgreen\", \"brightyellow\", \"brightblue\",\n                \"brightmagenta\", \"brightcyan\", \"white\"]\n\nx = 30\nfor dark, light in zip(dark_colors, light_colors):\n    codes[dark] = esc + \"%im\" % x\n    codes[light] = esc + \"%im\" % (60 + x)\n    x += 1\n\ndel dark, light, x\n\ncodes[\"white\"] = codes[\"bold\"]\n\n\ndef reset_color():\n    return codes[\"reset\"]\n\n\ndef colorize(color_key, text):\n    return codes[color_key] + text + codes[\"reset\"]\n\n\ndef ansiformat(attr, text):\n    \"\"\"\n    Format ``text`` with a color and/or some attributes::\n\n        color       normal color\n        *color*     bold color\n        _color_     underlined color\n        +color+     blinking color\n    \"\"\"\n    result = []\n    if attr[:1] == attr[-1:] == '+':\n        result.append(codes['blink'])\n        attr = attr[1:-1]\n    if attr[:1] == attr[-1:] == '*':\n        result.append(codes['bold'])\n        attr = attr[1:-1]\n    if attr[:1] == attr[-1:] == '_':\n        result.append(codes['underline'])\n        attr = attr[1:-1]\n    result.append(codes[attr])\n    result.append(text)\n    result.append(codes['reset'])\n    return ''.join(result)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/pygments/filter.py","size":1910,"sha1":"88e2f80e7420d3385dffc4d590c8a7746d96fb47","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\n    pygments.filter\n    ~~~~~~~~~~~~~~~\n\n    Module that implements the default filter.\n\n    :copyright: Copyright 2006-2024 by the Pygments team, see AUTHORS.\n    :license: BSD, see LICENSE for details.\n\"\"\"\n\n\ndef apply_filters(stream, filters, lexer=None):\n    \"\"\"\n    Use this method to apply an iterable of filters to\n    a stream. If lexer is given it's forwarded to the\n    filter, otherwise the filter receives `None`.\n    \"\"\"\n    def _apply(filter_, stream):\n        yield from filter_.filter(lexer, stream)\n    for filter_ in filters:\n        stream = _apply(filter_, stream)\n    return stream\n\n\ndef simplefilter(f):\n    \"\"\"\n    Decorator that converts a function into a filter::\n\n        @simplefilter\n        def lowercase(self, lexer, stream, options):\n            for ttype, value in stream:\n                yield ttype, value.lower()\n    \"\"\"\n    return type(f.__name__, (FunctionFilter,), {\n        '__module__': getattr(f, '__module__'),\n        '__doc__': f.__doc__,\n        'function': f,\n    })\n\n\nclass Filter:\n    \"\"\"\n    Default filter. Subclass this class or use the `simplefilter`\n    decorator to create own filters.\n    \"\"\"\n\n    def __init__(self, **options):\n        self.options = options\n\n    def filter(self, lexer, stream):\n        raise NotImplementedError()\n\n\nclass FunctionFilter(Filter):\n    \"\"\"\n    Abstract class used by `simplefilter` to create simple\n    function filters on the fly. The `simplefilter` decorator\n    automatically creates subclasses of this class for\n    functions passed to it.\n    \"\"\"\n    function = None\n\n    def __init__(self, **options):\n        if not hasattr(self, 'function'):\n            raise TypeError(f'{self.__class__.__name__!r} used without bound function')\n        Filter.__init__(self, **options)\n\n    def filter(self, lexer, stream):\n        # pylint: disable=not-callable\n        yield from self.function(lexer, stream, self.options)\n"}]}