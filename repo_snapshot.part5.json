{"generated_at":"2025-08-17T20:04:18.057896Z","root":"/home/runner/workspace","git":{"head":"7b7135163eb4227ef98e4c2d7b4ab78ea306bd73","branch":"main","status":" M corrections.db\n?? app_changes.json\n?? export_changes.py\n"},"filters":{"git_range":null,"since":null,"include_ext":[".cfg",".css",".env",".htm",".html",".ini",".jinja",".jinja2",".js",".json",".md",".py",".toml",".ts",".yaml",".yml"],"exclude_dirs":[".git",".ipynb_checkpoints",".mypy_cache",".pytest_cache",".pythonlibs",".venv","__pycache__","cache","chroma_db","data/exports","node_modules","venv"],"exclude_globs":["*.bmp","*.db","*.feather","*.gif","*.gz","*.ico","*.jpeg","*.jpg","*.jsonl","*.lock","*.log","*.parquet","*.png","*.sqlite","*.sqlite3","*.tar","*.webp","*.zip"],"max_file_bytes":400000},"summary":{"file_count":876,"total_bytes":9265289},"files":[{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/_emoji_codes.py","size":140235,"sha1":"668eaff13635a6a4368e1445d2e1dce7fdca6b7b","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"EMOJI = {\n    \"1st_place_medal\": \"ğŸ¥‡\",\n    \"2nd_place_medal\": \"ğŸ¥ˆ\",\n    \"3rd_place_medal\": \"ğŸ¥‰\",\n    \"ab_button_(blood_type)\": \"ğŸ†\",\n    \"atm_sign\": \"ğŸ§\",\n    \"a_button_(blood_type)\": \"ğŸ…°\",\n    \"afghanistan\": \"ğŸ‡¦ğŸ‡«\",\n    \"albania\": \"ğŸ‡¦ğŸ‡±\",\n    \"algeria\": \"ğŸ‡©ğŸ‡¿\",\n    \"american_samoa\": \"ğŸ‡¦ğŸ‡¸\",\n    \"andorra\": \"ğŸ‡¦ğŸ‡©\",\n    \"angola\": \"ğŸ‡¦ğŸ‡´\",\n    \"anguilla\": \"ğŸ‡¦ğŸ‡®\",\n    \"antarctica\": \"ğŸ‡¦ğŸ‡¶\",\n    \"antigua_&_barbuda\": \"ğŸ‡¦ğŸ‡¬\",\n    \"aquarius\": \"â™’\",\n    \"argentina\": \"ğŸ‡¦ğŸ‡·\",\n    \"aries\": \"â™ˆ\",\n    \"armenia\": \"ğŸ‡¦ğŸ‡²\",\n    \"aruba\": \"ğŸ‡¦ğŸ‡¼\",\n    \"ascension_island\": \"ğŸ‡¦ğŸ‡¨\",\n    \"australia\": \"ğŸ‡¦ğŸ‡º\",\n    \"austria\": \"ğŸ‡¦ğŸ‡¹\",\n    \"azerbaijan\": \"ğŸ‡¦ğŸ‡¿\",\n    \"back_arrow\": \"ğŸ”™\",\n    \"b_button_(blood_type)\": \"ğŸ…±\",\n    \"bahamas\": \"ğŸ‡§ğŸ‡¸\",\n    \"bahrain\": \"ğŸ‡§ğŸ‡­\",\n    \"bangladesh\": \"ğŸ‡§ğŸ‡©\",\n    \"barbados\": \"ğŸ‡§ğŸ‡§\",\n    \"belarus\": \"ğŸ‡§ğŸ‡¾\",\n    \"belgium\": \"ğŸ‡§ğŸ‡ª\",\n    \"belize\": \"ğŸ‡§ğŸ‡¿\",\n    \"benin\": \"ğŸ‡§ğŸ‡¯\",\n    \"bermuda\": \"ğŸ‡§ğŸ‡²\",\n    \"bhutan\": \"ğŸ‡§ğŸ‡¹\",\n    \"bolivia\": \"ğŸ‡§ğŸ‡´\",\n    \"bosnia_&_herzegovina\": \"ğŸ‡§ğŸ‡¦\",\n    \"botswana\": \"ğŸ‡§ğŸ‡¼\",\n    \"bouvet_island\": \"ğŸ‡§ğŸ‡»\",\n    \"brazil\": \"ğŸ‡§ğŸ‡·\",\n    \"british_indian_ocean_territory\": \"ğŸ‡®ğŸ‡´\",\n    \"british_virgin_islands\": \"ğŸ‡»ğŸ‡¬\",\n    \"brunei\": \"ğŸ‡§ğŸ‡³\",\n    \"bulgaria\": \"ğŸ‡§ğŸ‡¬\",\n    \"burkina_faso\": \"ğŸ‡§ğŸ‡«\",\n    \"burundi\": \"ğŸ‡§ğŸ‡®\",\n    \"cl_button\": \"ğŸ†‘\",\n    \"cool_button\": \"ğŸ†’\",\n    \"cambodia\": \"ğŸ‡°ğŸ‡­\",\n    \"cameroon\": \"ğŸ‡¨ğŸ‡²\",\n    \"canada\": \"ğŸ‡¨ğŸ‡¦\",\n    \"canary_islands\": \"ğŸ‡®ğŸ‡¨\",\n    \"cancer\": \"â™‹\",\n    \"cape_verde\": \"ğŸ‡¨ğŸ‡»\",\n    \"capricorn\": \"â™‘\",\n    \"caribbean_netherlands\": \"ğŸ‡§ğŸ‡¶\",\n    \"cayman_islands\": \"ğŸ‡°ğŸ‡¾\",\n    \"central_african_republic\": \"ğŸ‡¨ğŸ‡«\",\n    \"ceuta_&_melilla\": \"ğŸ‡ªğŸ‡¦\",\n    \"chad\": \"ğŸ‡¹ğŸ‡©\",\n    \"chile\": \"ğŸ‡¨ğŸ‡±\",\n    \"china\": \"ğŸ‡¨ğŸ‡³\",\n    \"christmas_island\": \"ğŸ‡¨ğŸ‡½\",\n    \"christmas_tree\": \"ğŸ„\",\n    \"clipperton_island\": \"ğŸ‡¨ğŸ‡µ\",\n    \"cocos_(keeling)_islands\": \"ğŸ‡¨ğŸ‡¨\",\n    \"colombia\": \"ğŸ‡¨ğŸ‡´\",\n    \"comoros\": \"ğŸ‡°ğŸ‡²\",\n    \"congo_-_brazzaville\": \"ğŸ‡¨ğŸ‡¬\",\n    \"congo_-_kinshasa\": \"ğŸ‡¨ğŸ‡©\",\n    \"cook_islands\": \"ğŸ‡¨ğŸ‡°\",\n    \"costa_rica\": \"ğŸ‡¨ğŸ‡·\",\n    \"croatia\": \"ğŸ‡­ğŸ‡·\",\n    \"cuba\": \"ğŸ‡¨ğŸ‡º\",\n    \"curaÃ§ao\": \"ğŸ‡¨ğŸ‡¼\",\n    \"cyprus\": \"ğŸ‡¨ğŸ‡¾\",\n    \"czechia\": \"ğŸ‡¨ğŸ‡¿\",\n    \"cÃ´te_dâ€™ivoire\": \"ğŸ‡¨ğŸ‡®\",\n    \"denmark\": \"ğŸ‡©ğŸ‡°\",\n    \"diego_garcia\": \"ğŸ‡©ğŸ‡¬\",\n    \"djibouti\": \"ğŸ‡©ğŸ‡¯\",\n    \"dominica\": \"ğŸ‡©ğŸ‡²\",\n    \"dominican_republic\": \"ğŸ‡©ğŸ‡´\",\n    \"end_arrow\": \"ğŸ”š\",\n    \"ecuador\": \"ğŸ‡ªğŸ‡¨\",\n    \"egypt\": \"ğŸ‡ªğŸ‡¬\",\n    \"el_salvador\": \"ğŸ‡¸ğŸ‡»\",\n    \"england\": \"ğŸ´\\U000e0067\\U000e0062\\U000e0065\\U000e006e\\U000e0067\\U000e007f\",\n    \"equatorial_guinea\": \"ğŸ‡¬ğŸ‡¶\",\n    \"eritrea\": \"ğŸ‡ªğŸ‡·\",\n    \"estonia\": \"ğŸ‡ªğŸ‡ª\",\n    \"ethiopia\": \"ğŸ‡ªğŸ‡¹\",\n    \"european_union\": \"ğŸ‡ªğŸ‡º\",\n    \"free_button\": \"ğŸ†“\",\n    \"falkland_islands\": \"ğŸ‡«ğŸ‡°\",\n    \"faroe_islands\": \"ğŸ‡«ğŸ‡´\",\n    \"fiji\": \"ğŸ‡«ğŸ‡¯\",\n    \"finland\": \"ğŸ‡«ğŸ‡®\",\n    \"france\": \"ğŸ‡«ğŸ‡·\",\n    \"french_guiana\": \"ğŸ‡¬ğŸ‡«\",\n    \"french_polynesia\": \"ğŸ‡µğŸ‡«\",\n    \"french_southern_territories\": \"ğŸ‡¹ğŸ‡«\",\n    \"gabon\": \"ğŸ‡¬ğŸ‡¦\",\n    \"gambia\": \"ğŸ‡¬ğŸ‡²\",\n    \"gemini\": \"â™Š\",\n    \"georgia\": \"ğŸ‡¬ğŸ‡ª\",\n    \"germany\": \"ğŸ‡©ğŸ‡ª\",\n    \"ghana\": \"ğŸ‡¬ğŸ‡­\",\n    \"gibraltar\": \"ğŸ‡¬ğŸ‡®\",\n    \"greece\": \"ğŸ‡¬ğŸ‡·\",\n    \"greenland\": \"ğŸ‡¬ğŸ‡±\",\n    \"grenada\": \"ğŸ‡¬ğŸ‡©\",\n    \"guadeloupe\": \"ğŸ‡¬ğŸ‡µ\",\n    \"guam\": \"ğŸ‡¬ğŸ‡º\",\n    \"guatemala\": \"ğŸ‡¬ğŸ‡¹\",\n    \"guernsey\": \"ğŸ‡¬ğŸ‡¬\",\n    \"guinea\": \"ğŸ‡¬ğŸ‡³\",\n    \"guinea-bissau\": \"ğŸ‡¬ğŸ‡¼\",\n    \"guyana\": \"ğŸ‡¬ğŸ‡¾\",\n    \"haiti\": \"ğŸ‡­ğŸ‡¹\",\n    \"heard_&_mcdonald_islands\": \"ğŸ‡­ğŸ‡²\",\n    \"honduras\": \"ğŸ‡­ğŸ‡³\",\n    \"hong_kong_sar_china\": \"ğŸ‡­ğŸ‡°\",\n    \"hungary\": \"ğŸ‡­ğŸ‡º\",\n    \"id_button\": \"ğŸ†”\",\n    \"iceland\": \"ğŸ‡®ğŸ‡¸\",\n    \"india\": \"ğŸ‡®ğŸ‡³\",\n    \"indonesia\": \"ğŸ‡®ğŸ‡©\",\n    \"iran\": \"ğŸ‡®ğŸ‡·\",\n    \"iraq\": \"ğŸ‡®ğŸ‡¶\",\n    \"ireland\": \"ğŸ‡®ğŸ‡ª\",\n    \"isle_of_man\": \"ğŸ‡®ğŸ‡²\",\n    \"israel\": \"ğŸ‡®ğŸ‡±\",\n    \"italy\": \"ğŸ‡®ğŸ‡¹\",\n    \"jamaica\": \"ğŸ‡¯ğŸ‡²\",\n    \"japan\": \"ğŸ—¾\",\n    \"japanese_acceptable_button\": \"ğŸ‰‘\",\n    \"japanese_application_button\": \"ğŸˆ¸\",\n    \"japanese_bargain_button\": \"ğŸ‰\",\n    \"japanese_castle\": \"ğŸ¯\",\n    \"japanese_congratulations_button\": \"ãŠ—\",\n    \"japanese_discount_button\": \"ğŸˆ¹\",\n    \"japanese_dolls\": \"ğŸ\",\n    \"japanese_free_of_charge_button\": \"ğŸˆš\",\n    \"japanese_here_button\": \"ğŸˆ\",\n    \"japanese_monthly_amount_button\": \"ğŸˆ·\",\n    \"japanese_no_vacancy_button\": \"ğŸˆµ\",\n    \"japanese_not_free_of_charge_button\": \"ğŸˆ¶\",\n    \"japanese_open_for_business_button\": \"ğŸˆº\",\n    \"japanese_passing_grade_button\": \"ğŸˆ´\",\n    \"japanese_post_office\": \"ğŸ£\",\n    \"japanese_prohibited_button\": \"ğŸˆ²\",\n    \"japanese_reserved_button\": \"ğŸˆ¯\",\n    \"japanese_secret_button\": \"ãŠ™\",\n    \"japanese_service_charge_button\": \"ğŸˆ‚\",\n    \"japanese_symbol_for_beginner\": \"ğŸ”°\",\n    \"japanese_vacancy_button\": \"ğŸˆ³\",\n    \"jersey\": \"ğŸ‡¯ğŸ‡ª\",\n    \"jordan\": \"ğŸ‡¯ğŸ‡´\",\n    \"kazakhstan\": \"ğŸ‡°ğŸ‡¿\",\n    \"kenya\": \"ğŸ‡°ğŸ‡ª\",\n    \"kiribati\": \"ğŸ‡°ğŸ‡®\",\n    \"kosovo\": \"ğŸ‡½ğŸ‡°\",\n    \"kuwait\": \"ğŸ‡°ğŸ‡¼\",\n    \"kyrgyzstan\": \"ğŸ‡°ğŸ‡¬\",\n    \"laos\": \"ğŸ‡±ğŸ‡¦\",\n    \"latvia\": \"ğŸ‡±ğŸ‡»\",\n    \"lebanon\": \"ğŸ‡±ğŸ‡§\",\n    \"leo\": \"â™Œ\",\n    \"lesotho\": \"ğŸ‡±ğŸ‡¸\",\n    \"liberia\": \"ğŸ‡±ğŸ‡·\",\n    \"libra\": \"â™\",\n    \"libya\": \"ğŸ‡±ğŸ‡¾\",\n    \"liechtenstein\": \"ğŸ‡±ğŸ‡®\",\n    \"lithuania\": \"ğŸ‡±ğŸ‡¹\",\n    \"luxembourg\": \"ğŸ‡±ğŸ‡º\",\n    \"macau_sar_china\": \"ğŸ‡²ğŸ‡´\",\n    \"macedonia\": \"ğŸ‡²ğŸ‡°\",\n    \"madagascar\": \"ğŸ‡²ğŸ‡¬\",\n    \"malawi\": \"ğŸ‡²ğŸ‡¼\",\n    \"malaysia\": \"ğŸ‡²ğŸ‡¾\",\n    \"maldives\": \"ğŸ‡²ğŸ‡»\",\n    \"mali\": \"ğŸ‡²ğŸ‡±\",\n    \"malta\": \"ğŸ‡²ğŸ‡¹\",\n    \"marshall_islands\": \"ğŸ‡²ğŸ‡­\",\n    \"martinique\": \"ğŸ‡²ğŸ‡¶\",\n    \"mauritania\": \"ğŸ‡²ğŸ‡·\",\n    \"mauritius\": \"ğŸ‡²ğŸ‡º\",\n    \"mayotte\": \"ğŸ‡¾ğŸ‡¹\",\n    \"mexico\": \"ğŸ‡²ğŸ‡½\",\n    \"micronesia\": \"ğŸ‡«ğŸ‡²\",\n    \"moldova\": \"ğŸ‡²ğŸ‡©\",\n    \"monaco\": \"ğŸ‡²ğŸ‡¨\",\n    \"mongolia\": \"ğŸ‡²ğŸ‡³\",\n    \"montenegro\": \"ğŸ‡²ğŸ‡ª\",\n    \"montserrat\": \"ğŸ‡²ğŸ‡¸\",\n    \"morocco\": \"ğŸ‡²ğŸ‡¦\",\n    \"mozambique\": \"ğŸ‡²ğŸ‡¿\",\n    \"mrs._claus\": \"ğŸ¤¶\",\n    \"mrs._claus_dark_skin_tone\": \"ğŸ¤¶ğŸ¿\",\n    \"mrs._claus_light_skin_tone\": \"ğŸ¤¶ğŸ»\",\n    \"mrs._claus_medium-dark_skin_tone\": \"ğŸ¤¶ğŸ¾\",\n    \"mrs._claus_medium-light_skin_tone\": \"ğŸ¤¶ğŸ¼\",\n    \"mrs._claus_medium_skin_tone\": \"ğŸ¤¶ğŸ½\",\n    \"myanmar_(burma)\": \"ğŸ‡²ğŸ‡²\",\n    \"new_button\": \"ğŸ†•\",\n    \"ng_button\": \"ğŸ†–\",\n    \"namibia\": \"ğŸ‡³ğŸ‡¦\",\n    \"nauru\": \"ğŸ‡³ğŸ‡·\",\n    \"nepal\": \"ğŸ‡³ğŸ‡µ\",\n    \"netherlands\": \"ğŸ‡³ğŸ‡±\",\n    \"new_caledonia\": \"ğŸ‡³ğŸ‡¨\",\n    \"new_zealand\": \"ğŸ‡³ğŸ‡¿\",\n    \"nicaragua\": \"ğŸ‡³ğŸ‡®\",\n    \"niger\": \"ğŸ‡³ğŸ‡ª\",\n    \"nigeria\": \"ğŸ‡³ğŸ‡¬\",\n    \"niue\": \"ğŸ‡³ğŸ‡º\",\n    \"norfolk_island\": \"ğŸ‡³ğŸ‡«\",\n    \"north_korea\": \"ğŸ‡°ğŸ‡µ\",\n    \"northern_mariana_islands\": \"ğŸ‡²ğŸ‡µ\",\n    \"norway\": \"ğŸ‡³ğŸ‡´\",\n    \"ok_button\": \"ğŸ†—\",\n    \"ok_hand\": \"ğŸ‘Œ\",\n    \"ok_hand_dark_skin_tone\": \"ğŸ‘ŒğŸ¿\",\n    \"ok_hand_light_skin_tone\": \"ğŸ‘ŒğŸ»\",\n    \"ok_hand_medium-dark_skin_tone\": \"ğŸ‘ŒğŸ¾\",\n    \"ok_hand_medium-light_skin_tone\": \"ğŸ‘ŒğŸ¼\",\n    \"ok_hand_medium_skin_tone\": \"ğŸ‘ŒğŸ½\",\n    \"on!_arrow\": \"ğŸ”›\",\n    \"o_button_(blood_type)\": \"ğŸ…¾\",\n    \"oman\": \"ğŸ‡´ğŸ‡²\",\n    \"ophiuchus\": \"â›\",\n    \"p_button\": \"ğŸ…¿\",\n    \"pakistan\": \"ğŸ‡µğŸ‡°\",\n    \"palau\": \"ğŸ‡µğŸ‡¼\",\n    \"palestinian_territories\": \"ğŸ‡µğŸ‡¸\",\n    \"panama\": \"ğŸ‡µğŸ‡¦\",\n    \"papua_new_guinea\": \"ğŸ‡µğŸ‡¬\",\n    \"paraguay\": \"ğŸ‡µğŸ‡¾\",\n    \"peru\": \"ğŸ‡µğŸ‡ª\",\n    \"philippines\": \"ğŸ‡µğŸ‡­\",\n    \"pisces\": \"â™“\",\n    \"pitcairn_islands\": \"ğŸ‡µğŸ‡³\",\n    \"poland\": \"ğŸ‡µğŸ‡±\",\n    \"portugal\": \"ğŸ‡µğŸ‡¹\",\n    \"puerto_rico\": \"ğŸ‡µğŸ‡·\",\n    \"qatar\": \"ğŸ‡¶ğŸ‡¦\",\n    \"romania\": \"ğŸ‡·ğŸ‡´\",\n    \"russia\": \"ğŸ‡·ğŸ‡º\",\n    \"rwanda\": \"ğŸ‡·ğŸ‡¼\",\n    \"rÃ©union\": \"ğŸ‡·ğŸ‡ª\",\n    \"soon_arrow\": \"ğŸ”œ\",\n    \"sos_button\": \"ğŸ†˜\",\n    \"sagittarius\": \"â™\",\n    \"samoa\": \"ğŸ‡¼ğŸ‡¸\",\n    \"san_marino\": \"ğŸ‡¸ğŸ‡²\",\n    \"santa_claus\": \"ğŸ…\",\n    \"santa_claus_dark_skin_tone\": \"ğŸ…ğŸ¿\",\n    \"santa_claus_light_skin_tone\": \"ğŸ…ğŸ»\",\n    \"santa_claus_medium-dark_skin_tone\": \"ğŸ…ğŸ¾\",\n    \"santa_claus_medium-light_skin_tone\": \"ğŸ…ğŸ¼\",\n    \"santa_claus_medium_skin_tone\": \"ğŸ…ğŸ½\",\n    \"saudi_arabia\": \"ğŸ‡¸ğŸ‡¦\",\n    \"scorpio\": \"â™\",\n    \"scotland\": \"ğŸ´\\U000e0067\\U000e0062\\U000e0073\\U000e0063\\U000e0074\\U000e007f\",\n    \"senegal\": \"ğŸ‡¸ğŸ‡³\",\n    \"serbia\": \"ğŸ‡·ğŸ‡¸\",\n    \"seychelles\": \"ğŸ‡¸ğŸ‡¨\",\n    \"sierra_leone\": \"ğŸ‡¸ğŸ‡±\",\n    \"singapore\": \"ğŸ‡¸ğŸ‡¬\",\n    \"sint_maarten\": \"ğŸ‡¸ğŸ‡½\",\n    \"slovakia\": \"ğŸ‡¸ğŸ‡°\",\n    \"slovenia\": \"ğŸ‡¸ğŸ‡®\",\n    \"solomon_islands\": \"ğŸ‡¸ğŸ‡§\",\n    \"somalia\": \"ğŸ‡¸ğŸ‡´\",\n    \"south_africa\": \"ğŸ‡¿ğŸ‡¦\",\n    \"south_georgia_&_south_sandwich_islands\": \"ğŸ‡¬ğŸ‡¸\",\n    \"south_korea\": \"ğŸ‡°ğŸ‡·\",\n    \"south_sudan\": \"ğŸ‡¸ğŸ‡¸\",\n    \"spain\": \"ğŸ‡ªğŸ‡¸\",\n    \"sri_lanka\": \"ğŸ‡±ğŸ‡°\",\n    \"st._barthÃ©lemy\": \"ğŸ‡§ğŸ‡±\",\n    \"st._helena\": \"ğŸ‡¸ğŸ‡­\",\n    \"st._kitts_&_nevis\": \"ğŸ‡°ğŸ‡³\",\n    \"st._lucia\": \"ğŸ‡±ğŸ‡¨\",\n    \"st._martin\": \"ğŸ‡²ğŸ‡«\",\n    \"st._pierre_&_miquelon\": \"ğŸ‡µğŸ‡²\",\n    \"st._vincent_&_grenadines\": \"ğŸ‡»ğŸ‡¨\",\n    \"statue_of_liberty\": \"ğŸ—½\",\n    \"sudan\": \"ğŸ‡¸ğŸ‡©\",\n    \"suriname\": \"ğŸ‡¸ğŸ‡·\",\n    \"svalbard_&_jan_mayen\": \"ğŸ‡¸ğŸ‡¯\",\n    \"swaziland\": \"ğŸ‡¸ğŸ‡¿\",\n    \"sweden\": \"ğŸ‡¸ğŸ‡ª\",\n    \"switzerland\": \"ğŸ‡¨ğŸ‡­\",\n    \"syria\": \"ğŸ‡¸ğŸ‡¾\",\n    \"sÃ£o_tomÃ©_&_prÃ­ncipe\": \"ğŸ‡¸ğŸ‡¹\",\n    \"t-rex\": \"ğŸ¦–\",\n    \"top_arrow\": \"ğŸ”\",\n    \"taiwan\": \"ğŸ‡¹ğŸ‡¼\",\n    \"tajikistan\": \"ğŸ‡¹ğŸ‡¯\",\n    \"tanzania\": \"ğŸ‡¹ğŸ‡¿\",\n    \"taurus\": \"â™‰\",\n    \"thailand\": \"ğŸ‡¹ğŸ‡­\",\n    \"timor-leste\": \"ğŸ‡¹ğŸ‡±\",\n    \"togo\": \"ğŸ‡¹ğŸ‡¬\",\n    \"tokelau\": \"ğŸ‡¹ğŸ‡°\",\n    \"tokyo_tower\": \"ğŸ—¼\",\n    \"tonga\": \"ğŸ‡¹ğŸ‡´\",\n    \"trinidad_&_tobago\": \"ğŸ‡¹ğŸ‡¹\",\n    \"tristan_da_cunha\": \"ğŸ‡¹ğŸ‡¦\",\n    \"tunisia\": \"ğŸ‡¹ğŸ‡³\",\n    \"turkey\": \"ğŸ¦ƒ\",\n    \"turkmenistan\": \"ğŸ‡¹ğŸ‡²\",\n    \"turks_&_caicos_islands\": \"ğŸ‡¹ğŸ‡¨\",\n    \"tuvalu\": \"ğŸ‡¹ğŸ‡»\",\n    \"u.s._outlying_islands\": \"ğŸ‡ºğŸ‡²\",\n    \"u.s._virgin_islands\": \"ğŸ‡»ğŸ‡®\",\n    \"up!_button\": \"ğŸ†™\",\n    \"uganda\": \"ğŸ‡ºğŸ‡¬\",\n    \"ukraine\": \"ğŸ‡ºğŸ‡¦\",\n    \"united_arab_emirates\": \"ğŸ‡¦ğŸ‡ª\",\n    \"united_kingdom\": \"ğŸ‡¬ğŸ‡§\",\n    \"united_nations\": \"ğŸ‡ºğŸ‡³\",\n    \"united_states\": \"ğŸ‡ºğŸ‡¸\",\n    \"uruguay\": \"ğŸ‡ºğŸ‡¾\",\n    \"uzbekistan\": \"ğŸ‡ºğŸ‡¿\",\n    \"vs_button\": \"ğŸ†š\",\n    \"vanuatu\": \"ğŸ‡»ğŸ‡º\",\n    \"vatican_city\": \"ğŸ‡»ğŸ‡¦\",\n    \"venezuela\": \"ğŸ‡»ğŸ‡ª\",\n    \"vietnam\": \"ğŸ‡»ğŸ‡³\",\n    \"virgo\": \"â™\",\n    \"wales\": \"ğŸ´\\U000e0067\\U000e0062\\U000e0077\\U000e006c\\U000e0073\\U000e007f\",\n    \"wallis_&_futuna\": \"ğŸ‡¼ğŸ‡«\",\n    \"western_sahara\": \"ğŸ‡ªğŸ‡­\",\n    \"yemen\": \"ğŸ‡¾ğŸ‡ª\",\n    \"zambia\": \"ğŸ‡¿ğŸ‡²\",\n    \"zimbabwe\": \"ğŸ‡¿ğŸ‡¼\",\n    \"abacus\": \"ğŸ§®\",\n    \"adhesive_bandage\": \"ğŸ©¹\",\n    \"admission_tickets\": \"ğŸŸ\",\n    \"adult\": \"ğŸ§‘\",\n    \"adult_dark_skin_tone\": \"ğŸ§‘ğŸ¿\",\n    \"adult_light_skin_tone\": \"ğŸ§‘ğŸ»\",\n    \"adult_medium-dark_skin_tone\": \"ğŸ§‘ğŸ¾\",\n    \"adult_medium-light_skin_tone\": \"ğŸ§‘ğŸ¼\",\n    \"adult_medium_skin_tone\": \"ğŸ§‘ğŸ½\",\n    \"aerial_tramway\": \"ğŸš¡\",\n    \"airplane\": \"âœˆ\",\n    \"airplane_arrival\": \"ğŸ›¬\",\n    \"airplane_departure\": \"ğŸ›«\",\n    \"alarm_clock\": \"â°\",\n    \"alembic\": \"âš—\",\n    \"alien\": \"ğŸ‘½\",\n    \"alien_monster\": \"ğŸ‘¾\",\n    \"ambulance\": \"ğŸš‘\",\n    \"american_football\": \"ğŸˆ\",\n    \"amphora\": \"ğŸº\",\n    \"anchor\": \"âš“\",\n    \"anger_symbol\": \"ğŸ’¢\",\n    \"angry_face\": \"ğŸ˜ \",\n    \"angry_face_with_horns\": \"ğŸ‘¿\",\n    \"anguished_face\": \"ğŸ˜§\",\n    \"ant\": \"ğŸœ\",\n    \"antenna_bars\": \"ğŸ“¶\",\n    \"anxious_face_with_sweat\": \"ğŸ˜°\",\n    \"articulated_lorry\": \"ğŸš›\",\n    \"artist_palette\": \"ğŸ¨\",\n    \"astonished_face\": \"ğŸ˜²\",\n    \"atom_symbol\": \"âš›\",\n    \"auto_rickshaw\": \"ğŸ›º\",\n    \"automobile\": \"ğŸš—\",\n    \"avocado\": \"ğŸ¥‘\",\n    \"axe\": \"ğŸª“\",\n    \"baby\": \"ğŸ‘¶\",\n    \"baby_angel\": \"ğŸ‘¼\",\n    \"baby_angel_dark_skin_tone\": \"ğŸ‘¼ğŸ¿\",\n    \"baby_angel_light_skin_tone\": \"ğŸ‘¼ğŸ»\",\n    \"baby_angel_medium-dark_skin_tone\": \"ğŸ‘¼ğŸ¾\",\n    \"baby_angel_medium-light_skin_tone\": \"ğŸ‘¼ğŸ¼\",\n    \"baby_angel_medium_skin_tone\": \"ğŸ‘¼ğŸ½\",\n    \"baby_bottle\": \"ğŸ¼\",\n    \"baby_chick\": \"ğŸ¤\",\n    \"baby_dark_skin_tone\": \"ğŸ‘¶ğŸ¿\",\n    \"baby_light_skin_tone\": \"ğŸ‘¶ğŸ»\",\n    \"baby_medium-dark_skin_tone\": \"ğŸ‘¶ğŸ¾\",\n    \"baby_medium-light_skin_tone\": \"ğŸ‘¶ğŸ¼\",\n    \"baby_medium_skin_tone\": \"ğŸ‘¶ğŸ½\",\n    \"baby_symbol\": \"ğŸš¼\",\n    \"backhand_index_pointing_down\": \"ğŸ‘‡\",\n    \"backhand_index_pointing_down_dark_skin_tone\": \"ğŸ‘‡ğŸ¿\",\n    \"backhand_index_pointing_down_light_skin_tone\": \"ğŸ‘‡ğŸ»\",\n    \"backhand_index_pointing_down_medium-dark_skin_tone\": \"ğŸ‘‡ğŸ¾\",\n    \"backhand_index_pointing_down_medium-light_skin_tone\": \"ğŸ‘‡ğŸ¼\",\n    \"backhand_index_pointing_down_medium_skin_tone\": \"ğŸ‘‡ğŸ½\",\n    \"backhand_index_pointing_left\": \"ğŸ‘ˆ\",\n    \"backhand_index_pointing_left_dark_skin_tone\": \"ğŸ‘ˆğŸ¿\",\n    \"backhand_index_pointing_left_light_skin_tone\": \"ğŸ‘ˆğŸ»\",\n    \"backhand_index_pointing_left_medium-dark_skin_tone\": \"ğŸ‘ˆğŸ¾\",\n    \"backhand_index_pointing_left_medium-light_skin_tone\": \"ğŸ‘ˆğŸ¼\",\n    \"backhand_index_pointing_left_medium_skin_tone\": \"ğŸ‘ˆğŸ½\",\n    \"backhand_index_pointing_right\": \"ğŸ‘‰\",\n    \"backhand_index_pointing_right_dark_skin_tone\": \"ğŸ‘‰ğŸ¿\",\n    \"backhand_index_pointing_right_light_skin_tone\": \"ğŸ‘‰ğŸ»\",\n    \"backhand_index_pointing_right_medium-dark_skin_tone\": \"ğŸ‘‰ğŸ¾\",\n    \"backhand_index_pointing_right_medium-light_skin_tone\": \"ğŸ‘‰ğŸ¼\",\n    \"backhand_index_pointing_right_medium_skin_tone\": \"ğŸ‘‰ğŸ½\",\n    \"backhand_index_pointing_up\": \"ğŸ‘†\",\n    \"backhand_index_pointing_up_dark_skin_tone\": \"ğŸ‘†ğŸ¿\",\n    \"backhand_index_pointing_up_light_skin_tone\": \"ğŸ‘†ğŸ»\",\n    \"backhand_index_pointing_up_medium-dark_skin_tone\": \"ğŸ‘†ğŸ¾\",\n    \"backhand_index_pointing_up_medium-light_skin_tone\": \"ğŸ‘†ğŸ¼\",\n    \"backhand_index_pointing_up_medium_skin_tone\": \"ğŸ‘†ğŸ½\",\n    \"bacon\": \"ğŸ¥“\",\n    \"badger\": \"ğŸ¦¡\",\n    \"badminton\": \"ğŸ¸\",\n    \"bagel\": \"ğŸ¥¯\",\n    \"baggage_claim\": \"ğŸ›„\",\n    \"baguette_bread\": \"ğŸ¥–\",\n    \"balance_scale\": \"âš–\",\n    \"bald\": \"ğŸ¦²\",\n    \"bald_man\": \"ğŸ‘¨\\u200dğŸ¦²\",\n    \"bald_woman\": \"ğŸ‘©\\u200dğŸ¦²\",\n    \"ballet_shoes\": \"ğŸ©°\",\n    \"balloon\": \"ğŸˆ\",\n    \"ballot_box_with_ballot\": \"ğŸ—³\",\n    \"ballot_box_with_check\": \"â˜‘\",\n    \"banana\": \"ğŸŒ\",\n    \"banjo\": \"ğŸª•\",\n    \"bank\": \"ğŸ¦\",\n    \"bar_chart\": \"ğŸ“Š\",\n    \"barber_pole\": \"ğŸ’ˆ\",\n    \"baseball\": \"âš¾\",\n    \"basket\": \"ğŸ§º\",\n    \"basketball\": \"ğŸ€\",\n    \"bat\": \"ğŸ¦‡\",\n    \"bathtub\": \"ğŸ›\",\n    \"battery\": \"ğŸ”‹\",\n    \"beach_with_umbrella\": \"ğŸ–\",\n    \"beaming_face_with_smiling_eyes\": \"ğŸ˜\",\n    \"bear_face\": \"ğŸ»\",\n    \"bearded_person\": \"ğŸ§”\",\n    \"bearded_person_dark_skin_tone\": \"ğŸ§”ğŸ¿\",\n    \"bearded_person_light_skin_tone\": \"ğŸ§”ğŸ»\",\n    \"bearded_person_medium-dark_skin_tone\": \"ğŸ§”ğŸ¾\",\n    \"bearded_person_medium-light_skin_tone\": \"ğŸ§”ğŸ¼\",\n    \"bearded_person_medium_skin_tone\": \"ğŸ§”ğŸ½\",\n    \"beating_heart\": \"ğŸ’“\",\n    \"bed\": \"ğŸ›\",\n    \"beer_mug\": \"ğŸº\",\n    \"bell\": \"ğŸ””\",\n    \"bell_with_slash\": \"ğŸ”•\",\n    \"bellhop_bell\": \"ğŸ›\",\n    \"bento_box\": \"ğŸ±\",\n    \"beverage_box\": \"ğŸ§ƒ\",\n    \"bicycle\": \"ğŸš²\",\n    \"bikini\": \"ğŸ‘™\",\n    \"billed_cap\": \"ğŸ§¢\",\n    \"biohazard\": \"â˜£\",\n    \"bird\": \"ğŸ¦\",\n    \"birthday_cake\": \"ğŸ‚\",\n    \"black_circle\": \"âš«\",\n    \"black_flag\": \"ğŸ´\",\n    \"black_heart\": \"ğŸ–¤\",\n    \"black_large_square\": \"â¬›\",\n    \"black_medium-small_square\": \"â—¾\",\n    \"black_medium_square\": \"â—¼\",\n    \"black_nib\": \"âœ’\",\n    \"black_small_square\": \"â–ª\",\n    \"black_square_button\": \"ğŸ”²\",\n    \"blond-haired_man\": \"ğŸ‘±\\u200dâ™‚ï¸\",\n    \"blond-haired_man_dark_skin_tone\": \"ğŸ‘±ğŸ¿\\u200dâ™‚ï¸\",\n    \"blond-haired_man_light_skin_tone\": \"ğŸ‘±ğŸ»\\u200dâ™‚ï¸\",\n    \"blond-haired_man_medium-dark_skin_tone\": \"ğŸ‘±ğŸ¾\\u200dâ™‚ï¸\",\n    \"blond-haired_man_medium-light_skin_tone\": \"ğŸ‘±ğŸ¼\\u200dâ™‚ï¸\",\n    \"blond-haired_man_medium_skin_tone\": \"ğŸ‘±ğŸ½\\u200dâ™‚ï¸\",\n    \"blond-haired_person\": \"ğŸ‘±\",\n    \"blond-haired_person_dark_skin_tone\": \"ğŸ‘±ğŸ¿\",\n    \"blond-haired_person_light_skin_tone\": \"ğŸ‘±ğŸ»\",\n    \"blond-haired_person_medium-dark_skin_tone\": \"ğŸ‘±ğŸ¾\",\n    \"blond-haired_person_medium-light_skin_tone\": \"ğŸ‘±ğŸ¼\",\n    \"blond-haired_person_medium_skin_tone\": \"ğŸ‘±ğŸ½\",\n    \"blond-haired_woman\": \"ğŸ‘±\\u200dâ™€ï¸\",\n    \"blond-haired_woman_dark_skin_tone\": \"ğŸ‘±ğŸ¿\\u200dâ™€ï¸\",\n    \"blond-haired_woman_light_skin_tone\": \"ğŸ‘±ğŸ»\\u200dâ™€ï¸\",\n    \"blond-haired_woman_medium-dark_skin_tone\": \"ğŸ‘±ğŸ¾\\u200dâ™€ï¸\",\n    \"blond-haired_woman_medium-light_skin_tone\": \"ğŸ‘±ğŸ¼\\u200dâ™€ï¸\",\n    \"blond-haired_woman_medium_skin_tone\": \"ğŸ‘±ğŸ½\\u200dâ™€ï¸\",\n    \"blossom\": \"ğŸŒ¼\",\n    \"blowfish\": \"ğŸ¡\",\n    \"blue_book\": \"ğŸ“˜\",\n    \"blue_circle\": \"ğŸ”µ\",\n    \"blue_heart\": \"ğŸ’™\",\n    \"blue_square\": \"ğŸŸ¦\",\n    \"boar\": \"ğŸ—\",\n    \"bomb\": \"ğŸ’£\",\n    \"bone\": \"ğŸ¦´\",\n    \"bookmark\": \"ğŸ”–\",\n    \"bookmark_tabs\": \"ğŸ“‘\",\n    \"books\": \"ğŸ“š\",\n    \"bottle_with_popping_cork\": \"ğŸ¾\",\n    \"bouquet\": \"ğŸ’\",\n    \"bow_and_arrow\": \"ğŸ¹\",\n    \"bowl_with_spoon\": \"ğŸ¥£\",\n    \"bowling\": \"ğŸ³\",\n    \"boxing_glove\": \"ğŸ¥Š\",\n    \"boy\": \"ğŸ‘¦\",\n    \"boy_dark_skin_tone\": \"ğŸ‘¦ğŸ¿\",\n    \"boy_light_skin_tone\": \"ğŸ‘¦ğŸ»\",\n    \"boy_medium-dark_skin_tone\": \"ğŸ‘¦ğŸ¾\",\n    \"boy_medium-light_skin_tone\": \"ğŸ‘¦ğŸ¼\",\n    \"boy_medium_skin_tone\": \"ğŸ‘¦ğŸ½\",\n    \"brain\": \"ğŸ§ \",\n    \"bread\": \"ğŸ\",\n    \"breast-feeding\": \"ğŸ¤±\",\n    \"breast-feeding_dark_skin_tone\": \"ğŸ¤±ğŸ¿\",\n    \"breast-feeding_light_skin_tone\": \"ğŸ¤±ğŸ»\",\n    \"breast-feeding_medium-dark_skin_tone\": \"ğŸ¤±ğŸ¾\",\n    \"breast-feeding_medium-light_skin_tone\": \"ğŸ¤±ğŸ¼\",\n    \"breast-feeding_medium_skin_tone\": \"ğŸ¤±ğŸ½\",\n    \"brick\": \"ğŸ§±\",\n    \"bride_with_veil\": \"ğŸ‘°\",\n    \"bride_with_veil_dark_skin_tone\": \"ğŸ‘°ğŸ¿\",\n    \"bride_with_veil_light_skin_tone\": \"ğŸ‘°ğŸ»\",\n    \"bride_with_veil_medium-dark_skin_tone\": \"ğŸ‘°ğŸ¾\",\n    \"bride_with_veil_medium-light_skin_tone\": \"ğŸ‘°ğŸ¼\",\n    \"bride_with_veil_medium_skin_tone\": \"ğŸ‘°ğŸ½\",\n    \"bridge_at_night\": \"ğŸŒ‰\",\n    \"briefcase\": \"ğŸ’¼\",\n    \"briefs\": \"ğŸ©²\",\n    \"bright_button\": \"ğŸ”†\",\n    \"broccoli\": \"ğŸ¥¦\",\n    \"broken_heart\": \"ğŸ’”\",\n    \"broom\": \"ğŸ§¹\",\n    \"brown_circle\": \"ğŸŸ¤\",\n    \"brown_heart\": \"ğŸ¤\",\n    \"brown_square\": \"ğŸŸ«\",\n    \"bug\": \"ğŸ›\",\n    \"building_construction\": \"ğŸ—\",\n    \"bullet_train\": \"ğŸš…\",\n    \"burrito\": \"ğŸŒ¯\",\n    \"bus\": \"ğŸšŒ\",\n    \"bus_stop\": \"ğŸš\",\n    \"bust_in_silhouette\": \"ğŸ‘¤\",\n    \"busts_in_silhouette\": \"ğŸ‘¥\",\n    \"butter\": \"ğŸ§ˆ\",\n    \"butterfly\": \"ğŸ¦‹\",\n    \"cactus\": \"ğŸŒµ\",\n    \"calendar\": \"ğŸ“†\",\n    \"call_me_hand\": \"ğŸ¤™\",\n    \"call_me_hand_dark_skin_tone\": \"ğŸ¤™ğŸ¿\",\n    \"call_me_hand_light_skin_tone\": \"ğŸ¤™ğŸ»\",\n    \"call_me_hand_medium-dark_skin_tone\": \"ğŸ¤™ğŸ¾\",\n    \"call_me_hand_medium-light_skin_tone\": \"ğŸ¤™ğŸ¼\",\n    \"call_me_hand_medium_skin_tone\": \"ğŸ¤™ğŸ½\",\n    \"camel\": \"ğŸ«\",\n    \"camera\": \"ğŸ“·\",\n    \"camera_with_flash\": \"ğŸ“¸\",\n    \"camping\": \"ğŸ•\",\n    \"candle\": \"ğŸ•¯\",\n    \"candy\": \"ğŸ¬\",\n    \"canned_food\": \"ğŸ¥«\",\n    \"canoe\": \"ğŸ›¶\",\n    \"card_file_box\": \"ğŸ—ƒ\",\n    \"card_index\": \"ğŸ“‡\",\n    \"card_index_dividers\": \"ğŸ—‚\",\n    \"carousel_horse\": \"ğŸ \",\n    \"carp_streamer\": \"ğŸ\",\n    \"carrot\": \"ğŸ¥•\",\n    \"castle\": \"ğŸ°\",\n    \"cat\": \"ğŸ±\",\n    \"cat_face\": \"ğŸ±\",\n    \"cat_face_with_tears_of_joy\": \"ğŸ˜¹\",\n    \"cat_face_with_wry_smile\": \"ğŸ˜¼\",\n    \"chains\": \"â›“\",\n    \"chair\": \"ğŸª‘\",\n    \"chart_decreasing\": \"ğŸ“‰\",\n    \"chart_increasing\": \"ğŸ“ˆ\",\n    \"chart_increasing_with_yen\": \"ğŸ’¹\",\n    \"cheese_wedge\": \"ğŸ§€\",\n    \"chequered_flag\": \"ğŸ\",\n    \"cherries\": \"ğŸ’\",\n    \"cherry_blossom\": \"ğŸŒ¸\",\n    \"chess_pawn\": \"â™Ÿ\",\n    \"chestnut\": \"ğŸŒ°\",\n    \"chicken\": \"ğŸ”\",\n    \"child\": \"ğŸ§’\",\n    \"child_dark_skin_tone\": \"ğŸ§’ğŸ¿\",\n    \"child_light_skin_tone\": \"ğŸ§’ğŸ»\",\n    \"child_medium-dark_skin_tone\": \"ğŸ§’ğŸ¾\",\n    \"child_medium-light_skin_tone\": \"ğŸ§’ğŸ¼\",\n    \"child_medium_skin_tone\": \"ğŸ§’ğŸ½\",\n    \"children_crossing\": \"ğŸš¸\",\n    \"chipmunk\": \"ğŸ¿\",\n    \"chocolate_bar\": \"ğŸ«\",\n    \"chopsticks\": \"ğŸ¥¢\",\n    \"church\": \"â›ª\",\n    \"cigarette\": \"ğŸš¬\",\n    \"cinema\": \"ğŸ¦\",\n    \"circled_m\": \"â“‚\",\n    \"circus_tent\": \"ğŸª\",\n    \"cityscape\": \"ğŸ™\",\n    \"cityscape_at_dusk\": \"ğŸŒ†\",\n    \"clamp\": \"ğŸ—œ\",\n    \"clapper_board\": \"ğŸ¬\",\n    \"clapping_hands\": \"ğŸ‘\",\n    \"clapping_hands_dark_skin_tone\": \"ğŸ‘ğŸ¿\",\n    \"clapping_hands_light_skin_tone\": \"ğŸ‘ğŸ»\",\n    \"clapping_hands_medium-dark_skin_tone\": \"ğŸ‘ğŸ¾\",\n    \"clapping_hands_medium-light_skin_tone\": \"ğŸ‘ğŸ¼\",\n    \"clapping_hands_medium_skin_tone\": \"ğŸ‘ğŸ½\",\n    \"classical_building\": \"ğŸ›\",\n    \"clinking_beer_mugs\": \"ğŸ»\",\n    \"clinking_glasses\": \"ğŸ¥‚\",\n    \"clipboard\": \"ğŸ“‹\",\n    \"clockwise_vertical_arrows\": \"ğŸ”ƒ\",\n    \"closed_book\": \"ğŸ“•\",\n    \"closed_mailbox_with_lowered_flag\": \"ğŸ“ª\",\n    \"closed_mailbox_with_raised_flag\": \"ğŸ“«\",\n    \"closed_umbrella\": \"ğŸŒ‚\",\n    \"cloud\": \"â˜\",\n    \"cloud_with_lightning\": \"ğŸŒ©\",\n    \"cloud_with_lightning_and_rain\": \"â›ˆ\",\n    \"cloud_with_rain\": \"ğŸŒ§\",\n    \"cloud_with_snow\": \"ğŸŒ¨\",\n    \"clown_face\": \"ğŸ¤¡\",\n    \"club_suit\": \"â™£\",\n    \"clutch_bag\": \"ğŸ‘\",\n    \"coat\": \"ğŸ§¥\",\n    \"cocktail_glass\": \"ğŸ¸\",\n    \"coconut\": \"ğŸ¥¥\",\n    \"coffin\": \"âš°\",\n    \"cold_face\": \"ğŸ¥¶\",\n    \"collision\": \"ğŸ’¥\",\n    \"comet\": \"â˜„\",\n    \"compass\": \"ğŸ§­\",\n    \"computer_disk\": \"ğŸ’½\",\n    \"computer_mouse\": \"ğŸ–±\",\n    \"confetti_ball\": \"ğŸŠ\",\n    \"confounded_face\": \"ğŸ˜–\",\n    \"confused_face\": \"ğŸ˜•\",\n    \"construction\": \"ğŸš§\",\n    \"construction_worker\": \"ğŸ‘·\",\n    \"construction_worker_dark_skin_tone\": \"ğŸ‘·ğŸ¿\",\n    \"construction_worker_light_skin_tone\": \"ğŸ‘·ğŸ»\",\n    \"construction_worker_medium-dark_skin_tone\": \"ğŸ‘·ğŸ¾\",\n    \"construction_worker_medium-light_skin_tone\": \"ğŸ‘·ğŸ¼\",\n    \"construction_worker_medium_skin_tone\": \"ğŸ‘·ğŸ½\",\n    \"control_knobs\": \"ğŸ›\",\n    \"convenience_store\": \"ğŸª\",\n    \"cooked_rice\": \"ğŸš\",\n    \"cookie\": \"ğŸª\",\n    \"cooking\": \"ğŸ³\",\n    \"copyright\": \"Â©\",\n    \"couch_and_lamp\": \"ğŸ›‹\",\n    \"counterclockwise_arrows_button\": \"ğŸ”„\",\n    \"couple_with_heart\": \"ğŸ’‘\",\n    \"couple_with_heart_man_man\": \"ğŸ‘¨\\u200dâ¤ï¸\\u200dğŸ‘¨\",\n    \"couple_with_heart_woman_man\": \"ğŸ‘©\\u200dâ¤ï¸\\u200dğŸ‘¨\",\n    \"couple_with_heart_woman_woman\": \"ğŸ‘©\\u200dâ¤ï¸\\u200dğŸ‘©\",\n    \"cow\": \"ğŸ®\",\n    \"cow_face\": \"ğŸ®\",\n    \"cowboy_hat_face\": \"ğŸ¤ \",\n    \"crab\": \"ğŸ¦€\",\n    \"crayon\": \"ğŸ–\",\n    \"credit_card\": \"ğŸ’³\",\n    \"crescent_moon\": \"ğŸŒ™\",\n    \"cricket\": \"ğŸ¦—\",\n    \"cricket_game\": \"ğŸ\",\n    \"crocodile\": \"ğŸŠ\",\n    \"croissant\": \"ğŸ¥\",\n    \"cross_mark\": \"âŒ\",\n    \"cross_mark_button\": \"â\",\n    \"crossed_fingers\": \"ğŸ¤\",\n    \"crossed_fingers_dark_skin_tone\": \"ğŸ¤ğŸ¿\",\n    \"crossed_fingers_light_skin_tone\": \"ğŸ¤ğŸ»\",\n    \"crossed_fingers_medium-dark_skin_tone\": \"ğŸ¤ğŸ¾\",\n    \"crossed_fingers_medium-light_skin_tone\": \"ğŸ¤ğŸ¼\",\n    \"crossed_fingers_medium_skin_tone\": \"ğŸ¤ğŸ½\",\n    \"crossed_flags\": \"ğŸŒ\",\n    \"crossed_swords\": \"âš”\",\n    \"crown\": \"ğŸ‘‘\",\n    \"crying_cat_face\": \"ğŸ˜¿\",\n    \"crying_face\": \"ğŸ˜¢\",\n    \"crystal_ball\": \"ğŸ”®\",\n    \"cucumber\": \"ğŸ¥’\",\n    \"cupcake\": \"ğŸ§\",\n    \"cup_with_straw\": \"ğŸ¥¤\",\n    \"curling_stone\": \"ğŸ¥Œ\",\n    \"curly_hair\": \"ğŸ¦±\",\n    \"curly-haired_man\": \"ğŸ‘¨\\u200dğŸ¦±\",\n    \"curly-haired_woman\": \"ğŸ‘©\\u200dğŸ¦±\",\n    \"curly_loop\": \"â°\",\n    \"currency_exchange\": \"ğŸ’±\",\n    \"curry_rice\": \"ğŸ›\",\n    \"custard\": \"ğŸ®\",\n    \"customs\": \"ğŸ›ƒ\",\n    \"cut_of_meat\": \"ğŸ¥©\",\n    \"cyclone\": \"ğŸŒ€\",\n    \"dagger\": \"ğŸ—¡\",\n    \"dango\": \"ğŸ¡\",\n    \"dashing_away\": \"ğŸ’¨\",\n    \"deaf_person\": \"ğŸ§\",\n    \"deciduous_tree\": \"ğŸŒ³\",\n    \"deer\": \"ğŸ¦Œ\",\n    \"delivery_truck\": \"ğŸšš\",\n    \"department_store\": \"ğŸ¬\",\n    \"derelict_house\": \"ğŸš\",\n    \"desert\": \"ğŸœ\",\n    \"desert_island\": \"ğŸ\",\n    \"desktop_computer\": \"ğŸ–¥\",\n    \"detective\": \"ğŸ•µ\",\n    \"detective_dark_skin_tone\": \"ğŸ•µğŸ¿\",\n    \"detective_light_skin_tone\": \"ğŸ•µğŸ»\",\n    \"detective_medium-dark_skin_tone\": \"ğŸ•µğŸ¾\",\n    \"detective_medium-light_skin_tone\": \"ğŸ•µğŸ¼\",\n    \"detective_medium_skin_tone\": \"ğŸ•µğŸ½\",\n    \"diamond_suit\": \"â™¦\",\n    \"diamond_with_a_dot\": \"ğŸ’ \",\n    \"dim_button\": \"ğŸ”…\",\n    \"direct_hit\": \"ğŸ¯\",\n    \"disappointed_face\": \"ğŸ˜\",\n    \"diving_mask\": \"ğŸ¤¿\",\n    \"diya_lamp\": \"ğŸª”\",\n    \"dizzy\": \"ğŸ’«\",\n    \"dizzy_face\": \"ğŸ˜µ\",\n    \"dna\": \"ğŸ§¬\",\n    \"dog\": \"ğŸ¶\",\n    \"dog_face\": \"ğŸ¶\",\n    \"dollar_banknote\": \"ğŸ’µ\",\n    \"dolphin\": \"ğŸ¬\",\n    \"door\": \"ğŸšª\",\n    \"dotted_six-pointed_star\": \"ğŸ”¯\",\n    \"double_curly_loop\": \"â¿\",\n    \"double_exclamation_mark\": \"â€¼\",\n    \"doughnut\": \"ğŸ©\",\n    \"dove\": \"ğŸ•Š\",\n    \"down-left_arrow\": \"â†™\",\n    \"down-right_arrow\": \"â†˜\",\n    \"down_arrow\": \"â¬‡\",\n    \"downcast_face_with_sweat\": \"ğŸ˜“\",\n    \"downwards_button\": \"ğŸ”½\",\n    \"dragon\": \"ğŸ‰\",\n    \"dragon_face\": \"ğŸ²\",\n    \"dress\": \"ğŸ‘—\",\n    \"drooling_face\": \"ğŸ¤¤\",\n    \"drop_of_blood\": \"ğŸ©¸\",\n    \"droplet\": \"ğŸ’§\",\n    \"drum\": \"ğŸ¥\",\n    \"duck\": \"ğŸ¦†\",\n    \"dumpling\": \"ğŸ¥Ÿ\",\n    \"dvd\": \"ğŸ“€\",\n    \"e-mail\": \"ğŸ“§\",\n    \"eagle\": \"ğŸ¦…\",\n    \"ear\": \"ğŸ‘‚\",\n    \"ear_dark_skin_tone\": \"ğŸ‘‚ğŸ¿\",\n    \"ear_light_skin_tone\": \"ğŸ‘‚ğŸ»\",\n    \"ear_medium-dark_skin_tone\": \"ğŸ‘‚ğŸ¾\",\n    \"ear_medium-light_skin_tone\": \"ğŸ‘‚ğŸ¼\",\n    \"ear_medium_skin_tone\": \"ğŸ‘‚ğŸ½\",\n    \"ear_of_corn\": \"ğŸŒ½\",\n    \"ear_with_hearing_aid\": \"ğŸ¦»\",\n    \"egg\": \"ğŸ³\",\n    \"eggplant\": \"ğŸ†\",\n    \"eight-pointed_star\": \"âœ´\",\n    \"eight-spoked_asterisk\": \"âœ³\",\n    \"eight-thirty\": \"ğŸ•£\",\n    \"eight_oâ€™clock\": \"ğŸ•—\",\n    \"eject_button\": \"â\",\n    \"electric_plug\": \"ğŸ”Œ\",\n    \"elephant\": \"ğŸ˜\",\n    \"eleven-thirty\": \"ğŸ•¦\",\n    \"eleven_oâ€™clock\": \"ğŸ•š\",\n    \"elf\": \"ğŸ§\",\n    \"elf_dark_skin_tone\": \"ğŸ§ğŸ¿\",\n    \"elf_light_skin_tone\": \"ğŸ§ğŸ»\",\n    \"elf_medium-dark_skin_tone\": \"ğŸ§ğŸ¾\",\n    \"elf_medium-light_skin_tone\": \"ğŸ§ğŸ¼\",\n    \"elf_medium_skin_tone\": \"ğŸ§ğŸ½\",\n    \"envelope\": \"âœ‰\",\n    \"envelope_with_arrow\": \"ğŸ“©\",\n    \"euro_banknote\": \"ğŸ’¶\",\n    \"evergreen_tree\": \"ğŸŒ²\",\n    \"ewe\": \"ğŸ‘\",\n    \"exclamation_mark\": \"â—\",\n    \"exclamation_question_mark\": \"â‰\",\n    \"exploding_head\": \"ğŸ¤¯\",\n    \"expressionless_face\": \"ğŸ˜‘\",\n    \"eye\": \"ğŸ‘\",\n    \"eye_in_speech_bubble\": \"ğŸ‘ï¸\\u200dğŸ—¨ï¸\",\n    \"eyes\": \"ğŸ‘€\",\n    \"face_blowing_a_kiss\": \"ğŸ˜˜\",\n    \"face_savoring_food\": \"ğŸ˜‹\",\n    \"face_screaming_in_fear\": \"ğŸ˜±\",\n    \"face_vomiting\": \"ğŸ¤®\",\n    \"face_with_hand_over_mouth\": \"ğŸ¤­\",\n    \"face_with_head-bandage\": \"ğŸ¤•\",\n    \"face_with_medical_mask\": \"ğŸ˜·\",\n    \"face_with_monocle\": \"ğŸ§\",\n    \"face_with_open_mouth\": \"ğŸ˜®\",\n    \"face_with_raised_eyebrow\": \"ğŸ¤¨\",\n    \"face_with_rolling_eyes\": \"ğŸ™„\",\n    \"face_with_steam_from_nose\": \"ğŸ˜¤\",\n    \"face_with_symbols_on_mouth\": \"ğŸ¤¬\",\n    \"face_with_tears_of_joy\": \"ğŸ˜‚\",\n    \"face_with_thermometer\": \"ğŸ¤’\",\n    \"face_with_tongue\": \"ğŸ˜›\",\n    \"face_without_mouth\": \"ğŸ˜¶\",\n    \"factory\": \"ğŸ­\",\n    \"fairy\": \"ğŸ§š\",\n    \"fairy_dark_skin_tone\": \"ğŸ§šğŸ¿\",\n    \"fairy_light_skin_tone\": \"ğŸ§šğŸ»\",\n    \"fairy_medium-dark_skin_tone\": \"ğŸ§šğŸ¾\",\n    \"fairy_medium-light_skin_tone\": \"ğŸ§šğŸ¼\",\n    \"fairy_medium_skin_tone\": \"ğŸ§šğŸ½\",\n    \"falafel\": \"ğŸ§†\",\n    \"fallen_leaf\": \"ğŸ‚\",\n    \"family\": \"ğŸ‘ª\",\n    \"family_man_boy\": \"ğŸ‘¨\\u200dğŸ‘¦\",\n    \"family_man_boy_boy\": \"ğŸ‘¨\\u200dğŸ‘¦\\u200dğŸ‘¦\",\n    \"family_man_girl\": \"ğŸ‘¨\\u200dğŸ‘§\",\n    \"family_man_girl_boy\": \"ğŸ‘¨\\u200dğŸ‘§\\u200dğŸ‘¦\",\n    \"family_man_girl_girl\": \"ğŸ‘¨\\u200dğŸ‘§\\u200dğŸ‘§\",\n    \"family_man_man_boy\": \"ğŸ‘¨\\u200dğŸ‘¨\\u200dğŸ‘¦\",\n    \"family_man_man_boy_boy\": \"ğŸ‘¨\\u200dğŸ‘¨\\u200dğŸ‘¦\\u200dğŸ‘¦\",\n    \"family_man_man_girl\": \"ğŸ‘¨\\u200dğŸ‘¨\\u200dğŸ‘§\",\n    \"family_man_man_girl_boy\": \"ğŸ‘¨\\u200dğŸ‘¨\\u200dğŸ‘§\\u200dğŸ‘¦\",\n    \"family_man_man_girl_girl\": \"ğŸ‘¨\\u200dğŸ‘¨\\u200dğŸ‘§\\u200dğŸ‘§\",\n    \"family_man_woman_boy\": \"ğŸ‘¨\\u200dğŸ‘©\\u200dğŸ‘¦\",\n    \"family_man_woman_boy_boy\": \"ğŸ‘¨\\u200dğŸ‘©\\u200dğŸ‘¦\\u200dğŸ‘¦\",\n    \"family_man_woman_girl\": \"ğŸ‘¨\\u200dğŸ‘©\\u200dğŸ‘§\",\n    \"family_man_woman_girl_boy\": \"ğŸ‘¨\\u200dğŸ‘©\\u200dğŸ‘§\\u200dğŸ‘¦\",\n    \"family_man_woman_girl_girl\": \"ğŸ‘¨\\u200dğŸ‘©\\u200dğŸ‘§\\u200dğŸ‘§\",\n    \"family_woman_boy\": \"ğŸ‘©\\u200dğŸ‘¦\",\n    \"family_woman_boy_boy\": \"ğŸ‘©\\u200dğŸ‘¦\\u200dğŸ‘¦\",\n    \"family_woman_girl\": \"ğŸ‘©\\u200dğŸ‘§\",\n    \"family_woman_girl_boy\": \"ğŸ‘©\\u200dğŸ‘§\\u200dğŸ‘¦\",\n    \"family_woman_girl_girl\": \"ğŸ‘©\\u200dğŸ‘§\\u200dğŸ‘§\",\n    \"family_woman_woman_boy\": \"ğŸ‘©\\u200dğŸ‘©\\u200dğŸ‘¦\",\n    \"family_woman_woman_boy_boy\": \"ğŸ‘©\\u200dğŸ‘©\\u200dğŸ‘¦\\u200dğŸ‘¦\",\n    \"family_woman_woman_girl\": \"ğŸ‘©\\u200dğŸ‘©\\u200dğŸ‘§\",\n    \"family_woman_woman_girl_boy\": \"ğŸ‘©\\u200dğŸ‘©\\u200dğŸ‘§\\u200dğŸ‘¦\",\n    \"family_woman_woman_girl_girl\": \"ğŸ‘©\\u200dğŸ‘©\\u200dğŸ‘§\\u200dğŸ‘§\",\n    \"fast-forward_button\": \"â©\",\n    \"fast_down_button\": \"â¬\",\n    \"fast_reverse_button\": \"âª\",\n    \"fast_up_button\": \"â«\",\n    \"fax_machine\": \"ğŸ“ \",\n    \"fearful_face\": \"ğŸ˜¨\",\n    \"female_sign\": \"â™€\",\n    \"ferris_wheel\": \"ğŸ¡\",\n    \"ferry\": \"â›´\",\n    \"field_hockey\": \"ğŸ‘\",\n    \"file_cabinet\": \"ğŸ—„\",\n    \"file_folder\": \"ğŸ“\",\n    \"film_frames\": \"ğŸ\",\n    \"film_projector\": \"ğŸ“½\",\n    \"fire\": \"ğŸ”¥\",\n    \"fire_extinguisher\": \"ğŸ§¯\",\n    \"firecracker\": \"ğŸ§¨\",\n    \"fire_engine\": \"ğŸš’\",\n    \"fireworks\": \"ğŸ†\",\n    \"first_quarter_moon\": \"ğŸŒ“\",\n    \"first_quarter_moon_face\": \"ğŸŒ›\",\n    \"fish\": \"ğŸŸ\",\n    \"fish_cake_with_swirl\": \"ğŸ¥\",\n    \"fishing_pole\": \"ğŸ£\",\n    \"five-thirty\": \"ğŸ• \",\n    \"five_oâ€™clock\": \"ğŸ•”\",\n    \"flag_in_hole\": \"â›³\",\n    \"flamingo\": \"ğŸ¦©\",\n    \"flashlight\": \"ğŸ”¦\",\n    \"flat_shoe\": \"ğŸ¥¿\",\n    \"fleur-de-lis\": \"âšœ\",\n    \"flexed_biceps\": \"ğŸ’ª\",\n    \"flexed_biceps_dark_skin_tone\": \"ğŸ’ªğŸ¿\",\n    \"flexed_biceps_light_skin_tone\": \"ğŸ’ªğŸ»\",\n    \"flexed_biceps_medium-dark_skin_tone\": \"ğŸ’ªğŸ¾\",\n    \"flexed_biceps_medium-light_skin_tone\": \"ğŸ’ªğŸ¼\",\n    \"flexed_biceps_medium_skin_tone\": \"ğŸ’ªğŸ½\",\n    \"floppy_disk\": \"ğŸ’¾\",\n    \"flower_playing_cards\": \"ğŸ´\",\n    \"flushed_face\": \"ğŸ˜³\",\n    \"flying_disc\": \"ğŸ¥\",\n    \"flying_saucer\": \"ğŸ›¸\",\n    \"fog\": \"ğŸŒ«\",\n    \"foggy\": \"ğŸŒ\",\n    \"folded_hands\": \"ğŸ™\",\n    \"folded_hands_dark_skin_tone\": \"ğŸ™ğŸ¿\",\n    \"folded_hands_light_skin_tone\": \"ğŸ™ğŸ»\",\n    \"folded_hands_medium-dark_skin_tone\": \"ğŸ™ğŸ¾\",\n    \"folded_hands_medium-light_skin_tone\": \"ğŸ™ğŸ¼\",\n    \"folded_hands_medium_skin_tone\": \"ğŸ™ğŸ½\",\n    \"foot\": \"ğŸ¦¶\",\n    \"footprints\": \"ğŸ‘£\",\n    \"fork_and_knife\": \"ğŸ´\",\n    \"fork_and_knife_with_plate\": \"ğŸ½\",\n    \"fortune_cookie\": \"ğŸ¥ \",\n    \"fountain\": \"â›²\",\n    \"fountain_pen\": \"ğŸ–‹\",\n    \"four-thirty\": \"ğŸ•Ÿ\",\n    \"four_leaf_clover\": \"ğŸ€\",\n    \"four_oâ€™clock\": \"ğŸ•“\",\n    \"fox_face\": \"ğŸ¦Š\",\n    \"framed_picture\": \"ğŸ–¼\",\n    \"french_fries\": \"ğŸŸ\",\n    \"fried_shrimp\": \"ğŸ¤\",\n    \"frog_face\": \"ğŸ¸\",\n    \"front-facing_baby_chick\": \"ğŸ¥\",\n    \"frowning_face\": \"â˜¹\",\n    \"frowning_face_with_open_mouth\": \"ğŸ˜¦\",\n    \"fuel_pump\": \"â›½\",\n    \"full_moon\": \"ğŸŒ•\",\n    \"full_moon_face\": \"ğŸŒ\",\n    \"funeral_urn\": \"âš±\",\n    \"game_die\": \"ğŸ²\",\n    \"garlic\": \"ğŸ§„\",\n    \"gear\": \"âš™\",\n    \"gem_stone\": \"ğŸ’\",\n    \"genie\": \"ğŸ§\",\n    \"ghost\": \"ğŸ‘»\",\n    \"giraffe\": \"ğŸ¦’\",\n    \"girl\": \"ğŸ‘§\",\n    \"girl_dark_skin_tone\": \"ğŸ‘§ğŸ¿\",\n    \"girl_light_skin_tone\": \"ğŸ‘§ğŸ»\",\n    \"girl_medium-dark_skin_tone\": \"ğŸ‘§ğŸ¾\",\n    \"girl_medium-light_skin_tone\": \"ğŸ‘§ğŸ¼\",\n    \"girl_medium_skin_tone\": \"ğŸ‘§ğŸ½\",\n    \"glass_of_milk\": \"ğŸ¥›\",\n    \"glasses\": \"ğŸ‘“\",\n    \"globe_showing_americas\": \"ğŸŒ\",\n    \"globe_showing_asia-australia\": \"ğŸŒ\",\n    \"globe_showing_europe-africa\": \"ğŸŒ\",\n    \"globe_with_meridians\": \"ğŸŒ\",\n    \"gloves\": \"ğŸ§¤\",\n    \"glowing_star\": \"ğŸŒŸ\",\n    \"goal_net\": \"ğŸ¥…\",\n    \"goat\": \"ğŸ\",\n    \"goblin\": \"ğŸ‘º\",\n    \"goggles\": \"ğŸ¥½\",\n    \"gorilla\": \"ğŸ¦\",\n    \"graduation_cap\": \"ğŸ“\",\n    \"grapes\": \"ğŸ‡\",\n    \"green_apple\": \"ğŸ\",\n    \"green_book\": \"ğŸ“—\",\n    \"green_circle\": \"ğŸŸ¢\",\n    \"green_heart\": \"ğŸ’š\",\n    \"green_salad\": \"ğŸ¥—\",\n    \"green_square\": \"ğŸŸ©\",\n    \"grimacing_face\": \"ğŸ˜¬\",\n    \"grinning_cat_face\": \"ğŸ˜º\",\n    \"grinning_cat_face_with_smiling_eyes\": \"ğŸ˜¸\",\n    \"grinning_face\": \"ğŸ˜€\",\n    \"grinning_face_with_big_eyes\": \"ğŸ˜ƒ\",\n    \"grinning_face_with_smiling_eyes\": \"ğŸ˜„\",\n    \"grinning_face_with_sweat\": \"ğŸ˜…\",\n    \"grinning_squinting_face\": \"ğŸ˜†\",\n    \"growing_heart\": \"ğŸ’—\",\n    \"guard\": \"ğŸ’‚\",\n    \"guard_dark_skin_tone\": \"ğŸ’‚ğŸ¿\",\n    \"guard_light_skin_tone\": \"ğŸ’‚ğŸ»\",\n    \"guard_medium-dark_skin_tone\": \"ğŸ’‚ğŸ¾\",\n    \"guard_medium-light_skin_tone\": \"ğŸ’‚ğŸ¼\",\n    \"guard_medium_skin_tone\": \"ğŸ’‚ğŸ½\",\n    \"guide_dog\": \"ğŸ¦®\",\n    \"guitar\": \"ğŸ¸\",\n    \"hamburger\": \"ğŸ”\",\n    \"hammer\": \"ğŸ”¨\",\n    \"hammer_and_pick\": \"âš’\",\n    \"hammer_and_wrench\": \"ğŸ› \",\n    \"hamster_face\": \"ğŸ¹\",\n    \"hand_with_fingers_splayed\": \"ğŸ–\",\n    \"hand_with_fingers_splayed_dark_skin_tone\": \"ğŸ–ğŸ¿\",\n    \"hand_with_fingers_splayed_light_skin_tone\": \"ğŸ–ğŸ»\",\n    \"hand_with_fingers_splayed_medium-dark_skin_tone\": \"ğŸ–ğŸ¾\",\n    \"hand_with_fingers_splayed_medium-light_skin_tone\": \"ğŸ–ğŸ¼\",\n    \"hand_with_fingers_splayed_medium_skin_tone\": \"ğŸ–ğŸ½\",\n    \"handbag\": \"ğŸ‘œ\",\n    \"handshake\": \"ğŸ¤\",\n    \"hatching_chick\": \"ğŸ£\",\n    \"headphone\": \"ğŸ§\",\n    \"hear-no-evil_monkey\": \"ğŸ™‰\",\n    \"heart_decoration\": \"ğŸ’Ÿ\",\n    \"heart_suit\": \"â™¥\",\n    \"heart_with_arrow\": \"ğŸ’˜\",\n    \"heart_with_ribbon\": \"ğŸ’\",\n    \"heavy_check_mark\": \"âœ”\",\n    \"heavy_division_sign\": \"â—\",\n    \"heavy_dollar_sign\": \"ğŸ’²\",\n    \"heavy_heart_exclamation\": \"â£\",\n    \"heavy_large_circle\": \"â­•\",\n    \"heavy_minus_sign\": \"â–\",\n    \"heavy_multiplication_x\": \"âœ–\",\n    \"heavy_plus_sign\": \"â•\",\n    \"hedgehog\": \"ğŸ¦”\",\n    \"helicopter\": \"ğŸš\",\n    \"herb\": \"ğŸŒ¿\",\n    \"hibiscus\": \"ğŸŒº\",\n    \"high-heeled_shoe\": \"ğŸ‘ \",\n    \"high-speed_train\": \"ğŸš„\",\n    \"high_voltage\": \"âš¡\",\n    \"hiking_boot\": \"ğŸ¥¾\",\n    \"hindu_temple\": \"ğŸ›•\",\n    \"hippopotamus\": \"ğŸ¦›\",\n    \"hole\": \"ğŸ•³\",\n    \"honey_pot\": \"ğŸ¯\",\n    \"honeybee\": \"ğŸ\",\n    \"horizontal_traffic_light\": \"ğŸš¥\",\n    \"horse\": \"ğŸ´\",\n    \"horse_face\": \"ğŸ´\",\n    \"horse_racing\": \"ğŸ‡\",\n    \"horse_racing_dark_skin_tone\": \"ğŸ‡ğŸ¿\",\n    \"horse_racing_light_skin_tone\": \"ğŸ‡ğŸ»\",\n    \"horse_racing_medium-dark_skin_tone\": \"ğŸ‡ğŸ¾\",\n    \"horse_racing_medium-light_skin_tone\": \"ğŸ‡ğŸ¼\",\n    \"horse_racing_medium_skin_tone\": \"ğŸ‡ğŸ½\",\n    \"hospital\": \"ğŸ¥\",\n    \"hot_beverage\": \"â˜•\",\n    \"hot_dog\": \"ğŸŒ­\",\n    \"hot_face\": \"ğŸ¥µ\",\n    \"hot_pepper\": \"ğŸŒ¶\",\n    \"hot_springs\": \"â™¨\",\n    \"hotel\": \"ğŸ¨\",\n    \"hourglass_done\": \"âŒ›\",\n    \"hourglass_not_done\": \"â³\",\n    \"house\": \"ğŸ \",\n    \"house_with_garden\": \"ğŸ¡\",\n    \"houses\": \"ğŸ˜\",\n    \"hugging_face\": \"ğŸ¤—\",\n    \"hundred_points\": \"ğŸ’¯\",\n    \"hushed_face\": \"ğŸ˜¯\",\n    \"ice\": \"ğŸ§Š\",\n    \"ice_cream\": \"ğŸ¨\",\n    \"ice_hockey\": \"ğŸ’\",\n    \"ice_skate\": \"â›¸\",\n    \"inbox_tray\": \"ğŸ“¥\",\n    \"incoming_envelope\": \"ğŸ“¨\",\n    \"index_pointing_up\": \"â˜\",\n    \"index_pointing_up_dark_skin_tone\": \"â˜ğŸ¿\",\n    \"index_pointing_up_light_skin_tone\": \"â˜ğŸ»\",\n    \"index_pointing_up_medium-dark_skin_tone\": \"â˜ğŸ¾\",\n    \"index_pointing_up_medium-light_skin_tone\": \"â˜ğŸ¼\",\n    \"index_pointing_up_medium_skin_tone\": \"â˜ğŸ½\",\n    \"infinity\": \"â™¾\",\n    \"information\": \"â„¹\",\n    \"input_latin_letters\": \"ğŸ”¤\",\n    \"input_latin_lowercase\": \"ğŸ”¡\",\n    \"input_latin_uppercase\": \"ğŸ” \",\n    \"input_numbers\": \"ğŸ”¢\",\n    \"input_symbols\": \"ğŸ”£\",\n    \"jack-o-lantern\": \"ğŸƒ\",\n    \"jeans\": \"ğŸ‘–\",\n    \"jigsaw\": \"ğŸ§©\",\n    \"joker\": \"ğŸƒ\",\n    \"joystick\": \"ğŸ•¹\",\n    \"kaaba\": \"ğŸ•‹\",\n    \"kangaroo\": \"ğŸ¦˜\",\n    \"key\": \"ğŸ”‘\",\n    \"keyboard\": \"âŒ¨\",\n    \"keycap_#\": \"#ï¸âƒ£\",\n    \"keycap_*\": \"*ï¸âƒ£\",\n    \"keycap_0\": \"0ï¸âƒ£\",\n    \"keycap_1\": \"1ï¸âƒ£\",\n    \"keycap_10\": \"ğŸ”Ÿ\",\n    \"keycap_2\": \"2ï¸âƒ£\",\n    \"keycap_3\": \"3ï¸âƒ£\",\n    \"keycap_4\": \"4ï¸âƒ£\",\n    \"keycap_5\": \"5ï¸âƒ£\",\n    \"keycap_6\": \"6ï¸âƒ£\",\n    \"keycap_7\": \"7ï¸âƒ£\",\n    \"keycap_8\": \"8ï¸âƒ£\",\n    \"keycap_9\": \"9ï¸âƒ£\",\n    \"kick_scooter\": \"ğŸ›´\",\n    \"kimono\": \"ğŸ‘˜\",\n    \"kiss\": \"ğŸ’‹\",\n    \"kiss_man_man\": \"ğŸ‘¨\\u200dâ¤ï¸\\u200dğŸ’‹\\u200dğŸ‘¨\",\n    \"kiss_mark\": \"ğŸ’‹\",\n    \"kiss_woman_man\": \"ğŸ‘©\\u200dâ¤ï¸\\u200dğŸ’‹\\u200dğŸ‘¨\",\n    \"kiss_woman_woman\": \"ğŸ‘©\\u200dâ¤ï¸\\u200dğŸ’‹\\u200dğŸ‘©\",\n    \"kissing_cat_face\": \"ğŸ˜½\",\n    \"kissing_face\": \"ğŸ˜—\",\n    \"kissing_face_with_closed_eyes\": \"ğŸ˜š\",\n    \"kissing_face_with_smiling_eyes\": \"ğŸ˜™\",\n    \"kitchen_knife\": \"ğŸ”ª\",\n    \"kite\": \"ğŸª\",\n    \"kiwi_fruit\": \"ğŸ¥\",\n    \"koala\": \"ğŸ¨\",\n    \"lab_coat\": \"ğŸ¥¼\",\n    \"label\": \"ğŸ·\",\n    \"lacrosse\": \"ğŸ¥\",\n    \"lady_beetle\": \"ğŸ\",\n    \"laptop_computer\": \"ğŸ’»\",\n    \"large_blue_diamond\": \"ğŸ”·\",\n    \"large_orange_diamond\": \"ğŸ”¶\",\n    \"last_quarter_moon\": \"ğŸŒ—\",\n    \"last_quarter_moon_face\": \"ğŸŒœ\",\n    \"last_track_button\": \"â®\",\n    \"latin_cross\": \"âœ\",\n    \"leaf_fluttering_in_wind\": \"ğŸƒ\",\n    \"leafy_green\": \"ğŸ¥¬\",\n    \"ledger\": \"ğŸ“’\",\n    \"left-facing_fist\": \"ğŸ¤›\",\n    \"left-facing_fist_dark_skin_tone\": \"ğŸ¤›ğŸ¿\",\n    \"left-facing_fist_light_skin_tone\": \"ğŸ¤›ğŸ»\",\n    \"left-facing_fist_medium-dark_skin_tone\": \"ğŸ¤›ğŸ¾\",\n    \"left-facing_fist_medium-light_skin_tone\": \"ğŸ¤›ğŸ¼\",\n    \"left-facing_fist_medium_skin_tone\": \"ğŸ¤›ğŸ½\",\n    \"left-right_arrow\": \"â†”\",\n    \"left_arrow\": \"â¬…\",\n    \"left_arrow_curving_right\": \"â†ª\",\n    \"left_luggage\": \"ğŸ›…\",\n    \"left_speech_bubble\": \"ğŸ—¨\",\n    \"leg\": \"ğŸ¦µ\",\n    \"lemon\": \"ğŸ‹\",\n    \"leopard\": \"ğŸ†\",\n    \"level_slider\": \"ğŸš\",\n    \"light_bulb\": \"ğŸ’¡\",\n    \"light_rail\": \"ğŸšˆ\",\n    \"link\": \"ğŸ”—\",\n    \"linked_paperclips\": \"ğŸ–‡\",\n    \"lion_face\": \"ğŸ¦\",\n    \"lipstick\": \"ğŸ’„\",\n    \"litter_in_bin_sign\": \"ğŸš®\",\n    \"lizard\": \"ğŸ¦\",\n    \"llama\": \"ğŸ¦™\",\n    \"lobster\": \"ğŸ¦\",\n    \"locked\": \"ğŸ”’\",\n    \"locked_with_key\": \"ğŸ”\",\n    \"locked_with_pen\": \"ğŸ”\",\n    \"locomotive\": \"ğŸš‚\",\n    \"lollipop\": \"ğŸ­\",\n    \"lotion_bottle\": \"ğŸ§´\",\n    \"loudly_crying_face\": \"ğŸ˜­\",\n    \"loudspeaker\": \"ğŸ“¢\",\n    \"love-you_gesture\": \"ğŸ¤Ÿ\",\n    \"love-you_gesture_dark_skin_tone\": \"ğŸ¤ŸğŸ¿\",\n    \"love-you_gesture_light_skin_tone\": \"ğŸ¤ŸğŸ»\",\n    \"love-you_gesture_medium-dark_skin_tone\": \"ğŸ¤ŸğŸ¾\",\n    \"love-you_gesture_medium-light_skin_tone\": \"ğŸ¤ŸğŸ¼\",\n    \"love-you_gesture_medium_skin_tone\": \"ğŸ¤ŸğŸ½\",\n    \"love_hotel\": \"ğŸ©\",\n    \"love_letter\": \"ğŸ’Œ\",\n    \"luggage\": \"ğŸ§³\",\n    \"lying_face\": \"ğŸ¤¥\",\n    \"mage\": \"ğŸ§™\",\n    \"mage_dark_skin_tone\": \"ğŸ§™ğŸ¿\",\n    \"mage_light_skin_tone\": \"ğŸ§™ğŸ»\",\n    \"mage_medium-dark_skin_tone\": \"ğŸ§™ğŸ¾\",\n    \"mage_medium-light_skin_tone\": \"ğŸ§™ğŸ¼\",\n    \"mage_medium_skin_tone\": \"ğŸ§™ğŸ½\",\n    \"magnet\": \"ğŸ§²\",\n    \"magnifying_glass_tilted_left\": \"ğŸ”\",\n    \"magnifying_glass_tilted_right\": \"ğŸ”\",\n    \"mahjong_red_dragon\": \"ğŸ€„\",\n    \"male_sign\": \"â™‚\",\n    \"man\": \"ğŸ‘¨\",\n    \"man_and_woman_holding_hands\": \"ğŸ‘«\",\n    \"man_artist\": \"ğŸ‘¨\\u200dğŸ¨\",\n    \"man_artist_dark_skin_tone\": \"ğŸ‘¨ğŸ¿\\u200dğŸ¨\",\n    \"man_artist_light_skin_tone\": \"ğŸ‘¨ğŸ»\\u200dğŸ¨\",\n    \"man_artist_medium-dark_skin_tone\": \"ğŸ‘¨ğŸ¾\\u200dğŸ¨\",\n    \"man_artist_medium-light_skin_tone\": \"ğŸ‘¨ğŸ¼\\u200dğŸ¨\",\n    \"man_artist_medium_skin_tone\": \"ğŸ‘¨ğŸ½\\u200dğŸ¨\",\n    \"man_astronaut\": \"ğŸ‘¨\\u200dğŸš€\",\n    \"man_astronaut_dark_skin_tone\": \"ğŸ‘¨ğŸ¿\\u200dğŸš€\",\n    \"man_astronaut_light_skin_tone\": \"ğŸ‘¨ğŸ»\\u200dğŸš€\",\n    \"man_astronaut_medium-dark_skin_tone\": \"ğŸ‘¨ğŸ¾\\u200dğŸš€\",\n    \"man_astronaut_medium-light_skin_tone\": \"ğŸ‘¨ğŸ¼\\u200dğŸš€\",\n    \"man_astronaut_medium_skin_tone\": \"ğŸ‘¨ğŸ½\\u200dğŸš€\",\n    \"man_biking\": \"ğŸš´\\u200dâ™‚ï¸\",\n    \"man_biking_dark_skin_tone\": \"ğŸš´ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_biking_light_skin_tone\": \"ğŸš´ğŸ»\\u200dâ™‚ï¸\",\n    \"man_biking_medium-dark_skin_tone\": \"ğŸš´ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_biking_medium-light_skin_tone\": \"ğŸš´ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_biking_medium_skin_tone\": \"ğŸš´ğŸ½\\u200dâ™‚ï¸\",\n    \"man_bouncing_ball\": \"â›¹ï¸\\u200dâ™‚ï¸\",\n    \"man_bouncing_ball_dark_skin_tone\": \"â›¹ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_bouncing_ball_light_skin_tone\": \"â›¹ğŸ»\\u200dâ™‚ï¸\",\n    \"man_bouncing_ball_medium-dark_skin_tone\": \"â›¹ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_bouncing_ball_medium-light_skin_tone\": \"â›¹ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_bouncing_ball_medium_skin_tone\": \"â›¹ğŸ½\\u200dâ™‚ï¸\",\n    \"man_bowing\": \"ğŸ™‡\\u200dâ™‚ï¸\",\n    \"man_bowing_dark_skin_tone\": \"ğŸ™‡ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_bowing_light_skin_tone\": \"ğŸ™‡ğŸ»\\u200dâ™‚ï¸\",\n    \"man_bowing_medium-dark_skin_tone\": \"ğŸ™‡ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_bowing_medium-light_skin_tone\": \"ğŸ™‡ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_bowing_medium_skin_tone\": \"ğŸ™‡ğŸ½\\u200dâ™‚ï¸\",\n    \"man_cartwheeling\": \"ğŸ¤¸\\u200dâ™‚ï¸\",\n    \"man_cartwheeling_dark_skin_tone\": \"ğŸ¤¸ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_cartwheeling_light_skin_tone\": \"ğŸ¤¸ğŸ»\\u200dâ™‚ï¸\",\n    \"man_cartwheeling_medium-dark_skin_tone\": \"ğŸ¤¸ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_cartwheeling_medium-light_skin_tone\": \"ğŸ¤¸ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_cartwheeling_medium_skin_tone\": \"ğŸ¤¸ğŸ½\\u200dâ™‚ï¸\",\n    \"man_climbing\": \"ğŸ§—\\u200dâ™‚ï¸\",\n    \"man_climbing_dark_skin_tone\": \"ğŸ§—ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_climbing_light_skin_tone\": \"ğŸ§—ğŸ»\\u200dâ™‚ï¸\",\n    \"man_climbing_medium-dark_skin_tone\": \"ğŸ§—ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_climbing_medium-light_skin_tone\": \"ğŸ§—ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_climbing_medium_skin_tone\": \"ğŸ§—ğŸ½\\u200dâ™‚ï¸\",\n    \"man_construction_worker\": \"ğŸ‘·\\u200dâ™‚ï¸\",\n    \"man_construction_worker_dark_skin_tone\": \"ğŸ‘·ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_construction_worker_light_skin_tone\": \"ğŸ‘·ğŸ»\\u200dâ™‚ï¸\",\n    \"man_construction_worker_medium-dark_skin_tone\": \"ğŸ‘·ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_construction_worker_medium-light_skin_tone\": \"ğŸ‘·ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_construction_worker_medium_skin_tone\": \"ğŸ‘·ğŸ½\\u200dâ™‚ï¸\",\n    \"man_cook\": \"ğŸ‘¨\\u200dğŸ³\",\n    \"man_cook_dark_skin_tone\": \"ğŸ‘¨ğŸ¿\\u200dğŸ³\",\n    \"man_cook_light_skin_tone\": \"ğŸ‘¨ğŸ»\\u200dğŸ³\",\n    \"man_cook_medium-dark_skin_tone\": \"ğŸ‘¨ğŸ¾\\u200dğŸ³\",\n    \"man_cook_medium-light_skin_tone\": \"ğŸ‘¨ğŸ¼\\u200dğŸ³\",\n    \"man_cook_medium_skin_tone\": \"ğŸ‘¨ğŸ½\\u200dğŸ³\",\n    \"man_dancing\": \"ğŸ•º\",\n    \"man_dancing_dark_skin_tone\": \"ğŸ•ºğŸ¿\",\n    \"man_dancing_light_skin_tone\": \"ğŸ•ºğŸ»\",\n    \"man_dancing_medium-dark_skin_tone\": \"ğŸ•ºğŸ¾\",\n    \"man_dancing_medium-light_skin_tone\": \"ğŸ•ºğŸ¼\",\n    \"man_dancing_medium_skin_tone\": \"ğŸ•ºğŸ½\",\n    \"man_dark_skin_tone\": \"ğŸ‘¨ğŸ¿\",\n    \"man_detective\": \"ğŸ•µï¸\\u200dâ™‚ï¸\",\n    \"man_detective_dark_skin_tone\": \"ğŸ•µğŸ¿\\u200dâ™‚ï¸\",\n    \"man_detective_light_skin_tone\": \"ğŸ•µğŸ»\\u200dâ™‚ï¸\",\n    \"man_detective_medium-dark_skin_tone\": \"ğŸ•µğŸ¾\\u200dâ™‚ï¸\",\n    \"man_detective_medium-light_skin_tone\": \"ğŸ•µğŸ¼\\u200dâ™‚ï¸\",\n    \"man_detective_medium_skin_tone\": \"ğŸ•µğŸ½\\u200dâ™‚ï¸\",\n    \"man_elf\": \"ğŸ§\\u200dâ™‚ï¸\",\n    \"man_elf_dark_skin_tone\": \"ğŸ§ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_elf_light_skin_tone\": \"ğŸ§ğŸ»\\u200dâ™‚ï¸\",\n    \"man_elf_medium-dark_skin_tone\": \"ğŸ§ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_elf_medium-light_skin_tone\": \"ğŸ§ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_elf_medium_skin_tone\": \"ğŸ§ğŸ½\\u200dâ™‚ï¸\",\n    \"man_facepalming\": \"ğŸ¤¦\\u200dâ™‚ï¸\",\n    \"man_facepalming_dark_skin_tone\": \"ğŸ¤¦ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_facepalming_light_skin_tone\": \"ğŸ¤¦ğŸ»\\u200dâ™‚ï¸\",\n    \"man_facepalming_medium-dark_skin_tone\": \"ğŸ¤¦ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_facepalming_medium-light_skin_tone\": \"ğŸ¤¦ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_facepalming_medium_skin_tone\": \"ğŸ¤¦ğŸ½\\u200dâ™‚ï¸\",\n    \"man_factory_worker\": \"ğŸ‘¨\\u200dğŸ­\",\n    \"man_factory_worker_dark_skin_tone\": \"ğŸ‘¨ğŸ¿\\u200dğŸ­\",\n    \"man_factory_worker_light_skin_tone\": \"ğŸ‘¨ğŸ»\\u200dğŸ­\",\n    \"man_factory_worker_medium-dark_skin_tone\": \"ğŸ‘¨ğŸ¾\\u200dğŸ­\",\n    \"man_factory_worker_medium-light_skin_tone\": \"ğŸ‘¨ğŸ¼\\u200dğŸ­\",\n    \"man_factory_worker_medium_skin_tone\": \"ğŸ‘¨ğŸ½\\u200dğŸ­\",\n    \"man_fairy\": \"ğŸ§š\\u200dâ™‚ï¸\",\n    \"man_fairy_dark_skin_tone\": \"ğŸ§šğŸ¿\\u200dâ™‚ï¸\",\n    \"man_fairy_light_skin_tone\": \"ğŸ§šğŸ»\\u200dâ™‚ï¸\",\n    \"man_fairy_medium-dark_skin_tone\": \"ğŸ§šğŸ¾\\u200dâ™‚ï¸\",\n    \"man_fairy_medium-light_skin_tone\": \"ğŸ§šğŸ¼\\u200dâ™‚ï¸\",\n    \"man_fairy_medium_skin_tone\": \"ğŸ§šğŸ½\\u200dâ™‚ï¸\",\n    \"man_farmer\": \"ğŸ‘¨\\u200dğŸŒ¾\",\n    \"man_farmer_dark_skin_tone\": \"ğŸ‘¨ğŸ¿\\u200dğŸŒ¾\",\n    \"man_farmer_light_skin_tone\": \"ğŸ‘¨ğŸ»\\u200dğŸŒ¾\",\n    \"man_farmer_medium-dark_skin_tone\": \"ğŸ‘¨ğŸ¾\\u200dğŸŒ¾\",\n    \"man_farmer_medium-light_skin_tone\": \"ğŸ‘¨ğŸ¼\\u200dğŸŒ¾\",\n    \"man_farmer_medium_skin_tone\": \"ğŸ‘¨ğŸ½\\u200dğŸŒ¾\",\n    \"man_firefighter\": \"ğŸ‘¨\\u200dğŸš’\",\n    \"man_firefighter_dark_skin_tone\": \"ğŸ‘¨ğŸ¿\\u200dğŸš’\",\n    \"man_firefighter_light_skin_tone\": \"ğŸ‘¨ğŸ»\\u200dğŸš’\",\n    \"man_firefighter_medium-dark_skin_tone\": \"ğŸ‘¨ğŸ¾\\u200dğŸš’\",\n    \"man_firefighter_medium-light_skin_tone\": \"ğŸ‘¨ğŸ¼\\u200dğŸš’\",\n    \"man_firefighter_medium_skin_tone\": \"ğŸ‘¨ğŸ½\\u200dğŸš’\",\n    \"man_frowning\": \"ğŸ™\\u200dâ™‚ï¸\",\n    \"man_frowning_dark_skin_tone\": \"ğŸ™ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_frowning_light_skin_tone\": \"ğŸ™ğŸ»\\u200dâ™‚ï¸\",\n    \"man_frowning_medium-dark_skin_tone\": \"ğŸ™ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_frowning_medium-light_skin_tone\": \"ğŸ™ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_frowning_medium_skin_tone\": \"ğŸ™ğŸ½\\u200dâ™‚ï¸\",\n    \"man_genie\": \"ğŸ§\\u200dâ™‚ï¸\",\n    \"man_gesturing_no\": \"ğŸ™…\\u200dâ™‚ï¸\",\n    \"man_gesturing_no_dark_skin_tone\": \"ğŸ™…ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_gesturing_no_light_skin_tone\": \"ğŸ™…ğŸ»\\u200dâ™‚ï¸\",\n    \"man_gesturing_no_medium-dark_skin_tone\": \"ğŸ™…ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_gesturing_no_medium-light_skin_tone\": \"ğŸ™…ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_gesturing_no_medium_skin_tone\": \"ğŸ™…ğŸ½\\u200dâ™‚ï¸\",\n    \"man_gesturing_ok\": \"ğŸ™†\\u200dâ™‚ï¸\",\n    \"man_gesturing_ok_dark_skin_tone\": \"ğŸ™†ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_gesturing_ok_light_skin_tone\": \"ğŸ™†ğŸ»\\u200dâ™‚ï¸\",\n    \"man_gesturing_ok_medium-dark_skin_tone\": \"ğŸ™†ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_gesturing_ok_medium-light_skin_tone\": \"ğŸ™†ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_gesturing_ok_medium_skin_tone\": \"ğŸ™†ğŸ½\\u200dâ™‚ï¸\",\n    \"man_getting_haircut\": \"ğŸ’‡\\u200dâ™‚ï¸\",\n    \"man_getting_haircut_dark_skin_tone\": \"ğŸ’‡ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_getting_haircut_light_skin_tone\": \"ğŸ’‡ğŸ»\\u200dâ™‚ï¸\",\n    \"man_getting_haircut_medium-dark_skin_tone\": \"ğŸ’‡ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_getting_haircut_medium-light_skin_tone\": \"ğŸ’‡ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_getting_haircut_medium_skin_tone\": \"ğŸ’‡ğŸ½\\u200dâ™‚ï¸\",\n    \"man_getting_massage\": \"ğŸ’†\\u200dâ™‚ï¸\",\n    \"man_getting_massage_dark_skin_tone\": \"ğŸ’†ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_getting_massage_light_skin_tone\": \"ğŸ’†ğŸ»\\u200dâ™‚ï¸\",\n    \"man_getting_massage_medium-dark_skin_tone\": \"ğŸ’†ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_getting_massage_medium-light_skin_tone\": \"ğŸ’†ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_getting_massage_medium_skin_tone\": \"ğŸ’†ğŸ½\\u200dâ™‚ï¸\",\n    \"man_golfing\": \"ğŸŒï¸\\u200dâ™‚ï¸\",\n    \"man_golfing_dark_skin_tone\": \"ğŸŒğŸ¿\\u200dâ™‚ï¸\",\n    \"man_golfing_light_skin_tone\": \"ğŸŒğŸ»\\u200dâ™‚ï¸\",\n    \"man_golfing_medium-dark_skin_tone\": \"ğŸŒğŸ¾\\u200dâ™‚ï¸\",\n    \"man_golfing_medium-light_skin_tone\": \"ğŸŒğŸ¼\\u200dâ™‚ï¸\",\n    \"man_golfing_medium_skin_tone\": \"ğŸŒğŸ½\\u200dâ™‚ï¸\",\n    \"man_guard\": \"ğŸ’‚\\u200dâ™‚ï¸\",\n    \"man_guard_dark_skin_tone\": \"ğŸ’‚ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_guard_light_skin_tone\": \"ğŸ’‚ğŸ»\\u200dâ™‚ï¸\",\n    \"man_guard_medium-dark_skin_tone\": \"ğŸ’‚ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_guard_medium-light_skin_tone\": \"ğŸ’‚ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_guard_medium_skin_tone\": \"ğŸ’‚ğŸ½\\u200dâ™‚ï¸\",\n    \"man_health_worker\": \"ğŸ‘¨\\u200dâš•ï¸\",\n    \"man_health_worker_dark_skin_tone\": \"ğŸ‘¨ğŸ¿\\u200dâš•ï¸\",\n    \"man_health_worker_light_skin_tone\": \"ğŸ‘¨ğŸ»\\u200dâš•ï¸\",\n    \"man_health_worker_medium-dark_skin_tone\": \"ğŸ‘¨ğŸ¾\\u200dâš•ï¸\",\n    \"man_health_worker_medium-light_skin_tone\": \"ğŸ‘¨ğŸ¼\\u200dâš•ï¸\",\n    \"man_health_worker_medium_skin_tone\": \"ğŸ‘¨ğŸ½\\u200dâš•ï¸\",\n    \"man_in_lotus_position\": \"ğŸ§˜\\u200dâ™‚ï¸\",\n    \"man_in_lotus_position_dark_skin_tone\": \"ğŸ§˜ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_in_lotus_position_light_skin_tone\": \"ğŸ§˜ğŸ»\\u200dâ™‚ï¸\",\n    \"man_in_lotus_position_medium-dark_skin_tone\": \"ğŸ§˜ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_in_lotus_position_medium-light_skin_tone\": \"ğŸ§˜ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_in_lotus_position_medium_skin_tone\": \"ğŸ§˜ğŸ½\\u200dâ™‚ï¸\",\n    \"man_in_manual_wheelchair\": \"ğŸ‘¨\\u200dğŸ¦½\",\n    \"man_in_motorized_wheelchair\": \"ğŸ‘¨\\u200dğŸ¦¼\",\n    \"man_in_steamy_room\": \"ğŸ§–\\u200dâ™‚ï¸\",\n    \"man_in_steamy_room_dark_skin_tone\": \"ğŸ§–ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_in_steamy_room_light_skin_tone\": \"ğŸ§–ğŸ»\\u200dâ™‚ï¸\",\n    \"man_in_steamy_room_medium-dark_skin_tone\": \"ğŸ§–ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_in_steamy_room_medium-light_skin_tone\": \"ğŸ§–ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_in_steamy_room_medium_skin_tone\": \"ğŸ§–ğŸ½\\u200dâ™‚ï¸\",\n    \"man_in_suit_levitating\": \"ğŸ•´\",\n    \"man_in_suit_levitating_dark_skin_tone\": \"ğŸ•´ğŸ¿\",\n    \"man_in_suit_levitating_light_skin_tone\": \"ğŸ•´ğŸ»\",\n    \"man_in_suit_levitating_medium-dark_skin_tone\": \"ğŸ•´ğŸ¾\",\n    \"man_in_suit_levitating_medium-light_skin_tone\": \"ğŸ•´ğŸ¼\",\n    \"man_in_suit_levitating_medium_skin_tone\": \"ğŸ•´ğŸ½\",\n    \"man_in_tuxedo\": \"ğŸ¤µ\",\n    \"man_in_tuxedo_dark_skin_tone\": \"ğŸ¤µğŸ¿\",\n    \"man_in_tuxedo_light_skin_tone\": \"ğŸ¤µğŸ»\",\n    \"man_in_tuxedo_medium-dark_skin_tone\": \"ğŸ¤µğŸ¾\",\n    \"man_in_tuxedo_medium-light_skin_tone\": \"ğŸ¤µğŸ¼\",\n    \"man_in_tuxedo_medium_skin_tone\": \"ğŸ¤µğŸ½\",\n    \"man_judge\": \"ğŸ‘¨\\u200dâš–ï¸\",\n    \"man_judge_dark_skin_tone\": \"ğŸ‘¨ğŸ¿\\u200dâš–ï¸\",\n    \"man_judge_light_skin_tone\": \"ğŸ‘¨ğŸ»\\u200dâš–ï¸\",\n    \"man_judge_medium-dark_skin_tone\": \"ğŸ‘¨ğŸ¾\\u200dâš–ï¸\",\n    \"man_judge_medium-light_skin_tone\": \"ğŸ‘¨ğŸ¼\\u200dâš–ï¸\",\n    \"man_judge_medium_skin_tone\": \"ğŸ‘¨ğŸ½\\u200dâš–ï¸\",\n    \"man_juggling\": \"ğŸ¤¹\\u200dâ™‚ï¸\",\n    \"man_juggling_dark_skin_tone\": \"ğŸ¤¹ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_juggling_light_skin_tone\": \"ğŸ¤¹ğŸ»\\u200dâ™‚ï¸\",\n    \"man_juggling_medium-dark_skin_tone\": \"ğŸ¤¹ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_juggling_medium-light_skin_tone\": \"ğŸ¤¹ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_juggling_medium_skin_tone\": \"ğŸ¤¹ğŸ½\\u200dâ™‚ï¸\",\n    \"man_lifting_weights\": \"ğŸ‹ï¸\\u200dâ™‚ï¸\",\n    \"man_lifting_weights_dark_skin_tone\": \"ğŸ‹ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_lifting_weights_light_skin_tone\": \"ğŸ‹ğŸ»\\u200dâ™‚ï¸\",\n    \"man_lifting_weights_medium-dark_skin_tone\": \"ğŸ‹ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_lifting_weights_medium-light_skin_tone\": \"ğŸ‹ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_lifting_weights_medium_skin_tone\": \"ğŸ‹ğŸ½\\u200dâ™‚ï¸\",\n    \"man_light_skin_tone\": \"ğŸ‘¨ğŸ»\",\n    \"man_mage\": \"ğŸ§™\\u200dâ™‚ï¸\",\n    \"man_mage_dark_skin_tone\": \"ğŸ§™ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_mage_light_skin_tone\": \"ğŸ§™ğŸ»\\u200dâ™‚ï¸\",\n    \"man_mage_medium-dark_skin_tone\": \"ğŸ§™ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_mage_medium-light_skin_tone\": \"ğŸ§™ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_mage_medium_skin_tone\": \"ğŸ§™ğŸ½\\u200dâ™‚ï¸\",\n    \"man_mechanic\": \"ğŸ‘¨\\u200dğŸ”§\",\n    \"man_mechanic_dark_skin_tone\": \"ğŸ‘¨ğŸ¿\\u200dğŸ”§\",\n    \"man_mechanic_light_skin_tone\": \"ğŸ‘¨ğŸ»\\u200dğŸ”§\",\n    \"man_mechanic_medium-dark_skin_tone\": \"ğŸ‘¨ğŸ¾\\u200dğŸ”§\",\n    \"man_mechanic_medium-light_skin_tone\": \"ğŸ‘¨ğŸ¼\\u200dğŸ”§\",\n    \"man_mechanic_medium_skin_tone\": \"ğŸ‘¨ğŸ½\\u200dğŸ”§\",\n    \"man_medium-dark_skin_tone\": \"ğŸ‘¨ğŸ¾\",\n    \"man_medium-light_skin_tone\": \"ğŸ‘¨ğŸ¼\",\n    \"man_medium_skin_tone\": \"ğŸ‘¨ğŸ½\",\n    \"man_mountain_biking\": \"ğŸšµ\\u200dâ™‚ï¸\",\n    \"man_mountain_biking_dark_skin_tone\": \"ğŸšµğŸ¿\\u200dâ™‚ï¸\",\n    \"man_mountain_biking_light_skin_tone\": \"ğŸšµğŸ»\\u200dâ™‚ï¸\",\n    \"man_mountain_biking_medium-dark_skin_tone\": \"ğŸšµğŸ¾\\u200dâ™‚ï¸\",\n    \"man_mountain_biking_medium-light_skin_tone\": \"ğŸšµğŸ¼\\u200dâ™‚ï¸\",\n    \"man_mountain_biking_medium_skin_tone\": \"ğŸšµğŸ½\\u200dâ™‚ï¸\",\n    \"man_office_worker\": \"ğŸ‘¨\\u200dğŸ’¼\",\n    \"man_office_worker_dark_skin_tone\": \"ğŸ‘¨ğŸ¿\\u200dğŸ’¼\",\n    \"man_office_worker_light_skin_tone\": \"ğŸ‘¨ğŸ»\\u200dğŸ’¼\",\n    \"man_office_worker_medium-dark_skin_tone\": \"ğŸ‘¨ğŸ¾\\u200dğŸ’¼\",\n    \"man_office_worker_medium-light_skin_tone\": \"ğŸ‘¨ğŸ¼\\u200dğŸ’¼\",\n    \"man_office_worker_medium_skin_tone\": \"ğŸ‘¨ğŸ½\\u200dğŸ’¼\",\n    \"man_pilot\": \"ğŸ‘¨\\u200dâœˆï¸\",\n    \"man_pilot_dark_skin_tone\": \"ğŸ‘¨ğŸ¿\\u200dâœˆï¸\",\n    \"man_pilot_light_skin_tone\": \"ğŸ‘¨ğŸ»\\u200dâœˆï¸\",\n    \"man_pilot_medium-dark_skin_tone\": \"ğŸ‘¨ğŸ¾\\u200dâœˆï¸\",\n    \"man_pilot_medium-light_skin_tone\": \"ğŸ‘¨ğŸ¼\\u200dâœˆï¸\",\n    \"man_pilot_medium_skin_tone\": \"ğŸ‘¨ğŸ½\\u200dâœˆï¸\",\n    \"man_playing_handball\": \"ğŸ¤¾\\u200dâ™‚ï¸\",\n    \"man_playing_handball_dark_skin_tone\": \"ğŸ¤¾ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_playing_handball_light_skin_tone\": \"ğŸ¤¾ğŸ»\\u200dâ™‚ï¸\",\n    \"man_playing_handball_medium-dark_skin_tone\": \"ğŸ¤¾ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_playing_handball_medium-light_skin_tone\": \"ğŸ¤¾ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_playing_handball_medium_skin_tone\": \"ğŸ¤¾ğŸ½\\u200dâ™‚ï¸\",\n    \"man_playing_water_polo\": \"ğŸ¤½\\u200dâ™‚ï¸\",\n    \"man_playing_water_polo_dark_skin_tone\": \"ğŸ¤½ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_playing_water_polo_light_skin_tone\": \"ğŸ¤½ğŸ»\\u200dâ™‚ï¸\",\n    \"man_playing_water_polo_medium-dark_skin_tone\": \"ğŸ¤½ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_playing_water_polo_medium-light_skin_tone\": \"ğŸ¤½ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_playing_water_polo_medium_skin_tone\": \"ğŸ¤½ğŸ½\\u200dâ™‚ï¸\",\n    \"man_police_officer\": \"ğŸ‘®\\u200dâ™‚ï¸\",\n    \"man_police_officer_dark_skin_tone\": \"ğŸ‘®ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_police_officer_light_skin_tone\": \"ğŸ‘®ğŸ»\\u200dâ™‚ï¸\",\n    \"man_police_officer_medium-dark_skin_tone\": \"ğŸ‘®ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_police_officer_medium-light_skin_tone\": \"ğŸ‘®ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_police_officer_medium_skin_tone\": \"ğŸ‘®ğŸ½\\u200dâ™‚ï¸\",\n    \"man_pouting\": \"ğŸ™\\u200dâ™‚ï¸\",\n    \"man_pouting_dark_skin_tone\": \"ğŸ™ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_pouting_light_skin_tone\": \"ğŸ™ğŸ»\\u200dâ™‚ï¸\",\n    \"man_pouting_medium-dark_skin_tone\": \"ğŸ™ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_pouting_medium-light_skin_tone\": \"ğŸ™ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_pouting_medium_skin_tone\": \"ğŸ™ğŸ½\\u200dâ™‚ï¸\",\n    \"man_raising_hand\": \"ğŸ™‹\\u200dâ™‚ï¸\",\n    \"man_raising_hand_dark_skin_tone\": \"ğŸ™‹ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_raising_hand_light_skin_tone\": \"ğŸ™‹ğŸ»\\u200dâ™‚ï¸\",\n    \"man_raising_hand_medium-dark_skin_tone\": \"ğŸ™‹ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_raising_hand_medium-light_skin_tone\": \"ğŸ™‹ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_raising_hand_medium_skin_tone\": \"ğŸ™‹ğŸ½\\u200dâ™‚ï¸\",\n    \"man_rowing_boat\": \"ğŸš£\\u200dâ™‚ï¸\",\n    \"man_rowing_boat_dark_skin_tone\": \"ğŸš£ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_rowing_boat_light_skin_tone\": \"ğŸš£ğŸ»\\u200dâ™‚ï¸\",\n    \"man_rowing_boat_medium-dark_skin_tone\": \"ğŸš£ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_rowing_boat_medium-light_skin_tone\": \"ğŸš£ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_rowing_boat_medium_skin_tone\": \"ğŸš£ğŸ½\\u200dâ™‚ï¸\",\n    \"man_running\": \"ğŸƒ\\u200dâ™‚ï¸\",\n    \"man_running_dark_skin_tone\": \"ğŸƒğŸ¿\\u200dâ™‚ï¸\",\n    \"man_running_light_skin_tone\": \"ğŸƒğŸ»\\u200dâ™‚ï¸\",\n    \"man_running_medium-dark_skin_tone\": \"ğŸƒğŸ¾\\u200dâ™‚ï¸\",\n    \"man_running_medium-light_skin_tone\": \"ğŸƒğŸ¼\\u200dâ™‚ï¸\",\n    \"man_running_medium_skin_tone\": \"ğŸƒğŸ½\\u200dâ™‚ï¸\",\n    \"man_scientist\": \"ğŸ‘¨\\u200dğŸ”¬\",\n    \"man_scientist_dark_skin_tone\": \"ğŸ‘¨ğŸ¿\\u200dğŸ”¬\",\n    \"man_scientist_light_skin_tone\": \"ğŸ‘¨ğŸ»\\u200dğŸ”¬\",\n    \"man_scientist_medium-dark_skin_tone\": \"ğŸ‘¨ğŸ¾\\u200dğŸ”¬\",\n    \"man_scientist_medium-light_skin_tone\": \"ğŸ‘¨ğŸ¼\\u200dğŸ”¬\",\n    \"man_scientist_medium_skin_tone\": \"ğŸ‘¨ğŸ½\\u200dğŸ”¬\",\n    \"man_shrugging\": \"ğŸ¤·\\u200dâ™‚ï¸\",\n    \"man_shrugging_dark_skin_tone\": \"ğŸ¤·ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_shrugging_light_skin_tone\": \"ğŸ¤·ğŸ»\\u200dâ™‚ï¸\",\n    \"man_shrugging_medium-dark_skin_tone\": \"ğŸ¤·ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_shrugging_medium-light_skin_tone\": \"ğŸ¤·ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_shrugging_medium_skin_tone\": \"ğŸ¤·ğŸ½\\u200dâ™‚ï¸\",\n    \"man_singer\": \"ğŸ‘¨\\u200dğŸ¤\",\n    \"man_singer_dark_skin_tone\": \"ğŸ‘¨ğŸ¿\\u200dğŸ¤\",\n    \"man_singer_light_skin_tone\": \"ğŸ‘¨ğŸ»\\u200dğŸ¤\",\n    \"man_singer_medium-dark_skin_tone\": \"ğŸ‘¨ğŸ¾\\u200dğŸ¤\",\n    \"man_singer_medium-light_skin_tone\": \"ğŸ‘¨ğŸ¼\\u200dğŸ¤\",\n    \"man_singer_medium_skin_tone\": \"ğŸ‘¨ğŸ½\\u200dğŸ¤\",\n    \"man_student\": \"ğŸ‘¨\\u200dğŸ“\",\n    \"man_student_dark_skin_tone\": \"ğŸ‘¨ğŸ¿\\u200dğŸ“\",\n    \"man_student_light_skin_tone\": \"ğŸ‘¨ğŸ»\\u200dğŸ“\",\n    \"man_student_medium-dark_skin_tone\": \"ğŸ‘¨ğŸ¾\\u200dğŸ“\",\n    \"man_student_medium-light_skin_tone\": \"ğŸ‘¨ğŸ¼\\u200dğŸ“\",\n    \"man_student_medium_skin_tone\": \"ğŸ‘¨ğŸ½\\u200dğŸ“\",\n    \"man_surfing\": \"ğŸ„\\u200dâ™‚ï¸\",\n    \"man_surfing_dark_skin_tone\": \"ğŸ„ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_surfing_light_skin_tone\": \"ğŸ„ğŸ»\\u200dâ™‚ï¸\",\n    \"man_surfing_medium-dark_skin_tone\": \"ğŸ„ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_surfing_medium-light_skin_tone\": \"ğŸ„ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_surfing_medium_skin_tone\": \"ğŸ„ğŸ½\\u200dâ™‚ï¸\",\n    \"man_swimming\": \"ğŸŠ\\u200dâ™‚ï¸\",\n    \"man_swimming_dark_skin_tone\": \"ğŸŠğŸ¿\\u200dâ™‚ï¸\",\n    \"man_swimming_light_skin_tone\": \"ğŸŠğŸ»\\u200dâ™‚ï¸\",\n    \"man_swimming_medium-dark_skin_tone\": \"ğŸŠğŸ¾\\u200dâ™‚ï¸\",\n    \"man_swimming_medium-light_skin_tone\": \"ğŸŠğŸ¼\\u200dâ™‚ï¸\",\n    \"man_swimming_medium_skin_tone\": \"ğŸŠğŸ½\\u200dâ™‚ï¸\",\n    \"man_teacher\": \"ğŸ‘¨\\u200dğŸ«\",\n    \"man_teacher_dark_skin_tone\": \"ğŸ‘¨ğŸ¿\\u200dğŸ«\",\n    \"man_teacher_light_skin_tone\": \"ğŸ‘¨ğŸ»\\u200dğŸ«\",\n    \"man_teacher_medium-dark_skin_tone\": \"ğŸ‘¨ğŸ¾\\u200dğŸ«\",\n    \"man_teacher_medium-light_skin_tone\": \"ğŸ‘¨ğŸ¼\\u200dğŸ«\",\n    \"man_teacher_medium_skin_tone\": \"ğŸ‘¨ğŸ½\\u200dğŸ«\",\n    \"man_technologist\": \"ğŸ‘¨\\u200dğŸ’»\",\n    \"man_technologist_dark_skin_tone\": \"ğŸ‘¨ğŸ¿\\u200dğŸ’»\",\n    \"man_technologist_light_skin_tone\": \"ğŸ‘¨ğŸ»\\u200dğŸ’»\",\n    \"man_technologist_medium-dark_skin_tone\": \"ğŸ‘¨ğŸ¾\\u200dğŸ’»\",\n    \"man_technologist_medium-light_skin_tone\": \"ğŸ‘¨ğŸ¼\\u200dğŸ’»\",\n    \"man_technologist_medium_skin_tone\": \"ğŸ‘¨ğŸ½\\u200dğŸ’»\",\n    \"man_tipping_hand\": \"ğŸ’\\u200dâ™‚ï¸\",\n    \"man_tipping_hand_dark_skin_tone\": \"ğŸ’ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_tipping_hand_light_skin_tone\": \"ğŸ’ğŸ»\\u200dâ™‚ï¸\",\n    \"man_tipping_hand_medium-dark_skin_tone\": \"ğŸ’ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_tipping_hand_medium-light_skin_tone\": \"ğŸ’ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_tipping_hand_medium_skin_tone\": \"ğŸ’ğŸ½\\u200dâ™‚ï¸\",\n    \"man_vampire\": \"ğŸ§›\\u200dâ™‚ï¸\",\n    \"man_vampire_dark_skin_tone\": \"ğŸ§›ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_vampire_light_skin_tone\": \"ğŸ§›ğŸ»\\u200dâ™‚ï¸\",\n    \"man_vampire_medium-dark_skin_tone\": \"ğŸ§›ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_vampire_medium-light_skin_tone\": \"ğŸ§›ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_vampire_medium_skin_tone\": \"ğŸ§›ğŸ½\\u200dâ™‚ï¸\",\n    \"man_walking\": \"ğŸš¶\\u200dâ™‚ï¸\",\n    \"man_walking_dark_skin_tone\": \"ğŸš¶ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_walking_light_skin_tone\": \"ğŸš¶ğŸ»\\u200dâ™‚ï¸\",\n    \"man_walking_medium-dark_skin_tone\": \"ğŸš¶ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_walking_medium-light_skin_tone\": \"ğŸš¶ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_walking_medium_skin_tone\": \"ğŸš¶ğŸ½\\u200dâ™‚ï¸\",\n    \"man_wearing_turban\": \"ğŸ‘³\\u200dâ™‚ï¸\",\n    \"man_wearing_turban_dark_skin_tone\": \"ğŸ‘³ğŸ¿\\u200dâ™‚ï¸\",\n    \"man_wearing_turban_light_skin_tone\": \"ğŸ‘³ğŸ»\\u200dâ™‚ï¸\",\n    \"man_wearing_turban_medium-dark_skin_tone\": \"ğŸ‘³ğŸ¾\\u200dâ™‚ï¸\",\n    \"man_wearing_turban_medium-light_skin_tone\": \"ğŸ‘³ğŸ¼\\u200dâ™‚ï¸\",\n    \"man_wearing_turban_medium_skin_tone\": \"ğŸ‘³ğŸ½\\u200dâ™‚ï¸\",\n    \"man_with_probing_cane\": \"ğŸ‘¨\\u200dğŸ¦¯\",\n    \"man_with_chinese_cap\": \"ğŸ‘²\",\n    \"man_with_chinese_cap_dark_skin_tone\": \"ğŸ‘²ğŸ¿\",\n    \"man_with_chinese_cap_light_skin_tone\": \"ğŸ‘²ğŸ»\",\n    \"man_with_chinese_cap_medium-dark_skin_tone\": \"ğŸ‘²ğŸ¾\",\n    \"man_with_chinese_cap_medium-light_skin_tone\": \"ğŸ‘²ğŸ¼\",\n    \"man_with_chinese_cap_medium_skin_tone\": \"ğŸ‘²ğŸ½\",\n    \"man_zombie\": \"ğŸ§Ÿ\\u200dâ™‚ï¸\",\n    \"mango\": \"ğŸ¥­\",\n    \"mantelpiece_clock\": \"ğŸ•°\",\n    \"manual_wheelchair\": \"ğŸ¦½\",\n    \"manâ€™s_shoe\": \"ğŸ‘\",\n    \"map_of_japan\": \"ğŸ—¾\",\n    \"maple_leaf\": \"ğŸ\",\n    \"martial_arts_uniform\": \"ğŸ¥‹\",\n    \"mate\": \"ğŸ§‰\",\n    \"meat_on_bone\": \"ğŸ–\",\n    \"mechanical_arm\": \"ğŸ¦¾\",\n    \"mechanical_leg\": \"ğŸ¦¿\",\n    \"medical_symbol\": \"âš•\",\n    \"megaphone\": \"ğŸ“£\",\n    \"melon\": \"ğŸˆ\",\n    \"memo\": \"ğŸ“\",\n    \"men_with_bunny_ears\": \"ğŸ‘¯\\u200dâ™‚ï¸\",\n    \"men_wrestling\": \"ğŸ¤¼\\u200dâ™‚ï¸\",\n    \"menorah\": \"ğŸ•\",\n    \"menâ€™s_room\": \"ğŸš¹\",\n    \"mermaid\": \"ğŸ§œ\\u200dâ™€ï¸\",\n    \"mermaid_dark_skin_tone\": \"ğŸ§œğŸ¿\\u200dâ™€ï¸\",\n    \"mermaid_light_skin_tone\": \"ğŸ§œğŸ»\\u200dâ™€ï¸\",\n    \"mermaid_medium-dark_skin_tone\": \"ğŸ§œğŸ¾\\u200dâ™€ï¸\",\n    \"mermaid_medium-light_skin_tone\": \"ğŸ§œğŸ¼\\u200dâ™€ï¸\",\n    \"mermaid_medium_skin_tone\": \"ğŸ§œğŸ½\\u200dâ™€ï¸\",\n    \"merman\": \"ğŸ§œ\\u200dâ™‚ï¸\",\n    \"merman_dark_skin_tone\": \"ğŸ§œğŸ¿\\u200dâ™‚ï¸\",\n    \"merman_light_skin_tone\": \"ğŸ§œğŸ»\\u200dâ™‚ï¸\",\n    \"merman_medium-dark_skin_tone\": \"ğŸ§œğŸ¾\\u200dâ™‚ï¸\",\n    \"merman_medium-light_skin_tone\": \"ğŸ§œğŸ¼\\u200dâ™‚ï¸\",\n    \"merman_medium_skin_tone\": \"ğŸ§œğŸ½\\u200dâ™‚ï¸\",\n    \"merperson\": \"ğŸ§œ\",\n    \"merperson_dark_skin_tone\": \"ğŸ§œğŸ¿\",\n    \"merperson_light_skin_tone\": \"ğŸ§œğŸ»\",\n    \"merperson_medium-dark_skin_tone\": \"ğŸ§œğŸ¾\",\n    \"merperson_medium-light_skin_tone\": \"ğŸ§œğŸ¼\",\n    \"merperson_medium_skin_tone\": \"ğŸ§œğŸ½\",\n    \"metro\": \"ğŸš‡\",\n    \"microbe\": \"ğŸ¦ \",\n    \"microphone\": \"ğŸ¤\",\n    \"microscope\": \"ğŸ”¬\",\n    \"middle_finger\": \"ğŸ–•\",\n    \"middle_finger_dark_skin_tone\": \"ğŸ–•ğŸ¿\",\n    \"middle_finger_light_skin_tone\": \"ğŸ–•ğŸ»\",\n    \"middle_finger_medium-dark_skin_tone\": \"ğŸ–•ğŸ¾\",\n    \"middle_finger_medium-light_skin_tone\": \"ğŸ–•ğŸ¼\",\n    \"middle_finger_medium_skin_tone\": \"ğŸ–•ğŸ½\",\n    \"military_medal\": \"ğŸ–\",\n    \"milky_way\": \"ğŸŒŒ\",\n    \"minibus\": \"ğŸš\",\n    \"moai\": \"ğŸ—¿\",\n    \"mobile_phone\": \"ğŸ“±\",\n    \"mobile_phone_off\": \"ğŸ“´\",\n    \"mobile_phone_with_arrow\": \"ğŸ“²\",\n    \"money-mouth_face\": \"ğŸ¤‘\",\n    \"money_bag\": \"ğŸ’°\",\n    \"money_with_wings\": \"ğŸ’¸\",\n    \"monkey\": \"ğŸ’\",\n    \"monkey_face\": \"ğŸµ\",\n    \"monorail\": \"ğŸš\",\n    \"moon_cake\": \"ğŸ¥®\",\n    \"moon_viewing_ceremony\": \"ğŸ‘\",\n    \"mosque\": \"ğŸ•Œ\",\n    \"mosquito\": \"ğŸ¦Ÿ\",\n    \"motor_boat\": \"ğŸ›¥\",\n    \"motor_scooter\": \"ğŸ›µ\",\n    \"motorcycle\": \"ğŸ\",\n    \"motorized_wheelchair\": \"ğŸ¦¼\",\n    \"motorway\": \"ğŸ›£\",\n    \"mount_fuji\": \"ğŸ—»\",\n    \"mountain\": \"â›°\",\n    \"mountain_cableway\": \"ğŸš \",\n    \"mountain_railway\": \"ğŸš\",\n    \"mouse\": \"ğŸ­\",\n    \"mouse_face\": \"ğŸ­\",\n    \"mouth\": \"ğŸ‘„\",\n    \"movie_camera\": \"ğŸ¥\",\n    \"mushroom\": \"ğŸ„\",\n    \"musical_keyboard\": \"ğŸ¹\",\n    \"musical_note\": \"ğŸµ\",\n    \"musical_notes\": \"ğŸ¶\",\n    \"musical_score\": \"ğŸ¼\",\n    \"muted_speaker\": \"ğŸ”‡\",\n    \"nail_polish\": \"ğŸ’…\",\n    \"nail_polish_dark_skin_tone\": \"ğŸ’…ğŸ¿\",\n    \"nail_polish_light_skin_tone\": \"ğŸ’…ğŸ»\",\n    \"nail_polish_medium-dark_skin_tone\": \"ğŸ’…ğŸ¾\",\n    \"nail_polish_medium-light_skin_tone\": \"ğŸ’…ğŸ¼\",\n    \"nail_polish_medium_skin_tone\": \"ğŸ’…ğŸ½\",\n    \"name_badge\": \"ğŸ“›\",\n    \"national_park\": \"ğŸ\",\n    \"nauseated_face\": \"ğŸ¤¢\",\n    \"nazar_amulet\": \"ğŸ§¿\",\n    \"necktie\": \"ğŸ‘”\",\n    \"nerd_face\": \"ğŸ¤“\",\n    \"neutral_face\": \"ğŸ˜\",\n    \"new_moon\": \"ğŸŒ‘\",\n    \"new_moon_face\": \"ğŸŒš\",\n    \"newspaper\": \"ğŸ“°\",\n    \"next_track_button\": \"â­\",\n    \"night_with_stars\": \"ğŸŒƒ\",\n    \"nine-thirty\": \"ğŸ•¤\",\n    \"nine_oâ€™clock\": \"ğŸ•˜\",\n    \"no_bicycles\": \"ğŸš³\",\n    \"no_entry\": \"â›”\",\n    \"no_littering\": \"ğŸš¯\",\n    \"no_mobile_phones\": \"ğŸ“µ\",\n    \"no_one_under_eighteen\": \"ğŸ”\",\n    \"no_pedestrians\": \"ğŸš·\",\n    \"no_smoking\": \"ğŸš­\",\n    \"non-potable_water\": \"ğŸš±\",\n    \"nose\": \"ğŸ‘ƒ\",\n    \"nose_dark_skin_tone\": \"ğŸ‘ƒğŸ¿\",\n    \"nose_light_skin_tone\": \"ğŸ‘ƒğŸ»\",\n    \"nose_medium-dark_skin_tone\": \"ğŸ‘ƒğŸ¾\",\n    \"nose_medium-light_skin_tone\": \"ğŸ‘ƒğŸ¼\",\n    \"nose_medium_skin_tone\": \"ğŸ‘ƒğŸ½\",\n    \"notebook\": \"ğŸ““\",\n    \"notebook_with_decorative_cover\": \"ğŸ“”\",\n    \"nut_and_bolt\": \"ğŸ”©\",\n    \"octopus\": \"ğŸ™\",\n    \"oden\": \"ğŸ¢\",\n    \"office_building\": \"ğŸ¢\",\n    \"ogre\": \"ğŸ‘¹\",\n    \"oil_drum\": \"ğŸ›¢\",\n    \"old_key\": \"ğŸ—\",\n    \"old_man\": \"ğŸ‘´\",\n    \"old_man_dark_skin_tone\": \"ğŸ‘´ğŸ¿\",\n    \"old_man_light_skin_tone\": \"ğŸ‘´ğŸ»\",\n    \"old_man_medium-dark_skin_tone\": \"ğŸ‘´ğŸ¾\",\n    \"old_man_medium-light_skin_tone\": \"ğŸ‘´ğŸ¼\",\n    \"old_man_medium_skin_tone\": \"ğŸ‘´ğŸ½\",\n    \"old_woman\": \"ğŸ‘µ\",\n    \"old_woman_dark_skin_tone\": \"ğŸ‘µğŸ¿\",\n    \"old_woman_light_skin_tone\": \"ğŸ‘µğŸ»\",\n    \"old_woman_medium-dark_skin_tone\": \"ğŸ‘µğŸ¾\",\n    \"old_woman_medium-light_skin_tone\": \"ğŸ‘µğŸ¼\",\n    \"old_woman_medium_skin_tone\": \"ğŸ‘µğŸ½\",\n    \"older_adult\": \"ğŸ§“\",\n    \"older_adult_dark_skin_tone\": \"ğŸ§“ğŸ¿\",\n    \"older_adult_light_skin_tone\": \"ğŸ§“ğŸ»\",\n    \"older_adult_medium-dark_skin_tone\": \"ğŸ§“ğŸ¾\",\n    \"older_adult_medium-light_skin_tone\": \"ğŸ§“ğŸ¼\",\n    \"older_adult_medium_skin_tone\": \"ğŸ§“ğŸ½\",\n    \"om\": \"ğŸ•‰\",\n    \"oncoming_automobile\": \"ğŸš˜\",\n    \"oncoming_bus\": \"ğŸš\",\n    \"oncoming_fist\": \"ğŸ‘Š\",\n    \"oncoming_fist_dark_skin_tone\": \"ğŸ‘ŠğŸ¿\",\n    \"oncoming_fist_light_skin_tone\": \"ğŸ‘ŠğŸ»\",\n    \"oncoming_fist_medium-dark_skin_tone\": \"ğŸ‘ŠğŸ¾\",\n    \"oncoming_fist_medium-light_skin_tone\": \"ğŸ‘ŠğŸ¼\",\n    \"oncoming_fist_medium_skin_tone\": \"ğŸ‘ŠğŸ½\",\n    \"oncoming_police_car\": \"ğŸš”\",\n    \"oncoming_taxi\": \"ğŸš–\",\n    \"one-piece_swimsuit\": \"ğŸ©±\",\n    \"one-thirty\": \"ğŸ•œ\",\n    \"one_oâ€™clock\": \"ğŸ•\",\n    \"onion\": \"ğŸ§…\",\n    \"open_book\": \"ğŸ“–\",\n    \"open_file_folder\": \"ğŸ“‚\",\n    \"open_hands\": \"ğŸ‘\",\n    \"open_hands_dark_skin_tone\": \"ğŸ‘ğŸ¿\",\n    \"open_hands_light_skin_tone\": \"ğŸ‘ğŸ»\",\n    \"open_hands_medium-dark_skin_tone\": \"ğŸ‘ğŸ¾\",\n    \"open_hands_medium-light_skin_tone\": \"ğŸ‘ğŸ¼\",\n    \"open_hands_medium_skin_tone\": \"ğŸ‘ğŸ½\",\n    \"open_mailbox_with_lowered_flag\": \"ğŸ“­\",\n    \"open_mailbox_with_raised_flag\": \"ğŸ“¬\",\n    \"optical_disk\": \"ğŸ’¿\",\n    \"orange_book\": \"ğŸ“™\",\n    \"orange_circle\": \"ğŸŸ \",\n    \"orange_heart\": \"ğŸ§¡\",\n    \"orange_square\": \"ğŸŸ§\",\n    \"orangutan\": \"ğŸ¦§\",\n    \"orthodox_cross\": \"â˜¦\",\n    \"otter\": \"ğŸ¦¦\",\n    \"outbox_tray\": \"ğŸ“¤\",\n    \"owl\": \"ğŸ¦‰\",\n    \"ox\": \"ğŸ‚\",\n    \"oyster\": \"ğŸ¦ª\",\n    \"package\": \"ğŸ“¦\",\n    \"page_facing_up\": \"ğŸ“„\",\n    \"page_with_curl\": \"ğŸ“ƒ\",\n    \"pager\": \"ğŸ“Ÿ\",\n    \"paintbrush\": \"ğŸ–Œ\",\n    \"palm_tree\": \"ğŸŒ´\",\n    \"palms_up_together\": \"ğŸ¤²\",\n    \"palms_up_together_dark_skin_tone\": \"ğŸ¤²ğŸ¿\",\n    \"palms_up_together_light_skin_tone\": \"ğŸ¤²ğŸ»\",\n    \"palms_up_together_medium-dark_skin_tone\": \"ğŸ¤²ğŸ¾\",\n    \"palms_up_together_medium-light_skin_tone\": \"ğŸ¤²ğŸ¼\",\n    \"palms_up_together_medium_skin_tone\": \"ğŸ¤²ğŸ½\",\n    \"pancakes\": \"ğŸ¥\",\n    \"panda_face\": \"ğŸ¼\",\n    \"paperclip\": \"ğŸ“\",\n    \"parrot\": \"ğŸ¦œ\",\n    \"part_alternation_mark\": \"ã€½\",\n    \"party_popper\": \"ğŸ‰\",\n    \"partying_face\": \"ğŸ¥³\",\n    \"passenger_ship\": \"ğŸ›³\",\n    \"passport_control\": \"ğŸ›‚\",\n    \"pause_button\": \"â¸\",\n    \"paw_prints\": \"ğŸ¾\",\n    \"peace_symbol\": \"â˜®\",\n    \"peach\": \"ğŸ‘\",\n    \"peacock\": \"ğŸ¦š\",\n    \"peanuts\": \"ğŸ¥œ\",\n    \"pear\": \"ğŸ\",\n    \"pen\": \"ğŸ–Š\",\n    \"pencil\": \"ğŸ“\",\n    \"penguin\": \"ğŸ§\",\n    \"pensive_face\": \"ğŸ˜”\",\n    \"people_holding_hands\": \"ğŸ§‘\\u200dğŸ¤\\u200dğŸ§‘\",\n    \"people_with_bunny_ears\": \"ğŸ‘¯\",\n    \"people_wrestling\": \"ğŸ¤¼\",\n    \"performing_arts\": \"ğŸ­\",\n    \"persevering_face\": \"ğŸ˜£\",\n    \"person_biking\": \"ğŸš´\",\n    \"person_biking_dark_skin_tone\": \"ğŸš´ğŸ¿\",\n    \"person_biking_light_skin_tone\": \"ğŸš´ğŸ»\",\n    \"person_biking_medium-dark_skin_tone\": \"ğŸš´ğŸ¾\",\n    \"person_biking_medium-light_skin_tone\": \"ğŸš´ğŸ¼\",\n    \"person_biking_medium_skin_tone\": \"ğŸš´ğŸ½\",\n    \"person_bouncing_ball\": \"â›¹\",\n    \"person_bouncing_ball_dark_skin_tone\": \"â›¹ğŸ¿\",\n    \"person_bouncing_ball_light_skin_tone\": \"â›¹ğŸ»\",\n    \"person_bouncing_ball_medium-dark_skin_tone\": \"â›¹ğŸ¾\",\n    \"person_bouncing_ball_medium-light_skin_tone\": \"â›¹ğŸ¼\",\n    \"person_bouncing_ball_medium_skin_tone\": \"â›¹ğŸ½\",\n    \"person_bowing\": \"ğŸ™‡\",\n    \"person_bowing_dark_skin_tone\": \"ğŸ™‡ğŸ¿\",\n    \"person_bowing_light_skin_tone\": \"ğŸ™‡ğŸ»\",\n    \"person_bowing_medium-dark_skin_tone\": \"ğŸ™‡ğŸ¾\",\n    \"person_bowing_medium-light_skin_tone\": \"ğŸ™‡ğŸ¼\",\n    \"person_bowing_medium_skin_tone\": \"ğŸ™‡ğŸ½\",\n    \"person_cartwheeling\": \"ğŸ¤¸\",\n    \"person_cartwheeling_dark_skin_tone\": \"ğŸ¤¸ğŸ¿\",\n    \"person_cartwheeling_light_skin_tone\": \"ğŸ¤¸ğŸ»\",\n    \"person_cartwheeling_medium-dark_skin_tone\": \"ğŸ¤¸ğŸ¾\",\n    \"person_cartwheeling_medium-light_skin_tone\": \"ğŸ¤¸ğŸ¼\",\n    \"person_cartwheeling_medium_skin_tone\": \"ğŸ¤¸ğŸ½\",\n    \"person_climbing\": \"ğŸ§—\",\n    \"person_climbing_dark_skin_tone\": \"ğŸ§—ğŸ¿\",\n    \"person_climbing_light_skin_tone\": \"ğŸ§—ğŸ»\",\n    \"person_climbing_medium-dark_skin_tone\": \"ğŸ§—ğŸ¾\",\n    \"person_climbing_medium-light_skin_tone\": \"ğŸ§—ğŸ¼\",\n    \"person_climbing_medium_skin_tone\": \"ğŸ§—ğŸ½\",\n    \"person_facepalming\": \"ğŸ¤¦\",\n    \"person_facepalming_dark_skin_tone\": \"ğŸ¤¦ğŸ¿\",\n    \"person_facepalming_light_skin_tone\": \"ğŸ¤¦ğŸ»\",\n    \"person_facepalming_medium-dark_skin_tone\": \"ğŸ¤¦ğŸ¾\",\n    \"person_facepalming_medium-light_skin_tone\": \"ğŸ¤¦ğŸ¼\",\n    \"person_facepalming_medium_skin_tone\": \"ğŸ¤¦ğŸ½\",\n    \"person_fencing\": \"ğŸ¤º\",\n    \"person_frowning\": \"ğŸ™\",\n    \"person_frowning_dark_skin_tone\": \"ğŸ™ğŸ¿\",\n    \"person_frowning_light_skin_tone\": \"ğŸ™ğŸ»\",\n    \"person_frowning_medium-dark_skin_tone\": \"ğŸ™ğŸ¾\",\n    \"person_frowning_medium-light_skin_tone\": \"ğŸ™ğŸ¼\",\n    \"person_frowning_medium_skin_tone\": \"ğŸ™ğŸ½\",\n    \"person_gesturing_no\": \"ğŸ™…\",\n    \"person_gesturing_no_dark_skin_tone\": \"ğŸ™…ğŸ¿\",\n    \"person_gesturing_no_light_skin_tone\": \"ğŸ™…ğŸ»\",\n    \"person_gesturing_no_medium-dark_skin_tone\": \"ğŸ™…ğŸ¾\",\n    \"person_gesturing_no_medium-light_skin_tone\": \"ğŸ™…ğŸ¼\",\n    \"person_gesturing_no_medium_skin_tone\": \"ğŸ™…ğŸ½\",\n    \"person_gesturing_ok\": \"ğŸ™†\",\n    \"person_gesturing_ok_dark_skin_tone\": \"ğŸ™†ğŸ¿\",\n    \"person_gesturing_ok_light_skin_tone\": \"ğŸ™†ğŸ»\",\n    \"person_gesturing_ok_medium-dark_skin_tone\": \"ğŸ™†ğŸ¾\",\n    \"person_gesturing_ok_medium-light_skin_tone\": \"ğŸ™†ğŸ¼\",\n    \"person_gesturing_ok_medium_skin_tone\": \"ğŸ™†ğŸ½\",\n    \"person_getting_haircut\": \"ğŸ’‡\",\n    \"person_getting_haircut_dark_skin_tone\": \"ğŸ’‡ğŸ¿\",\n    \"person_getting_haircut_light_skin_tone\": \"ğŸ’‡ğŸ»\",\n    \"person_getting_haircut_medium-dark_skin_tone\": \"ğŸ’‡ğŸ¾\",\n    \"person_getting_haircut_medium-light_skin_tone\": \"ğŸ’‡ğŸ¼\",\n    \"person_getting_haircut_medium_skin_tone\": \"ğŸ’‡ğŸ½\",\n    \"person_getting_massage\": \"ğŸ’†\",\n    \"person_getting_massage_dark_skin_tone\": \"ğŸ’†ğŸ¿\",\n    \"person_getting_massage_light_skin_tone\": \"ğŸ’†ğŸ»\",\n    \"person_getting_massage_medium-dark_skin_tone\": \"ğŸ’†ğŸ¾\",\n    \"person_getting_massage_medium-light_skin_tone\": \"ğŸ’†ğŸ¼\",\n    \"person_getting_massage_medium_skin_tone\": \"ğŸ’†ğŸ½\",\n    \"person_golfing\": \"ğŸŒ\",\n    \"person_golfing_dark_skin_tone\": \"ğŸŒğŸ¿\",\n    \"person_golfing_light_skin_tone\": \"ğŸŒğŸ»\",\n    \"person_golfing_medium-dark_skin_tone\": \"ğŸŒğŸ¾\",\n    \"person_golfing_medium-light_skin_tone\": \"ğŸŒğŸ¼\",\n    \"person_golfing_medium_skin_tone\": \"ğŸŒğŸ½\",\n    \"person_in_bed\": \"ğŸ›Œ\",\n    \"person_in_bed_dark_skin_tone\": \"ğŸ›ŒğŸ¿\",\n    \"person_in_bed_light_skin_tone\": \"ğŸ›ŒğŸ»\",\n    \"person_in_bed_medium-dark_skin_tone\": \"ğŸ›ŒğŸ¾\",\n    \"person_in_bed_medium-light_skin_tone\": \"ğŸ›ŒğŸ¼\",\n    \"person_in_bed_medium_skin_tone\": \"ğŸ›ŒğŸ½\",\n    \"person_in_lotus_position\": \"ğŸ§˜\",\n    \"person_in_lotus_position_dark_skin_tone\": \"ğŸ§˜ğŸ¿\",\n    \"person_in_lotus_position_light_skin_tone\": \"ğŸ§˜ğŸ»\",\n    \"person_in_lotus_position_medium-dark_skin_tone\": \"ğŸ§˜ğŸ¾\",\n    \"person_in_lotus_position_medium-light_skin_tone\": \"ğŸ§˜ğŸ¼\",\n    \"person_in_lotus_position_medium_skin_tone\": \"ğŸ§˜ğŸ½\",\n    \"person_in_steamy_room\": \"ğŸ§–\",\n    \"person_in_steamy_room_dark_skin_tone\": \"ğŸ§–ğŸ¿\",\n    \"person_in_steamy_room_light_skin_tone\": \"ğŸ§–ğŸ»\",\n    \"person_in_steamy_room_medium-dark_skin_tone\": \"ğŸ§–ğŸ¾\",\n    \"person_in_steamy_room_medium-light_skin_tone\": \"ğŸ§–ğŸ¼\",\n    \"person_in_steamy_room_medium_skin_tone\": \"ğŸ§–ğŸ½\",\n    \"person_juggling\": \"ğŸ¤¹\",\n    \"person_juggling_dark_skin_tone\": \"ğŸ¤¹ğŸ¿\",\n    \"person_juggling_light_skin_tone\": \"ğŸ¤¹ğŸ»\",\n    \"person_juggling_medium-dark_skin_tone\": \"ğŸ¤¹ğŸ¾\",\n    \"person_juggling_medium-light_skin_tone\": \"ğŸ¤¹ğŸ¼\",\n    \"person_juggling_medium_skin_tone\": \"ğŸ¤¹ğŸ½\",\n    \"person_kneeling\": \"ğŸ§\",\n    \"person_lifting_weights\": \"ğŸ‹\",\n    \"person_lifting_weights_dark_skin_tone\": \"ğŸ‹ğŸ¿\",\n    \"person_lifting_weights_light_skin_tone\": \"ğŸ‹ğŸ»\",\n    \"person_lifting_weights_medium-dark_skin_tone\": \"ğŸ‹ğŸ¾\",\n    \"person_lifting_weights_medium-light_skin_tone\": \"ğŸ‹ğŸ¼\",\n    \"person_lifting_weights_medium_skin_tone\": \"ğŸ‹ğŸ½\",\n    \"person_mountain_biking\": \"ğŸšµ\",\n    \"person_mountain_biking_dark_skin_tone\": \"ğŸšµğŸ¿\",\n    \"person_mountain_biking_light_skin_tone\": \"ğŸšµğŸ»\",\n    \"person_mountain_biking_medium-dark_skin_tone\": \"ğŸšµğŸ¾\",\n    \"person_mountain_biking_medium-light_skin_tone\": \"ğŸšµğŸ¼\",\n    \"person_mountain_biking_medium_skin_tone\": \"ğŸšµğŸ½\",\n    \"person_playing_handball\": \"ğŸ¤¾\",\n    \"person_playing_handball_dark_skin_tone\": \"ğŸ¤¾ğŸ¿\",\n    \"person_playing_handball_light_skin_tone\": \"ğŸ¤¾ğŸ»\",\n    \"person_playing_handball_medium-dark_skin_tone\": \"ğŸ¤¾ğŸ¾\",\n    \"person_playing_handball_medium-light_skin_tone\": \"ğŸ¤¾ğŸ¼\",\n    \"person_playing_handball_medium_skin_tone\": \"ğŸ¤¾ğŸ½\",\n    \"person_playing_water_polo\": \"ğŸ¤½\",\n    \"person_playing_water_polo_dark_skin_tone\": \"ğŸ¤½ğŸ¿\",\n    \"person_playing_water_polo_light_skin_tone\": \"ğŸ¤½ğŸ»\",\n    \"person_playing_water_polo_medium-dark_skin_tone\": \"ğŸ¤½ğŸ¾\",\n    \"person_playing_water_polo_medium-light_skin_tone\": \"ğŸ¤½ğŸ¼\",\n    \"person_playing_water_polo_medium_skin_tone\": \"ğŸ¤½ğŸ½\",\n    \"person_pouting\": \"ğŸ™\",\n    \"person_pouting_dark_skin_tone\": \"ğŸ™ğŸ¿\",\n    \"person_pouting_light_skin_tone\": \"ğŸ™ğŸ»\",\n    \"person_pouting_medium-dark_skin_tone\": \"ğŸ™ğŸ¾\",\n    \"person_pouting_medium-light_skin_tone\": \"ğŸ™ğŸ¼\",\n    \"person_pouting_medium_skin_tone\": \"ğŸ™ğŸ½\",\n    \"person_raising_hand\": \"ğŸ™‹\",\n    \"person_raising_hand_dark_skin_tone\": \"ğŸ™‹ğŸ¿\",\n    \"person_raising_hand_light_skin_tone\": \"ğŸ™‹ğŸ»\",\n    \"person_raising_hand_medium-dark_skin_tone\": \"ğŸ™‹ğŸ¾\",\n    \"person_raising_hand_medium-light_skin_tone\": \"ğŸ™‹ğŸ¼\",\n    \"person_raising_hand_medium_skin_tone\": \"ğŸ™‹ğŸ½\",\n    \"person_rowing_boat\": \"ğŸš£\",\n    \"person_rowing_boat_dark_skin_tone\": \"ğŸš£ğŸ¿\",\n    \"person_rowing_boat_light_skin_tone\": \"ğŸš£ğŸ»\",\n    \"person_rowing_boat_medium-dark_skin_tone\": \"ğŸš£ğŸ¾\",\n    \"person_rowing_boat_medium-light_skin_tone\": \"ğŸš£ğŸ¼\",\n    \"person_rowing_boat_medium_skin_tone\": \"ğŸš£ğŸ½\",\n    \"person_running\": \"ğŸƒ\",\n    \"person_running_dark_skin_tone\": \"ğŸƒğŸ¿\",\n    \"person_running_light_skin_tone\": \"ğŸƒğŸ»\",\n    \"person_running_medium-dark_skin_tone\": \"ğŸƒğŸ¾\",\n    \"person_running_medium-light_skin_tone\": \"ğŸƒğŸ¼\",\n    \"person_running_medium_skin_tone\": \"ğŸƒğŸ½\",\n    \"person_shrugging\": \"ğŸ¤·\",\n    \"person_shrugging_dark_skin_tone\": \"ğŸ¤·ğŸ¿\",\n    \"person_shrugging_light_skin_tone\": \"ğŸ¤·ğŸ»\",\n    \"person_shrugging_medium-dark_skin_tone\": \"ğŸ¤·ğŸ¾\",\n    \"person_shrugging_medium-light_skin_tone\": \"ğŸ¤·ğŸ¼\",\n    \"person_shrugging_medium_skin_tone\": \"ğŸ¤·ğŸ½\",\n    \"person_standing\": \"ğŸ§\",\n    \"person_surfing\": \"ğŸ„\",\n    \"person_surfing_dark_skin_tone\": \"ğŸ„ğŸ¿\",\n    \"person_surfing_light_skin_tone\": \"ğŸ„ğŸ»\",\n    \"person_surfing_medium-dark_skin_tone\": \"ğŸ„ğŸ¾\",\n    \"person_surfing_medium-light_skin_tone\": \"ğŸ„ğŸ¼\",\n    \"person_surfing_medium_skin_tone\": \"ğŸ„ğŸ½\",\n    \"person_swimming\": \"ğŸŠ\",\n    \"person_swimming_dark_skin_tone\": \"ğŸŠğŸ¿\",\n    \"person_swimming_light_skin_tone\": \"ğŸŠğŸ»\",\n    \"person_swimming_medium-dark_skin_tone\": \"ğŸŠğŸ¾\",\n    \"person_swimming_medium-light_skin_tone\": \"ğŸŠğŸ¼\",\n    \"person_swimming_medium_skin_tone\": \"ğŸŠğŸ½\",\n    \"person_taking_bath\": \"ğŸ›€\",\n    \"person_taking_bath_dark_skin_tone\": \"ğŸ›€ğŸ¿\",\n    \"person_taking_bath_light_skin_tone\": \"ğŸ›€ğŸ»\",\n    \"person_taking_bath_medium-dark_skin_tone\": \"ğŸ›€ğŸ¾\",\n    \"person_taking_bath_medium-light_skin_tone\": \"ğŸ›€ğŸ¼\",\n    \"person_taking_bath_medium_skin_tone\": \"ğŸ›€ğŸ½\",\n    \"person_tipping_hand\": \"ğŸ’\",\n    \"person_tipping_hand_dark_skin_tone\": \"ğŸ’ğŸ¿\",\n    \"person_tipping_hand_light_skin_tone\": \"ğŸ’ğŸ»\",\n    \"person_tipping_hand_medium-dark_skin_tone\": \"ğŸ’ğŸ¾\",\n    \"person_tipping_hand_medium-light_skin_tone\": \"ğŸ’ğŸ¼\",\n    \"person_tipping_hand_medium_skin_tone\": \"ğŸ’ğŸ½\",\n    \"person_walking\": \"ğŸš¶\",\n    \"person_walking_dark_skin_tone\": \"ğŸš¶ğŸ¿\",\n    \"person_walking_light_skin_tone\": \"ğŸš¶ğŸ»\",\n    \"person_walking_medium-dark_skin_tone\": \"ğŸš¶ğŸ¾\",\n    \"person_walking_medium-light_skin_tone\": \"ğŸš¶ğŸ¼\",\n    \"person_walking_medium_skin_tone\": \"ğŸš¶ğŸ½\",\n    \"person_wearing_turban\": \"ğŸ‘³\",\n    \"person_wearing_turban_dark_skin_tone\": \"ğŸ‘³ğŸ¿\",\n    \"person_wearing_turban_light_skin_tone\": \"ğŸ‘³ğŸ»\",\n    \"person_wearing_turban_medium-dark_skin_tone\": \"ğŸ‘³ğŸ¾\",\n    \"person_wearing_turban_medium-light_skin_tone\": \"ğŸ‘³ğŸ¼\",\n    \"person_wearing_turban_medium_skin_tone\": \"ğŸ‘³ğŸ½\",\n    \"petri_dish\": \"ğŸ§«\",\n    \"pick\": \"â›\",\n    \"pie\": \"ğŸ¥§\",\n    \"pig\": \"ğŸ·\",\n    \"pig_face\": \"ğŸ·\",\n    \"pig_nose\": \"ğŸ½\",\n    \"pile_of_poo\": \"ğŸ’©\",\n    \"pill\": \"ğŸ’Š\",\n    \"pinching_hand\": \"ğŸ¤\",\n    \"pine_decoration\": \"ğŸ\",\n    \"pineapple\": \"ğŸ\",\n    \"ping_pong\": \"ğŸ“\",\n    \"pirate_flag\": \"ğŸ´\\u200dâ˜ ï¸\",\n    \"pistol\": \"ğŸ”«\",\n    \"pizza\": \"ğŸ•\",\n    \"place_of_worship\": \"ğŸ›\",\n    \"play_button\": \"â–¶\",\n    \"play_or_pause_button\": \"â¯\",\n    \"pleading_face\": \"ğŸ¥º\",\n    \"police_car\": \"ğŸš“\",\n    \"police_car_light\": \"ğŸš¨\",\n    \"police_officer\": \"ğŸ‘®\",\n    \"police_officer_dark_skin_tone\": \"ğŸ‘®ğŸ¿\",\n    \"police_officer_light_skin_tone\": \"ğŸ‘®ğŸ»\",\n    \"police_officer_medium-dark_skin_tone\": \"ğŸ‘®ğŸ¾\",\n    \"police_officer_medium-light_skin_tone\": \"ğŸ‘®ğŸ¼\",\n    \"police_officer_medium_skin_tone\": \"ğŸ‘®ğŸ½\",\n    \"poodle\": \"ğŸ©\",\n    \"pool_8_ball\": \"ğŸ±\",\n    \"popcorn\": \"ğŸ¿\",\n    \"post_office\": \"ğŸ£\",\n    \"postal_horn\": \"ğŸ“¯\",\n    \"postbox\": \"ğŸ“®\",\n    \"pot_of_food\": \"ğŸ²\",\n    \"potable_water\": \"ğŸš°\",\n    \"potato\": \"ğŸ¥”\",\n    \"poultry_leg\": \"ğŸ—\",\n    \"pound_banknote\": \"ğŸ’·\",\n    \"pouting_cat_face\": \"ğŸ˜¾\",\n    \"pouting_face\": \"ğŸ˜¡\",\n    \"prayer_beads\": \"ğŸ“¿\",\n    \"pregnant_woman\": \"ğŸ¤°\",\n    \"pregnant_woman_dark_skin_tone\": \"ğŸ¤°ğŸ¿\",\n    \"pregnant_woman_light_skin_tone\": \"ğŸ¤°ğŸ»\",\n    \"pregnant_woman_medium-dark_skin_tone\": \"ğŸ¤°ğŸ¾\",\n    \"pregnant_woman_medium-light_skin_tone\": \"ğŸ¤°ğŸ¼\",\n    \"pregnant_woman_medium_skin_tone\": \"ğŸ¤°ğŸ½\",\n    \"pretzel\": \"ğŸ¥¨\",\n    \"probing_cane\": \"ğŸ¦¯\",\n    \"prince\": \"ğŸ¤´\",\n    \"prince_dark_skin_tone\": \"ğŸ¤´ğŸ¿\",\n    \"prince_light_skin_tone\": \"ğŸ¤´ğŸ»\",\n    \"prince_medium-dark_skin_tone\": \"ğŸ¤´ğŸ¾\",\n    \"prince_medium-light_skin_tone\": \"ğŸ¤´ğŸ¼\",\n    \"prince_medium_skin_tone\": \"ğŸ¤´ğŸ½\",\n    \"princess\": \"ğŸ‘¸\",\n    \"princess_dark_skin_tone\": \"ğŸ‘¸ğŸ¿\",\n    \"princess_light_skin_tone\": \"ğŸ‘¸ğŸ»\",\n    \"princess_medium-dark_skin_tone\": \"ğŸ‘¸ğŸ¾\",\n    \"princess_medium-light_skin_tone\": \"ğŸ‘¸ğŸ¼\",\n    \"princess_medium_skin_tone\": \"ğŸ‘¸ğŸ½\",\n    \"printer\": \"ğŸ–¨\",\n    \"prohibited\": \"ğŸš«\",\n    \"purple_circle\": \"ğŸŸ£\",\n    \"purple_heart\": \"ğŸ’œ\",\n    \"purple_square\": \"ğŸŸª\",\n    \"purse\": \"ğŸ‘›\",\n    \"pushpin\": \"ğŸ“Œ\",\n    \"question_mark\": \"â“\",\n    \"rabbit\": \"ğŸ°\",\n    \"rabbit_face\": \"ğŸ°\",\n    \"raccoon\": \"ğŸ¦\",\n    \"racing_car\": \"ğŸ\",\n    \"radio\": \"ğŸ“»\",\n    \"radio_button\": \"ğŸ”˜\",\n    \"radioactive\": \"â˜¢\",\n    \"railway_car\": \"ğŸšƒ\",\n    \"railway_track\": \"ğŸ›¤\",\n    \"rainbow\": \"ğŸŒˆ\",\n    \"rainbow_flag\": \"ğŸ³ï¸\\u200dğŸŒˆ\",\n    \"raised_back_of_hand\": \"ğŸ¤š\",\n    \"raised_back_of_hand_dark_skin_tone\": \"ğŸ¤šğŸ¿\",\n    \"raised_back_of_hand_light_skin_tone\": \"ğŸ¤šğŸ»\",\n    \"raised_back_of_hand_medium-dark_skin_tone\": \"ğŸ¤šğŸ¾\",\n    \"raised_back_of_hand_medium-light_skin_tone\": \"ğŸ¤šğŸ¼\",\n    \"raised_back_of_hand_medium_skin_tone\": \"ğŸ¤šğŸ½\",\n    \"raised_fist\": \"âœŠ\",\n    \"raised_fist_dark_skin_tone\": \"âœŠğŸ¿\",\n    \"raised_fist_light_skin_tone\": \"âœŠğŸ»\",\n    \"raised_fist_medium-dark_skin_tone\": \"âœŠğŸ¾\",\n    \"raised_fist_medium-light_skin_tone\": \"âœŠğŸ¼\",\n    \"raised_fist_medium_skin_tone\": \"âœŠğŸ½\",\n    \"raised_hand\": \"âœ‹\",\n    \"raised_hand_dark_skin_tone\": \"âœ‹ğŸ¿\",\n    \"raised_hand_light_skin_tone\": \"âœ‹ğŸ»\",\n    \"raised_hand_medium-dark_skin_tone\": \"âœ‹ğŸ¾\",\n    \"raised_hand_medium-light_skin_tone\": \"âœ‹ğŸ¼\",\n    \"raised_hand_medium_skin_tone\": \"âœ‹ğŸ½\",\n    \"raising_hands\": \"ğŸ™Œ\",\n    \"raising_hands_dark_skin_tone\": \"ğŸ™ŒğŸ¿\",\n    \"raising_hands_light_skin_tone\": \"ğŸ™ŒğŸ»\",\n    \"raising_hands_medium-dark_skin_tone\": \"ğŸ™ŒğŸ¾\",\n    \"raising_hands_medium-light_skin_tone\": \"ğŸ™ŒğŸ¼\",\n    \"raising_hands_medium_skin_tone\": \"ğŸ™ŒğŸ½\",\n    \"ram\": \"ğŸ\",\n    \"rat\": \"ğŸ€\",\n    \"razor\": \"ğŸª’\",\n    \"ringed_planet\": \"ğŸª\",\n    \"receipt\": \"ğŸ§¾\",\n    \"record_button\": \"âº\",\n    \"recycling_symbol\": \"â™»\",\n    \"red_apple\": \"ğŸ\",\n    \"red_circle\": \"ğŸ”´\",\n    \"red_envelope\": \"ğŸ§§\",\n    \"red_hair\": \"ğŸ¦°\",\n    \"red-haired_man\": \"ğŸ‘¨\\u200dğŸ¦°\",\n    \"red-haired_woman\": \"ğŸ‘©\\u200dğŸ¦°\",\n    \"red_heart\": \"â¤\",\n    \"red_paper_lantern\": \"ğŸ®\",\n    \"red_square\": \"ğŸŸ¥\",\n    \"red_triangle_pointed_down\": \"ğŸ”»\",\n    \"red_triangle_pointed_up\": \"ğŸ”º\",\n    \"registered\": \"Â®\",\n    \"relieved_face\": \"ğŸ˜Œ\",\n    \"reminder_ribbon\": \"ğŸ—\",\n    \"repeat_button\": \"ğŸ”\",\n    \"repeat_single_button\": \"ğŸ”‚\",\n    \"rescue_workerâ€™s_helmet\": \"â›‘\",\n    \"restroom\": \"ğŸš»\",\n    \"reverse_button\": \"â—€\",\n    \"revolving_hearts\": \"ğŸ’\",\n    \"rhinoceros\": \"ğŸ¦\",\n    \"ribbon\": \"ğŸ€\",\n    \"rice_ball\": \"ğŸ™\",\n    \"rice_cracker\": \"ğŸ˜\",\n    \"right-facing_fist\": \"ğŸ¤œ\",\n    \"right-facing_fist_dark_skin_tone\": \"ğŸ¤œğŸ¿\",\n    \"right-facing_fist_light_skin_tone\": \"ğŸ¤œğŸ»\",\n    \"right-facing_fist_medium-dark_skin_tone\": \"ğŸ¤œğŸ¾\",\n    \"right-facing_fist_medium-light_skin_tone\": \"ğŸ¤œğŸ¼\",\n    \"right-facing_fist_medium_skin_tone\": \"ğŸ¤œğŸ½\",\n    \"right_anger_bubble\": \"ğŸ—¯\",\n    \"right_arrow\": \"â¡\",\n    \"right_arrow_curving_down\": \"â¤µ\",\n    \"right_arrow_curving_left\": \"â†©\",\n    \"right_arrow_curving_up\": \"â¤´\",\n    \"ring\": \"ğŸ’\",\n    \"roasted_sweet_potato\": \"ğŸ \",\n    \"robot_face\": \"ğŸ¤–\",\n    \"rocket\": \"ğŸš€\",\n    \"roll_of_paper\": \"ğŸ§»\",\n    \"rolled-up_newspaper\": \"ğŸ—\",\n    \"roller_coaster\": \"ğŸ¢\",\n    \"rolling_on_the_floor_laughing\": \"ğŸ¤£\",\n    \"rooster\": \"ğŸ“\",\n    \"rose\": \"ğŸŒ¹\",\n    \"rosette\": \"ğŸµ\",\n    \"round_pushpin\": \"ğŸ“\",\n    \"rugby_football\": \"ğŸ‰\",\n    \"running_shirt\": \"ğŸ½\",\n    \"running_shoe\": \"ğŸ‘Ÿ\",\n    \"sad_but_relieved_face\": \"ğŸ˜¥\",\n    \"safety_pin\": \"ğŸ§·\",\n    \"safety_vest\": \"ğŸ¦º\",\n    \"salt\": \"ğŸ§‚\",\n    \"sailboat\": \"â›µ\",\n    \"sake\": \"ğŸ¶\",\n    \"sandwich\": \"ğŸ¥ª\",\n    \"sari\": \"ğŸ¥»\",\n    \"satellite\": \"ğŸ“¡\",\n    \"satellite_antenna\": \"ğŸ“¡\",\n    \"sauropod\": \"ğŸ¦•\",\n    \"saxophone\": \"ğŸ·\",\n    \"scarf\": \"ğŸ§£\",\n    \"school\": \"ğŸ«\",\n    \"school_backpack\": \"ğŸ’\",\n    \"scissors\": \"âœ‚\",\n    \"scorpion\": \"ğŸ¦‚\",\n    \"scroll\": \"ğŸ“œ\",\n    \"seat\": \"ğŸ’º\",\n    \"see-no-evil_monkey\": \"ğŸ™ˆ\",\n    \"seedling\": \"ğŸŒ±\",\n    \"selfie\": \"ğŸ¤³\",\n    \"selfie_dark_skin_tone\": \"ğŸ¤³ğŸ¿\",\n    \"selfie_light_skin_tone\": \"ğŸ¤³ğŸ»\",\n    \"selfie_medium-dark_skin_tone\": \"ğŸ¤³ğŸ¾\",\n    \"selfie_medium-light_skin_tone\": \"ğŸ¤³ğŸ¼\",\n    \"selfie_medium_skin_tone\": \"ğŸ¤³ğŸ½\",\n    \"service_dog\": \"ğŸ•\\u200dğŸ¦º\",\n    \"seven-thirty\": \"ğŸ•¢\",\n    \"seven_oâ€™clock\": \"ğŸ•–\",\n    \"shallow_pan_of_food\": \"ğŸ¥˜\",\n    \"shamrock\": \"â˜˜\",\n    \"shark\": \"ğŸ¦ˆ\",\n    \"shaved_ice\": \"ğŸ§\",\n    \"sheaf_of_rice\": \"ğŸŒ¾\",\n    \"shield\": \"ğŸ›¡\",\n    \"shinto_shrine\": \"â›©\",\n    \"ship\": \"ğŸš¢\",\n    \"shooting_star\": \"ğŸŒ \",\n    \"shopping_bags\": \"ğŸ›\",\n    \"shopping_cart\": \"ğŸ›’\",\n    \"shortcake\": \"ğŸ°\",\n    \"shorts\": \"ğŸ©³\",\n    \"shower\": \"ğŸš¿\",\n    \"shrimp\": \"ğŸ¦\",\n    \"shuffle_tracks_button\": \"ğŸ”€\",\n    \"shushing_face\": \"ğŸ¤«\",\n    \"sign_of_the_horns\": \"ğŸ¤˜\",\n    \"sign_of_the_horns_dark_skin_tone\": \"ğŸ¤˜ğŸ¿\",\n    \"sign_of_the_horns_light_skin_tone\": \"ğŸ¤˜ğŸ»\",\n    \"sign_of_the_horns_medium-dark_skin_tone\": \"ğŸ¤˜ğŸ¾\",\n    \"sign_of_the_horns_medium-light_skin_tone\": \"ğŸ¤˜ğŸ¼\",\n    \"sign_of_the_horns_medium_skin_tone\": \"ğŸ¤˜ğŸ½\",\n    \"six-thirty\": \"ğŸ•¡\",\n    \"six_oâ€™clock\": \"ğŸ••\",\n    \"skateboard\": \"ğŸ›¹\",\n    \"skier\": \"â›·\",\n    \"skis\": \"ğŸ¿\",\n    \"skull\": \"ğŸ’€\",\n    \"skull_and_crossbones\": \"â˜ \",\n    \"skunk\": \"ğŸ¦¨\",\n    \"sled\": \"ğŸ›·\",\n    \"sleeping_face\": \"ğŸ˜´\",\n    \"sleepy_face\": \"ğŸ˜ª\",\n    \"slightly_frowning_face\": \"ğŸ™\",\n    \"slightly_smiling_face\": \"ğŸ™‚\",\n    \"slot_machine\": \"ğŸ°\",\n    \"sloth\": \"ğŸ¦¥\",\n    \"small_airplane\": \"ğŸ›©\",\n    \"small_blue_diamond\": \"ğŸ”¹\",\n    \"small_orange_diamond\": \"ğŸ”¸\",\n    \"smiling_cat_face_with_heart-eyes\": \"ğŸ˜»\",\n    \"smiling_face\": \"â˜º\",\n    \"smiling_face_with_halo\": \"ğŸ˜‡\",\n    \"smiling_face_with_3_hearts\": \"ğŸ¥°\",\n    \"smiling_face_with_heart-eyes\": \"ğŸ˜\",\n    \"smiling_face_with_horns\": \"ğŸ˜ˆ\",\n    \"smiling_face_with_smiling_eyes\": \"ğŸ˜Š\",\n    \"smiling_face_with_sunglasses\": \"ğŸ˜\",\n    \"smirking_face\": \"ğŸ˜\",\n    \"snail\": \"ğŸŒ\",\n    \"snake\": \"ğŸ\",\n    \"sneezing_face\": \"ğŸ¤§\",\n    \"snow-capped_mountain\": \"ğŸ”\",\n    \"snowboarder\": \"ğŸ‚\",\n    \"snowboarder_dark_skin_tone\": \"ğŸ‚ğŸ¿\",\n    \"snowboarder_light_skin_tone\": \"ğŸ‚ğŸ»\",\n    \"snowboarder_medium-dark_skin_tone\": \"ğŸ‚ğŸ¾\",\n    \"snowboarder_medium-light_skin_tone\": \"ğŸ‚ğŸ¼\",\n    \"snowboarder_medium_skin_tone\": \"ğŸ‚ğŸ½\",\n    \"snowflake\": \"â„\",\n    \"snowman\": \"â˜ƒ\",\n    \"snowman_without_snow\": \"â›„\",\n    \"soap\": \"ğŸ§¼\",\n    \"soccer_ball\": \"âš½\",\n    \"socks\": \"ğŸ§¦\",\n    \"softball\": \"ğŸ¥\",\n    \"soft_ice_cream\": \"ğŸ¦\",\n    \"spade_suit\": \"â™ \",\n    \"spaghetti\": \"ğŸ\",\n    \"sparkle\": \"â‡\",\n    \"sparkler\": \"ğŸ‡\",\n    \"sparkles\": \"âœ¨\",\n    \"sparkling_heart\": \"ğŸ’–\",\n    \"speak-no-evil_monkey\": \"ğŸ™Š\",\n    \"speaker_high_volume\": \"ğŸ”Š\",\n    \"speaker_low_volume\": \"ğŸ”ˆ\",\n    \"speaker_medium_volume\": \"ğŸ”‰\",\n    \"speaking_head\": \"ğŸ—£\",\n    \"speech_balloon\": \"ğŸ’¬\",\n    \"speedboat\": \"ğŸš¤\",\n    \"spider\": \"ğŸ•·\",\n    \"spider_web\": \"ğŸ•¸\",\n    \"spiral_calendar\": \"ğŸ—“\",\n    \"spiral_notepad\": \"ğŸ—’\",\n    \"spiral_shell\": \"ğŸš\",\n    \"spoon\": \"ğŸ¥„\",\n    \"sponge\": \"ğŸ§½\",\n    \"sport_utility_vehicle\": \"ğŸš™\",\n    \"sports_medal\": \"ğŸ…\",\n    \"spouting_whale\": \"ğŸ³\",\n    \"squid\": \"ğŸ¦‘\",\n    \"squinting_face_with_tongue\": \"ğŸ˜\",\n    \"stadium\": \"ğŸŸ\",\n    \"star-struck\": \"ğŸ¤©\",\n    \"star_and_crescent\": \"â˜ª\",\n    \"star_of_david\": \"âœ¡\",\n    \"station\": \"ğŸš‰\",\n    \"steaming_bowl\": \"ğŸœ\",\n    \"stethoscope\": \"ğŸ©º\",\n    \"stop_button\": \"â¹\",\n    \"stop_sign\": \"ğŸ›‘\",\n    \"stopwatch\": \"â±\",\n    \"straight_ruler\": \"ğŸ“\",\n    \"strawberry\": \"ğŸ“\",\n    \"studio_microphone\": \"ğŸ™\",\n    \"stuffed_flatbread\": \"ğŸ¥™\",\n    \"sun\": \"â˜€\",\n    \"sun_behind_cloud\": \"â›…\",\n    \"sun_behind_large_cloud\": \"ğŸŒ¥\",\n    \"sun_behind_rain_cloud\": \"ğŸŒ¦\",\n    \"sun_behind_small_cloud\": \"ğŸŒ¤\",\n    \"sun_with_face\": \"ğŸŒ\",\n    \"sunflower\": \"ğŸŒ»\",\n    \"sunglasses\": \"ğŸ˜\",\n    \"sunrise\": \"ğŸŒ…\",\n    \"sunrise_over_mountains\": \"ğŸŒ„\",\n    \"sunset\": \"ğŸŒ‡\",\n    \"superhero\": \"ğŸ¦¸\",\n    \"supervillain\": \"ğŸ¦¹\",\n    \"sushi\": \"ğŸ£\",\n    \"suspension_railway\": \"ğŸšŸ\",\n    \"swan\": \"ğŸ¦¢\",\n    \"sweat_droplets\": \"ğŸ’¦\",\n    \"synagogue\": \"ğŸ•\",\n    \"syringe\": \"ğŸ’‰\",\n    \"t-shirt\": \"ğŸ‘•\",\n    \"taco\": \"ğŸŒ®\",\n    \"takeout_box\": \"ğŸ¥¡\",\n    \"tanabata_tree\": \"ğŸ‹\",\n    \"tangerine\": \"ğŸŠ\",\n    \"taxi\": \"ğŸš•\",\n    \"teacup_without_handle\": \"ğŸµ\",\n    \"tear-off_calendar\": \"ğŸ“†\",\n    \"teddy_bear\": \"ğŸ§¸\",\n    \"telephone\": \"â˜\",\n    \"telephone_receiver\": \"ğŸ“\",\n    \"telescope\": \"ğŸ”­\",\n    \"television\": \"ğŸ“º\",\n    \"ten-thirty\": \"ğŸ•¥\",\n    \"ten_oâ€™clock\": \"ğŸ•™\",\n    \"tennis\": \"ğŸ¾\",\n    \"tent\": \"â›º\",\n    \"test_tube\": \"ğŸ§ª\",\n    \"thermometer\": \"ğŸŒ¡\",\n    \"thinking_face\": \"ğŸ¤”\",\n    \"thought_balloon\": \"ğŸ’­\",\n    \"thread\": \"ğŸ§µ\",\n    \"three-thirty\": \"ğŸ•\",\n    \"three_oâ€™clock\": \"ğŸ•’\",\n    \"thumbs_down\": \"ğŸ‘\",\n    \"thumbs_down_dark_skin_tone\": \"ğŸ‘ğŸ¿\",\n    \"thumbs_down_light_skin_tone\": \"ğŸ‘ğŸ»\",\n    \"thumbs_down_medium-dark_skin_tone\": \"ğŸ‘ğŸ¾\",\n    \"thumbs_down_medium-light_skin_tone\": \"ğŸ‘ğŸ¼\",\n    \"thumbs_down_medium_skin_tone\": \"ğŸ‘ğŸ½\",\n    \"thumbs_up\": \"ğŸ‘\",\n    \"thumbs_up_dark_skin_tone\": \"ğŸ‘ğŸ¿\",\n    \"thumbs_up_light_skin_tone\": \"ğŸ‘ğŸ»\",\n    \"thumbs_up_medium-dark_skin_tone\": \"ğŸ‘ğŸ¾\",\n    \"thumbs_up_medium-light_skin_tone\": \"ğŸ‘ğŸ¼\",\n    \"thumbs_up_medium_skin_tone\": \"ğŸ‘ğŸ½\",\n    \"ticket\": \"ğŸ«\",\n    \"tiger\": \"ğŸ¯\",\n    \"tiger_face\": \"ğŸ¯\",\n    \"timer_clock\": \"â²\",\n    \"tired_face\": \"ğŸ˜«\",\n    \"toolbox\": \"ğŸ§°\",\n    \"toilet\": \"ğŸš½\",\n    \"tomato\": \"ğŸ…\",\n    \"tongue\": \"ğŸ‘…\",\n    \"tooth\": \"ğŸ¦·\",\n    \"top_hat\": \"ğŸ©\",\n    \"tornado\": \"ğŸŒª\",\n    \"trackball\": \"ğŸ–²\",\n    \"tractor\": \"ğŸšœ\",\n    \"trade_mark\": \"â„¢\",\n    \"train\": \"ğŸš‹\",\n    \"tram\": \"ğŸšŠ\",\n    \"tram_car\": \"ğŸš‹\",\n    \"triangular_flag\": \"ğŸš©\",\n    \"triangular_ruler\": \"ğŸ“\",\n    \"trident_emblem\": \"ğŸ”±\",\n    \"trolleybus\": \"ğŸš\",\n    \"trophy\": \"ğŸ†\",\n    \"tropical_drink\": \"ğŸ¹\",\n    \"tropical_fish\": \"ğŸ \",\n    \"trumpet\": \"ğŸº\",\n    \"tulip\": \"ğŸŒ·\",\n    \"tumbler_glass\": \"ğŸ¥ƒ\",\n    \"turtle\": \"ğŸ¢\",\n    \"twelve-thirty\": \"ğŸ•§\",\n    \"twelve_oâ€™clock\": \"ğŸ•›\",\n    \"two-hump_camel\": \"ğŸ«\",\n    \"two-thirty\": \"ğŸ•\",\n    \"two_hearts\": \"ğŸ’•\",\n    \"two_men_holding_hands\": \"ğŸ‘¬\",\n    \"two_oâ€™clock\": \"ğŸ•‘\",\n    \"two_women_holding_hands\": \"ğŸ‘­\",\n    \"umbrella\": \"â˜‚\",\n    \"umbrella_on_ground\": \"â›±\",\n    \"umbrella_with_rain_drops\": \"â˜”\",\n    \"unamused_face\": \"ğŸ˜’\",\n    \"unicorn_face\": \"ğŸ¦„\",\n    \"unlocked\": \"ğŸ”“\",\n    \"up-down_arrow\": \"â†•\",\n    \"up-left_arrow\": \"â†–\",\n    \"up-right_arrow\": \"â†—\",\n    \"up_arrow\": \"â¬†\",\n    \"upside-down_face\": \"ğŸ™ƒ\",\n    \"upwards_button\": \"ğŸ”¼\",\n    \"vampire\": \"ğŸ§›\",\n    \"vampire_dark_skin_tone\": \"ğŸ§›ğŸ¿\",\n    \"vampire_light_skin_tone\": \"ğŸ§›ğŸ»\",\n    \"vampire_medium-dark_skin_tone\": \"ğŸ§›ğŸ¾\",\n    \"vampire_medium-light_skin_tone\": \"ğŸ§›ğŸ¼\",\n    \"vampire_medium_skin_tone\": \"ğŸ§›ğŸ½\",\n    \"vertical_traffic_light\": \"ğŸš¦\",\n    \"vibration_mode\": \"ğŸ“³\",\n    \"victory_hand\": \"âœŒ\",\n    \"victory_hand_dark_skin_tone\": \"âœŒğŸ¿\",\n    \"victory_hand_light_skin_tone\": \"âœŒğŸ»\",\n    \"victory_hand_medium-dark_skin_tone\": \"âœŒğŸ¾\",\n    \"victory_hand_medium-light_skin_tone\": \"âœŒğŸ¼\",\n    \"victory_hand_medium_skin_tone\": \"âœŒğŸ½\",\n    \"video_camera\": \"ğŸ“¹\",\n    \"video_game\": \"ğŸ®\",\n    \"videocassette\": \"ğŸ“¼\",\n    \"violin\": \"ğŸ»\",\n    \"volcano\": \"ğŸŒ‹\",\n    \"volleyball\": \"ğŸ\",\n    \"vulcan_salute\": \"ğŸ––\",\n    \"vulcan_salute_dark_skin_tone\": \"ğŸ––ğŸ¿\",\n    \"vulcan_salute_light_skin_tone\": \"ğŸ––ğŸ»\",\n    \"vulcan_salute_medium-dark_skin_tone\": \"ğŸ––ğŸ¾\",\n    \"vulcan_salute_medium-light_skin_tone\": \"ğŸ––ğŸ¼\",\n    \"vulcan_salute_medium_skin_tone\": \"ğŸ––ğŸ½\",\n    \"waffle\": \"ğŸ§‡\",\n    \"waning_crescent_moon\": \"ğŸŒ˜\",\n    \"waning_gibbous_moon\": \"ğŸŒ–\",\n    \"warning\": \"âš \",\n    \"wastebasket\": \"ğŸ—‘\",\n    \"watch\": \"âŒš\",\n    \"water_buffalo\": \"ğŸƒ\",\n    \"water_closet\": \"ğŸš¾\",\n    \"water_wave\": \"ğŸŒŠ\",\n    \"watermelon\": \"ğŸ‰\",\n    \"waving_hand\": \"ğŸ‘‹\",\n    \"waving_hand_dark_skin_tone\": \"ğŸ‘‹ğŸ¿\",\n    \"waving_hand_light_skin_tone\": \"ğŸ‘‹ğŸ»\",\n    \"waving_hand_medium-dark_skin_tone\": \"ğŸ‘‹ğŸ¾\",\n    \"waving_hand_medium-light_skin_tone\": \"ğŸ‘‹ğŸ¼\",\n    \"waving_hand_medium_skin_tone\": \"ğŸ‘‹ğŸ½\",\n    \"wavy_dash\": \"ã€°\",\n    \"waxing_crescent_moon\": \"ğŸŒ’\",\n    \"waxing_gibbous_moon\": \"ğŸŒ”\",\n    \"weary_cat_face\": \"ğŸ™€\",\n    \"weary_face\": \"ğŸ˜©\",\n    \"wedding\": \"ğŸ’’\",\n    \"whale\": \"ğŸ³\",\n    \"wheel_of_dharma\": \"â˜¸\",\n    \"wheelchair_symbol\": \"â™¿\",\n    \"white_circle\": \"âšª\",\n    \"white_exclamation_mark\": \"â•\",\n    \"white_flag\": \"ğŸ³\",\n    \"white_flower\": \"ğŸ’®\",\n    \"white_hair\": \"ğŸ¦³\",\n    \"white-haired_man\": \"ğŸ‘¨\\u200dğŸ¦³\",\n    \"white-haired_woman\": \"ğŸ‘©\\u200dğŸ¦³\",\n    \"white_heart\": \"ğŸ¤\",\n    \"white_heavy_check_mark\": \"âœ…\",\n    \"white_large_square\": \"â¬œ\",\n    \"white_medium-small_square\": \"â—½\",\n    \"white_medium_square\": \"â—»\",\n    \"white_medium_star\": \"â­\",\n    \"white_question_mark\": \"â”\",\n    \"white_small_square\": \"â–«\",\n    \"white_square_button\": \"ğŸ”³\",\n    \"wilted_flower\": \"ğŸ¥€\",\n    \"wind_chime\": \"ğŸ\",\n    \"wind_face\": \"ğŸŒ¬\",\n    \"wine_glass\": \"ğŸ·\",\n    \"winking_face\": \"ğŸ˜‰\",\n    \"winking_face_with_tongue\": \"ğŸ˜œ\",\n    \"wolf_face\": \"ğŸº\",\n    \"woman\": \"ğŸ‘©\",\n    \"woman_artist\": \"ğŸ‘©\\u200dğŸ¨\",\n    \"woman_artist_dark_skin_tone\": \"ğŸ‘©ğŸ¿\\u200dğŸ¨\",\n    \"woman_artist_light_skin_tone\": \"ğŸ‘©ğŸ»\\u200dğŸ¨\",\n    \"woman_artist_medium-dark_skin_tone\": \"ğŸ‘©ğŸ¾\\u200dğŸ¨\",\n    \"woman_artist_medium-light_skin_tone\": \"ğŸ‘©ğŸ¼\\u200dğŸ¨\",\n    \"woman_artist_medium_skin_tone\": \"ğŸ‘©ğŸ½\\u200dğŸ¨\",\n    \"woman_astronaut\": \"ğŸ‘©\\u200dğŸš€\",\n    \"woman_astronaut_dark_skin_tone\": \"ğŸ‘©ğŸ¿\\u200dğŸš€\",\n    \"woman_astronaut_light_skin_tone\": \"ğŸ‘©ğŸ»\\u200dğŸš€\",\n    \"woman_astronaut_medium-dark_skin_tone\": \"ğŸ‘©ğŸ¾\\u200dğŸš€\",\n    \"woman_astronaut_medium-light_skin_tone\": \"ğŸ‘©ğŸ¼\\u200dğŸš€\",\n    \"woman_astronaut_medium_skin_tone\": \"ğŸ‘©ğŸ½\\u200dğŸš€\",\n    \"woman_biking\": \"ğŸš´\\u200dâ™€ï¸\",\n    \"woman_biking_dark_skin_tone\": \"ğŸš´ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_biking_light_skin_tone\": \"ğŸš´ğŸ»\\u200dâ™€ï¸\",\n    \"woman_biking_medium-dark_skin_tone\": \"ğŸš´ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_biking_medium-light_skin_tone\": \"ğŸš´ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_biking_medium_skin_tone\": \"ğŸš´ğŸ½\\u200dâ™€ï¸\",\n    \"woman_bouncing_ball\": \"â›¹ï¸\\u200dâ™€ï¸\",\n    \"woman_bouncing_ball_dark_skin_tone\": \"â›¹ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_bouncing_ball_light_skin_tone\": \"â›¹ğŸ»\\u200dâ™€ï¸\",\n    \"woman_bouncing_ball_medium-dark_skin_tone\": \"â›¹ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_bouncing_ball_medium-light_skin_tone\": \"â›¹ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_bouncing_ball_medium_skin_tone\": \"â›¹ğŸ½\\u200dâ™€ï¸\",\n    \"woman_bowing\": \"ğŸ™‡\\u200dâ™€ï¸\",\n    \"woman_bowing_dark_skin_tone\": \"ğŸ™‡ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_bowing_light_skin_tone\": \"ğŸ™‡ğŸ»\\u200dâ™€ï¸\",\n    \"woman_bowing_medium-dark_skin_tone\": \"ğŸ™‡ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_bowing_medium-light_skin_tone\": \"ğŸ™‡ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_bowing_medium_skin_tone\": \"ğŸ™‡ğŸ½\\u200dâ™€ï¸\",\n    \"woman_cartwheeling\": \"ğŸ¤¸\\u200dâ™€ï¸\",\n    \"woman_cartwheeling_dark_skin_tone\": \"ğŸ¤¸ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_cartwheeling_light_skin_tone\": \"ğŸ¤¸ğŸ»\\u200dâ™€ï¸\",\n    \"woman_cartwheeling_medium-dark_skin_tone\": \"ğŸ¤¸ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_cartwheeling_medium-light_skin_tone\": \"ğŸ¤¸ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_cartwheeling_medium_skin_tone\": \"ğŸ¤¸ğŸ½\\u200dâ™€ï¸\",\n    \"woman_climbing\": \"ğŸ§—\\u200dâ™€ï¸\",\n    \"woman_climbing_dark_skin_tone\": \"ğŸ§—ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_climbing_light_skin_tone\": \"ğŸ§—ğŸ»\\u200dâ™€ï¸\",\n    \"woman_climbing_medium-dark_skin_tone\": \"ğŸ§—ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_climbing_medium-light_skin_tone\": \"ğŸ§—ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_climbing_medium_skin_tone\": \"ğŸ§—ğŸ½\\u200dâ™€ï¸\",\n    \"woman_construction_worker\": \"ğŸ‘·\\u200dâ™€ï¸\",\n    \"woman_construction_worker_dark_skin_tone\": \"ğŸ‘·ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_construction_worker_light_skin_tone\": \"ğŸ‘·ğŸ»\\u200dâ™€ï¸\",\n    \"woman_construction_worker_medium-dark_skin_tone\": \"ğŸ‘·ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_construction_worker_medium-light_skin_tone\": \"ğŸ‘·ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_construction_worker_medium_skin_tone\": \"ğŸ‘·ğŸ½\\u200dâ™€ï¸\",\n    \"woman_cook\": \"ğŸ‘©\\u200dğŸ³\",\n    \"woman_cook_dark_skin_tone\": \"ğŸ‘©ğŸ¿\\u200dğŸ³\",\n    \"woman_cook_light_skin_tone\": \"ğŸ‘©ğŸ»\\u200dğŸ³\",\n    \"woman_cook_medium-dark_skin_tone\": \"ğŸ‘©ğŸ¾\\u200dğŸ³\",\n    \"woman_cook_medium-light_skin_tone\": \"ğŸ‘©ğŸ¼\\u200dğŸ³\",\n    \"woman_cook_medium_skin_tone\": \"ğŸ‘©ğŸ½\\u200dğŸ³\",\n    \"woman_dancing\": \"ğŸ’ƒ\",\n    \"woman_dancing_dark_skin_tone\": \"ğŸ’ƒğŸ¿\",\n    \"woman_dancing_light_skin_tone\": \"ğŸ’ƒğŸ»\",\n    \"woman_dancing_medium-dark_skin_tone\": \"ğŸ’ƒğŸ¾\",\n    \"woman_dancing_medium-light_skin_tone\": \"ğŸ’ƒğŸ¼\",\n    \"woman_dancing_medium_skin_tone\": \"ğŸ’ƒğŸ½\",\n    \"woman_dark_skin_tone\": \"ğŸ‘©ğŸ¿\",\n    \"woman_detective\": \"ğŸ•µï¸\\u200dâ™€ï¸\",\n    \"woman_detective_dark_skin_tone\": \"ğŸ•µğŸ¿\\u200dâ™€ï¸\",\n    \"woman_detective_light_skin_tone\": \"ğŸ•µğŸ»\\u200dâ™€ï¸\",\n    \"woman_detective_medium-dark_skin_tone\": \"ğŸ•µğŸ¾\\u200dâ™€ï¸\",\n    \"woman_detective_medium-light_skin_tone\": \"ğŸ•µğŸ¼\\u200dâ™€ï¸\",\n    \"woman_detective_medium_skin_tone\": \"ğŸ•µğŸ½\\u200dâ™€ï¸\",\n    \"woman_elf\": \"ğŸ§\\u200dâ™€ï¸\",\n    \"woman_elf_dark_skin_tone\": \"ğŸ§ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_elf_light_skin_tone\": \"ğŸ§ğŸ»\\u200dâ™€ï¸\",\n    \"woman_elf_medium-dark_skin_tone\": \"ğŸ§ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_elf_medium-light_skin_tone\": \"ğŸ§ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_elf_medium_skin_tone\": \"ğŸ§ğŸ½\\u200dâ™€ï¸\",\n    \"woman_facepalming\": \"ğŸ¤¦\\u200dâ™€ï¸\",\n    \"woman_facepalming_dark_skin_tone\": \"ğŸ¤¦ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_facepalming_light_skin_tone\": \"ğŸ¤¦ğŸ»\\u200dâ™€ï¸\",\n    \"woman_facepalming_medium-dark_skin_tone\": \"ğŸ¤¦ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_facepalming_medium-light_skin_tone\": \"ğŸ¤¦ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_facepalming_medium_skin_tone\": \"ğŸ¤¦ğŸ½\\u200dâ™€ï¸\",\n    \"woman_factory_worker\": \"ğŸ‘©\\u200dğŸ­\",\n    \"woman_factory_worker_dark_skin_tone\": \"ğŸ‘©ğŸ¿\\u200dğŸ­\",\n    \"woman_factory_worker_light_skin_tone\": \"ğŸ‘©ğŸ»\\u200dğŸ­\",\n    \"woman_factory_worker_medium-dark_skin_tone\": \"ğŸ‘©ğŸ¾\\u200dğŸ­\",\n    \"woman_factory_worker_medium-light_skin_tone\": \"ğŸ‘©ğŸ¼\\u200dğŸ­\",\n    \"woman_factory_worker_medium_skin_tone\": \"ğŸ‘©ğŸ½\\u200dğŸ­\",\n    \"woman_fairy\": \"ğŸ§š\\u200dâ™€ï¸\",\n    \"woman_fairy_dark_skin_tone\": \"ğŸ§šğŸ¿\\u200dâ™€ï¸\",\n    \"woman_fairy_light_skin_tone\": \"ğŸ§šğŸ»\\u200dâ™€ï¸\",\n    \"woman_fairy_medium-dark_skin_tone\": \"ğŸ§šğŸ¾\\u200dâ™€ï¸\",\n    \"woman_fairy_medium-light_skin_tone\": \"ğŸ§šğŸ¼\\u200dâ™€ï¸\",\n    \"woman_fairy_medium_skin_tone\": \"ğŸ§šğŸ½\\u200dâ™€ï¸\",\n    \"woman_farmer\": \"ğŸ‘©\\u200dğŸŒ¾\",\n    \"woman_farmer_dark_skin_tone\": \"ğŸ‘©ğŸ¿\\u200dğŸŒ¾\",\n    \"woman_farmer_light_skin_tone\": \"ğŸ‘©ğŸ»\\u200dğŸŒ¾\",\n    \"woman_farmer_medium-dark_skin_tone\": \"ğŸ‘©ğŸ¾\\u200dğŸŒ¾\",\n    \"woman_farmer_medium-light_skin_tone\": \"ğŸ‘©ğŸ¼\\u200dğŸŒ¾\",\n    \"woman_farmer_medium_skin_tone\": \"ğŸ‘©ğŸ½\\u200dğŸŒ¾\",\n    \"woman_firefighter\": \"ğŸ‘©\\u200dğŸš’\",\n    \"woman_firefighter_dark_skin_tone\": \"ğŸ‘©ğŸ¿\\u200dğŸš’\",\n    \"woman_firefighter_light_skin_tone\": \"ğŸ‘©ğŸ»\\u200dğŸš’\",\n    \"woman_firefighter_medium-dark_skin_tone\": \"ğŸ‘©ğŸ¾\\u200dğŸš’\",\n    \"woman_firefighter_medium-light_skin_tone\": \"ğŸ‘©ğŸ¼\\u200dğŸš’\",\n    \"woman_firefighter_medium_skin_tone\": \"ğŸ‘©ğŸ½\\u200dğŸš’\",\n    \"woman_frowning\": \"ğŸ™\\u200dâ™€ï¸\",\n    \"woman_frowning_dark_skin_tone\": \"ğŸ™ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_frowning_light_skin_tone\": \"ğŸ™ğŸ»\\u200dâ™€ï¸\",\n    \"woman_frowning_medium-dark_skin_tone\": \"ğŸ™ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_frowning_medium-light_skin_tone\": \"ğŸ™ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_frowning_medium_skin_tone\": \"ğŸ™ğŸ½\\u200dâ™€ï¸\",\n    \"woman_genie\": \"ğŸ§\\u200dâ™€ï¸\",\n    \"woman_gesturing_no\": \"ğŸ™…\\u200dâ™€ï¸\",\n    \"woman_gesturing_no_dark_skin_tone\": \"ğŸ™…ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_gesturing_no_light_skin_tone\": \"ğŸ™…ğŸ»\\u200dâ™€ï¸\",\n    \"woman_gesturing_no_medium-dark_skin_tone\": \"ğŸ™…ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_gesturing_no_medium-light_skin_tone\": \"ğŸ™…ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_gesturing_no_medium_skin_tone\": \"ğŸ™…ğŸ½\\u200dâ™€ï¸\",\n    \"woman_gesturing_ok\": \"ğŸ™†\\u200dâ™€ï¸\",\n    \"woman_gesturing_ok_dark_skin_tone\": \"ğŸ™†ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_gesturing_ok_light_skin_tone\": \"ğŸ™†ğŸ»\\u200dâ™€ï¸\",\n    \"woman_gesturing_ok_medium-dark_skin_tone\": \"ğŸ™†ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_gesturing_ok_medium-light_skin_tone\": \"ğŸ™†ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_gesturing_ok_medium_skin_tone\": \"ğŸ™†ğŸ½\\u200dâ™€ï¸\",\n    \"woman_getting_haircut\": \"ğŸ’‡\\u200dâ™€ï¸\",\n    \"woman_getting_haircut_dark_skin_tone\": \"ğŸ’‡ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_getting_haircut_light_skin_tone\": \"ğŸ’‡ğŸ»\\u200dâ™€ï¸\",\n    \"woman_getting_haircut_medium-dark_skin_tone\": \"ğŸ’‡ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_getting_haircut_medium-light_skin_tone\": \"ğŸ’‡ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_getting_haircut_medium_skin_tone\": \"ğŸ’‡ğŸ½\\u200dâ™€ï¸\",\n    \"woman_getting_massage\": \"ğŸ’†\\u200dâ™€ï¸\",\n    \"woman_getting_massage_dark_skin_tone\": \"ğŸ’†ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_getting_massage_light_skin_tone\": \"ğŸ’†ğŸ»\\u200dâ™€ï¸\",\n    \"woman_getting_massage_medium-dark_skin_tone\": \"ğŸ’†ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_getting_massage_medium-light_skin_tone\": \"ğŸ’†ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_getting_massage_medium_skin_tone\": \"ğŸ’†ğŸ½\\u200dâ™€ï¸\",\n    \"woman_golfing\": \"ğŸŒï¸\\u200dâ™€ï¸\",\n    \"woman_golfing_dark_skin_tone\": \"ğŸŒğŸ¿\\u200dâ™€ï¸\",\n    \"woman_golfing_light_skin_tone\": \"ğŸŒğŸ»\\u200dâ™€ï¸\",\n    \"woman_golfing_medium-dark_skin_tone\": \"ğŸŒğŸ¾\\u200dâ™€ï¸\",\n    \"woman_golfing_medium-light_skin_tone\": \"ğŸŒğŸ¼\\u200dâ™€ï¸\",\n    \"woman_golfing_medium_skin_tone\": \"ğŸŒğŸ½\\u200dâ™€ï¸\",\n    \"woman_guard\": \"ğŸ’‚\\u200dâ™€ï¸\",\n    \"woman_guard_dark_skin_tone\": \"ğŸ’‚ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_guard_light_skin_tone\": \"ğŸ’‚ğŸ»\\u200dâ™€ï¸\",\n    \"woman_guard_medium-dark_skin_tone\": \"ğŸ’‚ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_guard_medium-light_skin_tone\": \"ğŸ’‚ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_guard_medium_skin_tone\": \"ğŸ’‚ğŸ½\\u200dâ™€ï¸\",\n    \"woman_health_worker\": \"ğŸ‘©\\u200dâš•ï¸\",\n    \"woman_health_worker_dark_skin_tone\": \"ğŸ‘©ğŸ¿\\u200dâš•ï¸\",\n    \"woman_health_worker_light_skin_tone\": \"ğŸ‘©ğŸ»\\u200dâš•ï¸\",\n    \"woman_health_worker_medium-dark_skin_tone\": \"ğŸ‘©ğŸ¾\\u200dâš•ï¸\",\n    \"woman_health_worker_medium-light_skin_tone\": \"ğŸ‘©ğŸ¼\\u200dâš•ï¸\",\n    \"woman_health_worker_medium_skin_tone\": \"ğŸ‘©ğŸ½\\u200dâš•ï¸\",\n    \"woman_in_lotus_position\": \"ğŸ§˜\\u200dâ™€ï¸\",\n    \"woman_in_lotus_position_dark_skin_tone\": \"ğŸ§˜ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_in_lotus_position_light_skin_tone\": \"ğŸ§˜ğŸ»\\u200dâ™€ï¸\",\n    \"woman_in_lotus_position_medium-dark_skin_tone\": \"ğŸ§˜ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_in_lotus_position_medium-light_skin_tone\": \"ğŸ§˜ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_in_lotus_position_medium_skin_tone\": \"ğŸ§˜ğŸ½\\u200dâ™€ï¸\",\n    \"woman_in_manual_wheelchair\": \"ğŸ‘©\\u200dğŸ¦½\",\n    \"woman_in_motorized_wheelchair\": \"ğŸ‘©\\u200dğŸ¦¼\",\n    \"woman_in_steamy_room\": \"ğŸ§–\\u200dâ™€ï¸\",\n    \"woman_in_steamy_room_dark_skin_tone\": \"ğŸ§–ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_in_steamy_room_light_skin_tone\": \"ğŸ§–ğŸ»\\u200dâ™€ï¸\",\n    \"woman_in_steamy_room_medium-dark_skin_tone\": \"ğŸ§–ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_in_steamy_room_medium-light_skin_tone\": \"ğŸ§–ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_in_steamy_room_medium_skin_tone\": \"ğŸ§–ğŸ½\\u200dâ™€ï¸\",\n    \"woman_judge\": \"ğŸ‘©\\u200dâš–ï¸\",\n    \"woman_judge_dark_skin_tone\": \"ğŸ‘©ğŸ¿\\u200dâš–ï¸\",\n    \"woman_judge_light_skin_tone\": \"ğŸ‘©ğŸ»\\u200dâš–ï¸\",\n    \"woman_judge_medium-dark_skin_tone\": \"ğŸ‘©ğŸ¾\\u200dâš–ï¸\",\n    \"woman_judge_medium-light_skin_tone\": \"ğŸ‘©ğŸ¼\\u200dâš–ï¸\",\n    \"woman_judge_medium_skin_tone\": \"ğŸ‘©ğŸ½\\u200dâš–ï¸\",\n    \"woman_juggling\": \"ğŸ¤¹\\u200dâ™€ï¸\",\n    \"woman_juggling_dark_skin_tone\": \"ğŸ¤¹ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_juggling_light_skin_tone\": \"ğŸ¤¹ğŸ»\\u200dâ™€ï¸\",\n    \"woman_juggling_medium-dark_skin_tone\": \"ğŸ¤¹ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_juggling_medium-light_skin_tone\": \"ğŸ¤¹ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_juggling_medium_skin_tone\": \"ğŸ¤¹ğŸ½\\u200dâ™€ï¸\",\n    \"woman_lifting_weights\": \"ğŸ‹ï¸\\u200dâ™€ï¸\",\n    \"woman_lifting_weights_dark_skin_tone\": \"ğŸ‹ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_lifting_weights_light_skin_tone\": \"ğŸ‹ğŸ»\\u200dâ™€ï¸\",\n    \"woman_lifting_weights_medium-dark_skin_tone\": \"ğŸ‹ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_lifting_weights_medium-light_skin_tone\": \"ğŸ‹ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_lifting_weights_medium_skin_tone\": \"ğŸ‹ğŸ½\\u200dâ™€ï¸\",\n    \"woman_light_skin_tone\": \"ğŸ‘©ğŸ»\",\n    \"woman_mage\": \"ğŸ§™\\u200dâ™€ï¸\",\n    \"woman_mage_dark_skin_tone\": \"ğŸ§™ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_mage_light_skin_tone\": \"ğŸ§™ğŸ»\\u200dâ™€ï¸\",\n    \"woman_mage_medium-dark_skin_tone\": \"ğŸ§™ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_mage_medium-light_skin_tone\": \"ğŸ§™ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_mage_medium_skin_tone\": \"ğŸ§™ğŸ½\\u200dâ™€ï¸\",\n    \"woman_mechanic\": \"ğŸ‘©\\u200dğŸ”§\",\n    \"woman_mechanic_dark_skin_tone\": \"ğŸ‘©ğŸ¿\\u200dğŸ”§\",\n    \"woman_mechanic_light_skin_tone\": \"ğŸ‘©ğŸ»\\u200dğŸ”§\",\n    \"woman_mechanic_medium-dark_skin_tone\": \"ğŸ‘©ğŸ¾\\u200dğŸ”§\",\n    \"woman_mechanic_medium-light_skin_tone\": \"ğŸ‘©ğŸ¼\\u200dğŸ”§\",\n    \"woman_mechanic_medium_skin_tone\": \"ğŸ‘©ğŸ½\\u200dğŸ”§\",\n    \"woman_medium-dark_skin_tone\": \"ğŸ‘©ğŸ¾\",\n    \"woman_medium-light_skin_tone\": \"ğŸ‘©ğŸ¼\",\n    \"woman_medium_skin_tone\": \"ğŸ‘©ğŸ½\",\n    \"woman_mountain_biking\": \"ğŸšµ\\u200dâ™€ï¸\",\n    \"woman_mountain_biking_dark_skin_tone\": \"ğŸšµğŸ¿\\u200dâ™€ï¸\",\n    \"woman_mountain_biking_light_skin_tone\": \"ğŸšµğŸ»\\u200dâ™€ï¸\",\n    \"woman_mountain_biking_medium-dark_skin_tone\": \"ğŸšµğŸ¾\\u200dâ™€ï¸\",\n    \"woman_mountain_biking_medium-light_skin_tone\": \"ğŸšµğŸ¼\\u200dâ™€ï¸\",\n    \"woman_mountain_biking_medium_skin_tone\": \"ğŸšµğŸ½\\u200dâ™€ï¸\",\n    \"woman_office_worker\": \"ğŸ‘©\\u200dğŸ’¼\",\n    \"woman_office_worker_dark_skin_tone\": \"ğŸ‘©ğŸ¿\\u200dğŸ’¼\",\n    \"woman_office_worker_light_skin_tone\": \"ğŸ‘©ğŸ»\\u200dğŸ’¼\",\n    \"woman_office_worker_medium-dark_skin_tone\": \"ğŸ‘©ğŸ¾\\u200dğŸ’¼\",\n    \"woman_office_worker_medium-light_skin_tone\": \"ğŸ‘©ğŸ¼\\u200dğŸ’¼\",\n    \"woman_office_worker_medium_skin_tone\": \"ğŸ‘©ğŸ½\\u200dğŸ’¼\",\n    \"woman_pilot\": \"ğŸ‘©\\u200dâœˆï¸\",\n    \"woman_pilot_dark_skin_tone\": \"ğŸ‘©ğŸ¿\\u200dâœˆï¸\",\n    \"woman_pilot_light_skin_tone\": \"ğŸ‘©ğŸ»\\u200dâœˆï¸\",\n    \"woman_pilot_medium-dark_skin_tone\": \"ğŸ‘©ğŸ¾\\u200dâœˆï¸\",\n    \"woman_pilot_medium-light_skin_tone\": \"ğŸ‘©ğŸ¼\\u200dâœˆï¸\",\n    \"woman_pilot_medium_skin_tone\": \"ğŸ‘©ğŸ½\\u200dâœˆï¸\",\n    \"woman_playing_handball\": \"ğŸ¤¾\\u200dâ™€ï¸\",\n    \"woman_playing_handball_dark_skin_tone\": \"ğŸ¤¾ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_playing_handball_light_skin_tone\": \"ğŸ¤¾ğŸ»\\u200dâ™€ï¸\",\n    \"woman_playing_handball_medium-dark_skin_tone\": \"ğŸ¤¾ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_playing_handball_medium-light_skin_tone\": \"ğŸ¤¾ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_playing_handball_medium_skin_tone\": \"ğŸ¤¾ğŸ½\\u200dâ™€ï¸\",\n    \"woman_playing_water_polo\": \"ğŸ¤½\\u200dâ™€ï¸\",\n    \"woman_playing_water_polo_dark_skin_tone\": \"ğŸ¤½ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_playing_water_polo_light_skin_tone\": \"ğŸ¤½ğŸ»\\u200dâ™€ï¸\",\n    \"woman_playing_water_polo_medium-dark_skin_tone\": \"ğŸ¤½ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_playing_water_polo_medium-light_skin_tone\": \"ğŸ¤½ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_playing_water_polo_medium_skin_tone\": \"ğŸ¤½ğŸ½\\u200dâ™€ï¸\",\n    \"woman_police_officer\": \"ğŸ‘®\\u200dâ™€ï¸\",\n    \"woman_police_officer_dark_skin_tone\": \"ğŸ‘®ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_police_officer_light_skin_tone\": \"ğŸ‘®ğŸ»\\u200dâ™€ï¸\",\n    \"woman_police_officer_medium-dark_skin_tone\": \"ğŸ‘®ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_police_officer_medium-light_skin_tone\": \"ğŸ‘®ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_police_officer_medium_skin_tone\": \"ğŸ‘®ğŸ½\\u200dâ™€ï¸\",\n    \"woman_pouting\": \"ğŸ™\\u200dâ™€ï¸\",\n    \"woman_pouting_dark_skin_tone\": \"ğŸ™ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_pouting_light_skin_tone\": \"ğŸ™ğŸ»\\u200dâ™€ï¸\",\n    \"woman_pouting_medium-dark_skin_tone\": \"ğŸ™ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_pouting_medium-light_skin_tone\": \"ğŸ™ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_pouting_medium_skin_tone\": \"ğŸ™ğŸ½\\u200dâ™€ï¸\",\n    \"woman_raising_hand\": \"ğŸ™‹\\u200dâ™€ï¸\",\n    \"woman_raising_hand_dark_skin_tone\": \"ğŸ™‹ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_raising_hand_light_skin_tone\": \"ğŸ™‹ğŸ»\\u200dâ™€ï¸\",\n    \"woman_raising_hand_medium-dark_skin_tone\": \"ğŸ™‹ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_raising_hand_medium-light_skin_tone\": \"ğŸ™‹ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_raising_hand_medium_skin_tone\": \"ğŸ™‹ğŸ½\\u200dâ™€ï¸\",\n    \"woman_rowing_boat\": \"ğŸš£\\u200dâ™€ï¸\",\n    \"woman_rowing_boat_dark_skin_tone\": \"ğŸš£ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_rowing_boat_light_skin_tone\": \"ğŸš£ğŸ»\\u200dâ™€ï¸\",\n    \"woman_rowing_boat_medium-dark_skin_tone\": \"ğŸš£ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_rowing_boat_medium-light_skin_tone\": \"ğŸš£ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_rowing_boat_medium_skin_tone\": \"ğŸš£ğŸ½\\u200dâ™€ï¸\",\n    \"woman_running\": \"ğŸƒ\\u200dâ™€ï¸\",\n    \"woman_running_dark_skin_tone\": \"ğŸƒğŸ¿\\u200dâ™€ï¸\",\n    \"woman_running_light_skin_tone\": \"ğŸƒğŸ»\\u200dâ™€ï¸\",\n    \"woman_running_medium-dark_skin_tone\": \"ğŸƒğŸ¾\\u200dâ™€ï¸\",\n    \"woman_running_medium-light_skin_tone\": \"ğŸƒğŸ¼\\u200dâ™€ï¸\",\n    \"woman_running_medium_skin_tone\": \"ğŸƒğŸ½\\u200dâ™€ï¸\",\n    \"woman_scientist\": \"ğŸ‘©\\u200dğŸ”¬\",\n    \"woman_scientist_dark_skin_tone\": \"ğŸ‘©ğŸ¿\\u200dğŸ”¬\",\n    \"woman_scientist_light_skin_tone\": \"ğŸ‘©ğŸ»\\u200dğŸ”¬\",\n    \"woman_scientist_medium-dark_skin_tone\": \"ğŸ‘©ğŸ¾\\u200dğŸ”¬\",\n    \"woman_scientist_medium-light_skin_tone\": \"ğŸ‘©ğŸ¼\\u200dğŸ”¬\",\n    \"woman_scientist_medium_skin_tone\": \"ğŸ‘©ğŸ½\\u200dğŸ”¬\",\n    \"woman_shrugging\": \"ğŸ¤·\\u200dâ™€ï¸\",\n    \"woman_shrugging_dark_skin_tone\": \"ğŸ¤·ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_shrugging_light_skin_tone\": \"ğŸ¤·ğŸ»\\u200dâ™€ï¸\",\n    \"woman_shrugging_medium-dark_skin_tone\": \"ğŸ¤·ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_shrugging_medium-light_skin_tone\": \"ğŸ¤·ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_shrugging_medium_skin_tone\": \"ğŸ¤·ğŸ½\\u200dâ™€ï¸\",\n    \"woman_singer\": \"ğŸ‘©\\u200dğŸ¤\",\n    \"woman_singer_dark_skin_tone\": \"ğŸ‘©ğŸ¿\\u200dğŸ¤\",\n    \"woman_singer_light_skin_tone\": \"ğŸ‘©ğŸ»\\u200dğŸ¤\",\n    \"woman_singer_medium-dark_skin_tone\": \"ğŸ‘©ğŸ¾\\u200dğŸ¤\",\n    \"woman_singer_medium-light_skin_tone\": \"ğŸ‘©ğŸ¼\\u200dğŸ¤\",\n    \"woman_singer_medium_skin_tone\": \"ğŸ‘©ğŸ½\\u200dğŸ¤\",\n    \"woman_student\": \"ğŸ‘©\\u200dğŸ“\",\n    \"woman_student_dark_skin_tone\": \"ğŸ‘©ğŸ¿\\u200dğŸ“\",\n    \"woman_student_light_skin_tone\": \"ğŸ‘©ğŸ»\\u200dğŸ“\",\n    \"woman_student_medium-dark_skin_tone\": \"ğŸ‘©ğŸ¾\\u200dğŸ“\",\n    \"woman_student_medium-light_skin_tone\": \"ğŸ‘©ğŸ¼\\u200dğŸ“\",\n    \"woman_student_medium_skin_tone\": \"ğŸ‘©ğŸ½\\u200dğŸ“\",\n    \"woman_surfing\": \"ğŸ„\\u200dâ™€ï¸\",\n    \"woman_surfing_dark_skin_tone\": \"ğŸ„ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_surfing_light_skin_tone\": \"ğŸ„ğŸ»\\u200dâ™€ï¸\",\n    \"woman_surfing_medium-dark_skin_tone\": \"ğŸ„ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_surfing_medium-light_skin_tone\": \"ğŸ„ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_surfing_medium_skin_tone\": \"ğŸ„ğŸ½\\u200dâ™€ï¸\",\n    \"woman_swimming\": \"ğŸŠ\\u200dâ™€ï¸\",\n    \"woman_swimming_dark_skin_tone\": \"ğŸŠğŸ¿\\u200dâ™€ï¸\",\n    \"woman_swimming_light_skin_tone\": \"ğŸŠğŸ»\\u200dâ™€ï¸\",\n    \"woman_swimming_medium-dark_skin_tone\": \"ğŸŠğŸ¾\\u200dâ™€ï¸\",\n    \"woman_swimming_medium-light_skin_tone\": \"ğŸŠğŸ¼\\u200dâ™€ï¸\",\n    \"woman_swimming_medium_skin_tone\": \"ğŸŠğŸ½\\u200dâ™€ï¸\",\n    \"woman_teacher\": \"ğŸ‘©\\u200dğŸ«\",\n    \"woman_teacher_dark_skin_tone\": \"ğŸ‘©ğŸ¿\\u200dğŸ«\",\n    \"woman_teacher_light_skin_tone\": \"ğŸ‘©ğŸ»\\u200dğŸ«\",\n    \"woman_teacher_medium-dark_skin_tone\": \"ğŸ‘©ğŸ¾\\u200dğŸ«\",\n    \"woman_teacher_medium-light_skin_tone\": \"ğŸ‘©ğŸ¼\\u200dğŸ«\",\n    \"woman_teacher_medium_skin_tone\": \"ğŸ‘©ğŸ½\\u200dğŸ«\",\n    \"woman_technologist\": \"ğŸ‘©\\u200dğŸ’»\",\n    \"woman_technologist_dark_skin_tone\": \"ğŸ‘©ğŸ¿\\u200dğŸ’»\",\n    \"woman_technologist_light_skin_tone\": \"ğŸ‘©ğŸ»\\u200dğŸ’»\",\n    \"woman_technologist_medium-dark_skin_tone\": \"ğŸ‘©ğŸ¾\\u200dğŸ’»\",\n    \"woman_technologist_medium-light_skin_tone\": \"ğŸ‘©ğŸ¼\\u200dğŸ’»\",\n    \"woman_technologist_medium_skin_tone\": \"ğŸ‘©ğŸ½\\u200dğŸ’»\",\n    \"woman_tipping_hand\": \"ğŸ’\\u200dâ™€ï¸\",\n    \"woman_tipping_hand_dark_skin_tone\": \"ğŸ’ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_tipping_hand_light_skin_tone\": \"ğŸ’ğŸ»\\u200dâ™€ï¸\",\n    \"woman_tipping_hand_medium-dark_skin_tone\": \"ğŸ’ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_tipping_hand_medium-light_skin_tone\": \"ğŸ’ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_tipping_hand_medium_skin_tone\": \"ğŸ’ğŸ½\\u200dâ™€ï¸\",\n    \"woman_vampire\": \"ğŸ§›\\u200dâ™€ï¸\",\n    \"woman_vampire_dark_skin_tone\": \"ğŸ§›ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_vampire_light_skin_tone\": \"ğŸ§›ğŸ»\\u200dâ™€ï¸\",\n    \"woman_vampire_medium-dark_skin_tone\": \"ğŸ§›ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_vampire_medium-light_skin_tone\": \"ğŸ§›ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_vampire_medium_skin_tone\": \"ğŸ§›ğŸ½\\u200dâ™€ï¸\",\n    \"woman_walking\": \"ğŸš¶\\u200dâ™€ï¸\",\n    \"woman_walking_dark_skin_tone\": \"ğŸš¶ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_walking_light_skin_tone\": \"ğŸš¶ğŸ»\\u200dâ™€ï¸\",\n    \"woman_walking_medium-dark_skin_tone\": \"ğŸš¶ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_walking_medium-light_skin_tone\": \"ğŸš¶ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_walking_medium_skin_tone\": \"ğŸš¶ğŸ½\\u200dâ™€ï¸\",\n    \"woman_wearing_turban\": \"ğŸ‘³\\u200dâ™€ï¸\",\n    \"woman_wearing_turban_dark_skin_tone\": \"ğŸ‘³ğŸ¿\\u200dâ™€ï¸\",\n    \"woman_wearing_turban_light_skin_tone\": \"ğŸ‘³ğŸ»\\u200dâ™€ï¸\",\n    \"woman_wearing_turban_medium-dark_skin_tone\": \"ğŸ‘³ğŸ¾\\u200dâ™€ï¸\",\n    \"woman_wearing_turban_medium-light_skin_tone\": \"ğŸ‘³ğŸ¼\\u200dâ™€ï¸\",\n    \"woman_wearing_turban_medium_skin_tone\": \"ğŸ‘³ğŸ½\\u200dâ™€ï¸\",\n    \"woman_with_headscarf\": \"ğŸ§•\",\n    \"woman_with_headscarf_dark_skin_tone\": \"ğŸ§•ğŸ¿\",\n    \"woman_with_headscarf_light_skin_tone\": \"ğŸ§•ğŸ»\",\n    \"woman_with_headscarf_medium-dark_skin_tone\": \"ğŸ§•ğŸ¾\",\n    \"woman_with_headscarf_medium-light_skin_tone\": \"ğŸ§•ğŸ¼\",\n    \"woman_with_headscarf_medium_skin_tone\": \"ğŸ§•ğŸ½\",\n    \"woman_with_probing_cane\": \"ğŸ‘©\\u200dğŸ¦¯\",\n    \"woman_zombie\": \"ğŸ§Ÿ\\u200dâ™€ï¸\",\n    \"womanâ€™s_boot\": \"ğŸ‘¢\",\n    \"womanâ€™s_clothes\": \"ğŸ‘š\",\n    \"womanâ€™s_hat\": \"ğŸ‘’\",\n    \"womanâ€™s_sandal\": \"ğŸ‘¡\",\n    \"women_with_bunny_ears\": \"ğŸ‘¯\\u200dâ™€ï¸\",\n    \"women_wrestling\": \"ğŸ¤¼\\u200dâ™€ï¸\",\n    \"womenâ€™s_room\": \"ğŸšº\",\n    \"woozy_face\": \"ğŸ¥´\",\n    \"world_map\": \"ğŸ—º\",\n    \"worried_face\": \"ğŸ˜Ÿ\",\n    \"wrapped_gift\": \"ğŸ\",\n    \"wrench\": \"ğŸ”§\",\n    \"writing_hand\": \"âœ\",\n    \"writing_hand_dark_skin_tone\": \"âœğŸ¿\",\n    \"writing_hand_light_skin_tone\": \"âœğŸ»\",\n    \"writing_hand_medium-dark_skin_tone\": \"âœğŸ¾\",\n    \"writing_hand_medium-light_skin_tone\": \"âœğŸ¼\",\n    \"writing_hand_medium_skin_tone\": \"âœğŸ½\",\n    \"yarn\": \"ğŸ§¶\",\n    \"yawning_face\": \"ğŸ¥±\",\n    \"yellow_circle\": \"ğŸŸ¡\",\n    \"yellow_heart\": \"ğŸ’›\",\n    \"yellow_square\": \"ğŸŸ¨\",\n    \"yen_banknote\": \"ğŸ’´\",\n    \"yo-yo\": \"ğŸª€\",\n    \"yin_yang\": \"â˜¯\",\n    \"zany_face\": \"ğŸ¤ª\",\n    \"zebra\": \"ğŸ¦“\",\n    \"zipper-mouth_face\": \"ğŸ¤\",\n    \"zombie\": \"ğŸ§Ÿ\",\n    \"zzz\": \"ğŸ’¤\",\n    \"Ã¥land_islands\": \"ğŸ‡¦ğŸ‡½\",\n    \"keycap_asterisk\": \"*âƒ£\",\n    \"keycap_digit_eight\": \"8âƒ£\",\n    \"keycap_digit_five\": \"5âƒ£\",\n    \"keycap_digit_four\": \"4âƒ£\",\n    \"keycap_digit_nine\": \"9âƒ£\",\n    \"keycap_digit_one\": \"1âƒ£\",\n    \"keycap_digit_seven\": \"7âƒ£\",\n    \"keycap_digit_six\": \"6âƒ£\",\n    \"keycap_digit_three\": \"3âƒ£\",\n    \"keycap_digit_two\": \"2âƒ£\",\n    \"keycap_digit_zero\": \"0âƒ£\",\n    \"keycap_number_sign\": \"#âƒ£\",\n    \"light_skin_tone\": \"ğŸ»\",\n    \"medium_light_skin_tone\": \"ğŸ¼\",\n    \"medium_skin_tone\": \"ğŸ½\",\n    \"medium_dark_skin_tone\": \"ğŸ¾\",\n    \"dark_skin_tone\": \"ğŸ¿\",\n    \"regional_indicator_symbol_letter_a\": \"ğŸ‡¦\",\n    \"regional_indicator_symbol_letter_b\": \"ğŸ‡§\",\n    \"regional_indicator_symbol_letter_c\": \"ğŸ‡¨\",\n    \"regional_indicator_symbol_letter_d\": \"ğŸ‡©\",\n    \"regional_indicator_symbol_letter_e\": \"ğŸ‡ª\",\n    \"regional_indicator_symbol_letter_f\": \"ğŸ‡«\",\n    \"regional_indicator_symbol_letter_g\": \"ğŸ‡¬\",\n    \"regional_indicator_symbol_letter_h\": \"ğŸ‡­\",\n    \"regional_indicator_symbol_letter_i\": \"ğŸ‡®\",\n    \"regional_indicator_symbol_letter_j\": \"ğŸ‡¯\",\n    \"regional_indicator_symbol_letter_k\": \"ğŸ‡°\",\n    \"regional_indicator_symbol_letter_l\": \"ğŸ‡±\",\n    \"regional_indicator_symbol_letter_m\": \"ğŸ‡²\",\n    \"regional_indicator_symbol_letter_n\": \"ğŸ‡³\",\n    \"regional_indicator_symbol_letter_o\": \"ğŸ‡´\",\n    \"regional_indicator_symbol_letter_p\": \"ğŸ‡µ\",\n    \"regional_indicator_symbol_letter_q\": \"ğŸ‡¶\",\n    \"regional_indicator_symbol_letter_r\": \"ğŸ‡·\",\n    \"regional_indicator_symbol_letter_s\": \"ğŸ‡¸\",\n    \"regional_indicator_symbol_letter_t\": \"ğŸ‡¹\",\n    \"regional_indicator_symbol_letter_u\": \"ğŸ‡º\",\n    \"regional_indicator_symbol_letter_v\": \"ğŸ‡»\",\n    \"regional_indicator_symbol_letter_w\": \"ğŸ‡¼\",\n    \"regional_indicator_symbol_letter_x\": \"ğŸ‡½\",\n    \"regional_indicator_symbol_letter_y\": \"ğŸ‡¾\",\n    \"regional_indicator_symbol_letter_z\": \"ğŸ‡¿\",\n    \"airplane_arriving\": \"ğŸ›¬\",\n    \"space_invader\": \"ğŸ‘¾\",\n    \"football\": \"ğŸˆ\",\n    \"anger\": \"ğŸ’¢\",\n    \"angry\": \"ğŸ˜ \",\n    \"anguished\": \"ğŸ˜§\",\n    \"signal_strength\": \"ğŸ“¶\",\n    \"arrows_counterclockwise\": \"ğŸ”„\",\n    \"arrow_heading_down\": \"â¤µ\",\n    \"arrow_heading_up\": \"â¤´\",\n    \"art\": \"ğŸ¨\",\n    \"astonished\": \"ğŸ˜²\",\n    \"athletic_shoe\": \"ğŸ‘Ÿ\",\n    \"atm\": \"ğŸ§\",\n    \"car\": \"ğŸš—\",\n    \"red_car\": \"ğŸš—\",\n    \"angel\": \"ğŸ‘¼\",\n    \"back\": \"ğŸ”™\",\n    \"badminton_racquet_and_shuttlecock\": \"ğŸ¸\",\n    \"dollar\": \"ğŸ’µ\",\n    \"euro\": \"ğŸ’¶\",\n    \"pound\": \"ğŸ’·\",\n    \"yen\": \"ğŸ’´\",\n    \"barber\": \"ğŸ’ˆ\",\n    \"bath\": \"ğŸ›€\",\n    \"bear\": \"ğŸ»\",\n    \"heartbeat\": \"ğŸ’“\",\n    \"beer\": \"ğŸº\",\n    \"no_bell\": \"ğŸ”•\",\n    \"bento\": \"ğŸ±\",\n    \"bike\": \"ğŸš²\",\n    \"bicyclist\": \"ğŸš´\",\n    \"8ball\": \"ğŸ±\",\n    \"biohazard_sign\": \"â˜£\",\n    \"birthday\": \"ğŸ‚\",\n    \"black_circle_for_record\": \"âº\",\n    \"clubs\": \"â™£\",\n    \"diamonds\": \"â™¦\",\n    \"arrow_double_down\": \"â¬\",\n    \"hearts\": \"â™¥\",\n    \"rewind\": \"âª\",\n    \"black_left__pointing_double_triangle_with_vertical_bar\": \"â®\",\n    \"arrow_backward\": \"â—€\",\n    \"black_medium_small_square\": \"â—¾\",\n    \"question\": \"â“\",\n    \"fast_forward\": \"â©\",\n    \"black_right__pointing_double_triangle_with_vertical_bar\": \"â­\",\n    \"arrow_forward\": \"â–¶\",\n    \"black_right__pointing_triangle_with_double_vertical_bar\": \"â¯\",\n    \"arrow_right\": \"â¡\",\n    \"spades\": \"â™ \",\n    \"black_square_for_stop\": \"â¹\",\n    \"sunny\": \"â˜€\",\n    \"phone\": \"â˜\",\n    \"recycle\": \"â™»\",\n    \"arrow_double_up\": \"â«\",\n    \"busstop\": \"ğŸš\",\n    \"date\": \"ğŸ“…\",\n    \"flags\": \"ğŸ\",\n    \"cat2\": \"ğŸˆ\",\n    \"joy_cat\": \"ğŸ˜¹\",\n    \"smirk_cat\": \"ğŸ˜¼\",\n    \"chart_with_downwards_trend\": \"ğŸ“‰\",\n    \"chart_with_upwards_trend\": \"ğŸ“ˆ\",\n    \"chart\": \"ğŸ’¹\",\n    \"mega\": \"ğŸ“£\",\n    \"checkered_flag\": \"ğŸ\",\n    \"accept\": \"ğŸ‰‘\",\n    \"ideograph_advantage\": \"ğŸ‰\",\n    \"congratulations\": \"ãŠ—\",\n    \"secret\": \"ãŠ™\",\n    \"m\": \"â“‚\",\n    \"city_sunset\": \"ğŸŒ†\",\n    \"clapper\": \"ğŸ¬\",\n    \"clap\": \"ğŸ‘\",\n    \"beers\": \"ğŸ»\",\n    \"clock830\": \"ğŸ•£\",\n    \"clock8\": \"ğŸ•—\",\n    \"clock1130\": \"ğŸ•¦\",\n    \"clock11\": \"ğŸ•š\",\n    \"clock530\": \"ğŸ• \",\n    \"clock5\": \"ğŸ•”\",\n    \"clock430\": \"ğŸ•Ÿ\",\n    \"clock4\": \"ğŸ•“\",\n    \"clock930\": \"ğŸ•¤\",\n    \"clock9\": \"ğŸ•˜\",\n    \"clock130\": \"ğŸ•œ\",\n    \"clock1\": \"ğŸ•\",\n    \"clock730\": \"ğŸ•¢\",\n    \"clock7\": \"ğŸ•–\",\n    \"clock630\": \"ğŸ•¡\",\n    \"clock6\": \"ğŸ••\",\n    \"clock1030\": \"ğŸ•¥\",\n    \"clock10\": \"ğŸ•™\",\n    \"clock330\": \"ğŸ•\",\n    \"clock3\": \"ğŸ•’\",\n    \"clock1230\": \"ğŸ•§\",\n    \"clock12\": \"ğŸ•›\",\n    \"clock230\": \"ğŸ•\",\n    \"clock2\": \"ğŸ•‘\",\n    \"arrows_clockwise\": \"ğŸ”ƒ\",\n    \"repeat\": \"ğŸ”\",\n    \"repeat_one\": \"ğŸ”‚\",\n    \"closed_lock_with_key\": \"ğŸ”\",\n    \"mailbox_closed\": \"ğŸ“ª\",\n    \"mailbox\": \"ğŸ“«\",\n    \"cloud_with_tornado\": \"ğŸŒª\",\n    \"cocktail\": \"ğŸ¸\",\n    \"boom\": \"ğŸ’¥\",\n    \"compression\": \"ğŸ—œ\",\n    \"confounded\": \"ğŸ˜–\",\n    \"confused\": \"ğŸ˜•\",\n    \"rice\": \"ğŸš\",\n    \"cow2\": \"ğŸ„\",\n    \"cricket_bat_and_ball\": \"ğŸ\",\n    \"x\": \"âŒ\",\n    \"cry\": \"ğŸ˜¢\",\n    \"curry\": \"ğŸ›\",\n    \"dagger_knife\": \"ğŸ—¡\",\n    \"dancer\": \"ğŸ’ƒ\",\n    \"dark_sunglasses\": \"ğŸ•¶\",\n    \"dash\": \"ğŸ’¨\",\n    \"truck\": \"ğŸšš\",\n    \"derelict_house_building\": \"ğŸš\",\n    \"diamond_shape_with_a_dot_inside\": \"ğŸ’ \",\n    \"dart\": \"ğŸ¯\",\n    \"disappointed_relieved\": \"ğŸ˜¥\",\n    \"disappointed\": \"ğŸ˜\",\n    \"do_not_litter\": \"ğŸš¯\",\n    \"dog2\": \"ğŸ•\",\n    \"flipper\": \"ğŸ¬\",\n    \"loop\": \"â¿\",\n    \"bangbang\": \"â€¼\",\n    \"double_vertical_bar\": \"â¸\",\n    \"dove_of_peace\": \"ğŸ•Š\",\n    \"small_red_triangle_down\": \"ğŸ”»\",\n    \"arrow_down_small\": \"ğŸ”½\",\n    \"arrow_down\": \"â¬‡\",\n    \"dromedary_camel\": \"ğŸª\",\n    \"e__mail\": \"ğŸ“§\",\n    \"corn\": \"ğŸŒ½\",\n    \"ear_of_rice\": \"ğŸŒ¾\",\n    \"earth_americas\": \"ğŸŒ\",\n    \"earth_asia\": \"ğŸŒ\",\n    \"earth_africa\": \"ğŸŒ\",\n    \"eight_pointed_black_star\": \"âœ´\",\n    \"eight_spoked_asterisk\": \"âœ³\",\n    \"eject_symbol\": \"â\",\n    \"bulb\": \"ğŸ’¡\",\n    \"emoji_modifier_fitzpatrick_type__1__2\": \"ğŸ»\",\n    \"emoji_modifier_fitzpatrick_type__3\": \"ğŸ¼\",\n    \"emoji_modifier_fitzpatrick_type__4\": \"ğŸ½\",\n    \"emoji_modifier_fitzpatrick_type__5\": \"ğŸ¾\",\n    \"emoji_modifier_fitzpatrick_type__6\": \"ğŸ¿\",\n    \"end\": \"ğŸ”š\",\n    \"email\": \"âœ‰\",\n    \"european_castle\": \"ğŸ°\",\n    \"european_post_office\": \"ğŸ¤\",\n    \"interrobang\": \"â‰\",\n    \"expressionless\": \"ğŸ˜‘\",\n    \"eyeglasses\": \"ğŸ‘“\",\n    \"massage\": \"ğŸ’†\",\n    \"yum\": \"ğŸ˜‹\",\n    \"scream\": \"ğŸ˜±\",\n    \"kissing_heart\": \"ğŸ˜˜\",\n    \"sweat\": \"ğŸ˜“\",\n    \"face_with_head__bandage\": \"ğŸ¤•\",\n    \"triumph\": \"ğŸ˜¤\",\n    \"mask\": \"ğŸ˜·\",\n    \"no_good\": \"ğŸ™…\",\n    \"ok_woman\": \"ğŸ™†\",\n    \"open_mouth\": \"ğŸ˜®\",\n    \"cold_sweat\": \"ğŸ˜°\",\n    \"stuck_out_tongue\": \"ğŸ˜›\",\n    \"stuck_out_tongue_closed_eyes\": \"ğŸ˜\",\n    \"stuck_out_tongue_winking_eye\": \"ğŸ˜œ\",\n    \"joy\": \"ğŸ˜‚\",\n    \"no_mouth\": \"ğŸ˜¶\",\n    \"santa\": \"ğŸ…\",\n    \"fax\": \"ğŸ“ \",\n    \"fearful\": \"ğŸ˜¨\",\n    \"field_hockey_stick_and_ball\": \"ğŸ‘\",\n    \"first_quarter_moon_with_face\": \"ğŸŒ›\",\n    \"fish_cake\": \"ğŸ¥\",\n    \"fishing_pole_and_fish\": \"ğŸ£\",\n    \"facepunch\": \"ğŸ‘Š\",\n    \"punch\": \"ğŸ‘Š\",\n    \"flag_for_afghanistan\": \"ğŸ‡¦ğŸ‡«\",\n    \"flag_for_albania\": \"ğŸ‡¦ğŸ‡±\",\n    \"flag_for_algeria\": \"ğŸ‡©ğŸ‡¿\",\n    \"flag_for_american_samoa\": \"ğŸ‡¦ğŸ‡¸\",\n    \"flag_for_andorra\": \"ğŸ‡¦ğŸ‡©\",\n    \"flag_for_angola\": \"ğŸ‡¦ğŸ‡´\",\n    \"flag_for_anguilla\": \"ğŸ‡¦ğŸ‡®\",\n    \"flag_for_antarctica\": \"ğŸ‡¦ğŸ‡¶\",\n    \"flag_for_antigua_&_barbuda\": \"ğŸ‡¦ğŸ‡¬\",\n    \"flag_for_argentina\": \"ğŸ‡¦ğŸ‡·\",\n    \"flag_for_armenia\": \"ğŸ‡¦ğŸ‡²\",\n    \"flag_for_aruba\": \"ğŸ‡¦ğŸ‡¼\",\n    \"flag_for_ascension_island\": \"ğŸ‡¦ğŸ‡¨\",\n    \"flag_for_australia\": \"ğŸ‡¦ğŸ‡º\",\n    \"flag_for_austria\": \"ğŸ‡¦ğŸ‡¹\",\n    \"flag_for_azerbaijan\": \"ğŸ‡¦ğŸ‡¿\",\n    \"flag_for_bahamas\": \"ğŸ‡§ğŸ‡¸\",\n    \"flag_for_bahrain\": \"ğŸ‡§ğŸ‡­\",\n    \"flag_for_bangladesh\": \"ğŸ‡§ğŸ‡©\",\n    \"flag_for_barbados\": \"ğŸ‡§ğŸ‡§\",\n    \"flag_for_belarus\": \"ğŸ‡§ğŸ‡¾\",\n    \"flag_for_belgium\": \"ğŸ‡§ğŸ‡ª\",\n    \"flag_for_belize\": \"ğŸ‡§ğŸ‡¿\",\n    \"flag_for_benin\": \"ğŸ‡§ğŸ‡¯\",\n    \"flag_for_bermuda\": \"ğŸ‡§ğŸ‡²\",\n    \"flag_for_bhutan\": \"ğŸ‡§ğŸ‡¹\",\n    \"flag_for_bolivia\": \"ğŸ‡§ğŸ‡´\",\n    \"flag_for_bosnia_&_herzegovina\": \"ğŸ‡§ğŸ‡¦\",\n    \"flag_for_botswana\": \"ğŸ‡§ğŸ‡¼\",\n    \"flag_for_bouvet_island\": \"ğŸ‡§ğŸ‡»\",\n    \"flag_for_brazil\": \"ğŸ‡§ğŸ‡·\",\n    \"flag_for_british_indian_ocean_territory\": \"ğŸ‡®ğŸ‡´\",\n    \"flag_for_british_virgin_islands\": \"ğŸ‡»ğŸ‡¬\",\n    \"flag_for_brunei\": \"ğŸ‡§ğŸ‡³\",\n    \"flag_for_bulgaria\": \"ğŸ‡§ğŸ‡¬\",\n    \"flag_for_burkina_faso\": \"ğŸ‡§ğŸ‡«\",\n    \"flag_for_burundi\": \"ğŸ‡§ğŸ‡®\",\n    \"flag_for_cambodia\": \"ğŸ‡°ğŸ‡­\",\n    \"flag_for_cameroon\": \"ğŸ‡¨ğŸ‡²\",\n    \"flag_for_canada\": \"ğŸ‡¨ğŸ‡¦\",\n    \"flag_for_canary_islands\": \"ğŸ‡®ğŸ‡¨\",\n    \"flag_for_cape_verde\": \"ğŸ‡¨ğŸ‡»\",\n    \"flag_for_caribbean_netherlands\": \"ğŸ‡§ğŸ‡¶\",\n    \"flag_for_cayman_islands\": \"ğŸ‡°ğŸ‡¾\",\n    \"flag_for_central_african_republic\": \"ğŸ‡¨ğŸ‡«\",\n    \"flag_for_ceuta_&_melilla\": \"ğŸ‡ªğŸ‡¦\",\n    \"flag_for_chad\": \"ğŸ‡¹ğŸ‡©\",\n    \"flag_for_chile\": \"ğŸ‡¨ğŸ‡±\",\n    \"flag_for_china\": \"ğŸ‡¨ğŸ‡³\",\n    \"flag_for_christmas_island\": \"ğŸ‡¨ğŸ‡½\",\n    \"flag_for_clipperton_island\": \"ğŸ‡¨ğŸ‡µ\",\n    \"flag_for_cocos__islands\": \"ğŸ‡¨ğŸ‡¨\",\n    \"flag_for_colombia\": \"ğŸ‡¨ğŸ‡´\",\n    \"flag_for_comoros\": \"ğŸ‡°ğŸ‡²\",\n    \"flag_for_congo____brazzaville\": \"ğŸ‡¨ğŸ‡¬\",\n    \"flag_for_congo____kinshasa\": \"ğŸ‡¨ğŸ‡©\",\n    \"flag_for_cook_islands\": \"ğŸ‡¨ğŸ‡°\",\n    \"flag_for_costa_rica\": \"ğŸ‡¨ğŸ‡·\",\n    \"flag_for_croatia\": \"ğŸ‡­ğŸ‡·\",\n    \"flag_for_cuba\": \"ğŸ‡¨ğŸ‡º\",\n    \"flag_for_curaÃ§ao\": \"ğŸ‡¨ğŸ‡¼\",\n    \"flag_for_cyprus\": \"ğŸ‡¨ğŸ‡¾\",\n    \"flag_for_czech_republic\": \"ğŸ‡¨ğŸ‡¿\",\n    \"flag_for_cÃ´te_dâ€™ivoire\": \"ğŸ‡¨ğŸ‡®\",\n    \"flag_for_denmark\": \"ğŸ‡©ğŸ‡°\",\n    \"flag_for_diego_garcia\": \"ğŸ‡©ğŸ‡¬\",\n    \"flag_for_djibouti\": \"ğŸ‡©ğŸ‡¯\",\n    \"flag_for_dominica\": \"ğŸ‡©ğŸ‡²\",\n    \"flag_for_dominican_republic\": \"ğŸ‡©ğŸ‡´\",\n    \"flag_for_ecuador\": \"ğŸ‡ªğŸ‡¨\",\n    \"flag_for_egypt\": \"ğŸ‡ªğŸ‡¬\",\n    \"flag_for_el_salvador\": \"ğŸ‡¸ğŸ‡»\",\n    \"flag_for_equatorial_guinea\": \"ğŸ‡¬ğŸ‡¶\",\n    \"flag_for_eritrea\": \"ğŸ‡ªğŸ‡·\",\n    \"flag_for_estonia\": \"ğŸ‡ªğŸ‡ª\",\n    \"flag_for_ethiopia\": \"ğŸ‡ªğŸ‡¹\",\n    \"flag_for_european_union\": \"ğŸ‡ªğŸ‡º\",\n    \"flag_for_falkland_islands\": \"ğŸ‡«ğŸ‡°\",\n    \"flag_for_faroe_islands\": \"ğŸ‡«ğŸ‡´\",\n    \"flag_for_fiji\": \"ğŸ‡«ğŸ‡¯\",\n    \"flag_for_finland\": \"ğŸ‡«ğŸ‡®\",\n    \"flag_for_france\": \"ğŸ‡«ğŸ‡·\",\n    \"flag_for_french_guiana\": \"ğŸ‡¬ğŸ‡«\",\n    \"flag_for_french_polynesia\": \"ğŸ‡µğŸ‡«\",\n    \"flag_for_french_southern_territories\": \"ğŸ‡¹ğŸ‡«\",\n    \"flag_for_gabon\": \"ğŸ‡¬ğŸ‡¦\",\n    \"flag_for_gambia\": \"ğŸ‡¬ğŸ‡²\",\n    \"flag_for_georgia\": \"ğŸ‡¬ğŸ‡ª\",\n    \"flag_for_germany\": \"ğŸ‡©ğŸ‡ª\",\n    \"flag_for_ghana\": \"ğŸ‡¬ğŸ‡­\",\n    \"flag_for_gibraltar\": \"ğŸ‡¬ğŸ‡®\",\n    \"flag_for_greece\": \"ğŸ‡¬ğŸ‡·\",\n    \"flag_for_greenland\": \"ğŸ‡¬ğŸ‡±\",\n    \"flag_for_grenada\": \"ğŸ‡¬ğŸ‡©\",\n    \"flag_for_guadeloupe\": \"ğŸ‡¬ğŸ‡µ\",\n    \"flag_for_guam\": \"ğŸ‡¬ğŸ‡º\",\n    \"flag_for_guatemala\": \"ğŸ‡¬ğŸ‡¹\",\n    \"flag_for_guernsey\": \"ğŸ‡¬ğŸ‡¬\",\n    \"flag_for_guinea\": \"ğŸ‡¬ğŸ‡³\",\n    \"flag_for_guinea__bissau\": \"ğŸ‡¬ğŸ‡¼\",\n    \"flag_for_guyana\": \"ğŸ‡¬ğŸ‡¾\",\n    \"flag_for_haiti\": \"ğŸ‡­ğŸ‡¹\",\n    \"flag_for_heard_&_mcdonald_islands\": \"ğŸ‡­ğŸ‡²\",\n    \"flag_for_honduras\": \"ğŸ‡­ğŸ‡³\",\n    \"flag_for_hong_kong\": \"ğŸ‡­ğŸ‡°\",\n    \"flag_for_hungary\": \"ğŸ‡­ğŸ‡º\",\n    \"flag_for_iceland\": \"ğŸ‡®ğŸ‡¸\",\n    \"flag_for_india\": \"ğŸ‡®ğŸ‡³\",\n    \"flag_for_indonesia\": \"ğŸ‡®ğŸ‡©\",\n    \"flag_for_iran\": \"ğŸ‡®ğŸ‡·\",\n    \"flag_for_iraq\": \"ğŸ‡®ğŸ‡¶\",\n    \"flag_for_ireland\": \"ğŸ‡®ğŸ‡ª\",\n    \"flag_for_isle_of_man\": \"ğŸ‡®ğŸ‡²\",\n    \"flag_for_israel\": \"ğŸ‡®ğŸ‡±\",\n    \"flag_for_italy\": \"ğŸ‡®ğŸ‡¹\",\n    \"flag_for_jamaica\": \"ğŸ‡¯ğŸ‡²\",\n    \"flag_for_japan\": \"ğŸ‡¯ğŸ‡µ\",\n    \"flag_for_jersey\": \"ğŸ‡¯ğŸ‡ª\",\n    \"flag_for_jordan\": \"ğŸ‡¯ğŸ‡´\",\n    \"flag_for_kazakhstan\": \"ğŸ‡°ğŸ‡¿\",\n    \"flag_for_kenya\": \"ğŸ‡°ğŸ‡ª\",\n    \"flag_for_kiribati\": \"ğŸ‡°ğŸ‡®\",\n    \"flag_for_kosovo\": \"ğŸ‡½ğŸ‡°\",\n    \"flag_for_kuwait\": \"ğŸ‡°ğŸ‡¼\",\n    \"flag_for_kyrgyzstan\": \"ğŸ‡°ğŸ‡¬\",\n    \"flag_for_laos\": \"ğŸ‡±ğŸ‡¦\",\n    \"flag_for_latvia\": \"ğŸ‡±ğŸ‡»\",\n    \"flag_for_lebanon\": \"ğŸ‡±ğŸ‡§\",\n    \"flag_for_lesotho\": \"ğŸ‡±ğŸ‡¸\",\n    \"flag_for_liberia\": \"ğŸ‡±ğŸ‡·\",\n    \"flag_for_libya\": \"ğŸ‡±ğŸ‡¾\",\n    \"flag_for_liechtenstein\": \"ğŸ‡±ğŸ‡®\",\n    \"flag_for_lithuania\": \"ğŸ‡±ğŸ‡¹\",\n    \"flag_for_luxembourg\": \"ğŸ‡±ğŸ‡º\",\n    \"flag_for_macau\": \"ğŸ‡²ğŸ‡´\",\n    \"flag_for_macedonia\": \"ğŸ‡²ğŸ‡°\",\n    \"flag_for_madagascar\": \"ğŸ‡²ğŸ‡¬\",\n    \"flag_for_malawi\": \"ğŸ‡²ğŸ‡¼\",\n    \"flag_for_malaysia\": \"ğŸ‡²ğŸ‡¾\",\n    \"flag_for_maldives\": \"ğŸ‡²ğŸ‡»\",\n    \"flag_for_mali\": \"ğŸ‡²ğŸ‡±\",\n    \"flag_for_malta\": \"ğŸ‡²ğŸ‡¹\",\n    \"flag_for_marshall_islands\": \"ğŸ‡²ğŸ‡­\",\n    \"flag_for_martinique\": \"ğŸ‡²ğŸ‡¶\",\n    \"flag_for_mauritania\": \"ğŸ‡²ğŸ‡·\",\n    \"flag_for_mauritius\": \"ğŸ‡²ğŸ‡º\",\n    \"flag_for_mayotte\": \"ğŸ‡¾ğŸ‡¹\",\n    \"flag_for_mexico\": \"ğŸ‡²ğŸ‡½\",\n    \"flag_for_micronesia\": \"ğŸ‡«ğŸ‡²\",\n    \"flag_for_moldova\": \"ğŸ‡²ğŸ‡©\",\n    \"flag_for_monaco\": \"ğŸ‡²ğŸ‡¨\",\n    \"flag_for_mongolia\": \"ğŸ‡²ğŸ‡³\",\n    \"flag_for_montenegro\": \"ğŸ‡²ğŸ‡ª\",\n    \"flag_for_montserrat\": \"ğŸ‡²ğŸ‡¸\",\n    \"flag_for_morocco\": \"ğŸ‡²ğŸ‡¦\",\n    \"flag_for_mozambique\": \"ğŸ‡²ğŸ‡¿\",\n    \"flag_for_myanmar\": \"ğŸ‡²ğŸ‡²\",\n    \"flag_for_namibia\": \"ğŸ‡³ğŸ‡¦\",\n    \"flag_for_nauru\": \"ğŸ‡³ğŸ‡·\",\n    \"flag_for_nepal\": \"ğŸ‡³ğŸ‡µ\",\n    \"flag_for_netherlands\": \"ğŸ‡³ğŸ‡±\",\n    \"flag_for_new_caledonia\": \"ğŸ‡³ğŸ‡¨\",\n    \"flag_for_new_zealand\": \"ğŸ‡³ğŸ‡¿\",\n    \"flag_for_nicaragua\": \"ğŸ‡³ğŸ‡®\",\n    \"flag_for_niger\": \"ğŸ‡³ğŸ‡ª\",\n    \"flag_for_nigeria\": \"ğŸ‡³ğŸ‡¬\",\n    \"flag_for_niue\": \"ğŸ‡³ğŸ‡º\",\n    \"flag_for_norfolk_island\": \"ğŸ‡³ğŸ‡«\",\n    \"flag_for_north_korea\": \"ğŸ‡°ğŸ‡µ\",\n    \"flag_for_northern_mariana_islands\": \"ğŸ‡²ğŸ‡µ\",\n    \"flag_for_norway\": \"ğŸ‡³ğŸ‡´\",\n    \"flag_for_oman\": \"ğŸ‡´ğŸ‡²\",\n    \"flag_for_pakistan\": \"ğŸ‡µğŸ‡°\",\n    \"flag_for_palau\": \"ğŸ‡µğŸ‡¼\",\n    \"flag_for_palestinian_territories\": \"ğŸ‡µğŸ‡¸\",\n    \"flag_for_panama\": \"ğŸ‡µğŸ‡¦\",\n    \"flag_for_papua_new_guinea\": \"ğŸ‡µğŸ‡¬\",\n    \"flag_for_paraguay\": \"ğŸ‡µğŸ‡¾\",\n    \"flag_for_peru\": \"ğŸ‡µğŸ‡ª\",\n    \"flag_for_philippines\": \"ğŸ‡µğŸ‡­\",\n    \"flag_for_pitcairn_islands\": \"ğŸ‡µğŸ‡³\",\n    \"flag_for_poland\": \"ğŸ‡µğŸ‡±\",\n    \"flag_for_portugal\": \"ğŸ‡µğŸ‡¹\",\n    \"flag_for_puerto_rico\": \"ğŸ‡µğŸ‡·\",\n    \"flag_for_qatar\": \"ğŸ‡¶ğŸ‡¦\",\n    \"flag_for_romania\": \"ğŸ‡·ğŸ‡´\",\n    \"flag_for_russia\": \"ğŸ‡·ğŸ‡º\",\n    \"flag_for_rwanda\": \"ğŸ‡·ğŸ‡¼\",\n    \"flag_for_rÃ©union\": \"ğŸ‡·ğŸ‡ª\",\n    \"flag_for_samoa\": \"ğŸ‡¼ğŸ‡¸\",\n    \"flag_for_san_marino\": \"ğŸ‡¸ğŸ‡²\",\n    \"flag_for_saudi_arabia\": \"ğŸ‡¸ğŸ‡¦\",\n    \"flag_for_senegal\": \"ğŸ‡¸ğŸ‡³\",\n    \"flag_for_serbia\": \"ğŸ‡·ğŸ‡¸\",\n    \"flag_for_seychelles\": \"ğŸ‡¸ğŸ‡¨\",\n    \"flag_for_sierra_leone\": \"ğŸ‡¸ğŸ‡±\",\n    \"flag_for_singapore\": \"ğŸ‡¸ğŸ‡¬\",\n    \"flag_for_sint_maarten\": \"ğŸ‡¸ğŸ‡½\",\n    \"flag_for_slovakia\": \"ğŸ‡¸ğŸ‡°\",\n    \"flag_for_slovenia\": \"ğŸ‡¸ğŸ‡®\",\n    \"flag_for_solomon_islands\": \"ğŸ‡¸ğŸ‡§\",\n    \"flag_for_somalia\": \"ğŸ‡¸ğŸ‡´\",\n    \"flag_for_south_africa\": \"ğŸ‡¿ğŸ‡¦\",\n    \"flag_for_south_georgia_&_south_sandwich_islands\": \"ğŸ‡¬ğŸ‡¸\",\n    \"flag_for_south_korea\": \"ğŸ‡°ğŸ‡·\",\n    \"flag_for_south_sudan\": \"ğŸ‡¸ğŸ‡¸\",\n    \"flag_for_spain\": \"ğŸ‡ªğŸ‡¸\",\n    \"flag_for_sri_lanka\": \"ğŸ‡±ğŸ‡°\",\n    \"flag_for_st._barthÃ©lemy\": \"ğŸ‡§ğŸ‡±\",\n    \"flag_for_st._helena\": \"ğŸ‡¸ğŸ‡­\",\n    \"flag_for_st._kitts_&_nevis\": \"ğŸ‡°ğŸ‡³\",\n    \"flag_for_st._lucia\": \"ğŸ‡±ğŸ‡¨\",\n    \"flag_for_st._martin\": \"ğŸ‡²ğŸ‡«\",\n    \"flag_for_st._pierre_&_miquelon\": \"ğŸ‡µğŸ‡²\",\n    \"flag_for_st._vincent_&_grenadines\": \"ğŸ‡»ğŸ‡¨\",\n    \"flag_for_sudan\": \"ğŸ‡¸ğŸ‡©\",\n    \"flag_for_suriname\": \"ğŸ‡¸ğŸ‡·\",\n    \"flag_for_svalbard_&_jan_mayen\": \"ğŸ‡¸ğŸ‡¯\",\n    \"flag_for_swaziland\": \"ğŸ‡¸ğŸ‡¿\",\n    \"flag_for_sweden\": \"ğŸ‡¸ğŸ‡ª\",\n    \"flag_for_switzerland\": \"ğŸ‡¨ğŸ‡­\",\n    \"flag_for_syria\": \"ğŸ‡¸ğŸ‡¾\",\n    \"flag_for_sÃ£o_tomÃ©_&_prÃ­ncipe\": \"ğŸ‡¸ğŸ‡¹\",\n    \"flag_for_taiwan\": \"ğŸ‡¹ğŸ‡¼\",\n    \"flag_for_tajikistan\": \"ğŸ‡¹ğŸ‡¯\",\n    \"flag_for_tanzania\": \"ğŸ‡¹ğŸ‡¿\",\n    \"flag_for_thailand\": \"ğŸ‡¹ğŸ‡­\",\n    \"flag_for_timor__leste\": \"ğŸ‡¹ğŸ‡±\",\n    \"flag_for_togo\": \"ğŸ‡¹ğŸ‡¬\",\n    \"flag_for_tokelau\": \"ğŸ‡¹ğŸ‡°\",\n    \"flag_for_tonga\": \"ğŸ‡¹ğŸ‡´\",\n    \"flag_for_trinidad_&_tobago\": \"ğŸ‡¹ğŸ‡¹\",\n    \"flag_for_tristan_da_cunha\": \"ğŸ‡¹ğŸ‡¦\",\n    \"flag_for_tunisia\": \"ğŸ‡¹ğŸ‡³\",\n    \"flag_for_turkey\": \"ğŸ‡¹ğŸ‡·\",\n    \"flag_for_turkmenistan\": \"ğŸ‡¹ğŸ‡²\",\n    \"flag_for_turks_&_caicos_islands\": \"ğŸ‡¹ğŸ‡¨\",\n    \"flag_for_tuvalu\": \"ğŸ‡¹ğŸ‡»\",\n    \"flag_for_u.s._outlying_islands\": \"ğŸ‡ºğŸ‡²\",\n    \"flag_for_u.s._virgin_islands\": \"ğŸ‡»ğŸ‡®\",\n    \"flag_for_uganda\": \"ğŸ‡ºğŸ‡¬\",\n    \"flag_for_ukraine\": \"ğŸ‡ºğŸ‡¦\",\n    \"flag_for_united_arab_emirates\": \"ğŸ‡¦ğŸ‡ª\",\n    \"flag_for_united_kingdom\": \"ğŸ‡¬ğŸ‡§\",\n    \"flag_for_united_states\": \"ğŸ‡ºğŸ‡¸\",\n    \"flag_for_uruguay\": \"ğŸ‡ºğŸ‡¾\",\n    \"flag_for_uzbekistan\": \"ğŸ‡ºğŸ‡¿\",\n    \"flag_for_vanuatu\": \"ğŸ‡»ğŸ‡º\",\n    \"flag_for_vatican_city\": \"ğŸ‡»ğŸ‡¦\",\n    \"flag_for_venezuela\": \"ğŸ‡»ğŸ‡ª\",\n    \"flag_for_vietnam\": \"ğŸ‡»ğŸ‡³\",\n    \"flag_for_wallis_&_futuna\": \"ğŸ‡¼ğŸ‡«\",\n    \"flag_for_western_sahara\": \"ğŸ‡ªğŸ‡­\",\n    \"flag_for_yemen\": \"ğŸ‡¾ğŸ‡ª\",\n    \"flag_for_zambia\": \"ğŸ‡¿ğŸ‡²\",\n    \"flag_for_zimbabwe\": \"ğŸ‡¿ğŸ‡¼\",\n    \"flag_for_Ã¥land_islands\": \"ğŸ‡¦ğŸ‡½\",\n    \"golf\": \"â›³\",\n    \"fleur__de__lis\": \"âšœ\",\n    \"muscle\": \"ğŸ’ª\",\n    \"flushed\": \"ğŸ˜³\",\n    \"frame_with_picture\": \"ğŸ–¼\",\n    \"fries\": \"ğŸŸ\",\n    \"frog\": \"ğŸ¸\",\n    \"hatched_chick\": \"ğŸ¥\",\n    \"frowning\": \"ğŸ˜¦\",\n    \"fuelpump\": \"â›½\",\n    \"full_moon_with_face\": \"ğŸŒ\",\n    \"gem\": \"ğŸ’\",\n    \"star2\": \"ğŸŒŸ\",\n    \"golfer\": \"ğŸŒ\",\n    \"mortar_board\": \"ğŸ“\",\n    \"grimacing\": \"ğŸ˜¬\",\n    \"smile_cat\": \"ğŸ˜¸\",\n    \"grinning\": \"ğŸ˜€\",\n    \"grin\": \"ğŸ˜\",\n    \"heartpulse\": \"ğŸ’—\",\n    \"guardsman\": \"ğŸ’‚\",\n    \"haircut\": \"ğŸ’‡\",\n    \"hamster\": \"ğŸ¹\",\n    \"raising_hand\": \"ğŸ™‹\",\n    \"headphones\": \"ğŸ§\",\n    \"hear_no_evil\": \"ğŸ™‰\",\n    \"cupid\": \"ğŸ’˜\",\n    \"gift_heart\": \"ğŸ’\",\n    \"heart\": \"â¤\",\n    \"exclamation\": \"â—\",\n    \"heavy_exclamation_mark\": \"â—\",\n    \"heavy_heart_exclamation_mark_ornament\": \"â£\",\n    \"o\": \"â­•\",\n    \"helm_symbol\": \"âˆ\",\n    \"helmet_with_white_cross\": \"â›‘\",\n    \"high_heel\": \"ğŸ‘ \",\n    \"bullettrain_side\": \"ğŸš„\",\n    \"bullettrain_front\": \"ğŸš…\",\n    \"high_brightness\": \"ğŸ”†\",\n    \"zap\": \"âš¡\",\n    \"hocho\": \"ğŸ”ª\",\n    \"knife\": \"ğŸ”ª\",\n    \"bee\": \"ğŸ\",\n    \"traffic_light\": \"ğŸš¥\",\n    \"racehorse\": \"ğŸ\",\n    \"coffee\": \"â˜•\",\n    \"hotsprings\": \"â™¨\",\n    \"hourglass\": \"âŒ›\",\n    \"hourglass_flowing_sand\": \"â³\",\n    \"house_buildings\": \"ğŸ˜\",\n    \"100\": \"ğŸ’¯\",\n    \"hushed\": \"ğŸ˜¯\",\n    \"ice_hockey_stick_and_puck\": \"ğŸ’\",\n    \"imp\": \"ğŸ‘¿\",\n    \"information_desk_person\": \"ğŸ’\",\n    \"information_source\": \"â„¹\",\n    \"capital_abcd\": \"ğŸ” \",\n    \"abc\": \"ğŸ”¤\",\n    \"abcd\": \"ğŸ”¡\",\n    \"1234\": \"ğŸ”¢\",\n    \"symbols\": \"ğŸ”£\",\n    \"izakaya_lantern\": \"ğŸ®\",\n    \"lantern\": \"ğŸ®\",\n    \"jack_o_lantern\": \"ğŸƒ\",\n    \"dolls\": \"ğŸ\",\n    \"japanese_goblin\": \"ğŸ‘º\",\n    \"japanese_ogre\": \"ğŸ‘¹\",\n    \"beginner\": \"ğŸ”°\",\n    \"zero\": \"0ï¸âƒ£\",\n    \"one\": \"1ï¸âƒ£\",\n    \"ten\": \"ğŸ”Ÿ\",\n    \"two\": \"2ï¸âƒ£\",\n    \"three\": \"3ï¸âƒ£\",\n    \"four\": \"4ï¸âƒ£\",\n    \"five\": \"5ï¸âƒ£\",\n    \"six\": \"6ï¸âƒ£\",\n    \"seven\": \"7ï¸âƒ£\",\n    \"eight\": \"8ï¸âƒ£\",\n    \"nine\": \"9ï¸âƒ£\",\n    \"couplekiss\": \"ğŸ’\",\n    \"kissing_cat\": \"ğŸ˜½\",\n    \"kissing\": \"ğŸ˜—\",\n    \"kissing_closed_eyes\": \"ğŸ˜š\",\n    \"kissing_smiling_eyes\": \"ğŸ˜™\",\n    \"beetle\": \"ğŸ\",\n    \"large_blue_circle\": \"ğŸ”µ\",\n    \"last_quarter_moon_with_face\": \"ğŸŒœ\",\n    \"leaves\": \"ğŸƒ\",\n    \"mag\": \"ğŸ”\",\n    \"left_right_arrow\": \"â†”\",\n    \"leftwards_arrow_with_hook\": \"â†©\",\n    \"arrow_left\": \"â¬…\",\n    \"lock\": \"ğŸ”’\",\n    \"lock_with_ink_pen\": \"ğŸ”\",\n    \"sob\": \"ğŸ˜­\",\n    \"low_brightness\": \"ğŸ”…\",\n    \"lower_left_ballpoint_pen\": \"ğŸ–Š\",\n    \"lower_left_crayon\": \"ğŸ–\",\n    \"lower_left_fountain_pen\": \"ğŸ–‹\",\n    \"lower_left_paintbrush\": \"ğŸ–Œ\",\n    \"mahjong\": \"ğŸ€„\",\n    \"couple\": \"ğŸ‘«\",\n    \"man_in_business_suit_levitating\": \"ğŸ•´\",\n    \"man_with_gua_pi_mao\": \"ğŸ‘²\",\n    \"man_with_turban\": \"ğŸ‘³\",\n    \"mans_shoe\": \"ğŸ‘\",\n    \"shoe\": \"ğŸ‘\",\n    \"menorah_with_nine_branches\": \"ğŸ•\",\n    \"mens\": \"ğŸš¹\",\n    \"minidisc\": \"ğŸ’½\",\n    \"iphone\": \"ğŸ“±\",\n    \"calling\": \"ğŸ“²\",\n    \"money__mouth_face\": \"ğŸ¤‘\",\n    \"moneybag\": \"ğŸ’°\",\n    \"rice_scene\": \"ğŸ‘\",\n    \"mountain_bicyclist\": \"ğŸšµ\",\n    \"mouse2\": \"ğŸ\",\n    \"lips\": \"ğŸ‘„\",\n    \"moyai\": \"ğŸ—¿\",\n    \"notes\": \"ğŸ¶\",\n    \"nail_care\": \"ğŸ’…\",\n    \"ab\": \"ğŸ†\",\n    \"negative_squared_cross_mark\": \"â\",\n    \"a\": \"ğŸ…°\",\n    \"b\": \"ğŸ…±\",\n    \"o2\": \"ğŸ…¾\",\n    \"parking\": \"ğŸ…¿\",\n    \"new_moon_with_face\": \"ğŸŒš\",\n    \"no_entry_sign\": \"ğŸš«\",\n    \"underage\": \"ğŸ”\",\n    \"non__potable_water\": \"ğŸš±\",\n    \"arrow_upper_right\": \"â†—\",\n    \"arrow_upper_left\": \"â†–\",\n    \"office\": \"ğŸ¢\",\n    \"older_man\": \"ğŸ‘´\",\n    \"older_woman\": \"ğŸ‘µ\",\n    \"om_symbol\": \"ğŸ•‰\",\n    \"on\": \"ğŸ”›\",\n    \"book\": \"ğŸ“–\",\n    \"unlock\": \"ğŸ”“\",\n    \"mailbox_with_no_mail\": \"ğŸ“­\",\n    \"mailbox_with_mail\": \"ğŸ“¬\",\n    \"cd\": \"ğŸ’¿\",\n    \"tada\": \"ğŸ‰\",\n    \"feet\": \"ğŸ¾\",\n    \"walking\": \"ğŸš¶\",\n    \"pencil2\": \"âœ\",\n    \"pensive\": \"ğŸ˜”\",\n    \"persevere\": \"ğŸ˜£\",\n    \"bow\": \"ğŸ™‡\",\n    \"raised_hands\": \"ğŸ™Œ\",\n    \"person_with_ball\": \"â›¹\",\n    \"person_with_blond_hair\": \"ğŸ‘±\",\n    \"pray\": \"ğŸ™\",\n    \"person_with_pouting_face\": \"ğŸ™\",\n    \"computer\": \"ğŸ’»\",\n    \"pig2\": \"ğŸ–\",\n    \"hankey\": \"ğŸ’©\",\n    \"poop\": \"ğŸ’©\",\n    \"shit\": \"ğŸ’©\",\n    \"bamboo\": \"ğŸ\",\n    \"gun\": \"ğŸ”«\",\n    \"black_joker\": \"ğŸƒ\",\n    \"rotating_light\": \"ğŸš¨\",\n    \"cop\": \"ğŸ‘®\",\n    \"stew\": \"ğŸ²\",\n    \"pouch\": \"ğŸ‘\",\n    \"pouting_cat\": \"ğŸ˜¾\",\n    \"rage\": \"ğŸ˜¡\",\n    \"put_litter_in_its_place\": \"ğŸš®\",\n    \"rabbit2\": \"ğŸ‡\",\n    \"racing_motorcycle\": \"ğŸ\",\n    \"radioactive_sign\": \"â˜¢\",\n    \"fist\": \"âœŠ\",\n    \"hand\": \"âœ‹\",\n    \"raised_hand_with_fingers_splayed\": \"ğŸ–\",\n    \"raised_hand_with_part_between_middle_and_ring_fingers\": \"ğŸ––\",\n    \"blue_car\": \"ğŸš™\",\n    \"apple\": \"ğŸ\",\n    \"relieved\": \"ğŸ˜Œ\",\n    \"reversed_hand_with_middle_finger_extended\": \"ğŸ–•\",\n    \"mag_right\": \"ğŸ”\",\n    \"arrow_right_hook\": \"â†ª\",\n    \"sweet_potato\": \"ğŸ \",\n    \"robot\": \"ğŸ¤–\",\n    \"rolled__up_newspaper\": \"ğŸ—\",\n    \"rowboat\": \"ğŸš£\",\n    \"runner\": \"ğŸƒ\",\n    \"running\": \"ğŸƒ\",\n    \"running_shirt_with_sash\": \"ğŸ½\",\n    \"boat\": \"â›µ\",\n    \"scales\": \"âš–\",\n    \"school_satchel\": \"ğŸ’\",\n    \"scorpius\": \"â™\",\n    \"see_no_evil\": \"ğŸ™ˆ\",\n    \"sheep\": \"ğŸ‘\",\n    \"stars\": \"ğŸŒ \",\n    \"cake\": \"ğŸ°\",\n    \"six_pointed_star\": \"ğŸ”¯\",\n    \"ski\": \"ğŸ¿\",\n    \"sleeping_accommodation\": \"ğŸ›Œ\",\n    \"sleeping\": \"ğŸ˜´\",\n    \"sleepy\": \"ğŸ˜ª\",\n    \"sleuth_or_spy\": \"ğŸ•µ\",\n    \"heart_eyes_cat\": \"ğŸ˜»\",\n    \"smiley_cat\": \"ğŸ˜º\",\n    \"innocent\": \"ğŸ˜‡\",\n    \"heart_eyes\": \"ğŸ˜\",\n    \"smiling_imp\": \"ğŸ˜ˆ\",\n    \"smiley\": \"ğŸ˜ƒ\",\n    \"sweat_smile\": \"ğŸ˜…\",\n    \"smile\": \"ğŸ˜„\",\n    \"laughing\": \"ğŸ˜†\",\n    \"satisfied\": \"ğŸ˜†\",\n    \"blush\": \"ğŸ˜Š\",\n    \"smirk\": \"ğŸ˜\",\n    \"smoking\": \"ğŸš¬\",\n    \"snow_capped_mountain\": \"ğŸ”\",\n    \"soccer\": \"âš½\",\n    \"icecream\": \"ğŸ¦\",\n    \"soon\": \"ğŸ”œ\",\n    \"arrow_lower_right\": \"â†˜\",\n    \"arrow_lower_left\": \"â†™\",\n    \"speak_no_evil\": \"ğŸ™Š\",\n    \"speaker\": \"ğŸ”ˆ\",\n    \"mute\": \"ğŸ”‡\",\n    \"sound\": \"ğŸ”‰\",\n    \"loud_sound\": \"ğŸ”Š\",\n    \"speaking_head_in_silhouette\": \"ğŸ—£\",\n    \"spiral_calendar_pad\": \"ğŸ—“\",\n    \"spiral_note_pad\": \"ğŸ—’\",\n    \"shell\": \"ğŸš\",\n    \"sweat_drops\": \"ğŸ’¦\",\n    \"u5272\": \"ğŸˆ¹\",\n    \"u5408\": \"ğŸˆ´\",\n    \"u55b6\": \"ğŸˆº\",\n    \"u6307\": \"ğŸˆ¯\",\n    \"u6708\": \"ğŸˆ·\",\n    \"u6709\": \"ğŸˆ¶\",\n    \"u6e80\": \"ğŸˆµ\",\n    \"u7121\": \"ğŸˆš\",\n    \"u7533\": \"ğŸˆ¸\",\n    \"u7981\": \"ğŸˆ²\",\n    \"u7a7a\": \"ğŸˆ³\",\n    \"cl\": \"ğŸ†‘\",\n    \"cool\": \"ğŸ†’\",\n    \"free\": \"ğŸ†“\",\n    \"id\": \"ğŸ†”\",\n    \"koko\": \"ğŸˆ\",\n    \"sa\": \"ğŸˆ‚\",\n    \"new\": \"ğŸ†•\",\n    \"ng\": \"ğŸ†–\",\n    \"ok\": \"ğŸ†—\",\n    \"sos\": \"ğŸ†˜\",\n    \"up\": \"ğŸ†™\",\n    \"vs\": \"ğŸ†š\",\n    \"steam_locomotive\": \"ğŸš‚\",\n    \"ramen\": \"ğŸœ\",\n    \"partly_sunny\": \"â›…\",\n    \"city_sunrise\": \"ğŸŒ‡\",\n    \"surfer\": \"ğŸ„\",\n    \"swimmer\": \"ğŸŠ\",\n    \"shirt\": \"ğŸ‘•\",\n    \"tshirt\": \"ğŸ‘•\",\n    \"table_tennis_paddle_and_ball\": \"ğŸ“\",\n    \"tea\": \"ğŸµ\",\n    \"tv\": \"ğŸ“º\",\n    \"three_button_mouse\": \"ğŸ–±\",\n    \"+1\": \"ğŸ‘\",\n    \"thumbsup\": \"ğŸ‘\",\n    \"__1\": \"ğŸ‘\",\n    \"-1\": \"ğŸ‘\",\n    \"thumbsdown\": \"ğŸ‘\",\n    \"thunder_cloud_and_rain\": \"â›ˆ\",\n    \"tiger2\": \"ğŸ…\",\n    \"tophat\": \"ğŸ©\",\n    \"top\": \"ğŸ”\",\n    \"tm\": \"â„¢\",\n    \"train2\": \"ğŸš†\",\n    \"triangular_flag_on_post\": \"ğŸš©\",\n    \"trident\": \"ğŸ”±\",\n    \"twisted_rightwards_arrows\": \"ğŸ”€\",\n    \"unamused\": \"ğŸ˜’\",\n    \"small_red_triangle\": \"ğŸ”º\",\n    \"arrow_up_small\": \"ğŸ”¼\",\n    \"arrow_up_down\": \"â†•\",\n    \"upside__down_face\": \"ğŸ™ƒ\",\n    \"arrow_up\": \"â¬†\",\n    \"v\": \"âœŒ\",\n    \"vhs\": \"ğŸ“¼\",\n    \"wc\": \"ğŸš¾\",\n    \"ocean\": \"ğŸŒŠ\",\n    \"waving_black_flag\": \"ğŸ´\",\n    \"wave\": \"ğŸ‘‹\",\n    \"waving_white_flag\": \"ğŸ³\",\n    \"moon\": \"ğŸŒ”\",\n    \"scream_cat\": \"ğŸ™€\",\n    \"weary\": \"ğŸ˜©\",\n    \"weight_lifter\": \"ğŸ‹\",\n    \"whale2\": \"ğŸ‹\",\n    \"wheelchair\": \"â™¿\",\n    \"point_down\": \"ğŸ‘‡\",\n    \"grey_exclamation\": \"â•\",\n    \"white_frowning_face\": \"â˜¹\",\n    \"white_check_mark\": \"âœ…\",\n    \"point_left\": \"ğŸ‘ˆ\",\n    \"white_medium_small_square\": \"â—½\",\n    \"star\": \"â­\",\n    \"grey_question\": \"â”\",\n    \"point_right\": \"ğŸ‘‰\",\n    \"relaxed\": \"â˜º\",\n    \"white_sun_behind_cloud\": \"ğŸŒ¥\",\n    \"white_sun_behind_cloud_with_rain\": \"ğŸŒ¦\",\n    \"white_sun_with_small_cloud\": \"ğŸŒ¤\",\n    \"point_up_2\": \"ğŸ‘†\",\n    \"point_up\": \"â˜\",\n    \"wind_blowing_face\": \"ğŸŒ¬\",\n    \"wink\": \"ğŸ˜‰\",\n    \"wolf\": \"ğŸº\",\n    \"dancers\": \"ğŸ‘¯\",\n    \"boot\": \"ğŸ‘¢\",\n    \"womans_clothes\": \"ğŸ‘š\",\n    \"womans_hat\": \"ğŸ‘’\",\n    \"sandal\": \"ğŸ‘¡\",\n    \"womens\": \"ğŸšº\",\n    \"worried\": \"ğŸ˜Ÿ\",\n    \"gift\": \"ğŸ\",\n    \"zipper__mouth_face\": \"ğŸ¤\",\n    \"regional_indicator_a\": \"ğŸ‡¦\",\n    \"regional_indicator_b\": \"ğŸ‡§\",\n    \"regional_indicator_c\": \"ğŸ‡¨\",\n    \"regional_indicator_d\": \"ğŸ‡©\",\n    \"regional_indicator_e\": \"ğŸ‡ª\",\n    \"regional_indicator_f\": \"ğŸ‡«\",\n    \"regional_indicator_g\": \"ğŸ‡¬\",\n    \"regional_indicator_h\": \"ğŸ‡­\",\n    \"regional_indicator_i\": \"ğŸ‡®\",\n    \"regional_indicator_j\": \"ğŸ‡¯\",\n    \"regional_indicator_k\": \"ğŸ‡°\",\n    \"regional_indicator_l\": \"ğŸ‡±\",\n    \"regional_indicator_m\": \"ğŸ‡²\",\n    \"regional_indicator_n\": \"ğŸ‡³\",\n    \"regional_indicator_o\": \"ğŸ‡´\",\n    \"regional_indicator_p\": \"ğŸ‡µ\",\n    \"regional_indicator_q\": \"ğŸ‡¶\",\n    \"regional_indicator_r\": \"ğŸ‡·\",\n    \"regional_indicator_s\": \"ğŸ‡¸\",\n    \"regional_indicator_t\": \"ğŸ‡¹\",\n    \"regional_indicator_u\": \"ğŸ‡º\",\n    \"regional_indicator_v\": \"ğŸ‡»\",\n    \"regional_indicator_w\": \"ğŸ‡¼\",\n    \"regional_indicator_x\": \"ğŸ‡½\",\n    \"regional_indicator_y\": \"ğŸ‡¾\",\n    \"regional_indicator_z\": \"ğŸ‡¿\",\n}\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/_emoji_replace.py","size":1064,"sha1":"24b63b5fc802a433906688c21ce9106dad90c1d3","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import Callable, Match, Optional\nimport re\n\nfrom ._emoji_codes import EMOJI\n\n\n_ReStringMatch = Match[str]  # regex match object\n_ReSubCallable = Callable[[_ReStringMatch], str]  # Callable invoked by re.sub\n_EmojiSubMethod = Callable[[_ReSubCallable, str], str]  # Sub method of a compiled re\n\n\ndef _emoji_replace(\n    text: str,\n    default_variant: Optional[str] = None,\n    _emoji_sub: _EmojiSubMethod = re.compile(r\"(:(\\S*?)(?:(?:\\-)(emoji|text))?:)\").sub,\n) -> str:\n    \"\"\"Replace emoji code in text.\"\"\"\n    get_emoji = EMOJI.__getitem__\n    variants = {\"text\": \"\\uFE0E\", \"emoji\": \"\\uFE0F\"}\n    get_variant = variants.get\n    default_variant_code = variants.get(default_variant, \"\") if default_variant else \"\"\n\n    def do_replace(match: Match[str]) -> str:\n        emoji_code, emoji_name, variant = match.groups()\n        try:\n            return get_emoji(emoji_name.lower()) + get_variant(\n                variant, default_variant_code\n            )\n        except KeyError:\n            return emoji_code\n\n    return _emoji_sub(do_replace, text)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/_export_format.py","size":2128,"sha1":"a2785fa046dd008fbdeb43efa9271ef55acab28f","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"CONSOLE_HTML_FORMAT = \"\"\"\\\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<style>\n{stylesheet}\nbody {{\n    color: {foreground};\n    background-color: {background};\n}}\n</style>\n</head>\n<body>\n    <pre style=\"font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace\"><code style=\"font-family:inherit\">{code}</code></pre>\n</body>\n</html>\n\"\"\"\n\nCONSOLE_SVG_FORMAT = \"\"\"\\\n<svg class=\"rich-terminal\" viewBox=\"0 0 {width} {height}\" xmlns=\"http://www.w3.org/2000/svg\">\n    <!-- Generated with Rich https://www.textualize.io -->\n    <style>\n\n    @font-face {{\n        font-family: \"Fira Code\";\n        src: local(\"FiraCode-Regular\"),\n                url(\"https://cdnjs.cloudflare.com/ajax/libs/firacode/6.2.0/woff2/FiraCode-Regular.woff2\") format(\"woff2\"),\n                url(\"https://cdnjs.cloudflare.com/ajax/libs/firacode/6.2.0/woff/FiraCode-Regular.woff\") format(\"woff\");\n        font-style: normal;\n        font-weight: 400;\n    }}\n    @font-face {{\n        font-family: \"Fira Code\";\n        src: local(\"FiraCode-Bold\"),\n                url(\"https://cdnjs.cloudflare.com/ajax/libs/firacode/6.2.0/woff2/FiraCode-Bold.woff2\") format(\"woff2\"),\n                url(\"https://cdnjs.cloudflare.com/ajax/libs/firacode/6.2.0/woff/FiraCode-Bold.woff\") format(\"woff\");\n        font-style: bold;\n        font-weight: 700;\n    }}\n\n    .{unique_id}-matrix {{\n        font-family: Fira Code, monospace;\n        font-size: {char_height}px;\n        line-height: {line_height}px;\n        font-variant-east-asian: full-width;\n    }}\n\n    .{unique_id}-title {{\n        font-size: 18px;\n        font-weight: bold;\n        font-family: arial;\n    }}\n\n    {styles}\n    </style>\n\n    <defs>\n    <clipPath id=\"{unique_id}-clip-terminal\">\n      <rect x=\"0\" y=\"0\" width=\"{terminal_width}\" height=\"{terminal_height}\" />\n    </clipPath>\n    {lines}\n    </defs>\n\n    {chrome}\n    <g transform=\"translate({terminal_x}, {terminal_y})\" clip-path=\"url(#{unique_id}-clip-terminal)\">\n    {backgrounds}\n    <g class=\"{unique_id}-matrix\">\n    {matrix}\n    </g>\n    </g>\n</svg>\n\"\"\"\n\n_SVG_FONT_FAMILY = \"Rich Fira Code\"\n_SVG_CLASSES_PREFIX = \"rich-svg\"\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/_extension.py","size":265,"sha1":"5b52136df195dda4a08659e1a0376c38d87c2c80","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import Any\n\n\ndef load_ipython_extension(ip: Any) -> None:  # pragma: no cover\n    # prevent circular import\n    from pip._vendor.rich.pretty import install\n    from pip._vendor.rich.traceback import install as tr_install\n\n    install()\n    tr_install()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/_fileno.py","size":799,"sha1":"5519860d4817d286db77fd7cce5c3876b6a9adfa","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nfrom typing import IO, Callable\n\n\ndef get_fileno(file_like: IO[str]) -> int | None:\n    \"\"\"Get fileno() from a file, accounting for poorly implemented file-like objects.\n\n    Args:\n        file_like (IO): A file-like object.\n\n    Returns:\n        int | None: The result of fileno if available, or None if operation failed.\n    \"\"\"\n    fileno: Callable[[], int] | None = getattr(file_like, \"fileno\", None)\n    if fileno is not None:\n        try:\n            return fileno()\n        except Exception:\n            # `fileno` is documented as potentially raising a OSError\n            # Alas, from the issues, there are so many poorly implemented file-like objects,\n            # that `fileno()` can raise just about anything.\n            return None\n    return None\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/_inspect.py","size":9655,"sha1":"74ef73cc4c7137814461c921ea9a05ef0d26ad65","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import inspect\nfrom inspect import cleandoc, getdoc, getfile, isclass, ismodule, signature\nfrom typing import Any, Collection, Iterable, Optional, Tuple, Type, Union\n\nfrom .console import Group, RenderableType\nfrom .control import escape_control_codes\nfrom .highlighter import ReprHighlighter\nfrom .jupyter import JupyterMixin\nfrom .panel import Panel\nfrom .pretty import Pretty\nfrom .table import Table\nfrom .text import Text, TextType\n\n\ndef _first_paragraph(doc: str) -> str:\n    \"\"\"Get the first paragraph from a docstring.\"\"\"\n    paragraph, _, _ = doc.partition(\"\\n\\n\")\n    return paragraph\n\n\nclass Inspect(JupyterMixin):\n    \"\"\"A renderable to inspect any Python Object.\n\n    Args:\n        obj (Any): An object to inspect.\n        title (str, optional): Title to display over inspect result, or None use type. Defaults to None.\n        help (bool, optional): Show full help text rather than just first paragraph. Defaults to False.\n        methods (bool, optional): Enable inspection of callables. Defaults to False.\n        docs (bool, optional): Also render doc strings. Defaults to True.\n        private (bool, optional): Show private attributes (beginning with underscore). Defaults to False.\n        dunder (bool, optional): Show attributes starting with double underscore. Defaults to False.\n        sort (bool, optional): Sort attributes alphabetically. Defaults to True.\n        all (bool, optional): Show all attributes. Defaults to False.\n        value (bool, optional): Pretty print value of object. Defaults to True.\n    \"\"\"\n\n    def __init__(\n        self,\n        obj: Any,\n        *,\n        title: Optional[TextType] = None,\n        help: bool = False,\n        methods: bool = False,\n        docs: bool = True,\n        private: bool = False,\n        dunder: bool = False,\n        sort: bool = True,\n        all: bool = True,\n        value: bool = True,\n    ) -> None:\n        self.highlighter = ReprHighlighter()\n        self.obj = obj\n        self.title = title or self._make_title(obj)\n        if all:\n            methods = private = dunder = True\n        self.help = help\n        self.methods = methods\n        self.docs = docs or help\n        self.private = private or dunder\n        self.dunder = dunder\n        self.sort = sort\n        self.value = value\n\n    def _make_title(self, obj: Any) -> Text:\n        \"\"\"Make a default title.\"\"\"\n        title_str = (\n            str(obj)\n            if (isclass(obj) or callable(obj) or ismodule(obj))\n            else str(type(obj))\n        )\n        title_text = self.highlighter(title_str)\n        return title_text\n\n    def __rich__(self) -> Panel:\n        return Panel.fit(\n            Group(*self._render()),\n            title=self.title,\n            border_style=\"scope.border\",\n            padding=(0, 1),\n        )\n\n    def _get_signature(self, name: str, obj: Any) -> Optional[Text]:\n        \"\"\"Get a signature for a callable.\"\"\"\n        try:\n            _signature = str(signature(obj)) + \":\"\n        except ValueError:\n            _signature = \"(...)\"\n        except TypeError:\n            return None\n\n        source_filename: Optional[str] = None\n        try:\n            source_filename = getfile(obj)\n        except (OSError, TypeError):\n            # OSError is raised if obj has no source file, e.g. when defined in REPL.\n            pass\n\n        callable_name = Text(name, style=\"inspect.callable\")\n        if source_filename:\n            callable_name.stylize(f\"link file://{source_filename}\")\n        signature_text = self.highlighter(_signature)\n\n        qualname = name or getattr(obj, \"__qualname__\", name)\n\n        # If obj is a module, there may be classes (which are callable) to display\n        if inspect.isclass(obj):\n            prefix = \"class\"\n        elif inspect.iscoroutinefunction(obj):\n            prefix = \"async def\"\n        else:\n            prefix = \"def\"\n\n        qual_signature = Text.assemble(\n            (f\"{prefix} \", f\"inspect.{prefix.replace(' ', '_')}\"),\n            (qualname, \"inspect.callable\"),\n            signature_text,\n        )\n\n        return qual_signature\n\n    def _render(self) -> Iterable[RenderableType]:\n        \"\"\"Render object.\"\"\"\n\n        def sort_items(item: Tuple[str, Any]) -> Tuple[bool, str]:\n            key, (_error, value) = item\n            return (callable(value), key.strip(\"_\").lower())\n\n        def safe_getattr(attr_name: str) -> Tuple[Any, Any]:\n            \"\"\"Get attribute or any exception.\"\"\"\n            try:\n                return (None, getattr(obj, attr_name))\n            except Exception as error:\n                return (error, None)\n\n        obj = self.obj\n        keys = dir(obj)\n        total_items = len(keys)\n        if not self.dunder:\n            keys = [key for key in keys if not key.startswith(\"__\")]\n        if not self.private:\n            keys = [key for key in keys if not key.startswith(\"_\")]\n        not_shown_count = total_items - len(keys)\n        items = [(key, safe_getattr(key)) for key in keys]\n        if self.sort:\n            items.sort(key=sort_items)\n\n        items_table = Table.grid(padding=(0, 1), expand=False)\n        items_table.add_column(justify=\"right\")\n        add_row = items_table.add_row\n        highlighter = self.highlighter\n\n        if callable(obj):\n            signature = self._get_signature(\"\", obj)\n            if signature is not None:\n                yield signature\n                yield \"\"\n\n        if self.docs:\n            _doc = self._get_formatted_doc(obj)\n            if _doc is not None:\n                doc_text = Text(_doc, style=\"inspect.help\")\n                doc_text = highlighter(doc_text)\n                yield doc_text\n                yield \"\"\n\n        if self.value and not (isclass(obj) or callable(obj) or ismodule(obj)):\n            yield Panel(\n                Pretty(obj, indent_guides=True, max_length=10, max_string=60),\n                border_style=\"inspect.value.border\",\n            )\n            yield \"\"\n\n        for key, (error, value) in items:\n            key_text = Text.assemble(\n                (\n                    key,\n                    \"inspect.attr.dunder\" if key.startswith(\"__\") else \"inspect.attr\",\n                ),\n                (\" =\", \"inspect.equals\"),\n            )\n            if error is not None:\n                warning = key_text.copy()\n                warning.stylize(\"inspect.error\")\n                add_row(warning, highlighter(repr(error)))\n                continue\n\n            if callable(value):\n                if not self.methods:\n                    continue\n\n                _signature_text = self._get_signature(key, value)\n                if _signature_text is None:\n                    add_row(key_text, Pretty(value, highlighter=highlighter))\n                else:\n                    if self.docs:\n                        docs = self._get_formatted_doc(value)\n                        if docs is not None:\n                            _signature_text.append(\"\\n\" if \"\\n\" in docs else \" \")\n                            doc = highlighter(docs)\n                            doc.stylize(\"inspect.doc\")\n                            _signature_text.append(doc)\n\n                    add_row(key_text, _signature_text)\n            else:\n                add_row(key_text, Pretty(value, highlighter=highlighter))\n        if items_table.row_count:\n            yield items_table\n        elif not_shown_count:\n            yield Text.from_markup(\n                f\"[b cyan]{not_shown_count}[/][i] attribute(s) not shown.[/i] \"\n                f\"Run [b][magenta]inspect[/]([not b]inspect[/])[/b] for options.\"\n            )\n\n    def _get_formatted_doc(self, object_: Any) -> Optional[str]:\n        \"\"\"\n        Extract the docstring of an object, process it and returns it.\n        The processing consists in cleaning up the doctring's indentation,\n        taking only its 1st paragraph if `self.help` is not True,\n        and escape its control codes.\n\n        Args:\n            object_ (Any): the object to get the docstring from.\n\n        Returns:\n            Optional[str]: the processed docstring, or None if no docstring was found.\n        \"\"\"\n        docs = getdoc(object_)\n        if docs is None:\n            return None\n        docs = cleandoc(docs).strip()\n        if not self.help:\n            docs = _first_paragraph(docs)\n        return escape_control_codes(docs)\n\n\ndef get_object_types_mro(obj: Union[object, Type[Any]]) -> Tuple[type, ...]:\n    \"\"\"Returns the MRO of an object's class, or of the object itself if it's a class.\"\"\"\n    if not hasattr(obj, \"__mro__\"):\n        # N.B. we cannot use `if type(obj) is type` here because it doesn't work with\n        # some types of classes, such as the ones that use abc.ABCMeta.\n        obj = type(obj)\n    return getattr(obj, \"__mro__\", ())\n\n\ndef get_object_types_mro_as_strings(obj: object) -> Collection[str]:\n    \"\"\"\n    Returns the MRO of an object's class as full qualified names, or of the object itself if it's a class.\n\n    Examples:\n        `object_types_mro_as_strings(JSONDecoder)` will return `['json.decoder.JSONDecoder', 'builtins.object']`\n    \"\"\"\n    return [\n        f'{getattr(type_, \"__module__\", \"\")}.{getattr(type_, \"__qualname__\", \"\")}'\n        for type_ in get_object_types_mro(obj)\n    ]\n\n\ndef is_object_one_of_types(\n    obj: object, fully_qualified_types_names: Collection[str]\n) -> bool:\n    \"\"\"\n    Returns `True` if the given object's class (or the object itself, if it's a class) has one of the\n    fully qualified names in its MRO.\n    \"\"\"\n    for type_name in get_object_types_mro_as_strings(obj):\n        if type_name in fully_qualified_types_names:\n            return True\n    return False\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/_log_render.py","size":3225,"sha1":"e28c1f61c554f4dd34c210ea89f8b5031aff874d","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from datetime import datetime\nfrom typing import Iterable, List, Optional, TYPE_CHECKING, Union, Callable\n\n\nfrom .text import Text, TextType\n\nif TYPE_CHECKING:\n    from .console import Console, ConsoleRenderable, RenderableType\n    from .table import Table\n\nFormatTimeCallable = Callable[[datetime], Text]\n\n\nclass LogRender:\n    def __init__(\n        self,\n        show_time: bool = True,\n        show_level: bool = False,\n        show_path: bool = True,\n        time_format: Union[str, FormatTimeCallable] = \"[%x %X]\",\n        omit_repeated_times: bool = True,\n        level_width: Optional[int] = 8,\n    ) -> None:\n        self.show_time = show_time\n        self.show_level = show_level\n        self.show_path = show_path\n        self.time_format = time_format\n        self.omit_repeated_times = omit_repeated_times\n        self.level_width = level_width\n        self._last_time: Optional[Text] = None\n\n    def __call__(\n        self,\n        console: \"Console\",\n        renderables: Iterable[\"ConsoleRenderable\"],\n        log_time: Optional[datetime] = None,\n        time_format: Optional[Union[str, FormatTimeCallable]] = None,\n        level: TextType = \"\",\n        path: Optional[str] = None,\n        line_no: Optional[int] = None,\n        link_path: Optional[str] = None,\n    ) -> \"Table\":\n        from .containers import Renderables\n        from .table import Table\n\n        output = Table.grid(padding=(0, 1))\n        output.expand = True\n        if self.show_time:\n            output.add_column(style=\"log.time\")\n        if self.show_level:\n            output.add_column(style=\"log.level\", width=self.level_width)\n        output.add_column(ratio=1, style=\"log.message\", overflow=\"fold\")\n        if self.show_path and path:\n            output.add_column(style=\"log.path\")\n        row: List[\"RenderableType\"] = []\n        if self.show_time:\n            log_time = log_time or console.get_datetime()\n            time_format = time_format or self.time_format\n            if callable(time_format):\n                log_time_display = time_format(log_time)\n            else:\n                log_time_display = Text(log_time.strftime(time_format))\n            if log_time_display == self._last_time and self.omit_repeated_times:\n                row.append(Text(\" \" * len(log_time_display)))\n            else:\n                row.append(log_time_display)\n                self._last_time = log_time_display\n        if self.show_level:\n            row.append(level)\n\n        row.append(Renderables(renderables))\n        if self.show_path and path:\n            path_text = Text()\n            path_text.append(\n                path, style=f\"link file://{link_path}\" if link_path else \"\"\n            )\n            if line_no:\n                path_text.append(\":\")\n                path_text.append(\n                    f\"{line_no}\",\n                    style=f\"link file://{link_path}#{line_no}\" if link_path else \"\",\n                )\n            row.append(path_text)\n\n        output.add_row(*row)\n        return output\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from pip._vendor.rich.console import Console\n\n    c = Console()\n    c.print(\"[on blue]Hello\", justify=\"right\")\n    c.log(\"[on blue]hello\", justify=\"right\")\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/_loop.py","size":1236,"sha1":"64c1a76eb2413ded8096b98a419088ff40136da9","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import Iterable, Tuple, TypeVar\n\nT = TypeVar(\"T\")\n\n\ndef loop_first(values: Iterable[T]) -> Iterable[Tuple[bool, T]]:\n    \"\"\"Iterate and generate a tuple with a flag for first value.\"\"\"\n    iter_values = iter(values)\n    try:\n        value = next(iter_values)\n    except StopIteration:\n        return\n    yield True, value\n    for value in iter_values:\n        yield False, value\n\n\ndef loop_last(values: Iterable[T]) -> Iterable[Tuple[bool, T]]:\n    \"\"\"Iterate and generate a tuple with a flag for last value.\"\"\"\n    iter_values = iter(values)\n    try:\n        previous_value = next(iter_values)\n    except StopIteration:\n        return\n    for value in iter_values:\n        yield False, previous_value\n        previous_value = value\n    yield True, previous_value\n\n\ndef loop_first_last(values: Iterable[T]) -> Iterable[Tuple[bool, bool, T]]:\n    \"\"\"Iterate and generate a tuple with a flag for first and last value.\"\"\"\n    iter_values = iter(values)\n    try:\n        previous_value = next(iter_values)\n    except StopIteration:\n        return\n    first = True\n    for value in iter_values:\n        yield first, False, previous_value\n        first = False\n        previous_value = value\n    yield first, True, previous_value\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/_null_file.py","size":1394,"sha1":"1a51c14370129ae10d2cc1b3b0fe3038f7e30d7b","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from types import TracebackType\nfrom typing import IO, Iterable, Iterator, List, Optional, Type\n\n\nclass NullFile(IO[str]):\n    def close(self) -> None:\n        pass\n\n    def isatty(self) -> bool:\n        return False\n\n    def read(self, __n: int = 1) -> str:\n        return \"\"\n\n    def readable(self) -> bool:\n        return False\n\n    def readline(self, __limit: int = 1) -> str:\n        return \"\"\n\n    def readlines(self, __hint: int = 1) -> List[str]:\n        return []\n\n    def seek(self, __offset: int, __whence: int = 1) -> int:\n        return 0\n\n    def seekable(self) -> bool:\n        return False\n\n    def tell(self) -> int:\n        return 0\n\n    def truncate(self, __size: Optional[int] = 1) -> int:\n        return 0\n\n    def writable(self) -> bool:\n        return False\n\n    def writelines(self, __lines: Iterable[str]) -> None:\n        pass\n\n    def __next__(self) -> str:\n        return \"\"\n\n    def __iter__(self) -> Iterator[str]:\n        return iter([\"\"])\n\n    def __enter__(self) -> IO[str]:\n        return self\n\n    def __exit__(\n        self,\n        __t: Optional[Type[BaseException]],\n        __value: Optional[BaseException],\n        __traceback: Optional[TracebackType],\n    ) -> None:\n        pass\n\n    def write(self, text: str) -> int:\n        return 0\n\n    def flush(self) -> None:\n        pass\n\n    def fileno(self) -> int:\n        return -1\n\n\nNULL_FILE = NullFile()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/_palettes.py","size":7063,"sha1":"ee198b57907e766da93c0096481f639f84b8fe04","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from .palette import Palette\n\n\n# Taken from https://en.wikipedia.org/wiki/ANSI_escape_code (Windows 10 column)\nWINDOWS_PALETTE = Palette(\n    [\n        (12, 12, 12),\n        (197, 15, 31),\n        (19, 161, 14),\n        (193, 156, 0),\n        (0, 55, 218),\n        (136, 23, 152),\n        (58, 150, 221),\n        (204, 204, 204),\n        (118, 118, 118),\n        (231, 72, 86),\n        (22, 198, 12),\n        (249, 241, 165),\n        (59, 120, 255),\n        (180, 0, 158),\n        (97, 214, 214),\n        (242, 242, 242),\n    ]\n)\n\n# # The standard ansi colors (including bright variants)\nSTANDARD_PALETTE = Palette(\n    [\n        (0, 0, 0),\n        (170, 0, 0),\n        (0, 170, 0),\n        (170, 85, 0),\n        (0, 0, 170),\n        (170, 0, 170),\n        (0, 170, 170),\n        (170, 170, 170),\n        (85, 85, 85),\n        (255, 85, 85),\n        (85, 255, 85),\n        (255, 255, 85),\n        (85, 85, 255),\n        (255, 85, 255),\n        (85, 255, 255),\n        (255, 255, 255),\n    ]\n)\n\n\n# The 256 color palette\nEIGHT_BIT_PALETTE = Palette(\n    [\n        (0, 0, 0),\n        (128, 0, 0),\n        (0, 128, 0),\n        (128, 128, 0),\n        (0, 0, 128),\n        (128, 0, 128),\n        (0, 128, 128),\n        (192, 192, 192),\n        (128, 128, 128),\n        (255, 0, 0),\n        (0, 255, 0),\n        (255, 255, 0),\n        (0, 0, 255),\n        (255, 0, 255),\n        (0, 255, 255),\n        (255, 255, 255),\n        (0, 0, 0),\n        (0, 0, 95),\n        (0, 0, 135),\n        (0, 0, 175),\n        (0, 0, 215),\n        (0, 0, 255),\n        (0, 95, 0),\n        (0, 95, 95),\n        (0, 95, 135),\n        (0, 95, 175),\n        (0, 95, 215),\n        (0, 95, 255),\n        (0, 135, 0),\n        (0, 135, 95),\n        (0, 135, 135),\n        (0, 135, 175),\n        (0, 135, 215),\n        (0, 135, 255),\n        (0, 175, 0),\n        (0, 175, 95),\n        (0, 175, 135),\n        (0, 175, 175),\n        (0, 175, 215),\n        (0, 175, 255),\n        (0, 215, 0),\n        (0, 215, 95),\n        (0, 215, 135),\n        (0, 215, 175),\n        (0, 215, 215),\n        (0, 215, 255),\n        (0, 255, 0),\n        (0, 255, 95),\n        (0, 255, 135),\n        (0, 255, 175),\n        (0, 255, 215),\n        (0, 255, 255),\n        (95, 0, 0),\n        (95, 0, 95),\n        (95, 0, 135),\n        (95, 0, 175),\n        (95, 0, 215),\n        (95, 0, 255),\n        (95, 95, 0),\n        (95, 95, 95),\n        (95, 95, 135),\n        (95, 95, 175),\n        (95, 95, 215),\n        (95, 95, 255),\n        (95, 135, 0),\n        (95, 135, 95),\n        (95, 135, 135),\n        (95, 135, 175),\n        (95, 135, 215),\n        (95, 135, 255),\n        (95, 175, 0),\n        (95, 175, 95),\n        (95, 175, 135),\n        (95, 175, 175),\n        (95, 175, 215),\n        (95, 175, 255),\n        (95, 215, 0),\n        (95, 215, 95),\n        (95, 215, 135),\n        (95, 215, 175),\n        (95, 215, 215),\n        (95, 215, 255),\n        (95, 255, 0),\n        (95, 255, 95),\n        (95, 255, 135),\n        (95, 255, 175),\n        (95, 255, 215),\n        (95, 255, 255),\n        (135, 0, 0),\n        (135, 0, 95),\n        (135, 0, 135),\n        (135, 0, 175),\n        (135, 0, 215),\n        (135, 0, 255),\n        (135, 95, 0),\n        (135, 95, 95),\n        (135, 95, 135),\n        (135, 95, 175),\n        (135, 95, 215),\n        (135, 95, 255),\n        (135, 135, 0),\n        (135, 135, 95),\n        (135, 135, 135),\n        (135, 135, 175),\n        (135, 135, 215),\n        (135, 135, 255),\n        (135, 175, 0),\n        (135, 175, 95),\n        (135, 175, 135),\n        (135, 175, 175),\n        (135, 175, 215),\n        (135, 175, 255),\n        (135, 215, 0),\n        (135, 215, 95),\n        (135, 215, 135),\n        (135, 215, 175),\n        (135, 215, 215),\n        (135, 215, 255),\n        (135, 255, 0),\n        (135, 255, 95),\n        (135, 255, 135),\n        (135, 255, 175),\n        (135, 255, 215),\n        (135, 255, 255),\n        (175, 0, 0),\n        (175, 0, 95),\n        (175, 0, 135),\n        (175, 0, 175),\n        (175, 0, 215),\n        (175, 0, 255),\n        (175, 95, 0),\n        (175, 95, 95),\n        (175, 95, 135),\n        (175, 95, 175),\n        (175, 95, 215),\n        (175, 95, 255),\n        (175, 135, 0),\n        (175, 135, 95),\n        (175, 135, 135),\n        (175, 135, 175),\n        (175, 135, 215),\n        (175, 135, 255),\n        (175, 175, 0),\n        (175, 175, 95),\n        (175, 175, 135),\n        (175, 175, 175),\n        (175, 175, 215),\n        (175, 175, 255),\n        (175, 215, 0),\n        (175, 215, 95),\n        (175, 215, 135),\n        (175, 215, 175),\n        (175, 215, 215),\n        (175, 215, 255),\n        (175, 255, 0),\n        (175, 255, 95),\n        (175, 255, 135),\n        (175, 255, 175),\n        (175, 255, 215),\n        (175, 255, 255),\n        (215, 0, 0),\n        (215, 0, 95),\n        (215, 0, 135),\n        (215, 0, 175),\n        (215, 0, 215),\n        (215, 0, 255),\n        (215, 95, 0),\n        (215, 95, 95),\n        (215, 95, 135),\n        (215, 95, 175),\n        (215, 95, 215),\n        (215, 95, 255),\n        (215, 135, 0),\n        (215, 135, 95),\n        (215, 135, 135),\n        (215, 135, 175),\n        (215, 135, 215),\n        (215, 135, 255),\n        (215, 175, 0),\n        (215, 175, 95),\n        (215, 175, 135),\n        (215, 175, 175),\n        (215, 175, 215),\n        (215, 175, 255),\n        (215, 215, 0),\n        (215, 215, 95),\n        (215, 215, 135),\n        (215, 215, 175),\n        (215, 215, 215),\n        (215, 215, 255),\n        (215, 255, 0),\n        (215, 255, 95),\n        (215, 255, 135),\n        (215, 255, 175),\n        (215, 255, 215),\n        (215, 255, 255),\n        (255, 0, 0),\n        (255, 0, 95),\n        (255, 0, 135),\n        (255, 0, 175),\n        (255, 0, 215),\n        (255, 0, 255),\n        (255, 95, 0),\n        (255, 95, 95),\n        (255, 95, 135),\n        (255, 95, 175),\n        (255, 95, 215),\n        (255, 95, 255),\n        (255, 135, 0),\n        (255, 135, 95),\n        (255, 135, 135),\n        (255, 135, 175),\n        (255, 135, 215),\n        (255, 135, 255),\n        (255, 175, 0),\n        (255, 175, 95),\n        (255, 175, 135),\n        (255, 175, 175),\n        (255, 175, 215),\n        (255, 175, 255),\n        (255, 215, 0),\n        (255, 215, 95),\n        (255, 215, 135),\n        (255, 215, 175),\n        (255, 215, 215),\n        (255, 215, 255),\n        (255, 255, 0),\n        (255, 255, 95),\n        (255, 255, 135),\n        (255, 255, 175),\n        (255, 255, 215),\n        (255, 255, 255),\n        (8, 8, 8),\n        (18, 18, 18),\n        (28, 28, 28),\n        (38, 38, 38),\n        (48, 48, 48),\n        (58, 58, 58),\n        (68, 68, 68),\n        (78, 78, 78),\n        (88, 88, 88),\n        (98, 98, 98),\n        (108, 108, 108),\n        (118, 118, 118),\n        (128, 128, 128),\n        (138, 138, 138),\n        (148, 148, 148),\n        (158, 158, 158),\n        (168, 168, 168),\n        (178, 178, 178),\n        (188, 188, 188),\n        (198, 198, 198),\n        (208, 208, 208),\n        (218, 218, 218),\n        (228, 228, 228),\n        (238, 238, 238),\n    ]\n)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/_pick.py","size":423,"sha1":"72a297844fdb3fc6556944ce2e9799a93423b522","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import Optional\n\n\ndef pick_bool(*values: Optional[bool]) -> bool:\n    \"\"\"Pick the first non-none bool or return the last value.\n\n    Args:\n        *values (bool): Any number of boolean or None values.\n\n    Returns:\n        bool: First non-none boolean.\n    \"\"\"\n    assert values, \"1 or more values required\"\n    for value in values:\n        if value is not None:\n            return value\n    return bool(value)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/_ratio.py","size":5471,"sha1":"ecc088bfe541b6e2cb45f1106043ed06e667fac6","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\nfrom fractions import Fraction\nfrom math import ceil\nfrom typing import cast, List, Optional, Sequence\n\nif sys.version_info >= (3, 8):\n    from typing import Protocol\nelse:\n    from pip._vendor.typing_extensions import Protocol  # pragma: no cover\n\n\nclass Edge(Protocol):\n    \"\"\"Any object that defines an edge (such as Layout).\"\"\"\n\n    size: Optional[int] = None\n    ratio: int = 1\n    minimum_size: int = 1\n\n\ndef ratio_resolve(total: int, edges: Sequence[Edge]) -> List[int]:\n    \"\"\"Divide total space to satisfy size, ratio, and minimum_size, constraints.\n\n    The returned list of integers should add up to total in most cases, unless it is\n    impossible to satisfy all the constraints. For instance, if there are two edges\n    with a minimum size of 20 each and `total` is 30 then the returned list will be\n    greater than total. In practice, this would mean that a Layout object would\n    clip the rows that would overflow the screen height.\n\n    Args:\n        total (int): Total number of characters.\n        edges (List[Edge]): Edges within total space.\n\n    Returns:\n        List[int]: Number of characters for each edge.\n    \"\"\"\n    # Size of edge or None for yet to be determined\n    sizes = [(edge.size or None) for edge in edges]\n\n    _Fraction = Fraction\n\n    # While any edges haven't been calculated\n    while None in sizes:\n        # Get flexible edges and index to map these back on to sizes list\n        flexible_edges = [\n            (index, edge)\n            for index, (size, edge) in enumerate(zip(sizes, edges))\n            if size is None\n        ]\n        # Remaining space in total\n        remaining = total - sum(size or 0 for size in sizes)\n        if remaining <= 0:\n            # No room for flexible edges\n            return [\n                ((edge.minimum_size or 1) if size is None else size)\n                for size, edge in zip(sizes, edges)\n            ]\n        # Calculate number of characters in a ratio portion\n        portion = _Fraction(\n            remaining, sum((edge.ratio or 1) for _, edge in flexible_edges)\n        )\n\n        # If any edges will be less than their minimum, replace size with the minimum\n        for index, edge in flexible_edges:\n            if portion * edge.ratio <= edge.minimum_size:\n                sizes[index] = edge.minimum_size\n                # New fixed size will invalidate calculations, so we need to repeat the process\n                break\n        else:\n            # Distribute flexible space and compensate for rounding error\n            # Since edge sizes can only be integers we need to add the remainder\n            # to the following line\n            remainder = _Fraction(0)\n            for index, edge in flexible_edges:\n                size, remainder = divmod(portion * edge.ratio + remainder, 1)\n                sizes[index] = size\n            break\n    # Sizes now contains integers only\n    return cast(List[int], sizes)\n\n\ndef ratio_reduce(\n    total: int, ratios: List[int], maximums: List[int], values: List[int]\n) -> List[int]:\n    \"\"\"Divide an integer total in to parts based on ratios.\n\n    Args:\n        total (int): The total to divide.\n        ratios (List[int]): A list of integer ratios.\n        maximums (List[int]): List of maximums values for each slot.\n        values (List[int]): List of values\n\n    Returns:\n        List[int]: A list of integers guaranteed to sum to total.\n    \"\"\"\n    ratios = [ratio if _max else 0 for ratio, _max in zip(ratios, maximums)]\n    total_ratio = sum(ratios)\n    if not total_ratio:\n        return values[:]\n    total_remaining = total\n    result: List[int] = []\n    append = result.append\n    for ratio, maximum, value in zip(ratios, maximums, values):\n        if ratio and total_ratio > 0:\n            distributed = min(maximum, round(ratio * total_remaining / total_ratio))\n            append(value - distributed)\n            total_remaining -= distributed\n            total_ratio -= ratio\n        else:\n            append(value)\n    return result\n\n\ndef ratio_distribute(\n    total: int, ratios: List[int], minimums: Optional[List[int]] = None\n) -> List[int]:\n    \"\"\"Distribute an integer total in to parts based on ratios.\n\n    Args:\n        total (int): The total to divide.\n        ratios (List[int]): A list of integer ratios.\n        minimums (List[int]): List of minimum values for each slot.\n\n    Returns:\n        List[int]: A list of integers guaranteed to sum to total.\n    \"\"\"\n    if minimums:\n        ratios = [ratio if _min else 0 for ratio, _min in zip(ratios, minimums)]\n    total_ratio = sum(ratios)\n    assert total_ratio > 0, \"Sum of ratios must be > 0\"\n\n    total_remaining = total\n    distributed_total: List[int] = []\n    append = distributed_total.append\n    if minimums is None:\n        _minimums = [0] * len(ratios)\n    else:\n        _minimums = minimums\n    for ratio, minimum in zip(ratios, _minimums):\n        if total_ratio > 0:\n            distributed = max(minimum, ceil(ratio * total_remaining / total_ratio))\n        else:\n            distributed = total_remaining\n        append(distributed)\n        total_ratio -= ratio\n        total_remaining -= distributed\n    return distributed_total\n\n\nif __name__ == \"__main__\":\n    from dataclasses import dataclass\n\n    @dataclass\n    class E:\n        size: Optional[int] = None\n        ratio: int = 1\n        minimum_size: int = 1\n\n    resolved = ratio_resolve(110, [E(None, 1, 1), E(None, 1, 1), E(None, 1, 1)])\n    print(sum(resolved))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/_spinners.py","size":19919,"sha1":"7dc392ff666a492c8348338fbd08f412f81d6f34","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nSpinners are from:\n* cli-spinners:\n    MIT License\n    Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights to\n    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n    the Software, and to permit persons to whom the Software is furnished to do so,\n    subject to the following conditions:\n    The above copyright notice and this permission notice shall be included\n    in all copies or substantial portions of the Software.\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n    INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n    PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\n    FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n    IN THE SOFTWARE.\n\"\"\"\n\nSPINNERS = {\n    \"dots\": {\n        \"interval\": 80,\n        \"frames\": \"â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â \",\n    },\n    \"dots2\": {\"interval\": 80, \"frames\": \"â£¾â£½â£»â¢¿â¡¿â£Ÿâ£¯â£·\"},\n    \"dots3\": {\n        \"interval\": 80,\n        \"frames\": \"â ‹â ™â šâ â –â ¦â ´â ²â ³â “\",\n    },\n    \"dots4\": {\n        \"interval\": 80,\n        \"frames\": \"â „â †â ‡â ‹â ™â ¸â °â  â °â ¸â ™â ‹â ‡â †\",\n    },\n    \"dots5\": {\n        \"interval\": 80,\n        \"frames\": \"â ‹â ™â šâ ’â ‚â ‚â ’â ²â ´â ¦â –â ’â â â ’â “â ‹\",\n    },\n    \"dots6\": {\n        \"interval\": 80,\n        \"frames\": \"â â ‰â ™â šâ ’â ‚â ‚â ’â ²â ´â ¤â „â „â ¤â ´â ²â ’â ‚â ‚â ’â šâ ™â ‰â \",\n    },\n    \"dots7\": {\n        \"interval\": 80,\n        \"frames\": \"â ˆâ ‰â ‹â “â ’â â â ’â –â ¦â ¤â  â  â ¤â ¦â –â ’â â â ’â “â ‹â ‰â ˆ\",\n    },\n    \"dots8\": {\n        \"interval\": 80,\n        \"frames\": \"â â â ‰â ™â šâ ’â ‚â ‚â ’â ²â ´â ¤â „â „â ¤â  â  â ¤â ¦â –â ’â â â ’â “â ‹â ‰â ˆâ ˆ\",\n    },\n    \"dots9\": {\"interval\": 80, \"frames\": \"â¢¹â¢ºâ¢¼â£¸â£‡â¡§â¡—â¡\"},\n    \"dots10\": {\"interval\": 80, \"frames\": \"â¢„â¢‚â¢â¡â¡ˆâ¡â¡ \"},\n    \"dots11\": {\"interval\": 100, \"frames\": \"â â ‚â „â¡€â¢€â  â â ˆ\"},\n    \"dots12\": {\n        \"interval\": 80,\n        \"frames\": [\n            \"â¢€â €\",\n            \"â¡€â €\",\n            \"â „â €\",\n            \"â¢‚â €\",\n            \"â¡‚â €\",\n            \"â …â €\",\n            \"â¢ƒâ €\",\n            \"â¡ƒâ €\",\n            \"â â €\",\n            \"â¢‹â €\",\n            \"â¡‹â €\",\n            \"â â \",\n            \"â¢‹â \",\n            \"â¡‹â \",\n            \"â â ‰\",\n            \"â ‹â ‰\",\n            \"â ‹â ‰\",\n            \"â ‰â ™\",\n            \"â ‰â ™\",\n            \"â ‰â ©\",\n            \"â ˆâ¢™\",\n            \"â ˆâ¡™\",\n            \"â¢ˆâ ©\",\n            \"â¡€â¢™\",\n            \"â „â¡™\",\n            \"â¢‚â ©\",\n            \"â¡‚â¢˜\",\n            \"â …â¡˜\",\n            \"â¢ƒâ ¨\",\n            \"â¡ƒâ¢\",\n            \"â â¡\",\n            \"â¢‹â  \",\n            \"â¡‹â¢€\",\n            \"â â¡\",\n            \"â¢‹â \",\n            \"â¡‹â \",\n            \"â â ‰\",\n            \"â ‹â ‰\",\n            \"â ‹â ‰\",\n            \"â ‰â ™\",\n            \"â ‰â ™\",\n            \"â ‰â ©\",\n            \"â ˆâ¢™\",\n            \"â ˆâ¡™\",\n            \"â ˆâ ©\",\n            \"â €â¢™\",\n            \"â €â¡™\",\n            \"â €â ©\",\n            \"â €â¢˜\",\n            \"â €â¡˜\",\n            \"â €â ¨\",\n            \"â €â¢\",\n            \"â €â¡\",\n            \"â €â  \",\n            \"â €â¢€\",\n            \"â €â¡€\",\n        ],\n    },\n    \"dots8Bit\": {\n        \"interval\": 80,\n        \"frames\": \"â €â â ‚â ƒâ „â …â †â ‡â¡€â¡â¡‚â¡ƒâ¡„â¡…â¡†â¡‡â ˆâ ‰â Šâ ‹â Œâ â â â¡ˆâ¡‰â¡Šâ¡‹â¡Œâ¡â¡â¡â â ‘â ’â “â ”â •â –â —â¡â¡‘â¡’â¡“â¡”â¡•â¡–â¡—â ˜â ™â šâ ›â œâ â â Ÿâ¡˜â¡™\"\n        \"â¡šâ¡›â¡œâ¡â¡â¡Ÿâ  â ¡â ¢â £â ¤â ¥â ¦â §â¡ â¡¡â¡¢â¡£â¡¤â¡¥â¡¦â¡§â ¨â ©â ªâ «â ¬â ­â ®â ¯â¡¨â¡©â¡ªâ¡«â¡¬â¡­â¡®â¡¯â °â ±â ²â ³â ´â µâ ¶â ·â¡°â¡±â¡²â¡³â¡´â¡µâ¡¶â¡·â ¸â ¹â ºâ »\"\n        \"â ¼â ½â ¾â ¿â¡¸â¡¹â¡ºâ¡»â¡¼â¡½â¡¾â¡¿â¢€â¢â¢‚â¢ƒâ¢„â¢…â¢†â¢‡â£€â£â£‚â£ƒâ£„â£…â£†â£‡â¢ˆâ¢‰â¢Šâ¢‹â¢Œâ¢â¢â¢â£ˆâ£‰â£Šâ£‹â£Œâ£â£â£â¢â¢‘â¢’â¢“â¢”â¢•â¢–â¢—â£â£‘â£’â£“â£”â£•\"\n        \"â£–â£—â¢˜â¢™â¢šâ¢›â¢œâ¢â¢â¢Ÿâ£˜â£™â£šâ£›â£œâ£â£â£Ÿâ¢ â¢¡â¢¢â¢£â¢¤â¢¥â¢¦â¢§â£ â£¡â£¢â££â£¤â£¥â£¦â£§â¢¨â¢©â¢ªâ¢«â¢¬â¢­â¢®â¢¯â£¨â£©â£ªâ£«â£¬â£­â£®â£¯â¢°â¢±â¢²â¢³â¢´â¢µâ¢¶â¢·\"\n        \"â£°â£±â£²â£³â£´â£µâ£¶â£·â¢¸â¢¹â¢ºâ¢»â¢¼â¢½â¢¾â¢¿â£¸â£¹â£ºâ£»â£¼â£½â£¾â£¿\",\n    },\n    \"line\": {\"interval\": 130, \"frames\": [\"-\", \"\\\\\", \"|\", \"/\"]},\n    \"line2\": {\"interval\": 100, \"frames\": \"â ‚-â€“â€”â€“-\"},\n    \"pipe\": {\"interval\": 100, \"frames\": \"â”¤â”˜â”´â””â”œâ”Œâ”¬â”\"},\n    \"simpleDots\": {\"interval\": 400, \"frames\": [\".  \", \".. \", \"...\", \"   \"]},\n    \"simpleDotsScrolling\": {\n        \"interval\": 200,\n        \"frames\": [\".  \", \".. \", \"...\", \" ..\", \"  .\", \"   \"],\n    },\n    \"star\": {\"interval\": 70, \"frames\": \"âœ¶âœ¸âœ¹âœºâœ¹âœ·\"},\n    \"star2\": {\"interval\": 80, \"frames\": \"+x*\"},\n    \"flip\": {\n        \"interval\": 70,\n        \"frames\": \"___-``'Â´-___\",\n    },\n    \"hamburger\": {\"interval\": 100, \"frames\": \"â˜±â˜²â˜´\"},\n    \"growVertical\": {\n        \"interval\": 120,\n        \"frames\": \"â–â–ƒâ–„â–…â–†â–‡â–†â–…â–„â–ƒ\",\n    },\n    \"growHorizontal\": {\n        \"interval\": 120,\n        \"frames\": \"â–â–â–â–Œâ–‹â–Šâ–‰â–Šâ–‹â–Œâ–â–\",\n    },\n    \"balloon\": {\"interval\": 140, \"frames\": \" .oO@* \"},\n    \"balloon2\": {\"interval\": 120, \"frames\": \".oOÂ°Oo.\"},\n    \"noise\": {\"interval\": 100, \"frames\": \"â–“â–’â–‘\"},\n    \"bounce\": {\"interval\": 120, \"frames\": \"â â ‚â „â ‚\"},\n    \"boxBounce\": {\"interval\": 120, \"frames\": \"â––â–˜â–â–—\"},\n    \"boxBounce2\": {\"interval\": 100, \"frames\": \"â–Œâ–€â–â–„\"},\n    \"triangle\": {\"interval\": 50, \"frames\": \"â—¢â—£â—¤â—¥\"},\n    \"arc\": {\"interval\": 100, \"frames\": \"â—œâ— â—â—â—¡â—Ÿ\"},\n    \"circle\": {\"interval\": 120, \"frames\": \"â—¡âŠ™â— \"},\n    \"squareCorners\": {\"interval\": 180, \"frames\": \"â—°â—³â—²â—±\"},\n    \"circleQuarters\": {\"interval\": 120, \"frames\": \"â—´â—·â—¶â—µ\"},\n    \"circleHalves\": {\"interval\": 50, \"frames\": \"â—â—“â—‘â—’\"},\n    \"squish\": {\"interval\": 100, \"frames\": \"â•«â•ª\"},\n    \"toggle\": {\"interval\": 250, \"frames\": \"âŠ¶âŠ·\"},\n    \"toggle2\": {\"interval\": 80, \"frames\": \"â–«â–ª\"},\n    \"toggle3\": {\"interval\": 120, \"frames\": \"â–¡â– \"},\n    \"toggle4\": {\"interval\": 100, \"frames\": \"â– â–¡â–ªâ–«\"},\n    \"toggle5\": {\"interval\": 100, \"frames\": \"â–®â–¯\"},\n    \"toggle6\": {\"interval\": 300, \"frames\": \"á€á€\"},\n    \"toggle7\": {\"interval\": 80, \"frames\": \"â¦¾â¦¿\"},\n    \"toggle8\": {\"interval\": 100, \"frames\": \"â—â—Œ\"},\n    \"toggle9\": {\"interval\": 100, \"frames\": \"â—‰â—\"},\n    \"toggle10\": {\"interval\": 100, \"frames\": \"ãŠ‚ãŠ€ãŠ\"},\n    \"toggle11\": {\"interval\": 50, \"frames\": \"â§‡â§†\"},\n    \"toggle12\": {\"interval\": 120, \"frames\": \"â˜—â˜–\"},\n    \"toggle13\": {\"interval\": 80, \"frames\": \"=*-\"},\n    \"arrow\": {\"interval\": 100, \"frames\": \"â†â†–â†‘â†—â†’â†˜â†“â†™\"},\n    \"arrow2\": {\n        \"interval\": 80,\n        \"frames\": [\"â¬†ï¸ \", \"â†—ï¸ \", \"â¡ï¸ \", \"â†˜ï¸ \", \"â¬‡ï¸ \", \"â†™ï¸ \", \"â¬…ï¸ \", \"â†–ï¸ \"],\n    },\n    \"arrow3\": {\n        \"interval\": 120,\n        \"frames\": [\"â–¹â–¹â–¹â–¹â–¹\", \"â–¸â–¹â–¹â–¹â–¹\", \"â–¹â–¸â–¹â–¹â–¹\", \"â–¹â–¹â–¸â–¹â–¹\", \"â–¹â–¹â–¹â–¸â–¹\", \"â–¹â–¹â–¹â–¹â–¸\"],\n    },\n    \"bouncingBar\": {\n        \"interval\": 80,\n        \"frames\": [\n            \"[    ]\",\n            \"[=   ]\",\n            \"[==  ]\",\n            \"[=== ]\",\n            \"[ ===]\",\n            \"[  ==]\",\n            \"[   =]\",\n            \"[    ]\",\n            \"[   =]\",\n            \"[  ==]\",\n            \"[ ===]\",\n            \"[====]\",\n            \"[=== ]\",\n            \"[==  ]\",\n            \"[=   ]\",\n        ],\n    },\n    \"bouncingBall\": {\n        \"interval\": 80,\n        \"frames\": [\n            \"( â—    )\",\n            \"(  â—   )\",\n            \"(   â—  )\",\n            \"(    â— )\",\n            \"(     â—)\",\n            \"(    â— )\",\n            \"(   â—  )\",\n            \"(  â—   )\",\n            \"( â—    )\",\n            \"(â—     )\",\n        ],\n    },\n    \"smiley\": {\"interval\": 200, \"frames\": [\"ğŸ˜„ \", \"ğŸ˜ \"]},\n    \"monkey\": {\"interval\": 300, \"frames\": [\"ğŸ™ˆ \", \"ğŸ™ˆ \", \"ğŸ™‰ \", \"ğŸ™Š \"]},\n    \"hearts\": {\"interval\": 100, \"frames\": [\"ğŸ’› \", \"ğŸ’™ \", \"ğŸ’œ \", \"ğŸ’š \", \"â¤ï¸ \"]},\n    \"clock\": {\n        \"interval\": 100,\n        \"frames\": [\n            \"ğŸ•› \",\n            \"ğŸ• \",\n            \"ğŸ•‘ \",\n            \"ğŸ•’ \",\n            \"ğŸ•“ \",\n            \"ğŸ•” \",\n            \"ğŸ•• \",\n            \"ğŸ•– \",\n            \"ğŸ•— \",\n            \"ğŸ•˜ \",\n            \"ğŸ•™ \",\n            \"ğŸ•š \",\n        ],\n    },\n    \"earth\": {\"interval\": 180, \"frames\": [\"ğŸŒ \", \"ğŸŒ \", \"ğŸŒ \"]},\n    \"material\": {\n        \"interval\": 17,\n        \"frames\": [\n            \"â–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–\",\n            \"â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–\",\n            \"â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–\",\n            \"â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–\",\n            \"â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–\",\n            \"â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–\",\n            \"â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–\",\n            \"â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–\",\n            \"â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–\",\n            \"â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–\",\n            \"â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–\",\n            \"â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–\",\n            \"â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆ\",\n            \"â–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆ\",\n            \"â–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆ\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆ\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆ\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆ\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆ\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–\",\n            \"â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–â–\",\n            \"â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–\",\n            \"â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–â–\",\n            \"â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–â–\",\n            \"â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–\",\n            \"â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–\",\n            \"â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–\",\n            \"â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–\",\n            \"â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–â–\",\n            \"â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–\",\n            \"â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–â–\",\n            \"â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆâ–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ˆ\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–\",\n            \"â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–\",\n        ],\n    },\n    \"moon\": {\n        \"interval\": 80,\n        \"frames\": [\"ğŸŒ‘ \", \"ğŸŒ’ \", \"ğŸŒ“ \", \"ğŸŒ” \", \"ğŸŒ• \", \"ğŸŒ– \", \"ğŸŒ— \", \"ğŸŒ˜ \"],\n    },\n    \"runner\": {\"interval\": 140, \"frames\": [\"ğŸš¶ \", \"ğŸƒ \"]},\n    \"pong\": {\n        \"interval\": 80,\n        \"frames\": [\n            \"â–â ‚       â–Œ\",\n            \"â–â ˆ       â–Œ\",\n            \"â– â ‚      â–Œ\",\n            \"â– â        â–Œ\",\n            \"â–  â¡€     â–Œ\",\n            \"â–  â       â–Œ\",\n            \"â–   â ‚    â–Œ\",\n            \"â–   â ˆ    â–Œ\",\n            \"â–    â ‚   â–Œ\",\n            \"â–    â     â–Œ\",\n            \"â–     â¡€  â–Œ\",\n            \"â–     â    â–Œ\",\n            \"â–      â ‚ â–Œ\",\n            \"â–      â ˆ â–Œ\",\n            \"â–       â ‚â–Œ\",\n            \"â–       â  â–Œ\",\n            \"â–       â¡€â–Œ\",\n            \"â–      â   â–Œ\",\n            \"â–      â ‚ â–Œ\",\n            \"â–     â ˆ  â–Œ\",\n            \"â–     â ‚  â–Œ\",\n            \"â–    â     â–Œ\",\n            \"â–    â¡€   â–Œ\",\n            \"â–   â      â–Œ\",\n            \"â–   â ‚    â–Œ\",\n            \"â–  â ˆ     â–Œ\",\n            \"â–  â ‚     â–Œ\",\n            \"â– â        â–Œ\",\n            \"â– â¡€      â–Œ\",\n            \"â–â         â–Œ\",\n        ],\n    },\n    \"shark\": {\n        \"interval\": 120,\n        \"frames\": [\n            \"â–|\\\\____________â–Œ\",\n            \"â–_|\\\\___________â–Œ\",\n            \"â–__|\\\\__________â–Œ\",\n            \"â–___|\\\\_________â–Œ\",\n            \"â–____|\\\\________â–Œ\",\n            \"â–_____|\\\\_______â–Œ\",\n            \"â–______|\\\\______â–Œ\",\n            \"â–_______|\\\\_____â–Œ\",\n            \"â–________|\\\\____â–Œ\",\n            \"â–_________|\\\\___â–Œ\",\n            \"â–__________|\\\\__â–Œ\",\n            \"â–___________|\\\\_â–Œ\",\n            \"â–____________|\\\\â–Œ\",\n            \"â–____________/|â–Œ\",\n            \"â–___________/|_â–Œ\",\n            \"â–__________/|__â–Œ\",\n            \"â–_________/|___â–Œ\",\n            \"â–________/|____â–Œ\",\n            \"â–_______/|_____â–Œ\",\n            \"â–______/|______â–Œ\",\n            \"â–_____/|_______â–Œ\",\n            \"â–____/|________â–Œ\",\n            \"â–___/|_________â–Œ\",\n            \"â–__/|__________â–Œ\",\n            \"â–_/|___________â–Œ\",\n            \"â–/|____________â–Œ\",\n        ],\n    },\n    \"dqpb\": {\"interval\": 100, \"frames\": \"dqpb\"},\n    \"weather\": {\n        \"interval\": 100,\n        \"frames\": [\n            \"â˜€ï¸ \",\n            \"â˜€ï¸ \",\n            \"â˜€ï¸ \",\n            \"ğŸŒ¤ \",\n            \"â›…ï¸ \",\n            \"ğŸŒ¥ \",\n            \"â˜ï¸ \",\n            \"ğŸŒ§ \",\n            \"ğŸŒ¨ \",\n            \"ğŸŒ§ \",\n            \"ğŸŒ¨ \",\n            \"ğŸŒ§ \",\n            \"ğŸŒ¨ \",\n            \"â›ˆ \",\n            \"ğŸŒ¨ \",\n            \"ğŸŒ§ \",\n            \"ğŸŒ¨ \",\n            \"â˜ï¸ \",\n            \"ğŸŒ¥ \",\n            \"â›…ï¸ \",\n            \"ğŸŒ¤ \",\n            \"â˜€ï¸ \",\n            \"â˜€ï¸ \",\n        ],\n    },\n    \"christmas\": {\"interval\": 400, \"frames\": \"ğŸŒ²ğŸ„\"},\n    \"grenade\": {\n        \"interval\": 80,\n        \"frames\": [\n            \"ØŒ   \",\n            \"â€²   \",\n            \" Â´ \",\n            \" â€¾ \",\n            \"  â¸Œ\",\n            \"  â¸Š\",\n            \"  |\",\n            \"  â\",\n            \"  â•\",\n            \" à·´ \",\n            \"  â“\",\n            \"   \",\n            \"   \",\n            \"   \",\n        ],\n    },\n    \"point\": {\"interval\": 125, \"frames\": [\"âˆ™âˆ™âˆ™\", \"â—âˆ™âˆ™\", \"âˆ™â—âˆ™\", \"âˆ™âˆ™â—\", \"âˆ™âˆ™âˆ™\"]},\n    \"layer\": {\"interval\": 150, \"frames\": \"-=â‰¡\"},\n    \"betaWave\": {\n        \"interval\": 80,\n        \"frames\": [\n            \"ÏÎ²Î²Î²Î²Î²Î²\",\n            \"Î²ÏÎ²Î²Î²Î²Î²\",\n            \"Î²Î²ÏÎ²Î²Î²Î²\",\n            \"Î²Î²Î²ÏÎ²Î²Î²\",\n            \"Î²Î²Î²Î²ÏÎ²Î²\",\n            \"Î²Î²Î²Î²Î²ÏÎ²\",\n            \"Î²Î²Î²Î²Î²Î²Ï\",\n        ],\n    },\n    \"aesthetic\": {\n        \"interval\": 80,\n        \"frames\": [\n            \"â–°â–±â–±â–±â–±â–±â–±\",\n            \"â–°â–°â–±â–±â–±â–±â–±\",\n            \"â–°â–°â–°â–±â–±â–±â–±\",\n            \"â–°â–°â–°â–°â–±â–±â–±\",\n            \"â–°â–°â–°â–°â–°â–±â–±\",\n            \"â–°â–°â–°â–°â–°â–°â–±\",\n            \"â–°â–°â–°â–°â–°â–°â–°\",\n            \"â–°â–±â–±â–±â–±â–±â–±\",\n        ],\n    },\n}\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/_stack.py","size":351,"sha1":"3a77a4cd0cdaea78fad6d0088f35bc0035fb62f6","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import List, TypeVar\n\nT = TypeVar(\"T\")\n\n\nclass Stack(List[T]):\n    \"\"\"A small shim over builtin list.\"\"\"\n\n    @property\n    def top(self) -> T:\n        \"\"\"Get top of stack.\"\"\"\n        return self[-1]\n\n    def push(self, item: T) -> None:\n        \"\"\"Push an item on to the stack (append in stack nomenclature).\"\"\"\n        self.append(item)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/_timer.py","size":417,"sha1":"b93f8ddd7bc4ea918a9b40a1a5b993d7b7e93b19","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nTimer context manager, only used in debug.\n\n\"\"\"\n\nfrom time import time\n\nimport contextlib\nfrom typing import Generator\n\n\n@contextlib.contextmanager\ndef timer(subject: str = \"time\") -> Generator[None, None, None]:\n    \"\"\"print the elapsed time. (only used in debugging)\"\"\"\n    start = time()\n    yield\n    elapsed = time() - start\n    elapsed_ms = elapsed * 1000\n    print(f\"{subject} elapsed {elapsed_ms:.1f}ms\")\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/_win32_console.py","size":22755,"sha1":"2cbc9f90a5ee8ce59c40f3658763a752bcf8fadd","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Light wrapper around the Win32 Console API - this module should only be imported on Windows\n\nThe API that this module wraps is documented at https://docs.microsoft.com/en-us/windows/console/console-functions\n\"\"\"\n\nimport ctypes\nimport sys\nfrom typing import Any\n\nwindll: Any = None\nif sys.platform == \"win32\":\n    windll = ctypes.LibraryLoader(ctypes.WinDLL)\nelse:\n    raise ImportError(f\"{__name__} can only be imported on Windows\")\n\nimport time\nfrom ctypes import Structure, byref, wintypes\nfrom typing import IO, NamedTuple, Type, cast\n\nfrom pip._vendor.rich.color import ColorSystem\nfrom pip._vendor.rich.style import Style\n\nSTDOUT = -11\nENABLE_VIRTUAL_TERMINAL_PROCESSING = 4\n\nCOORD = wintypes._COORD\n\n\nclass LegacyWindowsError(Exception):\n    pass\n\n\nclass WindowsCoordinates(NamedTuple):\n    \"\"\"Coordinates in the Windows Console API are (y, x), not (x, y).\n    This class is intended to prevent that confusion.\n    Rows and columns are indexed from 0.\n    This class can be used in place of wintypes._COORD in arguments and argtypes.\n    \"\"\"\n\n    row: int\n    col: int\n\n    @classmethod\n    def from_param(cls, value: \"WindowsCoordinates\") -> COORD:\n        \"\"\"Converts a WindowsCoordinates into a wintypes _COORD structure.\n        This classmethod is internally called by ctypes to perform the conversion.\n\n        Args:\n            value (WindowsCoordinates): The input coordinates to convert.\n\n        Returns:\n            wintypes._COORD: The converted coordinates struct.\n        \"\"\"\n        return COORD(value.col, value.row)\n\n\nclass CONSOLE_SCREEN_BUFFER_INFO(Structure):\n    _fields_ = [\n        (\"dwSize\", COORD),\n        (\"dwCursorPosition\", COORD),\n        (\"wAttributes\", wintypes.WORD),\n        (\"srWindow\", wintypes.SMALL_RECT),\n        (\"dwMaximumWindowSize\", COORD),\n    ]\n\n\nclass CONSOLE_CURSOR_INFO(ctypes.Structure):\n    _fields_ = [(\"dwSize\", wintypes.DWORD), (\"bVisible\", wintypes.BOOL)]\n\n\n_GetStdHandle = windll.kernel32.GetStdHandle\n_GetStdHandle.argtypes = [\n    wintypes.DWORD,\n]\n_GetStdHandle.restype = wintypes.HANDLE\n\n\ndef GetStdHandle(handle: int = STDOUT) -> wintypes.HANDLE:\n    \"\"\"Retrieves a handle to the specified standard device (standard input, standard output, or standard error).\n\n    Args:\n        handle (int): Integer identifier for the handle. Defaults to -11 (stdout).\n\n    Returns:\n        wintypes.HANDLE: The handle\n    \"\"\"\n    return cast(wintypes.HANDLE, _GetStdHandle(handle))\n\n\n_GetConsoleMode = windll.kernel32.GetConsoleMode\n_GetConsoleMode.argtypes = [wintypes.HANDLE, wintypes.LPDWORD]\n_GetConsoleMode.restype = wintypes.BOOL\n\n\ndef GetConsoleMode(std_handle: wintypes.HANDLE) -> int:\n    \"\"\"Retrieves the current input mode of a console's input buffer\n    or the current output mode of a console screen buffer.\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n\n    Raises:\n        LegacyWindowsError: If any error occurs while calling the Windows console API.\n\n    Returns:\n        int: Value representing the current console mode as documented at\n            https://docs.microsoft.com/en-us/windows/console/getconsolemode#parameters\n    \"\"\"\n\n    console_mode = wintypes.DWORD()\n    success = bool(_GetConsoleMode(std_handle, console_mode))\n    if not success:\n        raise LegacyWindowsError(\"Unable to get legacy Windows Console Mode\")\n    return console_mode.value\n\n\n_FillConsoleOutputCharacterW = windll.kernel32.FillConsoleOutputCharacterW\n_FillConsoleOutputCharacterW.argtypes = [\n    wintypes.HANDLE,\n    ctypes.c_char,\n    wintypes.DWORD,\n    cast(Type[COORD], WindowsCoordinates),\n    ctypes.POINTER(wintypes.DWORD),\n]\n_FillConsoleOutputCharacterW.restype = wintypes.BOOL\n\n\ndef FillConsoleOutputCharacter(\n    std_handle: wintypes.HANDLE,\n    char: str,\n    length: int,\n    start: WindowsCoordinates,\n) -> int:\n    \"\"\"Writes a character to the console screen buffer a specified number of times, beginning at the specified coordinates.\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n        char (str): The character to write. Must be a string of length 1.\n        length (int): The number of times to write the character.\n        start (WindowsCoordinates): The coordinates to start writing at.\n\n    Returns:\n        int: The number of characters written.\n    \"\"\"\n    character = ctypes.c_char(char.encode())\n    num_characters = wintypes.DWORD(length)\n    num_written = wintypes.DWORD(0)\n    _FillConsoleOutputCharacterW(\n        std_handle,\n        character,\n        num_characters,\n        start,\n        byref(num_written),\n    )\n    return num_written.value\n\n\n_FillConsoleOutputAttribute = windll.kernel32.FillConsoleOutputAttribute\n_FillConsoleOutputAttribute.argtypes = [\n    wintypes.HANDLE,\n    wintypes.WORD,\n    wintypes.DWORD,\n    cast(Type[COORD], WindowsCoordinates),\n    ctypes.POINTER(wintypes.DWORD),\n]\n_FillConsoleOutputAttribute.restype = wintypes.BOOL\n\n\ndef FillConsoleOutputAttribute(\n    std_handle: wintypes.HANDLE,\n    attributes: int,\n    length: int,\n    start: WindowsCoordinates,\n) -> int:\n    \"\"\"Sets the character attributes for a specified number of character cells,\n    beginning at the specified coordinates in a screen buffer.\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n        attributes (int): Integer value representing the foreground and background colours of the cells.\n        length (int): The number of cells to set the output attribute of.\n        start (WindowsCoordinates): The coordinates of the first cell whose attributes are to be set.\n\n    Returns:\n        int: The number of cells whose attributes were actually set.\n    \"\"\"\n    num_cells = wintypes.DWORD(length)\n    style_attrs = wintypes.WORD(attributes)\n    num_written = wintypes.DWORD(0)\n    _FillConsoleOutputAttribute(\n        std_handle, style_attrs, num_cells, start, byref(num_written)\n    )\n    return num_written.value\n\n\n_SetConsoleTextAttribute = windll.kernel32.SetConsoleTextAttribute\n_SetConsoleTextAttribute.argtypes = [\n    wintypes.HANDLE,\n    wintypes.WORD,\n]\n_SetConsoleTextAttribute.restype = wintypes.BOOL\n\n\ndef SetConsoleTextAttribute(\n    std_handle: wintypes.HANDLE, attributes: wintypes.WORD\n) -> bool:\n    \"\"\"Set the colour attributes for all text written after this function is called.\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n        attributes (int): Integer value representing the foreground and background colours.\n\n\n    Returns:\n        bool: True if the attribute was set successfully, otherwise False.\n    \"\"\"\n    return bool(_SetConsoleTextAttribute(std_handle, attributes))\n\n\n_GetConsoleScreenBufferInfo = windll.kernel32.GetConsoleScreenBufferInfo\n_GetConsoleScreenBufferInfo.argtypes = [\n    wintypes.HANDLE,\n    ctypes.POINTER(CONSOLE_SCREEN_BUFFER_INFO),\n]\n_GetConsoleScreenBufferInfo.restype = wintypes.BOOL\n\n\ndef GetConsoleScreenBufferInfo(\n    std_handle: wintypes.HANDLE,\n) -> CONSOLE_SCREEN_BUFFER_INFO:\n    \"\"\"Retrieves information about the specified console screen buffer.\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n\n    Returns:\n        CONSOLE_SCREEN_BUFFER_INFO: A CONSOLE_SCREEN_BUFFER_INFO ctype struct contain information about\n            screen size, cursor position, colour attributes, and more.\"\"\"\n    console_screen_buffer_info = CONSOLE_SCREEN_BUFFER_INFO()\n    _GetConsoleScreenBufferInfo(std_handle, byref(console_screen_buffer_info))\n    return console_screen_buffer_info\n\n\n_SetConsoleCursorPosition = windll.kernel32.SetConsoleCursorPosition\n_SetConsoleCursorPosition.argtypes = [\n    wintypes.HANDLE,\n    cast(Type[COORD], WindowsCoordinates),\n]\n_SetConsoleCursorPosition.restype = wintypes.BOOL\n\n\ndef SetConsoleCursorPosition(\n    std_handle: wintypes.HANDLE, coords: WindowsCoordinates\n) -> bool:\n    \"\"\"Set the position of the cursor in the console screen\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n        coords (WindowsCoordinates): The coordinates to move the cursor to.\n\n    Returns:\n        bool: True if the function succeeds, otherwise False.\n    \"\"\"\n    return bool(_SetConsoleCursorPosition(std_handle, coords))\n\n\n_GetConsoleCursorInfo = windll.kernel32.GetConsoleCursorInfo\n_GetConsoleCursorInfo.argtypes = [\n    wintypes.HANDLE,\n    ctypes.POINTER(CONSOLE_CURSOR_INFO),\n]\n_GetConsoleCursorInfo.restype = wintypes.BOOL\n\n\ndef GetConsoleCursorInfo(\n    std_handle: wintypes.HANDLE, cursor_info: CONSOLE_CURSOR_INFO\n) -> bool:\n    \"\"\"Get the cursor info - used to get cursor visibility and width\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n        cursor_info (CONSOLE_CURSOR_INFO): CONSOLE_CURSOR_INFO ctype struct that receives information\n            about the console's cursor.\n\n    Returns:\n          bool: True if the function succeeds, otherwise False.\n    \"\"\"\n    return bool(_GetConsoleCursorInfo(std_handle, byref(cursor_info)))\n\n\n_SetConsoleCursorInfo = windll.kernel32.SetConsoleCursorInfo\n_SetConsoleCursorInfo.argtypes = [\n    wintypes.HANDLE,\n    ctypes.POINTER(CONSOLE_CURSOR_INFO),\n]\n_SetConsoleCursorInfo.restype = wintypes.BOOL\n\n\ndef SetConsoleCursorInfo(\n    std_handle: wintypes.HANDLE, cursor_info: CONSOLE_CURSOR_INFO\n) -> bool:\n    \"\"\"Set the cursor info - used for adjusting cursor visibility and width\n\n    Args:\n        std_handle (wintypes.HANDLE): A handle to the console input buffer or the console screen buffer.\n        cursor_info (CONSOLE_CURSOR_INFO): CONSOLE_CURSOR_INFO ctype struct containing the new cursor info.\n\n    Returns:\n          bool: True if the function succeeds, otherwise False.\n    \"\"\"\n    return bool(_SetConsoleCursorInfo(std_handle, byref(cursor_info)))\n\n\n_SetConsoleTitle = windll.kernel32.SetConsoleTitleW\n_SetConsoleTitle.argtypes = [wintypes.LPCWSTR]\n_SetConsoleTitle.restype = wintypes.BOOL\n\n\ndef SetConsoleTitle(title: str) -> bool:\n    \"\"\"Sets the title of the current console window\n\n    Args:\n        title (str): The new title of the console window.\n\n    Returns:\n        bool: True if the function succeeds, otherwise False.\n    \"\"\"\n    return bool(_SetConsoleTitle(title))\n\n\nclass LegacyWindowsTerm:\n    \"\"\"This class allows interaction with the legacy Windows Console API. It should only be used in the context\n    of environments where virtual terminal processing is not available. However, if it is used in a Windows environment,\n    the entire API should work.\n\n    Args:\n        file (IO[str]): The file which the Windows Console API HANDLE is retrieved from, defaults to sys.stdout.\n    \"\"\"\n\n    BRIGHT_BIT = 8\n\n    # Indices are ANSI color numbers, values are the corresponding Windows Console API color numbers\n    ANSI_TO_WINDOWS = [\n        0,  # black                      The Windows colours are defined in wincon.h as follows:\n        4,  # red                         define FOREGROUND_BLUE            0x0001 -- 0000 0001\n        2,  # green                       define FOREGROUND_GREEN           0x0002 -- 0000 0010\n        6,  # yellow                      define FOREGROUND_RED             0x0004 -- 0000 0100\n        1,  # blue                        define FOREGROUND_INTENSITY       0x0008 -- 0000 1000\n        5,  # magenta                     define BACKGROUND_BLUE            0x0010 -- 0001 0000\n        3,  # cyan                        define BACKGROUND_GREEN           0x0020 -- 0010 0000\n        7,  # white                       define BACKGROUND_RED             0x0040 -- 0100 0000\n        8,  # bright black (grey)         define BACKGROUND_INTENSITY       0x0080 -- 1000 0000\n        12,  # bright red\n        10,  # bright green\n        14,  # bright yellow\n        9,  # bright blue\n        13,  # bright magenta\n        11,  # bright cyan\n        15,  # bright white\n    ]\n\n    def __init__(self, file: \"IO[str]\") -> None:\n        handle = GetStdHandle(STDOUT)\n        self._handle = handle\n        default_text = GetConsoleScreenBufferInfo(handle).wAttributes\n        self._default_text = default_text\n\n        self._default_fore = default_text & 7\n        self._default_back = (default_text >> 4) & 7\n        self._default_attrs = self._default_fore | (self._default_back << 4)\n\n        self._file = file\n        self.write = file.write\n        self.flush = file.flush\n\n    @property\n    def cursor_position(self) -> WindowsCoordinates:\n        \"\"\"Returns the current position of the cursor (0-based)\n\n        Returns:\n            WindowsCoordinates: The current cursor position.\n        \"\"\"\n        coord: COORD = GetConsoleScreenBufferInfo(self._handle).dwCursorPosition\n        return WindowsCoordinates(row=coord.Y, col=coord.X)\n\n    @property\n    def screen_size(self) -> WindowsCoordinates:\n        \"\"\"Returns the current size of the console screen buffer, in character columns and rows\n\n        Returns:\n            WindowsCoordinates: The width and height of the screen as WindowsCoordinates.\n        \"\"\"\n        screen_size: COORD = GetConsoleScreenBufferInfo(self._handle).dwSize\n        return WindowsCoordinates(row=screen_size.Y, col=screen_size.X)\n\n    def write_text(self, text: str) -> None:\n        \"\"\"Write text directly to the terminal without any modification of styles\n\n        Args:\n            text (str): The text to write to the console\n        \"\"\"\n        self.write(text)\n        self.flush()\n\n    def write_styled(self, text: str, style: Style) -> None:\n        \"\"\"Write styled text to the terminal.\n\n        Args:\n            text (str): The text to write\n            style (Style): The style of the text\n        \"\"\"\n        color = style.color\n        bgcolor = style.bgcolor\n        if style.reverse:\n            color, bgcolor = bgcolor, color\n\n        if color:\n            fore = color.downgrade(ColorSystem.WINDOWS).number\n            fore = fore if fore is not None else 7  # Default to ANSI 7: White\n            if style.bold:\n                fore = fore | self.BRIGHT_BIT\n            if style.dim:\n                fore = fore & ~self.BRIGHT_BIT\n            fore = self.ANSI_TO_WINDOWS[fore]\n        else:\n            fore = self._default_fore\n\n        if bgcolor:\n            back = bgcolor.downgrade(ColorSystem.WINDOWS).number\n            back = back if back is not None else 0  # Default to ANSI 0: Black\n            back = self.ANSI_TO_WINDOWS[back]\n        else:\n            back = self._default_back\n\n        assert fore is not None\n        assert back is not None\n\n        SetConsoleTextAttribute(\n            self._handle, attributes=ctypes.c_ushort(fore | (back << 4))\n        )\n        self.write_text(text)\n        SetConsoleTextAttribute(self._handle, attributes=self._default_text)\n\n    def move_cursor_to(self, new_position: WindowsCoordinates) -> None:\n        \"\"\"Set the position of the cursor\n\n        Args:\n            new_position (WindowsCoordinates): The WindowsCoordinates representing the new position of the cursor.\n        \"\"\"\n        if new_position.col < 0 or new_position.row < 0:\n            return\n        SetConsoleCursorPosition(self._handle, coords=new_position)\n\n    def erase_line(self) -> None:\n        \"\"\"Erase all content on the line the cursor is currently located at\"\"\"\n        screen_size = self.screen_size\n        cursor_position = self.cursor_position\n        cells_to_erase = screen_size.col\n        start_coordinates = WindowsCoordinates(row=cursor_position.row, col=0)\n        FillConsoleOutputCharacter(\n            self._handle, \" \", length=cells_to_erase, start=start_coordinates\n        )\n        FillConsoleOutputAttribute(\n            self._handle,\n            self._default_attrs,\n            length=cells_to_erase,\n            start=start_coordinates,\n        )\n\n    def erase_end_of_line(self) -> None:\n        \"\"\"Erase all content from the cursor position to the end of that line\"\"\"\n        cursor_position = self.cursor_position\n        cells_to_erase = self.screen_size.col - cursor_position.col\n        FillConsoleOutputCharacter(\n            self._handle, \" \", length=cells_to_erase, start=cursor_position\n        )\n        FillConsoleOutputAttribute(\n            self._handle,\n            self._default_attrs,\n            length=cells_to_erase,\n            start=cursor_position,\n        )\n\n    def erase_start_of_line(self) -> None:\n        \"\"\"Erase all content from the cursor position to the start of that line\"\"\"\n        row, col = self.cursor_position\n        start = WindowsCoordinates(row, 0)\n        FillConsoleOutputCharacter(self._handle, \" \", length=col, start=start)\n        FillConsoleOutputAttribute(\n            self._handle, self._default_attrs, length=col, start=start\n        )\n\n    def move_cursor_up(self) -> None:\n        \"\"\"Move the cursor up a single cell\"\"\"\n        cursor_position = self.cursor_position\n        SetConsoleCursorPosition(\n            self._handle,\n            coords=WindowsCoordinates(\n                row=cursor_position.row - 1, col=cursor_position.col\n            ),\n        )\n\n    def move_cursor_down(self) -> None:\n        \"\"\"Move the cursor down a single cell\"\"\"\n        cursor_position = self.cursor_position\n        SetConsoleCursorPosition(\n            self._handle,\n            coords=WindowsCoordinates(\n                row=cursor_position.row + 1,\n                col=cursor_position.col,\n            ),\n        )\n\n    def move_cursor_forward(self) -> None:\n        \"\"\"Move the cursor forward a single cell. Wrap to the next line if required.\"\"\"\n        row, col = self.cursor_position\n        if col == self.screen_size.col - 1:\n            row += 1\n            col = 0\n        else:\n            col += 1\n        SetConsoleCursorPosition(\n            self._handle, coords=WindowsCoordinates(row=row, col=col)\n        )\n\n    def move_cursor_to_column(self, column: int) -> None:\n        \"\"\"Move cursor to the column specified by the zero-based column index, staying on the same row\n\n        Args:\n            column (int): The zero-based column index to move the cursor to.\n        \"\"\"\n        row, _ = self.cursor_position\n        SetConsoleCursorPosition(self._handle, coords=WindowsCoordinates(row, column))\n\n    def move_cursor_backward(self) -> None:\n        \"\"\"Move the cursor backward a single cell. Wrap to the previous line if required.\"\"\"\n        row, col = self.cursor_position\n        if col == 0:\n            row -= 1\n            col = self.screen_size.col - 1\n        else:\n            col -= 1\n        SetConsoleCursorPosition(\n            self._handle, coords=WindowsCoordinates(row=row, col=col)\n        )\n\n    def hide_cursor(self) -> None:\n        \"\"\"Hide the cursor\"\"\"\n        current_cursor_size = self._get_cursor_size()\n        invisible_cursor = CONSOLE_CURSOR_INFO(dwSize=current_cursor_size, bVisible=0)\n        SetConsoleCursorInfo(self._handle, cursor_info=invisible_cursor)\n\n    def show_cursor(self) -> None:\n        \"\"\"Show the cursor\"\"\"\n        current_cursor_size = self._get_cursor_size()\n        visible_cursor = CONSOLE_CURSOR_INFO(dwSize=current_cursor_size, bVisible=1)\n        SetConsoleCursorInfo(self._handle, cursor_info=visible_cursor)\n\n    def set_title(self, title: str) -> None:\n        \"\"\"Set the title of the terminal window\n\n        Args:\n            title (str): The new title of the console window\n        \"\"\"\n        assert len(title) < 255, \"Console title must be less than 255 characters\"\n        SetConsoleTitle(title)\n\n    def _get_cursor_size(self) -> int:\n        \"\"\"Get the percentage of the character cell that is filled by the cursor\"\"\"\n        cursor_info = CONSOLE_CURSOR_INFO()\n        GetConsoleCursorInfo(self._handle, cursor_info=cursor_info)\n        return int(cursor_info.dwSize)\n\n\nif __name__ == \"__main__\":\n    handle = GetStdHandle()\n\n    from pip._vendor.rich.console import Console\n\n    console = Console()\n\n    term = LegacyWindowsTerm(sys.stdout)\n    term.set_title(\"Win32 Console Examples\")\n\n    style = Style(color=\"black\", bgcolor=\"red\")\n\n    heading = Style.parse(\"black on green\")\n\n    # Check colour output\n    console.rule(\"Checking colour output\")\n    console.print(\"[on red]on red!\")\n    console.print(\"[blue]blue!\")\n    console.print(\"[yellow]yellow!\")\n    console.print(\"[bold yellow]bold yellow!\")\n    console.print(\"[bright_yellow]bright_yellow!\")\n    console.print(\"[dim bright_yellow]dim bright_yellow!\")\n    console.print(\"[italic cyan]italic cyan!\")\n    console.print(\"[bold white on blue]bold white on blue!\")\n    console.print(\"[reverse bold white on blue]reverse bold white on blue!\")\n    console.print(\"[bold black on cyan]bold black on cyan!\")\n    console.print(\"[black on green]black on green!\")\n    console.print(\"[blue on green]blue on green!\")\n    console.print(\"[white on black]white on black!\")\n    console.print(\"[black on white]black on white!\")\n    console.print(\"[#1BB152 on #DA812D]#1BB152 on #DA812D!\")\n\n    # Check cursor movement\n    console.rule(\"Checking cursor movement\")\n    console.print()\n    term.move_cursor_backward()\n    term.move_cursor_backward()\n    term.write_text(\"went back and wrapped to prev line\")\n    time.sleep(1)\n    term.move_cursor_up()\n    term.write_text(\"we go up\")\n    time.sleep(1)\n    term.move_cursor_down()\n    term.write_text(\"and down\")\n    time.sleep(1)\n    term.move_cursor_up()\n    term.move_cursor_backward()\n    term.move_cursor_backward()\n    term.write_text(\"we went up and back 2\")\n    time.sleep(1)\n    term.move_cursor_down()\n    term.move_cursor_backward()\n    term.move_cursor_backward()\n    term.write_text(\"we went down and back 2\")\n    time.sleep(1)\n\n    # Check erasing of lines\n    term.hide_cursor()\n    console.print()\n    console.rule(\"Checking line erasing\")\n    console.print(\"\\n...Deleting to the start of the line...\")\n    term.write_text(\"The red arrow shows the cursor location, and direction of erase\")\n    time.sleep(1)\n    term.move_cursor_to_column(16)\n    term.write_styled(\"<\", Style.parse(\"black on red\"))\n    term.move_cursor_backward()\n    time.sleep(1)\n    term.erase_start_of_line()\n    time.sleep(1)\n\n    console.print(\"\\n\\n...And to the end of the line...\")\n    term.write_text(\"The red arrow shows the cursor location, and direction of erase\")\n    time.sleep(1)\n\n    term.move_cursor_to_column(16)\n    term.write_styled(\">\", Style.parse(\"black on red\"))\n    time.sleep(1)\n    term.erase_end_of_line()\n    time.sleep(1)\n\n    console.print(\"\\n\\n...Now the whole line will be erased...\")\n    term.write_styled(\"I'm going to disappear!\", style=Style.parse(\"black on cyan\"))\n    time.sleep(1)\n    term.erase_line()\n\n    term.show_cursor()\n    print(\"\\n\")\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/_windows.py","size":1925,"sha1":"e312d9bfd14f611b77ee6fc267295bcf49568ac2","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass WindowsConsoleFeatures:\n    \"\"\"Windows features available.\"\"\"\n\n    vt: bool = False\n    \"\"\"The console supports VT codes.\"\"\"\n    truecolor: bool = False\n    \"\"\"The console supports truecolor.\"\"\"\n\n\ntry:\n    import ctypes\n    from ctypes import LibraryLoader\n\n    if sys.platform == \"win32\":\n        windll = LibraryLoader(ctypes.WinDLL)\n    else:\n        windll = None\n        raise ImportError(\"Not windows\")\n\n    from pip._vendor.rich._win32_console import (\n        ENABLE_VIRTUAL_TERMINAL_PROCESSING,\n        GetConsoleMode,\n        GetStdHandle,\n        LegacyWindowsError,\n    )\n\nexcept (AttributeError, ImportError, ValueError):\n    # Fallback if we can't load the Windows DLL\n    def get_windows_console_features() -> WindowsConsoleFeatures:\n        features = WindowsConsoleFeatures()\n        return features\n\nelse:\n\n    def get_windows_console_features() -> WindowsConsoleFeatures:\n        \"\"\"Get windows console features.\n\n        Returns:\n            WindowsConsoleFeatures: An instance of WindowsConsoleFeatures.\n        \"\"\"\n        handle = GetStdHandle()\n        try:\n            console_mode = GetConsoleMode(handle)\n            success = True\n        except LegacyWindowsError:\n            console_mode = 0\n            success = False\n        vt = bool(success and console_mode & ENABLE_VIRTUAL_TERMINAL_PROCESSING)\n        truecolor = False\n        if vt:\n            win_version = sys.getwindowsversion()\n            truecolor = win_version.major > 10 or (\n                win_version.major == 10 and win_version.build >= 15063\n            )\n        features = WindowsConsoleFeatures(vt=vt, truecolor=truecolor)\n        return features\n\n\nif __name__ == \"__main__\":\n    import platform\n\n    features = get_windows_console_features()\n    from pip._vendor.rich import print\n\n    print(f'platform=\"{platform.system()}\"')\n    print(repr(features))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/_windows_renderer.py","size":2783,"sha1":"f736af40e625c4da8c394ddabcc2b9a30d6b009e","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import Iterable, Sequence, Tuple, cast\n\nfrom pip._vendor.rich._win32_console import LegacyWindowsTerm, WindowsCoordinates\nfrom pip._vendor.rich.segment import ControlCode, ControlType, Segment\n\n\ndef legacy_windows_render(buffer: Iterable[Segment], term: LegacyWindowsTerm) -> None:\n    \"\"\"Makes appropriate Windows Console API calls based on the segments in the buffer.\n\n    Args:\n        buffer (Iterable[Segment]): Iterable of Segments to convert to Win32 API calls.\n        term (LegacyWindowsTerm): Used to call the Windows Console API.\n    \"\"\"\n    for text, style, control in buffer:\n        if not control:\n            if style:\n                term.write_styled(text, style)\n            else:\n                term.write_text(text)\n        else:\n            control_codes: Sequence[ControlCode] = control\n            for control_code in control_codes:\n                control_type = control_code[0]\n                if control_type == ControlType.CURSOR_MOVE_TO:\n                    _, x, y = cast(Tuple[ControlType, int, int], control_code)\n                    term.move_cursor_to(WindowsCoordinates(row=y - 1, col=x - 1))\n                elif control_type == ControlType.CARRIAGE_RETURN:\n                    term.write_text(\"\\r\")\n                elif control_type == ControlType.HOME:\n                    term.move_cursor_to(WindowsCoordinates(0, 0))\n                elif control_type == ControlType.CURSOR_UP:\n                    term.move_cursor_up()\n                elif control_type == ControlType.CURSOR_DOWN:\n                    term.move_cursor_down()\n                elif control_type == ControlType.CURSOR_FORWARD:\n                    term.move_cursor_forward()\n                elif control_type == ControlType.CURSOR_BACKWARD:\n                    term.move_cursor_backward()\n                elif control_type == ControlType.CURSOR_MOVE_TO_COLUMN:\n                    _, column = cast(Tuple[ControlType, int], control_code)\n                    term.move_cursor_to_column(column - 1)\n                elif control_type == ControlType.HIDE_CURSOR:\n                    term.hide_cursor()\n                elif control_type == ControlType.SHOW_CURSOR:\n                    term.show_cursor()\n                elif control_type == ControlType.ERASE_IN_LINE:\n                    _, mode = cast(Tuple[ControlType, int], control_code)\n                    if mode == 0:\n                        term.erase_end_of_line()\n                    elif mode == 1:\n                        term.erase_start_of_line()\n                    elif mode == 2:\n                        term.erase_line()\n                elif control_type == ControlType.SET_WINDOW_TITLE:\n                    _, title = cast(Tuple[ControlType, str], control_code)\n                    term.set_title(title)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/_wrap.py","size":3404,"sha1":"3d22539ae35a545a372103d2e37185a368559dbe","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport re\nfrom typing import Iterable\n\nfrom ._loop import loop_last\nfrom .cells import cell_len, chop_cells\n\nre_word = re.compile(r\"\\s*\\S+\\s*\")\n\n\ndef words(text: str) -> Iterable[tuple[int, int, str]]:\n    \"\"\"Yields each word from the text as a tuple\n    containing (start_index, end_index, word). A \"word\" in this context may\n    include the actual word and any whitespace to the right.\n    \"\"\"\n    position = 0\n    word_match = re_word.match(text, position)\n    while word_match is not None:\n        start, end = word_match.span()\n        word = word_match.group(0)\n        yield start, end, word\n        word_match = re_word.match(text, end)\n\n\ndef divide_line(text: str, width: int, fold: bool = True) -> list[int]:\n    \"\"\"Given a string of text, and a width (measured in cells), return a list\n    of cell offsets which the string should be split at in order for it to fit\n    within the given width.\n\n    Args:\n        text: The text to examine.\n        width: The available cell width.\n        fold: If True, words longer than `width` will be folded onto a new line.\n\n    Returns:\n        A list of indices to break the line at.\n    \"\"\"\n    break_positions: list[int] = []  # offsets to insert the breaks at\n    append = break_positions.append\n    cell_offset = 0\n    _cell_len = cell_len\n\n    for start, _end, word in words(text):\n        word_length = _cell_len(word.rstrip())\n        remaining_space = width - cell_offset\n        word_fits_remaining_space = remaining_space >= word_length\n\n        if word_fits_remaining_space:\n            # Simplest case - the word fits within the remaining width for this line.\n            cell_offset += _cell_len(word)\n        else:\n            # Not enough space remaining for this word on the current line.\n            if word_length > width:\n                # The word doesn't fit on any line, so we can't simply\n                # place it on the next line...\n                if fold:\n                    # Fold the word across multiple lines.\n                    folded_word = chop_cells(word, width=width)\n                    for last, line in loop_last(folded_word):\n                        if start:\n                            append(start)\n                        if last:\n                            cell_offset = _cell_len(line)\n                        else:\n                            start += len(line)\n                else:\n                    # Folding isn't allowed, so crop the word.\n                    if start:\n                        append(start)\n                    cell_offset = _cell_len(word)\n            elif cell_offset and start:\n                # The word doesn't fit within the remaining space on the current\n                # line, but it *can* fit on to the next (empty) line.\n                append(start)\n                cell_offset = _cell_len(word)\n\n    return break_positions\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from .console import Console\n\n    console = Console(width=10)\n    console.print(\"12345 abcdefghijklmnopqrstuvwyxzABCDEFGHIJKLMNOPQRSTUVWXYZ 12345\")\n    print(chop_cells(\"abcdefghijklmnopqrstuvwxyz\", 10))\n\n    console = Console(width=20)\n    console.rule()\n    console.print(\"Textualã¯Pythonã®é«˜é€Ÿã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹ç™ºãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ã™\")\n\n    console.rule()\n    console.print(\"ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¯1670ä¸‡è‰²ã‚’ä½¿ç”¨ã§ã\")\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/abc.py","size":890,"sha1":"9e5742f6c5e276b656a575bd91debe5b6935ebe1","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from abc import ABC\n\n\nclass RichRenderable(ABC):\n    \"\"\"An abstract base class for Rich renderables.\n\n    Note that there is no need to extend this class, the intended use is to check if an\n    object supports the Rich renderable protocol. For example::\n\n        if isinstance(my_object, RichRenderable):\n            console.print(my_object)\n\n    \"\"\"\n\n    @classmethod\n    def __subclasshook__(cls, other: type) -> bool:\n        \"\"\"Check if this class supports the rich render protocol.\"\"\"\n        return hasattr(other, \"__rich_console__\") or hasattr(other, \"__rich__\")\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from pip._vendor.rich.text import Text\n\n    t = Text()\n    print(isinstance(Text, RichRenderable))\n    print(isinstance(t, RichRenderable))\n\n    class Foo:\n        pass\n\n    f = Foo()\n    print(isinstance(f, RichRenderable))\n    print(isinstance(\"\", RichRenderable))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/align.py","size":10469,"sha1":"891b51135b4f24a8f78e59a8f3fd749af32610a6","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\nfrom itertools import chain\nfrom typing import TYPE_CHECKING, Iterable, Optional\n\nif sys.version_info >= (3, 8):\n    from typing import Literal\nelse:\n    from pip._vendor.typing_extensions import Literal  # pragma: no cover\n\nfrom .constrain import Constrain\nfrom .jupyter import JupyterMixin\nfrom .measure import Measurement\nfrom .segment import Segment\nfrom .style import StyleType\n\nif TYPE_CHECKING:\n    from .console import Console, ConsoleOptions, RenderableType, RenderResult\n\nAlignMethod = Literal[\"left\", \"center\", \"right\"]\nVerticalAlignMethod = Literal[\"top\", \"middle\", \"bottom\"]\n\n\nclass Align(JupyterMixin):\n    \"\"\"Align a renderable by adding spaces if necessary.\n\n    Args:\n        renderable (RenderableType): A console renderable.\n        align (AlignMethod): One of \"left\", \"center\", or \"right\"\"\n        style (StyleType, optional): An optional style to apply to the background.\n        vertical (Optional[VerticalAlignMethod], optional): Optional vertical align, one of \"top\", \"middle\", or \"bottom\". Defaults to None.\n        pad (bool, optional): Pad the right with spaces. Defaults to True.\n        width (int, optional): Restrict contents to given width, or None to use default width. Defaults to None.\n        height (int, optional): Set height of align renderable, or None to fit to contents. Defaults to None.\n\n    Raises:\n        ValueError: if ``align`` is not one of the expected values.\n    \"\"\"\n\n    def __init__(\n        self,\n        renderable: \"RenderableType\",\n        align: AlignMethod = \"left\",\n        style: Optional[StyleType] = None,\n        *,\n        vertical: Optional[VerticalAlignMethod] = None,\n        pad: bool = True,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n    ) -> None:\n        if align not in (\"left\", \"center\", \"right\"):\n            raise ValueError(\n                f'invalid value for align, expected \"left\", \"center\", or \"right\" (not {align!r})'\n            )\n        if vertical is not None and vertical not in (\"top\", \"middle\", \"bottom\"):\n            raise ValueError(\n                f'invalid value for vertical, expected \"top\", \"middle\", or \"bottom\" (not {vertical!r})'\n            )\n        self.renderable = renderable\n        self.align = align\n        self.style = style\n        self.vertical = vertical\n        self.pad = pad\n        self.width = width\n        self.height = height\n\n    def __repr__(self) -> str:\n        return f\"Align({self.renderable!r}, {self.align!r})\"\n\n    @classmethod\n    def left(\n        cls,\n        renderable: \"RenderableType\",\n        style: Optional[StyleType] = None,\n        *,\n        vertical: Optional[VerticalAlignMethod] = None,\n        pad: bool = True,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n    ) -> \"Align\":\n        \"\"\"Align a renderable to the left.\"\"\"\n        return cls(\n            renderable,\n            \"left\",\n            style=style,\n            vertical=vertical,\n            pad=pad,\n            width=width,\n            height=height,\n        )\n\n    @classmethod\n    def center(\n        cls,\n        renderable: \"RenderableType\",\n        style: Optional[StyleType] = None,\n        *,\n        vertical: Optional[VerticalAlignMethod] = None,\n        pad: bool = True,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n    ) -> \"Align\":\n        \"\"\"Align a renderable to the center.\"\"\"\n        return cls(\n            renderable,\n            \"center\",\n            style=style,\n            vertical=vertical,\n            pad=pad,\n            width=width,\n            height=height,\n        )\n\n    @classmethod\n    def right(\n        cls,\n        renderable: \"RenderableType\",\n        style: Optional[StyleType] = None,\n        *,\n        vertical: Optional[VerticalAlignMethod] = None,\n        pad: bool = True,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n    ) -> \"Align\":\n        \"\"\"Align a renderable to the right.\"\"\"\n        return cls(\n            renderable,\n            \"right\",\n            style=style,\n            vertical=vertical,\n            pad=pad,\n            width=width,\n            height=height,\n        )\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        align = self.align\n        width = console.measure(self.renderable, options=options).maximum\n        rendered = console.render(\n            Constrain(\n                self.renderable, width if self.width is None else min(width, self.width)\n            ),\n            options.update(height=None),\n        )\n        lines = list(Segment.split_lines(rendered))\n        width, height = Segment.get_shape(lines)\n        lines = Segment.set_shape(lines, width, height)\n        new_line = Segment.line()\n        excess_space = options.max_width - width\n        style = console.get_style(self.style) if self.style is not None else None\n\n        def generate_segments() -> Iterable[Segment]:\n            if excess_space <= 0:\n                # Exact fit\n                for line in lines:\n                    yield from line\n                    yield new_line\n\n            elif align == \"left\":\n                # Pad on the right\n                pad = Segment(\" \" * excess_space, style) if self.pad else None\n                for line in lines:\n                    yield from line\n                    if pad:\n                        yield pad\n                    yield new_line\n\n            elif align == \"center\":\n                # Pad left and right\n                left = excess_space // 2\n                pad = Segment(\" \" * left, style)\n                pad_right = (\n                    Segment(\" \" * (excess_space - left), style) if self.pad else None\n                )\n                for line in lines:\n                    if left:\n                        yield pad\n                    yield from line\n                    if pad_right:\n                        yield pad_right\n                    yield new_line\n\n            elif align == \"right\":\n                # Padding on left\n                pad = Segment(\" \" * excess_space, style)\n                for line in lines:\n                    yield pad\n                    yield from line\n                    yield new_line\n\n        blank_line = (\n            Segment(f\"{' ' * (self.width or options.max_width)}\\n\", style)\n            if self.pad\n            else Segment(\"\\n\")\n        )\n\n        def blank_lines(count: int) -> Iterable[Segment]:\n            if count > 0:\n                for _ in range(count):\n                    yield blank_line\n\n        vertical_height = self.height or options.height\n        iter_segments: Iterable[Segment]\n        if self.vertical and vertical_height is not None:\n            if self.vertical == \"top\":\n                bottom_space = vertical_height - height\n                iter_segments = chain(generate_segments(), blank_lines(bottom_space))\n            elif self.vertical == \"middle\":\n                top_space = (vertical_height - height) // 2\n                bottom_space = vertical_height - top_space - height\n                iter_segments = chain(\n                    blank_lines(top_space),\n                    generate_segments(),\n                    blank_lines(bottom_space),\n                )\n            else:  #  self.vertical == \"bottom\":\n                top_space = vertical_height - height\n                iter_segments = chain(blank_lines(top_space), generate_segments())\n        else:\n            iter_segments = generate_segments()\n        if self.style:\n            style = console.get_style(self.style)\n            iter_segments = Segment.apply_style(iter_segments, style)\n        yield from iter_segments\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> Measurement:\n        measurement = Measurement.get(console, options, self.renderable)\n        return measurement\n\n\nclass VerticalCenter(JupyterMixin):\n    \"\"\"Vertically aligns a renderable.\n\n    Warn:\n        This class is deprecated and may be removed in a future version. Use Align class with\n        `vertical=\"middle\"`.\n\n    Args:\n        renderable (RenderableType): A renderable object.\n        style (StyleType, optional): An optional style to apply to the background. Defaults to None.\n    \"\"\"\n\n    def __init__(\n        self,\n        renderable: \"RenderableType\",\n        style: Optional[StyleType] = None,\n    ) -> None:\n        self.renderable = renderable\n        self.style = style\n\n    def __repr__(self) -> str:\n        return f\"VerticalCenter({self.renderable!r})\"\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        style = console.get_style(self.style) if self.style is not None else None\n        lines = console.render_lines(\n            self.renderable, options.update(height=None), pad=False\n        )\n        width, _height = Segment.get_shape(lines)\n        new_line = Segment.line()\n        height = options.height or options.size.height\n        top_space = (height - len(lines)) // 2\n        bottom_space = height - top_space - len(lines)\n        blank_line = Segment(f\"{' ' * width}\", style)\n\n        def blank_lines(count: int) -> Iterable[Segment]:\n            for _ in range(count):\n                yield blank_line\n                yield new_line\n\n        if top_space > 0:\n            yield from blank_lines(top_space)\n        for line in lines:\n            yield from line\n            yield new_line\n        if bottom_space > 0:\n            yield from blank_lines(bottom_space)\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> Measurement:\n        measurement = Measurement.get(console, options, self.renderable)\n        return measurement\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from pip._vendor.rich.console import Console, Group\n    from pip._vendor.rich.highlighter import ReprHighlighter\n    from pip._vendor.rich.panel import Panel\n\n    highlighter = ReprHighlighter()\n    console = Console()\n\n    panel = Panel(\n        Group(\n            Align.left(highlighter(\"align='left'\")),\n            Align.center(highlighter(\"align='center'\")),\n            Align.right(highlighter(\"align='right'\")),\n        ),\n        width=60,\n        style=\"on dark_blue\",\n        title=\"Align\",\n    )\n\n    console.print(\n        Align.center(panel, vertical=\"middle\", style=\"on red\", height=console.height)\n    )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/ansi.py","size":6921,"sha1":"127e8fa3efd6a7b8e225173c9fb278cf17c44ba8","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import re\nimport sys\nfrom contextlib import suppress\nfrom typing import Iterable, NamedTuple, Optional\n\nfrom .color import Color\nfrom .style import Style\nfrom .text import Text\n\nre_ansi = re.compile(\n    r\"\"\"\n(?:\\x1b[0-?])|\n(?:\\x1b\\](.*?)\\x1b\\\\)|\n(?:\\x1b([(@-Z\\\\-_]|\\[[0-?]*[ -/]*[@-~]))\n\"\"\",\n    re.VERBOSE,\n)\n\n\nclass _AnsiToken(NamedTuple):\n    \"\"\"Result of ansi tokenized string.\"\"\"\n\n    plain: str = \"\"\n    sgr: Optional[str] = \"\"\n    osc: Optional[str] = \"\"\n\n\ndef _ansi_tokenize(ansi_text: str) -> Iterable[_AnsiToken]:\n    \"\"\"Tokenize a string in to plain text and ANSI codes.\n\n    Args:\n        ansi_text (str): A String containing ANSI codes.\n\n    Yields:\n        AnsiToken: A named tuple of (plain, sgr, osc)\n    \"\"\"\n\n    position = 0\n    sgr: Optional[str]\n    osc: Optional[str]\n    for match in re_ansi.finditer(ansi_text):\n        start, end = match.span(0)\n        osc, sgr = match.groups()\n        if start > position:\n            yield _AnsiToken(ansi_text[position:start])\n        if sgr:\n            if sgr == \"(\":\n                position = end + 1\n                continue\n            if sgr.endswith(\"m\"):\n                yield _AnsiToken(\"\", sgr[1:-1], osc)\n        else:\n            yield _AnsiToken(\"\", sgr, osc)\n        position = end\n    if position < len(ansi_text):\n        yield _AnsiToken(ansi_text[position:])\n\n\nSGR_STYLE_MAP = {\n    1: \"bold\",\n    2: \"dim\",\n    3: \"italic\",\n    4: \"underline\",\n    5: \"blink\",\n    6: \"blink2\",\n    7: \"reverse\",\n    8: \"conceal\",\n    9: \"strike\",\n    21: \"underline2\",\n    22: \"not dim not bold\",\n    23: \"not italic\",\n    24: \"not underline\",\n    25: \"not blink\",\n    26: \"not blink2\",\n    27: \"not reverse\",\n    28: \"not conceal\",\n    29: \"not strike\",\n    30: \"color(0)\",\n    31: \"color(1)\",\n    32: \"color(2)\",\n    33: \"color(3)\",\n    34: \"color(4)\",\n    35: \"color(5)\",\n    36: \"color(6)\",\n    37: \"color(7)\",\n    39: \"default\",\n    40: \"on color(0)\",\n    41: \"on color(1)\",\n    42: \"on color(2)\",\n    43: \"on color(3)\",\n    44: \"on color(4)\",\n    45: \"on color(5)\",\n    46: \"on color(6)\",\n    47: \"on color(7)\",\n    49: \"on default\",\n    51: \"frame\",\n    52: \"encircle\",\n    53: \"overline\",\n    54: \"not frame not encircle\",\n    55: \"not overline\",\n    90: \"color(8)\",\n    91: \"color(9)\",\n    92: \"color(10)\",\n    93: \"color(11)\",\n    94: \"color(12)\",\n    95: \"color(13)\",\n    96: \"color(14)\",\n    97: \"color(15)\",\n    100: \"on color(8)\",\n    101: \"on color(9)\",\n    102: \"on color(10)\",\n    103: \"on color(11)\",\n    104: \"on color(12)\",\n    105: \"on color(13)\",\n    106: \"on color(14)\",\n    107: \"on color(15)\",\n}\n\n\nclass AnsiDecoder:\n    \"\"\"Translate ANSI code in to styled Text.\"\"\"\n\n    def __init__(self) -> None:\n        self.style = Style.null()\n\n    def decode(self, terminal_text: str) -> Iterable[Text]:\n        \"\"\"Decode ANSI codes in an iterable of lines.\n\n        Args:\n            lines (Iterable[str]): An iterable of lines of terminal output.\n\n        Yields:\n            Text: Marked up Text.\n        \"\"\"\n        for line in terminal_text.splitlines():\n            yield self.decode_line(line)\n\n    def decode_line(self, line: str) -> Text:\n        \"\"\"Decode a line containing ansi codes.\n\n        Args:\n            line (str): A line of terminal output.\n\n        Returns:\n            Text: A Text instance marked up according to ansi codes.\n        \"\"\"\n        from_ansi = Color.from_ansi\n        from_rgb = Color.from_rgb\n        _Style = Style\n        text = Text()\n        append = text.append\n        line = line.rsplit(\"\\r\", 1)[-1]\n        for plain_text, sgr, osc in _ansi_tokenize(line):\n            if plain_text:\n                append(plain_text, self.style or None)\n            elif osc is not None:\n                if osc.startswith(\"8;\"):\n                    _params, semicolon, link = osc[2:].partition(\";\")\n                    if semicolon:\n                        self.style = self.style.update_link(link or None)\n            elif sgr is not None:\n                # Translate in to semi-colon separated codes\n                # Ignore invalid codes, because we want to be lenient\n                codes = [\n                    min(255, int(_code) if _code else 0)\n                    for _code in sgr.split(\";\")\n                    if _code.isdigit() or _code == \"\"\n                ]\n                iter_codes = iter(codes)\n                for code in iter_codes:\n                    if code == 0:\n                        # reset\n                        self.style = _Style.null()\n                    elif code in SGR_STYLE_MAP:\n                        # styles\n                        self.style += _Style.parse(SGR_STYLE_MAP[code])\n                    elif code == 38:\n                        # Â Foreground\n                        with suppress(StopIteration):\n                            color_type = next(iter_codes)\n                            if color_type == 5:\n                                self.style += _Style.from_color(\n                                    from_ansi(next(iter_codes))\n                                )\n                            elif color_type == 2:\n                                self.style += _Style.from_color(\n                                    from_rgb(\n                                        next(iter_codes),\n                                        next(iter_codes),\n                                        next(iter_codes),\n                                    )\n                                )\n                    elif code == 48:\n                        # Background\n                        with suppress(StopIteration):\n                            color_type = next(iter_codes)\n                            if color_type == 5:\n                                self.style += _Style.from_color(\n                                    None, from_ansi(next(iter_codes))\n                                )\n                            elif color_type == 2:\n                                self.style += _Style.from_color(\n                                    None,\n                                    from_rgb(\n                                        next(iter_codes),\n                                        next(iter_codes),\n                                        next(iter_codes),\n                                    ),\n                                )\n\n        return text\n\n\nif sys.platform != \"win32\" and __name__ == \"__main__\":  # pragma: no cover\n    import io\n    import os\n    import pty\n    import sys\n\n    decoder = AnsiDecoder()\n\n    stdout = io.BytesIO()\n\n    def read(fd: int) -> bytes:\n        data = os.read(fd, 1024)\n        stdout.write(data)\n        return data\n\n    pty.spawn(sys.argv[1:], read)\n\n    from .console import Console\n\n    console = Console(record=True)\n\n    stdout_result = stdout.getvalue().decode(\"utf-8\")\n    print(stdout_result)\n\n    for line in decoder.decode(stdout_result):\n        console.print(line)\n\n    console.save_html(\"stdout.html\")\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/bar.py","size":3263,"sha1":"a55869f0a6fc15e21bca34654cd2a4cf41ad0d3d","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import Optional, Union\n\nfrom .color import Color\nfrom .console import Console, ConsoleOptions, RenderResult\nfrom .jupyter import JupyterMixin\nfrom .measure import Measurement\nfrom .segment import Segment\nfrom .style import Style\n\n# There are left-aligned characters for 1/8 to 7/8, but\n# the right-aligned characters exist only for 1/8 and 4/8.\nBEGIN_BLOCK_ELEMENTS = [\"â–ˆ\", \"â–ˆ\", \"â–ˆ\", \"â–\", \"â–\", \"â–\", \"â–•\", \"â–•\"]\nEND_BLOCK_ELEMENTS = [\" \", \"â–\", \"â–\", \"â–\", \"â–Œ\", \"â–‹\", \"â–Š\", \"â–‰\"]\nFULL_BLOCK = \"â–ˆ\"\n\n\nclass Bar(JupyterMixin):\n    \"\"\"Renders a solid block bar.\n\n    Args:\n        size (float): Value for the end of the bar.\n        begin (float): Begin point (between 0 and size, inclusive).\n        end (float): End point (between 0 and size, inclusive).\n        width (int, optional): Width of the bar, or ``None`` for maximum width. Defaults to None.\n        color (Union[Color, str], optional): Color of the bar. Defaults to \"default\".\n        bgcolor (Union[Color, str], optional): Color of bar background. Defaults to \"default\".\n    \"\"\"\n\n    def __init__(\n        self,\n        size: float,\n        begin: float,\n        end: float,\n        *,\n        width: Optional[int] = None,\n        color: Union[Color, str] = \"default\",\n        bgcolor: Union[Color, str] = \"default\",\n    ):\n        self.size = size\n        self.begin = max(begin, 0)\n        self.end = min(end, size)\n        self.width = width\n        self.style = Style(color=color, bgcolor=bgcolor)\n\n    def __repr__(self) -> str:\n        return f\"Bar({self.size}, {self.begin}, {self.end})\"\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        width = min(\n            self.width if self.width is not None else options.max_width,\n            options.max_width,\n        )\n\n        if self.begin >= self.end:\n            yield Segment(\" \" * width, self.style)\n            yield Segment.line()\n            return\n\n        prefix_complete_eights = int(width * 8 * self.begin / self.size)\n        prefix_bar_count = prefix_complete_eights // 8\n        prefix_eights_count = prefix_complete_eights % 8\n\n        body_complete_eights = int(width * 8 * self.end / self.size)\n        body_bar_count = body_complete_eights // 8\n        body_eights_count = body_complete_eights % 8\n\n        # When start and end fall into the same cell, we ideally should render\n        # a symbol that's \"center-aligned\", but there is no good symbol in Unicode.\n        # In this case, we fall back to right-aligned block symbol for simplicity.\n\n        prefix = \" \" * prefix_bar_count\n        if prefix_eights_count:\n            prefix += BEGIN_BLOCK_ELEMENTS[prefix_eights_count]\n\n        body = FULL_BLOCK * body_bar_count\n        if body_eights_count:\n            body += END_BLOCK_ELEMENTS[body_eights_count]\n\n        suffix = \" \" * (width - len(body))\n\n        yield Segment(prefix + body[len(prefix) :] + suffix, self.style)\n        yield Segment.line()\n\n    def __rich_measure__(\n        self, console: Console, options: ConsoleOptions\n    ) -> Measurement:\n        return (\n            Measurement(self.width, self.width)\n            if self.width is not None\n            else Measurement(4, options.max_width)\n        )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/box.py","size":10831,"sha1":"b5786aadcb6ad27589c4ef5cf5833ea8b95a4601","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\nfrom typing import TYPE_CHECKING, Iterable, List\n\nif sys.version_info >= (3, 8):\n    from typing import Literal\nelse:\n    from pip._vendor.typing_extensions import Literal  # pragma: no cover\n\n\nfrom ._loop import loop_last\n\nif TYPE_CHECKING:\n    from pip._vendor.rich.console import ConsoleOptions\n\n\nclass Box:\n    \"\"\"Defines characters to render boxes.\n\n    â”Œâ”€â”¬â” top\n    â”‚ â”‚â”‚ head\n    â”œâ”€â”¼â”¤ head_row\n    â”‚ â”‚â”‚ mid\n    â”œâ”€â”¼â”¤ row\n    â”œâ”€â”¼â”¤ foot_row\n    â”‚ â”‚â”‚ foot\n    â””â”€â”´â”˜ bottom\n\n    Args:\n        box (str): Characters making up box.\n        ascii (bool, optional): True if this box uses ascii characters only. Default is False.\n    \"\"\"\n\n    def __init__(self, box: str, *, ascii: bool = False) -> None:\n        self._box = box\n        self.ascii = ascii\n        line1, line2, line3, line4, line5, line6, line7, line8 = box.splitlines()\n        # top\n        self.top_left, self.top, self.top_divider, self.top_right = iter(line1)\n        # head\n        self.head_left, _, self.head_vertical, self.head_right = iter(line2)\n        # head_row\n        (\n            self.head_row_left,\n            self.head_row_horizontal,\n            self.head_row_cross,\n            self.head_row_right,\n        ) = iter(line3)\n\n        # mid\n        self.mid_left, _, self.mid_vertical, self.mid_right = iter(line4)\n        # row\n        self.row_left, self.row_horizontal, self.row_cross, self.row_right = iter(line5)\n        # foot_row\n        (\n            self.foot_row_left,\n            self.foot_row_horizontal,\n            self.foot_row_cross,\n            self.foot_row_right,\n        ) = iter(line6)\n        # foot\n        self.foot_left, _, self.foot_vertical, self.foot_right = iter(line7)\n        # bottom\n        self.bottom_left, self.bottom, self.bottom_divider, self.bottom_right = iter(\n            line8\n        )\n\n    def __repr__(self) -> str:\n        return \"Box(...)\"\n\n    def __str__(self) -> str:\n        return self._box\n\n    def substitute(self, options: \"ConsoleOptions\", safe: bool = True) -> \"Box\":\n        \"\"\"Substitute this box for another if it won't render due to platform issues.\n\n        Args:\n            options (ConsoleOptions): Console options used in rendering.\n            safe (bool, optional): Substitute this for another Box if there are known problems\n                displaying on the platform (currently only relevant on Windows). Default is True.\n\n        Returns:\n            Box: A different Box or the same Box.\n        \"\"\"\n        box = self\n        if options.legacy_windows and safe:\n            box = LEGACY_WINDOWS_SUBSTITUTIONS.get(box, box)\n        if options.ascii_only and not box.ascii:\n            box = ASCII\n        return box\n\n    def get_plain_headed_box(self) -> \"Box\":\n        \"\"\"If this box uses special characters for the borders of the header, then\n        return the equivalent box that does not.\n\n        Returns:\n            Box: The most similar Box that doesn't use header-specific box characters.\n                If the current Box already satisfies this criterion, then it's returned.\n        \"\"\"\n        return PLAIN_HEADED_SUBSTITUTIONS.get(self, self)\n\n    def get_top(self, widths: Iterable[int]) -> str:\n        \"\"\"Get the top of a simple box.\n\n        Args:\n            widths (List[int]): Widths of columns.\n\n        Returns:\n            str: A string of box characters.\n        \"\"\"\n\n        parts: List[str] = []\n        append = parts.append\n        append(self.top_left)\n        for last, width in loop_last(widths):\n            append(self.top * width)\n            if not last:\n                append(self.top_divider)\n        append(self.top_right)\n        return \"\".join(parts)\n\n    def get_row(\n        self,\n        widths: Iterable[int],\n        level: Literal[\"head\", \"row\", \"foot\", \"mid\"] = \"row\",\n        edge: bool = True,\n    ) -> str:\n        \"\"\"Get the top of a simple box.\n\n        Args:\n            width (List[int]): Widths of columns.\n\n        Returns:\n            str: A string of box characters.\n        \"\"\"\n        if level == \"head\":\n            left = self.head_row_left\n            horizontal = self.head_row_horizontal\n            cross = self.head_row_cross\n            right = self.head_row_right\n        elif level == \"row\":\n            left = self.row_left\n            horizontal = self.row_horizontal\n            cross = self.row_cross\n            right = self.row_right\n        elif level == \"mid\":\n            left = self.mid_left\n            horizontal = \" \"\n            cross = self.mid_vertical\n            right = self.mid_right\n        elif level == \"foot\":\n            left = self.foot_row_left\n            horizontal = self.foot_row_horizontal\n            cross = self.foot_row_cross\n            right = self.foot_row_right\n        else:\n            raise ValueError(\"level must be 'head', 'row' or 'foot'\")\n\n        parts: List[str] = []\n        append = parts.append\n        if edge:\n            append(left)\n        for last, width in loop_last(widths):\n            append(horizontal * width)\n            if not last:\n                append(cross)\n        if edge:\n            append(right)\n        return \"\".join(parts)\n\n    def get_bottom(self, widths: Iterable[int]) -> str:\n        \"\"\"Get the bottom of a simple box.\n\n        Args:\n            widths (List[int]): Widths of columns.\n\n        Returns:\n            str: A string of box characters.\n        \"\"\"\n\n        parts: List[str] = []\n        append = parts.append\n        append(self.bottom_left)\n        for last, width in loop_last(widths):\n            append(self.bottom * width)\n            if not last:\n                append(self.bottom_divider)\n        append(self.bottom_right)\n        return \"\".join(parts)\n\n\n# fmt: off\nASCII: Box = Box(\n    \"+--+\\n\"\n    \"| ||\\n\"\n    \"|-+|\\n\"\n    \"| ||\\n\"\n    \"|-+|\\n\"\n    \"|-+|\\n\"\n    \"| ||\\n\"\n    \"+--+\\n\",\n    ascii=True,\n)\n\nASCII2: Box = Box(\n    \"+-++\\n\"\n    \"| ||\\n\"\n    \"+-++\\n\"\n    \"| ||\\n\"\n    \"+-++\\n\"\n    \"+-++\\n\"\n    \"| ||\\n\"\n    \"+-++\\n\",\n    ascii=True,\n)\n\nASCII_DOUBLE_HEAD: Box = Box(\n    \"+-++\\n\"\n    \"| ||\\n\"\n    \"+=++\\n\"\n    \"| ||\\n\"\n    \"+-++\\n\"\n    \"+-++\\n\"\n    \"| ||\\n\"\n    \"+-++\\n\",\n    ascii=True,\n)\n\nSQUARE: Box = Box(\n    \"â”Œâ”€â”¬â”\\n\"\n    \"â”‚ â”‚â”‚\\n\"\n    \"â”œâ”€â”¼â”¤\\n\"\n    \"â”‚ â”‚â”‚\\n\"\n    \"â”œâ”€â”¼â”¤\\n\"\n    \"â”œâ”€â”¼â”¤\\n\"\n    \"â”‚ â”‚â”‚\\n\"\n    \"â””â”€â”´â”˜\\n\"\n)\n\nSQUARE_DOUBLE_HEAD: Box = Box(\n    \"â”Œâ”€â”¬â”\\n\"\n    \"â”‚ â”‚â”‚\\n\"\n    \"â•â•â•ªâ•¡\\n\"\n    \"â”‚ â”‚â”‚\\n\"\n    \"â”œâ”€â”¼â”¤\\n\"\n    \"â”œâ”€â”¼â”¤\\n\"\n    \"â”‚ â”‚â”‚\\n\"\n    \"â””â”€â”´â”˜\\n\"\n)\n\nMINIMAL: Box = Box(\n    \"  â•· \\n\"\n    \"  â”‚ \\n\"\n    \"â•¶â”€â”¼â•´\\n\"\n    \"  â”‚ \\n\"\n    \"â•¶â”€â”¼â•´\\n\"\n    \"â•¶â”€â”¼â•´\\n\"\n    \"  â”‚ \\n\"\n    \"  â•µ \\n\"\n)\n\n\nMINIMAL_HEAVY_HEAD: Box = Box(\n    \"  â•· \\n\"\n    \"  â”‚ \\n\"\n    \"â•ºâ”â”¿â•¸\\n\"\n    \"  â”‚ \\n\"\n    \"â•¶â”€â”¼â•´\\n\"\n    \"â•¶â”€â”¼â•´\\n\"\n    \"  â”‚ \\n\"\n    \"  â•µ \\n\"\n)\n\nMINIMAL_DOUBLE_HEAD: Box = Box(\n    \"  â•· \\n\"\n    \"  â”‚ \\n\"\n    \" â•â•ª \\n\"\n    \"  â”‚ \\n\"\n    \" â”€â”¼ \\n\"\n    \" â”€â”¼ \\n\"\n    \"  â”‚ \\n\"\n    \"  â•µ \\n\"\n)\n\n\nSIMPLE: Box = Box(\n    \"    \\n\"\n    \"    \\n\"\n    \" â”€â”€ \\n\"\n    \"    \\n\"\n    \"    \\n\"\n    \" â”€â”€ \\n\"\n    \"    \\n\"\n    \"    \\n\"\n)\n\nSIMPLE_HEAD: Box = Box(\n    \"    \\n\"\n    \"    \\n\"\n    \" â”€â”€ \\n\"\n    \"    \\n\"\n    \"    \\n\"\n    \"    \\n\"\n    \"    \\n\"\n    \"    \\n\"\n)\n\n\nSIMPLE_HEAVY: Box = Box(\n    \"    \\n\"\n    \"    \\n\"\n    \" â”â” \\n\"\n    \"    \\n\"\n    \"    \\n\"\n    \" â”â” \\n\"\n    \"    \\n\"\n    \"    \\n\"\n)\n\n\nHORIZONTALS: Box = Box(\n    \" â”€â”€ \\n\"\n    \"    \\n\"\n    \" â”€â”€ \\n\"\n    \"    \\n\"\n    \" â”€â”€ \\n\"\n    \" â”€â”€ \\n\"\n    \"    \\n\"\n    \" â”€â”€ \\n\"\n)\n\nROUNDED: Box = Box(\n    \"â•­â”€â”¬â•®\\n\"\n    \"â”‚ â”‚â”‚\\n\"\n    \"â”œâ”€â”¼â”¤\\n\"\n    \"â”‚ â”‚â”‚\\n\"\n    \"â”œâ”€â”¼â”¤\\n\"\n    \"â”œâ”€â”¼â”¤\\n\"\n    \"â”‚ â”‚â”‚\\n\"\n    \"â•°â”€â”´â•¯\\n\"\n)\n\nHEAVY: Box = Box(\n    \"â”â”â”³â”“\\n\"\n    \"â”ƒ â”ƒâ”ƒ\\n\"\n    \"â”£â”â•‹â”«\\n\"\n    \"â”ƒ â”ƒâ”ƒ\\n\"\n    \"â”£â”â•‹â”«\\n\"\n    \"â”£â”â•‹â”«\\n\"\n    \"â”ƒ â”ƒâ”ƒ\\n\"\n    \"â”—â”â”»â”›\\n\"\n)\n\nHEAVY_EDGE: Box = Box(\n    \"â”â”â”¯â”“\\n\"\n    \"â”ƒ â”‚â”ƒ\\n\"\n    \"â” â”€â”¼â”¨\\n\"\n    \"â”ƒ â”‚â”ƒ\\n\"\n    \"â” â”€â”¼â”¨\\n\"\n    \"â” â”€â”¼â”¨\\n\"\n    \"â”ƒ â”‚â”ƒ\\n\"\n    \"â”—â”â”·â”›\\n\"\n)\n\nHEAVY_HEAD: Box = Box(\n    \"â”â”â”³â”“\\n\"\n    \"â”ƒ â”ƒâ”ƒ\\n\"\n    \"â”¡â”â•‡â”©\\n\"\n    \"â”‚ â”‚â”‚\\n\"\n    \"â”œâ”€â”¼â”¤\\n\"\n    \"â”œâ”€â”¼â”¤\\n\"\n    \"â”‚ â”‚â”‚\\n\"\n    \"â””â”€â”´â”˜\\n\"\n)\n\nDOUBLE: Box = Box(\n    \"â•”â•â•¦â•—\\n\"\n    \"â•‘ â•‘â•‘\\n\"\n    \"â• â•â•¬â•£\\n\"\n    \"â•‘ â•‘â•‘\\n\"\n    \"â• â•â•¬â•£\\n\"\n    \"â• â•â•¬â•£\\n\"\n    \"â•‘ â•‘â•‘\\n\"\n    \"â•šâ•â•©â•\\n\"\n)\n\nDOUBLE_EDGE: Box = Box(\n    \"â•”â•â•¤â•—\\n\"\n    \"â•‘ â”‚â•‘\\n\"\n    \"â•Ÿâ”€â”¼â•¢\\n\"\n    \"â•‘ â”‚â•‘\\n\"\n    \"â•Ÿâ”€â”¼â•¢\\n\"\n    \"â•Ÿâ”€â”¼â•¢\\n\"\n    \"â•‘ â”‚â•‘\\n\"\n    \"â•šâ•â•§â•\\n\"\n)\n\nMARKDOWN: Box = Box(\n    \"    \\n\"\n    \"| ||\\n\"\n    \"|-||\\n\"\n    \"| ||\\n\"\n    \"|-||\\n\"\n    \"|-||\\n\"\n    \"| ||\\n\"\n    \"    \\n\",\n    ascii=True,\n)\n# fmt: on\n\n# Map Boxes that don't render with raster fonts on to equivalent that do\nLEGACY_WINDOWS_SUBSTITUTIONS = {\n    ROUNDED: SQUARE,\n    MINIMAL_HEAVY_HEAD: MINIMAL,\n    SIMPLE_HEAVY: SIMPLE,\n    HEAVY: SQUARE,\n    HEAVY_EDGE: SQUARE,\n    HEAVY_HEAD: SQUARE,\n}\n\n# Map headed boxes to their headerless equivalents\nPLAIN_HEADED_SUBSTITUTIONS = {\n    HEAVY_HEAD: SQUARE,\n    SQUARE_DOUBLE_HEAD: SQUARE,\n    MINIMAL_DOUBLE_HEAD: MINIMAL,\n    MINIMAL_HEAVY_HEAD: MINIMAL,\n    ASCII_DOUBLE_HEAD: ASCII2,\n}\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from pip._vendor.rich.columns import Columns\n    from pip._vendor.rich.panel import Panel\n\n    from . import box as box\n    from .console import Console\n    from .table import Table\n    from .text import Text\n\n    console = Console(record=True)\n\n    BOXES = [\n        \"ASCII\",\n        \"ASCII2\",\n        \"ASCII_DOUBLE_HEAD\",\n        \"SQUARE\",\n        \"SQUARE_DOUBLE_HEAD\",\n        \"MINIMAL\",\n        \"MINIMAL_HEAVY_HEAD\",\n        \"MINIMAL_DOUBLE_HEAD\",\n        \"SIMPLE\",\n        \"SIMPLE_HEAD\",\n        \"SIMPLE_HEAVY\",\n        \"HORIZONTALS\",\n        \"ROUNDED\",\n        \"HEAVY\",\n        \"HEAVY_EDGE\",\n        \"HEAVY_HEAD\",\n        \"DOUBLE\",\n        \"DOUBLE_EDGE\",\n        \"MARKDOWN\",\n    ]\n\n    console.print(Panel(\"[bold green]Box Constants\", style=\"green\"), justify=\"center\")\n    console.print()\n\n    columns = Columns(expand=True, padding=2)\n    for box_name in sorted(BOXES):\n        table = Table(\n            show_footer=True, style=\"dim\", border_style=\"not dim\", expand=True\n        )\n        table.add_column(\"Header 1\", \"Footer 1\")\n        table.add_column(\"Header 2\", \"Footer 2\")\n        table.add_row(\"Cell\", \"Cell\")\n        table.add_row(\"Cell\", \"Cell\")\n        table.box = getattr(box, box_name)\n        table.title = Text(f\"box.{box_name}\", style=\"magenta\")\n        columns.add_renderable(table)\n    console.print(columns)\n\n    # console.save_svg(\"box.svg\")\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/cells.py","size":5130,"sha1":"f0bdec5436edb71a8c33c0a7b4e5ce75c754f87f","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nfrom functools import lru_cache\nfrom typing import Callable\n\nfrom ._cell_widths import CELL_WIDTHS\n\n# Ranges of unicode ordinals that produce a 1-cell wide character\n# This is non-exhaustive, but covers most common Western characters\n_SINGLE_CELL_UNICODE_RANGES: list[tuple[int, int]] = [\n    (0x20, 0x7E),  # Latin (excluding non-printable)\n    (0xA0, 0xAC),\n    (0xAE, 0x002FF),\n    (0x00370, 0x00482),  # Greek / Cyrillic\n    (0x02500, 0x025FC),  # Box drawing, box elements, geometric shapes\n    (0x02800, 0x028FF),  # Braille\n]\n\n# A set of characters that are a single cell wide\n_SINGLE_CELLS = frozenset(\n    [\n        character\n        for _start, _end in _SINGLE_CELL_UNICODE_RANGES\n        for character in map(chr, range(_start, _end + 1))\n    ]\n)\n\n# When called with a string this will return True if all\n# characters are single-cell, otherwise False\n_is_single_cell_widths: Callable[[str], bool] = _SINGLE_CELLS.issuperset\n\n\n@lru_cache(4096)\ndef cached_cell_len(text: str) -> int:\n    \"\"\"Get the number of cells required to display text.\n\n    This method always caches, which may use up a lot of memory. It is recommended to use\n    `cell_len` over this method.\n\n    Args:\n        text (str): Text to display.\n\n    Returns:\n        int: Get the number of cells required to display text.\n    \"\"\"\n    if _is_single_cell_widths(text):\n        return len(text)\n    return sum(map(get_character_cell_size, text))\n\n\ndef cell_len(text: str, _cell_len: Callable[[str], int] = cached_cell_len) -> int:\n    \"\"\"Get the number of cells required to display text.\n\n    Args:\n        text (str): Text to display.\n\n    Returns:\n        int: Get the number of cells required to display text.\n    \"\"\"\n    if len(text) < 512:\n        return _cell_len(text)\n    if _is_single_cell_widths(text):\n        return len(text)\n    return sum(map(get_character_cell_size, text))\n\n\n@lru_cache(maxsize=4096)\ndef get_character_cell_size(character: str) -> int:\n    \"\"\"Get the cell size of a character.\n\n    Args:\n        character (str): A single character.\n\n    Returns:\n        int: Number of cells (0, 1 or 2) occupied by that character.\n    \"\"\"\n    codepoint = ord(character)\n    _table = CELL_WIDTHS\n    lower_bound = 0\n    upper_bound = len(_table) - 1\n    index = (lower_bound + upper_bound) // 2\n    while True:\n        start, end, width = _table[index]\n        if codepoint < start:\n            upper_bound = index - 1\n        elif codepoint > end:\n            lower_bound = index + 1\n        else:\n            return 0 if width == -1 else width\n        if upper_bound < lower_bound:\n            break\n        index = (lower_bound + upper_bound) // 2\n    return 1\n\n\ndef set_cell_size(text: str, total: int) -> str:\n    \"\"\"Set the length of a string to fit within given number of cells.\"\"\"\n\n    if _is_single_cell_widths(text):\n        size = len(text)\n        if size < total:\n            return text + \" \" * (total - size)\n        return text[:total]\n\n    if total <= 0:\n        return \"\"\n    cell_size = cell_len(text)\n    if cell_size == total:\n        return text\n    if cell_size < total:\n        return text + \" \" * (total - cell_size)\n\n    start = 0\n    end = len(text)\n\n    # Binary search until we find the right size\n    while True:\n        pos = (start + end) // 2\n        before = text[: pos + 1]\n        before_len = cell_len(before)\n        if before_len == total + 1 and cell_len(before[-1]) == 2:\n            return before[:-1] + \" \"\n        if before_len == total:\n            return before\n        if before_len > total:\n            end = pos\n        else:\n            start = pos\n\n\ndef chop_cells(\n    text: str,\n    width: int,\n) -> list[str]:\n    \"\"\"Split text into lines such that each line fits within the available (cell) width.\n\n    Args:\n        text: The text to fold such that it fits in the given width.\n        width: The width available (number of cells).\n\n    Returns:\n        A list of strings such that each string in the list has cell width\n        less than or equal to the available width.\n    \"\"\"\n    _get_character_cell_size = get_character_cell_size\n    lines: list[list[str]] = [[]]\n\n    append_new_line = lines.append\n    append_to_last_line = lines[-1].append\n\n    total_width = 0\n\n    for character in text:\n        cell_width = _get_character_cell_size(character)\n        char_doesnt_fit = total_width + cell_width > width\n\n        if char_doesnt_fit:\n            append_new_line([character])\n            append_to_last_line = lines[-1].append\n            total_width = cell_width\n        else:\n            append_to_last_line(character)\n            total_width += cell_width\n\n    return [\"\".join(line) for line in lines]\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    print(get_character_cell_size(\"ğŸ˜½\"))\n    for line in chop_cells(\"\"\"è¿™æ˜¯å¯¹äºšæ´²è¯­è¨€æ”¯æŒçš„æµ‹è¯•ã€‚é¢å¯¹æ¨¡æ£±ä¸¤å¯çš„æƒ³æ³•ï¼Œæ‹’ç»çŒœæµ‹çš„è¯±æƒ‘ã€‚\"\"\", 8):\n        print(line)\n    for n in range(80, 1, -1):\n        print(set_cell_size(\"\"\"è¿™æ˜¯å¯¹äºšæ´²è¯­è¨€æ”¯æŒçš„æµ‹è¯•ã€‚é¢å¯¹æ¨¡æ£±ä¸¤å¯çš„æƒ³æ³•ï¼Œæ‹’ç»çŒœæµ‹çš„è¯±æƒ‘ã€‚\"\"\", n) + \"|\")\n        print(\"x\" * n)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/color.py","size":18211,"sha1":"a4cb4dba1139fd8bdcadbd1c3d271e26992cc342","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import re\nimport sys\nfrom colorsys import rgb_to_hls\nfrom enum import IntEnum\nfrom functools import lru_cache\nfrom typing import TYPE_CHECKING, NamedTuple, Optional, Tuple\n\nfrom ._palettes import EIGHT_BIT_PALETTE, STANDARD_PALETTE, WINDOWS_PALETTE\nfrom .color_triplet import ColorTriplet\nfrom .repr import Result, rich_repr\nfrom .terminal_theme import DEFAULT_TERMINAL_THEME\n\nif TYPE_CHECKING:  # pragma: no cover\n    from .terminal_theme import TerminalTheme\n    from .text import Text\n\n\nWINDOWS = sys.platform == \"win32\"\n\n\nclass ColorSystem(IntEnum):\n    \"\"\"One of the 3 color system supported by terminals.\"\"\"\n\n    STANDARD = 1\n    EIGHT_BIT = 2\n    TRUECOLOR = 3\n    WINDOWS = 4\n\n    def __repr__(self) -> str:\n        return f\"ColorSystem.{self.name}\"\n\n    def __str__(self) -> str:\n        return repr(self)\n\n\nclass ColorType(IntEnum):\n    \"\"\"Type of color stored in Color class.\"\"\"\n\n    DEFAULT = 0\n    STANDARD = 1\n    EIGHT_BIT = 2\n    TRUECOLOR = 3\n    WINDOWS = 4\n\n    def __repr__(self) -> str:\n        return f\"ColorType.{self.name}\"\n\n\nANSI_COLOR_NAMES = {\n    \"black\": 0,\n    \"red\": 1,\n    \"green\": 2,\n    \"yellow\": 3,\n    \"blue\": 4,\n    \"magenta\": 5,\n    \"cyan\": 6,\n    \"white\": 7,\n    \"bright_black\": 8,\n    \"bright_red\": 9,\n    \"bright_green\": 10,\n    \"bright_yellow\": 11,\n    \"bright_blue\": 12,\n    \"bright_magenta\": 13,\n    \"bright_cyan\": 14,\n    \"bright_white\": 15,\n    \"grey0\": 16,\n    \"gray0\": 16,\n    \"navy_blue\": 17,\n    \"dark_blue\": 18,\n    \"blue3\": 20,\n    \"blue1\": 21,\n    \"dark_green\": 22,\n    \"deep_sky_blue4\": 25,\n    \"dodger_blue3\": 26,\n    \"dodger_blue2\": 27,\n    \"green4\": 28,\n    \"spring_green4\": 29,\n    \"turquoise4\": 30,\n    \"deep_sky_blue3\": 32,\n    \"dodger_blue1\": 33,\n    \"green3\": 40,\n    \"spring_green3\": 41,\n    \"dark_cyan\": 36,\n    \"light_sea_green\": 37,\n    \"deep_sky_blue2\": 38,\n    \"deep_sky_blue1\": 39,\n    \"spring_green2\": 47,\n    \"cyan3\": 43,\n    \"dark_turquoise\": 44,\n    \"turquoise2\": 45,\n    \"green1\": 46,\n    \"spring_green1\": 48,\n    \"medium_spring_green\": 49,\n    \"cyan2\": 50,\n    \"cyan1\": 51,\n    \"dark_red\": 88,\n    \"deep_pink4\": 125,\n    \"purple4\": 55,\n    \"purple3\": 56,\n    \"blue_violet\": 57,\n    \"orange4\": 94,\n    \"grey37\": 59,\n    \"gray37\": 59,\n    \"medium_purple4\": 60,\n    \"slate_blue3\": 62,\n    \"royal_blue1\": 63,\n    \"chartreuse4\": 64,\n    \"dark_sea_green4\": 71,\n    \"pale_turquoise4\": 66,\n    \"steel_blue\": 67,\n    \"steel_blue3\": 68,\n    \"cornflower_blue\": 69,\n    \"chartreuse3\": 76,\n    \"cadet_blue\": 73,\n    \"sky_blue3\": 74,\n    \"steel_blue1\": 81,\n    \"pale_green3\": 114,\n    \"sea_green3\": 78,\n    \"aquamarine3\": 79,\n    \"medium_turquoise\": 80,\n    \"chartreuse2\": 112,\n    \"sea_green2\": 83,\n    \"sea_green1\": 85,\n    \"aquamarine1\": 122,\n    \"dark_slate_gray2\": 87,\n    \"dark_magenta\": 91,\n    \"dark_violet\": 128,\n    \"purple\": 129,\n    \"light_pink4\": 95,\n    \"plum4\": 96,\n    \"medium_purple3\": 98,\n    \"slate_blue1\": 99,\n    \"yellow4\": 106,\n    \"wheat4\": 101,\n    \"grey53\": 102,\n    \"gray53\": 102,\n    \"light_slate_grey\": 103,\n    \"light_slate_gray\": 103,\n    \"medium_purple\": 104,\n    \"light_slate_blue\": 105,\n    \"dark_olive_green3\": 149,\n    \"dark_sea_green\": 108,\n    \"light_sky_blue3\": 110,\n    \"sky_blue2\": 111,\n    \"dark_sea_green3\": 150,\n    \"dark_slate_gray3\": 116,\n    \"sky_blue1\": 117,\n    \"chartreuse1\": 118,\n    \"light_green\": 120,\n    \"pale_green1\": 156,\n    \"dark_slate_gray1\": 123,\n    \"red3\": 160,\n    \"medium_violet_red\": 126,\n    \"magenta3\": 164,\n    \"dark_orange3\": 166,\n    \"indian_red\": 167,\n    \"hot_pink3\": 168,\n    \"medium_orchid3\": 133,\n    \"medium_orchid\": 134,\n    \"medium_purple2\": 140,\n    \"dark_goldenrod\": 136,\n    \"light_salmon3\": 173,\n    \"rosy_brown\": 138,\n    \"grey63\": 139,\n    \"gray63\": 139,\n    \"medium_purple1\": 141,\n    \"gold3\": 178,\n    \"dark_khaki\": 143,\n    \"navajo_white3\": 144,\n    \"grey69\": 145,\n    \"gray69\": 145,\n    \"light_steel_blue3\": 146,\n    \"light_steel_blue\": 147,\n    \"yellow3\": 184,\n    \"dark_sea_green2\": 157,\n    \"light_cyan3\": 152,\n    \"light_sky_blue1\": 153,\n    \"green_yellow\": 154,\n    \"dark_olive_green2\": 155,\n    \"dark_sea_green1\": 193,\n    \"pale_turquoise1\": 159,\n    \"deep_pink3\": 162,\n    \"magenta2\": 200,\n    \"hot_pink2\": 169,\n    \"orchid\": 170,\n    \"medium_orchid1\": 207,\n    \"orange3\": 172,\n    \"light_pink3\": 174,\n    \"pink3\": 175,\n    \"plum3\": 176,\n    \"violet\": 177,\n    \"light_goldenrod3\": 179,\n    \"tan\": 180,\n    \"misty_rose3\": 181,\n    \"thistle3\": 182,\n    \"plum2\": 183,\n    \"khaki3\": 185,\n    \"light_goldenrod2\": 222,\n    \"light_yellow3\": 187,\n    \"grey84\": 188,\n    \"gray84\": 188,\n    \"light_steel_blue1\": 189,\n    \"yellow2\": 190,\n    \"dark_olive_green1\": 192,\n    \"honeydew2\": 194,\n    \"light_cyan1\": 195,\n    \"red1\": 196,\n    \"deep_pink2\": 197,\n    \"deep_pink1\": 199,\n    \"magenta1\": 201,\n    \"orange_red1\": 202,\n    \"indian_red1\": 204,\n    \"hot_pink\": 206,\n    \"dark_orange\": 208,\n    \"salmon1\": 209,\n    \"light_coral\": 210,\n    \"pale_violet_red1\": 211,\n    \"orchid2\": 212,\n    \"orchid1\": 213,\n    \"orange1\": 214,\n    \"sandy_brown\": 215,\n    \"light_salmon1\": 216,\n    \"light_pink1\": 217,\n    \"pink1\": 218,\n    \"plum1\": 219,\n    \"gold1\": 220,\n    \"navajo_white1\": 223,\n    \"misty_rose1\": 224,\n    \"thistle1\": 225,\n    \"yellow1\": 226,\n    \"light_goldenrod1\": 227,\n    \"khaki1\": 228,\n    \"wheat1\": 229,\n    \"cornsilk1\": 230,\n    \"grey100\": 231,\n    \"gray100\": 231,\n    \"grey3\": 232,\n    \"gray3\": 232,\n    \"grey7\": 233,\n    \"gray7\": 233,\n    \"grey11\": 234,\n    \"gray11\": 234,\n    \"grey15\": 235,\n    \"gray15\": 235,\n    \"grey19\": 236,\n    \"gray19\": 236,\n    \"grey23\": 237,\n    \"gray23\": 237,\n    \"grey27\": 238,\n    \"gray27\": 238,\n    \"grey30\": 239,\n    \"gray30\": 239,\n    \"grey35\": 240,\n    \"gray35\": 240,\n    \"grey39\": 241,\n    \"gray39\": 241,\n    \"grey42\": 242,\n    \"gray42\": 242,\n    \"grey46\": 243,\n    \"gray46\": 243,\n    \"grey50\": 244,\n    \"gray50\": 244,\n    \"grey54\": 245,\n    \"gray54\": 245,\n    \"grey58\": 246,\n    \"gray58\": 246,\n    \"grey62\": 247,\n    \"gray62\": 247,\n    \"grey66\": 248,\n    \"gray66\": 248,\n    \"grey70\": 249,\n    \"gray70\": 249,\n    \"grey74\": 250,\n    \"gray74\": 250,\n    \"grey78\": 251,\n    \"gray78\": 251,\n    \"grey82\": 252,\n    \"gray82\": 252,\n    \"grey85\": 253,\n    \"gray85\": 253,\n    \"grey89\": 254,\n    \"gray89\": 254,\n    \"grey93\": 255,\n    \"gray93\": 255,\n}\n\n\nclass ColorParseError(Exception):\n    \"\"\"The color could not be parsed.\"\"\"\n\n\nRE_COLOR = re.compile(\n    r\"\"\"^\n\\#([0-9a-f]{6})$|\ncolor\\(([0-9]{1,3})\\)$|\nrgb\\(([\\d\\s,]+)\\)$\n\"\"\",\n    re.VERBOSE,\n)\n\n\n@rich_repr\nclass Color(NamedTuple):\n    \"\"\"Terminal color definition.\"\"\"\n\n    name: str\n    \"\"\"The name of the color (typically the input to Color.parse).\"\"\"\n    type: ColorType\n    \"\"\"The type of the color.\"\"\"\n    number: Optional[int] = None\n    \"\"\"The color number, if a standard color, or None.\"\"\"\n    triplet: Optional[ColorTriplet] = None\n    \"\"\"A triplet of color components, if an RGB color.\"\"\"\n\n    def __rich__(self) -> \"Text\":\n        \"\"\"Displays the actual color if Rich printed.\"\"\"\n        from .style import Style\n        from .text import Text\n\n        return Text.assemble(\n            f\"<color {self.name!r} ({self.type.name.lower()})\",\n            (\"â¬¤\", Style(color=self)),\n            \" >\",\n        )\n\n    def __rich_repr__(self) -> Result:\n        yield self.name\n        yield self.type\n        yield \"number\", self.number, None\n        yield \"triplet\", self.triplet, None\n\n    @property\n    def system(self) -> ColorSystem:\n        \"\"\"Get the native color system for this color.\"\"\"\n        if self.type == ColorType.DEFAULT:\n            return ColorSystem.STANDARD\n        return ColorSystem(int(self.type))\n\n    @property\n    def is_system_defined(self) -> bool:\n        \"\"\"Check if the color is ultimately defined by the system.\"\"\"\n        return self.system not in (ColorSystem.EIGHT_BIT, ColorSystem.TRUECOLOR)\n\n    @property\n    def is_default(self) -> bool:\n        \"\"\"Check if the color is a default color.\"\"\"\n        return self.type == ColorType.DEFAULT\n\n    def get_truecolor(\n        self, theme: Optional[\"TerminalTheme\"] = None, foreground: bool = True\n    ) -> ColorTriplet:\n        \"\"\"Get an equivalent color triplet for this color.\n\n        Args:\n            theme (TerminalTheme, optional): Optional terminal theme, or None to use default. Defaults to None.\n            foreground (bool, optional): True for a foreground color, or False for background. Defaults to True.\n\n        Returns:\n            ColorTriplet: A color triplet containing RGB components.\n        \"\"\"\n\n        if theme is None:\n            theme = DEFAULT_TERMINAL_THEME\n        if self.type == ColorType.TRUECOLOR:\n            assert self.triplet is not None\n            return self.triplet\n        elif self.type == ColorType.EIGHT_BIT:\n            assert self.number is not None\n            return EIGHT_BIT_PALETTE[self.number]\n        elif self.type == ColorType.STANDARD:\n            assert self.number is not None\n            return theme.ansi_colors[self.number]\n        elif self.type == ColorType.WINDOWS:\n            assert self.number is not None\n            return WINDOWS_PALETTE[self.number]\n        else:  # self.type == ColorType.DEFAULT:\n            assert self.number is None\n            return theme.foreground_color if foreground else theme.background_color\n\n    @classmethod\n    def from_ansi(cls, number: int) -> \"Color\":\n        \"\"\"Create a Color number from it's 8-bit ansi number.\n\n        Args:\n            number (int): A number between 0-255 inclusive.\n\n        Returns:\n            Color: A new Color instance.\n        \"\"\"\n        return cls(\n            name=f\"color({number})\",\n            type=(ColorType.STANDARD if number < 16 else ColorType.EIGHT_BIT),\n            number=number,\n        )\n\n    @classmethod\n    def from_triplet(cls, triplet: \"ColorTriplet\") -> \"Color\":\n        \"\"\"Create a truecolor RGB color from a triplet of values.\n\n        Args:\n            triplet (ColorTriplet): A color triplet containing red, green and blue components.\n\n        Returns:\n            Color: A new color object.\n        \"\"\"\n        return cls(name=triplet.hex, type=ColorType.TRUECOLOR, triplet=triplet)\n\n    @classmethod\n    def from_rgb(cls, red: float, green: float, blue: float) -> \"Color\":\n        \"\"\"Create a truecolor from three color components in the range(0->255).\n\n        Args:\n            red (float): Red component in range 0-255.\n            green (float): Green component in range 0-255.\n            blue (float): Blue component in range 0-255.\n\n        Returns:\n            Color: A new color object.\n        \"\"\"\n        return cls.from_triplet(ColorTriplet(int(red), int(green), int(blue)))\n\n    @classmethod\n    def default(cls) -> \"Color\":\n        \"\"\"Get a Color instance representing the default color.\n\n        Returns:\n            Color: Default color.\n        \"\"\"\n        return cls(name=\"default\", type=ColorType.DEFAULT)\n\n    @classmethod\n    @lru_cache(maxsize=1024)\n    def parse(cls, color: str) -> \"Color\":\n        \"\"\"Parse a color definition.\"\"\"\n        original_color = color\n        color = color.lower().strip()\n\n        if color == \"default\":\n            return cls(color, type=ColorType.DEFAULT)\n\n        color_number = ANSI_COLOR_NAMES.get(color)\n        if color_number is not None:\n            return cls(\n                color,\n                type=(ColorType.STANDARD if color_number < 16 else ColorType.EIGHT_BIT),\n                number=color_number,\n            )\n\n        color_match = RE_COLOR.match(color)\n        if color_match is None:\n            raise ColorParseError(f\"{original_color!r} is not a valid color\")\n\n        color_24, color_8, color_rgb = color_match.groups()\n        if color_24:\n            triplet = ColorTriplet(\n                int(color_24[0:2], 16), int(color_24[2:4], 16), int(color_24[4:6], 16)\n            )\n            return cls(color, ColorType.TRUECOLOR, triplet=triplet)\n\n        elif color_8:\n            number = int(color_8)\n            if number > 255:\n                raise ColorParseError(f\"color number must be <= 255 in {color!r}\")\n            return cls(\n                color,\n                type=(ColorType.STANDARD if number < 16 else ColorType.EIGHT_BIT),\n                number=number,\n            )\n\n        else:  #  color_rgb:\n            components = color_rgb.split(\",\")\n            if len(components) != 3:\n                raise ColorParseError(\n                    f\"expected three components in {original_color!r}\"\n                )\n            red, green, blue = components\n            triplet = ColorTriplet(int(red), int(green), int(blue))\n            if not all(component <= 255 for component in triplet):\n                raise ColorParseError(\n                    f\"color components must be <= 255 in {original_color!r}\"\n                )\n            return cls(color, ColorType.TRUECOLOR, triplet=triplet)\n\n    @lru_cache(maxsize=1024)\n    def get_ansi_codes(self, foreground: bool = True) -> Tuple[str, ...]:\n        \"\"\"Get the ANSI escape codes for this color.\"\"\"\n        _type = self.type\n        if _type == ColorType.DEFAULT:\n            return (\"39\" if foreground else \"49\",)\n\n        elif _type == ColorType.WINDOWS:\n            number = self.number\n            assert number is not None\n            fore, back = (30, 40) if number < 8 else (82, 92)\n            return (str(fore + number if foreground else back + number),)\n\n        elif _type == ColorType.STANDARD:\n            number = self.number\n            assert number is not None\n            fore, back = (30, 40) if number < 8 else (82, 92)\n            return (str(fore + number if foreground else back + number),)\n\n        elif _type == ColorType.EIGHT_BIT:\n            assert self.number is not None\n            return (\"38\" if foreground else \"48\", \"5\", str(self.number))\n\n        else:  # self.standard == ColorStandard.TRUECOLOR:\n            assert self.triplet is not None\n            red, green, blue = self.triplet\n            return (\"38\" if foreground else \"48\", \"2\", str(red), str(green), str(blue))\n\n    @lru_cache(maxsize=1024)\n    def downgrade(self, system: ColorSystem) -> \"Color\":\n        \"\"\"Downgrade a color system to a system with fewer colors.\"\"\"\n\n        if self.type in (ColorType.DEFAULT, system):\n            return self\n        # Convert to 8-bit color from truecolor color\n        if system == ColorSystem.EIGHT_BIT and self.system == ColorSystem.TRUECOLOR:\n            assert self.triplet is not None\n            _h, l, s = rgb_to_hls(*self.triplet.normalized)\n            # If saturation is under 15% assume it is grayscale\n            if s < 0.15:\n                gray = round(l * 25.0)\n                if gray == 0:\n                    color_number = 16\n                elif gray == 25:\n                    color_number = 231\n                else:\n                    color_number = 231 + gray\n                return Color(self.name, ColorType.EIGHT_BIT, number=color_number)\n\n            red, green, blue = self.triplet\n            six_red = red / 95 if red < 95 else 1 + (red - 95) / 40\n            six_green = green / 95 if green < 95 else 1 + (green - 95) / 40\n            six_blue = blue / 95 if blue < 95 else 1 + (blue - 95) / 40\n\n            color_number = (\n                16 + 36 * round(six_red) + 6 * round(six_green) + round(six_blue)\n            )\n            return Color(self.name, ColorType.EIGHT_BIT, number=color_number)\n\n        # Convert to standard from truecolor or 8-bit\n        elif system == ColorSystem.STANDARD:\n            if self.system == ColorSystem.TRUECOLOR:\n                assert self.triplet is not None\n                triplet = self.triplet\n            else:  # self.system == ColorSystem.EIGHT_BIT\n                assert self.number is not None\n                triplet = ColorTriplet(*EIGHT_BIT_PALETTE[self.number])\n\n            color_number = STANDARD_PALETTE.match(triplet)\n            return Color(self.name, ColorType.STANDARD, number=color_number)\n\n        elif system == ColorSystem.WINDOWS:\n            if self.system == ColorSystem.TRUECOLOR:\n                assert self.triplet is not None\n                triplet = self.triplet\n            else:  # self.system == ColorSystem.EIGHT_BIT\n                assert self.number is not None\n                if self.number < 16:\n                    return Color(self.name, ColorType.WINDOWS, number=self.number)\n                triplet = ColorTriplet(*EIGHT_BIT_PALETTE[self.number])\n\n            color_number = WINDOWS_PALETTE.match(triplet)\n            return Color(self.name, ColorType.WINDOWS, number=color_number)\n\n        return self\n\n\ndef parse_rgb_hex(hex_color: str) -> ColorTriplet:\n    \"\"\"Parse six hex characters in to RGB triplet.\"\"\"\n    assert len(hex_color) == 6, \"must be 6 characters\"\n    color = ColorTriplet(\n        int(hex_color[0:2], 16), int(hex_color[2:4], 16), int(hex_color[4:6], 16)\n    )\n    return color\n\n\ndef blend_rgb(\n    color1: ColorTriplet, color2: ColorTriplet, cross_fade: float = 0.5\n) -> ColorTriplet:\n    \"\"\"Blend one RGB color in to another.\"\"\"\n    r1, g1, b1 = color1\n    r2, g2, b2 = color2\n    new_color = ColorTriplet(\n        int(r1 + (r2 - r1) * cross_fade),\n        int(g1 + (g2 - g1) * cross_fade),\n        int(b1 + (b2 - b1) * cross_fade),\n    )\n    return new_color\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from .console import Console\n    from .table import Table\n    from .text import Text\n\n    console = Console()\n\n    table = Table(show_footer=False, show_edge=True)\n    table.add_column(\"Color\", width=10, overflow=\"ellipsis\")\n    table.add_column(\"Number\", justify=\"right\", style=\"yellow\")\n    table.add_column(\"Name\", style=\"green\")\n    table.add_column(\"Hex\", style=\"blue\")\n    table.add_column(\"RGB\", style=\"magenta\")\n\n    colors = sorted((v, k) for k, v in ANSI_COLOR_NAMES.items())\n    for color_number, name in colors:\n        if \"grey\" in name:\n            continue\n        color_cell = Text(\" \" * 10, style=f\"on {name}\")\n        if color_number < 16:\n            table.add_row(color_cell, f\"{color_number}\", Text(f'\"{name}\"'))\n        else:\n            color = EIGHT_BIT_PALETTE[color_number]  # type: ignore[has-type]\n            table.add_row(\n                color_cell, str(color_number), Text(f'\"{name}\"'), color.hex, color.rgb\n            )\n\n    console.print(table)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/color_triplet.py","size":1054,"sha1":"fa44f6511c7b136d8bf9f3d9c858741f38bc776f","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import NamedTuple, Tuple\n\n\nclass ColorTriplet(NamedTuple):\n    \"\"\"The red, green, and blue components of a color.\"\"\"\n\n    red: int\n    \"\"\"Red component in 0 to 255 range.\"\"\"\n    green: int\n    \"\"\"Green component in 0 to 255 range.\"\"\"\n    blue: int\n    \"\"\"Blue component in 0 to 255 range.\"\"\"\n\n    @property\n    def hex(self) -> str:\n        \"\"\"get the color triplet in CSS style.\"\"\"\n        red, green, blue = self\n        return f\"#{red:02x}{green:02x}{blue:02x}\"\n\n    @property\n    def rgb(self) -> str:\n        \"\"\"The color in RGB format.\n\n        Returns:\n            str: An rgb color, e.g. ``\"rgb(100,23,255)\"``.\n        \"\"\"\n        red, green, blue = self\n        return f\"rgb({red},{green},{blue})\"\n\n    @property\n    def normalized(self) -> Tuple[float, float, float]:\n        \"\"\"Convert components into floats between 0 and 1.\n\n        Returns:\n            Tuple[float, float, float]: A tuple of three normalized colour components.\n        \"\"\"\n        red, green, blue = self\n        return red / 255.0, green / 255.0, blue / 255.0\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/columns.py","size":7131,"sha1":"556f2bdd1c7382fa941827c8f2afcbab008c1fc6","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from collections import defaultdict\nfrom itertools import chain\nfrom operator import itemgetter\nfrom typing import Dict, Iterable, List, Optional, Tuple\n\nfrom .align import Align, AlignMethod\nfrom .console import Console, ConsoleOptions, RenderableType, RenderResult\nfrom .constrain import Constrain\nfrom .measure import Measurement\nfrom .padding import Padding, PaddingDimensions\nfrom .table import Table\nfrom .text import TextType\nfrom .jupyter import JupyterMixin\n\n\nclass Columns(JupyterMixin):\n    \"\"\"Display renderables in neat columns.\n\n    Args:\n        renderables (Iterable[RenderableType]): Any number of Rich renderables (including str).\n        width (int, optional): The desired width of the columns, or None to auto detect. Defaults to None.\n        padding (PaddingDimensions, optional): Optional padding around cells. Defaults to (0, 1).\n        expand (bool, optional): Expand columns to full width. Defaults to False.\n        equal (bool, optional): Arrange in to equal sized columns. Defaults to False.\n        column_first (bool, optional): Align items from top to bottom (rather than left to right). Defaults to False.\n        right_to_left (bool, optional): Start column from right hand side. Defaults to False.\n        align (str, optional): Align value (\"left\", \"right\", or \"center\") or None for default. Defaults to None.\n        title (TextType, optional): Optional title for Columns.\n    \"\"\"\n\n    def __init__(\n        self,\n        renderables: Optional[Iterable[RenderableType]] = None,\n        padding: PaddingDimensions = (0, 1),\n        *,\n        width: Optional[int] = None,\n        expand: bool = False,\n        equal: bool = False,\n        column_first: bool = False,\n        right_to_left: bool = False,\n        align: Optional[AlignMethod] = None,\n        title: Optional[TextType] = None,\n    ) -> None:\n        self.renderables = list(renderables or [])\n        self.width = width\n        self.padding = padding\n        self.expand = expand\n        self.equal = equal\n        self.column_first = column_first\n        self.right_to_left = right_to_left\n        self.align: Optional[AlignMethod] = align\n        self.title = title\n\n    def add_renderable(self, renderable: RenderableType) -> None:\n        \"\"\"Add a renderable to the columns.\n\n        Args:\n            renderable (RenderableType): Any renderable object.\n        \"\"\"\n        self.renderables.append(renderable)\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        render_str = console.render_str\n        renderables = [\n            render_str(renderable) if isinstance(renderable, str) else renderable\n            for renderable in self.renderables\n        ]\n        if not renderables:\n            return\n        _top, right, _bottom, left = Padding.unpack(self.padding)\n        width_padding = max(left, right)\n        max_width = options.max_width\n        widths: Dict[int, int] = defaultdict(int)\n        column_count = len(renderables)\n\n        get_measurement = Measurement.get\n        renderable_widths = [\n            get_measurement(console, options, renderable).maximum\n            for renderable in renderables\n        ]\n        if self.equal:\n            renderable_widths = [max(renderable_widths)] * len(renderable_widths)\n\n        def iter_renderables(\n            column_count: int,\n        ) -> Iterable[Tuple[int, Optional[RenderableType]]]:\n            item_count = len(renderables)\n            if self.column_first:\n                width_renderables = list(zip(renderable_widths, renderables))\n\n                column_lengths: List[int] = [item_count // column_count] * column_count\n                for col_no in range(item_count % column_count):\n                    column_lengths[col_no] += 1\n\n                row_count = (item_count + column_count - 1) // column_count\n                cells = [[-1] * column_count for _ in range(row_count)]\n                row = col = 0\n                for index in range(item_count):\n                    cells[row][col] = index\n                    column_lengths[col] -= 1\n                    if column_lengths[col]:\n                        row += 1\n                    else:\n                        col += 1\n                        row = 0\n                for index in chain.from_iterable(cells):\n                    if index == -1:\n                        break\n                    yield width_renderables[index]\n            else:\n                yield from zip(renderable_widths, renderables)\n            # Pad odd elements with spaces\n            if item_count % column_count:\n                for _ in range(column_count - (item_count % column_count)):\n                    yield 0, None\n\n        table = Table.grid(padding=self.padding, collapse_padding=True, pad_edge=False)\n        table.expand = self.expand\n        table.title = self.title\n\n        if self.width is not None:\n            column_count = (max_width) // (self.width + width_padding)\n            for _ in range(column_count):\n                table.add_column(width=self.width)\n        else:\n            while column_count > 1:\n                widths.clear()\n                column_no = 0\n                for renderable_width, _ in iter_renderables(column_count):\n                    widths[column_no] = max(widths[column_no], renderable_width)\n                    total_width = sum(widths.values()) + width_padding * (\n                        len(widths) - 1\n                    )\n                    if total_width > max_width:\n                        column_count = len(widths) - 1\n                        break\n                    else:\n                        column_no = (column_no + 1) % column_count\n                else:\n                    break\n\n        get_renderable = itemgetter(1)\n        _renderables = [\n            get_renderable(_renderable)\n            for _renderable in iter_renderables(column_count)\n        ]\n        if self.equal:\n            _renderables = [\n                None\n                if renderable is None\n                else Constrain(renderable, renderable_widths[0])\n                for renderable in _renderables\n            ]\n        if self.align:\n            align = self.align\n            _Align = Align\n            _renderables = [\n                None if renderable is None else _Align(renderable, align)\n                for renderable in _renderables\n            ]\n\n        right_to_left = self.right_to_left\n        add_row = table.add_row\n        for start in range(0, len(_renderables), column_count):\n            row = _renderables[start : start + column_count]\n            if right_to_left:\n                row = row[::-1]\n            add_row(*row)\n        yield table\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    import os\n\n    console = Console()\n\n    files = [f\"{i} {s}\" for i, s in enumerate(sorted(os.listdir()))]\n    columns = Columns(files, padding=(0, 1), expand=False, equal=False)\n    console.print(columns)\n    console.rule()\n    columns.column_first = True\n    console.print(columns)\n    columns.right_to_left = True\n    console.rule()\n    console.print(columns)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/console.py","size":100156,"sha1":"9d80269fba89209075945bea5817cea53e4cdd22","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import inspect\nimport os\nimport sys\nimport threading\nimport zlib\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom functools import wraps\nfrom getpass import getpass\nfrom html import escape\nfrom inspect import isclass\nfrom itertools import islice\nfrom math import ceil\nfrom time import monotonic\nfrom types import FrameType, ModuleType, TracebackType\nfrom typing import (\n    IO,\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    Dict,\n    Iterable,\n    List,\n    Mapping,\n    NamedTuple,\n    Optional,\n    TextIO,\n    Tuple,\n    Type,\n    Union,\n    cast,\n)\n\nfrom pip._vendor.rich._null_file import NULL_FILE\n\nif sys.version_info >= (3, 8):\n    from typing import Literal, Protocol, runtime_checkable\nelse:\n    from pip._vendor.typing_extensions import (\n        Literal,\n        Protocol,\n        runtime_checkable,\n    )  # pragma: no cover\n\nfrom . import errors, themes\nfrom ._emoji_replace import _emoji_replace\nfrom ._export_format import CONSOLE_HTML_FORMAT, CONSOLE_SVG_FORMAT\nfrom ._fileno import get_fileno\nfrom ._log_render import FormatTimeCallable, LogRender\nfrom .align import Align, AlignMethod\nfrom .color import ColorSystem, blend_rgb\nfrom .control import Control\nfrom .emoji import EmojiVariant\nfrom .highlighter import NullHighlighter, ReprHighlighter\nfrom .markup import render as render_markup\nfrom .measure import Measurement, measure_renderables\nfrom .pager import Pager, SystemPager\nfrom .pretty import Pretty, is_expandable\nfrom .protocol import rich_cast\nfrom .region import Region\nfrom .scope import render_scope\nfrom .screen import Screen\nfrom .segment import Segment\nfrom .style import Style, StyleType\nfrom .styled import Styled\nfrom .terminal_theme import DEFAULT_TERMINAL_THEME, SVG_EXPORT_THEME, TerminalTheme\nfrom .text import Text, TextType\nfrom .theme import Theme, ThemeStack\n\nif TYPE_CHECKING:\n    from ._windows import WindowsConsoleFeatures\n    from .live import Live\n    from .status import Status\n\nJUPYTER_DEFAULT_COLUMNS = 115\nJUPYTER_DEFAULT_LINES = 100\nWINDOWS = sys.platform == \"win32\"\n\nHighlighterType = Callable[[Union[str, \"Text\"]], \"Text\"]\nJustifyMethod = Literal[\"default\", \"left\", \"center\", \"right\", \"full\"]\nOverflowMethod = Literal[\"fold\", \"crop\", \"ellipsis\", \"ignore\"]\n\n\nclass NoChange:\n    pass\n\n\nNO_CHANGE = NoChange()\n\ntry:\n    _STDIN_FILENO = sys.__stdin__.fileno()  # type: ignore[union-attr]\nexcept Exception:\n    _STDIN_FILENO = 0\ntry:\n    _STDOUT_FILENO = sys.__stdout__.fileno()  # type: ignore[union-attr]\nexcept Exception:\n    _STDOUT_FILENO = 1\ntry:\n    _STDERR_FILENO = sys.__stderr__.fileno()  # type: ignore[union-attr]\nexcept Exception:\n    _STDERR_FILENO = 2\n\n_STD_STREAMS = (_STDIN_FILENO, _STDOUT_FILENO, _STDERR_FILENO)\n_STD_STREAMS_OUTPUT = (_STDOUT_FILENO, _STDERR_FILENO)\n\n\n_TERM_COLORS = {\n    \"kitty\": ColorSystem.EIGHT_BIT,\n    \"256color\": ColorSystem.EIGHT_BIT,\n    \"16color\": ColorSystem.STANDARD,\n}\n\n\nclass ConsoleDimensions(NamedTuple):\n    \"\"\"Size of the terminal.\"\"\"\n\n    width: int\n    \"\"\"The width of the console in 'cells'.\"\"\"\n    height: int\n    \"\"\"The height of the console in lines.\"\"\"\n\n\n@dataclass\nclass ConsoleOptions:\n    \"\"\"Options for __rich_console__ method.\"\"\"\n\n    size: ConsoleDimensions\n    \"\"\"Size of console.\"\"\"\n    legacy_windows: bool\n    \"\"\"legacy_windows: flag for legacy windows.\"\"\"\n    min_width: int\n    \"\"\"Minimum width of renderable.\"\"\"\n    max_width: int\n    \"\"\"Maximum width of renderable.\"\"\"\n    is_terminal: bool\n    \"\"\"True if the target is a terminal, otherwise False.\"\"\"\n    encoding: str\n    \"\"\"Encoding of terminal.\"\"\"\n    max_height: int\n    \"\"\"Height of container (starts as terminal)\"\"\"\n    justify: Optional[JustifyMethod] = None\n    \"\"\"Justify value override for renderable.\"\"\"\n    overflow: Optional[OverflowMethod] = None\n    \"\"\"Overflow value override for renderable.\"\"\"\n    no_wrap: Optional[bool] = False\n    \"\"\"Disable wrapping for text.\"\"\"\n    highlight: Optional[bool] = None\n    \"\"\"Highlight override for render_str.\"\"\"\n    markup: Optional[bool] = None\n    \"\"\"Enable markup when rendering strings.\"\"\"\n    height: Optional[int] = None\n\n    @property\n    def ascii_only(self) -> bool:\n        \"\"\"Check if renderables should use ascii only.\"\"\"\n        return not self.encoding.startswith(\"utf\")\n\n    def copy(self) -> \"ConsoleOptions\":\n        \"\"\"Return a copy of the options.\n\n        Returns:\n            ConsoleOptions: a copy of self.\n        \"\"\"\n        options: ConsoleOptions = ConsoleOptions.__new__(ConsoleOptions)\n        options.__dict__ = self.__dict__.copy()\n        return options\n\n    def update(\n        self,\n        *,\n        width: Union[int, NoChange] = NO_CHANGE,\n        min_width: Union[int, NoChange] = NO_CHANGE,\n        max_width: Union[int, NoChange] = NO_CHANGE,\n        justify: Union[Optional[JustifyMethod], NoChange] = NO_CHANGE,\n        overflow: Union[Optional[OverflowMethod], NoChange] = NO_CHANGE,\n        no_wrap: Union[Optional[bool], NoChange] = NO_CHANGE,\n        highlight: Union[Optional[bool], NoChange] = NO_CHANGE,\n        markup: Union[Optional[bool], NoChange] = NO_CHANGE,\n        height: Union[Optional[int], NoChange] = NO_CHANGE,\n    ) -> \"ConsoleOptions\":\n        \"\"\"Update values, return a copy.\"\"\"\n        options = self.copy()\n        if not isinstance(width, NoChange):\n            options.min_width = options.max_width = max(0, width)\n        if not isinstance(min_width, NoChange):\n            options.min_width = min_width\n        if not isinstance(max_width, NoChange):\n            options.max_width = max_width\n        if not isinstance(justify, NoChange):\n            options.justify = justify\n        if not isinstance(overflow, NoChange):\n            options.overflow = overflow\n        if not isinstance(no_wrap, NoChange):\n            options.no_wrap = no_wrap\n        if not isinstance(highlight, NoChange):\n            options.highlight = highlight\n        if not isinstance(markup, NoChange):\n            options.markup = markup\n        if not isinstance(height, NoChange):\n            if height is not None:\n                options.max_height = height\n            options.height = None if height is None else max(0, height)\n        return options\n\n    def update_width(self, width: int) -> \"ConsoleOptions\":\n        \"\"\"Update just the width, return a copy.\n\n        Args:\n            width (int): New width (sets both min_width and max_width)\n\n        Returns:\n            ~ConsoleOptions: New console options instance.\n        \"\"\"\n        options = self.copy()\n        options.min_width = options.max_width = max(0, width)\n        return options\n\n    def update_height(self, height: int) -> \"ConsoleOptions\":\n        \"\"\"Update the height, and return a copy.\n\n        Args:\n            height (int): New height\n\n        Returns:\n            ~ConsoleOptions: New Console options instance.\n        \"\"\"\n        options = self.copy()\n        options.max_height = options.height = height\n        return options\n\n    def reset_height(self) -> \"ConsoleOptions\":\n        \"\"\"Return a copy of the options with height set to ``None``.\n\n        Returns:\n            ~ConsoleOptions: New console options instance.\n        \"\"\"\n        options = self.copy()\n        options.height = None\n        return options\n\n    def update_dimensions(self, width: int, height: int) -> \"ConsoleOptions\":\n        \"\"\"Update the width and height, and return a copy.\n\n        Args:\n            width (int): New width (sets both min_width and max_width).\n            height (int): New height.\n\n        Returns:\n            ~ConsoleOptions: New console options instance.\n        \"\"\"\n        options = self.copy()\n        options.min_width = options.max_width = max(0, width)\n        options.height = options.max_height = height\n        return options\n\n\n@runtime_checkable\nclass RichCast(Protocol):\n    \"\"\"An object that may be 'cast' to a console renderable.\"\"\"\n\n    def __rich__(\n        self,\n    ) -> Union[\"ConsoleRenderable\", \"RichCast\", str]:  # pragma: no cover\n        ...\n\n\n@runtime_checkable\nclass ConsoleRenderable(Protocol):\n    \"\"\"An object that supports the console protocol.\"\"\"\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":  # pragma: no cover\n        ...\n\n\n# A type that may be rendered by Console.\nRenderableType = Union[ConsoleRenderable, RichCast, str]\n\"\"\"A string or any object that may be rendered by Rich.\"\"\"\n\n# The result of calling a __rich_console__ method.\nRenderResult = Iterable[Union[RenderableType, Segment]]\n\n_null_highlighter = NullHighlighter()\n\n\nclass CaptureError(Exception):\n    \"\"\"An error in the Capture context manager.\"\"\"\n\n\nclass NewLine:\n    \"\"\"A renderable to generate new line(s)\"\"\"\n\n    def __init__(self, count: int = 1) -> None:\n        self.count = count\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> Iterable[Segment]:\n        yield Segment(\"\\n\" * self.count)\n\n\nclass ScreenUpdate:\n    \"\"\"Render a list of lines at a given offset.\"\"\"\n\n    def __init__(self, lines: List[List[Segment]], x: int, y: int) -> None:\n        self._lines = lines\n        self.x = x\n        self.y = y\n\n    def __rich_console__(\n        self, console: \"Console\", options: ConsoleOptions\n    ) -> RenderResult:\n        x = self.x\n        move_to = Control.move_to\n        for offset, line in enumerate(self._lines, self.y):\n            yield move_to(x, offset)\n            yield from line\n\n\nclass Capture:\n    \"\"\"Context manager to capture the result of printing to the console.\n    See :meth:`~rich.console.Console.capture` for how to use.\n\n    Args:\n        console (Console): A console instance to capture output.\n    \"\"\"\n\n    def __init__(self, console: \"Console\") -> None:\n        self._console = console\n        self._result: Optional[str] = None\n\n    def __enter__(self) -> \"Capture\":\n        self._console.begin_capture()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        self._result = self._console.end_capture()\n\n    def get(self) -> str:\n        \"\"\"Get the result of the capture.\"\"\"\n        if self._result is None:\n            raise CaptureError(\n                \"Capture result is not available until context manager exits.\"\n            )\n        return self._result\n\n\nclass ThemeContext:\n    \"\"\"A context manager to use a temporary theme. See :meth:`~rich.console.Console.use_theme` for usage.\"\"\"\n\n    def __init__(self, console: \"Console\", theme: Theme, inherit: bool = True) -> None:\n        self.console = console\n        self.theme = theme\n        self.inherit = inherit\n\n    def __enter__(self) -> \"ThemeContext\":\n        self.console.push_theme(self.theme)\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        self.console.pop_theme()\n\n\nclass PagerContext:\n    \"\"\"A context manager that 'pages' content. See :meth:`~rich.console.Console.pager` for usage.\"\"\"\n\n    def __init__(\n        self,\n        console: \"Console\",\n        pager: Optional[Pager] = None,\n        styles: bool = False,\n        links: bool = False,\n    ) -> None:\n        self._console = console\n        self.pager = SystemPager() if pager is None else pager\n        self.styles = styles\n        self.links = links\n\n    def __enter__(self) -> \"PagerContext\":\n        self._console._enter_buffer()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        if exc_type is None:\n            with self._console._lock:\n                buffer: List[Segment] = self._console._buffer[:]\n                del self._console._buffer[:]\n                segments: Iterable[Segment] = buffer\n                if not self.styles:\n                    segments = Segment.strip_styles(segments)\n                elif not self.links:\n                    segments = Segment.strip_links(segments)\n                content = self._console._render_buffer(segments)\n            self.pager.show(content)\n        self._console._exit_buffer()\n\n\nclass ScreenContext:\n    \"\"\"A context manager that enables an alternative screen. See :meth:`~rich.console.Console.screen` for usage.\"\"\"\n\n    def __init__(\n        self, console: \"Console\", hide_cursor: bool, style: StyleType = \"\"\n    ) -> None:\n        self.console = console\n        self.hide_cursor = hide_cursor\n        self.screen = Screen(style=style)\n        self._changed = False\n\n    def update(\n        self, *renderables: RenderableType, style: Optional[StyleType] = None\n    ) -> None:\n        \"\"\"Update the screen.\n\n        Args:\n            renderable (RenderableType, optional): Optional renderable to replace current renderable,\n                or None for no change. Defaults to None.\n            style: (Style, optional): Replacement style, or None for no change. Defaults to None.\n        \"\"\"\n        if renderables:\n            self.screen.renderable = (\n                Group(*renderables) if len(renderables) > 1 else renderables[0]\n            )\n        if style is not None:\n            self.screen.style = style\n        self.console.print(self.screen, end=\"\")\n\n    def __enter__(self) -> \"ScreenContext\":\n        self._changed = self.console.set_alt_screen(True)\n        if self._changed and self.hide_cursor:\n            self.console.show_cursor(False)\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        if self._changed:\n            self.console.set_alt_screen(False)\n            if self.hide_cursor:\n                self.console.show_cursor(True)\n\n\nclass Group:\n    \"\"\"Takes a group of renderables and returns a renderable object that renders the group.\n\n    Args:\n        renderables (Iterable[RenderableType]): An iterable of renderable objects.\n        fit (bool, optional): Fit dimension of group to contents, or fill available space. Defaults to True.\n    \"\"\"\n\n    def __init__(self, *renderables: \"RenderableType\", fit: bool = True) -> None:\n        self._renderables = renderables\n        self.fit = fit\n        self._render: Optional[List[RenderableType]] = None\n\n    @property\n    def renderables(self) -> List[\"RenderableType\"]:\n        if self._render is None:\n            self._render = list(self._renderables)\n        return self._render\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        if self.fit:\n            return measure_renderables(console, options, self.renderables)\n        else:\n            return Measurement(options.max_width, options.max_width)\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> RenderResult:\n        yield from self.renderables\n\n\ndef group(fit: bool = True) -> Callable[..., Callable[..., Group]]:\n    \"\"\"A decorator that turns an iterable of renderables in to a group.\n\n    Args:\n        fit (bool, optional): Fit dimension of group to contents, or fill available space. Defaults to True.\n    \"\"\"\n\n    def decorator(\n        method: Callable[..., Iterable[RenderableType]]\n    ) -> Callable[..., Group]:\n        \"\"\"Convert a method that returns an iterable of renderables in to a Group.\"\"\"\n\n        @wraps(method)\n        def _replace(*args: Any, **kwargs: Any) -> Group:\n            renderables = method(*args, **kwargs)\n            return Group(*renderables, fit=fit)\n\n        return _replace\n\n    return decorator\n\n\ndef _is_jupyter() -> bool:  # pragma: no cover\n    \"\"\"Check if we're running in a Jupyter notebook.\"\"\"\n    try:\n        get_ipython  # type: ignore[name-defined]\n    except NameError:\n        return False\n    ipython = get_ipython()  # type: ignore[name-defined]\n    shell = ipython.__class__.__name__\n    if (\n        \"google.colab\" in str(ipython.__class__)\n        or os.getenv(\"DATABRICKS_RUNTIME_VERSION\")\n        or shell == \"ZMQInteractiveShell\"\n    ):\n        return True  # Jupyter notebook or qtconsole\n    elif shell == \"TerminalInteractiveShell\":\n        return False  # Terminal running IPython\n    else:\n        return False  # Other type (?)\n\n\nCOLOR_SYSTEMS = {\n    \"standard\": ColorSystem.STANDARD,\n    \"256\": ColorSystem.EIGHT_BIT,\n    \"truecolor\": ColorSystem.TRUECOLOR,\n    \"windows\": ColorSystem.WINDOWS,\n}\n\n_COLOR_SYSTEMS_NAMES = {system: name for name, system in COLOR_SYSTEMS.items()}\n\n\n@dataclass\nclass ConsoleThreadLocals(threading.local):\n    \"\"\"Thread local values for Console context.\"\"\"\n\n    theme_stack: ThemeStack\n    buffer: List[Segment] = field(default_factory=list)\n    buffer_index: int = 0\n\n\nclass RenderHook(ABC):\n    \"\"\"Provides hooks in to the render process.\"\"\"\n\n    @abstractmethod\n    def process_renderables(\n        self, renderables: List[ConsoleRenderable]\n    ) -> List[ConsoleRenderable]:\n        \"\"\"Called with a list of objects to render.\n\n        This method can return a new list of renderables, or modify and return the same list.\n\n        Args:\n            renderables (List[ConsoleRenderable]): A number of renderable objects.\n\n        Returns:\n            List[ConsoleRenderable]: A replacement list of renderables.\n        \"\"\"\n\n\n_windows_console_features: Optional[\"WindowsConsoleFeatures\"] = None\n\n\ndef get_windows_console_features() -> \"WindowsConsoleFeatures\":  # pragma: no cover\n    global _windows_console_features\n    if _windows_console_features is not None:\n        return _windows_console_features\n    from ._windows import get_windows_console_features\n\n    _windows_console_features = get_windows_console_features()\n    return _windows_console_features\n\n\ndef detect_legacy_windows() -> bool:\n    \"\"\"Detect legacy Windows.\"\"\"\n    return WINDOWS and not get_windows_console_features().vt\n\n\nclass Console:\n    \"\"\"A high level console interface.\n\n    Args:\n        color_system (str, optional): The color system supported by your terminal,\n            either ``\"standard\"``, ``\"256\"`` or ``\"truecolor\"``. Leave as ``\"auto\"`` to autodetect.\n        force_terminal (Optional[bool], optional): Enable/disable terminal control codes, or None to auto-detect terminal. Defaults to None.\n        force_jupyter (Optional[bool], optional): Enable/disable Jupyter rendering, or None to auto-detect Jupyter. Defaults to None.\n        force_interactive (Optional[bool], optional): Enable/disable interactive mode, or None to auto detect. Defaults to None.\n        soft_wrap (Optional[bool], optional): Set soft wrap default on print method. Defaults to False.\n        theme (Theme, optional): An optional style theme object, or ``None`` for default theme.\n        stderr (bool, optional): Use stderr rather than stdout if ``file`` is not specified. Defaults to False.\n        file (IO, optional): A file object where the console should write to. Defaults to stdout.\n        quiet (bool, Optional): Boolean to suppress all output. Defaults to False.\n        width (int, optional): The width of the terminal. Leave as default to auto-detect width.\n        height (int, optional): The height of the terminal. Leave as default to auto-detect height.\n        style (StyleType, optional): Style to apply to all output, or None for no style. Defaults to None.\n        no_color (Optional[bool], optional): Enabled no color mode, or None to auto detect. Defaults to None.\n        tab_size (int, optional): Number of spaces used to replace a tab character. Defaults to 8.\n        record (bool, optional): Boolean to enable recording of terminal output,\n            required to call :meth:`export_html`, :meth:`export_svg`, and :meth:`export_text`. Defaults to False.\n        markup (bool, optional): Boolean to enable :ref:`console_markup`. Defaults to True.\n        emoji (bool, optional): Enable emoji code. Defaults to True.\n        emoji_variant (str, optional): Optional emoji variant, either \"text\" or \"emoji\". Defaults to None.\n        highlight (bool, optional): Enable automatic highlighting. Defaults to True.\n        log_time (bool, optional): Boolean to enable logging of time by :meth:`log` methods. Defaults to True.\n        log_path (bool, optional): Boolean to enable the logging of the caller by :meth:`log`. Defaults to True.\n        log_time_format (Union[str, TimeFormatterCallable], optional): If ``log_time`` is enabled, either string for strftime or callable that formats the time. Defaults to \"[%X] \".\n        highlighter (HighlighterType, optional): Default highlighter.\n        legacy_windows (bool, optional): Enable legacy Windows mode, or ``None`` to auto detect. Defaults to ``None``.\n        safe_box (bool, optional): Restrict box options that don't render on legacy Windows.\n        get_datetime (Callable[[], datetime], optional): Callable that gets the current time as a datetime.datetime object (used by Console.log),\n            or None for datetime.now.\n        get_time (Callable[[], time], optional): Callable that gets the current time in seconds, default uses time.monotonic.\n    \"\"\"\n\n    _environ: Mapping[str, str] = os.environ\n\n    def __init__(\n        self,\n        *,\n        color_system: Optional[\n            Literal[\"auto\", \"standard\", \"256\", \"truecolor\", \"windows\"]\n        ] = \"auto\",\n        force_terminal: Optional[bool] = None,\n        force_jupyter: Optional[bool] = None,\n        force_interactive: Optional[bool] = None,\n        soft_wrap: bool = False,\n        theme: Optional[Theme] = None,\n        stderr: bool = False,\n        file: Optional[IO[str]] = None,\n        quiet: bool = False,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        style: Optional[StyleType] = None,\n        no_color: Optional[bool] = None,\n        tab_size: int = 8,\n        record: bool = False,\n        markup: bool = True,\n        emoji: bool = True,\n        emoji_variant: Optional[EmojiVariant] = None,\n        highlight: bool = True,\n        log_time: bool = True,\n        log_path: bool = True,\n        log_time_format: Union[str, FormatTimeCallable] = \"[%X]\",\n        highlighter: Optional[\"HighlighterType\"] = ReprHighlighter(),\n        legacy_windows: Optional[bool] = None,\n        safe_box: bool = True,\n        get_datetime: Optional[Callable[[], datetime]] = None,\n        get_time: Optional[Callable[[], float]] = None,\n        _environ: Optional[Mapping[str, str]] = None,\n    ):\n        # Copy of os.environ allows us to replace it for testing\n        if _environ is not None:\n            self._environ = _environ\n\n        self.is_jupyter = _is_jupyter() if force_jupyter is None else force_jupyter\n        if self.is_jupyter:\n            if width is None:\n                jupyter_columns = self._environ.get(\"JUPYTER_COLUMNS\")\n                if jupyter_columns is not None and jupyter_columns.isdigit():\n                    width = int(jupyter_columns)\n                else:\n                    width = JUPYTER_DEFAULT_COLUMNS\n            if height is None:\n                jupyter_lines = self._environ.get(\"JUPYTER_LINES\")\n                if jupyter_lines is not None and jupyter_lines.isdigit():\n                    height = int(jupyter_lines)\n                else:\n                    height = JUPYTER_DEFAULT_LINES\n\n        self.tab_size = tab_size\n        self.record = record\n        self._markup = markup\n        self._emoji = emoji\n        self._emoji_variant: Optional[EmojiVariant] = emoji_variant\n        self._highlight = highlight\n        self.legacy_windows: bool = (\n            (detect_legacy_windows() and not self.is_jupyter)\n            if legacy_windows is None\n            else legacy_windows\n        )\n\n        if width is None:\n            columns = self._environ.get(\"COLUMNS\")\n            if columns is not None and columns.isdigit():\n                width = int(columns) - self.legacy_windows\n        if height is None:\n            lines = self._environ.get(\"LINES\")\n            if lines is not None and lines.isdigit():\n                height = int(lines)\n\n        self.soft_wrap = soft_wrap\n        self._width = width\n        self._height = height\n\n        self._color_system: Optional[ColorSystem]\n\n        self._force_terminal = None\n        if force_terminal is not None:\n            self._force_terminal = force_terminal\n\n        self._file = file\n        self.quiet = quiet\n        self.stderr = stderr\n\n        if color_system is None:\n            self._color_system = None\n        elif color_system == \"auto\":\n            self._color_system = self._detect_color_system()\n        else:\n            self._color_system = COLOR_SYSTEMS[color_system]\n\n        self._lock = threading.RLock()\n        self._log_render = LogRender(\n            show_time=log_time,\n            show_path=log_path,\n            time_format=log_time_format,\n        )\n        self.highlighter: HighlighterType = highlighter or _null_highlighter\n        self.safe_box = safe_box\n        self.get_datetime = get_datetime or datetime.now\n        self.get_time = get_time or monotonic\n        self.style = style\n        self.no_color = (\n            no_color if no_color is not None else \"NO_COLOR\" in self._environ\n        )\n        self.is_interactive = (\n            (self.is_terminal and not self.is_dumb_terminal)\n            if force_interactive is None\n            else force_interactive\n        )\n\n        self._record_buffer_lock = threading.RLock()\n        self._thread_locals = ConsoleThreadLocals(\n            theme_stack=ThemeStack(themes.DEFAULT if theme is None else theme)\n        )\n        self._record_buffer: List[Segment] = []\n        self._render_hooks: List[RenderHook] = []\n        self._live: Optional[\"Live\"] = None\n        self._is_alt_screen = False\n\n    def __repr__(self) -> str:\n        return f\"<console width={self.width} {self._color_system!s}>\"\n\n    @property\n    def file(self) -> IO[str]:\n        \"\"\"Get the file object to write to.\"\"\"\n        file = self._file or (sys.stderr if self.stderr else sys.stdout)\n        file = getattr(file, \"rich_proxied_file\", file)\n        if file is None:\n            file = NULL_FILE\n        return file\n\n    @file.setter\n    def file(self, new_file: IO[str]) -> None:\n        \"\"\"Set a new file object.\"\"\"\n        self._file = new_file\n\n    @property\n    def _buffer(self) -> List[Segment]:\n        \"\"\"Get a thread local buffer.\"\"\"\n        return self._thread_locals.buffer\n\n    @property\n    def _buffer_index(self) -> int:\n        \"\"\"Get a thread local buffer.\"\"\"\n        return self._thread_locals.buffer_index\n\n    @_buffer_index.setter\n    def _buffer_index(self, value: int) -> None:\n        self._thread_locals.buffer_index = value\n\n    @property\n    def _theme_stack(self) -> ThemeStack:\n        \"\"\"Get the thread local theme stack.\"\"\"\n        return self._thread_locals.theme_stack\n\n    def _detect_color_system(self) -> Optional[ColorSystem]:\n        \"\"\"Detect color system from env vars.\"\"\"\n        if self.is_jupyter:\n            return ColorSystem.TRUECOLOR\n        if not self.is_terminal or self.is_dumb_terminal:\n            return None\n        if WINDOWS:  # pragma: no cover\n            if self.legacy_windows:  # pragma: no cover\n                return ColorSystem.WINDOWS\n            windows_console_features = get_windows_console_features()\n            return (\n                ColorSystem.TRUECOLOR\n                if windows_console_features.truecolor\n                else ColorSystem.EIGHT_BIT\n            )\n        else:\n            color_term = self._environ.get(\"COLORTERM\", \"\").strip().lower()\n            if color_term in (\"truecolor\", \"24bit\"):\n                return ColorSystem.TRUECOLOR\n            term = self._environ.get(\"TERM\", \"\").strip().lower()\n            _term_name, _hyphen, colors = term.rpartition(\"-\")\n            color_system = _TERM_COLORS.get(colors, ColorSystem.STANDARD)\n            return color_system\n\n    def _enter_buffer(self) -> None:\n        \"\"\"Enter in to a buffer context, and buffer all output.\"\"\"\n        self._buffer_index += 1\n\n    def _exit_buffer(self) -> None:\n        \"\"\"Leave buffer context, and render content if required.\"\"\"\n        self._buffer_index -= 1\n        self._check_buffer()\n\n    def set_live(self, live: \"Live\") -> None:\n        \"\"\"Set Live instance. Used by Live context manager.\n\n        Args:\n            live (Live): Live instance using this Console.\n\n        Raises:\n            errors.LiveError: If this Console has a Live context currently active.\n        \"\"\"\n        with self._lock:\n            if self._live is not None:\n                raise errors.LiveError(\"Only one live display may be active at once\")\n            self._live = live\n\n    def clear_live(self) -> None:\n        \"\"\"Clear the Live instance.\"\"\"\n        with self._lock:\n            self._live = None\n\n    def push_render_hook(self, hook: RenderHook) -> None:\n        \"\"\"Add a new render hook to the stack.\n\n        Args:\n            hook (RenderHook): Render hook instance.\n        \"\"\"\n        with self._lock:\n            self._render_hooks.append(hook)\n\n    def pop_render_hook(self) -> None:\n        \"\"\"Pop the last renderhook from the stack.\"\"\"\n        with self._lock:\n            self._render_hooks.pop()\n\n    def __enter__(self) -> \"Console\":\n        \"\"\"Own context manager to enter buffer context.\"\"\"\n        self._enter_buffer()\n        return self\n\n    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> None:\n        \"\"\"Exit buffer context.\"\"\"\n        self._exit_buffer()\n\n    def begin_capture(self) -> None:\n        \"\"\"Begin capturing console output. Call :meth:`end_capture` to exit capture mode and return output.\"\"\"\n        self._enter_buffer()\n\n    def end_capture(self) -> str:\n        \"\"\"End capture mode and return captured string.\n\n        Returns:\n            str: Console output.\n        \"\"\"\n        render_result = self._render_buffer(self._buffer)\n        del self._buffer[:]\n        self._exit_buffer()\n        return render_result\n\n    def push_theme(self, theme: Theme, *, inherit: bool = True) -> None:\n        \"\"\"Push a new theme on to the top of the stack, replacing the styles from the previous theme.\n        Generally speaking, you should call :meth:`~rich.console.Console.use_theme` to get a context manager, rather\n        than calling this method directly.\n\n        Args:\n            theme (Theme): A theme instance.\n            inherit (bool, optional): Inherit existing styles. Defaults to True.\n        \"\"\"\n        self._theme_stack.push_theme(theme, inherit=inherit)\n\n    def pop_theme(self) -> None:\n        \"\"\"Remove theme from top of stack, restoring previous theme.\"\"\"\n        self._theme_stack.pop_theme()\n\n    def use_theme(self, theme: Theme, *, inherit: bool = True) -> ThemeContext:\n        \"\"\"Use a different theme for the duration of the context manager.\n\n        Args:\n            theme (Theme): Theme instance to user.\n            inherit (bool, optional): Inherit existing console styles. Defaults to True.\n\n        Returns:\n            ThemeContext: [description]\n        \"\"\"\n        return ThemeContext(self, theme, inherit)\n\n    @property\n    def color_system(self) -> Optional[str]:\n        \"\"\"Get color system string.\n\n        Returns:\n            Optional[str]: \"standard\", \"256\" or \"truecolor\".\n        \"\"\"\n\n        if self._color_system is not None:\n            return _COLOR_SYSTEMS_NAMES[self._color_system]\n        else:\n            return None\n\n    @property\n    def encoding(self) -> str:\n        \"\"\"Get the encoding of the console file, e.g. ``\"utf-8\"``.\n\n        Returns:\n            str: A standard encoding string.\n        \"\"\"\n        return (getattr(self.file, \"encoding\", \"utf-8\") or \"utf-8\").lower()\n\n    @property\n    def is_terminal(self) -> bool:\n        \"\"\"Check if the console is writing to a terminal.\n\n        Returns:\n            bool: True if the console writing to a device capable of\n            understanding terminal codes, otherwise False.\n        \"\"\"\n        if self._force_terminal is not None:\n            return self._force_terminal\n\n        if hasattr(sys.stdin, \"__module__\") and sys.stdin.__module__.startswith(\n            \"idlelib\"\n        ):\n            # Return False for Idle which claims to be a tty but can't handle ansi codes\n            return False\n\n        if self.is_jupyter:\n            # return False for Jupyter, which may have FORCE_COLOR set\n            return False\n\n        # If FORCE_COLOR env var has any value at all, we assume a terminal.\n        force_color = self._environ.get(\"FORCE_COLOR\")\n        if force_color is not None:\n            self._force_terminal = True\n            return True\n\n        isatty: Optional[Callable[[], bool]] = getattr(self.file, \"isatty\", None)\n        try:\n            return False if isatty is None else isatty()\n        except ValueError:\n            # in some situation (at the end of a pytest run for example) isatty() can raise\n            # ValueError: I/O operation on closed file\n            # return False because we aren't in a terminal anymore\n            return False\n\n    @property\n    def is_dumb_terminal(self) -> bool:\n        \"\"\"Detect dumb terminal.\n\n        Returns:\n            bool: True if writing to a dumb terminal, otherwise False.\n\n        \"\"\"\n        _term = self._environ.get(\"TERM\", \"\")\n        is_dumb = _term.lower() in (\"dumb\", \"unknown\")\n        return self.is_terminal and is_dumb\n\n    @property\n    def options(self) -> ConsoleOptions:\n        \"\"\"Get default console options.\"\"\"\n        return ConsoleOptions(\n            max_height=self.size.height,\n            size=self.size,\n            legacy_windows=self.legacy_windows,\n            min_width=1,\n            max_width=self.width,\n            encoding=self.encoding,\n            is_terminal=self.is_terminal,\n        )\n\n    @property\n    def size(self) -> ConsoleDimensions:\n        \"\"\"Get the size of the console.\n\n        Returns:\n            ConsoleDimensions: A named tuple containing the dimensions.\n        \"\"\"\n\n        if self._width is not None and self._height is not None:\n            return ConsoleDimensions(self._width - self.legacy_windows, self._height)\n\n        if self.is_dumb_terminal:\n            return ConsoleDimensions(80, 25)\n\n        width: Optional[int] = None\n        height: Optional[int] = None\n\n        streams = _STD_STREAMS_OUTPUT if WINDOWS else _STD_STREAMS\n        for file_descriptor in streams:\n            try:\n                width, height = os.get_terminal_size(file_descriptor)\n            except (AttributeError, ValueError, OSError):  # Probably not a terminal\n                pass\n            else:\n                break\n\n        columns = self._environ.get(\"COLUMNS\")\n        if columns is not None and columns.isdigit():\n            width = int(columns)\n        lines = self._environ.get(\"LINES\")\n        if lines is not None and lines.isdigit():\n            height = int(lines)\n\n        # get_terminal_size can report 0, 0 if run from pseudo-terminal\n        width = width or 80\n        height = height or 25\n        return ConsoleDimensions(\n            width - self.legacy_windows if self._width is None else self._width,\n            height if self._height is None else self._height,\n        )\n\n    @size.setter\n    def size(self, new_size: Tuple[int, int]) -> None:\n        \"\"\"Set a new size for the terminal.\n\n        Args:\n            new_size (Tuple[int, int]): New width and height.\n        \"\"\"\n        width, height = new_size\n        self._width = width\n        self._height = height\n\n    @property\n    def width(self) -> int:\n        \"\"\"Get the width of the console.\n\n        Returns:\n            int: The width (in characters) of the console.\n        \"\"\"\n        return self.size.width\n\n    @width.setter\n    def width(self, width: int) -> None:\n        \"\"\"Set width.\n\n        Args:\n            width (int): New width.\n        \"\"\"\n        self._width = width\n\n    @property\n    def height(self) -> int:\n        \"\"\"Get the height of the console.\n\n        Returns:\n            int: The height (in lines) of the console.\n        \"\"\"\n        return self.size.height\n\n    @height.setter\n    def height(self, height: int) -> None:\n        \"\"\"Set height.\n\n        Args:\n            height (int): new height.\n        \"\"\"\n        self._height = height\n\n    def bell(self) -> None:\n        \"\"\"Play a 'bell' sound (if supported by the terminal).\"\"\"\n        self.control(Control.bell())\n\n    def capture(self) -> Capture:\n        \"\"\"A context manager to *capture* the result of print() or log() in a string,\n        rather than writing it to the console.\n\n        Example:\n            >>> from rich.console import Console\n            >>> console = Console()\n            >>> with console.capture() as capture:\n            ...     console.print(\"[bold magenta]Hello World[/]\")\n            >>> print(capture.get())\n\n        Returns:\n            Capture: Context manager with disables writing to the terminal.\n        \"\"\"\n        capture = Capture(self)\n        return capture\n\n    def pager(\n        self, pager: Optional[Pager] = None, styles: bool = False, links: bool = False\n    ) -> PagerContext:\n        \"\"\"A context manager to display anything printed within a \"pager\". The pager application\n        is defined by the system and will typically support at least pressing a key to scroll.\n\n        Args:\n            pager (Pager, optional): A pager object, or None to use :class:`~rich.pager.SystemPager`. Defaults to None.\n            styles (bool, optional): Show styles in pager. Defaults to False.\n            links (bool, optional): Show links in pager. Defaults to False.\n\n        Example:\n            >>> from rich.console import Console\n            >>> from rich.__main__ import make_test_card\n            >>> console = Console()\n            >>> with console.pager():\n                    console.print(make_test_card())\n\n        Returns:\n            PagerContext: A context manager.\n        \"\"\"\n        return PagerContext(self, pager=pager, styles=styles, links=links)\n\n    def line(self, count: int = 1) -> None:\n        \"\"\"Write new line(s).\n\n        Args:\n            count (int, optional): Number of new lines. Defaults to 1.\n        \"\"\"\n\n        assert count >= 0, \"count must be >= 0\"\n        self.print(NewLine(count))\n\n    def clear(self, home: bool = True) -> None:\n        \"\"\"Clear the screen.\n\n        Args:\n            home (bool, optional): Also move the cursor to 'home' position. Defaults to True.\n        \"\"\"\n        if home:\n            self.control(Control.clear(), Control.home())\n        else:\n            self.control(Control.clear())\n\n    def status(\n        self,\n        status: RenderableType,\n        *,\n        spinner: str = \"dots\",\n        spinner_style: StyleType = \"status.spinner\",\n        speed: float = 1.0,\n        refresh_per_second: float = 12.5,\n    ) -> \"Status\":\n        \"\"\"Display a status and spinner.\n\n        Args:\n            status (RenderableType): A status renderable (str or Text typically).\n            spinner (str, optional): Name of spinner animation (see python -m rich.spinner). Defaults to \"dots\".\n            spinner_style (StyleType, optional): Style of spinner. Defaults to \"status.spinner\".\n            speed (float, optional): Speed factor for spinner animation. Defaults to 1.0.\n            refresh_per_second (float, optional): Number of refreshes per second. Defaults to 12.5.\n\n        Returns:\n            Status: A Status object that may be used as a context manager.\n        \"\"\"\n        from .status import Status\n\n        status_renderable = Status(\n            status,\n            console=self,\n            spinner=spinner,\n            spinner_style=spinner_style,\n            speed=speed,\n            refresh_per_second=refresh_per_second,\n        )\n        return status_renderable\n\n    def show_cursor(self, show: bool = True) -> bool:\n        \"\"\"Show or hide the cursor.\n\n        Args:\n            show (bool, optional): Set visibility of the cursor.\n        \"\"\"\n        if self.is_terminal:\n            self.control(Control.show_cursor(show))\n            return True\n        return False\n\n    def set_alt_screen(self, enable: bool = True) -> bool:\n        \"\"\"Enables alternative screen mode.\n\n        Note, if you enable this mode, you should ensure that is disabled before\n        the application exits. See :meth:`~rich.Console.screen` for a context manager\n        that handles this for you.\n\n        Args:\n            enable (bool, optional): Enable (True) or disable (False) alternate screen. Defaults to True.\n\n        Returns:\n            bool: True if the control codes were written.\n\n        \"\"\"\n        changed = False\n        if self.is_terminal and not self.legacy_windows:\n            self.control(Control.alt_screen(enable))\n            changed = True\n            self._is_alt_screen = enable\n        return changed\n\n    @property\n    def is_alt_screen(self) -> bool:\n        \"\"\"Check if the alt screen was enabled.\n\n        Returns:\n            bool: True if the alt screen was enabled, otherwise False.\n        \"\"\"\n        return self._is_alt_screen\n\n    def set_window_title(self, title: str) -> bool:\n        \"\"\"Set the title of the console terminal window.\n\n        Warning: There is no means within Rich of \"resetting\" the window title to its\n        previous value, meaning the title you set will persist even after your application\n        exits.\n\n        ``fish`` shell resets the window title before and after each command by default,\n        negating this issue. Windows Terminal and command prompt will also reset the title for you.\n        Most other shells and terminals, however, do not do this.\n\n        Some terminals may require configuration changes before you can set the title.\n        Some terminals may not support setting the title at all.\n\n        Other software (including the terminal itself, the shell, custom prompts, plugins, etc.)\n        may also set the terminal window title. This could result in whatever value you write\n        using this method being overwritten.\n\n        Args:\n            title (str): The new title of the terminal window.\n\n        Returns:\n            bool: True if the control code to change the terminal title was\n                written, otherwise False. Note that a return value of True\n                does not guarantee that the window title has actually changed,\n                since the feature may be unsupported/disabled in some terminals.\n        \"\"\"\n        if self.is_terminal:\n            self.control(Control.title(title))\n            return True\n        return False\n\n    def screen(\n        self, hide_cursor: bool = True, style: Optional[StyleType] = None\n    ) -> \"ScreenContext\":\n        \"\"\"Context manager to enable and disable 'alternative screen' mode.\n\n        Args:\n            hide_cursor (bool, optional): Also hide the cursor. Defaults to False.\n            style (Style, optional): Optional style for screen. Defaults to None.\n\n        Returns:\n            ~ScreenContext: Context which enables alternate screen on enter, and disables it on exit.\n        \"\"\"\n        return ScreenContext(self, hide_cursor=hide_cursor, style=style or \"\")\n\n    def measure(\n        self, renderable: RenderableType, *, options: Optional[ConsoleOptions] = None\n    ) -> Measurement:\n        \"\"\"Measure a renderable. Returns a :class:`~rich.measure.Measurement` object which contains\n        information regarding the number of characters required to print the renderable.\n\n        Args:\n            renderable (RenderableType): Any renderable or string.\n            options (Optional[ConsoleOptions], optional): Options to use when measuring, or None\n                to use default options. Defaults to None.\n\n        Returns:\n            Measurement: A measurement of the renderable.\n        \"\"\"\n        measurement = Measurement.get(self, options or self.options, renderable)\n        return measurement\n\n    def render(\n        self, renderable: RenderableType, options: Optional[ConsoleOptions] = None\n    ) -> Iterable[Segment]:\n        \"\"\"Render an object in to an iterable of `Segment` instances.\n\n        This method contains the logic for rendering objects with the console protocol.\n        You are unlikely to need to use it directly, unless you are extending the library.\n\n        Args:\n            renderable (RenderableType): An object supporting the console protocol, or\n                an object that may be converted to a string.\n            options (ConsoleOptions, optional): An options object, or None to use self.options. Defaults to None.\n\n        Returns:\n            Iterable[Segment]: An iterable of segments that may be rendered.\n        \"\"\"\n\n        _options = options or self.options\n        if _options.max_width < 1:\n            # No space to render anything. This prevents potential recursion errors.\n            return\n        render_iterable: RenderResult\n\n        renderable = rich_cast(renderable)\n        if hasattr(renderable, \"__rich_console__\") and not isclass(renderable):\n            render_iterable = renderable.__rich_console__(self, _options)\n        elif isinstance(renderable, str):\n            text_renderable = self.render_str(\n                renderable, highlight=_options.highlight, markup=_options.markup\n            )\n            render_iterable = text_renderable.__rich_console__(self, _options)\n        else:\n            raise errors.NotRenderableError(\n                f\"Unable to render {renderable!r}; \"\n                \"A str, Segment or object with __rich_console__ method is required\"\n            )\n\n        try:\n            iter_render = iter(render_iterable)\n        except TypeError:\n            raise errors.NotRenderableError(\n                f\"object {render_iterable!r} is not renderable\"\n            )\n        _Segment = Segment\n        _options = _options.reset_height()\n        for render_output in iter_render:\n            if isinstance(render_output, _Segment):\n                yield render_output\n            else:\n                yield from self.render(render_output, _options)\n\n    def render_lines(\n        self,\n        renderable: RenderableType,\n        options: Optional[ConsoleOptions] = None,\n        *,\n        style: Optional[Style] = None,\n        pad: bool = True,\n        new_lines: bool = False,\n    ) -> List[List[Segment]]:\n        \"\"\"Render objects in to a list of lines.\n\n        The output of render_lines is useful when further formatting of rendered console text\n        is required, such as the Panel class which draws a border around any renderable object.\n\n        Args:\n            renderable (RenderableType): Any object renderable in the console.\n            options (Optional[ConsoleOptions], optional): Console options, or None to use self.options. Default to ``None``.\n            style (Style, optional): Optional style to apply to renderables. Defaults to ``None``.\n            pad (bool, optional): Pad lines shorter than render width. Defaults to ``True``.\n            new_lines (bool, optional): Include \"\\n\" characters at end of lines.\n\n        Returns:\n            List[List[Segment]]: A list of lines, where a line is a list of Segment objects.\n        \"\"\"\n        with self._lock:\n            render_options = options or self.options\n            _rendered = self.render(renderable, render_options)\n            if style:\n                _rendered = Segment.apply_style(_rendered, style)\n\n            render_height = render_options.height\n            if render_height is not None:\n                render_height = max(0, render_height)\n\n            lines = list(\n                islice(\n                    Segment.split_and_crop_lines(\n                        _rendered,\n                        render_options.max_width,\n                        include_new_lines=new_lines,\n                        pad=pad,\n                        style=style,\n                    ),\n                    None,\n                    render_height,\n                )\n            )\n            if render_options.height is not None:\n                extra_lines = render_options.height - len(lines)\n                if extra_lines > 0:\n                    pad_line = [\n                        (\n                            [\n                                Segment(\" \" * render_options.max_width, style),\n                                Segment(\"\\n\"),\n                            ]\n                            if new_lines\n                            else [Segment(\" \" * render_options.max_width, style)]\n                        )\n                    ]\n                    lines.extend(pad_line * extra_lines)\n\n            return lines\n\n    def render_str(\n        self,\n        text: str,\n        *,\n        style: Union[str, Style] = \"\",\n        justify: Optional[JustifyMethod] = None,\n        overflow: Optional[OverflowMethod] = None,\n        emoji: Optional[bool] = None,\n        markup: Optional[bool] = None,\n        highlight: Optional[bool] = None,\n        highlighter: Optional[HighlighterType] = None,\n    ) -> \"Text\":\n        \"\"\"Convert a string to a Text instance. This is called automatically if\n        you print or log a string.\n\n        Args:\n            text (str): Text to render.\n            style (Union[str, Style], optional): Style to apply to rendered text.\n            justify (str, optional): Justify method: \"default\", \"left\", \"center\", \"full\", or \"right\". Defaults to ``None``.\n            overflow (str, optional): Overflow method: \"crop\", \"fold\", or \"ellipsis\". Defaults to ``None``.\n            emoji (Optional[bool], optional): Enable emoji, or ``None`` to use Console default.\n            markup (Optional[bool], optional): Enable markup, or ``None`` to use Console default.\n            highlight (Optional[bool], optional): Enable highlighting, or ``None`` to use Console default.\n            highlighter (HighlighterType, optional): Optional highlighter to apply.\n        Returns:\n            ConsoleRenderable: Renderable object.\n\n        \"\"\"\n        emoji_enabled = emoji or (emoji is None and self._emoji)\n        markup_enabled = markup or (markup is None and self._markup)\n        highlight_enabled = highlight or (highlight is None and self._highlight)\n\n        if markup_enabled:\n            rich_text = render_markup(\n                text,\n                style=style,\n                emoji=emoji_enabled,\n                emoji_variant=self._emoji_variant,\n            )\n            rich_text.justify = justify\n            rich_text.overflow = overflow\n        else:\n            rich_text = Text(\n                (\n                    _emoji_replace(text, default_variant=self._emoji_variant)\n                    if emoji_enabled\n                    else text\n                ),\n                justify=justify,\n                overflow=overflow,\n                style=style,\n            )\n\n        _highlighter = (highlighter or self.highlighter) if highlight_enabled else None\n        if _highlighter is not None:\n            highlight_text = _highlighter(str(rich_text))\n            highlight_text.copy_styles(rich_text)\n            return highlight_text\n\n        return rich_text\n\n    def get_style(\n        self, name: Union[str, Style], *, default: Optional[Union[Style, str]] = None\n    ) -> Style:\n        \"\"\"Get a Style instance by its theme name or parse a definition.\n\n        Args:\n            name (str): The name of a style or a style definition.\n\n        Returns:\n            Style: A Style object.\n\n        Raises:\n            MissingStyle: If no style could be parsed from name.\n\n        \"\"\"\n        if isinstance(name, Style):\n            return name\n\n        try:\n            style = self._theme_stack.get(name)\n            if style is None:\n                style = Style.parse(name)\n            return style.copy() if style.link else style\n        except errors.StyleSyntaxError as error:\n            if default is not None:\n                return self.get_style(default)\n            raise errors.MissingStyle(\n                f\"Failed to get style {name!r}; {error}\"\n            ) from None\n\n    def _collect_renderables(\n        self,\n        objects: Iterable[Any],\n        sep: str,\n        end: str,\n        *,\n        justify: Optional[JustifyMethod] = None,\n        emoji: Optional[bool] = None,\n        markup: Optional[bool] = None,\n        highlight: Optional[bool] = None,\n    ) -> List[ConsoleRenderable]:\n        \"\"\"Combine a number of renderables and text into one renderable.\n\n        Args:\n            objects (Iterable[Any]): Anything that Rich can render.\n            sep (str): String to write between print data.\n            end (str): String to write at end of print data.\n            justify (str, optional): One of \"left\", \"right\", \"center\", or \"full\". Defaults to ``None``.\n            emoji (Optional[bool], optional): Enable emoji code, or ``None`` to use console default.\n            markup (Optional[bool], optional): Enable markup, or ``None`` to use console default.\n            highlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use console default.\n\n        Returns:\n            List[ConsoleRenderable]: A list of things to render.\n        \"\"\"\n        renderables: List[ConsoleRenderable] = []\n        _append = renderables.append\n        text: List[Text] = []\n        append_text = text.append\n\n        append = _append\n        if justify in (\"left\", \"center\", \"right\"):\n\n            def align_append(renderable: RenderableType) -> None:\n                _append(Align(renderable, cast(AlignMethod, justify)))\n\n            append = align_append\n\n        _highlighter: HighlighterType = _null_highlighter\n        if highlight or (highlight is None and self._highlight):\n            _highlighter = self.highlighter\n\n        def check_text() -> None:\n            if text:\n                sep_text = Text(sep, justify=justify, end=end)\n                append(sep_text.join(text))\n                text.clear()\n\n        for renderable in objects:\n            renderable = rich_cast(renderable)\n            if isinstance(renderable, str):\n                append_text(\n                    self.render_str(\n                        renderable,\n                        emoji=emoji,\n                        markup=markup,\n                        highlight=highlight,\n                        highlighter=_highlighter,\n                    )\n                )\n            elif isinstance(renderable, Text):\n                append_text(renderable)\n            elif isinstance(renderable, ConsoleRenderable):\n                check_text()\n                append(renderable)\n            elif is_expandable(renderable):\n                check_text()\n                append(Pretty(renderable, highlighter=_highlighter))\n            else:\n                append_text(_highlighter(str(renderable)))\n\n        check_text()\n\n        if self.style is not None:\n            style = self.get_style(self.style)\n            renderables = [Styled(renderable, style) for renderable in renderables]\n\n        return renderables\n\n    def rule(\n        self,\n        title: TextType = \"\",\n        *,\n        characters: str = \"â”€\",\n        style: Union[str, Style] = \"rule.line\",\n        align: AlignMethod = \"center\",\n    ) -> None:\n        \"\"\"Draw a line with optional centered title.\n\n        Args:\n            title (str, optional): Text to render over the rule. Defaults to \"\".\n            characters (str, optional): Character(s) to form the line. Defaults to \"â”€\".\n            style (str, optional): Style of line. Defaults to \"rule.line\".\n            align (str, optional): How to align the title, one of \"left\", \"center\", or \"right\". Defaults to \"center\".\n        \"\"\"\n        from .rule import Rule\n\n        rule = Rule(title=title, characters=characters, style=style, align=align)\n        self.print(rule)\n\n    def control(self, *control: Control) -> None:\n        \"\"\"Insert non-printing control codes.\n\n        Args:\n            control_codes (str): Control codes, such as those that may move the cursor.\n        \"\"\"\n        if not self.is_dumb_terminal:\n            with self:\n                self._buffer.extend(_control.segment for _control in control)\n\n    def out(\n        self,\n        *objects: Any,\n        sep: str = \" \",\n        end: str = \"\\n\",\n        style: Optional[Union[str, Style]] = None,\n        highlight: Optional[bool] = None,\n    ) -> None:\n        \"\"\"Output to the terminal. This is a low-level way of writing to the terminal which unlike\n        :meth:`~rich.console.Console.print` won't pretty print, wrap text, or apply markup, but will\n        optionally apply highlighting and a basic style.\n\n        Args:\n            sep (str, optional): String to write between print data. Defaults to \" \".\n            end (str, optional): String to write at end of print data. Defaults to \"\\\\\\\\n\".\n            style (Union[str, Style], optional): A style to apply to output. Defaults to None.\n            highlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use\n                console default. Defaults to ``None``.\n        \"\"\"\n        raw_output: str = sep.join(str(_object) for _object in objects)\n        self.print(\n            raw_output,\n            style=style,\n            highlight=highlight,\n            emoji=False,\n            markup=False,\n            no_wrap=True,\n            overflow=\"ignore\",\n            crop=False,\n            end=end,\n        )\n\n    def print(\n        self,\n        *objects: Any,\n        sep: str = \" \",\n        end: str = \"\\n\",\n        style: Optional[Union[str, Style]] = None,\n        justify: Optional[JustifyMethod] = None,\n        overflow: Optional[OverflowMethod] = None,\n        no_wrap: Optional[bool] = None,\n        emoji: Optional[bool] = None,\n        markup: Optional[bool] = None,\n        highlight: Optional[bool] = None,\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        crop: bool = True,\n        soft_wrap: Optional[bool] = None,\n        new_line_start: bool = False,\n    ) -> None:\n        \"\"\"Print to the console.\n\n        Args:\n            objects (positional args): Objects to log to the terminal.\n            sep (str, optional): String to write between print data. Defaults to \" \".\n            end (str, optional): String to write at end of print data. Defaults to \"\\\\\\\\n\".\n            style (Union[str, Style], optional): A style to apply to output. Defaults to None.\n            justify (str, optional): Justify method: \"default\", \"left\", \"right\", \"center\", or \"full\". Defaults to ``None``.\n            overflow (str, optional): Overflow method: \"ignore\", \"crop\", \"fold\", or \"ellipsis\". Defaults to None.\n            no_wrap (Optional[bool], optional): Disable word wrapping. Defaults to None.\n            emoji (Optional[bool], optional): Enable emoji code, or ``None`` to use console default. Defaults to ``None``.\n            markup (Optional[bool], optional): Enable markup, or ``None`` to use console default. Defaults to ``None``.\n            highlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use console default. Defaults to ``None``.\n            width (Optional[int], optional): Width of output, or ``None`` to auto-detect. Defaults to ``None``.\n            crop (Optional[bool], optional): Crop output to width of terminal. Defaults to True.\n            soft_wrap (bool, optional): Enable soft wrap mode which disables word wrapping and cropping of text or ``None`` for\n                Console default. Defaults to ``None``.\n            new_line_start (bool, False): Insert a new line at the start if the output contains more than one line. Defaults to ``False``.\n        \"\"\"\n        if not objects:\n            objects = (NewLine(),)\n\n        if soft_wrap is None:\n            soft_wrap = self.soft_wrap\n        if soft_wrap:\n            if no_wrap is None:\n                no_wrap = True\n            if overflow is None:\n                overflow = \"ignore\"\n            crop = False\n        render_hooks = self._render_hooks[:]\n        with self:\n            renderables = self._collect_renderables(\n                objects,\n                sep,\n                end,\n                justify=justify,\n                emoji=emoji,\n                markup=markup,\n                highlight=highlight,\n            )\n            for hook in render_hooks:\n                renderables = hook.process_renderables(renderables)\n            render_options = self.options.update(\n                justify=justify,\n                overflow=overflow,\n                width=min(width, self.width) if width is not None else NO_CHANGE,\n                height=height,\n                no_wrap=no_wrap,\n                markup=markup,\n                highlight=highlight,\n            )\n\n            new_segments: List[Segment] = []\n            extend = new_segments.extend\n            render = self.render\n            if style is None:\n                for renderable in renderables:\n                    extend(render(renderable, render_options))\n            else:\n                for renderable in renderables:\n                    extend(\n                        Segment.apply_style(\n                            render(renderable, render_options), self.get_style(style)\n                        )\n                    )\n            if new_line_start:\n                if (\n                    len(\"\".join(segment.text for segment in new_segments).splitlines())\n                    > 1\n                ):\n                    new_segments.insert(0, Segment.line())\n            if crop:\n                buffer_extend = self._buffer.extend\n                for line in Segment.split_and_crop_lines(\n                    new_segments, self.width, pad=False\n                ):\n                    buffer_extend(line)\n            else:\n                self._buffer.extend(new_segments)\n\n    def print_json(\n        self,\n        json: Optional[str] = None,\n        *,\n        data: Any = None,\n        indent: Union[None, int, str] = 2,\n        highlight: bool = True,\n        skip_keys: bool = False,\n        ensure_ascii: bool = False,\n        check_circular: bool = True,\n        allow_nan: bool = True,\n        default: Optional[Callable[[Any], Any]] = None,\n        sort_keys: bool = False,\n    ) -> None:\n        \"\"\"Pretty prints JSON. Output will be valid JSON.\n\n        Args:\n            json (Optional[str]): A string containing JSON.\n            data (Any): If json is not supplied, then encode this data.\n            indent (Union[None, int, str], optional): Number of spaces to indent. Defaults to 2.\n            highlight (bool, optional): Enable highlighting of output: Defaults to True.\n            skip_keys (bool, optional): Skip keys not of a basic type. Defaults to False.\n            ensure_ascii (bool, optional): Escape all non-ascii characters. Defaults to False.\n            check_circular (bool, optional): Check for circular references. Defaults to True.\n            allow_nan (bool, optional): Allow NaN and Infinity values. Defaults to True.\n            default (Callable, optional): A callable that converts values that can not be encoded\n                in to something that can be JSON encoded. Defaults to None.\n            sort_keys (bool, optional): Sort dictionary keys. Defaults to False.\n        \"\"\"\n        from pip._vendor.rich.json import JSON\n\n        if json is None:\n            json_renderable = JSON.from_data(\n                data,\n                indent=indent,\n                highlight=highlight,\n                skip_keys=skip_keys,\n                ensure_ascii=ensure_ascii,\n                check_circular=check_circular,\n                allow_nan=allow_nan,\n                default=default,\n                sort_keys=sort_keys,\n            )\n        else:\n            if not isinstance(json, str):\n                raise TypeError(\n                    f\"json must be str. Did you mean print_json(data={json!r}) ?\"\n                )\n            json_renderable = JSON(\n                json,\n                indent=indent,\n                highlight=highlight,\n                skip_keys=skip_keys,\n                ensure_ascii=ensure_ascii,\n                check_circular=check_circular,\n                allow_nan=allow_nan,\n                default=default,\n                sort_keys=sort_keys,\n            )\n        self.print(json_renderable, soft_wrap=True)\n\n    def update_screen(\n        self,\n        renderable: RenderableType,\n        *,\n        region: Optional[Region] = None,\n        options: Optional[ConsoleOptions] = None,\n    ) -> None:\n        \"\"\"Update the screen at a given offset.\n\n        Args:\n            renderable (RenderableType): A Rich renderable.\n            region (Region, optional): Region of screen to update, or None for entire screen. Defaults to None.\n            x (int, optional): x offset. Defaults to 0.\n            y (int, optional): y offset. Defaults to 0.\n\n        Raises:\n            errors.NoAltScreen: If the Console isn't in alt screen mode.\n\n        \"\"\"\n        if not self.is_alt_screen:\n            raise errors.NoAltScreen(\"Alt screen must be enabled to call update_screen\")\n        render_options = options or self.options\n        if region is None:\n            x = y = 0\n            render_options = render_options.update_dimensions(\n                render_options.max_width, render_options.height or self.height\n            )\n        else:\n            x, y, width, height = region\n            render_options = render_options.update_dimensions(width, height)\n\n        lines = self.render_lines(renderable, options=render_options)\n        self.update_screen_lines(lines, x, y)\n\n    def update_screen_lines(\n        self, lines: List[List[Segment]], x: int = 0, y: int = 0\n    ) -> None:\n        \"\"\"Update lines of the screen at a given offset.\n\n        Args:\n            lines (List[List[Segment]]): Rendered lines (as produced by :meth:`~rich.Console.render_lines`).\n            x (int, optional): x offset (column no). Defaults to 0.\n            y (int, optional): y offset (column no). Defaults to 0.\n\n        Raises:\n            errors.NoAltScreen: If the Console isn't in alt screen mode.\n        \"\"\"\n        if not self.is_alt_screen:\n            raise errors.NoAltScreen(\"Alt screen must be enabled to call update_screen\")\n        screen_update = ScreenUpdate(lines, x, y)\n        segments = self.render(screen_update)\n        self._buffer.extend(segments)\n        self._check_buffer()\n\n    def print_exception(\n        self,\n        *,\n        width: Optional[int] = 100,\n        extra_lines: int = 3,\n        theme: Optional[str] = None,\n        word_wrap: bool = False,\n        show_locals: bool = False,\n        suppress: Iterable[Union[str, ModuleType]] = (),\n        max_frames: int = 100,\n    ) -> None:\n        \"\"\"Prints a rich render of the last exception and traceback.\n\n        Args:\n            width (Optional[int], optional): Number of characters used to render code. Defaults to 100.\n            extra_lines (int, optional): Additional lines of code to render. Defaults to 3.\n            theme (str, optional): Override pygments theme used in traceback\n            word_wrap (bool, optional): Enable word wrapping of long lines. Defaults to False.\n            show_locals (bool, optional): Enable display of local variables. Defaults to False.\n            suppress (Iterable[Union[str, ModuleType]]): Optional sequence of modules or paths to exclude from traceback.\n            max_frames (int): Maximum number of frames to show in a traceback, 0 for no maximum. Defaults to 100.\n        \"\"\"\n        from .traceback import Traceback\n\n        traceback = Traceback(\n            width=width,\n            extra_lines=extra_lines,\n            theme=theme,\n            word_wrap=word_wrap,\n            show_locals=show_locals,\n            suppress=suppress,\n            max_frames=max_frames,\n        )\n        self.print(traceback)\n\n    @staticmethod\n    def _caller_frame_info(\n        offset: int,\n        currentframe: Callable[[], Optional[FrameType]] = inspect.currentframe,\n    ) -> Tuple[str, int, Dict[str, Any]]:\n        \"\"\"Get caller frame information.\n\n        Args:\n            offset (int): the caller offset within the current frame stack.\n            currentframe (Callable[[], Optional[FrameType]], optional): the callable to use to\n                retrieve the current frame. Defaults to ``inspect.currentframe``.\n\n        Returns:\n            Tuple[str, int, Dict[str, Any]]: A tuple containing the filename, the line number and\n                the dictionary of local variables associated with the caller frame.\n\n        Raises:\n            RuntimeError: If the stack offset is invalid.\n        \"\"\"\n        # Ignore the frame of this local helper\n        offset += 1\n\n        frame = currentframe()\n        if frame is not None:\n            # Use the faster currentframe where implemented\n            while offset and frame is not None:\n                frame = frame.f_back\n                offset -= 1\n            assert frame is not None\n            return frame.f_code.co_filename, frame.f_lineno, frame.f_locals\n        else:\n            # Fallback to the slower stack\n            frame_info = inspect.stack()[offset]\n            return frame_info.filename, frame_info.lineno, frame_info.frame.f_locals\n\n    def log(\n        self,\n        *objects: Any,\n        sep: str = \" \",\n        end: str = \"\\n\",\n        style: Optional[Union[str, Style]] = None,\n        justify: Optional[JustifyMethod] = None,\n        emoji: Optional[bool] = None,\n        markup: Optional[bool] = None,\n        highlight: Optional[bool] = None,\n        log_locals: bool = False,\n        _stack_offset: int = 1,\n    ) -> None:\n        \"\"\"Log rich content to the terminal.\n\n        Args:\n            objects (positional args): Objects to log to the terminal.\n            sep (str, optional): String to write between print data. Defaults to \" \".\n            end (str, optional): String to write at end of print data. Defaults to \"\\\\\\\\n\".\n            style (Union[str, Style], optional): A style to apply to output. Defaults to None.\n            justify (str, optional): One of \"left\", \"right\", \"center\", or \"full\". Defaults to ``None``.\n            emoji (Optional[bool], optional): Enable emoji code, or ``None`` to use console default. Defaults to None.\n            markup (Optional[bool], optional): Enable markup, or ``None`` to use console default. Defaults to None.\n            highlight (Optional[bool], optional): Enable automatic highlighting, or ``None`` to use console default. Defaults to None.\n            log_locals (bool, optional): Boolean to enable logging of locals where ``log()``\n                was called. Defaults to False.\n            _stack_offset (int, optional): Offset of caller from end of call stack. Defaults to 1.\n        \"\"\"\n        if not objects:\n            objects = (NewLine(),)\n\n        render_hooks = self._render_hooks[:]\n\n        with self:\n            renderables = self._collect_renderables(\n                objects,\n                sep,\n                end,\n                justify=justify,\n                emoji=emoji,\n                markup=markup,\n                highlight=highlight,\n            )\n            if style is not None:\n                renderables = [Styled(renderable, style) for renderable in renderables]\n\n            filename, line_no, locals = self._caller_frame_info(_stack_offset)\n            link_path = None if filename.startswith(\"<\") else os.path.abspath(filename)\n            path = filename.rpartition(os.sep)[-1]\n            if log_locals:\n                locals_map = {\n                    key: value\n                    for key, value in locals.items()\n                    if not key.startswith(\"__\")\n                }\n                renderables.append(render_scope(locals_map, title=\"[i]locals\"))\n\n            renderables = [\n                self._log_render(\n                    self,\n                    renderables,\n                    log_time=self.get_datetime(),\n                    path=path,\n                    line_no=line_no,\n                    link_path=link_path,\n                )\n            ]\n            for hook in render_hooks:\n                renderables = hook.process_renderables(renderables)\n            new_segments: List[Segment] = []\n            extend = new_segments.extend\n            render = self.render\n            render_options = self.options\n            for renderable in renderables:\n                extend(render(renderable, render_options))\n            buffer_extend = self._buffer.extend\n            for line in Segment.split_and_crop_lines(\n                new_segments, self.width, pad=False\n            ):\n                buffer_extend(line)\n\n    def on_broken_pipe(self) -> None:\n        \"\"\"This function is called when a `BrokenPipeError` is raised.\n\n        This can occur when piping Textual output in Linux and macOS.\n        The default implementation is to exit the app, but you could implement\n        this method in a subclass to change the behavior.\n\n        See https://docs.python.org/3/library/signal.html#note-on-sigpipe for details.\n        \"\"\"\n        self.quiet = True\n        devnull = os.open(os.devnull, os.O_WRONLY)\n        os.dup2(devnull, sys.stdout.fileno())\n        raise SystemExit(1)\n\n    def _check_buffer(self) -> None:\n        \"\"\"Check if the buffer may be rendered. Render it if it can (e.g. Console.quiet is False)\n        Rendering is supported on Windows, Unix and Jupyter environments. For\n        legacy Windows consoles, the win32 API is called directly.\n        This method will also record what it renders if recording is enabled via Console.record.\n        \"\"\"\n        if self.quiet:\n            del self._buffer[:]\n            return\n\n        try:\n            self._write_buffer()\n        except BrokenPipeError:\n            self.on_broken_pipe()\n\n    def _write_buffer(self) -> None:\n        \"\"\"Write the buffer to the output file.\"\"\"\n\n        with self._lock:\n            if self.record and not self._buffer_index:\n                with self._record_buffer_lock:\n                    self._record_buffer.extend(self._buffer[:])\n\n            if self._buffer_index == 0:\n                if self.is_jupyter:  # pragma: no cover\n                    from .jupyter import display\n\n                    display(self._buffer, self._render_buffer(self._buffer[:]))\n                    del self._buffer[:]\n                else:\n                    if WINDOWS:\n                        use_legacy_windows_render = False\n                        if self.legacy_windows:\n                            fileno = get_fileno(self.file)\n                            if fileno is not None:\n                                use_legacy_windows_render = (\n                                    fileno in _STD_STREAMS_OUTPUT\n                                )\n\n                        if use_legacy_windows_render:\n                            from pip._vendor.rich._win32_console import LegacyWindowsTerm\n                            from pip._vendor.rich._windows_renderer import legacy_windows_render\n\n                            buffer = self._buffer[:]\n                            if self.no_color and self._color_system:\n                                buffer = list(Segment.remove_color(buffer))\n\n                            legacy_windows_render(buffer, LegacyWindowsTerm(self.file))\n                        else:\n                            # Either a non-std stream on legacy Windows, or modern Windows.\n                            text = self._render_buffer(self._buffer[:])\n                            # https://bugs.python.org/issue37871\n                            # https://github.com/python/cpython/issues/82052\n                            # We need to avoid writing more than 32Kb in a single write, due to the above bug\n                            write = self.file.write\n                            # Worse case scenario, every character is 4 bytes of utf-8\n                            MAX_WRITE = 32 * 1024 // 4\n                            try:\n                                if len(text) <= MAX_WRITE:\n                                    write(text)\n                                else:\n                                    batch: List[str] = []\n                                    batch_append = batch.append\n                                    size = 0\n                                    for line in text.splitlines(True):\n                                        if size + len(line) > MAX_WRITE and batch:\n                                            write(\"\".join(batch))\n                                            batch.clear()\n                                            size = 0\n                                        batch_append(line)\n                                        size += len(line)\n                                    if batch:\n                                        write(\"\".join(batch))\n                                        batch.clear()\n                            except UnicodeEncodeError as error:\n                                error.reason = f\"{error.reason}\\n*** You may need to add PYTHONIOENCODING=utf-8 to your environment ***\"\n                                raise\n                    else:\n                        text = self._render_buffer(self._buffer[:])\n                        try:\n                            self.file.write(text)\n                        except UnicodeEncodeError as error:\n                            error.reason = f\"{error.reason}\\n*** You may need to add PYTHONIOENCODING=utf-8 to your environment ***\"\n                            raise\n\n                    self.file.flush()\n                    del self._buffer[:]\n\n    def _render_buffer(self, buffer: Iterable[Segment]) -> str:\n        \"\"\"Render buffered output, and clear buffer.\"\"\"\n        output: List[str] = []\n        append = output.append\n        color_system = self._color_system\n        legacy_windows = self.legacy_windows\n        not_terminal = not self.is_terminal\n        if self.no_color and color_system:\n            buffer = Segment.remove_color(buffer)\n        for text, style, control in buffer:\n            if style:\n                append(\n                    style.render(\n                        text,\n                        color_system=color_system,\n                        legacy_windows=legacy_windows,\n                    )\n                )\n            elif not (not_terminal and control):\n                append(text)\n\n        rendered = \"\".join(output)\n        return rendered\n\n    def input(\n        self,\n        prompt: TextType = \"\",\n        *,\n        markup: bool = True,\n        emoji: bool = True,\n        password: bool = False,\n        stream: Optional[TextIO] = None,\n    ) -> str:\n        \"\"\"Displays a prompt and waits for input from the user. The prompt may contain color / style.\n\n        It works in the same way as Python's builtin :func:`input` function and provides elaborate line editing and history features if Python's builtin :mod:`readline` module is previously loaded.\n\n        Args:\n            prompt (Union[str, Text]): Text to render in the prompt.\n            markup (bool, optional): Enable console markup (requires a str prompt). Defaults to True.\n            emoji (bool, optional): Enable emoji (requires a str prompt). Defaults to True.\n            password: (bool, optional): Hide typed text. Defaults to False.\n            stream: (TextIO, optional): Optional file to read input from (rather than stdin). Defaults to None.\n\n        Returns:\n            str: Text read from stdin.\n        \"\"\"\n        if prompt:\n            self.print(prompt, markup=markup, emoji=emoji, end=\"\")\n        if password:\n            result = getpass(\"\", stream=stream)\n        else:\n            if stream:\n                result = stream.readline()\n            else:\n                result = input()\n        return result\n\n    def export_text(self, *, clear: bool = True, styles: bool = False) -> str:\n        \"\"\"Generate text from console contents (requires record=True argument in constructor).\n\n        Args:\n            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.\n            styles (bool, optional): If ``True``, ansi escape codes will be included. ``False`` for plain text.\n                Defaults to ``False``.\n\n        Returns:\n            str: String containing console contents.\n\n        \"\"\"\n        assert (\n            self.record\n        ), \"To export console contents set record=True in the constructor or instance\"\n\n        with self._record_buffer_lock:\n            if styles:\n                text = \"\".join(\n                    (style.render(text) if style else text)\n                    for text, style, _ in self._record_buffer\n                )\n            else:\n                text = \"\".join(\n                    segment.text\n                    for segment in self._record_buffer\n                    if not segment.control\n                )\n            if clear:\n                del self._record_buffer[:]\n        return text\n\n    def save_text(self, path: str, *, clear: bool = True, styles: bool = False) -> None:\n        \"\"\"Generate text from console and save to a given location (requires record=True argument in constructor).\n\n        Args:\n            path (str): Path to write text files.\n            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.\n            styles (bool, optional): If ``True``, ansi style codes will be included. ``False`` for plain text.\n                Defaults to ``False``.\n\n        \"\"\"\n        text = self.export_text(clear=clear, styles=styles)\n        with open(path, \"w\", encoding=\"utf-8\") as write_file:\n            write_file.write(text)\n\n    def export_html(\n        self,\n        *,\n        theme: Optional[TerminalTheme] = None,\n        clear: bool = True,\n        code_format: Optional[str] = None,\n        inline_styles: bool = False,\n    ) -> str:\n        \"\"\"Generate HTML from console contents (requires record=True argument in constructor).\n\n        Args:\n            theme (TerminalTheme, optional): TerminalTheme object containing console colors.\n            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.\n            code_format (str, optional): Format string to render HTML. In addition to '{foreground}',\n                '{background}', and '{code}', should contain '{stylesheet}' if inline_styles is ``False``.\n            inline_styles (bool, optional): If ``True`` styles will be inlined in to spans, which makes files\n                larger but easier to cut and paste markup. If ``False``, styles will be embedded in a style tag.\n                Defaults to False.\n\n        Returns:\n            str: String containing console contents as HTML.\n        \"\"\"\n        assert (\n            self.record\n        ), \"To export console contents set record=True in the constructor or instance\"\n        fragments: List[str] = []\n        append = fragments.append\n        _theme = theme or DEFAULT_TERMINAL_THEME\n        stylesheet = \"\"\n\n        render_code_format = CONSOLE_HTML_FORMAT if code_format is None else code_format\n\n        with self._record_buffer_lock:\n            if inline_styles:\n                for text, style, _ in Segment.filter_control(\n                    Segment.simplify(self._record_buffer)\n                ):\n                    text = escape(text)\n                    if style:\n                        rule = style.get_html_style(_theme)\n                        if style.link:\n                            text = f'<a href=\"{style.link}\">{text}</a>'\n                        text = f'<span style=\"{rule}\">{text}</span>' if rule else text\n                    append(text)\n            else:\n                styles: Dict[str, int] = {}\n                for text, style, _ in Segment.filter_control(\n                    Segment.simplify(self._record_buffer)\n                ):\n                    text = escape(text)\n                    if style:\n                        rule = style.get_html_style(_theme)\n                        style_number = styles.setdefault(rule, len(styles) + 1)\n                        if style.link:\n                            text = f'<a class=\"r{style_number}\" href=\"{style.link}\">{text}</a>'\n                        else:\n                            text = f'<span class=\"r{style_number}\">{text}</span>'\n                    append(text)\n                stylesheet_rules: List[str] = []\n                stylesheet_append = stylesheet_rules.append\n                for style_rule, style_number in styles.items():\n                    if style_rule:\n                        stylesheet_append(f\".r{style_number} {{{style_rule}}}\")\n                stylesheet = \"\\n\".join(stylesheet_rules)\n\n            rendered_code = render_code_format.format(\n                code=\"\".join(fragments),\n                stylesheet=stylesheet,\n                foreground=_theme.foreground_color.hex,\n                background=_theme.background_color.hex,\n            )\n            if clear:\n                del self._record_buffer[:]\n        return rendered_code\n\n    def save_html(\n        self,\n        path: str,\n        *,\n        theme: Optional[TerminalTheme] = None,\n        clear: bool = True,\n        code_format: str = CONSOLE_HTML_FORMAT,\n        inline_styles: bool = False,\n    ) -> None:\n        \"\"\"Generate HTML from console contents and write to a file (requires record=True argument in constructor).\n\n        Args:\n            path (str): Path to write html file.\n            theme (TerminalTheme, optional): TerminalTheme object containing console colors.\n            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``.\n            code_format (str, optional): Format string to render HTML. In addition to '{foreground}',\n                '{background}', and '{code}', should contain '{stylesheet}' if inline_styles is ``False``.\n            inline_styles (bool, optional): If ``True`` styles will be inlined in to spans, which makes files\n                larger but easier to cut and paste markup. If ``False``, styles will be embedded in a style tag.\n                Defaults to False.\n\n        \"\"\"\n        html = self.export_html(\n            theme=theme,\n            clear=clear,\n            code_format=code_format,\n            inline_styles=inline_styles,\n        )\n        with open(path, \"w\", encoding=\"utf-8\") as write_file:\n            write_file.write(html)\n\n    def export_svg(\n        self,\n        *,\n        title: str = \"Rich\",\n        theme: Optional[TerminalTheme] = None,\n        clear: bool = True,\n        code_format: str = CONSOLE_SVG_FORMAT,\n        font_aspect_ratio: float = 0.61,\n        unique_id: Optional[str] = None,\n    ) -> str:\n        \"\"\"\n        Generate an SVG from the console contents (requires record=True in Console constructor).\n\n        Args:\n            title (str, optional): The title of the tab in the output image\n            theme (TerminalTheme, optional): The ``TerminalTheme`` object to use to style the terminal\n            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``\n            code_format (str, optional): Format string used to generate the SVG. Rich will inject a number of variables\n                into the string in order to form the final SVG output. The default template used and the variables\n                injected by Rich can be found by inspecting the ``console.CONSOLE_SVG_FORMAT`` variable.\n            font_aspect_ratio (float, optional): The width to height ratio of the font used in the ``code_format``\n                string. Defaults to 0.61, which is the width to height ratio of Fira Code (the default font).\n                If you aren't specifying a different font inside ``code_format``, you probably don't need this.\n            unique_id (str, optional): unique id that is used as the prefix for various elements (CSS styles, node\n                ids). If not set, this defaults to a computed value based on the recorded content.\n        \"\"\"\n\n        from pip._vendor.rich.cells import cell_len\n\n        style_cache: Dict[Style, str] = {}\n\n        def get_svg_style(style: Style) -> str:\n            \"\"\"Convert a Style to CSS rules for SVG.\"\"\"\n            if style in style_cache:\n                return style_cache[style]\n            css_rules = []\n            color = (\n                _theme.foreground_color\n                if (style.color is None or style.color.is_default)\n                else style.color.get_truecolor(_theme)\n            )\n            bgcolor = (\n                _theme.background_color\n                if (style.bgcolor is None or style.bgcolor.is_default)\n                else style.bgcolor.get_truecolor(_theme)\n            )\n            if style.reverse:\n                color, bgcolor = bgcolor, color\n            if style.dim:\n                color = blend_rgb(color, bgcolor, 0.4)\n            css_rules.append(f\"fill: {color.hex}\")\n            if style.bold:\n                css_rules.append(\"font-weight: bold\")\n            if style.italic:\n                css_rules.append(\"font-style: italic;\")\n            if style.underline:\n                css_rules.append(\"text-decoration: underline;\")\n            if style.strike:\n                css_rules.append(\"text-decoration: line-through;\")\n\n            css = \";\".join(css_rules)\n            style_cache[style] = css\n            return css\n\n        _theme = theme or SVG_EXPORT_THEME\n\n        width = self.width\n        char_height = 20\n        char_width = char_height * font_aspect_ratio\n        line_height = char_height * 1.22\n\n        margin_top = 1\n        margin_right = 1\n        margin_bottom = 1\n        margin_left = 1\n\n        padding_top = 40\n        padding_right = 8\n        padding_bottom = 8\n        padding_left = 8\n\n        padding_width = padding_left + padding_right\n        padding_height = padding_top + padding_bottom\n        margin_width = margin_left + margin_right\n        margin_height = margin_top + margin_bottom\n\n        text_backgrounds: List[str] = []\n        text_group: List[str] = []\n        classes: Dict[str, int] = {}\n        style_no = 1\n\n        def escape_text(text: str) -> str:\n            \"\"\"HTML escape text and replace spaces with nbsp.\"\"\"\n            return escape(text).replace(\" \", \"&#160;\")\n\n        def make_tag(\n            name: str, content: Optional[str] = None, **attribs: object\n        ) -> str:\n            \"\"\"Make a tag from name, content, and attributes.\"\"\"\n\n            def stringify(value: object) -> str:\n                if isinstance(value, (float)):\n                    return format(value, \"g\")\n                return str(value)\n\n            tag_attribs = \" \".join(\n                f'{k.lstrip(\"_\").replace(\"_\", \"-\")}=\"{stringify(v)}\"'\n                for k, v in attribs.items()\n            )\n            return (\n                f\"<{name} {tag_attribs}>{content}</{name}>\"\n                if content\n                else f\"<{name} {tag_attribs}/>\"\n            )\n\n        with self._record_buffer_lock:\n            segments = list(Segment.filter_control(self._record_buffer))\n            if clear:\n                self._record_buffer.clear()\n\n        if unique_id is None:\n            unique_id = \"terminal-\" + str(\n                zlib.adler32(\n                    (\"\".join(repr(segment) for segment in segments)).encode(\n                        \"utf-8\",\n                        \"ignore\",\n                    )\n                    + title.encode(\"utf-8\", \"ignore\")\n                )\n            )\n        y = 0\n        for y, line in enumerate(Segment.split_and_crop_lines(segments, length=width)):\n            x = 0\n            for text, style, _control in line:\n                style = style or Style()\n                rules = get_svg_style(style)\n                if rules not in classes:\n                    classes[rules] = style_no\n                    style_no += 1\n                class_name = f\"r{classes[rules]}\"\n\n                if style.reverse:\n                    has_background = True\n                    background = (\n                        _theme.foreground_color.hex\n                        if style.color is None\n                        else style.color.get_truecolor(_theme).hex\n                    )\n                else:\n                    bgcolor = style.bgcolor\n                    has_background = bgcolor is not None and not bgcolor.is_default\n                    background = (\n                        _theme.background_color.hex\n                        if style.bgcolor is None\n                        else style.bgcolor.get_truecolor(_theme).hex\n                    )\n\n                text_length = cell_len(text)\n                if has_background:\n                    text_backgrounds.append(\n                        make_tag(\n                            \"rect\",\n                            fill=background,\n                            x=x * char_width,\n                            y=y * line_height + 1.5,\n                            width=char_width * text_length,\n                            height=line_height + 0.25,\n                            shape_rendering=\"crispEdges\",\n                        )\n                    )\n\n                if text != \" \" * len(text):\n                    text_group.append(\n                        make_tag(\n                            \"text\",\n                            escape_text(text),\n                            _class=f\"{unique_id}-{class_name}\",\n                            x=x * char_width,\n                            y=y * line_height + char_height,\n                            textLength=char_width * len(text),\n                            clip_path=f\"url(#{unique_id}-line-{y})\",\n                        )\n                    )\n                x += cell_len(text)\n\n        line_offsets = [line_no * line_height + 1.5 for line_no in range(y)]\n        lines = \"\\n\".join(\n            f\"\"\"<clipPath id=\"{unique_id}-line-{line_no}\">\n    {make_tag(\"rect\", x=0, y=offset, width=char_width * width, height=line_height + 0.25)}\n            </clipPath>\"\"\"\n            for line_no, offset in enumerate(line_offsets)\n        )\n\n        styles = \"\\n\".join(\n            f\".{unique_id}-r{rule_no} {{ {css} }}\" for css, rule_no in classes.items()\n        )\n        backgrounds = \"\".join(text_backgrounds)\n        matrix = \"\".join(text_group)\n\n        terminal_width = ceil(width * char_width + padding_width)\n        terminal_height = (y + 1) * line_height + padding_height\n        chrome = make_tag(\n            \"rect\",\n            fill=_theme.background_color.hex,\n            stroke=\"rgba(255,255,255,0.35)\",\n            stroke_width=\"1\",\n            x=margin_left,\n            y=margin_top,\n            width=terminal_width,\n            height=terminal_height,\n            rx=8,\n        )\n\n        title_color = _theme.foreground_color.hex\n        if title:\n            chrome += make_tag(\n                \"text\",\n                escape_text(title),\n                _class=f\"{unique_id}-title\",\n                fill=title_color,\n                text_anchor=\"middle\",\n                x=terminal_width // 2,\n                y=margin_top + char_height + 6,\n            )\n        chrome += f\"\"\"\n            <g transform=\"translate(26,22)\">\n            <circle cx=\"0\" cy=\"0\" r=\"7\" fill=\"#ff5f57\"/>\n            <circle cx=\"22\" cy=\"0\" r=\"7\" fill=\"#febc2e\"/>\n            <circle cx=\"44\" cy=\"0\" r=\"7\" fill=\"#28c840\"/>\n            </g>\n        \"\"\"\n\n        svg = code_format.format(\n            unique_id=unique_id,\n            char_width=char_width,\n            char_height=char_height,\n            line_height=line_height,\n            terminal_width=char_width * width - 1,\n            terminal_height=(y + 1) * line_height - 1,\n            width=terminal_width + margin_width,\n            height=terminal_height + margin_height,\n            terminal_x=margin_left + padding_left,\n            terminal_y=margin_top + padding_top,\n            styles=styles,\n            chrome=chrome,\n            backgrounds=backgrounds,\n            matrix=matrix,\n            lines=lines,\n        )\n        return svg\n\n    def save_svg(\n        self,\n        path: str,\n        *,\n        title: str = \"Rich\",\n        theme: Optional[TerminalTheme] = None,\n        clear: bool = True,\n        code_format: str = CONSOLE_SVG_FORMAT,\n        font_aspect_ratio: float = 0.61,\n        unique_id: Optional[str] = None,\n    ) -> None:\n        \"\"\"Generate an SVG file from the console contents (requires record=True in Console constructor).\n\n        Args:\n            path (str): The path to write the SVG to.\n            title (str, optional): The title of the tab in the output image\n            theme (TerminalTheme, optional): The ``TerminalTheme`` object to use to style the terminal\n            clear (bool, optional): Clear record buffer after exporting. Defaults to ``True``\n            code_format (str, optional): Format string used to generate the SVG. Rich will inject a number of variables\n                into the string in order to form the final SVG output. The default template used and the variables\n                injected by Rich can be found by inspecting the ``console.CONSOLE_SVG_FORMAT`` variable.\n            font_aspect_ratio (float, optional): The width to height ratio of the font used in the ``code_format``\n                string. Defaults to 0.61, which is the width to height ratio of Fira Code (the default font).\n                If you aren't specifying a different font inside ``code_format``, you probably don't need this.\n            unique_id (str, optional): unique id that is used as the prefix for various elements (CSS styles, node\n                ids). If not set, this defaults to a computed value based on the recorded content.\n        \"\"\"\n        svg = self.export_svg(\n            title=title,\n            theme=theme,\n            clear=clear,\n            code_format=code_format,\n            font_aspect_ratio=font_aspect_ratio,\n            unique_id=unique_id,\n        )\n        with open(path, \"w\", encoding=\"utf-8\") as write_file:\n            write_file.write(svg)\n\n\ndef _svg_hash(svg_main_code: str) -> str:\n    \"\"\"Returns a unique hash for the given SVG main code.\n\n    Args:\n        svg_main_code (str): The content we're going to inject in the SVG envelope.\n\n    Returns:\n        str: a hash of the given content\n    \"\"\"\n    return str(zlib.adler32(svg_main_code.encode()))\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    console = Console(record=True)\n\n    console.log(\n        \"JSONRPC [i]request[/i]\",\n        5,\n        1.3,\n        True,\n        False,\n        None,\n        {\n            \"jsonrpc\": \"2.0\",\n            \"method\": \"subtract\",\n            \"params\": {\"minuend\": 42, \"subtrahend\": 23},\n            \"id\": 3,\n        },\n    )\n\n    console.log(\"Hello, World!\", \"{'a': 1}\", repr(console))\n\n    console.print(\n        {\n            \"name\": None,\n            \"empty\": [],\n            \"quiz\": {\n                \"sport\": {\n                    \"answered\": True,\n                    \"q1\": {\n                        \"question\": \"Which one is correct team name in NBA?\",\n                        \"options\": [\n                            \"New York Bulls\",\n                            \"Los Angeles Kings\",\n                            \"Golden State Warriors\",\n                            \"Huston Rocket\",\n                        ],\n                        \"answer\": \"Huston Rocket\",\n                    },\n                },\n                \"maths\": {\n                    \"answered\": False,\n                    \"q1\": {\n                        \"question\": \"5 + 7 = ?\",\n                        \"options\": [10, 11, 12, 13],\n                        \"answer\": 12,\n                    },\n                    \"q2\": {\n                        \"question\": \"12 - 8 = ?\",\n                        \"options\": [1, 2, 3, 4],\n                        \"answer\": 4,\n                    },\n                },\n            },\n        }\n    )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/constrain.py","size":1288,"sha1":"97d8b90ab5f8d1eefb5f75b72a5658391ca58223","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import Optional, TYPE_CHECKING\n\nfrom .jupyter import JupyterMixin\nfrom .measure import Measurement\n\nif TYPE_CHECKING:\n    from .console import Console, ConsoleOptions, RenderableType, RenderResult\n\n\nclass Constrain(JupyterMixin):\n    \"\"\"Constrain the width of a renderable to a given number of characters.\n\n    Args:\n        renderable (RenderableType): A renderable object.\n        width (int, optional): The maximum width (in characters) to render. Defaults to 80.\n    \"\"\"\n\n    def __init__(self, renderable: \"RenderableType\", width: Optional[int] = 80) -> None:\n        self.renderable = renderable\n        self.width = width\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        if self.width is None:\n            yield self.renderable\n        else:\n            child_options = options.update_width(min(self.width, options.max_width))\n            yield from console.render(self.renderable, child_options)\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        if self.width is not None:\n            options = options.update_width(self.width)\n        measurement = Measurement.get(console, options, self.renderable)\n        return measurement\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/containers.py","size":5502,"sha1":"e78906a601db4e8284aae0033e5bb27568083e61","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from itertools import zip_longest\nfrom typing import (\n    TYPE_CHECKING,\n    Iterable,\n    Iterator,\n    List,\n    Optional,\n    TypeVar,\n    Union,\n    overload,\n)\n\nif TYPE_CHECKING:\n    from .console import (\n        Console,\n        ConsoleOptions,\n        JustifyMethod,\n        OverflowMethod,\n        RenderResult,\n        RenderableType,\n    )\n    from .text import Text\n\nfrom .cells import cell_len\nfrom .measure import Measurement\n\nT = TypeVar(\"T\")\n\n\nclass Renderables:\n    \"\"\"A list subclass which renders its contents to the console.\"\"\"\n\n    def __init__(\n        self, renderables: Optional[Iterable[\"RenderableType\"]] = None\n    ) -> None:\n        self._renderables: List[\"RenderableType\"] = (\n            list(renderables) if renderables is not None else []\n        )\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        \"\"\"Console render method to insert line-breaks.\"\"\"\n        yield from self._renderables\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        dimensions = [\n            Measurement.get(console, options, renderable)\n            for renderable in self._renderables\n        ]\n        if not dimensions:\n            return Measurement(1, 1)\n        _min = max(dimension.minimum for dimension in dimensions)\n        _max = max(dimension.maximum for dimension in dimensions)\n        return Measurement(_min, _max)\n\n    def append(self, renderable: \"RenderableType\") -> None:\n        self._renderables.append(renderable)\n\n    def __iter__(self) -> Iterable[\"RenderableType\"]:\n        return iter(self._renderables)\n\n\nclass Lines:\n    \"\"\"A list subclass which can render to the console.\"\"\"\n\n    def __init__(self, lines: Iterable[\"Text\"] = ()) -> None:\n        self._lines: List[\"Text\"] = list(lines)\n\n    def __repr__(self) -> str:\n        return f\"Lines({self._lines!r})\"\n\n    def __iter__(self) -> Iterator[\"Text\"]:\n        return iter(self._lines)\n\n    @overload\n    def __getitem__(self, index: int) -> \"Text\":\n        ...\n\n    @overload\n    def __getitem__(self, index: slice) -> List[\"Text\"]:\n        ...\n\n    def __getitem__(self, index: Union[slice, int]) -> Union[\"Text\", List[\"Text\"]]:\n        return self._lines[index]\n\n    def __setitem__(self, index: int, value: \"Text\") -> \"Lines\":\n        self._lines[index] = value\n        return self\n\n    def __len__(self) -> int:\n        return self._lines.__len__()\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        \"\"\"Console render method to insert line-breaks.\"\"\"\n        yield from self._lines\n\n    def append(self, line: \"Text\") -> None:\n        self._lines.append(line)\n\n    def extend(self, lines: Iterable[\"Text\"]) -> None:\n        self._lines.extend(lines)\n\n    def pop(self, index: int = -1) -> \"Text\":\n        return self._lines.pop(index)\n\n    def justify(\n        self,\n        console: \"Console\",\n        width: int,\n        justify: \"JustifyMethod\" = \"left\",\n        overflow: \"OverflowMethod\" = \"fold\",\n    ) -> None:\n        \"\"\"Justify and overflow text to a given width.\n\n        Args:\n            console (Console): Console instance.\n            width (int): Number of cells available per line.\n            justify (str, optional): Default justify method for text: \"left\", \"center\", \"full\" or \"right\". Defaults to \"left\".\n            overflow (str, optional): Default overflow for text: \"crop\", \"fold\", or \"ellipsis\". Defaults to \"fold\".\n\n        \"\"\"\n        from .text import Text\n\n        if justify == \"left\":\n            for line in self._lines:\n                line.truncate(width, overflow=overflow, pad=True)\n        elif justify == \"center\":\n            for line in self._lines:\n                line.rstrip()\n                line.truncate(width, overflow=overflow)\n                line.pad_left((width - cell_len(line.plain)) // 2)\n                line.pad_right(width - cell_len(line.plain))\n        elif justify == \"right\":\n            for line in self._lines:\n                line.rstrip()\n                line.truncate(width, overflow=overflow)\n                line.pad_left(width - cell_len(line.plain))\n        elif justify == \"full\":\n            for line_index, line in enumerate(self._lines):\n                if line_index == len(self._lines) - 1:\n                    break\n                words = line.split(\" \")\n                words_size = sum(cell_len(word.plain) for word in words)\n                num_spaces = len(words) - 1\n                spaces = [1 for _ in range(num_spaces)]\n                index = 0\n                if spaces:\n                    while words_size + num_spaces < width:\n                        spaces[len(spaces) - index - 1] += 1\n                        num_spaces += 1\n                        index = (index + 1) % len(spaces)\n                tokens: List[Text] = []\n                for index, (word, next_word) in enumerate(\n                    zip_longest(words, words[1:])\n                ):\n                    tokens.append(word)\n                    if index < len(spaces):\n                        style = word.get_style_at_offset(console, -1)\n                        next_style = next_word.get_style_at_offset(console, 0)\n                        space_style = style if style == next_style else line.style\n                        tokens.append(Text(\" \" * spaces[index], style=space_style))\n                self[line_index] = Text(\"\").join(tokens)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/control.py","size":6630,"sha1":"59d7c1fb1c7d75955fa319c2d27f341802b8e2f5","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\nimport time\nfrom typing import TYPE_CHECKING, Callable, Dict, Iterable, List, Union\n\nif sys.version_info >= (3, 8):\n    from typing import Final\nelse:\n    from pip._vendor.typing_extensions import Final  # pragma: no cover\n\nfrom .segment import ControlCode, ControlType, Segment\n\nif TYPE_CHECKING:\n    from .console import Console, ConsoleOptions, RenderResult\n\nSTRIP_CONTROL_CODES: Final = [\n    7,  # Bell\n    8,  # Backspace\n    11,  # Vertical tab\n    12,  # Form feed\n    13,  # Carriage return\n]\n_CONTROL_STRIP_TRANSLATE: Final = {\n    _codepoint: None for _codepoint in STRIP_CONTROL_CODES\n}\n\nCONTROL_ESCAPE: Final = {\n    7: \"\\\\a\",\n    8: \"\\\\b\",\n    11: \"\\\\v\",\n    12: \"\\\\f\",\n    13: \"\\\\r\",\n}\n\nCONTROL_CODES_FORMAT: Dict[int, Callable[..., str]] = {\n    ControlType.BELL: lambda: \"\\x07\",\n    ControlType.CARRIAGE_RETURN: lambda: \"\\r\",\n    ControlType.HOME: lambda: \"\\x1b[H\",\n    ControlType.CLEAR: lambda: \"\\x1b[2J\",\n    ControlType.ENABLE_ALT_SCREEN: lambda: \"\\x1b[?1049h\",\n    ControlType.DISABLE_ALT_SCREEN: lambda: \"\\x1b[?1049l\",\n    ControlType.SHOW_CURSOR: lambda: \"\\x1b[?25h\",\n    ControlType.HIDE_CURSOR: lambda: \"\\x1b[?25l\",\n    ControlType.CURSOR_UP: lambda param: f\"\\x1b[{param}A\",\n    ControlType.CURSOR_DOWN: lambda param: f\"\\x1b[{param}B\",\n    ControlType.CURSOR_FORWARD: lambda param: f\"\\x1b[{param}C\",\n    ControlType.CURSOR_BACKWARD: lambda param: f\"\\x1b[{param}D\",\n    ControlType.CURSOR_MOVE_TO_COLUMN: lambda param: f\"\\x1b[{param+1}G\",\n    ControlType.ERASE_IN_LINE: lambda param: f\"\\x1b[{param}K\",\n    ControlType.CURSOR_MOVE_TO: lambda x, y: f\"\\x1b[{y+1};{x+1}H\",\n    ControlType.SET_WINDOW_TITLE: lambda title: f\"\\x1b]0;{title}\\x07\",\n}\n\n\nclass Control:\n    \"\"\"A renderable that inserts a control code (non printable but may move cursor).\n\n    Args:\n        *codes (str): Positional arguments are either a :class:`~rich.segment.ControlType` enum or a\n            tuple of ControlType and an integer parameter\n    \"\"\"\n\n    __slots__ = [\"segment\"]\n\n    def __init__(self, *codes: Union[ControlType, ControlCode]) -> None:\n        control_codes: List[ControlCode] = [\n            (code,) if isinstance(code, ControlType) else code for code in codes\n        ]\n        _format_map = CONTROL_CODES_FORMAT\n        rendered_codes = \"\".join(\n            _format_map[code](*parameters) for code, *parameters in control_codes\n        )\n        self.segment = Segment(rendered_codes, None, control_codes)\n\n    @classmethod\n    def bell(cls) -> \"Control\":\n        \"\"\"Ring the 'bell'.\"\"\"\n        return cls(ControlType.BELL)\n\n    @classmethod\n    def home(cls) -> \"Control\":\n        \"\"\"Move cursor to 'home' position.\"\"\"\n        return cls(ControlType.HOME)\n\n    @classmethod\n    def move(cls, x: int = 0, y: int = 0) -> \"Control\":\n        \"\"\"Move cursor relative to current position.\n\n        Args:\n            x (int): X offset.\n            y (int): Y offset.\n\n        Returns:\n            ~Control: Control object.\n\n        \"\"\"\n\n        def get_codes() -> Iterable[ControlCode]:\n            control = ControlType\n            if x:\n                yield (\n                    control.CURSOR_FORWARD if x > 0 else control.CURSOR_BACKWARD,\n                    abs(x),\n                )\n            if y:\n                yield (\n                    control.CURSOR_DOWN if y > 0 else control.CURSOR_UP,\n                    abs(y),\n                )\n\n        control = cls(*get_codes())\n        return control\n\n    @classmethod\n    def move_to_column(cls, x: int, y: int = 0) -> \"Control\":\n        \"\"\"Move to the given column, optionally add offset to row.\n\n        Returns:\n            x (int): absolute x (column)\n            y (int): optional y offset (row)\n\n        Returns:\n            ~Control: Control object.\n        \"\"\"\n\n        return (\n            cls(\n                (ControlType.CURSOR_MOVE_TO_COLUMN, x),\n                (\n                    ControlType.CURSOR_DOWN if y > 0 else ControlType.CURSOR_UP,\n                    abs(y),\n                ),\n            )\n            if y\n            else cls((ControlType.CURSOR_MOVE_TO_COLUMN, x))\n        )\n\n    @classmethod\n    def move_to(cls, x: int, y: int) -> \"Control\":\n        \"\"\"Move cursor to absolute position.\n\n        Args:\n            x (int): x offset (column)\n            y (int): y offset (row)\n\n        Returns:\n            ~Control: Control object.\n        \"\"\"\n        return cls((ControlType.CURSOR_MOVE_TO, x, y))\n\n    @classmethod\n    def clear(cls) -> \"Control\":\n        \"\"\"Clear the screen.\"\"\"\n        return cls(ControlType.CLEAR)\n\n    @classmethod\n    def show_cursor(cls, show: bool) -> \"Control\":\n        \"\"\"Show or hide the cursor.\"\"\"\n        return cls(ControlType.SHOW_CURSOR if show else ControlType.HIDE_CURSOR)\n\n    @classmethod\n    def alt_screen(cls, enable: bool) -> \"Control\":\n        \"\"\"Enable or disable alt screen.\"\"\"\n        if enable:\n            return cls(ControlType.ENABLE_ALT_SCREEN, ControlType.HOME)\n        else:\n            return cls(ControlType.DISABLE_ALT_SCREEN)\n\n    @classmethod\n    def title(cls, title: str) -> \"Control\":\n        \"\"\"Set the terminal window title\n\n        Args:\n            title (str): The new terminal window title\n        \"\"\"\n        return cls((ControlType.SET_WINDOW_TITLE, title))\n\n    def __str__(self) -> str:\n        return self.segment.text\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        if self.segment.text:\n            yield self.segment\n\n\ndef strip_control_codes(\n    text: str, _translate_table: Dict[int, None] = _CONTROL_STRIP_TRANSLATE\n) -> str:\n    \"\"\"Remove control codes from text.\n\n    Args:\n        text (str): A string possibly contain control codes.\n\n    Returns:\n        str: String with control codes removed.\n    \"\"\"\n    return text.translate(_translate_table)\n\n\ndef escape_control_codes(\n    text: str,\n    _translate_table: Dict[int, str] = CONTROL_ESCAPE,\n) -> str:\n    \"\"\"Replace control codes with their \"escaped\" equivalent in the given text.\n    (e.g. \"\\b\" becomes \"\\\\b\")\n\n    Args:\n        text (str): A string possibly containing control codes.\n\n    Returns:\n        str: String with control codes replaced with their escaped version.\n    \"\"\"\n    return text.translate(_translate_table)\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from pip._vendor.rich.console import Console\n\n    console = Console()\n    console.print(\"Look at the title of your terminal window ^\")\n    # console.print(Control((ControlType.SET_WINDOW_TITLE, \"Hello, world!\")))\n    for i in range(10):\n        console.set_window_title(\"ğŸš€ Loading\" + \".\" * i)\n        time.sleep(0.5)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/default_styles.py","size":8159,"sha1":"6627de17626f218c22af2105cf8e1634067475b6","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import Dict\n\nfrom .style import Style\n\nDEFAULT_STYLES: Dict[str, Style] = {\n    \"none\": Style.null(),\n    \"reset\": Style(\n        color=\"default\",\n        bgcolor=\"default\",\n        dim=False,\n        bold=False,\n        italic=False,\n        underline=False,\n        blink=False,\n        blink2=False,\n        reverse=False,\n        conceal=False,\n        strike=False,\n    ),\n    \"dim\": Style(dim=True),\n    \"bright\": Style(dim=False),\n    \"bold\": Style(bold=True),\n    \"strong\": Style(bold=True),\n    \"code\": Style(reverse=True, bold=True),\n    \"italic\": Style(italic=True),\n    \"emphasize\": Style(italic=True),\n    \"underline\": Style(underline=True),\n    \"blink\": Style(blink=True),\n    \"blink2\": Style(blink2=True),\n    \"reverse\": Style(reverse=True),\n    \"strike\": Style(strike=True),\n    \"black\": Style(color=\"black\"),\n    \"red\": Style(color=\"red\"),\n    \"green\": Style(color=\"green\"),\n    \"yellow\": Style(color=\"yellow\"),\n    \"magenta\": Style(color=\"magenta\"),\n    \"cyan\": Style(color=\"cyan\"),\n    \"white\": Style(color=\"white\"),\n    \"inspect.attr\": Style(color=\"yellow\", italic=True),\n    \"inspect.attr.dunder\": Style(color=\"yellow\", italic=True, dim=True),\n    \"inspect.callable\": Style(bold=True, color=\"red\"),\n    \"inspect.async_def\": Style(italic=True, color=\"bright_cyan\"),\n    \"inspect.def\": Style(italic=True, color=\"bright_cyan\"),\n    \"inspect.class\": Style(italic=True, color=\"bright_cyan\"),\n    \"inspect.error\": Style(bold=True, color=\"red\"),\n    \"inspect.equals\": Style(),\n    \"inspect.help\": Style(color=\"cyan\"),\n    \"inspect.doc\": Style(dim=True),\n    \"inspect.value.border\": Style(color=\"green\"),\n    \"live.ellipsis\": Style(bold=True, color=\"red\"),\n    \"layout.tree.row\": Style(dim=False, color=\"red\"),\n    \"layout.tree.column\": Style(dim=False, color=\"blue\"),\n    \"logging.keyword\": Style(bold=True, color=\"yellow\"),\n    \"logging.level.notset\": Style(dim=True),\n    \"logging.level.debug\": Style(color=\"green\"),\n    \"logging.level.info\": Style(color=\"blue\"),\n    \"logging.level.warning\": Style(color=\"yellow\"),\n    \"logging.level.error\": Style(color=\"red\", bold=True),\n    \"logging.level.critical\": Style(color=\"red\", bold=True, reverse=True),\n    \"log.level\": Style.null(),\n    \"log.time\": Style(color=\"cyan\", dim=True),\n    \"log.message\": Style.null(),\n    \"log.path\": Style(dim=True),\n    \"repr.ellipsis\": Style(color=\"yellow\"),\n    \"repr.indent\": Style(color=\"green\", dim=True),\n    \"repr.error\": Style(color=\"red\", bold=True),\n    \"repr.str\": Style(color=\"green\", italic=False, bold=False),\n    \"repr.brace\": Style(bold=True),\n    \"repr.comma\": Style(bold=True),\n    \"repr.ipv4\": Style(bold=True, color=\"bright_green\"),\n    \"repr.ipv6\": Style(bold=True, color=\"bright_green\"),\n    \"repr.eui48\": Style(bold=True, color=\"bright_green\"),\n    \"repr.eui64\": Style(bold=True, color=\"bright_green\"),\n    \"repr.tag_start\": Style(bold=True),\n    \"repr.tag_name\": Style(color=\"bright_magenta\", bold=True),\n    \"repr.tag_contents\": Style(color=\"default\"),\n    \"repr.tag_end\": Style(bold=True),\n    \"repr.attrib_name\": Style(color=\"yellow\", italic=False),\n    \"repr.attrib_equal\": Style(bold=True),\n    \"repr.attrib_value\": Style(color=\"magenta\", italic=False),\n    \"repr.number\": Style(color=\"cyan\", bold=True, italic=False),\n    \"repr.number_complex\": Style(color=\"cyan\", bold=True, italic=False),  # same\n    \"repr.bool_true\": Style(color=\"bright_green\", italic=True),\n    \"repr.bool_false\": Style(color=\"bright_red\", italic=True),\n    \"repr.none\": Style(color=\"magenta\", italic=True),\n    \"repr.url\": Style(underline=True, color=\"bright_blue\", italic=False, bold=False),\n    \"repr.uuid\": Style(color=\"bright_yellow\", bold=False),\n    \"repr.call\": Style(color=\"magenta\", bold=True),\n    \"repr.path\": Style(color=\"magenta\"),\n    \"repr.filename\": Style(color=\"bright_magenta\"),\n    \"rule.line\": Style(color=\"bright_green\"),\n    \"rule.text\": Style.null(),\n    \"json.brace\": Style(bold=True),\n    \"json.bool_true\": Style(color=\"bright_green\", italic=True),\n    \"json.bool_false\": Style(color=\"bright_red\", italic=True),\n    \"json.null\": Style(color=\"magenta\", italic=True),\n    \"json.number\": Style(color=\"cyan\", bold=True, italic=False),\n    \"json.str\": Style(color=\"green\", italic=False, bold=False),\n    \"json.key\": Style(color=\"blue\", bold=True),\n    \"prompt\": Style.null(),\n    \"prompt.choices\": Style(color=\"magenta\", bold=True),\n    \"prompt.default\": Style(color=\"cyan\", bold=True),\n    \"prompt.invalid\": Style(color=\"red\"),\n    \"prompt.invalid.choice\": Style(color=\"red\"),\n    \"pretty\": Style.null(),\n    \"scope.border\": Style(color=\"blue\"),\n    \"scope.key\": Style(color=\"yellow\", italic=True),\n    \"scope.key.special\": Style(color=\"yellow\", italic=True, dim=True),\n    \"scope.equals\": Style(color=\"red\"),\n    \"table.header\": Style(bold=True),\n    \"table.footer\": Style(bold=True),\n    \"table.cell\": Style.null(),\n    \"table.title\": Style(italic=True),\n    \"table.caption\": Style(italic=True, dim=True),\n    \"traceback.error\": Style(color=\"red\", italic=True),\n    \"traceback.border.syntax_error\": Style(color=\"bright_red\"),\n    \"traceback.border\": Style(color=\"red\"),\n    \"traceback.text\": Style.null(),\n    \"traceback.title\": Style(color=\"red\", bold=True),\n    \"traceback.exc_type\": Style(color=\"bright_red\", bold=True),\n    \"traceback.exc_value\": Style.null(),\n    \"traceback.offset\": Style(color=\"bright_red\", bold=True),\n    \"traceback.error_range\": Style(underline=True, bold=True, dim=False),\n    \"bar.back\": Style(color=\"grey23\"),\n    \"bar.complete\": Style(color=\"rgb(249,38,114)\"),\n    \"bar.finished\": Style(color=\"rgb(114,156,31)\"),\n    \"bar.pulse\": Style(color=\"rgb(249,38,114)\"),\n    \"progress.description\": Style.null(),\n    \"progress.filesize\": Style(color=\"green\"),\n    \"progress.filesize.total\": Style(color=\"green\"),\n    \"progress.download\": Style(color=\"green\"),\n    \"progress.elapsed\": Style(color=\"yellow\"),\n    \"progress.percentage\": Style(color=\"magenta\"),\n    \"progress.remaining\": Style(color=\"cyan\"),\n    \"progress.data.speed\": Style(color=\"red\"),\n    \"progress.spinner\": Style(color=\"green\"),\n    \"status.spinner\": Style(color=\"green\"),\n    \"tree\": Style(),\n    \"tree.line\": Style(),\n    \"markdown.paragraph\": Style(),\n    \"markdown.text\": Style(),\n    \"markdown.em\": Style(italic=True),\n    \"markdown.emph\": Style(italic=True),  # For commonmark backwards compatibility\n    \"markdown.strong\": Style(bold=True),\n    \"markdown.code\": Style(bold=True, color=\"cyan\", bgcolor=\"black\"),\n    \"markdown.code_block\": Style(color=\"cyan\", bgcolor=\"black\"),\n    \"markdown.block_quote\": Style(color=\"magenta\"),\n    \"markdown.list\": Style(color=\"cyan\"),\n    \"markdown.item\": Style(),\n    \"markdown.item.bullet\": Style(color=\"yellow\", bold=True),\n    \"markdown.item.number\": Style(color=\"yellow\", bold=True),\n    \"markdown.hr\": Style(color=\"yellow\"),\n    \"markdown.h1.border\": Style(),\n    \"markdown.h1\": Style(bold=True),\n    \"markdown.h2\": Style(bold=True, underline=True),\n    \"markdown.h3\": Style(bold=True),\n    \"markdown.h4\": Style(bold=True, dim=True),\n    \"markdown.h5\": Style(underline=True),\n    \"markdown.h6\": Style(italic=True),\n    \"markdown.h7\": Style(italic=True, dim=True),\n    \"markdown.link\": Style(color=\"bright_blue\"),\n    \"markdown.link_url\": Style(color=\"blue\", underline=True),\n    \"markdown.s\": Style(strike=True),\n    \"iso8601.date\": Style(color=\"blue\"),\n    \"iso8601.time\": Style(color=\"magenta\"),\n    \"iso8601.timezone\": Style(color=\"yellow\"),\n}\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    import argparse\n    import io\n\n    from pip._vendor.rich.console import Console\n    from pip._vendor.rich.table import Table\n    from pip._vendor.rich.text import Text\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--html\", action=\"store_true\", help=\"Export as HTML table\")\n    args = parser.parse_args()\n    html: bool = args.html\n    console = Console(record=True, width=70, file=io.StringIO()) if html else Console()\n\n    table = Table(\"Name\", \"Styling\")\n\n    for style_name, style in DEFAULT_STYLES.items():\n        table.add_row(Text(style_name, style=style), str(style))\n\n    console.print(table)\n    if html:\n        print(console.export_html(inline_styles=True))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/diagnose.py","size":972,"sha1":"a8d91b9a64a8c1ff92990cd44035812da8217c92","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import os\nimport platform\n\nfrom pip._vendor.rich import inspect\nfrom pip._vendor.rich.console import Console, get_windows_console_features\nfrom pip._vendor.rich.panel import Panel\nfrom pip._vendor.rich.pretty import Pretty\n\n\ndef report() -> None:  # pragma: no cover\n    \"\"\"Print a report to the terminal with debugging information\"\"\"\n    console = Console()\n    inspect(console)\n    features = get_windows_console_features()\n    inspect(features)\n\n    env_names = (\n        \"TERM\",\n        \"COLORTERM\",\n        \"CLICOLOR\",\n        \"NO_COLOR\",\n        \"TERM_PROGRAM\",\n        \"COLUMNS\",\n        \"LINES\",\n        \"JUPYTER_COLUMNS\",\n        \"JUPYTER_LINES\",\n        \"JPY_PARENT_PID\",\n        \"VSCODE_VERBOSE_LOGGING\",\n    )\n    env = {name: os.getenv(name) for name in env_names}\n    console.print(Panel.fit((Pretty(env)), title=\"[b]Environment Variables\"))\n\n    console.print(f'platform=\"{platform.system()}\"')\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    report()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/emoji.py","size":2501,"sha1":"23a65b3dc99d265648ecc0517aa97c8fe767020e","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\nfrom typing import TYPE_CHECKING, Optional, Union\n\nfrom .jupyter import JupyterMixin\nfrom .segment import Segment\nfrom .style import Style\nfrom ._emoji_codes import EMOJI\nfrom ._emoji_replace import _emoji_replace\n\nif sys.version_info >= (3, 8):\n    from typing import Literal\nelse:\n    from pip._vendor.typing_extensions import Literal  # pragma: no cover\n\n\nif TYPE_CHECKING:\n    from .console import Console, ConsoleOptions, RenderResult\n\n\nEmojiVariant = Literal[\"emoji\", \"text\"]\n\n\nclass NoEmoji(Exception):\n    \"\"\"No emoji by that name.\"\"\"\n\n\nclass Emoji(JupyterMixin):\n    __slots__ = [\"name\", \"style\", \"_char\", \"variant\"]\n\n    VARIANTS = {\"text\": \"\\uFE0E\", \"emoji\": \"\\uFE0F\"}\n\n    def __init__(\n        self,\n        name: str,\n        style: Union[str, Style] = \"none\",\n        variant: Optional[EmojiVariant] = None,\n    ) -> None:\n        \"\"\"A single emoji character.\n\n        Args:\n            name (str): Name of emoji.\n            style (Union[str, Style], optional): Optional style. Defaults to None.\n\n        Raises:\n            NoEmoji: If the emoji doesn't exist.\n        \"\"\"\n        self.name = name\n        self.style = style\n        self.variant = variant\n        try:\n            self._char = EMOJI[name]\n        except KeyError:\n            raise NoEmoji(f\"No emoji called {name!r}\")\n        if variant is not None:\n            self._char += self.VARIANTS.get(variant, \"\")\n\n    @classmethod\n    def replace(cls, text: str) -> str:\n        \"\"\"Replace emoji markup with corresponding unicode characters.\n\n        Args:\n            text (str): A string with emojis codes, e.g. \"Hello :smiley:!\"\n\n        Returns:\n            str: A string with emoji codes replaces with actual emoji.\n        \"\"\"\n        return _emoji_replace(text)\n\n    def __repr__(self) -> str:\n        return f\"<emoji {self.name!r}>\"\n\n    def __str__(self) -> str:\n        return self._char\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        yield Segment(self._char, console.get_style(self.style))\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    import sys\n\n    from pip._vendor.rich.columns import Columns\n    from pip._vendor.rich.console import Console\n\n    console = Console(record=True)\n\n    columns = Columns(\n        (f\":{name}: {name}\" for name in sorted(EMOJI.keys()) if \"\\u200D\" not in name),\n        column_first=True,\n    )\n\n    console.print(columns)\n    if len(sys.argv) > 1:\n        console.save_html(sys.argv[1])\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/errors.py","size":642,"sha1":"cfd7926adb4a02cb6df8794999212c6f026af1f1","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"class ConsoleError(Exception):\n    \"\"\"An error in console operation.\"\"\"\n\n\nclass StyleError(Exception):\n    \"\"\"An error in styles.\"\"\"\n\n\nclass StyleSyntaxError(ConsoleError):\n    \"\"\"Style was badly formatted.\"\"\"\n\n\nclass MissingStyle(StyleError):\n    \"\"\"No such style.\"\"\"\n\n\nclass StyleStackError(ConsoleError):\n    \"\"\"Style stack is invalid.\"\"\"\n\n\nclass NotRenderableError(ConsoleError):\n    \"\"\"Object is not renderable.\"\"\"\n\n\nclass MarkupError(ConsoleError):\n    \"\"\"Markup was badly formatted.\"\"\"\n\n\nclass LiveError(ConsoleError):\n    \"\"\"Error related to Live display.\"\"\"\n\n\nclass NoAltScreen(ConsoleError):\n    \"\"\"Alt screen mode was required.\"\"\"\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/file_proxy.py","size":1683,"sha1":"5f7dee3ccc5b50b923adaec01508dfb25984acd6","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import io\nfrom typing import IO, TYPE_CHECKING, Any, List\n\nfrom .ansi import AnsiDecoder\nfrom .text import Text\n\nif TYPE_CHECKING:\n    from .console import Console\n\n\nclass FileProxy(io.TextIOBase):\n    \"\"\"Wraps a file (e.g. sys.stdout) and redirects writes to a console.\"\"\"\n\n    def __init__(self, console: \"Console\", file: IO[str]) -> None:\n        self.__console = console\n        self.__file = file\n        self.__buffer: List[str] = []\n        self.__ansi_decoder = AnsiDecoder()\n\n    @property\n    def rich_proxied_file(self) -> IO[str]:\n        \"\"\"Get proxied file.\"\"\"\n        return self.__file\n\n    def __getattr__(self, name: str) -> Any:\n        return getattr(self.__file, name)\n\n    def write(self, text: str) -> int:\n        if not isinstance(text, str):\n            raise TypeError(f\"write() argument must be str, not {type(text).__name__}\")\n        buffer = self.__buffer\n        lines: List[str] = []\n        while text:\n            line, new_line, text = text.partition(\"\\n\")\n            if new_line:\n                lines.append(\"\".join(buffer) + line)\n                buffer.clear()\n            else:\n                buffer.append(line)\n                break\n        if lines:\n            console = self.__console\n            with console:\n                output = Text(\"\\n\").join(\n                    self.__ansi_decoder.decode_line(line) for line in lines\n                )\n                console.print(output)\n        return len(text)\n\n    def flush(self) -> None:\n        output = \"\".join(self.__buffer)\n        if output:\n            self.__console.print(output)\n        del self.__buffer[:]\n\n    def fileno(self) -> int:\n        return self.__file.fileno()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/filesize.py","size":2484,"sha1":"161b8e1ee81d034f516fc970090fff4bd9350f9a","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Functions for reporting filesizes. Borrowed from https://github.com/PyFilesystem/pyfilesystem2\n\nThe functions declared in this module should cover the different\nuse cases needed to generate a string representation of a file size\nusing several different units. Since there are many standards regarding\nfile size units, three different functions have been implemented.\n\nSee Also:\n    * `Wikipedia: Binary prefix <https://en.wikipedia.org/wiki/Binary_prefix>`_\n\n\"\"\"\n\n__all__ = [\"decimal\"]\n\nfrom typing import Iterable, List, Optional, Tuple\n\n\ndef _to_str(\n    size: int,\n    suffixes: Iterable[str],\n    base: int,\n    *,\n    precision: Optional[int] = 1,\n    separator: Optional[str] = \" \",\n) -> str:\n    if size == 1:\n        return \"1 byte\"\n    elif size < base:\n        return f\"{size:,} bytes\"\n\n    for i, suffix in enumerate(suffixes, 2):  # noqa: B007\n        unit = base**i\n        if size < unit:\n            break\n    return \"{:,.{precision}f}{separator}{}\".format(\n        (base * size / unit),\n        suffix,\n        precision=precision,\n        separator=separator,\n    )\n\n\ndef pick_unit_and_suffix(size: int, suffixes: List[str], base: int) -> Tuple[int, str]:\n    \"\"\"Pick a suffix and base for the given size.\"\"\"\n    for i, suffix in enumerate(suffixes):\n        unit = base**i\n        if size < unit * base:\n            break\n    return unit, suffix\n\n\ndef decimal(\n    size: int,\n    *,\n    precision: Optional[int] = 1,\n    separator: Optional[str] = \" \",\n) -> str:\n    \"\"\"Convert a filesize in to a string (powers of 1000, SI prefixes).\n\n    In this convention, ``1000 B = 1 kB``.\n\n    This is typically the format used to advertise the storage\n    capacity of USB flash drives and the like (*256 MB* meaning\n    actually a storage capacity of more than *256 000 000 B*),\n    or used by **Mac OS X** since v10.6 to report file sizes.\n\n    Arguments:\n        int (size): A file size.\n        int (precision): The number of decimal places to include (default = 1).\n        str (separator): The string to separate the value from the units (default = \" \").\n\n    Returns:\n        `str`: A string containing a abbreviated file size and units.\n\n    Example:\n        >>> filesize.decimal(30000)\n        '30.0 kB'\n        >>> filesize.decimal(30000, precision=2, separator=\"\")\n        '30.00kB'\n\n    \"\"\"\n    return _to_str(\n        size,\n        (\"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"),\n        1000,\n        precision=precision,\n        separator=separator,\n    )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/highlighter.py","size":9586,"sha1":"e5d86b4c15c5184c06a32634a77417a87443490b","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import re\nfrom abc import ABC, abstractmethod\nfrom typing import List, Union\n\nfrom .text import Span, Text\n\n\ndef _combine_regex(*regexes: str) -> str:\n    \"\"\"Combine a number of regexes in to a single regex.\n\n    Returns:\n        str: New regex with all regexes ORed together.\n    \"\"\"\n    return \"|\".join(regexes)\n\n\nclass Highlighter(ABC):\n    \"\"\"Abstract base class for highlighters.\"\"\"\n\n    def __call__(self, text: Union[str, Text]) -> Text:\n        \"\"\"Highlight a str or Text instance.\n\n        Args:\n            text (Union[str, ~Text]): Text to highlight.\n\n        Raises:\n            TypeError: If not called with text or str.\n\n        Returns:\n            Text: A test instance with highlighting applied.\n        \"\"\"\n        if isinstance(text, str):\n            highlight_text = Text(text)\n        elif isinstance(text, Text):\n            highlight_text = text.copy()\n        else:\n            raise TypeError(f\"str or Text instance required, not {text!r}\")\n        self.highlight(highlight_text)\n        return highlight_text\n\n    @abstractmethod\n    def highlight(self, text: Text) -> None:\n        \"\"\"Apply highlighting in place to text.\n\n        Args:\n            text (~Text): A text object highlight.\n        \"\"\"\n\n\nclass NullHighlighter(Highlighter):\n    \"\"\"A highlighter object that doesn't highlight.\n\n    May be used to disable highlighting entirely.\n\n    \"\"\"\n\n    def highlight(self, text: Text) -> None:\n        \"\"\"Nothing to do\"\"\"\n\n\nclass RegexHighlighter(Highlighter):\n    \"\"\"Applies highlighting from a list of regular expressions.\"\"\"\n\n    highlights: List[str] = []\n    base_style: str = \"\"\n\n    def highlight(self, text: Text) -> None:\n        \"\"\"Highlight :class:`rich.text.Text` using regular expressions.\n\n        Args:\n            text (~Text): Text to highlighted.\n\n        \"\"\"\n\n        highlight_regex = text.highlight_regex\n        for re_highlight in self.highlights:\n            highlight_regex(re_highlight, style_prefix=self.base_style)\n\n\nclass ReprHighlighter(RegexHighlighter):\n    \"\"\"Highlights the text typically produced from ``__repr__`` methods.\"\"\"\n\n    base_style = \"repr.\"\n    highlights = [\n        r\"(?P<tag_start><)(?P<tag_name>[-\\w.:|]*)(?P<tag_contents>[\\w\\W]*)(?P<tag_end>>)\",\n        r'(?P<attrib_name>[\\w_]{1,50})=(?P<attrib_value>\"?[\\w_]+\"?)?',\n        r\"(?P<brace>[][{}()])\",\n        _combine_regex(\n            r\"(?P<ipv4>[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})\",\n            r\"(?P<ipv6>([A-Fa-f0-9]{1,4}::?){1,7}[A-Fa-f0-9]{1,4})\",\n            r\"(?P<eui64>(?:[0-9A-Fa-f]{1,2}-){7}[0-9A-Fa-f]{1,2}|(?:[0-9A-Fa-f]{1,2}:){7}[0-9A-Fa-f]{1,2}|(?:[0-9A-Fa-f]{4}\\.){3}[0-9A-Fa-f]{4})\",\n            r\"(?P<eui48>(?:[0-9A-Fa-f]{1,2}-){5}[0-9A-Fa-f]{1,2}|(?:[0-9A-Fa-f]{1,2}:){5}[0-9A-Fa-f]{1,2}|(?:[0-9A-Fa-f]{4}\\.){2}[0-9A-Fa-f]{4})\",\n            r\"(?P<uuid>[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12})\",\n            r\"(?P<call>[\\w.]*?)\\(\",\n            r\"\\b(?P<bool_true>True)\\b|\\b(?P<bool_false>False)\\b|\\b(?P<none>None)\\b\",\n            r\"(?P<ellipsis>\\.\\.\\.)\",\n            r\"(?P<number_complex>(?<!\\w)(?:\\-?[0-9]+\\.?[0-9]*(?:e[-+]?\\d+?)?)(?:[-+](?:[0-9]+\\.?[0-9]*(?:e[-+]?\\d+)?))?j)\",\n            r\"(?P<number>(?<!\\w)\\-?[0-9]+\\.?[0-9]*(e[-+]?\\d+?)?\\b|0x[0-9a-fA-F]*)\",\n            r\"(?P<path>\\B(/[-\\w._+]+)*\\/)(?P<filename>[-\\w._+]*)?\",\n            r\"(?<![\\\\\\w])(?P<str>b?'''.*?(?<!\\\\)'''|b?'.*?(?<!\\\\)'|b?\\\"\\\"\\\".*?(?<!\\\\)\\\"\\\"\\\"|b?\\\".*?(?<!\\\\)\\\")\",\n            r\"(?P<url>(file|https|http|ws|wss)://[-0-9a-zA-Z$_+!`(),.?/;:&=%#~@]*)\",\n        ),\n    ]\n\n\nclass JSONHighlighter(RegexHighlighter):\n    \"\"\"Highlights JSON\"\"\"\n\n    # Captures the start and end of JSON strings, handling escaped quotes\n    JSON_STR = r\"(?<![\\\\\\w])(?P<str>b?\\\".*?(?<!\\\\)\\\")\"\n    JSON_WHITESPACE = {\" \", \"\\n\", \"\\r\", \"\\t\"}\n\n    base_style = \"json.\"\n    highlights = [\n        _combine_regex(\n            r\"(?P<brace>[\\{\\[\\(\\)\\]\\}])\",\n            r\"\\b(?P<bool_true>true)\\b|\\b(?P<bool_false>false)\\b|\\b(?P<null>null)\\b\",\n            r\"(?P<number>(?<!\\w)\\-?[0-9]+\\.?[0-9]*(e[\\-\\+]?\\d+?)?\\b|0x[0-9a-fA-F]*)\",\n            JSON_STR,\n        ),\n    ]\n\n    def highlight(self, text: Text) -> None:\n        super().highlight(text)\n\n        # Additional work to handle highlighting JSON keys\n        plain = text.plain\n        append = text.spans.append\n        whitespace = self.JSON_WHITESPACE\n        for match in re.finditer(self.JSON_STR, plain):\n            start, end = match.span()\n            cursor = end\n            while cursor < len(plain):\n                char = plain[cursor]\n                cursor += 1\n                if char == \":\":\n                    append(Span(start, end, \"json.key\"))\n                elif char in whitespace:\n                    continue\n                break\n\n\nclass ISO8601Highlighter(RegexHighlighter):\n    \"\"\"Highlights the ISO8601 date time strings.\n    Regex reference: https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch04s07.html\n    \"\"\"\n\n    base_style = \"iso8601.\"\n    highlights = [\n        #\n        # Dates\n        #\n        # Calendar month (e.g. 2008-08). The hyphen is required\n        r\"^(?P<year>[0-9]{4})-(?P<month>1[0-2]|0[1-9])$\",\n        # Calendar date w/o hyphens (e.g. 20080830)\n        r\"^(?P<date>(?P<year>[0-9]{4})(?P<month>1[0-2]|0[1-9])(?P<day>3[01]|0[1-9]|[12][0-9]))$\",\n        # Ordinal date (e.g. 2008-243). The hyphen is optional\n        r\"^(?P<date>(?P<year>[0-9]{4})-?(?P<day>36[0-6]|3[0-5][0-9]|[12][0-9]{2}|0[1-9][0-9]|00[1-9]))$\",\n        #\n        # Weeks\n        #\n        # Week of the year (e.g., 2008-W35). The hyphen is optional\n        r\"^(?P<date>(?P<year>[0-9]{4})-?W(?P<week>5[0-3]|[1-4][0-9]|0[1-9]))$\",\n        # Week date (e.g., 2008-W35-6). The hyphens are optional\n        r\"^(?P<date>(?P<year>[0-9]{4})-?W(?P<week>5[0-3]|[1-4][0-9]|0[1-9])-?(?P<day>[1-7]))$\",\n        #\n        # Times\n        #\n        # Hours and minutes (e.g., 17:21). The colon is optional\n        r\"^(?P<time>(?P<hour>2[0-3]|[01][0-9]):?(?P<minute>[0-5][0-9]))$\",\n        # Hours, minutes, and seconds w/o colons (e.g., 172159)\n        r\"^(?P<time>(?P<hour>2[0-3]|[01][0-9])(?P<minute>[0-5][0-9])(?P<second>[0-5][0-9]))$\",\n        # Time zone designator (e.g., Z, +07 or +07:00). The colons and the minutes are optional\n        r\"^(?P<timezone>(Z|[+-](?:2[0-3]|[01][0-9])(?::?(?:[0-5][0-9]))?))$\",\n        # Hours, minutes, and seconds with time zone designator (e.g., 17:21:59+07:00).\n        # All the colons are optional. The minutes in the time zone designator are also optional\n        r\"^(?P<time>(?P<hour>2[0-3]|[01][0-9])(?P<minute>[0-5][0-9])(?P<second>[0-5][0-9]))(?P<timezone>Z|[+-](?:2[0-3]|[01][0-9])(?::?(?:[0-5][0-9]))?)$\",\n        #\n        # Date and Time\n        #\n        # Calendar date with hours, minutes, and seconds (e.g., 2008-08-30 17:21:59 or 20080830 172159).\n        # A space is required between the date and the time. The hyphens and colons are optional.\n        # This regex matches dates and times that specify some hyphens or colons but omit others.\n        # This does not follow ISO 8601\n        r\"^(?P<date>(?P<year>[0-9]{4})(?P<hyphen>-)?(?P<month>1[0-2]|0[1-9])(?(hyphen)-)(?P<day>3[01]|0[1-9]|[12][0-9])) (?P<time>(?P<hour>2[0-3]|[01][0-9])(?(hyphen):)(?P<minute>[0-5][0-9])(?(hyphen):)(?P<second>[0-5][0-9]))$\",\n        #\n        # XML Schema dates and times\n        #\n        # Date, with optional time zone (e.g., 2008-08-30 or 2008-08-30+07:00).\n        # Hyphens are required. This is the XML Schema 'date' type\n        r\"^(?P<date>(?P<year>-?(?:[1-9][0-9]*)?[0-9]{4})-(?P<month>1[0-2]|0[1-9])-(?P<day>3[01]|0[1-9]|[12][0-9]))(?P<timezone>Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$\",\n        # Time, with optional fractional seconds and time zone (e.g., 01:45:36 or 01:45:36.123+07:00).\n        # There is no limit on the number of digits for the fractional seconds. This is the XML Schema 'time' type\n        r\"^(?P<time>(?P<hour>2[0-3]|[01][0-9]):(?P<minute>[0-5][0-9]):(?P<second>[0-5][0-9])(?P<frac>\\.[0-9]+)?)(?P<timezone>Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$\",\n        # Date and time, with optional fractional seconds and time zone (e.g., 2008-08-30T01:45:36 or 2008-08-30T01:45:36.123Z).\n        # This is the XML Schema 'dateTime' type\n        r\"^(?P<date>(?P<year>-?(?:[1-9][0-9]*)?[0-9]{4})-(?P<month>1[0-2]|0[1-9])-(?P<day>3[01]|0[1-9]|[12][0-9]))T(?P<time>(?P<hour>2[0-3]|[01][0-9]):(?P<minute>[0-5][0-9]):(?P<second>[0-5][0-9])(?P<ms>\\.[0-9]+)?)(?P<timezone>Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$\",\n    ]\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from .console import Console\n\n    console = Console()\n    console.print(\"[bold green]hello world![/bold green]\")\n    console.print(\"'[bold green]hello world![/bold green]'\")\n\n    console.print(\" /foo\")\n    console.print(\"/foo/\")\n    console.print(\"/foo/bar\")\n    console.print(\"foo/bar/baz\")\n\n    console.print(\"/foo/bar/baz?foo=bar+egg&egg=baz\")\n    console.print(\"/foo/bar/baz/\")\n    console.print(\"/foo/bar/baz/egg\")\n    console.print(\"/foo/bar/baz/egg.py\")\n    console.print(\"/foo/bar/baz/egg.py word\")\n    console.print(\" /foo/bar/baz/egg.py word\")\n    console.print(\"foo /foo/bar/baz/egg.py word\")\n    console.print(\"foo /foo/bar/ba._++z/egg+.py word\")\n    console.print(\"https://example.org?foo=bar#header\")\n\n    console.print(1234567.34)\n    console.print(1 / 2)\n    console.print(-1 / 123123123123)\n\n    console.print(\n        \"127.0.1.1 bar 192.168.1.4 2001:0db8:85a3:0000:0000:8a2e:0370:7334 foo\"\n    )\n    import json\n\n    console.print_json(json.dumps(obj={\"name\": \"apple\", \"count\": 1}), indent=None)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/json.py","size":5031,"sha1":"bdfcfcf4649743e765ba3254279f009c29f57ee4","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from pathlib import Path\nfrom json import loads, dumps\nfrom typing import Any, Callable, Optional, Union\n\nfrom .text import Text\nfrom .highlighter import JSONHighlighter, NullHighlighter\n\n\nclass JSON:\n    \"\"\"A renderable which pretty prints JSON.\n\n    Args:\n        json (str): JSON encoded data.\n        indent (Union[None, int, str], optional): Number of characters to indent by. Defaults to 2.\n        highlight (bool, optional): Enable highlighting. Defaults to True.\n        skip_keys (bool, optional): Skip keys not of a basic type. Defaults to False.\n        ensure_ascii (bool, optional): Escape all non-ascii characters. Defaults to False.\n        check_circular (bool, optional): Check for circular references. Defaults to True.\n        allow_nan (bool, optional): Allow NaN and Infinity values. Defaults to True.\n        default (Callable, optional): A callable that converts values that can not be encoded\n            in to something that can be JSON encoded. Defaults to None.\n        sort_keys (bool, optional): Sort dictionary keys. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        json: str,\n        indent: Union[None, int, str] = 2,\n        highlight: bool = True,\n        skip_keys: bool = False,\n        ensure_ascii: bool = False,\n        check_circular: bool = True,\n        allow_nan: bool = True,\n        default: Optional[Callable[[Any], Any]] = None,\n        sort_keys: bool = False,\n    ) -> None:\n        data = loads(json)\n        json = dumps(\n            data,\n            indent=indent,\n            skipkeys=skip_keys,\n            ensure_ascii=ensure_ascii,\n            check_circular=check_circular,\n            allow_nan=allow_nan,\n            default=default,\n            sort_keys=sort_keys,\n        )\n        highlighter = JSONHighlighter() if highlight else NullHighlighter()\n        self.text = highlighter(json)\n        self.text.no_wrap = True\n        self.text.overflow = None\n\n    @classmethod\n    def from_data(\n        cls,\n        data: Any,\n        indent: Union[None, int, str] = 2,\n        highlight: bool = True,\n        skip_keys: bool = False,\n        ensure_ascii: bool = False,\n        check_circular: bool = True,\n        allow_nan: bool = True,\n        default: Optional[Callable[[Any], Any]] = None,\n        sort_keys: bool = False,\n    ) -> \"JSON\":\n        \"\"\"Encodes a JSON object from arbitrary data.\n\n        Args:\n            data (Any): An object that may be encoded in to JSON\n            indent (Union[None, int, str], optional): Number of characters to indent by. Defaults to 2.\n            highlight (bool, optional): Enable highlighting. Defaults to True.\n            default (Callable, optional): Optional callable which will be called for objects that cannot be serialized. Defaults to None.\n            skip_keys (bool, optional): Skip keys not of a basic type. Defaults to False.\n            ensure_ascii (bool, optional): Escape all non-ascii characters. Defaults to False.\n            check_circular (bool, optional): Check for circular references. Defaults to True.\n            allow_nan (bool, optional): Allow NaN and Infinity values. Defaults to True.\n            default (Callable, optional): A callable that converts values that can not be encoded\n                in to something that can be JSON encoded. Defaults to None.\n            sort_keys (bool, optional): Sort dictionary keys. Defaults to False.\n\n        Returns:\n            JSON: New JSON object from the given data.\n        \"\"\"\n        json_instance: \"JSON\" = cls.__new__(cls)\n        json = dumps(\n            data,\n            indent=indent,\n            skipkeys=skip_keys,\n            ensure_ascii=ensure_ascii,\n            check_circular=check_circular,\n            allow_nan=allow_nan,\n            default=default,\n            sort_keys=sort_keys,\n        )\n        highlighter = JSONHighlighter() if highlight else NullHighlighter()\n        json_instance.text = highlighter(json)\n        json_instance.text.no_wrap = True\n        json_instance.text.overflow = None\n        return json_instance\n\n    def __rich__(self) -> Text:\n        return self.text\n\n\nif __name__ == \"__main__\":\n    import argparse\n    import sys\n\n    parser = argparse.ArgumentParser(description=\"Pretty print json\")\n    parser.add_argument(\n        \"path\",\n        metavar=\"PATH\",\n        help=\"path to file, or - for stdin\",\n    )\n    parser.add_argument(\n        \"-i\",\n        \"--indent\",\n        metavar=\"SPACES\",\n        type=int,\n        help=\"Number of spaces in an indent\",\n        default=2,\n    )\n    args = parser.parse_args()\n\n    from pip._vendor.rich.console import Console\n\n    console = Console()\n    error_console = Console(stderr=True)\n\n    try:\n        if args.path == \"-\":\n            json_data = sys.stdin.read()\n        else:\n            json_data = Path(args.path).read_text()\n    except Exception as error:\n        error_console.print(f\"Unable to read {args.path!r}; {error}\")\n        sys.exit(-1)\n\n    console.print(JSON(json_data, indent=args.indent), soft_wrap=True)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/jupyter.py","size":3252,"sha1":"4ccdab1925739170a634b5e3507c6249a3ffc649","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import TYPE_CHECKING, Any, Dict, Iterable, List, Sequence\n\nif TYPE_CHECKING:\n    from pip._vendor.rich.console import ConsoleRenderable\n\nfrom . import get_console\nfrom .segment import Segment\nfrom .terminal_theme import DEFAULT_TERMINAL_THEME\n\nif TYPE_CHECKING:\n    from pip._vendor.rich.console import ConsoleRenderable\n\nJUPYTER_HTML_FORMAT = \"\"\"\\\n<pre style=\"white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace\">{code}</pre>\n\"\"\"\n\n\nclass JupyterRenderable:\n    \"\"\"A shim to write html to Jupyter notebook.\"\"\"\n\n    def __init__(self, html: str, text: str) -> None:\n        self.html = html\n        self.text = text\n\n    def _repr_mimebundle_(\n        self, include: Sequence[str], exclude: Sequence[str], **kwargs: Any\n    ) -> Dict[str, str]:\n        data = {\"text/plain\": self.text, \"text/html\": self.html}\n        if include:\n            data = {k: v for (k, v) in data.items() if k in include}\n        if exclude:\n            data = {k: v for (k, v) in data.items() if k not in exclude}\n        return data\n\n\nclass JupyterMixin:\n    \"\"\"Add to an Rich renderable to make it render in Jupyter notebook.\"\"\"\n\n    __slots__ = ()\n\n    def _repr_mimebundle_(\n        self: \"ConsoleRenderable\",\n        include: Sequence[str],\n        exclude: Sequence[str],\n        **kwargs: Any,\n    ) -> Dict[str, str]:\n        console = get_console()\n        segments = list(console.render(self, console.options))\n        html = _render_segments(segments)\n        text = console._render_buffer(segments)\n        data = {\"text/plain\": text, \"text/html\": html}\n        if include:\n            data = {k: v for (k, v) in data.items() if k in include}\n        if exclude:\n            data = {k: v for (k, v) in data.items() if k not in exclude}\n        return data\n\n\ndef _render_segments(segments: Iterable[Segment]) -> str:\n    def escape(text: str) -> str:\n        \"\"\"Escape html.\"\"\"\n        return text.replace(\"&\", \"&amp;\").replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")\n\n    fragments: List[str] = []\n    append_fragment = fragments.append\n    theme = DEFAULT_TERMINAL_THEME\n    for text, style, control in Segment.simplify(segments):\n        if control:\n            continue\n        text = escape(text)\n        if style:\n            rule = style.get_html_style(theme)\n            text = f'<span style=\"{rule}\">{text}</span>' if rule else text\n            if style.link:\n                text = f'<a href=\"{style.link}\" target=\"_blank\">{text}</a>'\n        append_fragment(text)\n\n    code = \"\".join(fragments)\n    html = JUPYTER_HTML_FORMAT.format(code=code)\n\n    return html\n\n\ndef display(segments: Iterable[Segment], text: str) -> None:\n    \"\"\"Render segments to Jupyter.\"\"\"\n    html = _render_segments(segments)\n    jupyter_renderable = JupyterRenderable(html, text)\n    try:\n        from IPython.display import display as ipython_display\n\n        ipython_display(jupyter_renderable)\n    except ModuleNotFoundError:\n        # Handle the case where the Console has force_jupyter=True,\n        # but IPython is not installed.\n        pass\n\n\ndef print(*args: Any, **kwargs: Any) -> None:\n    \"\"\"Proxy for Console print.\"\"\"\n    console = get_console()\n    return console.print(*args, **kwargs)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/layout.py","size":14004,"sha1":"9b64aec344926091411c2ec17fa526f66df7be94","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from abc import ABC, abstractmethod\nfrom itertools import islice\nfrom operator import itemgetter\nfrom threading import RLock\nfrom typing import (\n    TYPE_CHECKING,\n    Dict,\n    Iterable,\n    List,\n    NamedTuple,\n    Optional,\n    Sequence,\n    Tuple,\n    Union,\n)\n\nfrom ._ratio import ratio_resolve\nfrom .align import Align\nfrom .console import Console, ConsoleOptions, RenderableType, RenderResult\nfrom .highlighter import ReprHighlighter\nfrom .panel import Panel\nfrom .pretty import Pretty\nfrom .region import Region\nfrom .repr import Result, rich_repr\nfrom .segment import Segment\nfrom .style import StyleType\n\nif TYPE_CHECKING:\n    from pip._vendor.rich.tree import Tree\n\n\nclass LayoutRender(NamedTuple):\n    \"\"\"An individual layout render.\"\"\"\n\n    region: Region\n    render: List[List[Segment]]\n\n\nRegionMap = Dict[\"Layout\", Region]\nRenderMap = Dict[\"Layout\", LayoutRender]\n\n\nclass LayoutError(Exception):\n    \"\"\"Layout related error.\"\"\"\n\n\nclass NoSplitter(LayoutError):\n    \"\"\"Requested splitter does not exist.\"\"\"\n\n\nclass _Placeholder:\n    \"\"\"An internal renderable used as a Layout placeholder.\"\"\"\n\n    highlighter = ReprHighlighter()\n\n    def __init__(self, layout: \"Layout\", style: StyleType = \"\") -> None:\n        self.layout = layout\n        self.style = style\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        width = options.max_width\n        height = options.height or options.size.height\n        layout = self.layout\n        title = (\n            f\"{layout.name!r} ({width} x {height})\"\n            if layout.name\n            else f\"({width} x {height})\"\n        )\n        yield Panel(\n            Align.center(Pretty(layout), vertical=\"middle\"),\n            style=self.style,\n            title=self.highlighter(title),\n            border_style=\"blue\",\n            height=height,\n        )\n\n\nclass Splitter(ABC):\n    \"\"\"Base class for a splitter.\"\"\"\n\n    name: str = \"\"\n\n    @abstractmethod\n    def get_tree_icon(self) -> str:\n        \"\"\"Get the icon (emoji) used in layout.tree\"\"\"\n\n    @abstractmethod\n    def divide(\n        self, children: Sequence[\"Layout\"], region: Region\n    ) -> Iterable[Tuple[\"Layout\", Region]]:\n        \"\"\"Divide a region amongst several child layouts.\n\n        Args:\n            children (Sequence(Layout)): A number of child layouts.\n            region (Region): A rectangular region to divide.\n        \"\"\"\n\n\nclass RowSplitter(Splitter):\n    \"\"\"Split a layout region in to rows.\"\"\"\n\n    name = \"row\"\n\n    def get_tree_icon(self) -> str:\n        return \"[layout.tree.row]â¬Œ\"\n\n    def divide(\n        self, children: Sequence[\"Layout\"], region: Region\n    ) -> Iterable[Tuple[\"Layout\", Region]]:\n        x, y, width, height = region\n        render_widths = ratio_resolve(width, children)\n        offset = 0\n        _Region = Region\n        for child, child_width in zip(children, render_widths):\n            yield child, _Region(x + offset, y, child_width, height)\n            offset += child_width\n\n\nclass ColumnSplitter(Splitter):\n    \"\"\"Split a layout region in to columns.\"\"\"\n\n    name = \"column\"\n\n    def get_tree_icon(self) -> str:\n        return \"[layout.tree.column]â¬\"\n\n    def divide(\n        self, children: Sequence[\"Layout\"], region: Region\n    ) -> Iterable[Tuple[\"Layout\", Region]]:\n        x, y, width, height = region\n        render_heights = ratio_resolve(height, children)\n        offset = 0\n        _Region = Region\n        for child, child_height in zip(children, render_heights):\n            yield child, _Region(x, y + offset, width, child_height)\n            offset += child_height\n\n\n@rich_repr\nclass Layout:\n    \"\"\"A renderable to divide a fixed height in to rows or columns.\n\n    Args:\n        renderable (RenderableType, optional): Renderable content, or None for placeholder. Defaults to None.\n        name (str, optional): Optional identifier for Layout. Defaults to None.\n        size (int, optional): Optional fixed size of layout. Defaults to None.\n        minimum_size (int, optional): Minimum size of layout. Defaults to 1.\n        ratio (int, optional): Optional ratio for flexible layout. Defaults to 1.\n        visible (bool, optional): Visibility of layout. Defaults to True.\n    \"\"\"\n\n    splitters = {\"row\": RowSplitter, \"column\": ColumnSplitter}\n\n    def __init__(\n        self,\n        renderable: Optional[RenderableType] = None,\n        *,\n        name: Optional[str] = None,\n        size: Optional[int] = None,\n        minimum_size: int = 1,\n        ratio: int = 1,\n        visible: bool = True,\n    ) -> None:\n        self._renderable = renderable or _Placeholder(self)\n        self.size = size\n        self.minimum_size = minimum_size\n        self.ratio = ratio\n        self.name = name\n        self.visible = visible\n        self.splitter: Splitter = self.splitters[\"column\"]()\n        self._children: List[Layout] = []\n        self._render_map: RenderMap = {}\n        self._lock = RLock()\n\n    def __rich_repr__(self) -> Result:\n        yield \"name\", self.name, None\n        yield \"size\", self.size, None\n        yield \"minimum_size\", self.minimum_size, 1\n        yield \"ratio\", self.ratio, 1\n\n    @property\n    def renderable(self) -> RenderableType:\n        \"\"\"Layout renderable.\"\"\"\n        return self if self._children else self._renderable\n\n    @property\n    def children(self) -> List[\"Layout\"]:\n        \"\"\"Gets (visible) layout children.\"\"\"\n        return [child for child in self._children if child.visible]\n\n    @property\n    def map(self) -> RenderMap:\n        \"\"\"Get a map of the last render.\"\"\"\n        return self._render_map\n\n    def get(self, name: str) -> Optional[\"Layout\"]:\n        \"\"\"Get a named layout, or None if it doesn't exist.\n\n        Args:\n            name (str): Name of layout.\n\n        Returns:\n            Optional[Layout]: Layout instance or None if no layout was found.\n        \"\"\"\n        if self.name == name:\n            return self\n        else:\n            for child in self._children:\n                named_layout = child.get(name)\n                if named_layout is not None:\n                    return named_layout\n        return None\n\n    def __getitem__(self, name: str) -> \"Layout\":\n        layout = self.get(name)\n        if layout is None:\n            raise KeyError(f\"No layout with name {name!r}\")\n        return layout\n\n    @property\n    def tree(self) -> \"Tree\":\n        \"\"\"Get a tree renderable to show layout structure.\"\"\"\n        from pip._vendor.rich.styled import Styled\n        from pip._vendor.rich.table import Table\n        from pip._vendor.rich.tree import Tree\n\n        def summary(layout: \"Layout\") -> Table:\n            icon = layout.splitter.get_tree_icon()\n\n            table = Table.grid(padding=(0, 1, 0, 0))\n\n            text: RenderableType = (\n                Pretty(layout) if layout.visible else Styled(Pretty(layout), \"dim\")\n            )\n            table.add_row(icon, text)\n            _summary = table\n            return _summary\n\n        layout = self\n        tree = Tree(\n            summary(layout),\n            guide_style=f\"layout.tree.{layout.splitter.name}\",\n            highlight=True,\n        )\n\n        def recurse(tree: \"Tree\", layout: \"Layout\") -> None:\n            for child in layout._children:\n                recurse(\n                    tree.add(\n                        summary(child),\n                        guide_style=f\"layout.tree.{child.splitter.name}\",\n                    ),\n                    child,\n                )\n\n        recurse(tree, self)\n        return tree\n\n    def split(\n        self,\n        *layouts: Union[\"Layout\", RenderableType],\n        splitter: Union[Splitter, str] = \"column\",\n    ) -> None:\n        \"\"\"Split the layout in to multiple sub-layouts.\n\n        Args:\n            *layouts (Layout): Positional arguments should be (sub) Layout instances.\n            splitter (Union[Splitter, str]): Splitter instance or name of splitter.\n        \"\"\"\n        _layouts = [\n            layout if isinstance(layout, Layout) else Layout(layout)\n            for layout in layouts\n        ]\n        try:\n            self.splitter = (\n                splitter\n                if isinstance(splitter, Splitter)\n                else self.splitters[splitter]()\n            )\n        except KeyError:\n            raise NoSplitter(f\"No splitter called {splitter!r}\")\n        self._children[:] = _layouts\n\n    def add_split(self, *layouts: Union[\"Layout\", RenderableType]) -> None:\n        \"\"\"Add a new layout(s) to existing split.\n\n        Args:\n            *layouts (Union[Layout, RenderableType]): Positional arguments should be renderables or (sub) Layout instances.\n\n        \"\"\"\n        _layouts = (\n            layout if isinstance(layout, Layout) else Layout(layout)\n            for layout in layouts\n        )\n        self._children.extend(_layouts)\n\n    def split_row(self, *layouts: Union[\"Layout\", RenderableType]) -> None:\n        \"\"\"Split the layout in to a row (layouts side by side).\n\n        Args:\n            *layouts (Layout): Positional arguments should be (sub) Layout instances.\n        \"\"\"\n        self.split(*layouts, splitter=\"row\")\n\n    def split_column(self, *layouts: Union[\"Layout\", RenderableType]) -> None:\n        \"\"\"Split the layout in to a column (layouts stacked on top of each other).\n\n        Args:\n            *layouts (Layout): Positional arguments should be (sub) Layout instances.\n        \"\"\"\n        self.split(*layouts, splitter=\"column\")\n\n    def unsplit(self) -> None:\n        \"\"\"Reset splits to initial state.\"\"\"\n        del self._children[:]\n\n    def update(self, renderable: RenderableType) -> None:\n        \"\"\"Update renderable.\n\n        Args:\n            renderable (RenderableType): New renderable object.\n        \"\"\"\n        with self._lock:\n            self._renderable = renderable\n\n    def refresh_screen(self, console: \"Console\", layout_name: str) -> None:\n        \"\"\"Refresh a sub-layout.\n\n        Args:\n            console (Console): Console instance where Layout is to be rendered.\n            layout_name (str): Name of layout.\n        \"\"\"\n        with self._lock:\n            layout = self[layout_name]\n            region, _lines = self._render_map[layout]\n            (x, y, width, height) = region\n            lines = console.render_lines(\n                layout, console.options.update_dimensions(width, height)\n            )\n            self._render_map[layout] = LayoutRender(region, lines)\n            console.update_screen_lines(lines, x, y)\n\n    def _make_region_map(self, width: int, height: int) -> RegionMap:\n        \"\"\"Create a dict that maps layout on to Region.\"\"\"\n        stack: List[Tuple[Layout, Region]] = [(self, Region(0, 0, width, height))]\n        push = stack.append\n        pop = stack.pop\n        layout_regions: List[Tuple[Layout, Region]] = []\n        append_layout_region = layout_regions.append\n        while stack:\n            append_layout_region(pop())\n            layout, region = layout_regions[-1]\n            children = layout.children\n            if children:\n                for child_and_region in layout.splitter.divide(children, region):\n                    push(child_and_region)\n\n        region_map = {\n            layout: region\n            for layout, region in sorted(layout_regions, key=itemgetter(1))\n        }\n        return region_map\n\n    def render(self, console: Console, options: ConsoleOptions) -> RenderMap:\n        \"\"\"Render the sub_layouts.\n\n        Args:\n            console (Console): Console instance.\n            options (ConsoleOptions): Console options.\n\n        Returns:\n            RenderMap: A dict that maps Layout on to a tuple of Region, lines\n        \"\"\"\n        render_width = options.max_width\n        render_height = options.height or console.height\n        region_map = self._make_region_map(render_width, render_height)\n        layout_regions = [\n            (layout, region)\n            for layout, region in region_map.items()\n            if not layout.children\n        ]\n        render_map: Dict[\"Layout\", \"LayoutRender\"] = {}\n        render_lines = console.render_lines\n        update_dimensions = options.update_dimensions\n\n        for layout, region in layout_regions:\n            lines = render_lines(\n                layout.renderable, update_dimensions(region.width, region.height)\n            )\n            render_map[layout] = LayoutRender(region, lines)\n        return render_map\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        with self._lock:\n            width = options.max_width or console.width\n            height = options.height or console.height\n            render_map = self.render(console, options.update_dimensions(width, height))\n            self._render_map = render_map\n            layout_lines: List[List[Segment]] = [[] for _ in range(height)]\n            _islice = islice\n            for region, lines in render_map.values():\n                _x, y, _layout_width, layout_height = region\n                for row, line in zip(\n                    _islice(layout_lines, y, y + layout_height), lines\n                ):\n                    row.extend(line)\n\n            new_line = Segment.line()\n            for layout_row in layout_lines:\n                yield from layout_row\n                yield new_line\n\n\nif __name__ == \"__main__\":\n    from pip._vendor.rich.console import Console\n\n    console = Console()\n    layout = Layout()\n\n    layout.split_column(\n        Layout(name=\"header\", size=3),\n        Layout(ratio=1, name=\"main\"),\n        Layout(size=10, name=\"footer\"),\n    )\n\n    layout[\"main\"].split_row(Layout(name=\"side\"), Layout(name=\"body\", ratio=2))\n\n    layout[\"body\"].split_row(Layout(name=\"content\", ratio=2), Layout(name=\"s2\"))\n\n    layout[\"s2\"].split_column(\n        Layout(name=\"top\"), Layout(name=\"middle\"), Layout(name=\"bottom\")\n    )\n\n    layout[\"side\"].split_column(Layout(layout.tree, name=\"left1\"), Layout(name=\"left2\"))\n\n    layout[\"content\"].update(\"foo\")\n\n    console.print(layout)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/live.py","size":14270,"sha1":"0b57f5e5a818230f699291a313695fa2d229af28","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\nfrom threading import Event, RLock, Thread\nfrom types import TracebackType\nfrom typing import IO, Any, Callable, List, Optional, TextIO, Type, cast\n\nfrom . import get_console\nfrom .console import Console, ConsoleRenderable, RenderableType, RenderHook\nfrom .control import Control\nfrom .file_proxy import FileProxy\nfrom .jupyter import JupyterMixin\nfrom .live_render import LiveRender, VerticalOverflowMethod\nfrom .screen import Screen\nfrom .text import Text\n\n\nclass _RefreshThread(Thread):\n    \"\"\"A thread that calls refresh() at regular intervals.\"\"\"\n\n    def __init__(self, live: \"Live\", refresh_per_second: float) -> None:\n        self.live = live\n        self.refresh_per_second = refresh_per_second\n        self.done = Event()\n        super().__init__(daemon=True)\n\n    def stop(self) -> None:\n        self.done.set()\n\n    def run(self) -> None:\n        while not self.done.wait(1 / self.refresh_per_second):\n            with self.live._lock:\n                if not self.done.is_set():\n                    self.live.refresh()\n\n\nclass Live(JupyterMixin, RenderHook):\n    \"\"\"Renders an auto-updating live display of any given renderable.\n\n    Args:\n        renderable (RenderableType, optional): The renderable to live display. Defaults to displaying nothing.\n        console (Console, optional): Optional Console instance. Defaults to an internal Console instance writing to stdout.\n        screen (bool, optional): Enable alternate screen mode. Defaults to False.\n        auto_refresh (bool, optional): Enable auto refresh. If disabled, you will need to call `refresh()` or `update()` with refresh flag. Defaults to True\n        refresh_per_second (float, optional): Number of times per second to refresh the live display. Defaults to 4.\n        transient (bool, optional): Clear the renderable on exit (has no effect when screen=True). Defaults to False.\n        redirect_stdout (bool, optional): Enable redirection of stdout, so ``print`` may be used. Defaults to True.\n        redirect_stderr (bool, optional): Enable redirection of stderr. Defaults to True.\n        vertical_overflow (VerticalOverflowMethod, optional): How to handle renderable when it is too tall for the console. Defaults to \"ellipsis\".\n        get_renderable (Callable[[], RenderableType], optional): Optional callable to get renderable. Defaults to None.\n    \"\"\"\n\n    def __init__(\n        self,\n        renderable: Optional[RenderableType] = None,\n        *,\n        console: Optional[Console] = None,\n        screen: bool = False,\n        auto_refresh: bool = True,\n        refresh_per_second: float = 4,\n        transient: bool = False,\n        redirect_stdout: bool = True,\n        redirect_stderr: bool = True,\n        vertical_overflow: VerticalOverflowMethod = \"ellipsis\",\n        get_renderable: Optional[Callable[[], RenderableType]] = None,\n    ) -> None:\n        assert refresh_per_second > 0, \"refresh_per_second must be > 0\"\n        self._renderable = renderable\n        self.console = console if console is not None else get_console()\n        self._screen = screen\n        self._alt_screen = False\n\n        self._redirect_stdout = redirect_stdout\n        self._redirect_stderr = redirect_stderr\n        self._restore_stdout: Optional[IO[str]] = None\n        self._restore_stderr: Optional[IO[str]] = None\n\n        self._lock = RLock()\n        self.ipy_widget: Optional[Any] = None\n        self.auto_refresh = auto_refresh\n        self._started: bool = False\n        self.transient = True if screen else transient\n\n        self._refresh_thread: Optional[_RefreshThread] = None\n        self.refresh_per_second = refresh_per_second\n\n        self.vertical_overflow = vertical_overflow\n        self._get_renderable = get_renderable\n        self._live_render = LiveRender(\n            self.get_renderable(), vertical_overflow=vertical_overflow\n        )\n\n    @property\n    def is_started(self) -> bool:\n        \"\"\"Check if live display has been started.\"\"\"\n        return self._started\n\n    def get_renderable(self) -> RenderableType:\n        renderable = (\n            self._get_renderable()\n            if self._get_renderable is not None\n            else self._renderable\n        )\n        return renderable or \"\"\n\n    def start(self, refresh: bool = False) -> None:\n        \"\"\"Start live rendering display.\n\n        Args:\n            refresh (bool, optional): Also refresh. Defaults to False.\n        \"\"\"\n        with self._lock:\n            if self._started:\n                return\n            self.console.set_live(self)\n            self._started = True\n            if self._screen:\n                self._alt_screen = self.console.set_alt_screen(True)\n            self.console.show_cursor(False)\n            self._enable_redirect_io()\n            self.console.push_render_hook(self)\n            if refresh:\n                try:\n                    self.refresh()\n                except Exception:\n                    # If refresh fails, we want to stop the redirection of sys.stderr,\n                    # so the error stacktrace is properly displayed in the terminal.\n                    # (or, if the code that calls Rich captures the exception and wants to display something,\n                    # let this be displayed in the terminal).\n                    self.stop()\n                    raise\n            if self.auto_refresh:\n                self._refresh_thread = _RefreshThread(self, self.refresh_per_second)\n                self._refresh_thread.start()\n\n    def stop(self) -> None:\n        \"\"\"Stop live rendering display.\"\"\"\n        with self._lock:\n            if not self._started:\n                return\n            self.console.clear_live()\n            self._started = False\n\n            if self.auto_refresh and self._refresh_thread is not None:\n                self._refresh_thread.stop()\n                self._refresh_thread = None\n            # allow it to fully render on the last even if overflow\n            self.vertical_overflow = \"visible\"\n            with self.console:\n                try:\n                    if not self._alt_screen and not self.console.is_jupyter:\n                        self.refresh()\n                finally:\n                    self._disable_redirect_io()\n                    self.console.pop_render_hook()\n                    if not self._alt_screen and self.console.is_terminal:\n                        self.console.line()\n                    self.console.show_cursor(True)\n                    if self._alt_screen:\n                        self.console.set_alt_screen(False)\n\n                    if self.transient and not self._alt_screen:\n                        self.console.control(self._live_render.restore_cursor())\n                    if self.ipy_widget is not None and self.transient:\n                        self.ipy_widget.close()  # pragma: no cover\n\n    def __enter__(self) -> \"Live\":\n        self.start(refresh=self._renderable is not None)\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        self.stop()\n\n    def _enable_redirect_io(self) -> None:\n        \"\"\"Enable redirecting of stdout / stderr.\"\"\"\n        if self.console.is_terminal or self.console.is_jupyter:\n            if self._redirect_stdout and not isinstance(sys.stdout, FileProxy):\n                self._restore_stdout = sys.stdout\n                sys.stdout = cast(\"TextIO\", FileProxy(self.console, sys.stdout))\n            if self._redirect_stderr and not isinstance(sys.stderr, FileProxy):\n                self._restore_stderr = sys.stderr\n                sys.stderr = cast(\"TextIO\", FileProxy(self.console, sys.stderr))\n\n    def _disable_redirect_io(self) -> None:\n        \"\"\"Disable redirecting of stdout / stderr.\"\"\"\n        if self._restore_stdout:\n            sys.stdout = cast(\"TextIO\", self._restore_stdout)\n            self._restore_stdout = None\n        if self._restore_stderr:\n            sys.stderr = cast(\"TextIO\", self._restore_stderr)\n            self._restore_stderr = None\n\n    @property\n    def renderable(self) -> RenderableType:\n        \"\"\"Get the renderable that is being displayed\n\n        Returns:\n            RenderableType: Displayed renderable.\n        \"\"\"\n        renderable = self.get_renderable()\n        return Screen(renderable) if self._alt_screen else renderable\n\n    def update(self, renderable: RenderableType, *, refresh: bool = False) -> None:\n        \"\"\"Update the renderable that is being displayed\n\n        Args:\n            renderable (RenderableType): New renderable to use.\n            refresh (bool, optional): Refresh the display. Defaults to False.\n        \"\"\"\n        if isinstance(renderable, str):\n            renderable = self.console.render_str(renderable)\n        with self._lock:\n            self._renderable = renderable\n            if refresh:\n                self.refresh()\n\n    def refresh(self) -> None:\n        \"\"\"Update the display of the Live Render.\"\"\"\n        with self._lock:\n            self._live_render.set_renderable(self.renderable)\n            if self.console.is_jupyter:  # pragma: no cover\n                try:\n                    from IPython.display import display\n                    from ipywidgets import Output\n                except ImportError:\n                    import warnings\n\n                    warnings.warn('install \"ipywidgets\" for Jupyter support')\n                else:\n                    if self.ipy_widget is None:\n                        self.ipy_widget = Output()\n                        display(self.ipy_widget)\n\n                    with self.ipy_widget:\n                        self.ipy_widget.clear_output(wait=True)\n                        self.console.print(self._live_render.renderable)\n            elif self.console.is_terminal and not self.console.is_dumb_terminal:\n                with self.console:\n                    self.console.print(Control())\n            elif (\n                not self._started and not self.transient\n            ):  # if it is finished allow files or dumb-terminals to see final result\n                with self.console:\n                    self.console.print(Control())\n\n    def process_renderables(\n        self, renderables: List[ConsoleRenderable]\n    ) -> List[ConsoleRenderable]:\n        \"\"\"Process renderables to restore cursor and display progress.\"\"\"\n        self._live_render.vertical_overflow = self.vertical_overflow\n        if self.console.is_interactive:\n            # lock needs acquiring as user can modify live_render renderable at any time unlike in Progress.\n            with self._lock:\n                reset = (\n                    Control.home()\n                    if self._alt_screen\n                    else self._live_render.position_cursor()\n                )\n                renderables = [reset, *renderables, self._live_render]\n        elif (\n            not self._started and not self.transient\n        ):  # if it is finished render the final output for files or dumb_terminals\n            renderables = [*renderables, self._live_render]\n\n        return renderables\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    import random\n    import time\n    from itertools import cycle\n    from typing import Dict, List, Tuple\n\n    from .align import Align\n    from .console import Console\n    from .live import Live as Live\n    from .panel import Panel\n    from .rule import Rule\n    from .syntax import Syntax\n    from .table import Table\n\n    console = Console()\n\n    syntax = Syntax(\n        '''def loop_last(values: Iterable[T]) -> Iterable[Tuple[bool, T]]:\n    \"\"\"Iterate and generate a tuple with a flag for last value.\"\"\"\n    iter_values = iter(values)\n    try:\n        previous_value = next(iter_values)\n    except StopIteration:\n        return\n    for value in iter_values:\n        yield False, previous_value\n        previous_value = value\n    yield True, previous_value''',\n        \"python\",\n        line_numbers=True,\n    )\n\n    table = Table(\"foo\", \"bar\", \"baz\")\n    table.add_row(\"1\", \"2\", \"3\")\n\n    progress_renderables = [\n        \"You can make the terminal shorter and taller to see the live table hide\"\n        \"Text may be printed while the progress bars are rendering.\",\n        Panel(\"In fact, [i]any[/i] renderable will work\"),\n        \"Such as [magenta]tables[/]...\",\n        table,\n        \"Pretty printed structures...\",\n        {\"type\": \"example\", \"text\": \"Pretty printed\"},\n        \"Syntax...\",\n        syntax,\n        Rule(\"Give it a try!\"),\n    ]\n\n    examples = cycle(progress_renderables)\n\n    exchanges = [\n        \"SGD\",\n        \"MYR\",\n        \"EUR\",\n        \"USD\",\n        \"AUD\",\n        \"JPY\",\n        \"CNH\",\n        \"HKD\",\n        \"CAD\",\n        \"INR\",\n        \"DKK\",\n        \"GBP\",\n        \"RUB\",\n        \"NZD\",\n        \"MXN\",\n        \"IDR\",\n        \"TWD\",\n        \"THB\",\n        \"VND\",\n    ]\n    with Live(console=console) as live_table:\n        exchange_rate_dict: Dict[Tuple[str, str], float] = {}\n\n        for index in range(100):\n            select_exchange = exchanges[index % len(exchanges)]\n\n            for exchange in exchanges:\n                if exchange == select_exchange:\n                    continue\n                time.sleep(0.4)\n                if random.randint(0, 10) < 1:\n                    console.log(next(examples))\n                exchange_rate_dict[(select_exchange, exchange)] = 200 / (\n                    (random.random() * 320) + 1\n                )\n                if len(exchange_rate_dict) > len(exchanges) - 1:\n                    exchange_rate_dict.pop(list(exchange_rate_dict.keys())[0])\n                table = Table(title=\"Exchange Rates\")\n\n                table.add_column(\"Source Currency\")\n                table.add_column(\"Destination Currency\")\n                table.add_column(\"Exchange Rate\")\n\n                for (source, dest), exchange_rate in exchange_rate_dict.items():\n                    table.add_row(\n                        source,\n                        dest,\n                        Text(\n                            f\"{exchange_rate:.4f}\",\n                            style=\"red\" if exchange_rate < 1.0 else \"green\",\n                        ),\n                    )\n\n                live_table.update(Align.center(table))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/live_render.py","size":3666,"sha1":"89bf548e4fa15ccdc00b24699b99c8c8509c8593","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\nfrom typing import Optional, Tuple\n\nif sys.version_info >= (3, 8):\n    from typing import Literal\nelse:\n    from pip._vendor.typing_extensions import Literal  # pragma: no cover\n\n\nfrom ._loop import loop_last\nfrom .console import Console, ConsoleOptions, RenderableType, RenderResult\nfrom .control import Control\nfrom .segment import ControlType, Segment\nfrom .style import StyleType\nfrom .text import Text\n\nVerticalOverflowMethod = Literal[\"crop\", \"ellipsis\", \"visible\"]\n\n\nclass LiveRender:\n    \"\"\"Creates a renderable that may be updated.\n\n    Args:\n        renderable (RenderableType): Any renderable object.\n        style (StyleType, optional): An optional style to apply to the renderable. Defaults to \"\".\n    \"\"\"\n\n    def __init__(\n        self,\n        renderable: RenderableType,\n        style: StyleType = \"\",\n        vertical_overflow: VerticalOverflowMethod = \"ellipsis\",\n    ) -> None:\n        self.renderable = renderable\n        self.style = style\n        self.vertical_overflow = vertical_overflow\n        self._shape: Optional[Tuple[int, int]] = None\n\n    def set_renderable(self, renderable: RenderableType) -> None:\n        \"\"\"Set a new renderable.\n\n        Args:\n            renderable (RenderableType): Any renderable object, including str.\n        \"\"\"\n        self.renderable = renderable\n\n    def position_cursor(self) -> Control:\n        \"\"\"Get control codes to move cursor to beginning of live render.\n\n        Returns:\n            Control: A control instance that may be printed.\n        \"\"\"\n        if self._shape is not None:\n            _, height = self._shape\n            return Control(\n                ControlType.CARRIAGE_RETURN,\n                (ControlType.ERASE_IN_LINE, 2),\n                *(\n                    (\n                        (ControlType.CURSOR_UP, 1),\n                        (ControlType.ERASE_IN_LINE, 2),\n                    )\n                    * (height - 1)\n                )\n            )\n        return Control()\n\n    def restore_cursor(self) -> Control:\n        \"\"\"Get control codes to clear the render and restore the cursor to its previous position.\n\n        Returns:\n            Control: A Control instance that may be printed.\n        \"\"\"\n        if self._shape is not None:\n            _, height = self._shape\n            return Control(\n                ControlType.CARRIAGE_RETURN,\n                *((ControlType.CURSOR_UP, 1), (ControlType.ERASE_IN_LINE, 2)) * height\n            )\n        return Control()\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        renderable = self.renderable\n        style = console.get_style(self.style)\n        lines = console.render_lines(renderable, options, style=style, pad=False)\n        shape = Segment.get_shape(lines)\n\n        _, height = shape\n        if height > options.size.height:\n            if self.vertical_overflow == \"crop\":\n                lines = lines[: options.size.height]\n                shape = Segment.get_shape(lines)\n            elif self.vertical_overflow == \"ellipsis\":\n                lines = lines[: (options.size.height - 1)]\n                overflow_text = Text(\n                    \"...\",\n                    overflow=\"crop\",\n                    justify=\"center\",\n                    end=\"\",\n                    style=\"live.ellipsis\",\n                )\n                lines.append(list(console.render(overflow_text)))\n                shape = Segment.get_shape(lines)\n        self._shape = shape\n\n        new_line = Segment.line()\n        for last, line in loop_last(lines):\n            yield from line\n            if not last:\n                yield new_line\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/logging.py","size":12458,"sha1":"a5e0c8e8c7da4f590ab7142d10eacf46a4cbe059","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import logging\nfrom datetime import datetime\nfrom logging import Handler, LogRecord\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import ClassVar, Iterable, List, Optional, Type, Union\n\nfrom pip._vendor.rich._null_file import NullFile\n\nfrom . import get_console\nfrom ._log_render import FormatTimeCallable, LogRender\nfrom .console import Console, ConsoleRenderable\nfrom .highlighter import Highlighter, ReprHighlighter\nfrom .text import Text\nfrom .traceback import Traceback\n\n\nclass RichHandler(Handler):\n    \"\"\"A logging handler that renders output with Rich. The time / level / message and file are displayed in columns.\n    The level is color coded, and the message is syntax highlighted.\n\n    Note:\n        Be careful when enabling console markup in log messages if you have configured logging for libraries not\n        under your control. If a dependency writes messages containing square brackets, it may not produce the intended output.\n\n    Args:\n        level (Union[int, str], optional): Log level. Defaults to logging.NOTSET.\n        console (:class:`~rich.console.Console`, optional): Optional console instance to write logs.\n            Default will use a global console instance writing to stdout.\n        show_time (bool, optional): Show a column for the time. Defaults to True.\n        omit_repeated_times (bool, optional): Omit repetition of the same time. Defaults to True.\n        show_level (bool, optional): Show a column for the level. Defaults to True.\n        show_path (bool, optional): Show the path to the original log call. Defaults to True.\n        enable_link_path (bool, optional): Enable terminal link of path column to file. Defaults to True.\n        highlighter (Highlighter, optional): Highlighter to style log messages, or None to use ReprHighlighter. Defaults to None.\n        markup (bool, optional): Enable console markup in log messages. Defaults to False.\n        rich_tracebacks (bool, optional): Enable rich tracebacks with syntax highlighting and formatting. Defaults to False.\n        tracebacks_width (Optional[int], optional): Number of characters used to render tracebacks, or None for full width. Defaults to None.\n        tracebacks_code_width (int, optional): Number of code characters used to render tracebacks, or None for full width. Defaults to 88.\n        tracebacks_extra_lines (int, optional): Additional lines of code to render tracebacks, or None for full width. Defaults to None.\n        tracebacks_theme (str, optional): Override pygments theme used in traceback.\n        tracebacks_word_wrap (bool, optional): Enable word wrapping of long tracebacks lines. Defaults to True.\n        tracebacks_show_locals (bool, optional): Enable display of locals in tracebacks. Defaults to False.\n        tracebacks_suppress (Sequence[Union[str, ModuleType]]): Optional sequence of modules or paths to exclude from traceback.\n        tracebacks_max_frames (int, optional): Optional maximum number of frames returned by traceback.\n        locals_max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n            Defaults to 10.\n        locals_max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to 80.\n        log_time_format (Union[str, TimeFormatterCallable], optional): If ``log_time`` is enabled, either string for strftime or callable that formats the time. Defaults to \"[%x %X] \".\n        keywords (List[str], optional): List of words to highlight instead of ``RichHandler.KEYWORDS``.\n    \"\"\"\n\n    KEYWORDS: ClassVar[Optional[List[str]]] = [\n        \"GET\",\n        \"POST\",\n        \"HEAD\",\n        \"PUT\",\n        \"DELETE\",\n        \"OPTIONS\",\n        \"TRACE\",\n        \"PATCH\",\n    ]\n    HIGHLIGHTER_CLASS: ClassVar[Type[Highlighter]] = ReprHighlighter\n\n    def __init__(\n        self,\n        level: Union[int, str] = logging.NOTSET,\n        console: Optional[Console] = None,\n        *,\n        show_time: bool = True,\n        omit_repeated_times: bool = True,\n        show_level: bool = True,\n        show_path: bool = True,\n        enable_link_path: bool = True,\n        highlighter: Optional[Highlighter] = None,\n        markup: bool = False,\n        rich_tracebacks: bool = False,\n        tracebacks_width: Optional[int] = None,\n        tracebacks_code_width: int = 88,\n        tracebacks_extra_lines: int = 3,\n        tracebacks_theme: Optional[str] = None,\n        tracebacks_word_wrap: bool = True,\n        tracebacks_show_locals: bool = False,\n        tracebacks_suppress: Iterable[Union[str, ModuleType]] = (),\n        tracebacks_max_frames: int = 100,\n        locals_max_length: int = 10,\n        locals_max_string: int = 80,\n        log_time_format: Union[str, FormatTimeCallable] = \"[%x %X]\",\n        keywords: Optional[List[str]] = None,\n    ) -> None:\n        super().__init__(level=level)\n        self.console = console or get_console()\n        self.highlighter = highlighter or self.HIGHLIGHTER_CLASS()\n        self._log_render = LogRender(\n            show_time=show_time,\n            show_level=show_level,\n            show_path=show_path,\n            time_format=log_time_format,\n            omit_repeated_times=omit_repeated_times,\n            level_width=None,\n        )\n        self.enable_link_path = enable_link_path\n        self.markup = markup\n        self.rich_tracebacks = rich_tracebacks\n        self.tracebacks_width = tracebacks_width\n        self.tracebacks_extra_lines = tracebacks_extra_lines\n        self.tracebacks_theme = tracebacks_theme\n        self.tracebacks_word_wrap = tracebacks_word_wrap\n        self.tracebacks_show_locals = tracebacks_show_locals\n        self.tracebacks_suppress = tracebacks_suppress\n        self.tracebacks_max_frames = tracebacks_max_frames\n        self.tracebacks_code_width = tracebacks_code_width\n        self.locals_max_length = locals_max_length\n        self.locals_max_string = locals_max_string\n        self.keywords = keywords\n\n    def get_level_text(self, record: LogRecord) -> Text:\n        \"\"\"Get the level name from the record.\n\n        Args:\n            record (LogRecord): LogRecord instance.\n\n        Returns:\n            Text: A tuple of the style and level name.\n        \"\"\"\n        level_name = record.levelname\n        level_text = Text.styled(\n            level_name.ljust(8), f\"logging.level.{level_name.lower()}\"\n        )\n        return level_text\n\n    def emit(self, record: LogRecord) -> None:\n        \"\"\"Invoked by logging.\"\"\"\n        message = self.format(record)\n        traceback = None\n        if (\n            self.rich_tracebacks\n            and record.exc_info\n            and record.exc_info != (None, None, None)\n        ):\n            exc_type, exc_value, exc_traceback = record.exc_info\n            assert exc_type is not None\n            assert exc_value is not None\n            traceback = Traceback.from_exception(\n                exc_type,\n                exc_value,\n                exc_traceback,\n                width=self.tracebacks_width,\n                code_width=self.tracebacks_code_width,\n                extra_lines=self.tracebacks_extra_lines,\n                theme=self.tracebacks_theme,\n                word_wrap=self.tracebacks_word_wrap,\n                show_locals=self.tracebacks_show_locals,\n                locals_max_length=self.locals_max_length,\n                locals_max_string=self.locals_max_string,\n                suppress=self.tracebacks_suppress,\n                max_frames=self.tracebacks_max_frames,\n            )\n            message = record.getMessage()\n            if self.formatter:\n                record.message = record.getMessage()\n                formatter = self.formatter\n                if hasattr(formatter, \"usesTime\") and formatter.usesTime():\n                    record.asctime = formatter.formatTime(record, formatter.datefmt)\n                message = formatter.formatMessage(record)\n\n        message_renderable = self.render_message(record, message)\n        log_renderable = self.render(\n            record=record, traceback=traceback, message_renderable=message_renderable\n        )\n        if isinstance(self.console.file, NullFile):\n            # Handles pythonw, where stdout/stderr are null, and we return NullFile\n            # instance from Console.file. In this case, we still want to make a log record\n            # even though we won't be writing anything to a file.\n            self.handleError(record)\n        else:\n            try:\n                self.console.print(log_renderable)\n            except Exception:\n                self.handleError(record)\n\n    def render_message(self, record: LogRecord, message: str) -> \"ConsoleRenderable\":\n        \"\"\"Render message text in to Text.\n\n        Args:\n            record (LogRecord): logging Record.\n            message (str): String containing log message.\n\n        Returns:\n            ConsoleRenderable: Renderable to display log message.\n        \"\"\"\n        use_markup = getattr(record, \"markup\", self.markup)\n        message_text = Text.from_markup(message) if use_markup else Text(message)\n\n        highlighter = getattr(record, \"highlighter\", self.highlighter)\n        if highlighter:\n            message_text = highlighter(message_text)\n\n        if self.keywords is None:\n            self.keywords = self.KEYWORDS\n\n        if self.keywords:\n            message_text.highlight_words(self.keywords, \"logging.keyword\")\n\n        return message_text\n\n    def render(\n        self,\n        *,\n        record: LogRecord,\n        traceback: Optional[Traceback],\n        message_renderable: \"ConsoleRenderable\",\n    ) -> \"ConsoleRenderable\":\n        \"\"\"Render log for display.\n\n        Args:\n            record (LogRecord): logging Record.\n            traceback (Optional[Traceback]): Traceback instance or None for no Traceback.\n            message_renderable (ConsoleRenderable): Renderable (typically Text) containing log message contents.\n\n        Returns:\n            ConsoleRenderable: Renderable to display log.\n        \"\"\"\n        path = Path(record.pathname).name\n        level = self.get_level_text(record)\n        time_format = None if self.formatter is None else self.formatter.datefmt\n        log_time = datetime.fromtimestamp(record.created)\n\n        log_renderable = self._log_render(\n            self.console,\n            [message_renderable] if not traceback else [message_renderable, traceback],\n            log_time=log_time,\n            time_format=time_format,\n            level=level,\n            path=path,\n            line_no=record.lineno,\n            link_path=record.pathname if self.enable_link_path else None,\n        )\n        return log_renderable\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from time import sleep\n\n    FORMAT = \"%(message)s\"\n    # FORMAT = \"%(asctime)-15s - %(levelname)s - %(message)s\"\n    logging.basicConfig(\n        level=\"NOTSET\",\n        format=FORMAT,\n        datefmt=\"[%X]\",\n        handlers=[RichHandler(rich_tracebacks=True, tracebacks_show_locals=True)],\n    )\n    log = logging.getLogger(\"rich\")\n\n    log.info(\"Server starting...\")\n    log.info(\"Listening on http://127.0.0.1:8080\")\n    sleep(1)\n\n    log.info(\"GET /index.html 200 1298\")\n    log.info(\"GET /imgs/backgrounds/back1.jpg 200 54386\")\n    log.info(\"GET /css/styles.css 200 54386\")\n    log.warning(\"GET /favicon.ico 404 242\")\n    sleep(1)\n\n    log.debug(\n        \"JSONRPC request\\n--> %r\\n<-- %r\",\n        {\n            \"version\": \"1.1\",\n            \"method\": \"confirmFruitPurchase\",\n            \"params\": [[\"apple\", \"orange\", \"mangoes\", \"pomelo\"], 1.123],\n            \"id\": \"194521489\",\n        },\n        {\"version\": \"1.1\", \"result\": True, \"error\": None, \"id\": \"194521489\"},\n    )\n    log.debug(\n        \"Loading configuration file /adasd/asdasd/qeqwe/qwrqwrqwr/sdgsdgsdg/werwerwer/dfgerert/ertertert/ertetert/werwerwer\"\n    )\n    log.error(\"Unable to find 'pomelo' in database!\")\n    log.info(\"POST /jsonrpc/ 200 65532\")\n    log.info(\"POST /admin/ 401 42234\")\n    log.warning(\"password was rejected for admin site.\")\n\n    def divide() -> None:\n        number = 1\n        divisor = 0\n        foos = [\"foo\"] * 100\n        log.debug(\"in divide\")\n        try:\n            number / divisor\n        except:\n            log.exception(\"An error of some kind occurred!\")\n\n    divide()\n    sleep(1)\n    log.critical(\"Out of memory!\")\n    log.info(\"Server exited with code=-1\")\n    log.info(\"[bold]EXITING...[/bold]\", extra=dict(markup=True))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/markup.py","size":8451,"sha1":"203e0225a128f5df37647adc517fef2489ae087e","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import re\nfrom ast import literal_eval\nfrom operator import attrgetter\nfrom typing import Callable, Iterable, List, Match, NamedTuple, Optional, Tuple, Union\n\nfrom ._emoji_replace import _emoji_replace\nfrom .emoji import EmojiVariant\nfrom .errors import MarkupError\nfrom .style import Style\nfrom .text import Span, Text\n\nRE_TAGS = re.compile(\n    r\"\"\"((\\\\*)\\[([a-z#/@][^[]*?)])\"\"\",\n    re.VERBOSE,\n)\n\nRE_HANDLER = re.compile(r\"^([\\w.]*?)(\\(.*?\\))?$\")\n\n\nclass Tag(NamedTuple):\n    \"\"\"A tag in console markup.\"\"\"\n\n    name: str\n    \"\"\"The tag name. e.g. 'bold'.\"\"\"\n    parameters: Optional[str]\n    \"\"\"Any additional parameters after the name.\"\"\"\n\n    def __str__(self) -> str:\n        return (\n            self.name if self.parameters is None else f\"{self.name} {self.parameters}\"\n        )\n\n    @property\n    def markup(self) -> str:\n        \"\"\"Get the string representation of this tag.\"\"\"\n        return (\n            f\"[{self.name}]\"\n            if self.parameters is None\n            else f\"[{self.name}={self.parameters}]\"\n        )\n\n\n_ReStringMatch = Match[str]  # regex match object\n_ReSubCallable = Callable[[_ReStringMatch], str]  # Callable invoked by re.sub\n_EscapeSubMethod = Callable[[_ReSubCallable, str], str]  # Sub method of a compiled re\n\n\ndef escape(\n    markup: str,\n    _escape: _EscapeSubMethod = re.compile(r\"(\\\\*)(\\[[a-z#/@][^[]*?])\").sub,\n) -> str:\n    \"\"\"Escapes text so that it won't be interpreted as markup.\n\n    Args:\n        markup (str): Content to be inserted in to markup.\n\n    Returns:\n        str: Markup with square brackets escaped.\n    \"\"\"\n\n    def escape_backslashes(match: Match[str]) -> str:\n        \"\"\"Called by re.sub replace matches.\"\"\"\n        backslashes, text = match.groups()\n        return f\"{backslashes}{backslashes}\\\\{text}\"\n\n    markup = _escape(escape_backslashes, markup)\n    if markup.endswith(\"\\\\\") and not markup.endswith(\"\\\\\\\\\"):\n        return markup + \"\\\\\"\n\n    return markup\n\n\ndef _parse(markup: str) -> Iterable[Tuple[int, Optional[str], Optional[Tag]]]:\n    \"\"\"Parse markup in to an iterable of tuples of (position, text, tag).\n\n    Args:\n        markup (str): A string containing console markup\n\n    \"\"\"\n    position = 0\n    _divmod = divmod\n    _Tag = Tag\n    for match in RE_TAGS.finditer(markup):\n        full_text, escapes, tag_text = match.groups()\n        start, end = match.span()\n        if start > position:\n            yield start, markup[position:start], None\n        if escapes:\n            backslashes, escaped = _divmod(len(escapes), 2)\n            if backslashes:\n                # Literal backslashes\n                yield start, \"\\\\\" * backslashes, None\n                start += backslashes * 2\n            if escaped:\n                # Escape of tag\n                yield start, full_text[len(escapes) :], None\n                position = end\n                continue\n        text, equals, parameters = tag_text.partition(\"=\")\n        yield start, None, _Tag(text, parameters if equals else None)\n        position = end\n    if position < len(markup):\n        yield position, markup[position:], None\n\n\ndef render(\n    markup: str,\n    style: Union[str, Style] = \"\",\n    emoji: bool = True,\n    emoji_variant: Optional[EmojiVariant] = None,\n) -> Text:\n    \"\"\"Render console markup in to a Text instance.\n\n    Args:\n        markup (str): A string containing console markup.\n        style: (Union[str, Style]): The style to use.\n        emoji (bool, optional): Also render emoji code. Defaults to True.\n        emoji_variant (str, optional): Optional emoji variant, either \"text\" or \"emoji\". Defaults to None.\n\n\n    Raises:\n        MarkupError: If there is a syntax error in the markup.\n\n    Returns:\n        Text: A test instance.\n    \"\"\"\n    emoji_replace = _emoji_replace\n    if \"[\" not in markup:\n        return Text(\n            emoji_replace(markup, default_variant=emoji_variant) if emoji else markup,\n            style=style,\n        )\n    text = Text(style=style)\n    append = text.append\n    normalize = Style.normalize\n\n    style_stack: List[Tuple[int, Tag]] = []\n    pop = style_stack.pop\n\n    spans: List[Span] = []\n    append_span = spans.append\n\n    _Span = Span\n    _Tag = Tag\n\n    def pop_style(style_name: str) -> Tuple[int, Tag]:\n        \"\"\"Pop tag matching given style name.\"\"\"\n        for index, (_, tag) in enumerate(reversed(style_stack), 1):\n            if tag.name == style_name:\n                return pop(-index)\n        raise KeyError(style_name)\n\n    for position, plain_text, tag in _parse(markup):\n        if plain_text is not None:\n            # Handle open brace escapes, where the brace is not part of a tag.\n            plain_text = plain_text.replace(\"\\\\[\", \"[\")\n            append(emoji_replace(plain_text) if emoji else plain_text)\n        elif tag is not None:\n            if tag.name.startswith(\"/\"):  # Closing tag\n                style_name = tag.name[1:].strip()\n\n                if style_name:  # explicit close\n                    style_name = normalize(style_name)\n                    try:\n                        start, open_tag = pop_style(style_name)\n                    except KeyError:\n                        raise MarkupError(\n                            f\"closing tag '{tag.markup}' at position {position} doesn't match any open tag\"\n                        ) from None\n                else:  # implicit close\n                    try:\n                        start, open_tag = pop()\n                    except IndexError:\n                        raise MarkupError(\n                            f\"closing tag '[/]' at position {position} has nothing to close\"\n                        ) from None\n\n                if open_tag.name.startswith(\"@\"):\n                    if open_tag.parameters:\n                        handler_name = \"\"\n                        parameters = open_tag.parameters.strip()\n                        handler_match = RE_HANDLER.match(parameters)\n                        if handler_match is not None:\n                            handler_name, match_parameters = handler_match.groups()\n                            parameters = (\n                                \"()\" if match_parameters is None else match_parameters\n                            )\n\n                        try:\n                            meta_params = literal_eval(parameters)\n                        except SyntaxError as error:\n                            raise MarkupError(\n                                f\"error parsing {parameters!r} in {open_tag.parameters!r}; {error.msg}\"\n                            )\n                        except Exception as error:\n                            raise MarkupError(\n                                f\"error parsing {open_tag.parameters!r}; {error}\"\n                            ) from None\n\n                        if handler_name:\n                            meta_params = (\n                                handler_name,\n                                meta_params\n                                if isinstance(meta_params, tuple)\n                                else (meta_params,),\n                            )\n\n                    else:\n                        meta_params = ()\n\n                    append_span(\n                        _Span(\n                            start, len(text), Style(meta={open_tag.name: meta_params})\n                        )\n                    )\n                else:\n                    append_span(_Span(start, len(text), str(open_tag)))\n\n            else:  # Opening tag\n                normalized_tag = _Tag(normalize(tag.name), tag.parameters)\n                style_stack.append((len(text), normalized_tag))\n\n    text_length = len(text)\n    while style_stack:\n        start, tag = style_stack.pop()\n        style = str(tag)\n        if style:\n            append_span(_Span(start, text_length, style))\n\n    text.spans = sorted(spans[::-1], key=attrgetter(\"start\"))\n    return text\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    MARKUP = [\n        \"[red]Hello World[/red]\",\n        \"[magenta]Hello [b]World[/b]\",\n        \"[bold]Bold[italic] bold and italic [/bold]italic[/italic]\",\n        \"Click [link=https://www.willmcgugan.com]here[/link] to visit my Blog\",\n        \":warning-emoji: [bold red blink] DANGER![/]\",\n    ]\n\n    from pip._vendor.rich import print\n    from pip._vendor.rich.table import Table\n\n    grid = Table(\"Markup\", \"Result\", padding=(0, 1))\n\n    for markup in MARKUP:\n        grid.add_row(Text(markup), markup)\n\n    print(grid)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/measure.py","size":5305,"sha1":"cecfbef0e10cb7f974bd8f494e639ebd1c6990a6","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from operator import itemgetter\nfrom typing import TYPE_CHECKING, Callable, NamedTuple, Optional, Sequence\n\nfrom . import errors\nfrom .protocol import is_renderable, rich_cast\n\nif TYPE_CHECKING:\n    from .console import Console, ConsoleOptions, RenderableType\n\n\nclass Measurement(NamedTuple):\n    \"\"\"Stores the minimum and maximum widths (in characters) required to render an object.\"\"\"\n\n    minimum: int\n    \"\"\"Minimum number of cells required to render.\"\"\"\n    maximum: int\n    \"\"\"Maximum number of cells required to render.\"\"\"\n\n    @property\n    def span(self) -> int:\n        \"\"\"Get difference between maximum and minimum.\"\"\"\n        return self.maximum - self.minimum\n\n    def normalize(self) -> \"Measurement\":\n        \"\"\"Get measurement that ensures that minimum <= maximum and minimum >= 0\n\n        Returns:\n            Measurement: A normalized measurement.\n        \"\"\"\n        minimum, maximum = self\n        minimum = min(max(0, minimum), maximum)\n        return Measurement(max(0, minimum), max(0, max(minimum, maximum)))\n\n    def with_maximum(self, width: int) -> \"Measurement\":\n        \"\"\"Get a RenderableWith where the widths are <= width.\n\n        Args:\n            width (int): Maximum desired width.\n\n        Returns:\n            Measurement: New Measurement object.\n        \"\"\"\n        minimum, maximum = self\n        return Measurement(min(minimum, width), min(maximum, width))\n\n    def with_minimum(self, width: int) -> \"Measurement\":\n        \"\"\"Get a RenderableWith where the widths are >= width.\n\n        Args:\n            width (int): Minimum desired width.\n\n        Returns:\n            Measurement: New Measurement object.\n        \"\"\"\n        minimum, maximum = self\n        width = max(0, width)\n        return Measurement(max(minimum, width), max(maximum, width))\n\n    def clamp(\n        self, min_width: Optional[int] = None, max_width: Optional[int] = None\n    ) -> \"Measurement\":\n        \"\"\"Clamp a measurement within the specified range.\n\n        Args:\n            min_width (int): Minimum desired width, or ``None`` for no minimum. Defaults to None.\n            max_width (int): Maximum desired width, or ``None`` for no maximum. Defaults to None.\n\n        Returns:\n            Measurement: New Measurement object.\n        \"\"\"\n        measurement = self\n        if min_width is not None:\n            measurement = measurement.with_minimum(min_width)\n        if max_width is not None:\n            measurement = measurement.with_maximum(max_width)\n        return measurement\n\n    @classmethod\n    def get(\n        cls, console: \"Console\", options: \"ConsoleOptions\", renderable: \"RenderableType\"\n    ) -> \"Measurement\":\n        \"\"\"Get a measurement for a renderable.\n\n        Args:\n            console (~rich.console.Console): Console instance.\n            options (~rich.console.ConsoleOptions): Console options.\n            renderable (RenderableType): An object that may be rendered with Rich.\n\n        Raises:\n            errors.NotRenderableError: If the object is not renderable.\n\n        Returns:\n            Measurement: Measurement object containing range of character widths required to render the object.\n        \"\"\"\n        _max_width = options.max_width\n        if _max_width < 1:\n            return Measurement(0, 0)\n        if isinstance(renderable, str):\n            renderable = console.render_str(\n                renderable, markup=options.markup, highlight=False\n            )\n        renderable = rich_cast(renderable)\n        if is_renderable(renderable):\n            get_console_width: Optional[\n                Callable[[\"Console\", \"ConsoleOptions\"], \"Measurement\"]\n            ] = getattr(renderable, \"__rich_measure__\", None)\n            if get_console_width is not None:\n                render_width = (\n                    get_console_width(console, options)\n                    .normalize()\n                    .with_maximum(_max_width)\n                )\n                if render_width.maximum < 1:\n                    return Measurement(0, 0)\n                return render_width.normalize()\n            else:\n                return Measurement(0, _max_width)\n        else:\n            raise errors.NotRenderableError(\n                f\"Unable to get render width for {renderable!r}; \"\n                \"a str, Segment, or object with __rich_console__ method is required\"\n            )\n\n\ndef measure_renderables(\n    console: \"Console\",\n    options: \"ConsoleOptions\",\n    renderables: Sequence[\"RenderableType\"],\n) -> \"Measurement\":\n    \"\"\"Get a measurement that would fit a number of renderables.\n\n    Args:\n        console (~rich.console.Console): Console instance.\n        options (~rich.console.ConsoleOptions): Console options.\n        renderables (Iterable[RenderableType]): One or more renderable objects.\n\n    Returns:\n        Measurement: Measurement object containing range of character widths required to\n            contain all given renderables.\n    \"\"\"\n    if not renderables:\n        return Measurement(0, 0)\n    get_measurement = Measurement.get\n    measurements = [\n        get_measurement(console, options, renderable) for renderable in renderables\n    ]\n    measured_width = Measurement(\n        max(measurements, key=itemgetter(0)).minimum,\n        max(measurements, key=itemgetter(1)).maximum,\n    )\n    return measured_width\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/padding.py","size":4908,"sha1":"2a3db7368ecfeb2a10c76fa5fbc3a17da042f4af","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import TYPE_CHECKING, List, Optional, Tuple, Union\n\nif TYPE_CHECKING:\n    from .console import (\n        Console,\n        ConsoleOptions,\n        RenderableType,\n        RenderResult,\n    )\n\nfrom .jupyter import JupyterMixin\nfrom .measure import Measurement\nfrom .segment import Segment\nfrom .style import Style\n\nPaddingDimensions = Union[int, Tuple[int], Tuple[int, int], Tuple[int, int, int, int]]\n\n\nclass Padding(JupyterMixin):\n    \"\"\"Draw space around content.\n\n    Example:\n        >>> print(Padding(\"Hello\", (2, 4), style=\"on blue\"))\n\n    Args:\n        renderable (RenderableType): String or other renderable.\n        pad (Union[int, Tuple[int]]): Padding for top, right, bottom, and left borders.\n            May be specified with 1, 2, or 4 integers (CSS style).\n        style (Union[str, Style], optional): Style for padding characters. Defaults to \"none\".\n        expand (bool, optional): Expand padding to fit available width. Defaults to True.\n    \"\"\"\n\n    def __init__(\n        self,\n        renderable: \"RenderableType\",\n        pad: \"PaddingDimensions\" = (0, 0, 0, 0),\n        *,\n        style: Union[str, Style] = \"none\",\n        expand: bool = True,\n    ):\n        self.renderable = renderable\n        self.top, self.right, self.bottom, self.left = self.unpack(pad)\n        self.style = style\n        self.expand = expand\n\n    @classmethod\n    def indent(cls, renderable: \"RenderableType\", level: int) -> \"Padding\":\n        \"\"\"Make padding instance to render an indent.\n\n        Args:\n            renderable (RenderableType): String or other renderable.\n            level (int): Number of characters to indent.\n\n        Returns:\n            Padding: A Padding instance.\n        \"\"\"\n\n        return Padding(renderable, pad=(0, 0, 0, level), expand=False)\n\n    @staticmethod\n    def unpack(pad: \"PaddingDimensions\") -> Tuple[int, int, int, int]:\n        \"\"\"Unpack padding specified in CSS style.\"\"\"\n        if isinstance(pad, int):\n            return (pad, pad, pad, pad)\n        if len(pad) == 1:\n            _pad = pad[0]\n            return (_pad, _pad, _pad, _pad)\n        if len(pad) == 2:\n            pad_top, pad_right = pad\n            return (pad_top, pad_right, pad_top, pad_right)\n        if len(pad) == 4:\n            top, right, bottom, left = pad\n            return (top, right, bottom, left)\n        raise ValueError(f\"1, 2 or 4 integers required for padding; {len(pad)} given\")\n\n    def __repr__(self) -> str:\n        return f\"Padding({self.renderable!r}, ({self.top},{self.right},{self.bottom},{self.left}))\"\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        style = console.get_style(self.style)\n        if self.expand:\n            width = options.max_width\n        else:\n            width = min(\n                Measurement.get(console, options, self.renderable).maximum\n                + self.left\n                + self.right,\n                options.max_width,\n            )\n        render_options = options.update_width(width - self.left - self.right)\n        if render_options.height is not None:\n            render_options = render_options.update_height(\n                height=render_options.height - self.top - self.bottom\n            )\n        lines = console.render_lines(\n            self.renderable, render_options, style=style, pad=True\n        )\n        _Segment = Segment\n\n        left = _Segment(\" \" * self.left, style) if self.left else None\n        right = (\n            [_Segment(f'{\" \" * self.right}', style), _Segment.line()]\n            if self.right\n            else [_Segment.line()]\n        )\n        blank_line: Optional[List[Segment]] = None\n        if self.top:\n            blank_line = [_Segment(f'{\" \" * width}\\n', style)]\n            yield from blank_line * self.top\n        if left:\n            for line in lines:\n                yield left\n                yield from line\n                yield from right\n        else:\n            for line in lines:\n                yield from line\n                yield from right\n        if self.bottom:\n            blank_line = blank_line or [_Segment(f'{\" \" * width}\\n', style)]\n            yield from blank_line * self.bottom\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        max_width = options.max_width\n        extra_width = self.left + self.right\n        if max_width - extra_width < 1:\n            return Measurement(max_width, max_width)\n        measure_min, measure_max = Measurement.get(console, options, self.renderable)\n        measurement = Measurement(measure_min + extra_width, measure_max + extra_width)\n        measurement = measurement.with_maximum(max_width)\n        return measurement\n\n\nif __name__ == \"__main__\":  #  pragma: no cover\n    from pip._vendor.rich import print\n\n    print(Padding(\"Hello, World\", (2, 4), style=\"on blue\"))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/pager.py","size":828,"sha1":"66a01aaa2f82c4f00e8dde3c2a7eb04e876613e7","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from abc import ABC, abstractmethod\nfrom typing import Any\n\n\nclass Pager(ABC):\n    \"\"\"Base class for a pager.\"\"\"\n\n    @abstractmethod\n    def show(self, content: str) -> None:\n        \"\"\"Show content in pager.\n\n        Args:\n            content (str): Content to be displayed.\n        \"\"\"\n\n\nclass SystemPager(Pager):\n    \"\"\"Uses the pager installed on the system.\"\"\"\n\n    def _pager(self, content: str) -> Any:  # Â pragma: no cover\n        return __import__(\"pydoc\").pager(content)\n\n    def show(self, content: str) -> None:\n        \"\"\"Use the same pager used by pydoc.\"\"\"\n        self._pager(content)\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from .__main__ import make_test_card\n    from .console import Console\n\n    console = Console()\n    with console.pager(styles=True):\n        console.print(make_test_card())\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/palette.py","size":3396,"sha1":"30f805997188595a92c7e3a32effdadf5d7f7e6a","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from math import sqrt\nfrom functools import lru_cache\nfrom typing import Sequence, Tuple, TYPE_CHECKING\n\nfrom .color_triplet import ColorTriplet\n\nif TYPE_CHECKING:\n    from pip._vendor.rich.table import Table\n\n\nclass Palette:\n    \"\"\"A palette of available colors.\"\"\"\n\n    def __init__(self, colors: Sequence[Tuple[int, int, int]]):\n        self._colors = colors\n\n    def __getitem__(self, number: int) -> ColorTriplet:\n        return ColorTriplet(*self._colors[number])\n\n    def __rich__(self) -> \"Table\":\n        from pip._vendor.rich.color import Color\n        from pip._vendor.rich.style import Style\n        from pip._vendor.rich.text import Text\n        from pip._vendor.rich.table import Table\n\n        table = Table(\n            \"index\",\n            \"RGB\",\n            \"Color\",\n            title=\"Palette\",\n            caption=f\"{len(self._colors)} colors\",\n            highlight=True,\n            caption_justify=\"right\",\n        )\n        for index, color in enumerate(self._colors):\n            table.add_row(\n                str(index),\n                repr(color),\n                Text(\" \" * 16, style=Style(bgcolor=Color.from_rgb(*color))),\n            )\n        return table\n\n    # This is somewhat inefficient and needs caching\n    @lru_cache(maxsize=1024)\n    def match(self, color: Tuple[int, int, int]) -> int:\n        \"\"\"Find a color from a palette that most closely matches a given color.\n\n        Args:\n            color (Tuple[int, int, int]): RGB components in range 0 > 255.\n\n        Returns:\n            int: Index of closes matching color.\n        \"\"\"\n        red1, green1, blue1 = color\n        _sqrt = sqrt\n        get_color = self._colors.__getitem__\n\n        def get_color_distance(index: int) -> float:\n            \"\"\"Get the distance to a color.\"\"\"\n            red2, green2, blue2 = get_color(index)\n            red_mean = (red1 + red2) // 2\n            red = red1 - red2\n            green = green1 - green2\n            blue = blue1 - blue2\n            return _sqrt(\n                (((512 + red_mean) * red * red) >> 8)\n                + 4 * green * green\n                + (((767 - red_mean) * blue * blue) >> 8)\n            )\n\n        min_index = min(range(len(self._colors)), key=get_color_distance)\n        return min_index\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    import colorsys\n    from typing import Iterable\n    from pip._vendor.rich.color import Color\n    from pip._vendor.rich.console import Console, ConsoleOptions\n    from pip._vendor.rich.segment import Segment\n    from pip._vendor.rich.style import Style\n\n    class ColorBox:\n        def __rich_console__(\n            self, console: Console, options: ConsoleOptions\n        ) -> Iterable[Segment]:\n            height = console.size.height - 3\n            for y in range(0, height):\n                for x in range(options.max_width):\n                    h = x / options.max_width\n                    l = y / (height + 1)\n                    r1, g1, b1 = colorsys.hls_to_rgb(h, l, 1.0)\n                    r2, g2, b2 = colorsys.hls_to_rgb(h, l + (1 / height / 2), 1.0)\n                    bgcolor = Color.from_rgb(r1 * 255, g1 * 255, b1 * 255)\n                    color = Color.from_rgb(r2 * 255, g2 * 255, b2 * 255)\n                    yield Segment(\"â–„\", Style(color=color, bgcolor=bgcolor))\n                yield Segment.line()\n\n    console = Console()\n    console.print(ColorBox())\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/panel.py","size":11235,"sha1":"9a2611cd2944c5776102787f5d043883c05833e9","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import TYPE_CHECKING, Optional\n\nfrom .align import AlignMethod\nfrom .box import ROUNDED, Box\nfrom .cells import cell_len\nfrom .jupyter import JupyterMixin\nfrom .measure import Measurement, measure_renderables\nfrom .padding import Padding, PaddingDimensions\nfrom .segment import Segment\nfrom .style import Style, StyleType\nfrom .text import Text, TextType\n\nif TYPE_CHECKING:\n    from .console import Console, ConsoleOptions, RenderableType, RenderResult\n\n\nclass Panel(JupyterMixin):\n    \"\"\"A console renderable that draws a border around its contents.\n\n    Example:\n        >>> console.print(Panel(\"Hello, World!\"))\n\n    Args:\n        renderable (RenderableType): A console renderable object.\n        box (Box, optional): A Box instance that defines the look of the border (see :ref:`appendix_box`. Defaults to box.ROUNDED.\n        title (Optional[TextType], optional): Optional title displayed in panel header. Defaults to None.\n        title_align (AlignMethod, optional): Alignment of title. Defaults to \"center\".\n        subtitle (Optional[TextType], optional): Optional subtitle displayed in panel footer. Defaults to None.\n        subtitle_align (AlignMethod, optional): Alignment of subtitle. Defaults to \"center\".\n        safe_box (bool, optional): Disable box characters that don't display on windows legacy terminal with *raster* fonts. Defaults to True.\n        expand (bool, optional): If True the panel will stretch to fill the console width, otherwise it will be sized to fit the contents. Defaults to True.\n        style (str, optional): The style of the panel (border and contents). Defaults to \"none\".\n        border_style (str, optional): The style of the border. Defaults to \"none\".\n        width (Optional[int], optional): Optional width of panel. Defaults to None to auto-detect.\n        height (Optional[int], optional): Optional height of panel. Defaults to None to auto-detect.\n        padding (Optional[PaddingDimensions]): Optional padding around renderable. Defaults to 0.\n        highlight (bool, optional): Enable automatic highlighting of panel title (if str). Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        renderable: \"RenderableType\",\n        box: Box = ROUNDED,\n        *,\n        title: Optional[TextType] = None,\n        title_align: AlignMethod = \"center\",\n        subtitle: Optional[TextType] = None,\n        subtitle_align: AlignMethod = \"center\",\n        safe_box: Optional[bool] = None,\n        expand: bool = True,\n        style: StyleType = \"none\",\n        border_style: StyleType = \"none\",\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        padding: PaddingDimensions = (0, 1),\n        highlight: bool = False,\n    ) -> None:\n        self.renderable = renderable\n        self.box = box\n        self.title = title\n        self.title_align: AlignMethod = title_align\n        self.subtitle = subtitle\n        self.subtitle_align = subtitle_align\n        self.safe_box = safe_box\n        self.expand = expand\n        self.style = style\n        self.border_style = border_style\n        self.width = width\n        self.height = height\n        self.padding = padding\n        self.highlight = highlight\n\n    @classmethod\n    def fit(\n        cls,\n        renderable: \"RenderableType\",\n        box: Box = ROUNDED,\n        *,\n        title: Optional[TextType] = None,\n        title_align: AlignMethod = \"center\",\n        subtitle: Optional[TextType] = None,\n        subtitle_align: AlignMethod = \"center\",\n        safe_box: Optional[bool] = None,\n        style: StyleType = \"none\",\n        border_style: StyleType = \"none\",\n        width: Optional[int] = None,\n        height: Optional[int] = None,\n        padding: PaddingDimensions = (0, 1),\n        highlight: bool = False,\n    ) -> \"Panel\":\n        \"\"\"An alternative constructor that sets expand=False.\"\"\"\n        return cls(\n            renderable,\n            box,\n            title=title,\n            title_align=title_align,\n            subtitle=subtitle,\n            subtitle_align=subtitle_align,\n            safe_box=safe_box,\n            style=style,\n            border_style=border_style,\n            width=width,\n            height=height,\n            padding=padding,\n            highlight=highlight,\n            expand=False,\n        )\n\n    @property\n    def _title(self) -> Optional[Text]:\n        if self.title:\n            title_text = (\n                Text.from_markup(self.title)\n                if isinstance(self.title, str)\n                else self.title.copy()\n            )\n            title_text.end = \"\"\n            title_text.plain = title_text.plain.replace(\"\\n\", \" \")\n            title_text.no_wrap = True\n            title_text.expand_tabs()\n            title_text.pad(1)\n            return title_text\n        return None\n\n    @property\n    def _subtitle(self) -> Optional[Text]:\n        if self.subtitle:\n            subtitle_text = (\n                Text.from_markup(self.subtitle)\n                if isinstance(self.subtitle, str)\n                else self.subtitle.copy()\n            )\n            subtitle_text.end = \"\"\n            subtitle_text.plain = subtitle_text.plain.replace(\"\\n\", \" \")\n            subtitle_text.no_wrap = True\n            subtitle_text.expand_tabs()\n            subtitle_text.pad(1)\n            return subtitle_text\n        return None\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        _padding = Padding.unpack(self.padding)\n        renderable = (\n            Padding(self.renderable, _padding) if any(_padding) else self.renderable\n        )\n        style = console.get_style(self.style)\n        partial_border_style = console.get_style(self.border_style)\n        border_style = style + partial_border_style\n        width = (\n            options.max_width\n            if self.width is None\n            else min(options.max_width, self.width)\n        )\n\n        safe_box: bool = console.safe_box if self.safe_box is None else self.safe_box\n        box = self.box.substitute(options, safe=safe_box)\n\n        def align_text(\n            text: Text, width: int, align: str, character: str, style: Style\n        ) -> Text:\n            \"\"\"Gets new aligned text.\n\n            Args:\n                text (Text): Title or subtitle text.\n                width (int): Desired width.\n                align (str): Alignment.\n                character (str): Character for alignment.\n                style (Style): Border style\n\n            Returns:\n                Text: New text instance\n            \"\"\"\n            text = text.copy()\n            text.truncate(width)\n            excess_space = width - cell_len(text.plain)\n            if text.style:\n                text.stylize(console.get_style(text.style))\n\n            if excess_space:\n                if align == \"left\":\n                    return Text.assemble(\n                        text,\n                        (character * excess_space, style),\n                        no_wrap=True,\n                        end=\"\",\n                    )\n                elif align == \"center\":\n                    left = excess_space // 2\n                    return Text.assemble(\n                        (character * left, style),\n                        text,\n                        (character * (excess_space - left), style),\n                        no_wrap=True,\n                        end=\"\",\n                    )\n                else:\n                    return Text.assemble(\n                        (character * excess_space, style),\n                        text,\n                        no_wrap=True,\n                        end=\"\",\n                    )\n            return text\n\n        title_text = self._title\n        if title_text is not None:\n            title_text.stylize_before(partial_border_style)\n\n        child_width = (\n            width - 2\n            if self.expand\n            else console.measure(\n                renderable, options=options.update_width(width - 2)\n            ).maximum\n        )\n        child_height = self.height or options.height or None\n        if child_height:\n            child_height -= 2\n        if title_text is not None:\n            child_width = min(\n                options.max_width - 2, max(child_width, title_text.cell_len + 2)\n            )\n\n        width = child_width + 2\n        child_options = options.update(\n            width=child_width, height=child_height, highlight=self.highlight\n        )\n        lines = console.render_lines(renderable, child_options, style=style)\n\n        line_start = Segment(box.mid_left, border_style)\n        line_end = Segment(f\"{box.mid_right}\", border_style)\n        new_line = Segment.line()\n        if title_text is None or width <= 4:\n            yield Segment(box.get_top([width - 2]), border_style)\n        else:\n            title_text = align_text(\n                title_text,\n                width - 4,\n                self.title_align,\n                box.top,\n                border_style,\n            )\n            yield Segment(box.top_left + box.top, border_style)\n            yield from console.render(title_text, child_options.update_width(width - 4))\n            yield Segment(box.top + box.top_right, border_style)\n\n        yield new_line\n        for line in lines:\n            yield line_start\n            yield from line\n            yield line_end\n            yield new_line\n\n        subtitle_text = self._subtitle\n        if subtitle_text is not None:\n            subtitle_text.stylize_before(partial_border_style)\n\n        if subtitle_text is None or width <= 4:\n            yield Segment(box.get_bottom([width - 2]), border_style)\n        else:\n            subtitle_text = align_text(\n                subtitle_text,\n                width - 4,\n                self.subtitle_align,\n                box.bottom,\n                border_style,\n            )\n            yield Segment(box.bottom_left + box.bottom, border_style)\n            yield from console.render(\n                subtitle_text, child_options.update_width(width - 4)\n            )\n            yield Segment(box.bottom + box.bottom_right, border_style)\n\n        yield new_line\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        _title = self._title\n        _, right, _, left = Padding.unpack(self.padding)\n        padding = left + right\n        renderables = [self.renderable, _title] if _title else [self.renderable]\n\n        if self.width is None:\n            width = (\n                measure_renderables(\n                    console,\n                    options.update_width(options.max_width - padding - 2),\n                    renderables,\n                ).maximum\n                + padding\n                + 2\n            )\n        else:\n            width = self.width\n        return Measurement(width, width)\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from .console import Console\n\n    c = Console()\n\n    from .box import DOUBLE, ROUNDED\n    from .padding import Padding\n\n    p = Panel(\n        \"Hello, World!\",\n        title=\"rich.Panel\",\n        style=\"white on blue\",\n        box=DOUBLE,\n        padding=1,\n    )\n\n    c.print()\n    c.print(p)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/pretty.py","size":36391,"sha1":"f62af39f4c8d1acfa8647f44510234a9508520d3","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import builtins\nimport collections\nimport dataclasses\nimport inspect\nimport os\nimport reprlib\nimport sys\nfrom array import array\nfrom collections import Counter, UserDict, UserList, defaultdict, deque\nfrom dataclasses import dataclass, fields, is_dataclass\nfrom inspect import isclass\nfrom itertools import islice\nfrom types import MappingProxyType\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    DefaultDict,\n    Deque,\n    Dict,\n    Iterable,\n    List,\n    Optional,\n    Sequence,\n    Set,\n    Tuple,\n    Union,\n)\n\nfrom pip._vendor.rich.repr import RichReprResult\n\ntry:\n    import attr as _attr_module\n\n    _has_attrs = hasattr(_attr_module, \"ib\")\nexcept ImportError:  # pragma: no cover\n    _has_attrs = False\n\nfrom . import get_console\nfrom ._loop import loop_last\nfrom ._pick import pick_bool\nfrom .abc import RichRenderable\nfrom .cells import cell_len\nfrom .highlighter import ReprHighlighter\nfrom .jupyter import JupyterMixin, JupyterRenderable\nfrom .measure import Measurement\nfrom .text import Text\n\nif TYPE_CHECKING:\n    from .console import (\n        Console,\n        ConsoleOptions,\n        HighlighterType,\n        JustifyMethod,\n        OverflowMethod,\n        RenderResult,\n    )\n\n\ndef _is_attr_object(obj: Any) -> bool:\n    \"\"\"Check if an object was created with attrs module.\"\"\"\n    return _has_attrs and _attr_module.has(type(obj))\n\n\ndef _get_attr_fields(obj: Any) -> Sequence[\"_attr_module.Attribute[Any]\"]:\n    \"\"\"Get fields for an attrs object.\"\"\"\n    return _attr_module.fields(type(obj)) if _has_attrs else []\n\n\ndef _is_dataclass_repr(obj: object) -> bool:\n    \"\"\"Check if an instance of a dataclass contains the default repr.\n\n    Args:\n        obj (object): A dataclass instance.\n\n    Returns:\n        bool: True if the default repr is used, False if there is a custom repr.\n    \"\"\"\n    # Digging in to a lot of internals here\n    # Catching all exceptions in case something is missing on a non CPython implementation\n    try:\n        return obj.__repr__.__code__.co_filename in (\n            dataclasses.__file__,\n            reprlib.__file__,\n        )\n    except Exception:  # pragma: no coverage\n        return False\n\n\n_dummy_namedtuple = collections.namedtuple(\"_dummy_namedtuple\", [])\n\n\ndef _has_default_namedtuple_repr(obj: object) -> bool:\n    \"\"\"Check if an instance of namedtuple contains the default repr\n\n    Args:\n        obj (object): A namedtuple\n\n    Returns:\n        bool: True if the default repr is used, False if there's a custom repr.\n    \"\"\"\n    obj_file = None\n    try:\n        obj_file = inspect.getfile(obj.__repr__)\n    except (OSError, TypeError):\n        # OSError handles case where object is defined in __main__ scope, e.g. REPL - no filename available.\n        # TypeError trapped defensively, in case of object without filename slips through.\n        pass\n    default_repr_file = inspect.getfile(_dummy_namedtuple.__repr__)\n    return obj_file == default_repr_file\n\n\ndef _ipy_display_hook(\n    value: Any,\n    console: Optional[\"Console\"] = None,\n    overflow: \"OverflowMethod\" = \"ignore\",\n    crop: bool = False,\n    indent_guides: bool = False,\n    max_length: Optional[int] = None,\n    max_string: Optional[int] = None,\n    max_depth: Optional[int] = None,\n    expand_all: bool = False,\n) -> Union[str, None]:\n    # needed here to prevent circular import:\n    from .console import ConsoleRenderable\n\n    # always skip rich generated jupyter renderables or None values\n    if _safe_isinstance(value, JupyterRenderable) or value is None:\n        return None\n\n    console = console or get_console()\n\n    with console.capture() as capture:\n        # certain renderables should start on a new line\n        if _safe_isinstance(value, ConsoleRenderable):\n            console.line()\n        console.print(\n            (\n                value\n                if _safe_isinstance(value, RichRenderable)\n                else Pretty(\n                    value,\n                    overflow=overflow,\n                    indent_guides=indent_guides,\n                    max_length=max_length,\n                    max_string=max_string,\n                    max_depth=max_depth,\n                    expand_all=expand_all,\n                    margin=12,\n                )\n            ),\n            crop=crop,\n            new_line_start=True,\n            end=\"\",\n        )\n    # strip trailing newline, not usually part of a text repr\n    # I'm not sure if this should be prevented at a lower level\n    return capture.get().rstrip(\"\\n\")\n\n\ndef _safe_isinstance(\n    obj: object, class_or_tuple: Union[type, Tuple[type, ...]]\n) -> bool:\n    \"\"\"isinstance can fail in rare cases, for example types with no __class__\"\"\"\n    try:\n        return isinstance(obj, class_or_tuple)\n    except Exception:\n        return False\n\n\ndef install(\n    console: Optional[\"Console\"] = None,\n    overflow: \"OverflowMethod\" = \"ignore\",\n    crop: bool = False,\n    indent_guides: bool = False,\n    max_length: Optional[int] = None,\n    max_string: Optional[int] = None,\n    max_depth: Optional[int] = None,\n    expand_all: bool = False,\n) -> None:\n    \"\"\"Install automatic pretty printing in the Python REPL.\n\n    Args:\n        console (Console, optional): Console instance or ``None`` to use global console. Defaults to None.\n        overflow (Optional[OverflowMethod], optional): Overflow method. Defaults to \"ignore\".\n        crop (Optional[bool], optional): Enable cropping of long lines. Defaults to False.\n        indent_guides (bool, optional): Enable indentation guides. Defaults to False.\n        max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n            Defaults to None.\n        max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to None.\n        max_depth (int, optional): Maximum depth of nested data structures, or None for no maximum. Defaults to None.\n        expand_all (bool, optional): Expand all containers. Defaults to False.\n        max_frames (int): Maximum number of frames to show in a traceback, 0 for no maximum. Defaults to 100.\n    \"\"\"\n    from pip._vendor.rich import get_console\n\n    console = console or get_console()\n    assert console is not None\n\n    def display_hook(value: Any) -> None:\n        \"\"\"Replacement sys.displayhook which prettifies objects with Rich.\"\"\"\n        if value is not None:\n            assert console is not None\n            builtins._ = None  # type: ignore[attr-defined]\n            console.print(\n                (\n                    value\n                    if _safe_isinstance(value, RichRenderable)\n                    else Pretty(\n                        value,\n                        overflow=overflow,\n                        indent_guides=indent_guides,\n                        max_length=max_length,\n                        max_string=max_string,\n                        max_depth=max_depth,\n                        expand_all=expand_all,\n                    )\n                ),\n                crop=crop,\n            )\n            builtins._ = value  # type: ignore[attr-defined]\n\n    try:\n        ip = get_ipython()  # type: ignore[name-defined]\n    except NameError:\n        sys.displayhook = display_hook\n    else:\n        from IPython.core.formatters import BaseFormatter\n\n        class RichFormatter(BaseFormatter):  # type: ignore[misc]\n            pprint: bool = True\n\n            def __call__(self, value: Any) -> Any:\n                if self.pprint:\n                    return _ipy_display_hook(\n                        value,\n                        console=get_console(),\n                        overflow=overflow,\n                        indent_guides=indent_guides,\n                        max_length=max_length,\n                        max_string=max_string,\n                        max_depth=max_depth,\n                        expand_all=expand_all,\n                    )\n                else:\n                    return repr(value)\n\n        # replace plain text formatter with rich formatter\n        rich_formatter = RichFormatter()\n        ip.display_formatter.formatters[\"text/plain\"] = rich_formatter\n\n\nclass Pretty(JupyterMixin):\n    \"\"\"A rich renderable that pretty prints an object.\n\n    Args:\n        _object (Any): An object to pretty print.\n        highlighter (HighlighterType, optional): Highlighter object to apply to result, or None for ReprHighlighter. Defaults to None.\n        indent_size (int, optional): Number of spaces in indent. Defaults to 4.\n        justify (JustifyMethod, optional): Justify method, or None for default. Defaults to None.\n        overflow (OverflowMethod, optional): Overflow method, or None for default. Defaults to None.\n        no_wrap (Optional[bool], optional): Disable word wrapping. Defaults to False.\n        indent_guides (bool, optional): Enable indentation guides. Defaults to False.\n        max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n            Defaults to None.\n        max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to None.\n        max_depth (int, optional): Maximum depth of nested data structures, or None for no maximum. Defaults to None.\n        expand_all (bool, optional): Expand all containers. Defaults to False.\n        margin (int, optional): Subtrace a margin from width to force containers to expand earlier. Defaults to 0.\n        insert_line (bool, optional): Insert a new line if the output has multiple new lines. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        _object: Any,\n        highlighter: Optional[\"HighlighterType\"] = None,\n        *,\n        indent_size: int = 4,\n        justify: Optional[\"JustifyMethod\"] = None,\n        overflow: Optional[\"OverflowMethod\"] = None,\n        no_wrap: Optional[bool] = False,\n        indent_guides: bool = False,\n        max_length: Optional[int] = None,\n        max_string: Optional[int] = None,\n        max_depth: Optional[int] = None,\n        expand_all: bool = False,\n        margin: int = 0,\n        insert_line: bool = False,\n    ) -> None:\n        self._object = _object\n        self.highlighter = highlighter or ReprHighlighter()\n        self.indent_size = indent_size\n        self.justify: Optional[\"JustifyMethod\"] = justify\n        self.overflow: Optional[\"OverflowMethod\"] = overflow\n        self.no_wrap = no_wrap\n        self.indent_guides = indent_guides\n        self.max_length = max_length\n        self.max_string = max_string\n        self.max_depth = max_depth\n        self.expand_all = expand_all\n        self.margin = margin\n        self.insert_line = insert_line\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        pretty_str = pretty_repr(\n            self._object,\n            max_width=options.max_width - self.margin,\n            indent_size=self.indent_size,\n            max_length=self.max_length,\n            max_string=self.max_string,\n            max_depth=self.max_depth,\n            expand_all=self.expand_all,\n        )\n        pretty_text = Text.from_ansi(\n            pretty_str,\n            justify=self.justify or options.justify,\n            overflow=self.overflow or options.overflow,\n            no_wrap=pick_bool(self.no_wrap, options.no_wrap),\n            style=\"pretty\",\n        )\n        pretty_text = (\n            self.highlighter(pretty_text)\n            if pretty_text\n            else Text(\n                f\"{type(self._object)}.__repr__ returned empty string\",\n                style=\"dim italic\",\n            )\n        )\n        if self.indent_guides and not options.ascii_only:\n            pretty_text = pretty_text.with_indent_guides(\n                self.indent_size, style=\"repr.indent\"\n            )\n        if self.insert_line and \"\\n\" in pretty_text:\n            yield \"\"\n        yield pretty_text\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        pretty_str = pretty_repr(\n            self._object,\n            max_width=options.max_width,\n            indent_size=self.indent_size,\n            max_length=self.max_length,\n            max_string=self.max_string,\n            max_depth=self.max_depth,\n            expand_all=self.expand_all,\n        )\n        text_width = (\n            max(cell_len(line) for line in pretty_str.splitlines()) if pretty_str else 0\n        )\n        return Measurement(text_width, text_width)\n\n\ndef _get_braces_for_defaultdict(_object: DefaultDict[Any, Any]) -> Tuple[str, str, str]:\n    return (\n        f\"defaultdict({_object.default_factory!r}, {{\",\n        \"})\",\n        f\"defaultdict({_object.default_factory!r}, {{}})\",\n    )\n\n\ndef _get_braces_for_deque(_object: Deque[Any]) -> Tuple[str, str, str]:\n    if _object.maxlen is None:\n        return (\"deque([\", \"])\", \"deque()\")\n    return (\n        \"deque([\",\n        f\"], maxlen={_object.maxlen})\",\n        f\"deque(maxlen={_object.maxlen})\",\n    )\n\n\ndef _get_braces_for_array(_object: \"array[Any]\") -> Tuple[str, str, str]:\n    return (f\"array({_object.typecode!r}, [\", \"])\", f\"array({_object.typecode!r})\")\n\n\n_BRACES: Dict[type, Callable[[Any], Tuple[str, str, str]]] = {\n    os._Environ: lambda _object: (\"environ({\", \"})\", \"environ({})\"),\n    array: _get_braces_for_array,\n    defaultdict: _get_braces_for_defaultdict,\n    Counter: lambda _object: (\"Counter({\", \"})\", \"Counter()\"),\n    deque: _get_braces_for_deque,\n    dict: lambda _object: (\"{\", \"}\", \"{}\"),\n    UserDict: lambda _object: (\"{\", \"}\", \"{}\"),\n    frozenset: lambda _object: (\"frozenset({\", \"})\", \"frozenset()\"),\n    list: lambda _object: (\"[\", \"]\", \"[]\"),\n    UserList: lambda _object: (\"[\", \"]\", \"[]\"),\n    set: lambda _object: (\"{\", \"}\", \"set()\"),\n    tuple: lambda _object: (\"(\", \")\", \"()\"),\n    MappingProxyType: lambda _object: (\"mappingproxy({\", \"})\", \"mappingproxy({})\"),\n}\n_CONTAINERS = tuple(_BRACES.keys())\n_MAPPING_CONTAINERS = (dict, os._Environ, MappingProxyType, UserDict)\n\n\ndef is_expandable(obj: Any) -> bool:\n    \"\"\"Check if an object may be expanded by pretty print.\"\"\"\n    return (\n        _safe_isinstance(obj, _CONTAINERS)\n        or (is_dataclass(obj))\n        or (hasattr(obj, \"__rich_repr__\"))\n        or _is_attr_object(obj)\n    ) and not isclass(obj)\n\n\n@dataclass\nclass Node:\n    \"\"\"A node in a repr tree. May be atomic or a container.\"\"\"\n\n    key_repr: str = \"\"\n    value_repr: str = \"\"\n    open_brace: str = \"\"\n    close_brace: str = \"\"\n    empty: str = \"\"\n    last: bool = False\n    is_tuple: bool = False\n    is_namedtuple: bool = False\n    children: Optional[List[\"Node\"]] = None\n    key_separator: str = \": \"\n    separator: str = \", \"\n\n    def iter_tokens(self) -> Iterable[str]:\n        \"\"\"Generate tokens for this node.\"\"\"\n        if self.key_repr:\n            yield self.key_repr\n            yield self.key_separator\n        if self.value_repr:\n            yield self.value_repr\n        elif self.children is not None:\n            if self.children:\n                yield self.open_brace\n                if self.is_tuple and not self.is_namedtuple and len(self.children) == 1:\n                    yield from self.children[0].iter_tokens()\n                    yield \",\"\n                else:\n                    for child in self.children:\n                        yield from child.iter_tokens()\n                        if not child.last:\n                            yield self.separator\n                yield self.close_brace\n            else:\n                yield self.empty\n\n    def check_length(self, start_length: int, max_length: int) -> bool:\n        \"\"\"Check the length fits within a limit.\n\n        Args:\n            start_length (int): Starting length of the line (indent, prefix, suffix).\n            max_length (int): Maximum length.\n\n        Returns:\n            bool: True if the node can be rendered within max length, otherwise False.\n        \"\"\"\n        total_length = start_length\n        for token in self.iter_tokens():\n            total_length += cell_len(token)\n            if total_length > max_length:\n                return False\n        return True\n\n    def __str__(self) -> str:\n        repr_text = \"\".join(self.iter_tokens())\n        return repr_text\n\n    def render(\n        self, max_width: int = 80, indent_size: int = 4, expand_all: bool = False\n    ) -> str:\n        \"\"\"Render the node to a pretty repr.\n\n        Args:\n            max_width (int, optional): Maximum width of the repr. Defaults to 80.\n            indent_size (int, optional): Size of indents. Defaults to 4.\n            expand_all (bool, optional): Expand all levels. Defaults to False.\n\n        Returns:\n            str: A repr string of the original object.\n        \"\"\"\n        lines = [_Line(node=self, is_root=True)]\n        line_no = 0\n        while line_no < len(lines):\n            line = lines[line_no]\n            if line.expandable and not line.expanded:\n                if expand_all or not line.check_length(max_width):\n                    lines[line_no : line_no + 1] = line.expand(indent_size)\n            line_no += 1\n\n        repr_str = \"\\n\".join(str(line) for line in lines)\n        return repr_str\n\n\n@dataclass\nclass _Line:\n    \"\"\"A line in repr output.\"\"\"\n\n    parent: Optional[\"_Line\"] = None\n    is_root: bool = False\n    node: Optional[Node] = None\n    text: str = \"\"\n    suffix: str = \"\"\n    whitespace: str = \"\"\n    expanded: bool = False\n    last: bool = False\n\n    @property\n    def expandable(self) -> bool:\n        \"\"\"Check if the line may be expanded.\"\"\"\n        return bool(self.node is not None and self.node.children)\n\n    def check_length(self, max_length: int) -> bool:\n        \"\"\"Check this line fits within a given number of cells.\"\"\"\n        start_length = (\n            len(self.whitespace) + cell_len(self.text) + cell_len(self.suffix)\n        )\n        assert self.node is not None\n        return self.node.check_length(start_length, max_length)\n\n    def expand(self, indent_size: int) -> Iterable[\"_Line\"]:\n        \"\"\"Expand this line by adding children on their own line.\"\"\"\n        node = self.node\n        assert node is not None\n        whitespace = self.whitespace\n        assert node.children\n        if node.key_repr:\n            new_line = yield _Line(\n                text=f\"{node.key_repr}{node.key_separator}{node.open_brace}\",\n                whitespace=whitespace,\n            )\n        else:\n            new_line = yield _Line(text=node.open_brace, whitespace=whitespace)\n        child_whitespace = self.whitespace + \" \" * indent_size\n        tuple_of_one = node.is_tuple and len(node.children) == 1\n        for last, child in loop_last(node.children):\n            separator = \",\" if tuple_of_one else node.separator\n            line = _Line(\n                parent=new_line,\n                node=child,\n                whitespace=child_whitespace,\n                suffix=separator,\n                last=last and not tuple_of_one,\n            )\n            yield line\n\n        yield _Line(\n            text=node.close_brace,\n            whitespace=whitespace,\n            suffix=self.suffix,\n            last=self.last,\n        )\n\n    def __str__(self) -> str:\n        if self.last:\n            return f\"{self.whitespace}{self.text}{self.node or ''}\"\n        else:\n            return (\n                f\"{self.whitespace}{self.text}{self.node or ''}{self.suffix.rstrip()}\"\n            )\n\n\ndef _is_namedtuple(obj: Any) -> bool:\n    \"\"\"Checks if an object is most likely a namedtuple. It is possible\n    to craft an object that passes this check and isn't a namedtuple, but\n    there is only a minuscule chance of this happening unintentionally.\n\n    Args:\n        obj (Any): The object to test\n\n    Returns:\n        bool: True if the object is a namedtuple. False otherwise.\n    \"\"\"\n    try:\n        fields = getattr(obj, \"_fields\", None)\n    except Exception:\n        # Being very defensive - if we cannot get the attr then its not a namedtuple\n        return False\n    return isinstance(obj, tuple) and isinstance(fields, tuple)\n\n\ndef traverse(\n    _object: Any,\n    max_length: Optional[int] = None,\n    max_string: Optional[int] = None,\n    max_depth: Optional[int] = None,\n) -> Node:\n    \"\"\"Traverse object and generate a tree.\n\n    Args:\n        _object (Any): Object to be traversed.\n        max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n            Defaults to None.\n        max_string (int, optional): Maximum length of string before truncating, or None to disable truncating.\n            Defaults to None.\n        max_depth (int, optional): Maximum depth of data structures, or None for no maximum.\n            Defaults to None.\n\n    Returns:\n        Node: The root of a tree structure which can be used to render a pretty repr.\n    \"\"\"\n\n    def to_repr(obj: Any) -> str:\n        \"\"\"Get repr string for an object, but catch errors.\"\"\"\n        if (\n            max_string is not None\n            and _safe_isinstance(obj, (bytes, str))\n            and len(obj) > max_string\n        ):\n            truncated = len(obj) - max_string\n            obj_repr = f\"{obj[:max_string]!r}+{truncated}\"\n        else:\n            try:\n                obj_repr = repr(obj)\n            except Exception as error:\n                obj_repr = f\"<repr-error {str(error)!r}>\"\n        return obj_repr\n\n    visited_ids: Set[int] = set()\n    push_visited = visited_ids.add\n    pop_visited = visited_ids.remove\n\n    def _traverse(obj: Any, root: bool = False, depth: int = 0) -> Node:\n        \"\"\"Walk the object depth first.\"\"\"\n\n        obj_id = id(obj)\n        if obj_id in visited_ids:\n            # Recursion detected\n            return Node(value_repr=\"...\")\n\n        obj_type = type(obj)\n        children: List[Node]\n        reached_max_depth = max_depth is not None and depth >= max_depth\n\n        def iter_rich_args(rich_args: Any) -> Iterable[Union[Any, Tuple[str, Any]]]:\n            for arg in rich_args:\n                if _safe_isinstance(arg, tuple):\n                    if len(arg) == 3:\n                        key, child, default = arg\n                        if default == child:\n                            continue\n                        yield key, child\n                    elif len(arg) == 2:\n                        key, child = arg\n                        yield key, child\n                    elif len(arg) == 1:\n                        yield arg[0]\n                else:\n                    yield arg\n\n        try:\n            fake_attributes = hasattr(\n                obj, \"awehoi234_wdfjwljet234_234wdfoijsdfmmnxpi492\"\n            )\n        except Exception:\n            fake_attributes = False\n\n        rich_repr_result: Optional[RichReprResult] = None\n        if not fake_attributes:\n            try:\n                if hasattr(obj, \"__rich_repr__\") and not isclass(obj):\n                    rich_repr_result = obj.__rich_repr__()\n            except Exception:\n                pass\n\n        if rich_repr_result is not None:\n            push_visited(obj_id)\n            angular = getattr(obj.__rich_repr__, \"angular\", False)\n            args = list(iter_rich_args(rich_repr_result))\n            class_name = obj.__class__.__name__\n\n            if args:\n                children = []\n                append = children.append\n\n                if reached_max_depth:\n                    if angular:\n                        node = Node(value_repr=f\"<{class_name}...>\")\n                    else:\n                        node = Node(value_repr=f\"{class_name}(...)\")\n                else:\n                    if angular:\n                        node = Node(\n                            open_brace=f\"<{class_name} \",\n                            close_brace=\">\",\n                            children=children,\n                            last=root,\n                            separator=\" \",\n                        )\n                    else:\n                        node = Node(\n                            open_brace=f\"{class_name}(\",\n                            close_brace=\")\",\n                            children=children,\n                            last=root,\n                        )\n                    for last, arg in loop_last(args):\n                        if _safe_isinstance(arg, tuple):\n                            key, child = arg\n                            child_node = _traverse(child, depth=depth + 1)\n                            child_node.last = last\n                            child_node.key_repr = key\n                            child_node.key_separator = \"=\"\n                            append(child_node)\n                        else:\n                            child_node = _traverse(arg, depth=depth + 1)\n                            child_node.last = last\n                            append(child_node)\n            else:\n                node = Node(\n                    value_repr=f\"<{class_name}>\" if angular else f\"{class_name}()\",\n                    children=[],\n                    last=root,\n                )\n            pop_visited(obj_id)\n        elif _is_attr_object(obj) and not fake_attributes:\n            push_visited(obj_id)\n            children = []\n            append = children.append\n\n            attr_fields = _get_attr_fields(obj)\n            if attr_fields:\n                if reached_max_depth:\n                    node = Node(value_repr=f\"{obj.__class__.__name__}(...)\")\n                else:\n                    node = Node(\n                        open_brace=f\"{obj.__class__.__name__}(\",\n                        close_brace=\")\",\n                        children=children,\n                        last=root,\n                    )\n\n                    def iter_attrs() -> (\n                        Iterable[Tuple[str, Any, Optional[Callable[[Any], str]]]]\n                    ):\n                        \"\"\"Iterate over attr fields and values.\"\"\"\n                        for attr in attr_fields:\n                            if attr.repr:\n                                try:\n                                    value = getattr(obj, attr.name)\n                                except Exception as error:\n                                    # Can happen, albeit rarely\n                                    yield (attr.name, error, None)\n                                else:\n                                    yield (\n                                        attr.name,\n                                        value,\n                                        attr.repr if callable(attr.repr) else None,\n                                    )\n\n                    for last, (name, value, repr_callable) in loop_last(iter_attrs()):\n                        if repr_callable:\n                            child_node = Node(value_repr=str(repr_callable(value)))\n                        else:\n                            child_node = _traverse(value, depth=depth + 1)\n                        child_node.last = last\n                        child_node.key_repr = name\n                        child_node.key_separator = \"=\"\n                        append(child_node)\n            else:\n                node = Node(\n                    value_repr=f\"{obj.__class__.__name__}()\", children=[], last=root\n                )\n            pop_visited(obj_id)\n        elif (\n            is_dataclass(obj)\n            and not _safe_isinstance(obj, type)\n            and not fake_attributes\n            and _is_dataclass_repr(obj)\n        ):\n            push_visited(obj_id)\n            children = []\n            append = children.append\n            if reached_max_depth:\n                node = Node(value_repr=f\"{obj.__class__.__name__}(...)\")\n            else:\n                node = Node(\n                    open_brace=f\"{obj.__class__.__name__}(\",\n                    close_brace=\")\",\n                    children=children,\n                    last=root,\n                    empty=f\"{obj.__class__.__name__}()\",\n                )\n\n                for last, field in loop_last(\n                    field\n                    for field in fields(obj)\n                    if field.repr and hasattr(obj, field.name)\n                ):\n                    child_node = _traverse(getattr(obj, field.name), depth=depth + 1)\n                    child_node.key_repr = field.name\n                    child_node.last = last\n                    child_node.key_separator = \"=\"\n                    append(child_node)\n\n            pop_visited(obj_id)\n        elif _is_namedtuple(obj) and _has_default_namedtuple_repr(obj):\n            push_visited(obj_id)\n            class_name = obj.__class__.__name__\n            if reached_max_depth:\n                # If we've reached the max depth, we still show the class name, but not its contents\n                node = Node(\n                    value_repr=f\"{class_name}(...)\",\n                )\n            else:\n                children = []\n                append = children.append\n                node = Node(\n                    open_brace=f\"{class_name}(\",\n                    close_brace=\")\",\n                    children=children,\n                    empty=f\"{class_name}()\",\n                )\n                for last, (key, value) in loop_last(obj._asdict().items()):\n                    child_node = _traverse(value, depth=depth + 1)\n                    child_node.key_repr = key\n                    child_node.last = last\n                    child_node.key_separator = \"=\"\n                    append(child_node)\n            pop_visited(obj_id)\n        elif _safe_isinstance(obj, _CONTAINERS):\n            for container_type in _CONTAINERS:\n                if _safe_isinstance(obj, container_type):\n                    obj_type = container_type\n                    break\n\n            push_visited(obj_id)\n\n            open_brace, close_brace, empty = _BRACES[obj_type](obj)\n\n            if reached_max_depth:\n                node = Node(value_repr=f\"{open_brace}...{close_brace}\")\n            elif obj_type.__repr__ != type(obj).__repr__:\n                node = Node(value_repr=to_repr(obj), last=root)\n            elif obj:\n                children = []\n                node = Node(\n                    open_brace=open_brace,\n                    close_brace=close_brace,\n                    children=children,\n                    last=root,\n                )\n                append = children.append\n                num_items = len(obj)\n                last_item_index = num_items - 1\n\n                if _safe_isinstance(obj, _MAPPING_CONTAINERS):\n                    iter_items = iter(obj.items())\n                    if max_length is not None:\n                        iter_items = islice(iter_items, max_length)\n                    for index, (key, child) in enumerate(iter_items):\n                        child_node = _traverse(child, depth=depth + 1)\n                        child_node.key_repr = to_repr(key)\n                        child_node.last = index == last_item_index\n                        append(child_node)\n                else:\n                    iter_values = iter(obj)\n                    if max_length is not None:\n                        iter_values = islice(iter_values, max_length)\n                    for index, child in enumerate(iter_values):\n                        child_node = _traverse(child, depth=depth + 1)\n                        child_node.last = index == last_item_index\n                        append(child_node)\n                if max_length is not None and num_items > max_length:\n                    append(Node(value_repr=f\"... +{num_items - max_length}\", last=True))\n            else:\n                node = Node(empty=empty, children=[], last=root)\n\n            pop_visited(obj_id)\n        else:\n            node = Node(value_repr=to_repr(obj), last=root)\n        node.is_tuple = type(obj) == tuple\n        node.is_namedtuple = _is_namedtuple(obj)\n        return node\n\n    node = _traverse(_object, root=True)\n    return node\n\n\ndef pretty_repr(\n    _object: Any,\n    *,\n    max_width: int = 80,\n    indent_size: int = 4,\n    max_length: Optional[int] = None,\n    max_string: Optional[int] = None,\n    max_depth: Optional[int] = None,\n    expand_all: bool = False,\n) -> str:\n    \"\"\"Prettify repr string by expanding on to new lines to fit within a given width.\n\n    Args:\n        _object (Any): Object to repr.\n        max_width (int, optional): Desired maximum width of repr string. Defaults to 80.\n        indent_size (int, optional): Number of spaces to indent. Defaults to 4.\n        max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n            Defaults to None.\n        max_string (int, optional): Maximum length of string before truncating, or None to disable truncating.\n            Defaults to None.\n        max_depth (int, optional): Maximum depth of nested data structure, or None for no depth.\n            Defaults to None.\n        expand_all (bool, optional): Expand all containers regardless of available width. Defaults to False.\n\n    Returns:\n        str: A possibly multi-line representation of the object.\n    \"\"\"\n\n    if _safe_isinstance(_object, Node):\n        node = _object\n    else:\n        node = traverse(\n            _object, max_length=max_length, max_string=max_string, max_depth=max_depth\n        )\n    repr_str: str = node.render(\n        max_width=max_width, indent_size=indent_size, expand_all=expand_all\n    )\n    return repr_str\n\n\ndef pprint(\n    _object: Any,\n    *,\n    console: Optional[\"Console\"] = None,\n    indent_guides: bool = True,\n    max_length: Optional[int] = None,\n    max_string: Optional[int] = None,\n    max_depth: Optional[int] = None,\n    expand_all: bool = False,\n) -> None:\n    \"\"\"A convenience function for pretty printing.\n\n    Args:\n        _object (Any): Object to pretty print.\n        console (Console, optional): Console instance, or None to use default. Defaults to None.\n        max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n            Defaults to None.\n        max_string (int, optional): Maximum length of strings before truncating, or None to disable. Defaults to None.\n        max_depth (int, optional): Maximum depth for nested data structures, or None for unlimited depth. Defaults to None.\n        indent_guides (bool, optional): Enable indentation guides. Defaults to True.\n        expand_all (bool, optional): Expand all containers. Defaults to False.\n    \"\"\"\n    _console = get_console() if console is None else console\n    _console.print(\n        Pretty(\n            _object,\n            max_length=max_length,\n            max_string=max_string,\n            max_depth=max_depth,\n            indent_guides=indent_guides,\n            expand_all=expand_all,\n            overflow=\"ignore\",\n        ),\n        soft_wrap=True,\n    )\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n\n    class BrokenRepr:\n        def __repr__(self) -> str:\n            1 / 0\n            return \"this will fail\"\n\n    from typing import NamedTuple\n\n    class StockKeepingUnit(NamedTuple):\n        name: str\n        description: str\n        price: float\n        category: str\n        reviews: List[str]\n\n    d = defaultdict(int)\n    d[\"foo\"] = 5\n    data = {\n        \"foo\": [\n            1,\n            \"Hello World!\",\n            100.123,\n            323.232,\n            432324.0,\n            {5, 6, 7, (1, 2, 3, 4), 8},\n        ],\n        \"bar\": frozenset({1, 2, 3}),\n        \"defaultdict\": defaultdict(\n            list, {\"crumble\": [\"apple\", \"rhubarb\", \"butter\", \"sugar\", \"flour\"]}\n        ),\n        \"counter\": Counter(\n            [\n                \"apple\",\n                \"orange\",\n                \"pear\",\n                \"kumquat\",\n                \"kumquat\",\n                \"durian\" * 100,\n            ]\n        ),\n        \"atomic\": (False, True, None),\n        \"namedtuple\": StockKeepingUnit(\n            \"Sparkling British Spring Water\",\n            \"Carbonated spring water\",\n            0.9,\n            \"water\",\n            [\"its amazing!\", \"its terrible!\"],\n        ),\n        \"Broken\": BrokenRepr(),\n    }\n    data[\"foo\"].append(data)  # type: ignore[attr-defined]\n\n    from pip._vendor.rich import print\n\n    print(Pretty(data, indent_guides=True, max_string=20))\n\n    class Thing:\n        def __repr__(self) -> str:\n            return \"Hello\\x1b[38;5;239m World!\"\n\n    print(Pretty(Thing()))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/progress.py","size":60357,"sha1":"a4db842800f05093438c69a4d1f019011e0207f9","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import io\nimport sys\nimport typing\nimport warnings\nfrom abc import ABC, abstractmethod\nfrom collections import deque\nfrom dataclasses import dataclass, field\nfrom datetime import timedelta\nfrom io import RawIOBase, UnsupportedOperation\nfrom math import ceil\nfrom mmap import mmap\nfrom operator import length_hint\nfrom os import PathLike, stat\nfrom threading import Event, RLock, Thread\nfrom types import TracebackType\nfrom typing import (\n    Any,\n    BinaryIO,\n    Callable,\n    ContextManager,\n    Deque,\n    Dict,\n    Generic,\n    Iterable,\n    List,\n    NamedTuple,\n    NewType,\n    Optional,\n    Sequence,\n    TextIO,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n)\n\nif sys.version_info >= (3, 8):\n    from typing import Literal\nelse:\n    from pip._vendor.typing_extensions import Literal  # pragma: no cover\n\nif sys.version_info >= (3, 11):\n    from typing import Self\nelse:\n    from pip._vendor.typing_extensions import Self  # pragma: no cover\n\nfrom . import filesize, get_console\nfrom .console import Console, Group, JustifyMethod, RenderableType\nfrom .highlighter import Highlighter\nfrom .jupyter import JupyterMixin\nfrom .live import Live\nfrom .progress_bar import ProgressBar\nfrom .spinner import Spinner\nfrom .style import StyleType\nfrom .table import Column, Table\nfrom .text import Text, TextType\n\nTaskID = NewType(\"TaskID\", int)\n\nProgressType = TypeVar(\"ProgressType\")\n\nGetTimeCallable = Callable[[], float]\n\n\n_I = typing.TypeVar(\"_I\", TextIO, BinaryIO)\n\n\nclass _TrackThread(Thread):\n    \"\"\"A thread to periodically update progress.\"\"\"\n\n    def __init__(self, progress: \"Progress\", task_id: \"TaskID\", update_period: float):\n        self.progress = progress\n        self.task_id = task_id\n        self.update_period = update_period\n        self.done = Event()\n\n        self.completed = 0\n        super().__init__(daemon=True)\n\n    def run(self) -> None:\n        task_id = self.task_id\n        advance = self.progress.advance\n        update_period = self.update_period\n        last_completed = 0\n        wait = self.done.wait\n        while not wait(update_period) and self.progress.live.is_started:\n            completed = self.completed\n            if last_completed != completed:\n                advance(task_id, completed - last_completed)\n                last_completed = completed\n\n        self.progress.update(self.task_id, completed=self.completed, refresh=True)\n\n    def __enter__(self) -> \"_TrackThread\":\n        self.start()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        self.done.set()\n        self.join()\n\n\ndef track(\n    sequence: Union[Sequence[ProgressType], Iterable[ProgressType]],\n    description: str = \"Working...\",\n    total: Optional[float] = None,\n    completed: int = 0,\n    auto_refresh: bool = True,\n    console: Optional[Console] = None,\n    transient: bool = False,\n    get_time: Optional[Callable[[], float]] = None,\n    refresh_per_second: float = 10,\n    style: StyleType = \"bar.back\",\n    complete_style: StyleType = \"bar.complete\",\n    finished_style: StyleType = \"bar.finished\",\n    pulse_style: StyleType = \"bar.pulse\",\n    update_period: float = 0.1,\n    disable: bool = False,\n    show_speed: bool = True,\n) -> Iterable[ProgressType]:\n    \"\"\"Track progress by iterating over a sequence.\n\n    Args:\n        sequence (Iterable[ProgressType]): A sequence (must support \"len\") you wish to iterate over.\n        description (str, optional): Description of task show next to progress bar. Defaults to \"Working\".\n        total: (float, optional): Total number of steps. Default is len(sequence).\n        completed (int, optional): Number of steps completed so far. Defaults to 0.\n        auto_refresh (bool, optional): Automatic refresh, disable to force a refresh after each iteration. Default is True.\n        transient: (bool, optional): Clear the progress on exit. Defaults to False.\n        console (Console, optional): Console to write to. Default creates internal Console instance.\n        refresh_per_second (float): Number of times per second to refresh the progress information. Defaults to 10.\n        style (StyleType, optional): Style for the bar background. Defaults to \"bar.back\".\n        complete_style (StyleType, optional): Style for the completed bar. Defaults to \"bar.complete\".\n        finished_style (StyleType, optional): Style for a finished bar. Defaults to \"bar.finished\".\n        pulse_style (StyleType, optional): Style for pulsing bars. Defaults to \"bar.pulse\".\n        update_period (float, optional): Minimum time (in seconds) between calls to update(). Defaults to 0.1.\n        disable (bool, optional): Disable display of progress.\n        show_speed (bool, optional): Show speed if total isn't known. Defaults to True.\n    Returns:\n        Iterable[ProgressType]: An iterable of the values in the sequence.\n\n    \"\"\"\n\n    columns: List[\"ProgressColumn\"] = (\n        [TextColumn(\"[progress.description]{task.description}\")] if description else []\n    )\n    columns.extend(\n        (\n            BarColumn(\n                style=style,\n                complete_style=complete_style,\n                finished_style=finished_style,\n                pulse_style=pulse_style,\n            ),\n            TaskProgressColumn(show_speed=show_speed),\n            TimeRemainingColumn(elapsed_when_finished=True),\n        )\n    )\n    progress = Progress(\n        *columns,\n        auto_refresh=auto_refresh,\n        console=console,\n        transient=transient,\n        get_time=get_time,\n        refresh_per_second=refresh_per_second or 10,\n        disable=disable,\n    )\n\n    with progress:\n        yield from progress.track(\n            sequence,\n            total=total,\n            completed=completed,\n            description=description,\n            update_period=update_period,\n        )\n\n\nclass _Reader(RawIOBase, BinaryIO):\n    \"\"\"A reader that tracks progress while it's being read from.\"\"\"\n\n    def __init__(\n        self,\n        handle: BinaryIO,\n        progress: \"Progress\",\n        task: TaskID,\n        close_handle: bool = True,\n    ) -> None:\n        self.handle = handle\n        self.progress = progress\n        self.task = task\n        self.close_handle = close_handle\n        self._closed = False\n\n    def __enter__(self) -> \"_Reader\":\n        self.handle.__enter__()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        self.close()\n\n    def __iter__(self) -> BinaryIO:\n        return self\n\n    def __next__(self) -> bytes:\n        line = next(self.handle)\n        self.progress.advance(self.task, advance=len(line))\n        return line\n\n    @property\n    def closed(self) -> bool:\n        return self._closed\n\n    def fileno(self) -> int:\n        return self.handle.fileno()\n\n    def isatty(self) -> bool:\n        return self.handle.isatty()\n\n    @property\n    def mode(self) -> str:\n        return self.handle.mode\n\n    @property\n    def name(self) -> str:\n        return self.handle.name\n\n    def readable(self) -> bool:\n        return self.handle.readable()\n\n    def seekable(self) -> bool:\n        return self.handle.seekable()\n\n    def writable(self) -> bool:\n        return False\n\n    def read(self, size: int = -1) -> bytes:\n        block = self.handle.read(size)\n        self.progress.advance(self.task, advance=len(block))\n        return block\n\n    def readinto(self, b: Union[bytearray, memoryview, mmap]):  # type: ignore[no-untyped-def, override]\n        n = self.handle.readinto(b)  # type: ignore[attr-defined]\n        self.progress.advance(self.task, advance=n)\n        return n\n\n    def readline(self, size: int = -1) -> bytes:  # type: ignore[override]\n        line = self.handle.readline(size)\n        self.progress.advance(self.task, advance=len(line))\n        return line\n\n    def readlines(self, hint: int = -1) -> List[bytes]:\n        lines = self.handle.readlines(hint)\n        self.progress.advance(self.task, advance=sum(map(len, lines)))\n        return lines\n\n    def close(self) -> None:\n        if self.close_handle:\n            self.handle.close()\n        self._closed = True\n\n    def seek(self, offset: int, whence: int = 0) -> int:\n        pos = self.handle.seek(offset, whence)\n        self.progress.update(self.task, completed=pos)\n        return pos\n\n    def tell(self) -> int:\n        return self.handle.tell()\n\n    def write(self, s: Any) -> int:\n        raise UnsupportedOperation(\"write\")\n\n    def writelines(self, lines: Iterable[Any]) -> None:\n        raise UnsupportedOperation(\"writelines\")\n\n\nclass _ReadContext(ContextManager[_I], Generic[_I]):\n    \"\"\"A utility class to handle a context for both a reader and a progress.\"\"\"\n\n    def __init__(self, progress: \"Progress\", reader: _I) -> None:\n        self.progress = progress\n        self.reader: _I = reader\n\n    def __enter__(self) -> _I:\n        self.progress.start()\n        return self.reader.__enter__()\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        self.progress.stop()\n        self.reader.__exit__(exc_type, exc_val, exc_tb)\n\n\ndef wrap_file(\n    file: BinaryIO,\n    total: int,\n    *,\n    description: str = \"Reading...\",\n    auto_refresh: bool = True,\n    console: Optional[Console] = None,\n    transient: bool = False,\n    get_time: Optional[Callable[[], float]] = None,\n    refresh_per_second: float = 10,\n    style: StyleType = \"bar.back\",\n    complete_style: StyleType = \"bar.complete\",\n    finished_style: StyleType = \"bar.finished\",\n    pulse_style: StyleType = \"bar.pulse\",\n    disable: bool = False,\n) -> ContextManager[BinaryIO]:\n    \"\"\"Read bytes from a file while tracking progress.\n\n    Args:\n        file (Union[str, PathLike[str], BinaryIO]): The path to the file to read, or a file-like object in binary mode.\n        total (int): Total number of bytes to read.\n        description (str, optional): Description of task show next to progress bar. Defaults to \"Reading\".\n        auto_refresh (bool, optional): Automatic refresh, disable to force a refresh after each iteration. Default is True.\n        transient: (bool, optional): Clear the progress on exit. Defaults to False.\n        console (Console, optional): Console to write to. Default creates internal Console instance.\n        refresh_per_second (float): Number of times per second to refresh the progress information. Defaults to 10.\n        style (StyleType, optional): Style for the bar background. Defaults to \"bar.back\".\n        complete_style (StyleType, optional): Style for the completed bar. Defaults to \"bar.complete\".\n        finished_style (StyleType, optional): Style for a finished bar. Defaults to \"bar.finished\".\n        pulse_style (StyleType, optional): Style for pulsing bars. Defaults to \"bar.pulse\".\n        disable (bool, optional): Disable display of progress.\n    Returns:\n        ContextManager[BinaryIO]: A context manager yielding a progress reader.\n\n    \"\"\"\n\n    columns: List[\"ProgressColumn\"] = (\n        [TextColumn(\"[progress.description]{task.description}\")] if description else []\n    )\n    columns.extend(\n        (\n            BarColumn(\n                style=style,\n                complete_style=complete_style,\n                finished_style=finished_style,\n                pulse_style=pulse_style,\n            ),\n            DownloadColumn(),\n            TimeRemainingColumn(),\n        )\n    )\n    progress = Progress(\n        *columns,\n        auto_refresh=auto_refresh,\n        console=console,\n        transient=transient,\n        get_time=get_time,\n        refresh_per_second=refresh_per_second or 10,\n        disable=disable,\n    )\n\n    reader = progress.wrap_file(file, total=total, description=description)\n    return _ReadContext(progress, reader)\n\n\n@typing.overload\ndef open(\n    file: Union[str, \"PathLike[str]\", bytes],\n    mode: Union[Literal[\"rt\"], Literal[\"r\"]],\n    buffering: int = -1,\n    encoding: Optional[str] = None,\n    errors: Optional[str] = None,\n    newline: Optional[str] = None,\n    *,\n    total: Optional[int] = None,\n    description: str = \"Reading...\",\n    auto_refresh: bool = True,\n    console: Optional[Console] = None,\n    transient: bool = False,\n    get_time: Optional[Callable[[], float]] = None,\n    refresh_per_second: float = 10,\n    style: StyleType = \"bar.back\",\n    complete_style: StyleType = \"bar.complete\",\n    finished_style: StyleType = \"bar.finished\",\n    pulse_style: StyleType = \"bar.pulse\",\n    disable: bool = False,\n) -> ContextManager[TextIO]:\n    pass\n\n\n@typing.overload\ndef open(\n    file: Union[str, \"PathLike[str]\", bytes],\n    mode: Literal[\"rb\"],\n    buffering: int = -1,\n    encoding: Optional[str] = None,\n    errors: Optional[str] = None,\n    newline: Optional[str] = None,\n    *,\n    total: Optional[int] = None,\n    description: str = \"Reading...\",\n    auto_refresh: bool = True,\n    console: Optional[Console] = None,\n    transient: bool = False,\n    get_time: Optional[Callable[[], float]] = None,\n    refresh_per_second: float = 10,\n    style: StyleType = \"bar.back\",\n    complete_style: StyleType = \"bar.complete\",\n    finished_style: StyleType = \"bar.finished\",\n    pulse_style: StyleType = \"bar.pulse\",\n    disable: bool = False,\n) -> ContextManager[BinaryIO]:\n    pass\n\n\ndef open(\n    file: Union[str, \"PathLike[str]\", bytes],\n    mode: Union[Literal[\"rb\"], Literal[\"rt\"], Literal[\"r\"]] = \"r\",\n    buffering: int = -1,\n    encoding: Optional[str] = None,\n    errors: Optional[str] = None,\n    newline: Optional[str] = None,\n    *,\n    total: Optional[int] = None,\n    description: str = \"Reading...\",\n    auto_refresh: bool = True,\n    console: Optional[Console] = None,\n    transient: bool = False,\n    get_time: Optional[Callable[[], float]] = None,\n    refresh_per_second: float = 10,\n    style: StyleType = \"bar.back\",\n    complete_style: StyleType = \"bar.complete\",\n    finished_style: StyleType = \"bar.finished\",\n    pulse_style: StyleType = \"bar.pulse\",\n    disable: bool = False,\n) -> Union[ContextManager[BinaryIO], ContextManager[TextIO]]:\n    \"\"\"Read bytes from a file while tracking progress.\n\n    Args:\n        path (Union[str, PathLike[str], BinaryIO]): The path to the file to read, or a file-like object in binary mode.\n        mode (str): The mode to use to open the file. Only supports \"r\", \"rb\" or \"rt\".\n        buffering (int): The buffering strategy to use, see :func:`io.open`.\n        encoding (str, optional): The encoding to use when reading in text mode, see :func:`io.open`.\n        errors (str, optional): The error handling strategy for decoding errors, see :func:`io.open`.\n        newline (str, optional): The strategy for handling newlines in text mode, see :func:`io.open`\n        total: (int, optional): Total number of bytes to read. Must be provided if reading from a file handle. Default for a path is os.stat(file).st_size.\n        description (str, optional): Description of task show next to progress bar. Defaults to \"Reading\".\n        auto_refresh (bool, optional): Automatic refresh, disable to force a refresh after each iteration. Default is True.\n        transient: (bool, optional): Clear the progress on exit. Defaults to False.\n        console (Console, optional): Console to write to. Default creates internal Console instance.\n        refresh_per_second (float): Number of times per second to refresh the progress information. Defaults to 10.\n        style (StyleType, optional): Style for the bar background. Defaults to \"bar.back\".\n        complete_style (StyleType, optional): Style for the completed bar. Defaults to \"bar.complete\".\n        finished_style (StyleType, optional): Style for a finished bar. Defaults to \"bar.finished\".\n        pulse_style (StyleType, optional): Style for pulsing bars. Defaults to \"bar.pulse\".\n        disable (bool, optional): Disable display of progress.\n        encoding (str, optional): The encoding to use when reading in text mode.\n\n    Returns:\n        ContextManager[BinaryIO]: A context manager yielding a progress reader.\n\n    \"\"\"\n\n    columns: List[\"ProgressColumn\"] = (\n        [TextColumn(\"[progress.description]{task.description}\")] if description else []\n    )\n    columns.extend(\n        (\n            BarColumn(\n                style=style,\n                complete_style=complete_style,\n                finished_style=finished_style,\n                pulse_style=pulse_style,\n            ),\n            DownloadColumn(),\n            TimeRemainingColumn(),\n        )\n    )\n    progress = Progress(\n        *columns,\n        auto_refresh=auto_refresh,\n        console=console,\n        transient=transient,\n        get_time=get_time,\n        refresh_per_second=refresh_per_second or 10,\n        disable=disable,\n    )\n\n    reader = progress.open(\n        file,\n        mode=mode,\n        buffering=buffering,\n        encoding=encoding,\n        errors=errors,\n        newline=newline,\n        total=total,\n        description=description,\n    )\n    return _ReadContext(progress, reader)  # type: ignore[return-value, type-var]\n\n\nclass ProgressColumn(ABC):\n    \"\"\"Base class for a widget to use in progress display.\"\"\"\n\n    max_refresh: Optional[float] = None\n\n    def __init__(self, table_column: Optional[Column] = None) -> None:\n        self._table_column = table_column\n        self._renderable_cache: Dict[TaskID, Tuple[float, RenderableType]] = {}\n        self._update_time: Optional[float] = None\n\n    def get_table_column(self) -> Column:\n        \"\"\"Get a table column, used to build tasks table.\"\"\"\n        return self._table_column or Column()\n\n    def __call__(self, task: \"Task\") -> RenderableType:\n        \"\"\"Called by the Progress object to return a renderable for the given task.\n\n        Args:\n            task (Task): An object containing information regarding the task.\n\n        Returns:\n            RenderableType: Anything renderable (including str).\n        \"\"\"\n        current_time = task.get_time()\n        if self.max_refresh is not None and not task.completed:\n            try:\n                timestamp, renderable = self._renderable_cache[task.id]\n            except KeyError:\n                pass\n            else:\n                if timestamp + self.max_refresh > current_time:\n                    return renderable\n\n        renderable = self.render(task)\n        self._renderable_cache[task.id] = (current_time, renderable)\n        return renderable\n\n    @abstractmethod\n    def render(self, task: \"Task\") -> RenderableType:\n        \"\"\"Should return a renderable object.\"\"\"\n\n\nclass RenderableColumn(ProgressColumn):\n    \"\"\"A column to insert an arbitrary column.\n\n    Args:\n        renderable (RenderableType, optional): Any renderable. Defaults to empty string.\n    \"\"\"\n\n    def __init__(\n        self, renderable: RenderableType = \"\", *, table_column: Optional[Column] = None\n    ):\n        self.renderable = renderable\n        super().__init__(table_column=table_column)\n\n    def render(self, task: \"Task\") -> RenderableType:\n        return self.renderable\n\n\nclass SpinnerColumn(ProgressColumn):\n    \"\"\"A column with a 'spinner' animation.\n\n    Args:\n        spinner_name (str, optional): Name of spinner animation. Defaults to \"dots\".\n        style (StyleType, optional): Style of spinner. Defaults to \"progress.spinner\".\n        speed (float, optional): Speed factor of spinner. Defaults to 1.0.\n        finished_text (TextType, optional): Text used when task is finished. Defaults to \" \".\n    \"\"\"\n\n    def __init__(\n        self,\n        spinner_name: str = \"dots\",\n        style: Optional[StyleType] = \"progress.spinner\",\n        speed: float = 1.0,\n        finished_text: TextType = \" \",\n        table_column: Optional[Column] = None,\n    ):\n        self.spinner = Spinner(spinner_name, style=style, speed=speed)\n        self.finished_text = (\n            Text.from_markup(finished_text)\n            if isinstance(finished_text, str)\n            else finished_text\n        )\n        super().__init__(table_column=table_column)\n\n    def set_spinner(\n        self,\n        spinner_name: str,\n        spinner_style: Optional[StyleType] = \"progress.spinner\",\n        speed: float = 1.0,\n    ) -> None:\n        \"\"\"Set a new spinner.\n\n        Args:\n            spinner_name (str): Spinner name, see python -m rich.spinner.\n            spinner_style (Optional[StyleType], optional): Spinner style. Defaults to \"progress.spinner\".\n            speed (float, optional): Speed factor of spinner. Defaults to 1.0.\n        \"\"\"\n        self.spinner = Spinner(spinner_name, style=spinner_style, speed=speed)\n\n    def render(self, task: \"Task\") -> RenderableType:\n        text = (\n            self.finished_text\n            if task.finished\n            else self.spinner.render(task.get_time())\n        )\n        return text\n\n\nclass TextColumn(ProgressColumn):\n    \"\"\"A column containing text.\"\"\"\n\n    def __init__(\n        self,\n        text_format: str,\n        style: StyleType = \"none\",\n        justify: JustifyMethod = \"left\",\n        markup: bool = True,\n        highlighter: Optional[Highlighter] = None,\n        table_column: Optional[Column] = None,\n    ) -> None:\n        self.text_format = text_format\n        self.justify: JustifyMethod = justify\n        self.style = style\n        self.markup = markup\n        self.highlighter = highlighter\n        super().__init__(table_column=table_column or Column(no_wrap=True))\n\n    def render(self, task: \"Task\") -> Text:\n        _text = self.text_format.format(task=task)\n        if self.markup:\n            text = Text.from_markup(_text, style=self.style, justify=self.justify)\n        else:\n            text = Text(_text, style=self.style, justify=self.justify)\n        if self.highlighter:\n            self.highlighter.highlight(text)\n        return text\n\n\nclass BarColumn(ProgressColumn):\n    \"\"\"Renders a visual progress bar.\n\n    Args:\n        bar_width (Optional[int], optional): Width of bar or None for full width. Defaults to 40.\n        style (StyleType, optional): Style for the bar background. Defaults to \"bar.back\".\n        complete_style (StyleType, optional): Style for the completed bar. Defaults to \"bar.complete\".\n        finished_style (StyleType, optional): Style for a finished bar. Defaults to \"bar.finished\".\n        pulse_style (StyleType, optional): Style for pulsing bars. Defaults to \"bar.pulse\".\n    \"\"\"\n\n    def __init__(\n        self,\n        bar_width: Optional[int] = 40,\n        style: StyleType = \"bar.back\",\n        complete_style: StyleType = \"bar.complete\",\n        finished_style: StyleType = \"bar.finished\",\n        pulse_style: StyleType = \"bar.pulse\",\n        table_column: Optional[Column] = None,\n    ) -> None:\n        self.bar_width = bar_width\n        self.style = style\n        self.complete_style = complete_style\n        self.finished_style = finished_style\n        self.pulse_style = pulse_style\n        super().__init__(table_column=table_column)\n\n    def render(self, task: \"Task\") -> ProgressBar:\n        \"\"\"Gets a progress bar widget for a task.\"\"\"\n        return ProgressBar(\n            total=max(0, task.total) if task.total is not None else None,\n            completed=max(0, task.completed),\n            width=None if self.bar_width is None else max(1, self.bar_width),\n            pulse=not task.started,\n            animation_time=task.get_time(),\n            style=self.style,\n            complete_style=self.complete_style,\n            finished_style=self.finished_style,\n            pulse_style=self.pulse_style,\n        )\n\n\nclass TimeElapsedColumn(ProgressColumn):\n    \"\"\"Renders time elapsed.\"\"\"\n\n    def render(self, task: \"Task\") -> Text:\n        \"\"\"Show time elapsed.\"\"\"\n        elapsed = task.finished_time if task.finished else task.elapsed\n        if elapsed is None:\n            return Text(\"-:--:--\", style=\"progress.elapsed\")\n        delta = timedelta(seconds=max(0, int(elapsed)))\n        return Text(str(delta), style=\"progress.elapsed\")\n\n\nclass TaskProgressColumn(TextColumn):\n    \"\"\"Show task progress as a percentage.\n\n    Args:\n        text_format (str, optional): Format for percentage display. Defaults to \"[progress.percentage]{task.percentage:>3.0f}%\".\n        text_format_no_percentage (str, optional): Format if percentage is unknown. Defaults to \"\".\n        style (StyleType, optional): Style of output. Defaults to \"none\".\n        justify (JustifyMethod, optional): Text justification. Defaults to \"left\".\n        markup (bool, optional): Enable markup. Defaults to True.\n        highlighter (Optional[Highlighter], optional): Highlighter to apply to output. Defaults to None.\n        table_column (Optional[Column], optional): Table Column to use. Defaults to None.\n        show_speed (bool, optional): Show speed if total is unknown. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        text_format: str = \"[progress.percentage]{task.percentage:>3.0f}%\",\n        text_format_no_percentage: str = \"\",\n        style: StyleType = \"none\",\n        justify: JustifyMethod = \"left\",\n        markup: bool = True,\n        highlighter: Optional[Highlighter] = None,\n        table_column: Optional[Column] = None,\n        show_speed: bool = False,\n    ) -> None:\n        self.text_format_no_percentage = text_format_no_percentage\n        self.show_speed = show_speed\n        super().__init__(\n            text_format=text_format,\n            style=style,\n            justify=justify,\n            markup=markup,\n            highlighter=highlighter,\n            table_column=table_column,\n        )\n\n    @classmethod\n    def render_speed(cls, speed: Optional[float]) -> Text:\n        \"\"\"Render the speed in iterations per second.\n\n        Args:\n            task (Task): A Task object.\n\n        Returns:\n            Text: Text object containing the task speed.\n        \"\"\"\n        if speed is None:\n            return Text(\"\", style=\"progress.percentage\")\n        unit, suffix = filesize.pick_unit_and_suffix(\n            int(speed),\n            [\"\", \"Ã—10Â³\", \"Ã—10â¶\", \"Ã—10â¹\", \"Ã—10Â¹Â²\"],\n            1000,\n        )\n        data_speed = speed / unit\n        return Text(f\"{data_speed:.1f}{suffix} it/s\", style=\"progress.percentage\")\n\n    def render(self, task: \"Task\") -> Text:\n        if task.total is None and self.show_speed:\n            return self.render_speed(task.finished_speed or task.speed)\n        text_format = (\n            self.text_format_no_percentage if task.total is None else self.text_format\n        )\n        _text = text_format.format(task=task)\n        if self.markup:\n            text = Text.from_markup(_text, style=self.style, justify=self.justify)\n        else:\n            text = Text(_text, style=self.style, justify=self.justify)\n        if self.highlighter:\n            self.highlighter.highlight(text)\n        return text\n\n\nclass TimeRemainingColumn(ProgressColumn):\n    \"\"\"Renders estimated time remaining.\n\n    Args:\n        compact (bool, optional): Render MM:SS when time remaining is less than an hour. Defaults to False.\n        elapsed_when_finished (bool, optional): Render time elapsed when the task is finished. Defaults to False.\n    \"\"\"\n\n    # Only refresh twice a second to prevent jitter\n    max_refresh = 0.5\n\n    def __init__(\n        self,\n        compact: bool = False,\n        elapsed_when_finished: bool = False,\n        table_column: Optional[Column] = None,\n    ):\n        self.compact = compact\n        self.elapsed_when_finished = elapsed_when_finished\n        super().__init__(table_column=table_column)\n\n    def render(self, task: \"Task\") -> Text:\n        \"\"\"Show time remaining.\"\"\"\n        if self.elapsed_when_finished and task.finished:\n            task_time = task.finished_time\n            style = \"progress.elapsed\"\n        else:\n            task_time = task.time_remaining\n            style = \"progress.remaining\"\n\n        if task.total is None:\n            return Text(\"\", style=style)\n\n        if task_time is None:\n            return Text(\"--:--\" if self.compact else \"-:--:--\", style=style)\n\n        # Based on https://github.com/tqdm/tqdm/blob/master/tqdm/std.py\n        minutes, seconds = divmod(int(task_time), 60)\n        hours, minutes = divmod(minutes, 60)\n\n        if self.compact and not hours:\n            formatted = f\"{minutes:02d}:{seconds:02d}\"\n        else:\n            formatted = f\"{hours:d}:{minutes:02d}:{seconds:02d}\"\n\n        return Text(formatted, style=style)\n\n\nclass FileSizeColumn(ProgressColumn):\n    \"\"\"Renders completed filesize.\"\"\"\n\n    def render(self, task: \"Task\") -> Text:\n        \"\"\"Show data completed.\"\"\"\n        data_size = filesize.decimal(int(task.completed))\n        return Text(data_size, style=\"progress.filesize\")\n\n\nclass TotalFileSizeColumn(ProgressColumn):\n    \"\"\"Renders total filesize.\"\"\"\n\n    def render(self, task: \"Task\") -> Text:\n        \"\"\"Show data completed.\"\"\"\n        data_size = filesize.decimal(int(task.total)) if task.total is not None else \"\"\n        return Text(data_size, style=\"progress.filesize.total\")\n\n\nclass MofNCompleteColumn(ProgressColumn):\n    \"\"\"Renders completed count/total, e.g. '  10/1000'.\n\n    Best for bounded tasks with int quantities.\n\n    Space pads the completed count so that progress length does not change as task progresses\n    past powers of 10.\n\n    Args:\n        separator (str, optional): Text to separate completed and total values. Defaults to \"/\".\n    \"\"\"\n\n    def __init__(self, separator: str = \"/\", table_column: Optional[Column] = None):\n        self.separator = separator\n        super().__init__(table_column=table_column)\n\n    def render(self, task: \"Task\") -> Text:\n        \"\"\"Show completed/total.\"\"\"\n        completed = int(task.completed)\n        total = int(task.total) if task.total is not None else \"?\"\n        total_width = len(str(total))\n        return Text(\n            f\"{completed:{total_width}d}{self.separator}{total}\",\n            style=\"progress.download\",\n        )\n\n\nclass DownloadColumn(ProgressColumn):\n    \"\"\"Renders file size downloaded and total, e.g. '0.5/2.3 GB'.\n\n    Args:\n        binary_units (bool, optional): Use binary units, KiB, MiB etc. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self, binary_units: bool = False, table_column: Optional[Column] = None\n    ) -> None:\n        self.binary_units = binary_units\n        super().__init__(table_column=table_column)\n\n    def render(self, task: \"Task\") -> Text:\n        \"\"\"Calculate common unit for completed and total.\"\"\"\n        completed = int(task.completed)\n\n        unit_and_suffix_calculation_base = (\n            int(task.total) if task.total is not None else completed\n        )\n        if self.binary_units:\n            unit, suffix = filesize.pick_unit_and_suffix(\n                unit_and_suffix_calculation_base,\n                [\"bytes\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"ZiB\", \"YiB\"],\n                1024,\n            )\n        else:\n            unit, suffix = filesize.pick_unit_and_suffix(\n                unit_and_suffix_calculation_base,\n                [\"bytes\", \"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"],\n                1000,\n            )\n        precision = 0 if unit == 1 else 1\n\n        completed_ratio = completed / unit\n        completed_str = f\"{completed_ratio:,.{precision}f}\"\n\n        if task.total is not None:\n            total = int(task.total)\n            total_ratio = total / unit\n            total_str = f\"{total_ratio:,.{precision}f}\"\n        else:\n            total_str = \"?\"\n\n        download_status = f\"{completed_str}/{total_str} {suffix}\"\n        download_text = Text(download_status, style=\"progress.download\")\n        return download_text\n\n\nclass TransferSpeedColumn(ProgressColumn):\n    \"\"\"Renders human readable transfer speed.\"\"\"\n\n    def render(self, task: \"Task\") -> Text:\n        \"\"\"Show data transfer speed.\"\"\"\n        speed = task.finished_speed or task.speed\n        if speed is None:\n            return Text(\"?\", style=\"progress.data.speed\")\n        data_speed = filesize.decimal(int(speed))\n        return Text(f\"{data_speed}/s\", style=\"progress.data.speed\")\n\n\nclass ProgressSample(NamedTuple):\n    \"\"\"Sample of progress for a given time.\"\"\"\n\n    timestamp: float\n    \"\"\"Timestamp of sample.\"\"\"\n    completed: float\n    \"\"\"Number of steps completed.\"\"\"\n\n\n@dataclass\nclass Task:\n    \"\"\"Information regarding a progress task.\n\n    This object should be considered read-only outside of the :class:`~Progress` class.\n\n    \"\"\"\n\n    id: TaskID\n    \"\"\"Task ID associated with this task (used in Progress methods).\"\"\"\n\n    description: str\n    \"\"\"str: Description of the task.\"\"\"\n\n    total: Optional[float]\n    \"\"\"Optional[float]: Total number of steps in this task.\"\"\"\n\n    completed: float\n    \"\"\"float: Number of steps completed\"\"\"\n\n    _get_time: GetTimeCallable\n    \"\"\"Callable to get the current time.\"\"\"\n\n    finished_time: Optional[float] = None\n    \"\"\"float: Time task was finished.\"\"\"\n\n    visible: bool = True\n    \"\"\"bool: Indicates if this task is visible in the progress display.\"\"\"\n\n    fields: Dict[str, Any] = field(default_factory=dict)\n    \"\"\"dict: Arbitrary fields passed in via Progress.update.\"\"\"\n\n    start_time: Optional[float] = field(default=None, init=False, repr=False)\n    \"\"\"Optional[float]: Time this task was started, or None if not started.\"\"\"\n\n    stop_time: Optional[float] = field(default=None, init=False, repr=False)\n    \"\"\"Optional[float]: Time this task was stopped, or None if not stopped.\"\"\"\n\n    finished_speed: Optional[float] = None\n    \"\"\"Optional[float]: The last speed for a finished task.\"\"\"\n\n    _progress: Deque[ProgressSample] = field(\n        default_factory=lambda: deque(maxlen=1000), init=False, repr=False\n    )\n\n    _lock: RLock = field(repr=False, default_factory=RLock)\n    \"\"\"Thread lock.\"\"\"\n\n    def get_time(self) -> float:\n        \"\"\"float: Get the current time, in seconds.\"\"\"\n        return self._get_time()\n\n    @property\n    def started(self) -> bool:\n        \"\"\"bool: Check if the task as started.\"\"\"\n        return self.start_time is not None\n\n    @property\n    def remaining(self) -> Optional[float]:\n        \"\"\"Optional[float]: Get the number of steps remaining, if a non-None total was set.\"\"\"\n        if self.total is None:\n            return None\n        return self.total - self.completed\n\n    @property\n    def elapsed(self) -> Optional[float]:\n        \"\"\"Optional[float]: Time elapsed since task was started, or ``None`` if the task hasn't started.\"\"\"\n        if self.start_time is None:\n            return None\n        if self.stop_time is not None:\n            return self.stop_time - self.start_time\n        return self.get_time() - self.start_time\n\n    @property\n    def finished(self) -> bool:\n        \"\"\"Check if the task has finished.\"\"\"\n        return self.finished_time is not None\n\n    @property\n    def percentage(self) -> float:\n        \"\"\"float: Get progress of task as a percentage. If a None total was set, returns 0\"\"\"\n        if not self.total:\n            return 0.0\n        completed = (self.completed / self.total) * 100.0\n        completed = min(100.0, max(0.0, completed))\n        return completed\n\n    @property\n    def speed(self) -> Optional[float]:\n        \"\"\"Optional[float]: Get the estimated speed in steps per second.\"\"\"\n        if self.start_time is None:\n            return None\n        with self._lock:\n            progress = self._progress\n            if not progress:\n                return None\n            total_time = progress[-1].timestamp - progress[0].timestamp\n            if total_time == 0:\n                return None\n            iter_progress = iter(progress)\n            next(iter_progress)\n            total_completed = sum(sample.completed for sample in iter_progress)\n            speed = total_completed / total_time\n            return speed\n\n    @property\n    def time_remaining(self) -> Optional[float]:\n        \"\"\"Optional[float]: Get estimated time to completion, or ``None`` if no data.\"\"\"\n        if self.finished:\n            return 0.0\n        speed = self.speed\n        if not speed:\n            return None\n        remaining = self.remaining\n        if remaining is None:\n            return None\n        estimate = ceil(remaining / speed)\n        return estimate\n\n    def _reset(self) -> None:\n        \"\"\"Reset progress.\"\"\"\n        self._progress.clear()\n        self.finished_time = None\n        self.finished_speed = None\n\n\nclass Progress(JupyterMixin):\n    \"\"\"Renders an auto-updating progress bar(s).\n\n    Args:\n        console (Console, optional): Optional Console instance. Defaults to an internal Console instance writing to stdout.\n        auto_refresh (bool, optional): Enable auto refresh. If disabled, you will need to call `refresh()`.\n        refresh_per_second (Optional[float], optional): Number of times per second to refresh the progress information or None to use default (10). Defaults to None.\n        speed_estimate_period: (float, optional): Period (in seconds) used to calculate the speed estimate. Defaults to 30.\n        transient: (bool, optional): Clear the progress on exit. Defaults to False.\n        redirect_stdout: (bool, optional): Enable redirection of stdout, so ``print`` may be used. Defaults to True.\n        redirect_stderr: (bool, optional): Enable redirection of stderr. Defaults to True.\n        get_time: (Callable, optional): A callable that gets the current time, or None to use Console.get_time. Defaults to None.\n        disable (bool, optional): Disable progress display. Defaults to False\n        expand (bool, optional): Expand tasks table to fit width. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        *columns: Union[str, ProgressColumn],\n        console: Optional[Console] = None,\n        auto_refresh: bool = True,\n        refresh_per_second: float = 10,\n        speed_estimate_period: float = 30.0,\n        transient: bool = False,\n        redirect_stdout: bool = True,\n        redirect_stderr: bool = True,\n        get_time: Optional[GetTimeCallable] = None,\n        disable: bool = False,\n        expand: bool = False,\n    ) -> None:\n        assert refresh_per_second > 0, \"refresh_per_second must be > 0\"\n        self._lock = RLock()\n        self.columns = columns or self.get_default_columns()\n        self.speed_estimate_period = speed_estimate_period\n\n        self.disable = disable\n        self.expand = expand\n        self._tasks: Dict[TaskID, Task] = {}\n        self._task_index: TaskID = TaskID(0)\n        self.live = Live(\n            console=console or get_console(),\n            auto_refresh=auto_refresh,\n            refresh_per_second=refresh_per_second,\n            transient=transient,\n            redirect_stdout=redirect_stdout,\n            redirect_stderr=redirect_stderr,\n            get_renderable=self.get_renderable,\n        )\n        self.get_time = get_time or self.console.get_time\n        self.print = self.console.print\n        self.log = self.console.log\n\n    @classmethod\n    def get_default_columns(cls) -> Tuple[ProgressColumn, ...]:\n        \"\"\"Get the default columns used for a new Progress instance:\n           - a text column for the description (TextColumn)\n           - the bar itself (BarColumn)\n           - a text column showing completion percentage (TextColumn)\n           - an estimated-time-remaining column (TimeRemainingColumn)\n        If the Progress instance is created without passing a columns argument,\n        the default columns defined here will be used.\n\n        You can also create a Progress instance using custom columns before\n        and/or after the defaults, as in this example:\n\n            progress = Progress(\n                SpinnerColumn(),\n                *Progress.get_default_columns(),\n                \"Elapsed:\",\n                TimeElapsedColumn(),\n            )\n\n        This code shows the creation of a Progress display, containing\n        a spinner to the left, the default columns, and a labeled elapsed\n        time column.\n        \"\"\"\n        return (\n            TextColumn(\"[progress.description]{task.description}\"),\n            BarColumn(),\n            TaskProgressColumn(),\n            TimeRemainingColumn(),\n        )\n\n    @property\n    def console(self) -> Console:\n        return self.live.console\n\n    @property\n    def tasks(self) -> List[Task]:\n        \"\"\"Get a list of Task instances.\"\"\"\n        with self._lock:\n            return list(self._tasks.values())\n\n    @property\n    def task_ids(self) -> List[TaskID]:\n        \"\"\"A list of task IDs.\"\"\"\n        with self._lock:\n            return list(self._tasks.keys())\n\n    @property\n    def finished(self) -> bool:\n        \"\"\"Check if all tasks have been completed.\"\"\"\n        with self._lock:\n            if not self._tasks:\n                return True\n            return all(task.finished for task in self._tasks.values())\n\n    def start(self) -> None:\n        \"\"\"Start the progress display.\"\"\"\n        if not self.disable:\n            self.live.start(refresh=True)\n\n    def stop(self) -> None:\n        \"\"\"Stop the progress display.\"\"\"\n        self.live.stop()\n        if not self.console.is_interactive and not self.console.is_jupyter:\n            self.console.print()\n\n    def __enter__(self) -> Self:\n        self.start()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        self.stop()\n\n    def track(\n        self,\n        sequence: Union[Iterable[ProgressType], Sequence[ProgressType]],\n        total: Optional[float] = None,\n        completed: int = 0,\n        task_id: Optional[TaskID] = None,\n        description: str = \"Working...\",\n        update_period: float = 0.1,\n    ) -> Iterable[ProgressType]:\n        \"\"\"Track progress by iterating over a sequence.\n\n        Args:\n            sequence (Sequence[ProgressType]): A sequence of values you want to iterate over and track progress.\n            total: (float, optional): Total number of steps. Default is len(sequence).\n            completed (int, optional): Number of steps completed so far. Defaults to 0.\n            task_id: (TaskID): Task to track. Default is new task.\n            description: (str, optional): Description of task, if new task is created.\n            update_period (float, optional): Minimum time (in seconds) between calls to update(). Defaults to 0.1.\n\n        Returns:\n            Iterable[ProgressType]: An iterable of values taken from the provided sequence.\n        \"\"\"\n        if total is None:\n            total = float(length_hint(sequence)) or None\n\n        if task_id is None:\n            task_id = self.add_task(description, total=total, completed=completed)\n        else:\n            self.update(task_id, total=total, completed=completed)\n\n        if self.live.auto_refresh:\n            with _TrackThread(self, task_id, update_period) as track_thread:\n                for value in sequence:\n                    yield value\n                    track_thread.completed += 1\n        else:\n            advance = self.advance\n            refresh = self.refresh\n            for value in sequence:\n                yield value\n                advance(task_id, 1)\n                refresh()\n\n    def wrap_file(\n        self,\n        file: BinaryIO,\n        total: Optional[int] = None,\n        *,\n        task_id: Optional[TaskID] = None,\n        description: str = \"Reading...\",\n    ) -> BinaryIO:\n        \"\"\"Track progress file reading from a binary file.\n\n        Args:\n            file (BinaryIO): A file-like object opened in binary mode.\n            total (int, optional): Total number of bytes to read. This must be provided unless a task with a total is also given.\n            task_id (TaskID): Task to track. Default is new task.\n            description (str, optional): Description of task, if new task is created.\n\n        Returns:\n            BinaryIO: A readable file-like object in binary mode.\n\n        Raises:\n            ValueError: When no total value can be extracted from the arguments or the task.\n        \"\"\"\n        # attempt to recover the total from the task\n        total_bytes: Optional[float] = None\n        if total is not None:\n            total_bytes = total\n        elif task_id is not None:\n            with self._lock:\n                total_bytes = self._tasks[task_id].total\n        if total_bytes is None:\n            raise ValueError(\n                f\"unable to get the total number of bytes, please specify 'total'\"\n            )\n\n        # update total of task or create new task\n        if task_id is None:\n            task_id = self.add_task(description, total=total_bytes)\n        else:\n            self.update(task_id, total=total_bytes)\n\n        return _Reader(file, self, task_id, close_handle=False)\n\n    @typing.overload\n    def open(\n        self,\n        file: Union[str, \"PathLike[str]\", bytes],\n        mode: Literal[\"rb\"],\n        buffering: int = -1,\n        encoding: Optional[str] = None,\n        errors: Optional[str] = None,\n        newline: Optional[str] = None,\n        *,\n        total: Optional[int] = None,\n        task_id: Optional[TaskID] = None,\n        description: str = \"Reading...\",\n    ) -> BinaryIO:\n        pass\n\n    @typing.overload\n    def open(\n        self,\n        file: Union[str, \"PathLike[str]\", bytes],\n        mode: Union[Literal[\"r\"], Literal[\"rt\"]],\n        buffering: int = -1,\n        encoding: Optional[str] = None,\n        errors: Optional[str] = None,\n        newline: Optional[str] = None,\n        *,\n        total: Optional[int] = None,\n        task_id: Optional[TaskID] = None,\n        description: str = \"Reading...\",\n    ) -> TextIO:\n        pass\n\n    def open(\n        self,\n        file: Union[str, \"PathLike[str]\", bytes],\n        mode: Union[Literal[\"rb\"], Literal[\"rt\"], Literal[\"r\"]] = \"r\",\n        buffering: int = -1,\n        encoding: Optional[str] = None,\n        errors: Optional[str] = None,\n        newline: Optional[str] = None,\n        *,\n        total: Optional[int] = None,\n        task_id: Optional[TaskID] = None,\n        description: str = \"Reading...\",\n    ) -> Union[BinaryIO, TextIO]:\n        \"\"\"Track progress while reading from a binary file.\n\n        Args:\n            path (Union[str, PathLike[str]]): The path to the file to read.\n            mode (str): The mode to use to open the file. Only supports \"r\", \"rb\" or \"rt\".\n            buffering (int): The buffering strategy to use, see :func:`io.open`.\n            encoding (str, optional): The encoding to use when reading in text mode, see :func:`io.open`.\n            errors (str, optional): The error handling strategy for decoding errors, see :func:`io.open`.\n            newline (str, optional): The strategy for handling newlines in text mode, see :func:`io.open`.\n            total (int, optional): Total number of bytes to read. If none given, os.stat(path).st_size is used.\n            task_id (TaskID): Task to track. Default is new task.\n            description (str, optional): Description of task, if new task is created.\n\n        Returns:\n            BinaryIO: A readable file-like object in binary mode.\n\n        Raises:\n            ValueError: When an invalid mode is given.\n        \"\"\"\n        # normalize the mode (always rb, rt)\n        _mode = \"\".join(sorted(mode, reverse=False))\n        if _mode not in (\"br\", \"rt\", \"r\"):\n            raise ValueError(f\"invalid mode {mode!r}\")\n\n        # patch buffering to provide the same behaviour as the builtin `open`\n        line_buffering = buffering == 1\n        if _mode == \"br\" and buffering == 1:\n            warnings.warn(\n                \"line buffering (buffering=1) isn't supported in binary mode, the default buffer size will be used\",\n                RuntimeWarning,\n            )\n            buffering = -1\n        elif _mode in (\"rt\", \"r\"):\n            if buffering == 0:\n                raise ValueError(\"can't have unbuffered text I/O\")\n            elif buffering == 1:\n                buffering = -1\n\n        # attempt to get the total with `os.stat`\n        if total is None:\n            total = stat(file).st_size\n\n        # update total of task or create new task\n        if task_id is None:\n            task_id = self.add_task(description, total=total)\n        else:\n            self.update(task_id, total=total)\n\n        # open the file in binary mode,\n        handle = io.open(file, \"rb\", buffering=buffering)\n        reader = _Reader(handle, self, task_id, close_handle=True)\n\n        # wrap the reader in a `TextIOWrapper` if text mode\n        if mode in (\"r\", \"rt\"):\n            return io.TextIOWrapper(\n                reader,\n                encoding=encoding,\n                errors=errors,\n                newline=newline,\n                line_buffering=line_buffering,\n            )\n\n        return reader\n\n    def start_task(self, task_id: TaskID) -> None:\n        \"\"\"Start a task.\n\n        Starts a task (used when calculating elapsed time). You may need to call this manually,\n        if you called ``add_task`` with ``start=False``.\n\n        Args:\n            task_id (TaskID): ID of task.\n        \"\"\"\n        with self._lock:\n            task = self._tasks[task_id]\n            if task.start_time is None:\n                task.start_time = self.get_time()\n\n    def stop_task(self, task_id: TaskID) -> None:\n        \"\"\"Stop a task.\n\n        This will freeze the elapsed time on the task.\n\n        Args:\n            task_id (TaskID): ID of task.\n        \"\"\"\n        with self._lock:\n            task = self._tasks[task_id]\n            current_time = self.get_time()\n            if task.start_time is None:\n                task.start_time = current_time\n            task.stop_time = current_time\n\n    def update(\n        self,\n        task_id: TaskID,\n        *,\n        total: Optional[float] = None,\n        completed: Optional[float] = None,\n        advance: Optional[float] = None,\n        description: Optional[str] = None,\n        visible: Optional[bool] = None,\n        refresh: bool = False,\n        **fields: Any,\n    ) -> None:\n        \"\"\"Update information associated with a task.\n\n        Args:\n            task_id (TaskID): Task id (returned by add_task).\n            total (float, optional): Updates task.total if not None.\n            completed (float, optional): Updates task.completed if not None.\n            advance (float, optional): Add a value to task.completed if not None.\n            description (str, optional): Change task description if not None.\n            visible (bool, optional): Set visible flag if not None.\n            refresh (bool): Force a refresh of progress information. Default is False.\n            **fields (Any): Additional data fields required for rendering.\n        \"\"\"\n        with self._lock:\n            task = self._tasks[task_id]\n            completed_start = task.completed\n\n            if total is not None and total != task.total:\n                task.total = total\n                task._reset()\n            if advance is not None:\n                task.completed += advance\n            if completed is not None:\n                task.completed = completed\n            if description is not None:\n                task.description = description\n            if visible is not None:\n                task.visible = visible\n            task.fields.update(fields)\n            update_completed = task.completed - completed_start\n\n            current_time = self.get_time()\n            old_sample_time = current_time - self.speed_estimate_period\n            _progress = task._progress\n\n            popleft = _progress.popleft\n            while _progress and _progress[0].timestamp < old_sample_time:\n                popleft()\n            if update_completed > 0:\n                _progress.append(ProgressSample(current_time, update_completed))\n            if (\n                task.total is not None\n                and task.completed >= task.total\n                and task.finished_time is None\n            ):\n                task.finished_time = task.elapsed\n\n        if refresh:\n            self.refresh()\n\n    def reset(\n        self,\n        task_id: TaskID,\n        *,\n        start: bool = True,\n        total: Optional[float] = None,\n        completed: int = 0,\n        visible: Optional[bool] = None,\n        description: Optional[str] = None,\n        **fields: Any,\n    ) -> None:\n        \"\"\"Reset a task so completed is 0 and the clock is reset.\n\n        Args:\n            task_id (TaskID): ID of task.\n            start (bool, optional): Start the task after reset. Defaults to True.\n            total (float, optional): New total steps in task, or None to use current total. Defaults to None.\n            completed (int, optional): Number of steps completed. Defaults to 0.\n            visible (bool, optional): Enable display of the task. Defaults to True.\n            description (str, optional): Change task description if not None. Defaults to None.\n            **fields (str): Additional data fields required for rendering.\n        \"\"\"\n        current_time = self.get_time()\n        with self._lock:\n            task = self._tasks[task_id]\n            task._reset()\n            task.start_time = current_time if start else None\n            if total is not None:\n                task.total = total\n            task.completed = completed\n            if visible is not None:\n                task.visible = visible\n            if fields:\n                task.fields = fields\n            if description is not None:\n                task.description = description\n            task.finished_time = None\n        self.refresh()\n\n    def advance(self, task_id: TaskID, advance: float = 1) -> None:\n        \"\"\"Advance task by a number of steps.\n\n        Args:\n            task_id (TaskID): ID of task.\n            advance (float): Number of steps to advance. Default is 1.\n        \"\"\"\n        current_time = self.get_time()\n        with self._lock:\n            task = self._tasks[task_id]\n            completed_start = task.completed\n            task.completed += advance\n            update_completed = task.completed - completed_start\n            old_sample_time = current_time - self.speed_estimate_period\n            _progress = task._progress\n\n            popleft = _progress.popleft\n            while _progress and _progress[0].timestamp < old_sample_time:\n                popleft()\n            while len(_progress) > 1000:\n                popleft()\n            _progress.append(ProgressSample(current_time, update_completed))\n            if (\n                task.total is not None\n                and task.completed >= task.total\n                and task.finished_time is None\n            ):\n                task.finished_time = task.elapsed\n                task.finished_speed = task.speed\n\n    def refresh(self) -> None:\n        \"\"\"Refresh (render) the progress information.\"\"\"\n        if not self.disable and self.live.is_started:\n            self.live.refresh()\n\n    def get_renderable(self) -> RenderableType:\n        \"\"\"Get a renderable for the progress display.\"\"\"\n        renderable = Group(*self.get_renderables())\n        return renderable\n\n    def get_renderables(self) -> Iterable[RenderableType]:\n        \"\"\"Get a number of renderables for the progress display.\"\"\"\n        table = self.make_tasks_table(self.tasks)\n        yield table\n\n    def make_tasks_table(self, tasks: Iterable[Task]) -> Table:\n        \"\"\"Get a table to render the Progress display.\n\n        Args:\n            tasks (Iterable[Task]): An iterable of Task instances, one per row of the table.\n\n        Returns:\n            Table: A table instance.\n        \"\"\"\n        table_columns = (\n            (\n                Column(no_wrap=True)\n                if isinstance(_column, str)\n                else _column.get_table_column().copy()\n            )\n            for _column in self.columns\n        )\n        table = Table.grid(*table_columns, padding=(0, 1), expand=self.expand)\n\n        for task in tasks:\n            if task.visible:\n                table.add_row(\n                    *(\n                        (\n                            column.format(task=task)\n                            if isinstance(column, str)\n                            else column(task)\n                        )\n                        for column in self.columns\n                    )\n                )\n        return table\n\n    def __rich__(self) -> RenderableType:\n        \"\"\"Makes the Progress class itself renderable.\"\"\"\n        with self._lock:\n            return self.get_renderable()\n\n    def add_task(\n        self,\n        description: str,\n        start: bool = True,\n        total: Optional[float] = 100.0,\n        completed: int = 0,\n        visible: bool = True,\n        **fields: Any,\n    ) -> TaskID:\n        \"\"\"Add a new 'task' to the Progress display.\n\n        Args:\n            description (str): A description of the task.\n            start (bool, optional): Start the task immediately (to calculate elapsed time). If set to False,\n                you will need to call `start` manually. Defaults to True.\n            total (float, optional): Number of total steps in the progress if known.\n                Set to None to render a pulsing animation. Defaults to 100.\n            completed (int, optional): Number of steps completed so far. Defaults to 0.\n            visible (bool, optional): Enable display of the task. Defaults to True.\n            **fields (str): Additional data fields required for rendering.\n\n        Returns:\n            TaskID: An ID you can use when calling `update`.\n        \"\"\"\n        with self._lock:\n            task = Task(\n                self._task_index,\n                description,\n                total,\n                completed,\n                visible=visible,\n                fields=fields,\n                _get_time=self.get_time,\n                _lock=self._lock,\n            )\n            self._tasks[self._task_index] = task\n            if start:\n                self.start_task(self._task_index)\n            new_task_index = self._task_index\n            self._task_index = TaskID(int(self._task_index) + 1)\n        self.refresh()\n        return new_task_index\n\n    def remove_task(self, task_id: TaskID) -> None:\n        \"\"\"Delete a task if it exists.\n\n        Args:\n            task_id (TaskID): A task ID.\n\n        \"\"\"\n        with self._lock:\n            del self._tasks[task_id]\n\n\nif __name__ == \"__main__\":  # pragma: no coverage\n    import random\n    import time\n\n    from .panel import Panel\n    from .rule import Rule\n    from .syntax import Syntax\n    from .table import Table\n\n    syntax = Syntax(\n        '''def loop_last(values: Iterable[T]) -> Iterable[Tuple[bool, T]]:\n    \"\"\"Iterate and generate a tuple with a flag for last value.\"\"\"\n    iter_values = iter(values)\n    try:\n        previous_value = next(iter_values)\n    except StopIteration:\n        return\n    for value in iter_values:\n        yield False, previous_value\n        previous_value = value\n    yield True, previous_value''',\n        \"python\",\n        line_numbers=True,\n    )\n\n    table = Table(\"foo\", \"bar\", \"baz\")\n    table.add_row(\"1\", \"2\", \"3\")\n\n    progress_renderables = [\n        \"Text may be printed while the progress bars are rendering.\",\n        Panel(\"In fact, [i]any[/i] renderable will work\"),\n        \"Such as [magenta]tables[/]...\",\n        table,\n        \"Pretty printed structures...\",\n        {\"type\": \"example\", \"text\": \"Pretty printed\"},\n        \"Syntax...\",\n        syntax,\n        Rule(\"Give it a try!\"),\n    ]\n\n    from itertools import cycle\n\n    examples = cycle(progress_renderables)\n\n    console = Console(record=True)\n\n    with Progress(\n        SpinnerColumn(),\n        *Progress.get_default_columns(),\n        TimeElapsedColumn(),\n        console=console,\n        transient=False,\n    ) as progress:\n        task1 = progress.add_task(\"[red]Downloading\", total=1000)\n        task2 = progress.add_task(\"[green]Processing\", total=1000)\n        task3 = progress.add_task(\"[yellow]Thinking\", total=None)\n\n        while not progress.finished:\n            progress.update(task1, advance=0.5)\n            progress.update(task2, advance=0.3)\n            time.sleep(0.01)\n            if random.randint(0, 100) < 1:\n                progress.log(next(examples))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/progress_bar.py","size":8162,"sha1":"67d2ad11833cc754dea867849dd18e10b0c53dfa","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import math\nfrom functools import lru_cache\nfrom time import monotonic\nfrom typing import Iterable, List, Optional\n\nfrom .color import Color, blend_rgb\nfrom .color_triplet import ColorTriplet\nfrom .console import Console, ConsoleOptions, RenderResult\nfrom .jupyter import JupyterMixin\nfrom .measure import Measurement\nfrom .segment import Segment\nfrom .style import Style, StyleType\n\n# Number of characters before 'pulse' animation repeats\nPULSE_SIZE = 20\n\n\nclass ProgressBar(JupyterMixin):\n    \"\"\"Renders a (progress) bar. Used by rich.progress.\n\n    Args:\n        total (float, optional): Number of steps in the bar. Defaults to 100. Set to None to render a pulsing animation.\n        completed (float, optional): Number of steps completed. Defaults to 0.\n        width (int, optional): Width of the bar, or ``None`` for maximum width. Defaults to None.\n        pulse (bool, optional): Enable pulse effect. Defaults to False. Will pulse if a None total was passed.\n        style (StyleType, optional): Style for the bar background. Defaults to \"bar.back\".\n        complete_style (StyleType, optional): Style for the completed bar. Defaults to \"bar.complete\".\n        finished_style (StyleType, optional): Style for a finished bar. Defaults to \"bar.finished\".\n        pulse_style (StyleType, optional): Style for pulsing bars. Defaults to \"bar.pulse\".\n        animation_time (Optional[float], optional): Time in seconds to use for animation, or None to use system time.\n    \"\"\"\n\n    def __init__(\n        self,\n        total: Optional[float] = 100.0,\n        completed: float = 0,\n        width: Optional[int] = None,\n        pulse: bool = False,\n        style: StyleType = \"bar.back\",\n        complete_style: StyleType = \"bar.complete\",\n        finished_style: StyleType = \"bar.finished\",\n        pulse_style: StyleType = \"bar.pulse\",\n        animation_time: Optional[float] = None,\n    ):\n        self.total = total\n        self.completed = completed\n        self.width = width\n        self.pulse = pulse\n        self.style = style\n        self.complete_style = complete_style\n        self.finished_style = finished_style\n        self.pulse_style = pulse_style\n        self.animation_time = animation_time\n\n        self._pulse_segments: Optional[List[Segment]] = None\n\n    def __repr__(self) -> str:\n        return f\"<Bar {self.completed!r} of {self.total!r}>\"\n\n    @property\n    def percentage_completed(self) -> Optional[float]:\n        \"\"\"Calculate percentage complete.\"\"\"\n        if self.total is None:\n            return None\n        completed = (self.completed / self.total) * 100.0\n        completed = min(100, max(0.0, completed))\n        return completed\n\n    @lru_cache(maxsize=16)\n    def _get_pulse_segments(\n        self,\n        fore_style: Style,\n        back_style: Style,\n        color_system: str,\n        no_color: bool,\n        ascii: bool = False,\n    ) -> List[Segment]:\n        \"\"\"Get a list of segments to render a pulse animation.\n\n        Returns:\n            List[Segment]: A list of segments, one segment per character.\n        \"\"\"\n        bar = \"-\" if ascii else \"â”\"\n        segments: List[Segment] = []\n        if color_system not in (\"standard\", \"eight_bit\", \"truecolor\") or no_color:\n            segments += [Segment(bar, fore_style)] * (PULSE_SIZE // 2)\n            segments += [Segment(\" \" if no_color else bar, back_style)] * (\n                PULSE_SIZE - (PULSE_SIZE // 2)\n            )\n            return segments\n\n        append = segments.append\n        fore_color = (\n            fore_style.color.get_truecolor()\n            if fore_style.color\n            else ColorTriplet(255, 0, 255)\n        )\n        back_color = (\n            back_style.color.get_truecolor()\n            if back_style.color\n            else ColorTriplet(0, 0, 0)\n        )\n        cos = math.cos\n        pi = math.pi\n        _Segment = Segment\n        _Style = Style\n        from_triplet = Color.from_triplet\n\n        for index in range(PULSE_SIZE):\n            position = index / PULSE_SIZE\n            fade = 0.5 + cos(position * pi * 2) / 2.0\n            color = blend_rgb(fore_color, back_color, cross_fade=fade)\n            append(_Segment(bar, _Style(color=from_triplet(color))))\n        return segments\n\n    def update(self, completed: float, total: Optional[float] = None) -> None:\n        \"\"\"Update progress with new values.\n\n        Args:\n            completed (float): Number of steps completed.\n            total (float, optional): Total number of steps, or ``None`` to not change. Defaults to None.\n        \"\"\"\n        self.completed = completed\n        self.total = total if total is not None else self.total\n\n    def _render_pulse(\n        self, console: Console, width: int, ascii: bool = False\n    ) -> Iterable[Segment]:\n        \"\"\"Renders the pulse animation.\n\n        Args:\n            console (Console): Console instance.\n            width (int): Width in characters of pulse animation.\n\n        Returns:\n            RenderResult: [description]\n\n        Yields:\n            Iterator[Segment]: Segments to render pulse\n        \"\"\"\n        fore_style = console.get_style(self.pulse_style, default=\"white\")\n        back_style = console.get_style(self.style, default=\"black\")\n\n        pulse_segments = self._get_pulse_segments(\n            fore_style, back_style, console.color_system, console.no_color, ascii=ascii\n        )\n        segment_count = len(pulse_segments)\n        current_time = (\n            monotonic() if self.animation_time is None else self.animation_time\n        )\n        segments = pulse_segments * (int(width / segment_count) + 2)\n        offset = int(-current_time * 15) % segment_count\n        segments = segments[offset : offset + width]\n        yield from segments\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        width = min(self.width or options.max_width, options.max_width)\n        ascii = options.legacy_windows or options.ascii_only\n        should_pulse = self.pulse or self.total is None\n        if should_pulse:\n            yield from self._render_pulse(console, width, ascii=ascii)\n            return\n\n        completed: Optional[float] = (\n            min(self.total, max(0, self.completed)) if self.total is not None else None\n        )\n\n        bar = \"-\" if ascii else \"â”\"\n        half_bar_right = \" \" if ascii else \"â•¸\"\n        half_bar_left = \" \" if ascii else \"â•º\"\n        complete_halves = (\n            int(width * 2 * completed / self.total)\n            if self.total and completed is not None\n            else width * 2\n        )\n        bar_count = complete_halves // 2\n        half_bar_count = complete_halves % 2\n        style = console.get_style(self.style)\n        is_finished = self.total is None or self.completed >= self.total\n        complete_style = console.get_style(\n            self.finished_style if is_finished else self.complete_style\n        )\n        _Segment = Segment\n        if bar_count:\n            yield _Segment(bar * bar_count, complete_style)\n        if half_bar_count:\n            yield _Segment(half_bar_right * half_bar_count, complete_style)\n\n        if not console.no_color:\n            remaining_bars = width - bar_count - half_bar_count\n            if remaining_bars and console.color_system is not None:\n                if not half_bar_count and bar_count:\n                    yield _Segment(half_bar_left, style)\n                    remaining_bars -= 1\n                if remaining_bars:\n                    yield _Segment(bar * remaining_bars, style)\n\n    def __rich_measure__(\n        self, console: Console, options: ConsoleOptions\n    ) -> Measurement:\n        return (\n            Measurement(self.width, self.width)\n            if self.width is not None\n            else Measurement(4, options.max_width)\n        )\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    console = Console()\n    bar = ProgressBar(width=50, total=100)\n\n    import time\n\n    console.show_cursor(False)\n    for n in range(0, 101, 1):\n        bar.update(n)\n        console.print(bar)\n        console.file.write(\"\\r\")\n        time.sleep(0.05)\n    console.show_cursor(True)\n    console.print()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/prompt.py","size":12447,"sha1":"4ec3638d1879714b7f41828e65eb750bf8c2f845","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import Any, Generic, List, Optional, TextIO, TypeVar, Union, overload\n\nfrom . import get_console\nfrom .console import Console\nfrom .text import Text, TextType\n\nPromptType = TypeVar(\"PromptType\")\nDefaultType = TypeVar(\"DefaultType\")\n\n\nclass PromptError(Exception):\n    \"\"\"Exception base class for prompt related errors.\"\"\"\n\n\nclass InvalidResponse(PromptError):\n    \"\"\"Exception to indicate a response was invalid. Raise this within process_response() to indicate an error\n    and provide an error message.\n\n    Args:\n        message (Union[str, Text]): Error message.\n    \"\"\"\n\n    def __init__(self, message: TextType) -> None:\n        self.message = message\n\n    def __rich__(self) -> TextType:\n        return self.message\n\n\nclass PromptBase(Generic[PromptType]):\n    \"\"\"Ask the user for input until a valid response is received. This is the base class, see one of\n    the concrete classes for examples.\n\n    Args:\n        prompt (TextType, optional): Prompt text. Defaults to \"\".\n        console (Console, optional): A Console instance or None to use global console. Defaults to None.\n        password (bool, optional): Enable password input. Defaults to False.\n        choices (List[str], optional): A list of valid choices. Defaults to None.\n        case_sensitive (bool, optional): Matching of choices should be case-sensitive. Defaults to True.\n        show_default (bool, optional): Show default in prompt. Defaults to True.\n        show_choices (bool, optional): Show choices in prompt. Defaults to True.\n    \"\"\"\n\n    response_type: type = str\n\n    validate_error_message = \"[prompt.invalid]Please enter a valid value\"\n    illegal_choice_message = (\n        \"[prompt.invalid.choice]Please select one of the available options\"\n    )\n    prompt_suffix = \": \"\n\n    choices: Optional[List[str]] = None\n\n    def __init__(\n        self,\n        prompt: TextType = \"\",\n        *,\n        console: Optional[Console] = None,\n        password: bool = False,\n        choices: Optional[List[str]] = None,\n        case_sensitive: bool = True,\n        show_default: bool = True,\n        show_choices: bool = True,\n    ) -> None:\n        self.console = console or get_console()\n        self.prompt = (\n            Text.from_markup(prompt, style=\"prompt\")\n            if isinstance(prompt, str)\n            else prompt\n        )\n        self.password = password\n        if choices is not None:\n            self.choices = choices\n        self.case_sensitive = case_sensitive\n        self.show_default = show_default\n        self.show_choices = show_choices\n\n    @classmethod\n    @overload\n    def ask(\n        cls,\n        prompt: TextType = \"\",\n        *,\n        console: Optional[Console] = None,\n        password: bool = False,\n        choices: Optional[List[str]] = None,\n        case_sensitive: bool = True,\n        show_default: bool = True,\n        show_choices: bool = True,\n        default: DefaultType,\n        stream: Optional[TextIO] = None,\n    ) -> Union[DefaultType, PromptType]:\n        ...\n\n    @classmethod\n    @overload\n    def ask(\n        cls,\n        prompt: TextType = \"\",\n        *,\n        console: Optional[Console] = None,\n        password: bool = False,\n        choices: Optional[List[str]] = None,\n        case_sensitive: bool = True,\n        show_default: bool = True,\n        show_choices: bool = True,\n        stream: Optional[TextIO] = None,\n    ) -> PromptType:\n        ...\n\n    @classmethod\n    def ask(\n        cls,\n        prompt: TextType = \"\",\n        *,\n        console: Optional[Console] = None,\n        password: bool = False,\n        choices: Optional[List[str]] = None,\n        case_sensitive: bool = True,\n        show_default: bool = True,\n        show_choices: bool = True,\n        default: Any = ...,\n        stream: Optional[TextIO] = None,\n    ) -> Any:\n        \"\"\"Shortcut to construct and run a prompt loop and return the result.\n\n        Example:\n            >>> filename = Prompt.ask(\"Enter a filename\")\n\n        Args:\n            prompt (TextType, optional): Prompt text. Defaults to \"\".\n            console (Console, optional): A Console instance or None to use global console. Defaults to None.\n            password (bool, optional): Enable password input. Defaults to False.\n            choices (List[str], optional): A list of valid choices. Defaults to None.\n            case_sensitive (bool, optional): Matching of choices should be case-sensitive. Defaults to True.\n            show_default (bool, optional): Show default in prompt. Defaults to True.\n            show_choices (bool, optional): Show choices in prompt. Defaults to True.\n            stream (TextIO, optional): Optional text file open for reading to get input. Defaults to None.\n        \"\"\"\n        _prompt = cls(\n            prompt,\n            console=console,\n            password=password,\n            choices=choices,\n            case_sensitive=case_sensitive,\n            show_default=show_default,\n            show_choices=show_choices,\n        )\n        return _prompt(default=default, stream=stream)\n\n    def render_default(self, default: DefaultType) -> Text:\n        \"\"\"Turn the supplied default in to a Text instance.\n\n        Args:\n            default (DefaultType): Default value.\n\n        Returns:\n            Text: Text containing rendering of default value.\n        \"\"\"\n        return Text(f\"({default})\", \"prompt.default\")\n\n    def make_prompt(self, default: DefaultType) -> Text:\n        \"\"\"Make prompt text.\n\n        Args:\n            default (DefaultType): Default value.\n\n        Returns:\n            Text: Text to display in prompt.\n        \"\"\"\n        prompt = self.prompt.copy()\n        prompt.end = \"\"\n\n        if self.show_choices and self.choices:\n            _choices = \"/\".join(self.choices)\n            choices = f\"[{_choices}]\"\n            prompt.append(\" \")\n            prompt.append(choices, \"prompt.choices\")\n\n        if (\n            default != ...\n            and self.show_default\n            and isinstance(default, (str, self.response_type))\n        ):\n            prompt.append(\" \")\n            _default = self.render_default(default)\n            prompt.append(_default)\n\n        prompt.append(self.prompt_suffix)\n\n        return prompt\n\n    @classmethod\n    def get_input(\n        cls,\n        console: Console,\n        prompt: TextType,\n        password: bool,\n        stream: Optional[TextIO] = None,\n    ) -> str:\n        \"\"\"Get input from user.\n\n        Args:\n            console (Console): Console instance.\n            prompt (TextType): Prompt text.\n            password (bool): Enable password entry.\n\n        Returns:\n            str: String from user.\n        \"\"\"\n        return console.input(prompt, password=password, stream=stream)\n\n    def check_choice(self, value: str) -> bool:\n        \"\"\"Check value is in the list of valid choices.\n\n        Args:\n            value (str): Value entered by user.\n\n        Returns:\n            bool: True if choice was valid, otherwise False.\n        \"\"\"\n        assert self.choices is not None\n        if self.case_sensitive:\n            return value.strip() in self.choices\n        return value.strip().lower() in [choice.lower() for choice in self.choices]\n\n    def process_response(self, value: str) -> PromptType:\n        \"\"\"Process response from user, convert to prompt type.\n\n        Args:\n            value (str): String typed by user.\n\n        Raises:\n            InvalidResponse: If ``value`` is invalid.\n\n        Returns:\n            PromptType: The value to be returned from ask method.\n        \"\"\"\n        value = value.strip()\n        try:\n            return_value: PromptType = self.response_type(value)\n        except ValueError:\n            raise InvalidResponse(self.validate_error_message)\n\n        if self.choices is not None:\n            if not self.check_choice(value):\n                raise InvalidResponse(self.illegal_choice_message)\n\n            if not self.case_sensitive:\n                # return the original choice, not the lower case version\n                return_value = self.response_type(\n                    self.choices[\n                        [choice.lower() for choice in self.choices].index(value.lower())\n                    ]\n                )\n        return return_value\n\n    def on_validate_error(self, value: str, error: InvalidResponse) -> None:\n        \"\"\"Called to handle validation error.\n\n        Args:\n            value (str): String entered by user.\n            error (InvalidResponse): Exception instance the initiated the error.\n        \"\"\"\n        self.console.print(error)\n\n    def pre_prompt(self) -> None:\n        \"\"\"Hook to display something before the prompt.\"\"\"\n\n    @overload\n    def __call__(self, *, stream: Optional[TextIO] = None) -> PromptType:\n        ...\n\n    @overload\n    def __call__(\n        self, *, default: DefaultType, stream: Optional[TextIO] = None\n    ) -> Union[PromptType, DefaultType]:\n        ...\n\n    def __call__(self, *, default: Any = ..., stream: Optional[TextIO] = None) -> Any:\n        \"\"\"Run the prompt loop.\n\n        Args:\n            default (Any, optional): Optional default value.\n\n        Returns:\n            PromptType: Processed value.\n        \"\"\"\n        while True:\n            self.pre_prompt()\n            prompt = self.make_prompt(default)\n            value = self.get_input(self.console, prompt, self.password, stream=stream)\n            if value == \"\" and default != ...:\n                return default\n            try:\n                return_value = self.process_response(value)\n            except InvalidResponse as error:\n                self.on_validate_error(value, error)\n                continue\n            else:\n                return return_value\n\n\nclass Prompt(PromptBase[str]):\n    \"\"\"A prompt that returns a str.\n\n    Example:\n        >>> name = Prompt.ask(\"Enter your name\")\n\n\n    \"\"\"\n\n    response_type = str\n\n\nclass IntPrompt(PromptBase[int]):\n    \"\"\"A prompt that returns an integer.\n\n    Example:\n        >>> burrito_count = IntPrompt.ask(\"How many burritos do you want to order\")\n\n    \"\"\"\n\n    response_type = int\n    validate_error_message = \"[prompt.invalid]Please enter a valid integer number\"\n\n\nclass FloatPrompt(PromptBase[float]):\n    \"\"\"A prompt that returns a float.\n\n    Example:\n        >>> temperature = FloatPrompt.ask(\"Enter desired temperature\")\n\n    \"\"\"\n\n    response_type = float\n    validate_error_message = \"[prompt.invalid]Please enter a number\"\n\n\nclass Confirm(PromptBase[bool]):\n    \"\"\"A yes / no confirmation prompt.\n\n    Example:\n        >>> if Confirm.ask(\"Continue\"):\n                run_job()\n\n    \"\"\"\n\n    response_type = bool\n    validate_error_message = \"[prompt.invalid]Please enter Y or N\"\n    choices: List[str] = [\"y\", \"n\"]\n\n    def render_default(self, default: DefaultType) -> Text:\n        \"\"\"Render the default as (y) or (n) rather than True/False.\"\"\"\n        yes, no = self.choices\n        return Text(f\"({yes})\" if default else f\"({no})\", style=\"prompt.default\")\n\n    def process_response(self, value: str) -> bool:\n        \"\"\"Convert choices to a bool.\"\"\"\n        value = value.strip().lower()\n        if value not in self.choices:\n            raise InvalidResponse(self.validate_error_message)\n        return value == self.choices[0]\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from pip._vendor.rich import print\n\n    if Confirm.ask(\"Run [i]prompt[/i] tests?\", default=True):\n        while True:\n            result = IntPrompt.ask(\n                \":rocket: Enter a number between [b]1[/b] and [b]10[/b]\", default=5\n            )\n            if result >= 1 and result <= 10:\n                break\n            print(\":pile_of_poo: [prompt.invalid]Number must be between 1 and 10\")\n        print(f\"number={result}\")\n\n        while True:\n            password = Prompt.ask(\n                \"Please enter a password [cyan](must be at least 5 characters)\",\n                password=True,\n            )\n            if len(password) >= 5:\n                break\n            print(\"[prompt.invalid]password too short\")\n        print(f\"password={password!r}\")\n\n        fruit = Prompt.ask(\"Enter a fruit\", choices=[\"apple\", \"orange\", \"pear\"])\n        print(f\"fruit={fruit!r}\")\n\n        doggie = Prompt.ask(\n            \"What's the best Dog? (Case INSENSITIVE)\",\n            choices=[\"Border Terrier\", \"Collie\", \"Labradoodle\"],\n            case_sensitive=False,\n        )\n        print(f\"doggie={doggie!r}\")\n\n    else:\n        print(\"[b]OK :loudly_crying_face:\")\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/protocol.py","size":1391,"sha1":"a2dca9d46365f198635de5bbfd6c2628566ab28f","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import Any, cast, Set, TYPE_CHECKING\nfrom inspect import isclass\n\nif TYPE_CHECKING:\n    from pip._vendor.rich.console import RenderableType\n\n_GIBBERISH = \"\"\"aihwerij235234ljsdnp34ksodfipwoe234234jlskjdf\"\"\"\n\n\ndef is_renderable(check_object: Any) -> bool:\n    \"\"\"Check if an object may be rendered by Rich.\"\"\"\n    return (\n        isinstance(check_object, str)\n        or hasattr(check_object, \"__rich__\")\n        or hasattr(check_object, \"__rich_console__\")\n    )\n\n\ndef rich_cast(renderable: object) -> \"RenderableType\":\n    \"\"\"Cast an object to a renderable by calling __rich__ if present.\n\n    Args:\n        renderable (object): A potentially renderable object\n\n    Returns:\n        object: The result of recursively calling __rich__.\n    \"\"\"\n    from pip._vendor.rich.console import RenderableType\n\n    rich_visited_set: Set[type] = set()  # Prevent potential infinite loop\n    while hasattr(renderable, \"__rich__\") and not isclass(renderable):\n        # Detect object which claim to have all the attributes\n        if hasattr(renderable, _GIBBERISH):\n            return repr(renderable)\n        cast_method = getattr(renderable, \"__rich__\")\n        renderable = cast_method()\n        renderable_type = type(renderable)\n        if renderable_type in rich_visited_set:\n            break\n        rich_visited_set.add(renderable_type)\n\n    return cast(RenderableType, renderable)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/region.py","size":166,"sha1":"f38fc0db54d1fa3e66820604153208c316dc4df3","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import NamedTuple\n\n\nclass Region(NamedTuple):\n    \"\"\"Defines a rectangular region of the screen.\"\"\"\n\n    x: int\n    y: int\n    width: int\n    height: int\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/repr.py","size":4431,"sha1":"bce66f8d6512bb144555fa7b6ceec329b469defb","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import inspect\nfrom functools import partial\nfrom typing import (\n    Any,\n    Callable,\n    Iterable,\n    List,\n    Optional,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    overload,\n)\n\nT = TypeVar(\"T\")\n\n\nResult = Iterable[Union[Any, Tuple[Any], Tuple[str, Any], Tuple[str, Any, Any]]]\nRichReprResult = Result\n\n\nclass ReprError(Exception):\n    \"\"\"An error occurred when attempting to build a repr.\"\"\"\n\n\n@overload\ndef auto(cls: Optional[Type[T]]) -> Type[T]:\n    ...\n\n\n@overload\ndef auto(*, angular: bool = False) -> Callable[[Type[T]], Type[T]]:\n    ...\n\n\ndef auto(\n    cls: Optional[Type[T]] = None, *, angular: Optional[bool] = None\n) -> Union[Type[T], Callable[[Type[T]], Type[T]]]:\n    \"\"\"Class decorator to create __repr__ from __rich_repr__\"\"\"\n\n    def do_replace(cls: Type[T], angular: Optional[bool] = None) -> Type[T]:\n        def auto_repr(self: T) -> str:\n            \"\"\"Create repr string from __rich_repr__\"\"\"\n            repr_str: List[str] = []\n            append = repr_str.append\n\n            angular: bool = getattr(self.__rich_repr__, \"angular\", False)  # type: ignore[attr-defined]\n            for arg in self.__rich_repr__():  # type: ignore[attr-defined]\n                if isinstance(arg, tuple):\n                    if len(arg) == 1:\n                        append(repr(arg[0]))\n                    else:\n                        key, value, *default = arg\n                        if key is None:\n                            append(repr(value))\n                        else:\n                            if default and default[0] == value:\n                                continue\n                            append(f\"{key}={value!r}\")\n                else:\n                    append(repr(arg))\n            if angular:\n                return f\"<{self.__class__.__name__} {' '.join(repr_str)}>\"\n            else:\n                return f\"{self.__class__.__name__}({', '.join(repr_str)})\"\n\n        def auto_rich_repr(self: Type[T]) -> Result:\n            \"\"\"Auto generate __rich_rep__ from signature of __init__\"\"\"\n            try:\n                signature = inspect.signature(self.__init__)\n                for name, param in signature.parameters.items():\n                    if param.kind == param.POSITIONAL_ONLY:\n                        yield getattr(self, name)\n                    elif param.kind in (\n                        param.POSITIONAL_OR_KEYWORD,\n                        param.KEYWORD_ONLY,\n                    ):\n                        if param.default is param.empty:\n                            yield getattr(self, param.name)\n                        else:\n                            yield param.name, getattr(self, param.name), param.default\n            except Exception as error:\n                raise ReprError(\n                    f\"Failed to auto generate __rich_repr__; {error}\"\n                ) from None\n\n        if not hasattr(cls, \"__rich_repr__\"):\n            auto_rich_repr.__doc__ = \"Build a rich repr\"\n            cls.__rich_repr__ = auto_rich_repr  # type: ignore[attr-defined]\n\n        auto_repr.__doc__ = \"Return repr(self)\"\n        cls.__repr__ = auto_repr  # type: ignore[assignment]\n        if angular is not None:\n            cls.__rich_repr__.angular = angular  # type: ignore[attr-defined]\n        return cls\n\n    if cls is None:\n        return partial(do_replace, angular=angular)\n    else:\n        return do_replace(cls, angular=angular)\n\n\n@overload\ndef rich_repr(cls: Optional[Type[T]]) -> Type[T]:\n    ...\n\n\n@overload\ndef rich_repr(*, angular: bool = False) -> Callable[[Type[T]], Type[T]]:\n    ...\n\n\ndef rich_repr(\n    cls: Optional[Type[T]] = None, *, angular: bool = False\n) -> Union[Type[T], Callable[[Type[T]], Type[T]]]:\n    if cls is None:\n        return auto(angular=angular)\n    else:\n        return auto(cls)\n\n\nif __name__ == \"__main__\":\n\n    @auto\n    class Foo:\n        def __rich_repr__(self) -> Result:\n            yield \"foo\"\n            yield \"bar\", {\"shopping\": [\"eggs\", \"ham\", \"pineapple\"]}\n            yield \"buy\", \"hand sanitizer\"\n\n    foo = Foo()\n    from pip._vendor.rich.console import Console\n\n    console = Console()\n\n    console.rule(\"Standard repr\")\n    console.print(foo)\n\n    console.print(foo, width=60)\n    console.print(foo, width=30)\n\n    console.rule(\"Angular repr\")\n    Foo.__rich_repr__.angular = True  # type: ignore[attr-defined]\n\n    console.print(foo)\n\n    console.print(foo, width=60)\n    console.print(foo, width=30)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/rule.py","size":4602,"sha1":"7749aef099cb40f7099a009edf075ee3936d4757","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import Union\n\nfrom .align import AlignMethod\nfrom .cells import cell_len, set_cell_size\nfrom .console import Console, ConsoleOptions, RenderResult\nfrom .jupyter import JupyterMixin\nfrom .measure import Measurement\nfrom .style import Style\nfrom .text import Text\n\n\nclass Rule(JupyterMixin):\n    \"\"\"A console renderable to draw a horizontal rule (line).\n\n    Args:\n        title (Union[str, Text], optional): Text to render in the rule. Defaults to \"\".\n        characters (str, optional): Character(s) used to draw the line. Defaults to \"â”€\".\n        style (StyleType, optional): Style of Rule. Defaults to \"rule.line\".\n        end (str, optional): Character at end of Rule. defaults to \"\\\\\\\\n\"\n        align (str, optional): How to align the title, one of \"left\", \"center\", or \"right\". Defaults to \"center\".\n    \"\"\"\n\n    def __init__(\n        self,\n        title: Union[str, Text] = \"\",\n        *,\n        characters: str = \"â”€\",\n        style: Union[str, Style] = \"rule.line\",\n        end: str = \"\\n\",\n        align: AlignMethod = \"center\",\n    ) -> None:\n        if cell_len(characters) < 1:\n            raise ValueError(\n                \"'characters' argument must have a cell width of at least 1\"\n            )\n        if align not in (\"left\", \"center\", \"right\"):\n            raise ValueError(\n                f'invalid value for align, expected \"left\", \"center\", \"right\" (not {align!r})'\n            )\n        self.title = title\n        self.characters = characters\n        self.style = style\n        self.end = end\n        self.align = align\n\n    def __repr__(self) -> str:\n        return f\"Rule({self.title!r}, {self.characters!r})\"\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        width = options.max_width\n\n        characters = (\n            \"-\"\n            if (options.ascii_only and not self.characters.isascii())\n            else self.characters\n        )\n\n        chars_len = cell_len(characters)\n        if not self.title:\n            yield self._rule_line(chars_len, width)\n            return\n\n        if isinstance(self.title, Text):\n            title_text = self.title\n        else:\n            title_text = console.render_str(self.title, style=\"rule.text\")\n\n        title_text.plain = title_text.plain.replace(\"\\n\", \" \")\n        title_text.expand_tabs()\n\n        required_space = 4 if self.align == \"center\" else 2\n        truncate_width = max(0, width - required_space)\n        if not truncate_width:\n            yield self._rule_line(chars_len, width)\n            return\n\n        rule_text = Text(end=self.end)\n        if self.align == \"center\":\n            title_text.truncate(truncate_width, overflow=\"ellipsis\")\n            side_width = (width - cell_len(title_text.plain)) // 2\n            left = Text(characters * (side_width // chars_len + 1))\n            left.truncate(side_width - 1)\n            right_length = width - cell_len(left.plain) - cell_len(title_text.plain)\n            right = Text(characters * (side_width // chars_len + 1))\n            right.truncate(right_length)\n            rule_text.append(left.plain + \" \", self.style)\n            rule_text.append(title_text)\n            rule_text.append(\" \" + right.plain, self.style)\n        elif self.align == \"left\":\n            title_text.truncate(truncate_width, overflow=\"ellipsis\")\n            rule_text.append(title_text)\n            rule_text.append(\" \")\n            rule_text.append(characters * (width - rule_text.cell_len), self.style)\n        elif self.align == \"right\":\n            title_text.truncate(truncate_width, overflow=\"ellipsis\")\n            rule_text.append(characters * (width - title_text.cell_len - 1), self.style)\n            rule_text.append(\" \")\n            rule_text.append(title_text)\n\n        rule_text.plain = set_cell_size(rule_text.plain, width)\n        yield rule_text\n\n    def _rule_line(self, chars_len: int, width: int) -> Text:\n        rule_text = Text(self.characters * ((width // chars_len) + 1), self.style)\n        rule_text.truncate(width)\n        rule_text.plain = set_cell_size(rule_text.plain, width)\n        return rule_text\n\n    def __rich_measure__(\n        self, console: Console, options: ConsoleOptions\n    ) -> Measurement:\n        return Measurement(1, 1)\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    import sys\n\n    from pip._vendor.rich.console import Console\n\n    try:\n        text = sys.argv[1]\n    except IndexError:\n        text = \"Hello, World\"\n    console = Console()\n    console.print(Rule(title=text))\n\n    console = Console()\n    console.print(Rule(\"foo\"), width=4)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/scope.py","size":2843,"sha1":"5aec0581ed1c64d49146d94301c0e01d2ecc5000","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from collections.abc import Mapping\nfrom typing import TYPE_CHECKING, Any, Optional, Tuple\n\nfrom .highlighter import ReprHighlighter\nfrom .panel import Panel\nfrom .pretty import Pretty\nfrom .table import Table\nfrom .text import Text, TextType\n\nif TYPE_CHECKING:\n    from .console import ConsoleRenderable\n\n\ndef render_scope(\n    scope: \"Mapping[str, Any]\",\n    *,\n    title: Optional[TextType] = None,\n    sort_keys: bool = True,\n    indent_guides: bool = False,\n    max_length: Optional[int] = None,\n    max_string: Optional[int] = None,\n) -> \"ConsoleRenderable\":\n    \"\"\"Render python variables in a given scope.\n\n    Args:\n        scope (Mapping): A mapping containing variable names and values.\n        title (str, optional): Optional title. Defaults to None.\n        sort_keys (bool, optional): Enable sorting of items. Defaults to True.\n        indent_guides (bool, optional): Enable indentation guides. Defaults to False.\n        max_length (int, optional): Maximum length of containers before abbreviating, or None for no abbreviation.\n            Defaults to None.\n        max_string (int, optional): Maximum length of string before truncating, or None to disable. Defaults to None.\n\n    Returns:\n        ConsoleRenderable: A renderable object.\n    \"\"\"\n    highlighter = ReprHighlighter()\n    items_table = Table.grid(padding=(0, 1), expand=False)\n    items_table.add_column(justify=\"right\")\n\n    def sort_items(item: Tuple[str, Any]) -> Tuple[bool, str]:\n        \"\"\"Sort special variables first, then alphabetically.\"\"\"\n        key, _ = item\n        return (not key.startswith(\"__\"), key.lower())\n\n    items = sorted(scope.items(), key=sort_items) if sort_keys else scope.items()\n    for key, value in items:\n        key_text = Text.assemble(\n            (key, \"scope.key.special\" if key.startswith(\"__\") else \"scope.key\"),\n            (\" =\", \"scope.equals\"),\n        )\n        items_table.add_row(\n            key_text,\n            Pretty(\n                value,\n                highlighter=highlighter,\n                indent_guides=indent_guides,\n                max_length=max_length,\n                max_string=max_string,\n            ),\n        )\n    return Panel.fit(\n        items_table,\n        title=title,\n        border_style=\"scope.border\",\n        padding=(0, 1),\n    )\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from pip._vendor.rich import print\n\n    print()\n\n    def test(foo: float, bar: float) -> None:\n        list_of_things = [1, 2, 3, None, 4, True, False, \"Hello World\"]\n        dict_of_things = {\n            \"version\": \"1.1\",\n            \"method\": \"confirmFruitPurchase\",\n            \"params\": [[\"apple\", \"orange\", \"mangoes\", \"pomelo\"], 1.123],\n            \"id\": \"194521489\",\n        }\n        print(render_scope(locals(), title=\"[i]locals\", sort_keys=False))\n\n    test(20.3423, 3.1427)\n    print()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/screen.py","size":1591,"sha1":"4f0802d8391d8c1e0397768db38bb9e56cbac613","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import Optional, TYPE_CHECKING\n\nfrom .segment import Segment\nfrom .style import StyleType\nfrom ._loop import loop_last\n\n\nif TYPE_CHECKING:\n    from .console import (\n        Console,\n        ConsoleOptions,\n        RenderResult,\n        RenderableType,\n        Group,\n    )\n\n\nclass Screen:\n    \"\"\"A renderable that fills the terminal screen and crops excess.\n\n    Args:\n        renderable (RenderableType): Child renderable.\n        style (StyleType, optional): Optional background style. Defaults to None.\n    \"\"\"\n\n    renderable: \"RenderableType\"\n\n    def __init__(\n        self,\n        *renderables: \"RenderableType\",\n        style: Optional[StyleType] = None,\n        application_mode: bool = False,\n    ) -> None:\n        from pip._vendor.rich.console import Group\n\n        self.renderable = Group(*renderables)\n        self.style = style\n        self.application_mode = application_mode\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        width, height = options.size\n        style = console.get_style(self.style) if self.style else None\n        render_options = options.update(width=width, height=height)\n        lines = console.render_lines(\n            self.renderable or \"\", render_options, style=style, pad=True\n        )\n        lines = Segment.set_shape(lines, width, height, style=style)\n        new_line = Segment(\"\\n\\r\") if self.application_mode else Segment.line()\n        for last, line in loop_last(lines):\n            yield from line\n            if not last:\n                yield new_line\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/segment.py","size":24743,"sha1":"e138b6fd2ee08fa2b1bdfcbf82a3761b37c5ad29","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from enum import IntEnum\nfrom functools import lru_cache\nfrom itertools import filterfalse\nfrom logging import getLogger\nfrom operator import attrgetter\nfrom typing import (\n    TYPE_CHECKING,\n    Dict,\n    Iterable,\n    List,\n    NamedTuple,\n    Optional,\n    Sequence,\n    Tuple,\n    Type,\n    Union,\n)\n\nfrom .cells import (\n    _is_single_cell_widths,\n    cached_cell_len,\n    cell_len,\n    get_character_cell_size,\n    set_cell_size,\n)\nfrom .repr import Result, rich_repr\nfrom .style import Style\n\nif TYPE_CHECKING:\n    from .console import Console, ConsoleOptions, RenderResult\n\nlog = getLogger(\"rich\")\n\n\nclass ControlType(IntEnum):\n    \"\"\"Non-printable control codes which typically translate to ANSI codes.\"\"\"\n\n    BELL = 1\n    CARRIAGE_RETURN = 2\n    HOME = 3\n    CLEAR = 4\n    SHOW_CURSOR = 5\n    HIDE_CURSOR = 6\n    ENABLE_ALT_SCREEN = 7\n    DISABLE_ALT_SCREEN = 8\n    CURSOR_UP = 9\n    CURSOR_DOWN = 10\n    CURSOR_FORWARD = 11\n    CURSOR_BACKWARD = 12\n    CURSOR_MOVE_TO_COLUMN = 13\n    CURSOR_MOVE_TO = 14\n    ERASE_IN_LINE = 15\n    SET_WINDOW_TITLE = 16\n\n\nControlCode = Union[\n    Tuple[ControlType],\n    Tuple[ControlType, Union[int, str]],\n    Tuple[ControlType, int, int],\n]\n\n\n@rich_repr()\nclass Segment(NamedTuple):\n    \"\"\"A piece of text with associated style. Segments are produced by the Console render process and\n    are ultimately converted in to strings to be written to the terminal.\n\n    Args:\n        text (str): A piece of text.\n        style (:class:`~rich.style.Style`, optional): An optional style to apply to the text.\n        control (Tuple[ControlCode], optional): Optional sequence of control codes.\n\n    Attributes:\n        cell_length (int): The cell length of this Segment.\n    \"\"\"\n\n    text: str\n    style: Optional[Style] = None\n    control: Optional[Sequence[ControlCode]] = None\n\n    @property\n    def cell_length(self) -> int:\n        \"\"\"The number of terminal cells required to display self.text.\n\n        Returns:\n            int: A number of cells.\n        \"\"\"\n        text, _style, control = self\n        return 0 if control else cell_len(text)\n\n    def __rich_repr__(self) -> Result:\n        yield self.text\n        if self.control is None:\n            if self.style is not None:\n                yield self.style\n        else:\n            yield self.style\n            yield self.control\n\n    def __bool__(self) -> bool:\n        \"\"\"Check if the segment contains text.\"\"\"\n        return bool(self.text)\n\n    @property\n    def is_control(self) -> bool:\n        \"\"\"Check if the segment contains control codes.\"\"\"\n        return self.control is not None\n\n    @classmethod\n    @lru_cache(1024 * 16)\n    def _split_cells(cls, segment: \"Segment\", cut: int) -> Tuple[\"Segment\", \"Segment\"]:\n        \"\"\"Split a segment in to two at a given cell position.\n\n        Note that splitting a double-width character, may result in that character turning\n        into two spaces.\n\n        Args:\n            segment (Segment): A segment to split.\n            cut (int): A cell position to cut on.\n\n        Returns:\n            A tuple of two segments.\n        \"\"\"\n        text, style, control = segment\n        _Segment = Segment\n        cell_length = segment.cell_length\n        if cut >= cell_length:\n            return segment, _Segment(\"\", style, control)\n\n        cell_size = get_character_cell_size\n\n        pos = int((cut / cell_length) * len(text))\n\n        while True:\n            before = text[:pos]\n            cell_pos = cell_len(before)\n            out_by = cell_pos - cut\n            if not out_by:\n                return (\n                    _Segment(before, style, control),\n                    _Segment(text[pos:], style, control),\n                )\n            if out_by == -1 and cell_size(text[pos]) == 2:\n                return (\n                    _Segment(text[:pos] + \" \", style, control),\n                    _Segment(\" \" + text[pos + 1 :], style, control),\n                )\n            if out_by == +1 and cell_size(text[pos - 1]) == 2:\n                return (\n                    _Segment(text[: pos - 1] + \" \", style, control),\n                    _Segment(\" \" + text[pos:], style, control),\n                )\n            if cell_pos < cut:\n                pos += 1\n            else:\n                pos -= 1\n\n    def split_cells(self, cut: int) -> Tuple[\"Segment\", \"Segment\"]:\n        \"\"\"Split segment in to two segments at the specified column.\n\n        If the cut point falls in the middle of a 2-cell wide character then it is replaced\n        by two spaces, to preserve the display width of the parent segment.\n\n        Args:\n            cut (int): Offset within the segment to cut.\n\n        Returns:\n            Tuple[Segment, Segment]: Two segments.\n        \"\"\"\n        text, style, control = self\n        assert cut >= 0\n\n        if _is_single_cell_widths(text):\n            # Fast path with all 1 cell characters\n            if cut >= len(text):\n                return self, Segment(\"\", style, control)\n            return (\n                Segment(text[:cut], style, control),\n                Segment(text[cut:], style, control),\n            )\n\n        return self._split_cells(self, cut)\n\n    @classmethod\n    def line(cls) -> \"Segment\":\n        \"\"\"Make a new line segment.\"\"\"\n        return cls(\"\\n\")\n\n    @classmethod\n    def apply_style(\n        cls,\n        segments: Iterable[\"Segment\"],\n        style: Optional[Style] = None,\n        post_style: Optional[Style] = None,\n    ) -> Iterable[\"Segment\"]:\n        \"\"\"Apply style(s) to an iterable of segments.\n\n        Returns an iterable of segments where the style is replaced by ``style + segment.style + post_style``.\n\n        Args:\n            segments (Iterable[Segment]): Segments to process.\n            style (Style, optional): Base style. Defaults to None.\n            post_style (Style, optional): Style to apply on top of segment style. Defaults to None.\n\n        Returns:\n            Iterable[Segments]: A new iterable of segments (possibly the same iterable).\n        \"\"\"\n        result_segments = segments\n        if style:\n            apply = style.__add__\n            result_segments = (\n                cls(text, None if control else apply(_style), control)\n                for text, _style, control in result_segments\n            )\n        if post_style:\n            result_segments = (\n                cls(\n                    text,\n                    (\n                        None\n                        if control\n                        else (_style + post_style if _style else post_style)\n                    ),\n                    control,\n                )\n                for text, _style, control in result_segments\n            )\n        return result_segments\n\n    @classmethod\n    def filter_control(\n        cls, segments: Iterable[\"Segment\"], is_control: bool = False\n    ) -> Iterable[\"Segment\"]:\n        \"\"\"Filter segments by ``is_control`` attribute.\n\n        Args:\n            segments (Iterable[Segment]): An iterable of Segment instances.\n            is_control (bool, optional): is_control flag to match in search.\n\n        Returns:\n            Iterable[Segment]: And iterable of Segment instances.\n\n        \"\"\"\n        if is_control:\n            return filter(attrgetter(\"control\"), segments)\n        else:\n            return filterfalse(attrgetter(\"control\"), segments)\n\n    @classmethod\n    def split_lines(cls, segments: Iterable[\"Segment\"]) -> Iterable[List[\"Segment\"]]:\n        \"\"\"Split a sequence of segments in to a list of lines.\n\n        Args:\n            segments (Iterable[Segment]): Segments potentially containing line feeds.\n\n        Yields:\n            Iterable[List[Segment]]: Iterable of segment lists, one per line.\n        \"\"\"\n        line: List[Segment] = []\n        append = line.append\n\n        for segment in segments:\n            if \"\\n\" in segment.text and not segment.control:\n                text, style, _ = segment\n                while text:\n                    _text, new_line, text = text.partition(\"\\n\")\n                    if _text:\n                        append(cls(_text, style))\n                    if new_line:\n                        yield line\n                        line = []\n                        append = line.append\n            else:\n                append(segment)\n        if line:\n            yield line\n\n    @classmethod\n    def split_and_crop_lines(\n        cls,\n        segments: Iterable[\"Segment\"],\n        length: int,\n        style: Optional[Style] = None,\n        pad: bool = True,\n        include_new_lines: bool = True,\n    ) -> Iterable[List[\"Segment\"]]:\n        \"\"\"Split segments in to lines, and crop lines greater than a given length.\n\n        Args:\n            segments (Iterable[Segment]): An iterable of segments, probably\n                generated from console.render.\n            length (int): Desired line length.\n            style (Style, optional): Style to use for any padding.\n            pad (bool): Enable padding of lines that are less than `length`.\n\n        Returns:\n            Iterable[List[Segment]]: An iterable of lines of segments.\n        \"\"\"\n        line: List[Segment] = []\n        append = line.append\n\n        adjust_line_length = cls.adjust_line_length\n        new_line_segment = cls(\"\\n\")\n\n        for segment in segments:\n            if \"\\n\" in segment.text and not segment.control:\n                text, segment_style, _ = segment\n                while text:\n                    _text, new_line, text = text.partition(\"\\n\")\n                    if _text:\n                        append(cls(_text, segment_style))\n                    if new_line:\n                        cropped_line = adjust_line_length(\n                            line, length, style=style, pad=pad\n                        )\n                        if include_new_lines:\n                            cropped_line.append(new_line_segment)\n                        yield cropped_line\n                        line.clear()\n            else:\n                append(segment)\n        if line:\n            yield adjust_line_length(line, length, style=style, pad=pad)\n\n    @classmethod\n    def adjust_line_length(\n        cls,\n        line: List[\"Segment\"],\n        length: int,\n        style: Optional[Style] = None,\n        pad: bool = True,\n    ) -> List[\"Segment\"]:\n        \"\"\"Adjust a line to a given width (cropping or padding as required).\n\n        Args:\n            segments (Iterable[Segment]): A list of segments in a single line.\n            length (int): The desired width of the line.\n            style (Style, optional): The style of padding if used (space on the end). Defaults to None.\n            pad (bool, optional): Pad lines with spaces if they are shorter than `length`. Defaults to True.\n\n        Returns:\n            List[Segment]: A line of segments with the desired length.\n        \"\"\"\n        line_length = sum(segment.cell_length for segment in line)\n        new_line: List[Segment]\n\n        if line_length < length:\n            if pad:\n                new_line = line + [cls(\" \" * (length - line_length), style)]\n            else:\n                new_line = line[:]\n        elif line_length > length:\n            new_line = []\n            append = new_line.append\n            line_length = 0\n            for segment in line:\n                segment_length = segment.cell_length\n                if line_length + segment_length < length or segment.control:\n                    append(segment)\n                    line_length += segment_length\n                else:\n                    text, segment_style, _ = segment\n                    text = set_cell_size(text, length - line_length)\n                    append(cls(text, segment_style))\n                    break\n        else:\n            new_line = line[:]\n        return new_line\n\n    @classmethod\n    def get_line_length(cls, line: List[\"Segment\"]) -> int:\n        \"\"\"Get the length of list of segments.\n\n        Args:\n            line (List[Segment]): A line encoded as a list of Segments (assumes no '\\\\\\\\n' characters),\n\n        Returns:\n            int: The length of the line.\n        \"\"\"\n        _cell_len = cell_len\n        return sum(_cell_len(text) for text, style, control in line if not control)\n\n    @classmethod\n    def get_shape(cls, lines: List[List[\"Segment\"]]) -> Tuple[int, int]:\n        \"\"\"Get the shape (enclosing rectangle) of a list of lines.\n\n        Args:\n            lines (List[List[Segment]]): A list of lines (no '\\\\\\\\n' characters).\n\n        Returns:\n            Tuple[int, int]: Width and height in characters.\n        \"\"\"\n        get_line_length = cls.get_line_length\n        max_width = max(get_line_length(line) for line in lines) if lines else 0\n        return (max_width, len(lines))\n\n    @classmethod\n    def set_shape(\n        cls,\n        lines: List[List[\"Segment\"]],\n        width: int,\n        height: Optional[int] = None,\n        style: Optional[Style] = None,\n        new_lines: bool = False,\n    ) -> List[List[\"Segment\"]]:\n        \"\"\"Set the shape of a list of lines (enclosing rectangle).\n\n        Args:\n            lines (List[List[Segment]]): A list of lines.\n            width (int): Desired width.\n            height (int, optional): Desired height or None for no change.\n            style (Style, optional): Style of any padding added.\n            new_lines (bool, optional): Padded lines should include \"\\n\". Defaults to False.\n\n        Returns:\n            List[List[Segment]]: New list of lines.\n        \"\"\"\n        _height = height or len(lines)\n\n        blank = (\n            [cls(\" \" * width + \"\\n\", style)] if new_lines else [cls(\" \" * width, style)]\n        )\n\n        adjust_line_length = cls.adjust_line_length\n        shaped_lines = lines[:_height]\n        shaped_lines[:] = [\n            adjust_line_length(line, width, style=style) for line in lines\n        ]\n        if len(shaped_lines) < _height:\n            shaped_lines.extend([blank] * (_height - len(shaped_lines)))\n        return shaped_lines\n\n    @classmethod\n    def align_top(\n        cls: Type[\"Segment\"],\n        lines: List[List[\"Segment\"]],\n        width: int,\n        height: int,\n        style: Style,\n        new_lines: bool = False,\n    ) -> List[List[\"Segment\"]]:\n        \"\"\"Aligns lines to top (adds extra lines to bottom as required).\n\n        Args:\n            lines (List[List[Segment]]): A list of lines.\n            width (int): Desired width.\n            height (int, optional): Desired height or None for no change.\n            style (Style): Style of any padding added.\n            new_lines (bool, optional): Padded lines should include \"\\n\". Defaults to False.\n\n        Returns:\n            List[List[Segment]]: New list of lines.\n        \"\"\"\n        extra_lines = height - len(lines)\n        if not extra_lines:\n            return lines[:]\n        lines = lines[:height]\n        blank = cls(\" \" * width + \"\\n\", style) if new_lines else cls(\" \" * width, style)\n        lines = lines + [[blank]] * extra_lines\n        return lines\n\n    @classmethod\n    def align_bottom(\n        cls: Type[\"Segment\"],\n        lines: List[List[\"Segment\"]],\n        width: int,\n        height: int,\n        style: Style,\n        new_lines: bool = False,\n    ) -> List[List[\"Segment\"]]:\n        \"\"\"Aligns render to bottom (adds extra lines above as required).\n\n        Args:\n            lines (List[List[Segment]]): A list of lines.\n            width (int): Desired width.\n            height (int, optional): Desired height or None for no change.\n            style (Style): Style of any padding added. Defaults to None.\n            new_lines (bool, optional): Padded lines should include \"\\n\". Defaults to False.\n\n        Returns:\n            List[List[Segment]]: New list of lines.\n        \"\"\"\n        extra_lines = height - len(lines)\n        if not extra_lines:\n            return lines[:]\n        lines = lines[:height]\n        blank = cls(\" \" * width + \"\\n\", style) if new_lines else cls(\" \" * width, style)\n        lines = [[blank]] * extra_lines + lines\n        return lines\n\n    @classmethod\n    def align_middle(\n        cls: Type[\"Segment\"],\n        lines: List[List[\"Segment\"]],\n        width: int,\n        height: int,\n        style: Style,\n        new_lines: bool = False,\n    ) -> List[List[\"Segment\"]]:\n        \"\"\"Aligns lines to middle (adds extra lines to above and below as required).\n\n        Args:\n            lines (List[List[Segment]]): A list of lines.\n            width (int): Desired width.\n            height (int, optional): Desired height or None for no change.\n            style (Style): Style of any padding added.\n            new_lines (bool, optional): Padded lines should include \"\\n\". Defaults to False.\n\n        Returns:\n            List[List[Segment]]: New list of lines.\n        \"\"\"\n        extra_lines = height - len(lines)\n        if not extra_lines:\n            return lines[:]\n        lines = lines[:height]\n        blank = cls(\" \" * width + \"\\n\", style) if new_lines else cls(\" \" * width, style)\n        top_lines = extra_lines // 2\n        bottom_lines = extra_lines - top_lines\n        lines = [[blank]] * top_lines + lines + [[blank]] * bottom_lines\n        return lines\n\n    @classmethod\n    def simplify(cls, segments: Iterable[\"Segment\"]) -> Iterable[\"Segment\"]:\n        \"\"\"Simplify an iterable of segments by combining contiguous segments with the same style.\n\n        Args:\n            segments (Iterable[Segment]): An iterable of segments.\n\n        Returns:\n            Iterable[Segment]: A possibly smaller iterable of segments that will render the same way.\n        \"\"\"\n        iter_segments = iter(segments)\n        try:\n            last_segment = next(iter_segments)\n        except StopIteration:\n            return\n\n        _Segment = Segment\n        for segment in iter_segments:\n            if last_segment.style == segment.style and not segment.control:\n                last_segment = _Segment(\n                    last_segment.text + segment.text, last_segment.style\n                )\n            else:\n                yield last_segment\n                last_segment = segment\n        yield last_segment\n\n    @classmethod\n    def strip_links(cls, segments: Iterable[\"Segment\"]) -> Iterable[\"Segment\"]:\n        \"\"\"Remove all links from an iterable of styles.\n\n        Args:\n            segments (Iterable[Segment]): An iterable segments.\n\n        Yields:\n            Segment: Segments with link removed.\n        \"\"\"\n        for segment in segments:\n            if segment.control or segment.style is None:\n                yield segment\n            else:\n                text, style, _control = segment\n                yield cls(text, style.update_link(None) if style else None)\n\n    @classmethod\n    def strip_styles(cls, segments: Iterable[\"Segment\"]) -> Iterable[\"Segment\"]:\n        \"\"\"Remove all styles from an iterable of segments.\n\n        Args:\n            segments (Iterable[Segment]): An iterable segments.\n\n        Yields:\n            Segment: Segments with styles replace with None\n        \"\"\"\n        for text, _style, control in segments:\n            yield cls(text, None, control)\n\n    @classmethod\n    def remove_color(cls, segments: Iterable[\"Segment\"]) -> Iterable[\"Segment\"]:\n        \"\"\"Remove all color from an iterable of segments.\n\n        Args:\n            segments (Iterable[Segment]): An iterable segments.\n\n        Yields:\n            Segment: Segments with colorless style.\n        \"\"\"\n\n        cache: Dict[Style, Style] = {}\n        for text, style, control in segments:\n            if style:\n                colorless_style = cache.get(style)\n                if colorless_style is None:\n                    colorless_style = style.without_color\n                    cache[style] = colorless_style\n                yield cls(text, colorless_style, control)\n            else:\n                yield cls(text, None, control)\n\n    @classmethod\n    def divide(\n        cls, segments: Iterable[\"Segment\"], cuts: Iterable[int]\n    ) -> Iterable[List[\"Segment\"]]:\n        \"\"\"Divides an iterable of segments in to portions.\n\n        Args:\n            cuts (Iterable[int]): Cell positions where to divide.\n\n        Yields:\n            [Iterable[List[Segment]]]: An iterable of Segments in List.\n        \"\"\"\n        split_segments: List[\"Segment\"] = []\n        add_segment = split_segments.append\n\n        iter_cuts = iter(cuts)\n\n        while True:\n            cut = next(iter_cuts, -1)\n            if cut == -1:\n                return\n            if cut != 0:\n                break\n            yield []\n        pos = 0\n\n        segments_clear = split_segments.clear\n        segments_copy = split_segments.copy\n\n        _cell_len = cached_cell_len\n        for segment in segments:\n            text, _style, control = segment\n            while text:\n                end_pos = pos if control else pos + _cell_len(text)\n                if end_pos < cut:\n                    add_segment(segment)\n                    pos = end_pos\n                    break\n\n                if end_pos == cut:\n                    add_segment(segment)\n                    yield segments_copy()\n                    segments_clear()\n                    pos = end_pos\n\n                    cut = next(iter_cuts, -1)\n                    if cut == -1:\n                        if split_segments:\n                            yield segments_copy()\n                        return\n\n                    break\n\n                else:\n                    before, segment = segment.split_cells(cut - pos)\n                    text, _style, control = segment\n                    add_segment(before)\n                    yield segments_copy()\n                    segments_clear()\n                    pos = cut\n\n                cut = next(iter_cuts, -1)\n                if cut == -1:\n                    if split_segments:\n                        yield segments_copy()\n                    return\n\n        yield segments_copy()\n\n\nclass Segments:\n    \"\"\"A simple renderable to render an iterable of segments. This class may be useful if\n    you want to print segments outside of a __rich_console__ method.\n\n    Args:\n        segments (Iterable[Segment]): An iterable of segments.\n        new_lines (bool, optional): Add new lines between segments. Defaults to False.\n    \"\"\"\n\n    def __init__(self, segments: Iterable[Segment], new_lines: bool = False) -> None:\n        self.segments = list(segments)\n        self.new_lines = new_lines\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        if self.new_lines:\n            line = Segment.line()\n            for segment in self.segments:\n                yield segment\n                yield line\n        else:\n            yield from self.segments\n\n\nclass SegmentLines:\n    def __init__(self, lines: Iterable[List[Segment]], new_lines: bool = False) -> None:\n        \"\"\"A simple renderable containing a number of lines of segments. May be used as an intermediate\n        in rendering process.\n\n        Args:\n            lines (Iterable[List[Segment]]): Lists of segments forming lines.\n            new_lines (bool, optional): Insert new lines after each line. Defaults to False.\n        \"\"\"\n        self.lines = list(lines)\n        self.new_lines = new_lines\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        if self.new_lines:\n            new_line = Segment.line()\n            for line in self.lines:\n                yield from line\n                yield new_line\n        else:\n            for line in self.lines:\n                yield from line\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from pip._vendor.rich.console import Console\n    from pip._vendor.rich.syntax import Syntax\n    from pip._vendor.rich.text import Text\n\n    code = \"\"\"from rich.console import Console\nconsole = Console()\ntext = Text.from_markup(\"Hello, [bold magenta]World[/]!\")\nconsole.print(text)\"\"\"\n\n    text = Text.from_markup(\"Hello, [bold magenta]World[/]!\")\n\n    console = Console()\n\n    console.rule(\"rich.Segment\")\n    console.print(\n        \"A Segment is the last step in the Rich render process before generating text with ANSI codes.\"\n    )\n    console.print(\"\\nConsider the following code:\\n\")\n    console.print(Syntax(code, \"python\", line_numbers=True))\n    console.print()\n    console.print(\n        \"When you call [b]print()[/b], Rich [i]renders[/i] the object in to the following:\\n\"\n    )\n    fragments = list(console.render(text))\n    console.print(fragments)\n    console.print()\n    console.print(\"The Segments are then processed to produce the following output:\\n\")\n    console.print(text)\n    console.print(\n        \"\\nYou will only need to know this if you are implementing your own Rich renderables.\"\n    )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/spinner.py","size":4364,"sha1":"3969fca0a1346f1d7f18f697170520d170800634","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import cast, List, Optional, TYPE_CHECKING, Union\n\nfrom ._spinners import SPINNERS\nfrom .measure import Measurement\nfrom .table import Table\nfrom .text import Text\n\nif TYPE_CHECKING:\n    from .console import Console, ConsoleOptions, RenderResult, RenderableType\n    from .style import StyleType\n\n\nclass Spinner:\n    \"\"\"A spinner animation.\n\n    Args:\n        name (str): Name of spinner (run python -m rich.spinner).\n        text (RenderableType, optional): A renderable to display at the right of the spinner (str or Text typically). Defaults to \"\".\n        style (StyleType, optional): Style for spinner animation. Defaults to None.\n        speed (float, optional): Speed factor for animation. Defaults to 1.0.\n\n    Raises:\n        KeyError: If name isn't one of the supported spinner animations.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        text: \"RenderableType\" = \"\",\n        *,\n        style: Optional[\"StyleType\"] = None,\n        speed: float = 1.0,\n    ) -> None:\n        try:\n            spinner = SPINNERS[name]\n        except KeyError:\n            raise KeyError(f\"no spinner called {name!r}\")\n        self.text: \"Union[RenderableType, Text]\" = (\n            Text.from_markup(text) if isinstance(text, str) else text\n        )\n        self.name = name\n        self.frames = cast(List[str], spinner[\"frames\"])[:]\n        self.interval = cast(float, spinner[\"interval\"])\n        self.start_time: Optional[float] = None\n        self.style = style\n        self.speed = speed\n        self.frame_no_offset: float = 0.0\n        self._update_speed = 0.0\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        yield self.render(console.get_time())\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> Measurement:\n        text = self.render(0)\n        return Measurement.get(console, options, text)\n\n    def render(self, time: float) -> \"RenderableType\":\n        \"\"\"Render the spinner for a given time.\n\n        Args:\n            time (float): Time in seconds.\n\n        Returns:\n            RenderableType: A renderable containing animation frame.\n        \"\"\"\n        if self.start_time is None:\n            self.start_time = time\n\n        frame_no = ((time - self.start_time) * self.speed) / (\n            self.interval / 1000.0\n        ) + self.frame_no_offset\n        frame = Text(\n            self.frames[int(frame_no) % len(self.frames)], style=self.style or \"\"\n        )\n\n        if self._update_speed:\n            self.frame_no_offset = frame_no\n            self.start_time = time\n            self.speed = self._update_speed\n            self._update_speed = 0.0\n\n        if not self.text:\n            return frame\n        elif isinstance(self.text, (str, Text)):\n            return Text.assemble(frame, \" \", self.text)\n        else:\n            table = Table.grid(padding=1)\n            table.add_row(frame, self.text)\n            return table\n\n    def update(\n        self,\n        *,\n        text: \"RenderableType\" = \"\",\n        style: Optional[\"StyleType\"] = None,\n        speed: Optional[float] = None,\n    ) -> None:\n        \"\"\"Updates attributes of a spinner after it has been started.\n\n        Args:\n            text (RenderableType, optional): A renderable to display at the right of the spinner (str or Text typically). Defaults to \"\".\n            style (StyleType, optional): Style for spinner animation. Defaults to None.\n            speed (float, optional): Speed factor for animation. Defaults to None.\n        \"\"\"\n        if text:\n            self.text = Text.from_markup(text) if isinstance(text, str) else text\n        if style:\n            self.style = style\n        if speed:\n            self._update_speed = speed\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from time import sleep\n\n    from .columns import Columns\n    from .panel import Panel\n    from .live import Live\n\n    all_spinners = Columns(\n        [\n            Spinner(spinner_name, text=Text(repr(spinner_name), style=\"green\"))\n            for spinner_name in sorted(SPINNERS.keys())\n        ],\n        column_first=True,\n        expand=True,\n    )\n\n    with Live(\n        Panel(all_spinners, title=\"Spinners\", border_style=\"blue\"),\n        refresh_per_second=20,\n    ) as live:\n        while True:\n            sleep(0.1)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/status.py","size":4424,"sha1":"50b0610610fe2fa9df8cc1448ddc09bc51d1ba5e","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from types import TracebackType\nfrom typing import Optional, Type\n\nfrom .console import Console, RenderableType\nfrom .jupyter import JupyterMixin\nfrom .live import Live\nfrom .spinner import Spinner\nfrom .style import StyleType\n\n\nclass Status(JupyterMixin):\n    \"\"\"Displays a status indicator with a 'spinner' animation.\n\n    Args:\n        status (RenderableType): A status renderable (str or Text typically).\n        console (Console, optional): Console instance to use, or None for global console. Defaults to None.\n        spinner (str, optional): Name of spinner animation (see python -m rich.spinner). Defaults to \"dots\".\n        spinner_style (StyleType, optional): Style of spinner. Defaults to \"status.spinner\".\n        speed (float, optional): Speed factor for spinner animation. Defaults to 1.0.\n        refresh_per_second (float, optional): Number of refreshes per second. Defaults to 12.5.\n    \"\"\"\n\n    def __init__(\n        self,\n        status: RenderableType,\n        *,\n        console: Optional[Console] = None,\n        spinner: str = \"dots\",\n        spinner_style: StyleType = \"status.spinner\",\n        speed: float = 1.0,\n        refresh_per_second: float = 12.5,\n    ):\n        self.status = status\n        self.spinner_style = spinner_style\n        self.speed = speed\n        self._spinner = Spinner(spinner, text=status, style=spinner_style, speed=speed)\n        self._live = Live(\n            self.renderable,\n            console=console,\n            refresh_per_second=refresh_per_second,\n            transient=True,\n        )\n\n    @property\n    def renderable(self) -> Spinner:\n        return self._spinner\n\n    @property\n    def console(self) -> \"Console\":\n        \"\"\"Get the Console used by the Status objects.\"\"\"\n        return self._live.console\n\n    def update(\n        self,\n        status: Optional[RenderableType] = None,\n        *,\n        spinner: Optional[str] = None,\n        spinner_style: Optional[StyleType] = None,\n        speed: Optional[float] = None,\n    ) -> None:\n        \"\"\"Update status.\n\n        Args:\n            status (Optional[RenderableType], optional): New status renderable or None for no change. Defaults to None.\n            spinner (Optional[str], optional): New spinner or None for no change. Defaults to None.\n            spinner_style (Optional[StyleType], optional): New spinner style or None for no change. Defaults to None.\n            speed (Optional[float], optional): Speed factor for spinner animation or None for no change. Defaults to None.\n        \"\"\"\n        if status is not None:\n            self.status = status\n        if spinner_style is not None:\n            self.spinner_style = spinner_style\n        if speed is not None:\n            self.speed = speed\n        if spinner is not None:\n            self._spinner = Spinner(\n                spinner, text=self.status, style=self.spinner_style, speed=self.speed\n            )\n            self._live.update(self.renderable, refresh=True)\n        else:\n            self._spinner.update(\n                text=self.status, style=self.spinner_style, speed=self.speed\n            )\n\n    def start(self) -> None:\n        \"\"\"Start the status animation.\"\"\"\n        self._live.start()\n\n    def stop(self) -> None:\n        \"\"\"Stop the spinner animation.\"\"\"\n        self._live.stop()\n\n    def __rich__(self) -> RenderableType:\n        return self.renderable\n\n    def __enter__(self) -> \"Status\":\n        self.start()\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -> None:\n        self.stop()\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from time import sleep\n\n    from .console import Console\n\n    console = Console()\n    with console.status(\"[magenta]Covid detector booting up\") as status:\n        sleep(3)\n        console.log(\"Importing advanced AI\")\n        sleep(3)\n        console.log(\"Advanced Covid AI Ready\")\n        sleep(3)\n        status.update(status=\"[bold blue] Scanning for Covid\", spinner=\"earth\")\n        sleep(3)\n        console.log(\"Found 10,000,000,000 copies of Covid32.exe\")\n        sleep(3)\n        status.update(\n            status=\"[bold red]Moving Covid32.exe to Trash\",\n            spinner=\"bouncingBall\",\n            spinner_style=\"yellow\",\n        )\n        sleep(5)\n    console.print(\"[bold green]Covid deleted successfully\")\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/style.py","size":27067,"sha1":"4c436e399961ccefbd37300ff93fa3eee4278258","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\nfrom functools import lru_cache\nfrom marshal import dumps, loads\nfrom random import randint\nfrom typing import Any, Dict, Iterable, List, Optional, Type, Union, cast\n\nfrom . import errors\nfrom .color import Color, ColorParseError, ColorSystem, blend_rgb\nfrom .repr import Result, rich_repr\nfrom .terminal_theme import DEFAULT_TERMINAL_THEME, TerminalTheme\n\n# Style instances and style definitions are often interchangeable\nStyleType = Union[str, \"Style\"]\n\n\nclass _Bit:\n    \"\"\"A descriptor to get/set a style attribute bit.\"\"\"\n\n    __slots__ = [\"bit\"]\n\n    def __init__(self, bit_no: int) -> None:\n        self.bit = 1 << bit_no\n\n    def __get__(self, obj: \"Style\", objtype: Type[\"Style\"]) -> Optional[bool]:\n        if obj._set_attributes & self.bit:\n            return obj._attributes & self.bit != 0\n        return None\n\n\n@rich_repr\nclass Style:\n    \"\"\"A terminal style.\n\n    A terminal style consists of a color (`color`), a background color (`bgcolor`), and a number of attributes, such\n    as bold, italic etc. The attributes have 3 states: they can either be on\n    (``True``), off (``False``), or not set (``None``).\n\n    Args:\n        color (Union[Color, str], optional): Color of terminal text. Defaults to None.\n        bgcolor (Union[Color, str], optional): Color of terminal background. Defaults to None.\n        bold (bool, optional): Enable bold text. Defaults to None.\n        dim (bool, optional): Enable dim text. Defaults to None.\n        italic (bool, optional): Enable italic text. Defaults to None.\n        underline (bool, optional): Enable underlined text. Defaults to None.\n        blink (bool, optional): Enabled blinking text. Defaults to None.\n        blink2 (bool, optional): Enable fast blinking text. Defaults to None.\n        reverse (bool, optional): Enabled reverse text. Defaults to None.\n        conceal (bool, optional): Enable concealed text. Defaults to None.\n        strike (bool, optional): Enable strikethrough text. Defaults to None.\n        underline2 (bool, optional): Enable doubly underlined text. Defaults to None.\n        frame (bool, optional): Enable framed text. Defaults to None.\n        encircle (bool, optional): Enable encircled text. Defaults to None.\n        overline (bool, optional): Enable overlined text. Defaults to None.\n        link (str, link): Link URL. Defaults to None.\n\n    \"\"\"\n\n    _color: Optional[Color]\n    _bgcolor: Optional[Color]\n    _attributes: int\n    _set_attributes: int\n    _hash: Optional[int]\n    _null: bool\n    _meta: Optional[bytes]\n\n    __slots__ = [\n        \"_color\",\n        \"_bgcolor\",\n        \"_attributes\",\n        \"_set_attributes\",\n        \"_link\",\n        \"_link_id\",\n        \"_ansi\",\n        \"_style_definition\",\n        \"_hash\",\n        \"_null\",\n        \"_meta\",\n    ]\n\n    # maps bits on to SGR parameter\n    _style_map = {\n        0: \"1\",\n        1: \"2\",\n        2: \"3\",\n        3: \"4\",\n        4: \"5\",\n        5: \"6\",\n        6: \"7\",\n        7: \"8\",\n        8: \"9\",\n        9: \"21\",\n        10: \"51\",\n        11: \"52\",\n        12: \"53\",\n    }\n\n    STYLE_ATTRIBUTES = {\n        \"dim\": \"dim\",\n        \"d\": \"dim\",\n        \"bold\": \"bold\",\n        \"b\": \"bold\",\n        \"italic\": \"italic\",\n        \"i\": \"italic\",\n        \"underline\": \"underline\",\n        \"u\": \"underline\",\n        \"blink\": \"blink\",\n        \"blink2\": \"blink2\",\n        \"reverse\": \"reverse\",\n        \"r\": \"reverse\",\n        \"conceal\": \"conceal\",\n        \"c\": \"conceal\",\n        \"strike\": \"strike\",\n        \"s\": \"strike\",\n        \"underline2\": \"underline2\",\n        \"uu\": \"underline2\",\n        \"frame\": \"frame\",\n        \"encircle\": \"encircle\",\n        \"overline\": \"overline\",\n        \"o\": \"overline\",\n    }\n\n    def __init__(\n        self,\n        *,\n        color: Optional[Union[Color, str]] = None,\n        bgcolor: Optional[Union[Color, str]] = None,\n        bold: Optional[bool] = None,\n        dim: Optional[bool] = None,\n        italic: Optional[bool] = None,\n        underline: Optional[bool] = None,\n        blink: Optional[bool] = None,\n        blink2: Optional[bool] = None,\n        reverse: Optional[bool] = None,\n        conceal: Optional[bool] = None,\n        strike: Optional[bool] = None,\n        underline2: Optional[bool] = None,\n        frame: Optional[bool] = None,\n        encircle: Optional[bool] = None,\n        overline: Optional[bool] = None,\n        link: Optional[str] = None,\n        meta: Optional[Dict[str, Any]] = None,\n    ):\n        self._ansi: Optional[str] = None\n        self._style_definition: Optional[str] = None\n\n        def _make_color(color: Union[Color, str]) -> Color:\n            return color if isinstance(color, Color) else Color.parse(color)\n\n        self._color = None if color is None else _make_color(color)\n        self._bgcolor = None if bgcolor is None else _make_color(bgcolor)\n        self._set_attributes = sum(\n            (\n                bold is not None,\n                dim is not None and 2,\n                italic is not None and 4,\n                underline is not None and 8,\n                blink is not None and 16,\n                blink2 is not None and 32,\n                reverse is not None and 64,\n                conceal is not None and 128,\n                strike is not None and 256,\n                underline2 is not None and 512,\n                frame is not None and 1024,\n                encircle is not None and 2048,\n                overline is not None and 4096,\n            )\n        )\n        self._attributes = (\n            sum(\n                (\n                    bold and 1 or 0,\n                    dim and 2 or 0,\n                    italic and 4 or 0,\n                    underline and 8 or 0,\n                    blink and 16 or 0,\n                    blink2 and 32 or 0,\n                    reverse and 64 or 0,\n                    conceal and 128 or 0,\n                    strike and 256 or 0,\n                    underline2 and 512 or 0,\n                    frame and 1024 or 0,\n                    encircle and 2048 or 0,\n                    overline and 4096 or 0,\n                )\n            )\n            if self._set_attributes\n            else 0\n        )\n\n        self._link = link\n        self._meta = None if meta is None else dumps(meta)\n        self._link_id = (\n            f\"{randint(0, 999999)}{hash(self._meta)}\" if (link or meta) else \"\"\n        )\n        self._hash: Optional[int] = None\n        self._null = not (self._set_attributes or color or bgcolor or link or meta)\n\n    @classmethod\n    def null(cls) -> \"Style\":\n        \"\"\"Create an 'null' style, equivalent to Style(), but more performant.\"\"\"\n        return NULL_STYLE\n\n    @classmethod\n    def from_color(\n        cls, color: Optional[Color] = None, bgcolor: Optional[Color] = None\n    ) -> \"Style\":\n        \"\"\"Create a new style with colors and no attributes.\n\n        Returns:\n            color (Optional[Color]): A (foreground) color, or None for no color. Defaults to None.\n            bgcolor (Optional[Color]): A (background) color, or None for no color. Defaults to None.\n        \"\"\"\n        style: Style = cls.__new__(Style)\n        style._ansi = None\n        style._style_definition = None\n        style._color = color\n        style._bgcolor = bgcolor\n        style._set_attributes = 0\n        style._attributes = 0\n        style._link = None\n        style._link_id = \"\"\n        style._meta = None\n        style._null = not (color or bgcolor)\n        style._hash = None\n        return style\n\n    @classmethod\n    def from_meta(cls, meta: Optional[Dict[str, Any]]) -> \"Style\":\n        \"\"\"Create a new style with meta data.\n\n        Returns:\n            meta (Optional[Dict[str, Any]]): A dictionary of meta data. Defaults to None.\n        \"\"\"\n        style: Style = cls.__new__(Style)\n        style._ansi = None\n        style._style_definition = None\n        style._color = None\n        style._bgcolor = None\n        style._set_attributes = 0\n        style._attributes = 0\n        style._link = None\n        style._meta = dumps(meta)\n        style._link_id = f\"{randint(0, 999999)}{hash(style._meta)}\"\n        style._hash = None\n        style._null = not (meta)\n        return style\n\n    @classmethod\n    def on(cls, meta: Optional[Dict[str, Any]] = None, **handlers: Any) -> \"Style\":\n        \"\"\"Create a blank style with meta information.\n\n        Example:\n            style = Style.on(click=self.on_click)\n\n        Args:\n            meta (Optional[Dict[str, Any]], optional): An optional dict of meta information.\n            **handlers (Any): Keyword arguments are translated in to handlers.\n\n        Returns:\n            Style: A Style with meta information attached.\n        \"\"\"\n        meta = {} if meta is None else meta\n        meta.update({f\"@{key}\": value for key, value in handlers.items()})\n        return cls.from_meta(meta)\n\n    bold = _Bit(0)\n    dim = _Bit(1)\n    italic = _Bit(2)\n    underline = _Bit(3)\n    blink = _Bit(4)\n    blink2 = _Bit(5)\n    reverse = _Bit(6)\n    conceal = _Bit(7)\n    strike = _Bit(8)\n    underline2 = _Bit(9)\n    frame = _Bit(10)\n    encircle = _Bit(11)\n    overline = _Bit(12)\n\n    @property\n    def link_id(self) -> str:\n        \"\"\"Get a link id, used in ansi code for links.\"\"\"\n        return self._link_id\n\n    def __str__(self) -> str:\n        \"\"\"Re-generate style definition from attributes.\"\"\"\n        if self._style_definition is None:\n            attributes: List[str] = []\n            append = attributes.append\n            bits = self._set_attributes\n            if bits & 0b0000000001111:\n                if bits & 1:\n                    append(\"bold\" if self.bold else \"not bold\")\n                if bits & (1 << 1):\n                    append(\"dim\" if self.dim else \"not dim\")\n                if bits & (1 << 2):\n                    append(\"italic\" if self.italic else \"not italic\")\n                if bits & (1 << 3):\n                    append(\"underline\" if self.underline else \"not underline\")\n            if bits & 0b0000111110000:\n                if bits & (1 << 4):\n                    append(\"blink\" if self.blink else \"not blink\")\n                if bits & (1 << 5):\n                    append(\"blink2\" if self.blink2 else \"not blink2\")\n                if bits & (1 << 6):\n                    append(\"reverse\" if self.reverse else \"not reverse\")\n                if bits & (1 << 7):\n                    append(\"conceal\" if self.conceal else \"not conceal\")\n                if bits & (1 << 8):\n                    append(\"strike\" if self.strike else \"not strike\")\n            if bits & 0b1111000000000:\n                if bits & (1 << 9):\n                    append(\"underline2\" if self.underline2 else \"not underline2\")\n                if bits & (1 << 10):\n                    append(\"frame\" if self.frame else \"not frame\")\n                if bits & (1 << 11):\n                    append(\"encircle\" if self.encircle else \"not encircle\")\n                if bits & (1 << 12):\n                    append(\"overline\" if self.overline else \"not overline\")\n            if self._color is not None:\n                append(self._color.name)\n            if self._bgcolor is not None:\n                append(\"on\")\n                append(self._bgcolor.name)\n            if self._link:\n                append(\"link\")\n                append(self._link)\n            self._style_definition = \" \".join(attributes) or \"none\"\n        return self._style_definition\n\n    def __bool__(self) -> bool:\n        \"\"\"A Style is false if it has no attributes, colors, or links.\"\"\"\n        return not self._null\n\n    def _make_ansi_codes(self, color_system: ColorSystem) -> str:\n        \"\"\"Generate ANSI codes for this style.\n\n        Args:\n            color_system (ColorSystem): Color system.\n\n        Returns:\n            str: String containing codes.\n        \"\"\"\n\n        if self._ansi is None:\n            sgr: List[str] = []\n            append = sgr.append\n            _style_map = self._style_map\n            attributes = self._attributes & self._set_attributes\n            if attributes:\n                if attributes & 1:\n                    append(_style_map[0])\n                if attributes & 2:\n                    append(_style_map[1])\n                if attributes & 4:\n                    append(_style_map[2])\n                if attributes & 8:\n                    append(_style_map[3])\n                if attributes & 0b0000111110000:\n                    for bit in range(4, 9):\n                        if attributes & (1 << bit):\n                            append(_style_map[bit])\n                if attributes & 0b1111000000000:\n                    for bit in range(9, 13):\n                        if attributes & (1 << bit):\n                            append(_style_map[bit])\n            if self._color is not None:\n                sgr.extend(self._color.downgrade(color_system).get_ansi_codes())\n            if self._bgcolor is not None:\n                sgr.extend(\n                    self._bgcolor.downgrade(color_system).get_ansi_codes(\n                        foreground=False\n                    )\n                )\n            self._ansi = \";\".join(sgr)\n        return self._ansi\n\n    @classmethod\n    @lru_cache(maxsize=1024)\n    def normalize(cls, style: str) -> str:\n        \"\"\"Normalize a style definition so that styles with the same effect have the same string\n        representation.\n\n        Args:\n            style (str): A style definition.\n\n        Returns:\n            str: Normal form of style definition.\n        \"\"\"\n        try:\n            return str(cls.parse(style))\n        except errors.StyleSyntaxError:\n            return style.strip().lower()\n\n    @classmethod\n    def pick_first(cls, *values: Optional[StyleType]) -> StyleType:\n        \"\"\"Pick first non-None style.\"\"\"\n        for value in values:\n            if value is not None:\n                return value\n        raise ValueError(\"expected at least one non-None style\")\n\n    def __rich_repr__(self) -> Result:\n        yield \"color\", self.color, None\n        yield \"bgcolor\", self.bgcolor, None\n        yield \"bold\", self.bold, None,\n        yield \"dim\", self.dim, None,\n        yield \"italic\", self.italic, None\n        yield \"underline\", self.underline, None,\n        yield \"blink\", self.blink, None\n        yield \"blink2\", self.blink2, None\n        yield \"reverse\", self.reverse, None\n        yield \"conceal\", self.conceal, None\n        yield \"strike\", self.strike, None\n        yield \"underline2\", self.underline2, None\n        yield \"frame\", self.frame, None\n        yield \"encircle\", self.encircle, None\n        yield \"link\", self.link, None\n        if self._meta:\n            yield \"meta\", self.meta\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, Style):\n            return NotImplemented\n        return self.__hash__() == other.__hash__()\n\n    def __ne__(self, other: Any) -> bool:\n        if not isinstance(other, Style):\n            return NotImplemented\n        return self.__hash__() != other.__hash__()\n\n    def __hash__(self) -> int:\n        if self._hash is not None:\n            return self._hash\n        self._hash = hash(\n            (\n                self._color,\n                self._bgcolor,\n                self._attributes,\n                self._set_attributes,\n                self._link,\n                self._meta,\n            )\n        )\n        return self._hash\n\n    @property\n    def color(self) -> Optional[Color]:\n        \"\"\"The foreground color or None if it is not set.\"\"\"\n        return self._color\n\n    @property\n    def bgcolor(self) -> Optional[Color]:\n        \"\"\"The background color or None if it is not set.\"\"\"\n        return self._bgcolor\n\n    @property\n    def link(self) -> Optional[str]:\n        \"\"\"Link text, if set.\"\"\"\n        return self._link\n\n    @property\n    def transparent_background(self) -> bool:\n        \"\"\"Check if the style specified a transparent background.\"\"\"\n        return self.bgcolor is None or self.bgcolor.is_default\n\n    @property\n    def background_style(self) -> \"Style\":\n        \"\"\"A Style with background only.\"\"\"\n        return Style(bgcolor=self.bgcolor)\n\n    @property\n    def meta(self) -> Dict[str, Any]:\n        \"\"\"Get meta information (can not be changed after construction).\"\"\"\n        return {} if self._meta is None else cast(Dict[str, Any], loads(self._meta))\n\n    @property\n    def without_color(self) -> \"Style\":\n        \"\"\"Get a copy of the style with color removed.\"\"\"\n        if self._null:\n            return NULL_STYLE\n        style: Style = self.__new__(Style)\n        style._ansi = None\n        style._style_definition = None\n        style._color = None\n        style._bgcolor = None\n        style._attributes = self._attributes\n        style._set_attributes = self._set_attributes\n        style._link = self._link\n        style._link_id = f\"{randint(0, 999999)}\" if self._link else \"\"\n        style._null = False\n        style._meta = None\n        style._hash = None\n        return style\n\n    @classmethod\n    @lru_cache(maxsize=4096)\n    def parse(cls, style_definition: str) -> \"Style\":\n        \"\"\"Parse a style definition.\n\n        Args:\n            style_definition (str): A string containing a style.\n\n        Raises:\n            errors.StyleSyntaxError: If the style definition syntax is invalid.\n\n        Returns:\n            `Style`: A Style instance.\n        \"\"\"\n        if style_definition.strip() == \"none\" or not style_definition:\n            return cls.null()\n\n        STYLE_ATTRIBUTES = cls.STYLE_ATTRIBUTES\n        color: Optional[str] = None\n        bgcolor: Optional[str] = None\n        attributes: Dict[str, Optional[Any]] = {}\n        link: Optional[str] = None\n\n        words = iter(style_definition.split())\n        for original_word in words:\n            word = original_word.lower()\n            if word == \"on\":\n                word = next(words, \"\")\n                if not word:\n                    raise errors.StyleSyntaxError(\"color expected after 'on'\")\n                try:\n                    Color.parse(word) is None\n                except ColorParseError as error:\n                    raise errors.StyleSyntaxError(\n                        f\"unable to parse {word!r} as background color; {error}\"\n                    ) from None\n                bgcolor = word\n\n            elif word == \"not\":\n                word = next(words, \"\")\n                attribute = STYLE_ATTRIBUTES.get(word)\n                if attribute is None:\n                    raise errors.StyleSyntaxError(\n                        f\"expected style attribute after 'not', found {word!r}\"\n                    )\n                attributes[attribute] = False\n\n            elif word == \"link\":\n                word = next(words, \"\")\n                if not word:\n                    raise errors.StyleSyntaxError(\"URL expected after 'link'\")\n                link = word\n\n            elif word in STYLE_ATTRIBUTES:\n                attributes[STYLE_ATTRIBUTES[word]] = True\n\n            else:\n                try:\n                    Color.parse(word)\n                except ColorParseError as error:\n                    raise errors.StyleSyntaxError(\n                        f\"unable to parse {word!r} as color; {error}\"\n                    ) from None\n                color = word\n        style = Style(color=color, bgcolor=bgcolor, link=link, **attributes)\n        return style\n\n    @lru_cache(maxsize=1024)\n    def get_html_style(self, theme: Optional[TerminalTheme] = None) -> str:\n        \"\"\"Get a CSS style rule.\"\"\"\n        theme = theme or DEFAULT_TERMINAL_THEME\n        css: List[str] = []\n        append = css.append\n\n        color = self.color\n        bgcolor = self.bgcolor\n        if self.reverse:\n            color, bgcolor = bgcolor, color\n        if self.dim:\n            foreground_color = (\n                theme.foreground_color if color is None else color.get_truecolor(theme)\n            )\n            color = Color.from_triplet(\n                blend_rgb(foreground_color, theme.background_color, 0.5)\n            )\n        if color is not None:\n            theme_color = color.get_truecolor(theme)\n            append(f\"color: {theme_color.hex}\")\n            append(f\"text-decoration-color: {theme_color.hex}\")\n        if bgcolor is not None:\n            theme_color = bgcolor.get_truecolor(theme, foreground=False)\n            append(f\"background-color: {theme_color.hex}\")\n        if self.bold:\n            append(\"font-weight: bold\")\n        if self.italic:\n            append(\"font-style: italic\")\n        if self.underline:\n            append(\"text-decoration: underline\")\n        if self.strike:\n            append(\"text-decoration: line-through\")\n        if self.overline:\n            append(\"text-decoration: overline\")\n        return \"; \".join(css)\n\n    @classmethod\n    def combine(cls, styles: Iterable[\"Style\"]) -> \"Style\":\n        \"\"\"Combine styles and get result.\n\n        Args:\n            styles (Iterable[Style]): Styles to combine.\n\n        Returns:\n            Style: A new style instance.\n        \"\"\"\n        iter_styles = iter(styles)\n        return sum(iter_styles, next(iter_styles))\n\n    @classmethod\n    def chain(cls, *styles: \"Style\") -> \"Style\":\n        \"\"\"Combine styles from positional argument in to a single style.\n\n        Args:\n            *styles (Iterable[Style]): Styles to combine.\n\n        Returns:\n            Style: A new style instance.\n        \"\"\"\n        iter_styles = iter(styles)\n        return sum(iter_styles, next(iter_styles))\n\n    def copy(self) -> \"Style\":\n        \"\"\"Get a copy of this style.\n\n        Returns:\n            Style: A new Style instance with identical attributes.\n        \"\"\"\n        if self._null:\n            return NULL_STYLE\n        style: Style = self.__new__(Style)\n        style._ansi = self._ansi\n        style._style_definition = self._style_definition\n        style._color = self._color\n        style._bgcolor = self._bgcolor\n        style._attributes = self._attributes\n        style._set_attributes = self._set_attributes\n        style._link = self._link\n        style._link_id = f\"{randint(0, 999999)}\" if self._link else \"\"\n        style._hash = self._hash\n        style._null = False\n        style._meta = self._meta\n        return style\n\n    @lru_cache(maxsize=128)\n    def clear_meta_and_links(self) -> \"Style\":\n        \"\"\"Get a copy of this style with link and meta information removed.\n\n        Returns:\n            Style: New style object.\n        \"\"\"\n        if self._null:\n            return NULL_STYLE\n        style: Style = self.__new__(Style)\n        style._ansi = self._ansi\n        style._style_definition = self._style_definition\n        style._color = self._color\n        style._bgcolor = self._bgcolor\n        style._attributes = self._attributes\n        style._set_attributes = self._set_attributes\n        style._link = None\n        style._link_id = \"\"\n        style._hash = None\n        style._null = False\n        style._meta = None\n        return style\n\n    def update_link(self, link: Optional[str] = None) -> \"Style\":\n        \"\"\"Get a copy with a different value for link.\n\n        Args:\n            link (str, optional): New value for link. Defaults to None.\n\n        Returns:\n            Style: A new Style instance.\n        \"\"\"\n        style: Style = self.__new__(Style)\n        style._ansi = self._ansi\n        style._style_definition = self._style_definition\n        style._color = self._color\n        style._bgcolor = self._bgcolor\n        style._attributes = self._attributes\n        style._set_attributes = self._set_attributes\n        style._link = link\n        style._link_id = f\"{randint(0, 999999)}\" if link else \"\"\n        style._hash = None\n        style._null = False\n        style._meta = self._meta\n        return style\n\n    def render(\n        self,\n        text: str = \"\",\n        *,\n        color_system: Optional[ColorSystem] = ColorSystem.TRUECOLOR,\n        legacy_windows: bool = False,\n    ) -> str:\n        \"\"\"Render the ANSI codes for the style.\n\n        Args:\n            text (str, optional): A string to style. Defaults to \"\".\n            color_system (Optional[ColorSystem], optional): Color system to render to. Defaults to ColorSystem.TRUECOLOR.\n\n        Returns:\n            str: A string containing ANSI style codes.\n        \"\"\"\n        if not text or color_system is None:\n            return text\n        attrs = self._ansi or self._make_ansi_codes(color_system)\n        rendered = f\"\\x1b[{attrs}m{text}\\x1b[0m\" if attrs else text\n        if self._link and not legacy_windows:\n            rendered = (\n                f\"\\x1b]8;id={self._link_id};{self._link}\\x1b\\\\{rendered}\\x1b]8;;\\x1b\\\\\"\n            )\n        return rendered\n\n    def test(self, text: Optional[str] = None) -> None:\n        \"\"\"Write text with style directly to terminal.\n\n        This method is for testing purposes only.\n\n        Args:\n            text (Optional[str], optional): Text to style or None for style name.\n\n        \"\"\"\n        text = text or str(self)\n        sys.stdout.write(f\"{self.render(text)}\\n\")\n\n    @lru_cache(maxsize=1024)\n    def _add(self, style: Optional[\"Style\"]) -> \"Style\":\n        if style is None or style._null:\n            return self\n        if self._null:\n            return style\n        new_style: Style = self.__new__(Style)\n        new_style._ansi = None\n        new_style._style_definition = None\n        new_style._color = style._color or self._color\n        new_style._bgcolor = style._bgcolor or self._bgcolor\n        new_style._attributes = (self._attributes & ~style._set_attributes) | (\n            style._attributes & style._set_attributes\n        )\n        new_style._set_attributes = self._set_attributes | style._set_attributes\n        new_style._link = style._link or self._link\n        new_style._link_id = style._link_id or self._link_id\n        new_style._null = style._null\n        if self._meta and style._meta:\n            new_style._meta = dumps({**self.meta, **style.meta})\n        else:\n            new_style._meta = self._meta or style._meta\n        new_style._hash = None\n        return new_style\n\n    def __add__(self, style: Optional[\"Style\"]) -> \"Style\":\n        combined_style = self._add(style)\n        return combined_style.copy() if combined_style.link else combined_style\n\n\nNULL_STYLE = Style()\n\n\nclass StyleStack:\n    \"\"\"A stack of styles.\"\"\"\n\n    __slots__ = [\"_stack\"]\n\n    def __init__(self, default_style: \"Style\") -> None:\n        self._stack: List[Style] = [default_style]\n\n    def __repr__(self) -> str:\n        return f\"<stylestack {self._stack!r}>\"\n\n    @property\n    def current(self) -> Style:\n        \"\"\"Get the Style at the top of the stack.\"\"\"\n        return self._stack[-1]\n\n    def push(self, style: Style) -> None:\n        \"\"\"Push a new style on to the stack.\n\n        Args:\n            style (Style): New style to combine with current style.\n        \"\"\"\n        self._stack.append(self._stack[-1] + style)\n\n    def pop(self) -> Style:\n        \"\"\"Pop last style and discard.\n\n        Returns:\n            Style: New current style (also available as stack.current)\n        \"\"\"\n        self._stack.pop()\n        return self._stack[-1]\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/styled.py","size":1258,"sha1":"6fd170ba37f8246b0f64ba21357410459044160c","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import TYPE_CHECKING\n\nfrom .measure import Measurement\nfrom .segment import Segment\nfrom .style import StyleType\n\nif TYPE_CHECKING:\n    from .console import Console, ConsoleOptions, RenderResult, RenderableType\n\n\nclass Styled:\n    \"\"\"Apply a style to a renderable.\n\n    Args:\n        renderable (RenderableType): Any renderable.\n        style (StyleType): A style to apply across the entire renderable.\n    \"\"\"\n\n    def __init__(self, renderable: \"RenderableType\", style: \"StyleType\") -> None:\n        self.renderable = renderable\n        self.style = style\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        style = console.get_style(self.style)\n        rendered_segments = console.render(self.renderable, options)\n        segments = Segment.apply_style(rendered_segments, style)\n        return segments\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> Measurement:\n        return Measurement.get(console, options, self.renderable)\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from pip._vendor.rich import print\n    from pip._vendor.rich.panel import Panel\n\n    panel = Styled(Panel(\"hello\"), \"on blue\")\n    print(panel)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/syntax.py","size":35763,"sha1":"570693d1b647a7e356011028557992f754e8744d","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import os.path\nimport re\nimport sys\nimport textwrap\nfrom abc import ABC, abstractmethod\nfrom pathlib import Path\nfrom typing import (\n    Any,\n    Dict,\n    Iterable,\n    List,\n    NamedTuple,\n    Optional,\n    Sequence,\n    Set,\n    Tuple,\n    Type,\n    Union,\n)\n\nfrom pip._vendor.pygments.lexer import Lexer\nfrom pip._vendor.pygments.lexers import get_lexer_by_name, guess_lexer_for_filename\nfrom pip._vendor.pygments.style import Style as PygmentsStyle\nfrom pip._vendor.pygments.styles import get_style_by_name\nfrom pip._vendor.pygments.token import (\n    Comment,\n    Error,\n    Generic,\n    Keyword,\n    Name,\n    Number,\n    Operator,\n    String,\n    Token,\n    Whitespace,\n)\nfrom pip._vendor.pygments.util import ClassNotFound\n\nfrom pip._vendor.rich.containers import Lines\nfrom pip._vendor.rich.padding import Padding, PaddingDimensions\n\nfrom ._loop import loop_first\nfrom .cells import cell_len\nfrom .color import Color, blend_rgb\nfrom .console import Console, ConsoleOptions, JustifyMethod, RenderResult\nfrom .jupyter import JupyterMixin\nfrom .measure import Measurement\nfrom .segment import Segment, Segments\nfrom .style import Style, StyleType\nfrom .text import Text\n\nTokenType = Tuple[str, ...]\n\nWINDOWS = sys.platform == \"win32\"\nDEFAULT_THEME = \"monokai\"\n\n# The following styles are based on https://github.com/pygments/pygments/blob/master/pygments/formatters/terminal.py\n# A few modifications were made\n\nANSI_LIGHT: Dict[TokenType, Style] = {\n    Token: Style(),\n    Whitespace: Style(color=\"white\"),\n    Comment: Style(dim=True),\n    Comment.Preproc: Style(color=\"cyan\"),\n    Keyword: Style(color=\"blue\"),\n    Keyword.Type: Style(color=\"cyan\"),\n    Operator.Word: Style(color=\"magenta\"),\n    Name.Builtin: Style(color=\"cyan\"),\n    Name.Function: Style(color=\"green\"),\n    Name.Namespace: Style(color=\"cyan\", underline=True),\n    Name.Class: Style(color=\"green\", underline=True),\n    Name.Exception: Style(color=\"cyan\"),\n    Name.Decorator: Style(color=\"magenta\", bold=True),\n    Name.Variable: Style(color=\"red\"),\n    Name.Constant: Style(color=\"red\"),\n    Name.Attribute: Style(color=\"cyan\"),\n    Name.Tag: Style(color=\"bright_blue\"),\n    String: Style(color=\"yellow\"),\n    Number: Style(color=\"blue\"),\n    Generic.Deleted: Style(color=\"bright_red\"),\n    Generic.Inserted: Style(color=\"green\"),\n    Generic.Heading: Style(bold=True),\n    Generic.Subheading: Style(color=\"magenta\", bold=True),\n    Generic.Prompt: Style(bold=True),\n    Generic.Error: Style(color=\"bright_red\"),\n    Error: Style(color=\"red\", underline=True),\n}\n\nANSI_DARK: Dict[TokenType, Style] = {\n    Token: Style(),\n    Whitespace: Style(color=\"bright_black\"),\n    Comment: Style(dim=True),\n    Comment.Preproc: Style(color=\"bright_cyan\"),\n    Keyword: Style(color=\"bright_blue\"),\n    Keyword.Type: Style(color=\"bright_cyan\"),\n    Operator.Word: Style(color=\"bright_magenta\"),\n    Name.Builtin: Style(color=\"bright_cyan\"),\n    Name.Function: Style(color=\"bright_green\"),\n    Name.Namespace: Style(color=\"bright_cyan\", underline=True),\n    Name.Class: Style(color=\"bright_green\", underline=True),\n    Name.Exception: Style(color=\"bright_cyan\"),\n    Name.Decorator: Style(color=\"bright_magenta\", bold=True),\n    Name.Variable: Style(color=\"bright_red\"),\n    Name.Constant: Style(color=\"bright_red\"),\n    Name.Attribute: Style(color=\"bright_cyan\"),\n    Name.Tag: Style(color=\"bright_blue\"),\n    String: Style(color=\"yellow\"),\n    Number: Style(color=\"bright_blue\"),\n    Generic.Deleted: Style(color=\"bright_red\"),\n    Generic.Inserted: Style(color=\"bright_green\"),\n    Generic.Heading: Style(bold=True),\n    Generic.Subheading: Style(color=\"bright_magenta\", bold=True),\n    Generic.Prompt: Style(bold=True),\n    Generic.Error: Style(color=\"bright_red\"),\n    Error: Style(color=\"red\", underline=True),\n}\n\nRICH_SYNTAX_THEMES = {\"ansi_light\": ANSI_LIGHT, \"ansi_dark\": ANSI_DARK}\nNUMBERS_COLUMN_DEFAULT_PADDING = 2\n\n\nclass SyntaxTheme(ABC):\n    \"\"\"Base class for a syntax theme.\"\"\"\n\n    @abstractmethod\n    def get_style_for_token(self, token_type: TokenType) -> Style:\n        \"\"\"Get a style for a given Pygments token.\"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n    @abstractmethod\n    def get_background_style(self) -> Style:\n        \"\"\"Get the background color.\"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n\nclass PygmentsSyntaxTheme(SyntaxTheme):\n    \"\"\"Syntax theme that delegates to Pygments theme.\"\"\"\n\n    def __init__(self, theme: Union[str, Type[PygmentsStyle]]) -> None:\n        self._style_cache: Dict[TokenType, Style] = {}\n        if isinstance(theme, str):\n            try:\n                self._pygments_style_class = get_style_by_name(theme)\n            except ClassNotFound:\n                self._pygments_style_class = get_style_by_name(\"default\")\n        else:\n            self._pygments_style_class = theme\n\n        self._background_color = self._pygments_style_class.background_color\n        self._background_style = Style(bgcolor=self._background_color)\n\n    def get_style_for_token(self, token_type: TokenType) -> Style:\n        \"\"\"Get a style from a Pygments class.\"\"\"\n        try:\n            return self._style_cache[token_type]\n        except KeyError:\n            try:\n                pygments_style = self._pygments_style_class.style_for_token(token_type)\n            except KeyError:\n                style = Style.null()\n            else:\n                color = pygments_style[\"color\"]\n                bgcolor = pygments_style[\"bgcolor\"]\n                style = Style(\n                    color=\"#\" + color if color else \"#000000\",\n                    bgcolor=\"#\" + bgcolor if bgcolor else self._background_color,\n                    bold=pygments_style[\"bold\"],\n                    italic=pygments_style[\"italic\"],\n                    underline=pygments_style[\"underline\"],\n                )\n            self._style_cache[token_type] = style\n        return style\n\n    def get_background_style(self) -> Style:\n        return self._background_style\n\n\nclass ANSISyntaxTheme(SyntaxTheme):\n    \"\"\"Syntax theme to use standard colors.\"\"\"\n\n    def __init__(self, style_map: Dict[TokenType, Style]) -> None:\n        self.style_map = style_map\n        self._missing_style = Style.null()\n        self._background_style = Style.null()\n        self._style_cache: Dict[TokenType, Style] = {}\n\n    def get_style_for_token(self, token_type: TokenType) -> Style:\n        \"\"\"Look up style in the style map.\"\"\"\n        try:\n            return self._style_cache[token_type]\n        except KeyError:\n            # Styles form a hierarchy\n            # We need to go from most to least specific\n            # e.g. (\"foo\", \"bar\", \"baz\") to (\"foo\", \"bar\")  to (\"foo\",)\n            get_style = self.style_map.get\n            token = tuple(token_type)\n            style = self._missing_style\n            while token:\n                _style = get_style(token)\n                if _style is not None:\n                    style = _style\n                    break\n                token = token[:-1]\n            self._style_cache[token_type] = style\n            return style\n\n    def get_background_style(self) -> Style:\n        return self._background_style\n\n\nSyntaxPosition = Tuple[int, int]\n\n\nclass _SyntaxHighlightRange(NamedTuple):\n    \"\"\"\n    A range to highlight in a Syntax object.\n    `start` and `end` are 2-integers tuples, where the first integer is the line number\n    (starting from 1) and the second integer is the column index (starting from 0).\n    \"\"\"\n\n    style: StyleType\n    start: SyntaxPosition\n    end: SyntaxPosition\n    style_before: bool = False\n\n\nclass Syntax(JupyterMixin):\n    \"\"\"Construct a Syntax object to render syntax highlighted code.\n\n    Args:\n        code (str): Code to highlight.\n        lexer (Lexer | str): Lexer to use (see https://pygments.org/docs/lexers/)\n        theme (str, optional): Color theme, aka Pygments style (see https://pygments.org/docs/styles/#getting-a-list-of-available-styles). Defaults to \"monokai\".\n        dedent (bool, optional): Enable stripping of initial whitespace. Defaults to False.\n        line_numbers (bool, optional): Enable rendering of line numbers. Defaults to False.\n        start_line (int, optional): Starting number for line numbers. Defaults to 1.\n        line_range (Tuple[int | None, int | None], optional): If given should be a tuple of the start and end line to render.\n            A value of None in the tuple indicates the range is open in that direction.\n        highlight_lines (Set[int]): A set of line numbers to highlight.\n        code_width: Width of code to render (not including line numbers), or ``None`` to use all available width.\n        tab_size (int, optional): Size of tabs. Defaults to 4.\n        word_wrap (bool, optional): Enable word wrapping.\n        background_color (str, optional): Optional background color, or None to use theme color. Defaults to None.\n        indent_guides (bool, optional): Show indent guides. Defaults to False.\n        padding (PaddingDimensions): Padding to apply around the syntax. Defaults to 0 (no padding).\n    \"\"\"\n\n    _pygments_style_class: Type[PygmentsStyle]\n    _theme: SyntaxTheme\n\n    @classmethod\n    def get_theme(cls, name: Union[str, SyntaxTheme]) -> SyntaxTheme:\n        \"\"\"Get a syntax theme instance.\"\"\"\n        if isinstance(name, SyntaxTheme):\n            return name\n        theme: SyntaxTheme\n        if name in RICH_SYNTAX_THEMES:\n            theme = ANSISyntaxTheme(RICH_SYNTAX_THEMES[name])\n        else:\n            theme = PygmentsSyntaxTheme(name)\n        return theme\n\n    def __init__(\n        self,\n        code: str,\n        lexer: Union[Lexer, str],\n        *,\n        theme: Union[str, SyntaxTheme] = DEFAULT_THEME,\n        dedent: bool = False,\n        line_numbers: bool = False,\n        start_line: int = 1,\n        line_range: Optional[Tuple[Optional[int], Optional[int]]] = None,\n        highlight_lines: Optional[Set[int]] = None,\n        code_width: Optional[int] = None,\n        tab_size: int = 4,\n        word_wrap: bool = False,\n        background_color: Optional[str] = None,\n        indent_guides: bool = False,\n        padding: PaddingDimensions = 0,\n    ) -> None:\n        self.code = code\n        self._lexer = lexer\n        self.dedent = dedent\n        self.line_numbers = line_numbers\n        self.start_line = start_line\n        self.line_range = line_range\n        self.highlight_lines = highlight_lines or set()\n        self.code_width = code_width\n        self.tab_size = tab_size\n        self.word_wrap = word_wrap\n        self.background_color = background_color\n        self.background_style = (\n            Style(bgcolor=background_color) if background_color else Style()\n        )\n        self.indent_guides = indent_guides\n        self.padding = padding\n\n        self._theme = self.get_theme(theme)\n        self._stylized_ranges: List[_SyntaxHighlightRange] = []\n\n    @classmethod\n    def from_path(\n        cls,\n        path: str,\n        encoding: str = \"utf-8\",\n        lexer: Optional[Union[Lexer, str]] = None,\n        theme: Union[str, SyntaxTheme] = DEFAULT_THEME,\n        dedent: bool = False,\n        line_numbers: bool = False,\n        line_range: Optional[Tuple[int, int]] = None,\n        start_line: int = 1,\n        highlight_lines: Optional[Set[int]] = None,\n        code_width: Optional[int] = None,\n        tab_size: int = 4,\n        word_wrap: bool = False,\n        background_color: Optional[str] = None,\n        indent_guides: bool = False,\n        padding: PaddingDimensions = 0,\n    ) -> \"Syntax\":\n        \"\"\"Construct a Syntax object from a file.\n\n        Args:\n            path (str): Path to file to highlight.\n            encoding (str): Encoding of file.\n            lexer (str | Lexer, optional): Lexer to use. If None, lexer will be auto-detected from path/file content.\n            theme (str, optional): Color theme, aka Pygments style (see https://pygments.org/docs/styles/#getting-a-list-of-available-styles). Defaults to \"emacs\".\n            dedent (bool, optional): Enable stripping of initial whitespace. Defaults to True.\n            line_numbers (bool, optional): Enable rendering of line numbers. Defaults to False.\n            start_line (int, optional): Starting number for line numbers. Defaults to 1.\n            line_range (Tuple[int, int], optional): If given should be a tuple of the start and end line to render.\n            highlight_lines (Set[int]): A set of line numbers to highlight.\n            code_width: Width of code to render (not including line numbers), or ``None`` to use all available width.\n            tab_size (int, optional): Size of tabs. Defaults to 4.\n            word_wrap (bool, optional): Enable word wrapping of code.\n            background_color (str, optional): Optional background color, or None to use theme color. Defaults to None.\n            indent_guides (bool, optional): Show indent guides. Defaults to False.\n            padding (PaddingDimensions): Padding to apply around the syntax. Defaults to 0 (no padding).\n\n        Returns:\n            [Syntax]: A Syntax object that may be printed to the console\n        \"\"\"\n        code = Path(path).read_text(encoding=encoding)\n\n        if not lexer:\n            lexer = cls.guess_lexer(path, code=code)\n\n        return cls(\n            code,\n            lexer,\n            theme=theme,\n            dedent=dedent,\n            line_numbers=line_numbers,\n            line_range=line_range,\n            start_line=start_line,\n            highlight_lines=highlight_lines,\n            code_width=code_width,\n            tab_size=tab_size,\n            word_wrap=word_wrap,\n            background_color=background_color,\n            indent_guides=indent_guides,\n            padding=padding,\n        )\n\n    @classmethod\n    def guess_lexer(cls, path: str, code: Optional[str] = None) -> str:\n        \"\"\"Guess the alias of the Pygments lexer to use based on a path and an optional string of code.\n        If code is supplied, it will use a combination of the code and the filename to determine the\n        best lexer to use. For example, if the file is ``index.html`` and the file contains Django\n        templating syntax, then \"html+django\" will be returned. If the file is ``index.html``, and no\n        templating language is used, the \"html\" lexer will be used. If no string of code\n        is supplied, the lexer will be chosen based on the file extension..\n\n        Args:\n             path (AnyStr): The path to the file containing the code you wish to know the lexer for.\n             code (str, optional): Optional string of code that will be used as a fallback if no lexer\n                is found for the supplied path.\n\n        Returns:\n            str: The name of the Pygments lexer that best matches the supplied path/code.\n        \"\"\"\n        lexer: Optional[Lexer] = None\n        lexer_name = \"default\"\n        if code:\n            try:\n                lexer = guess_lexer_for_filename(path, code)\n            except ClassNotFound:\n                pass\n\n        if not lexer:\n            try:\n                _, ext = os.path.splitext(path)\n                if ext:\n                    extension = ext.lstrip(\".\").lower()\n                    lexer = get_lexer_by_name(extension)\n            except ClassNotFound:\n                pass\n\n        if lexer:\n            if lexer.aliases:\n                lexer_name = lexer.aliases[0]\n            else:\n                lexer_name = lexer.name\n\n        return lexer_name\n\n    def _get_base_style(self) -> Style:\n        \"\"\"Get the base style.\"\"\"\n        default_style = self._theme.get_background_style() + self.background_style\n        return default_style\n\n    def _get_token_color(self, token_type: TokenType) -> Optional[Color]:\n        \"\"\"Get a color (if any) for the given token.\n\n        Args:\n            token_type (TokenType): A token type tuple from Pygments.\n\n        Returns:\n            Optional[Color]: Color from theme, or None for no color.\n        \"\"\"\n        style = self._theme.get_style_for_token(token_type)\n        return style.color\n\n    @property\n    def lexer(self) -> Optional[Lexer]:\n        \"\"\"The lexer for this syntax, or None if no lexer was found.\n\n        Tries to find the lexer by name if a string was passed to the constructor.\n        \"\"\"\n\n        if isinstance(self._lexer, Lexer):\n            return self._lexer\n        try:\n            return get_lexer_by_name(\n                self._lexer,\n                stripnl=False,\n                ensurenl=True,\n                tabsize=self.tab_size,\n            )\n        except ClassNotFound:\n            return None\n\n    @property\n    def default_lexer(self) -> Lexer:\n        \"\"\"A Pygments Lexer to use if one is not specified or invalid.\"\"\"\n        return get_lexer_by_name(\n            \"text\",\n            stripnl=False,\n            ensurenl=True,\n            tabsize=self.tab_size,\n        )\n\n    def highlight(\n        self,\n        code: str,\n        line_range: Optional[Tuple[Optional[int], Optional[int]]] = None,\n    ) -> Text:\n        \"\"\"Highlight code and return a Text instance.\n\n        Args:\n            code (str): Code to highlight.\n            line_range(Tuple[int, int], optional): Optional line range to highlight.\n\n        Returns:\n            Text: A text instance containing highlighted syntax.\n        \"\"\"\n\n        base_style = self._get_base_style()\n        justify: JustifyMethod = (\n            \"default\" if base_style.transparent_background else \"left\"\n        )\n\n        text = Text(\n            justify=justify,\n            style=base_style,\n            tab_size=self.tab_size,\n            no_wrap=not self.word_wrap,\n        )\n        _get_theme_style = self._theme.get_style_for_token\n\n        lexer = self.lexer or self.default_lexer\n\n        if lexer is None:\n            text.append(code)\n        else:\n            if line_range:\n                # More complicated path to only stylize a portion of the code\n                # This speeds up further operations as there are less spans to process\n                line_start, line_end = line_range\n\n                def line_tokenize() -> Iterable[Tuple[Any, str]]:\n                    \"\"\"Split tokens to one per line.\"\"\"\n                    assert lexer  # required to make MyPy happy - we know lexer is not None at this point\n\n                    for token_type, token in lexer.get_tokens(code):\n                        while token:\n                            line_token, new_line, token = token.partition(\"\\n\")\n                            yield token_type, line_token + new_line\n\n                def tokens_to_spans() -> Iterable[Tuple[str, Optional[Style]]]:\n                    \"\"\"Convert tokens to spans.\"\"\"\n                    tokens = iter(line_tokenize())\n                    line_no = 0\n                    _line_start = line_start - 1 if line_start else 0\n\n                    # Skip over tokens until line start\n                    while line_no < _line_start:\n                        try:\n                            _token_type, token = next(tokens)\n                        except StopIteration:\n                            break\n                        yield (token, None)\n                        if token.endswith(\"\\n\"):\n                            line_no += 1\n                    # Generate spans until line end\n                    for token_type, token in tokens:\n                        yield (token, _get_theme_style(token_type))\n                        if token.endswith(\"\\n\"):\n                            line_no += 1\n                            if line_end and line_no >= line_end:\n                                break\n\n                text.append_tokens(tokens_to_spans())\n\n            else:\n                text.append_tokens(\n                    (token, _get_theme_style(token_type))\n                    for token_type, token in lexer.get_tokens(code)\n                )\n            if self.background_color is not None:\n                text.stylize(f\"on {self.background_color}\")\n\n        if self._stylized_ranges:\n            self._apply_stylized_ranges(text)\n\n        return text\n\n    def stylize_range(\n        self,\n        style: StyleType,\n        start: SyntaxPosition,\n        end: SyntaxPosition,\n        style_before: bool = False,\n    ) -> None:\n        \"\"\"\n        Adds a custom style on a part of the code, that will be applied to the syntax display when it's rendered.\n        Line numbers are 1-based, while column indexes are 0-based.\n\n        Args:\n            style (StyleType): The style to apply.\n            start (Tuple[int, int]): The start of the range, in the form `[line number, column index]`.\n            end (Tuple[int, int]): The end of the range, in the form `[line number, column index]`.\n            style_before (bool): Apply the style before any existing styles.\n        \"\"\"\n        self._stylized_ranges.append(\n            _SyntaxHighlightRange(style, start, end, style_before)\n        )\n\n    def _get_line_numbers_color(self, blend: float = 0.3) -> Color:\n        background_style = self._theme.get_background_style() + self.background_style\n        background_color = background_style.bgcolor\n        if background_color is None or background_color.is_system_defined:\n            return Color.default()\n        foreground_color = self._get_token_color(Token.Text)\n        if foreground_color is None or foreground_color.is_system_defined:\n            return foreground_color or Color.default()\n        new_color = blend_rgb(\n            background_color.get_truecolor(),\n            foreground_color.get_truecolor(),\n            cross_fade=blend,\n        )\n        return Color.from_triplet(new_color)\n\n    @property\n    def _numbers_column_width(self) -> int:\n        \"\"\"Get the number of characters used to render the numbers column.\"\"\"\n        column_width = 0\n        if self.line_numbers:\n            column_width = (\n                len(str(self.start_line + self.code.count(\"\\n\")))\n                + NUMBERS_COLUMN_DEFAULT_PADDING\n            )\n        return column_width\n\n    def _get_number_styles(self, console: Console) -> Tuple[Style, Style, Style]:\n        \"\"\"Get background, number, and highlight styles for line numbers.\"\"\"\n        background_style = self._get_base_style()\n        if background_style.transparent_background:\n            return Style.null(), Style(dim=True), Style.null()\n        if console.color_system in (\"256\", \"truecolor\"):\n            number_style = Style.chain(\n                background_style,\n                self._theme.get_style_for_token(Token.Text),\n                Style(color=self._get_line_numbers_color()),\n                self.background_style,\n            )\n            highlight_number_style = Style.chain(\n                background_style,\n                self._theme.get_style_for_token(Token.Text),\n                Style(bold=True, color=self._get_line_numbers_color(0.9)),\n                self.background_style,\n            )\n        else:\n            number_style = background_style + Style(dim=True)\n            highlight_number_style = background_style + Style(dim=False)\n        return background_style, number_style, highlight_number_style\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"Measurement\":\n        _, right, _, left = Padding.unpack(self.padding)\n        padding = left + right\n        if self.code_width is not None:\n            width = self.code_width + self._numbers_column_width + padding + 1\n            return Measurement(self._numbers_column_width, width)\n        lines = self.code.splitlines()\n        width = (\n            self._numbers_column_width\n            + padding\n            + (max(cell_len(line) for line in lines) if lines else 0)\n        )\n        if self.line_numbers:\n            width += 1\n        return Measurement(self._numbers_column_width, width)\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        segments = Segments(self._get_syntax(console, options))\n        if self.padding:\n            yield Padding(segments, style=self._get_base_style(), pad=self.padding)\n        else:\n            yield segments\n\n    def _get_syntax(\n        self,\n        console: Console,\n        options: ConsoleOptions,\n    ) -> Iterable[Segment]:\n        \"\"\"\n        Get the Segments for the Syntax object, excluding any vertical/horizontal padding\n        \"\"\"\n        transparent_background = self._get_base_style().transparent_background\n        code_width = (\n            (\n                (options.max_width - self._numbers_column_width - 1)\n                if self.line_numbers\n                else options.max_width\n            )\n            if self.code_width is None\n            else self.code_width\n        )\n\n        ends_on_nl, processed_code = self._process_code(self.code)\n        text = self.highlight(processed_code, self.line_range)\n\n        if not self.line_numbers and not self.word_wrap and not self.line_range:\n            if not ends_on_nl:\n                text.remove_suffix(\"\\n\")\n            # Simple case of just rendering text\n            style = (\n                self._get_base_style()\n                + self._theme.get_style_for_token(Comment)\n                + Style(dim=True)\n                + self.background_style\n            )\n            if self.indent_guides and not options.ascii_only:\n                text = text.with_indent_guides(self.tab_size, style=style)\n                text.overflow = \"crop\"\n            if style.transparent_background:\n                yield from console.render(\n                    text, options=options.update(width=code_width)\n                )\n            else:\n                syntax_lines = console.render_lines(\n                    text,\n                    options.update(width=code_width, height=None, justify=\"left\"),\n                    style=self.background_style,\n                    pad=True,\n                    new_lines=True,\n                )\n                for syntax_line in syntax_lines:\n                    yield from syntax_line\n            return\n\n        start_line, end_line = self.line_range or (None, None)\n        line_offset = 0\n        if start_line:\n            line_offset = max(0, start_line - 1)\n        lines: Union[List[Text], Lines] = text.split(\"\\n\", allow_blank=ends_on_nl)\n        if self.line_range:\n            if line_offset > len(lines):\n                return\n            lines = lines[line_offset:end_line]\n\n        if self.indent_guides and not options.ascii_only:\n            style = (\n                self._get_base_style()\n                + self._theme.get_style_for_token(Comment)\n                + Style(dim=True)\n                + self.background_style\n            )\n            lines = (\n                Text(\"\\n\")\n                .join(lines)\n                .with_indent_guides(self.tab_size, style=style + Style(italic=False))\n                .split(\"\\n\", allow_blank=True)\n            )\n\n        numbers_column_width = self._numbers_column_width\n        render_options = options.update(width=code_width)\n\n        highlight_line = self.highlight_lines.__contains__\n        _Segment = Segment\n        new_line = _Segment(\"\\n\")\n\n        line_pointer = \"> \" if options.legacy_windows else \"â± \"\n\n        (\n            background_style,\n            number_style,\n            highlight_number_style,\n        ) = self._get_number_styles(console)\n\n        for line_no, line in enumerate(lines, self.start_line + line_offset):\n            if self.word_wrap:\n                wrapped_lines = console.render_lines(\n                    line,\n                    render_options.update(height=None, justify=\"left\"),\n                    style=background_style,\n                    pad=not transparent_background,\n                )\n            else:\n                segments = list(line.render(console, end=\"\"))\n                if options.no_wrap:\n                    wrapped_lines = [segments]\n                else:\n                    wrapped_lines = [\n                        _Segment.adjust_line_length(\n                            segments,\n                            render_options.max_width,\n                            style=background_style,\n                            pad=not transparent_background,\n                        )\n                    ]\n\n            if self.line_numbers:\n                wrapped_line_left_pad = _Segment(\n                    \" \" * numbers_column_width + \" \", background_style\n                )\n                for first, wrapped_line in loop_first(wrapped_lines):\n                    if first:\n                        line_column = str(line_no).rjust(numbers_column_width - 2) + \" \"\n                        if highlight_line(line_no):\n                            yield _Segment(line_pointer, Style(color=\"red\"))\n                            yield _Segment(line_column, highlight_number_style)\n                        else:\n                            yield _Segment(\"  \", highlight_number_style)\n                            yield _Segment(line_column, number_style)\n                    else:\n                        yield wrapped_line_left_pad\n                    yield from wrapped_line\n                    yield new_line\n            else:\n                for wrapped_line in wrapped_lines:\n                    yield from wrapped_line\n                    yield new_line\n\n    def _apply_stylized_ranges(self, text: Text) -> None:\n        \"\"\"\n        Apply stylized ranges to a text instance,\n        using the given code to determine the right portion to apply the style to.\n\n        Args:\n            text (Text): Text instance to apply the style to.\n        \"\"\"\n        code = text.plain\n        newlines_offsets = [\n            # Let's add outer boundaries at each side of the list:\n            0,\n            # N.B. using \"\\n\" here is much faster than using metacharacters such as \"^\" or \"\\Z\":\n            *[\n                match.start() + 1\n                for match in re.finditer(\"\\n\", code, flags=re.MULTILINE)\n            ],\n            len(code) + 1,\n        ]\n\n        for stylized_range in self._stylized_ranges:\n            start = _get_code_index_for_syntax_position(\n                newlines_offsets, stylized_range.start\n            )\n            end = _get_code_index_for_syntax_position(\n                newlines_offsets, stylized_range.end\n            )\n            if start is not None and end is not None:\n                if stylized_range.style_before:\n                    text.stylize_before(stylized_range.style, start, end)\n                else:\n                    text.stylize(stylized_range.style, start, end)\n\n    def _process_code(self, code: str) -> Tuple[bool, str]:\n        \"\"\"\n        Applies various processing to a raw code string\n        (normalises it so it always ends with a line return, dedents it if necessary, etc.)\n\n        Args:\n            code (str): The raw code string to process\n\n        Returns:\n            Tuple[bool, str]: the boolean indicates whether the raw code ends with a line return,\n                while the string is the processed code.\n        \"\"\"\n        ends_on_nl = code.endswith(\"\\n\")\n        processed_code = code if ends_on_nl else code + \"\\n\"\n        processed_code = (\n            textwrap.dedent(processed_code) if self.dedent else processed_code\n        )\n        processed_code = processed_code.expandtabs(self.tab_size)\n        return ends_on_nl, processed_code\n\n\ndef _get_code_index_for_syntax_position(\n    newlines_offsets: Sequence[int], position: SyntaxPosition\n) -> Optional[int]:\n    \"\"\"\n    Returns the index of the code string for the given positions.\n\n    Args:\n        newlines_offsets (Sequence[int]): The offset of each newline character found in the code snippet.\n        position (SyntaxPosition): The position to search for.\n\n    Returns:\n        Optional[int]: The index of the code string for this position, or `None`\n            if the given position's line number is out of range (if it's the column that is out of range\n            we silently clamp its value so that it reaches the end of the line)\n    \"\"\"\n    lines_count = len(newlines_offsets)\n\n    line_number, column_index = position\n    if line_number > lines_count or len(newlines_offsets) < (line_number + 1):\n        return None  # `line_number` is out of range\n    line_index = line_number - 1\n    line_length = newlines_offsets[line_index + 1] - newlines_offsets[line_index] - 1\n    # If `column_index` is out of range: let's silently clamp it:\n    column_index = min(line_length, column_index)\n    return newlines_offsets[line_index] + column_index\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    import argparse\n    import sys\n\n    parser = argparse.ArgumentParser(\n        description=\"Render syntax to the console with Rich\"\n    )\n    parser.add_argument(\n        \"path\",\n        metavar=\"PATH\",\n        help=\"path to file, or - for stdin\",\n    )\n    parser.add_argument(\n        \"-c\",\n        \"--force-color\",\n        dest=\"force_color\",\n        action=\"store_true\",\n        default=None,\n        help=\"force color for non-terminals\",\n    )\n    parser.add_argument(\n        \"-i\",\n        \"--indent-guides\",\n        dest=\"indent_guides\",\n        action=\"store_true\",\n        default=False,\n        help=\"display indent guides\",\n    )\n    parser.add_argument(\n        \"-l\",\n        \"--line-numbers\",\n        dest=\"line_numbers\",\n        action=\"store_true\",\n        help=\"render line numbers\",\n    )\n    parser.add_argument(\n        \"-w\",\n        \"--width\",\n        type=int,\n        dest=\"width\",\n        default=None,\n        help=\"width of output (default will auto-detect)\",\n    )\n    parser.add_argument(\n        \"-r\",\n        \"--wrap\",\n        dest=\"word_wrap\",\n        action=\"store_true\",\n        default=False,\n        help=\"word wrap long lines\",\n    )\n    parser.add_argument(\n        \"-s\",\n        \"--soft-wrap\",\n        action=\"store_true\",\n        dest=\"soft_wrap\",\n        default=False,\n        help=\"enable soft wrapping mode\",\n    )\n    parser.add_argument(\n        \"-t\", \"--theme\", dest=\"theme\", default=\"monokai\", help=\"pygments theme\"\n    )\n    parser.add_argument(\n        \"-b\",\n        \"--background-color\",\n        dest=\"background_color\",\n        default=None,\n        help=\"Override background color\",\n    )\n    parser.add_argument(\n        \"-x\",\n        \"--lexer\",\n        default=None,\n        dest=\"lexer_name\",\n        help=\"Lexer name\",\n    )\n    parser.add_argument(\n        \"-p\", \"--padding\", type=int, default=0, dest=\"padding\", help=\"Padding\"\n    )\n    parser.add_argument(\n        \"--highlight-line\",\n        type=int,\n        default=None,\n        dest=\"highlight_line\",\n        help=\"The line number (not index!) to highlight\",\n    )\n    args = parser.parse_args()\n\n    from pip._vendor.rich.console import Console\n\n    console = Console(force_terminal=args.force_color, width=args.width)\n\n    if args.path == \"-\":\n        code = sys.stdin.read()\n        syntax = Syntax(\n            code=code,\n            lexer=args.lexer_name,\n            line_numbers=args.line_numbers,\n            word_wrap=args.word_wrap,\n            theme=args.theme,\n            background_color=args.background_color,\n            indent_guides=args.indent_guides,\n            padding=args.padding,\n            highlight_lines={args.highlight_line},\n        )\n    else:\n        syntax = Syntax.from_path(\n            args.path,\n            lexer=args.lexer_name,\n            line_numbers=args.line_numbers,\n            word_wrap=args.word_wrap,\n            theme=args.theme,\n            background_color=args.background_color,\n            indent_guides=args.indent_guides,\n            padding=args.padding,\n            highlight_lines={args.highlight_line},\n        )\n    console.print(syntax, soft_wrap=args.soft_wrap)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/table.py","size":40103,"sha1":"2b7dbab5d40dbad215c5deccb85095d5d9b21045","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from dataclasses import dataclass, field, replace\nfrom typing import (\n    TYPE_CHECKING,\n    Dict,\n    Iterable,\n    List,\n    NamedTuple,\n    Optional,\n    Sequence,\n    Tuple,\n    Union,\n)\n\nfrom . import box, errors\nfrom ._loop import loop_first_last, loop_last\nfrom ._pick import pick_bool\nfrom ._ratio import ratio_distribute, ratio_reduce\nfrom .align import VerticalAlignMethod\nfrom .jupyter import JupyterMixin\nfrom .measure import Measurement\nfrom .padding import Padding, PaddingDimensions\nfrom .protocol import is_renderable\nfrom .segment import Segment\nfrom .style import Style, StyleType\nfrom .text import Text, TextType\n\nif TYPE_CHECKING:\n    from .console import (\n        Console,\n        ConsoleOptions,\n        JustifyMethod,\n        OverflowMethod,\n        RenderableType,\n        RenderResult,\n    )\n\n\n@dataclass\nclass Column:\n    \"\"\"Defines a column within a ~Table.\n\n    Args:\n        title (Union[str, Text], optional): The title of the table rendered at the top. Defaults to None.\n        caption (Union[str, Text], optional): The table caption rendered below. Defaults to None.\n        width (int, optional): The width in characters of the table, or ``None`` to automatically fit. Defaults to None.\n        min_width (Optional[int], optional): The minimum width of the table, or ``None`` for no minimum. Defaults to None.\n        box (box.Box, optional): One of the constants in box.py used to draw the edges (see :ref:`appendix_box`), or ``None`` for no box lines. Defaults to box.HEAVY_HEAD.\n        safe_box (Optional[bool], optional): Disable box characters that don't display on windows legacy terminal with *raster* fonts. Defaults to True.\n        padding (PaddingDimensions, optional): Padding for cells (top, right, bottom, left). Defaults to (0, 1).\n        collapse_padding (bool, optional): Enable collapsing of padding around cells. Defaults to False.\n        pad_edge (bool, optional): Enable padding of edge cells. Defaults to True.\n        expand (bool, optional): Expand the table to fit the available space if ``True``, otherwise the table width will be auto-calculated. Defaults to False.\n        show_header (bool, optional): Show a header row. Defaults to True.\n        show_footer (bool, optional): Show a footer row. Defaults to False.\n        show_edge (bool, optional): Draw a box around the outside of the table. Defaults to True.\n        show_lines (bool, optional): Draw lines between every row. Defaults to False.\n        leading (int, optional): Number of blank lines between rows (precludes ``show_lines``). Defaults to 0.\n        style (Union[str, Style], optional): Default style for the table. Defaults to \"none\".\n        row_styles (List[Union, str], optional): Optional list of row styles, if more than one style is given then the styles will alternate. Defaults to None.\n        header_style (Union[str, Style], optional): Style of the header. Defaults to \"table.header\".\n        footer_style (Union[str, Style], optional): Style of the footer. Defaults to \"table.footer\".\n        border_style (Union[str, Style], optional): Style of the border. Defaults to None.\n        title_style (Union[str, Style], optional): Style of the title. Defaults to None.\n        caption_style (Union[str, Style], optional): Style of the caption. Defaults to None.\n        title_justify (str, optional): Justify method for title. Defaults to \"center\".\n        caption_justify (str, optional): Justify method for caption. Defaults to \"center\".\n        highlight (bool, optional): Highlight cell contents (if str). Defaults to False.\n    \"\"\"\n\n    header: \"RenderableType\" = \"\"\n    \"\"\"RenderableType: Renderable for the header (typically a string)\"\"\"\n\n    footer: \"RenderableType\" = \"\"\n    \"\"\"RenderableType: Renderable for the footer (typically a string)\"\"\"\n\n    header_style: StyleType = \"\"\n    \"\"\"StyleType: The style of the header.\"\"\"\n\n    footer_style: StyleType = \"\"\n    \"\"\"StyleType: The style of the footer.\"\"\"\n\n    style: StyleType = \"\"\n    \"\"\"StyleType: The style of the column.\"\"\"\n\n    justify: \"JustifyMethod\" = \"left\"\n    \"\"\"str: How to justify text within the column (\"left\", \"center\", \"right\", or \"full\")\"\"\"\n\n    vertical: \"VerticalAlignMethod\" = \"top\"\n    \"\"\"str: How to vertically align content (\"top\", \"middle\", or \"bottom\")\"\"\"\n\n    overflow: \"OverflowMethod\" = \"ellipsis\"\n    \"\"\"str: Overflow method.\"\"\"\n\n    width: Optional[int] = None\n    \"\"\"Optional[int]: Width of the column, or ``None`` (default) to auto calculate width.\"\"\"\n\n    min_width: Optional[int] = None\n    \"\"\"Optional[int]: Minimum width of column, or ``None`` for no minimum. Defaults to None.\"\"\"\n\n    max_width: Optional[int] = None\n    \"\"\"Optional[int]: Maximum width of column, or ``None`` for no maximum. Defaults to None.\"\"\"\n\n    ratio: Optional[int] = None\n    \"\"\"Optional[int]: Ratio to use when calculating column width, or ``None`` (default) to adapt to column contents.\"\"\"\n\n    no_wrap: bool = False\n    \"\"\"bool: Prevent wrapping of text within the column. Defaults to ``False``.\"\"\"\n\n    highlight: bool = False\n    \"\"\"bool: Apply highlighter to column. Defaults to ``False``.\"\"\"\n\n    _index: int = 0\n    \"\"\"Index of column.\"\"\"\n\n    _cells: List[\"RenderableType\"] = field(default_factory=list)\n\n    def copy(self) -> \"Column\":\n        \"\"\"Return a copy of this Column.\"\"\"\n        return replace(self, _cells=[])\n\n    @property\n    def cells(self) -> Iterable[\"RenderableType\"]:\n        \"\"\"Get all cells in the column, not including header.\"\"\"\n        yield from self._cells\n\n    @property\n    def flexible(self) -> bool:\n        \"\"\"Check if this column is flexible.\"\"\"\n        return self.ratio is not None\n\n\n@dataclass\nclass Row:\n    \"\"\"Information regarding a row.\"\"\"\n\n    style: Optional[StyleType] = None\n    \"\"\"Style to apply to row.\"\"\"\n\n    end_section: bool = False\n    \"\"\"Indicated end of section, which will force a line beneath the row.\"\"\"\n\n\nclass _Cell(NamedTuple):\n    \"\"\"A single cell in a table.\"\"\"\n\n    style: StyleType\n    \"\"\"Style to apply to cell.\"\"\"\n    renderable: \"RenderableType\"\n    \"\"\"Cell renderable.\"\"\"\n    vertical: VerticalAlignMethod\n    \"\"\"Cell vertical alignment.\"\"\"\n\n\nclass Table(JupyterMixin):\n    \"\"\"A console renderable to draw a table.\n\n    Args:\n        *headers (Union[Column, str]): Column headers, either as a string, or :class:`~rich.table.Column` instance.\n        title (Union[str, Text], optional): The title of the table rendered at the top. Defaults to None.\n        caption (Union[str, Text], optional): The table caption rendered below. Defaults to None.\n        width (int, optional): The width in characters of the table, or ``None`` to automatically fit. Defaults to None.\n        min_width (Optional[int], optional): The minimum width of the table, or ``None`` for no minimum. Defaults to None.\n        box (box.Box, optional): One of the constants in box.py used to draw the edges (see :ref:`appendix_box`), or ``None`` for no box lines. Defaults to box.HEAVY_HEAD.\n        safe_box (Optional[bool], optional): Disable box characters that don't display on windows legacy terminal with *raster* fonts. Defaults to True.\n        padding (PaddingDimensions, optional): Padding for cells (top, right, bottom, left). Defaults to (0, 1).\n        collapse_padding (bool, optional): Enable collapsing of padding around cells. Defaults to False.\n        pad_edge (bool, optional): Enable padding of edge cells. Defaults to True.\n        expand (bool, optional): Expand the table to fit the available space if ``True``, otherwise the table width will be auto-calculated. Defaults to False.\n        show_header (bool, optional): Show a header row. Defaults to True.\n        show_footer (bool, optional): Show a footer row. Defaults to False.\n        show_edge (bool, optional): Draw a box around the outside of the table. Defaults to True.\n        show_lines (bool, optional): Draw lines between every row. Defaults to False.\n        leading (int, optional): Number of blank lines between rows (precludes ``show_lines``). Defaults to 0.\n        style (Union[str, Style], optional): Default style for the table. Defaults to \"none\".\n        row_styles (List[Union, str], optional): Optional list of row styles, if more than one style is given then the styles will alternate. Defaults to None.\n        header_style (Union[str, Style], optional): Style of the header. Defaults to \"table.header\".\n        footer_style (Union[str, Style], optional): Style of the footer. Defaults to \"table.footer\".\n        border_style (Union[str, Style], optional): Style of the border. Defaults to None.\n        title_style (Union[str, Style], optional): Style of the title. Defaults to None.\n        caption_style (Union[str, Style], optional): Style of the caption. Defaults to None.\n        title_justify (str, optional): Justify method for title. Defaults to \"center\".\n        caption_justify (str, optional): Justify method for caption. Defaults to \"center\".\n        highlight (bool, optional): Highlight cell contents (if str). Defaults to False.\n    \"\"\"\n\n    columns: List[Column]\n    rows: List[Row]\n\n    def __init__(\n        self,\n        *headers: Union[Column, str],\n        title: Optional[TextType] = None,\n        caption: Optional[TextType] = None,\n        width: Optional[int] = None,\n        min_width: Optional[int] = None,\n        box: Optional[box.Box] = box.HEAVY_HEAD,\n        safe_box: Optional[bool] = None,\n        padding: PaddingDimensions = (0, 1),\n        collapse_padding: bool = False,\n        pad_edge: bool = True,\n        expand: bool = False,\n        show_header: bool = True,\n        show_footer: bool = False,\n        show_edge: bool = True,\n        show_lines: bool = False,\n        leading: int = 0,\n        style: StyleType = \"none\",\n        row_styles: Optional[Iterable[StyleType]] = None,\n        header_style: Optional[StyleType] = \"table.header\",\n        footer_style: Optional[StyleType] = \"table.footer\",\n        border_style: Optional[StyleType] = None,\n        title_style: Optional[StyleType] = None,\n        caption_style: Optional[StyleType] = None,\n        title_justify: \"JustifyMethod\" = \"center\",\n        caption_justify: \"JustifyMethod\" = \"center\",\n        highlight: bool = False,\n    ) -> None:\n        self.columns: List[Column] = []\n        self.rows: List[Row] = []\n        self.title = title\n        self.caption = caption\n        self.width = width\n        self.min_width = min_width\n        self.box = box\n        self.safe_box = safe_box\n        self._padding = Padding.unpack(padding)\n        self.pad_edge = pad_edge\n        self._expand = expand\n        self.show_header = show_header\n        self.show_footer = show_footer\n        self.show_edge = show_edge\n        self.show_lines = show_lines\n        self.leading = leading\n        self.collapse_padding = collapse_padding\n        self.style = style\n        self.header_style = header_style or \"\"\n        self.footer_style = footer_style or \"\"\n        self.border_style = border_style\n        self.title_style = title_style\n        self.caption_style = caption_style\n        self.title_justify: \"JustifyMethod\" = title_justify\n        self.caption_justify: \"JustifyMethod\" = caption_justify\n        self.highlight = highlight\n        self.row_styles: Sequence[StyleType] = list(row_styles or [])\n        append_column = self.columns.append\n        for header in headers:\n            if isinstance(header, str):\n                self.add_column(header=header)\n            else:\n                header._index = len(self.columns)\n                append_column(header)\n\n    @classmethod\n    def grid(\n        cls,\n        *headers: Union[Column, str],\n        padding: PaddingDimensions = 0,\n        collapse_padding: bool = True,\n        pad_edge: bool = False,\n        expand: bool = False,\n    ) -> \"Table\":\n        \"\"\"Get a table with no lines, headers, or footer.\n\n        Args:\n            *headers (Union[Column, str]): Column headers, either as a string, or :class:`~rich.table.Column` instance.\n            padding (PaddingDimensions, optional): Get padding around cells. Defaults to 0.\n            collapse_padding (bool, optional): Enable collapsing of padding around cells. Defaults to True.\n            pad_edge (bool, optional): Enable padding around edges of table. Defaults to False.\n            expand (bool, optional): Expand the table to fit the available space if ``True``, otherwise the table width will be auto-calculated. Defaults to False.\n\n        Returns:\n            Table: A table instance.\n        \"\"\"\n        return cls(\n            *headers,\n            box=None,\n            padding=padding,\n            collapse_padding=collapse_padding,\n            show_header=False,\n            show_footer=False,\n            show_edge=False,\n            pad_edge=pad_edge,\n            expand=expand,\n        )\n\n    @property\n    def expand(self) -> bool:\n        \"\"\"Setting a non-None self.width implies expand.\"\"\"\n        return self._expand or self.width is not None\n\n    @expand.setter\n    def expand(self, expand: bool) -> None:\n        \"\"\"Set expand.\"\"\"\n        self._expand = expand\n\n    @property\n    def _extra_width(self) -> int:\n        \"\"\"Get extra width to add to cell content.\"\"\"\n        width = 0\n        if self.box and self.show_edge:\n            width += 2\n        if self.box:\n            width += len(self.columns) - 1\n        return width\n\n    @property\n    def row_count(self) -> int:\n        \"\"\"Get the current number of rows.\"\"\"\n        return len(self.rows)\n\n    def get_row_style(self, console: \"Console\", index: int) -> StyleType:\n        \"\"\"Get the current row style.\"\"\"\n        style = Style.null()\n        if self.row_styles:\n            style += console.get_style(self.row_styles[index % len(self.row_styles)])\n        row_style = self.rows[index].style\n        if row_style is not None:\n            style += console.get_style(row_style)\n        return style\n\n    def __rich_measure__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> Measurement:\n        max_width = options.max_width\n        if self.width is not None:\n            max_width = self.width\n        if max_width < 0:\n            return Measurement(0, 0)\n\n        extra_width = self._extra_width\n        max_width = sum(\n            self._calculate_column_widths(\n                console, options.update_width(max_width - extra_width)\n            )\n        )\n        _measure_column = self._measure_column\n\n        measurements = [\n            _measure_column(console, options.update_width(max_width), column)\n            for column in self.columns\n        ]\n        minimum_width = (\n            sum(measurement.minimum for measurement in measurements) + extra_width\n        )\n        maximum_width = (\n            sum(measurement.maximum for measurement in measurements) + extra_width\n            if (self.width is None)\n            else self.width\n        )\n        measurement = Measurement(minimum_width, maximum_width)\n        measurement = measurement.clamp(self.min_width)\n        return measurement\n\n    @property\n    def padding(self) -> Tuple[int, int, int, int]:\n        \"\"\"Get cell padding.\"\"\"\n        return self._padding\n\n    @padding.setter\n    def padding(self, padding: PaddingDimensions) -> \"Table\":\n        \"\"\"Set cell padding.\"\"\"\n        self._padding = Padding.unpack(padding)\n        return self\n\n    def add_column(\n        self,\n        header: \"RenderableType\" = \"\",\n        footer: \"RenderableType\" = \"\",\n        *,\n        header_style: Optional[StyleType] = None,\n        highlight: Optional[bool] = None,\n        footer_style: Optional[StyleType] = None,\n        style: Optional[StyleType] = None,\n        justify: \"JustifyMethod\" = \"left\",\n        vertical: \"VerticalAlignMethod\" = \"top\",\n        overflow: \"OverflowMethod\" = \"ellipsis\",\n        width: Optional[int] = None,\n        min_width: Optional[int] = None,\n        max_width: Optional[int] = None,\n        ratio: Optional[int] = None,\n        no_wrap: bool = False,\n    ) -> None:\n        \"\"\"Add a column to the table.\n\n        Args:\n            header (RenderableType, optional): Text or renderable for the header.\n                Defaults to \"\".\n            footer (RenderableType, optional): Text or renderable for the footer.\n                Defaults to \"\".\n            header_style (Union[str, Style], optional): Style for the header, or None for default. Defaults to None.\n            highlight (bool, optional): Whether to highlight the text. The default of None uses the value of the table (self) object.\n            footer_style (Union[str, Style], optional): Style for the footer, or None for default. Defaults to None.\n            style (Union[str, Style], optional): Style for the column cells, or None for default. Defaults to None.\n            justify (JustifyMethod, optional): Alignment for cells. Defaults to \"left\".\n            vertical (VerticalAlignMethod, optional): Vertical alignment, one of \"top\", \"middle\", or \"bottom\". Defaults to \"top\".\n            overflow (OverflowMethod): Overflow method: \"crop\", \"fold\", \"ellipsis\". Defaults to \"ellipsis\".\n            width (int, optional): Desired width of column in characters, or None to fit to contents. Defaults to None.\n            min_width (Optional[int], optional): Minimum width of column, or ``None`` for no minimum. Defaults to None.\n            max_width (Optional[int], optional): Maximum width of column, or ``None`` for no maximum. Defaults to None.\n            ratio (int, optional): Flexible ratio for the column (requires ``Table.expand`` or ``Table.width``). Defaults to None.\n            no_wrap (bool, optional): Set to ``True`` to disable wrapping of this column.\n        \"\"\"\n\n        column = Column(\n            _index=len(self.columns),\n            header=header,\n            footer=footer,\n            header_style=header_style or \"\",\n            highlight=highlight if highlight is not None else self.highlight,\n            footer_style=footer_style or \"\",\n            style=style or \"\",\n            justify=justify,\n            vertical=vertical,\n            overflow=overflow,\n            width=width,\n            min_width=min_width,\n            max_width=max_width,\n            ratio=ratio,\n            no_wrap=no_wrap,\n        )\n        self.columns.append(column)\n\n    def add_row(\n        self,\n        *renderables: Optional[\"RenderableType\"],\n        style: Optional[StyleType] = None,\n        end_section: bool = False,\n    ) -> None:\n        \"\"\"Add a row of renderables.\n\n        Args:\n            *renderables (None or renderable): Each cell in a row must be a renderable object (including str),\n                or ``None`` for a blank cell.\n            style (StyleType, optional): An optional style to apply to the entire row. Defaults to None.\n            end_section (bool, optional): End a section and draw a line. Defaults to False.\n\n        Raises:\n            errors.NotRenderableError: If you add something that can't be rendered.\n        \"\"\"\n\n        def add_cell(column: Column, renderable: \"RenderableType\") -> None:\n            column._cells.append(renderable)\n\n        cell_renderables: List[Optional[\"RenderableType\"]] = list(renderables)\n\n        columns = self.columns\n        if len(cell_renderables) < len(columns):\n            cell_renderables = [\n                *cell_renderables,\n                *[None] * (len(columns) - len(cell_renderables)),\n            ]\n        for index, renderable in enumerate(cell_renderables):\n            if index == len(columns):\n                column = Column(_index=index, highlight=self.highlight)\n                for _ in self.rows:\n                    add_cell(column, Text(\"\"))\n                self.columns.append(column)\n            else:\n                column = columns[index]\n            if renderable is None:\n                add_cell(column, \"\")\n            elif is_renderable(renderable):\n                add_cell(column, renderable)\n            else:\n                raise errors.NotRenderableError(\n                    f\"unable to render {type(renderable).__name__}; a string or other renderable object is required\"\n                )\n        self.rows.append(Row(style=style, end_section=end_section))\n\n    def add_section(self) -> None:\n        \"\"\"Add a new section (draw a line after current row).\"\"\"\n\n        if self.rows:\n            self.rows[-1].end_section = True\n\n    def __rich_console__(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> \"RenderResult\":\n        if not self.columns:\n            yield Segment(\"\\n\")\n            return\n\n        max_width = options.max_width\n        if self.width is not None:\n            max_width = self.width\n\n        extra_width = self._extra_width\n        widths = self._calculate_column_widths(\n            console, options.update_width(max_width - extra_width)\n        )\n        table_width = sum(widths) + extra_width\n\n        render_options = options.update(\n            width=table_width, highlight=self.highlight, height=None\n        )\n\n        def render_annotation(\n            text: TextType, style: StyleType, justify: \"JustifyMethod\" = \"center\"\n        ) -> \"RenderResult\":\n            render_text = (\n                console.render_str(text, style=style, highlight=False)\n                if isinstance(text, str)\n                else text\n            )\n            return console.render(\n                render_text, options=render_options.update(justify=justify)\n            )\n\n        if self.title:\n            yield from render_annotation(\n                self.title,\n                style=Style.pick_first(self.title_style, \"table.title\"),\n                justify=self.title_justify,\n            )\n        yield from self._render(console, render_options, widths)\n        if self.caption:\n            yield from render_annotation(\n                self.caption,\n                style=Style.pick_first(self.caption_style, \"table.caption\"),\n                justify=self.caption_justify,\n            )\n\n    def _calculate_column_widths(\n        self, console: \"Console\", options: \"ConsoleOptions\"\n    ) -> List[int]:\n        \"\"\"Calculate the widths of each column, including padding, not including borders.\"\"\"\n        max_width = options.max_width\n        columns = self.columns\n        width_ranges = [\n            self._measure_column(console, options, column) for column in columns\n        ]\n        widths = [_range.maximum or 1 for _range in width_ranges]\n        get_padding_width = self._get_padding_width\n        extra_width = self._extra_width\n        if self.expand:\n            ratios = [col.ratio or 0 for col in columns if col.flexible]\n            if any(ratios):\n                fixed_widths = [\n                    0 if column.flexible else _range.maximum\n                    for _range, column in zip(width_ranges, columns)\n                ]\n                flex_minimum = [\n                    (column.width or 1) + get_padding_width(column._index)\n                    for column in columns\n                    if column.flexible\n                ]\n                flexible_width = max_width - sum(fixed_widths)\n                flex_widths = ratio_distribute(flexible_width, ratios, flex_minimum)\n                iter_flex_widths = iter(flex_widths)\n                for index, column in enumerate(columns):\n                    if column.flexible:\n                        widths[index] = fixed_widths[index] + next(iter_flex_widths)\n        table_width = sum(widths)\n\n        if table_width > max_width:\n            widths = self._collapse_widths(\n                widths,\n                [(column.width is None and not column.no_wrap) for column in columns],\n                max_width,\n            )\n            table_width = sum(widths)\n            # last resort, reduce columns evenly\n            if table_width > max_width:\n                excess_width = table_width - max_width\n                widths = ratio_reduce(excess_width, [1] * len(widths), widths, widths)\n                table_width = sum(widths)\n\n            width_ranges = [\n                self._measure_column(console, options.update_width(width), column)\n                for width, column in zip(widths, columns)\n            ]\n            widths = [_range.maximum or 0 for _range in width_ranges]\n\n        if (table_width < max_width and self.expand) or (\n            self.min_width is not None and table_width < (self.min_width - extra_width)\n        ):\n            _max_width = (\n                max_width\n                if self.min_width is None\n                else min(self.min_width - extra_width, max_width)\n            )\n            pad_widths = ratio_distribute(_max_width - table_width, widths)\n            widths = [_width + pad for _width, pad in zip(widths, pad_widths)]\n\n        return widths\n\n    @classmethod\n    def _collapse_widths(\n        cls, widths: List[int], wrapable: List[bool], max_width: int\n    ) -> List[int]:\n        \"\"\"Reduce widths so that the total is under max_width.\n\n        Args:\n            widths (List[int]): List of widths.\n            wrapable (List[bool]): List of booleans that indicate if a column may shrink.\n            max_width (int): Maximum width to reduce to.\n\n        Returns:\n            List[int]: A new list of widths.\n        \"\"\"\n        total_width = sum(widths)\n        excess_width = total_width - max_width\n        if any(wrapable):\n            while total_width and excess_width > 0:\n                max_column = max(\n                    width for width, allow_wrap in zip(widths, wrapable) if allow_wrap\n                )\n                second_max_column = max(\n                    width if allow_wrap and width != max_column else 0\n                    for width, allow_wrap in zip(widths, wrapable)\n                )\n                column_difference = max_column - second_max_column\n                ratios = [\n                    (1 if (width == max_column and allow_wrap) else 0)\n                    for width, allow_wrap in zip(widths, wrapable)\n                ]\n                if not any(ratios) or not column_difference:\n                    break\n                max_reduce = [min(excess_width, column_difference)] * len(widths)\n                widths = ratio_reduce(excess_width, ratios, max_reduce, widths)\n\n                total_width = sum(widths)\n                excess_width = total_width - max_width\n        return widths\n\n    def _get_cells(\n        self, console: \"Console\", column_index: int, column: Column\n    ) -> Iterable[_Cell]:\n        \"\"\"Get all the cells with padding and optional header.\"\"\"\n\n        collapse_padding = self.collapse_padding\n        pad_edge = self.pad_edge\n        padding = self.padding\n        any_padding = any(padding)\n\n        first_column = column_index == 0\n        last_column = column_index == len(self.columns) - 1\n\n        _padding_cache: Dict[Tuple[bool, bool], Tuple[int, int, int, int]] = {}\n\n        def get_padding(first_row: bool, last_row: bool) -> Tuple[int, int, int, int]:\n            cached = _padding_cache.get((first_row, last_row))\n            if cached:\n                return cached\n            top, right, bottom, left = padding\n\n            if collapse_padding:\n                if not first_column:\n                    left = max(0, left - right)\n                if not last_row:\n                    bottom = max(0, top - bottom)\n\n            if not pad_edge:\n                if first_column:\n                    left = 0\n                if last_column:\n                    right = 0\n                if first_row:\n                    top = 0\n                if last_row:\n                    bottom = 0\n            _padding = (top, right, bottom, left)\n            _padding_cache[(first_row, last_row)] = _padding\n            return _padding\n\n        raw_cells: List[Tuple[StyleType, \"RenderableType\"]] = []\n        _append = raw_cells.append\n        get_style = console.get_style\n        if self.show_header:\n            header_style = get_style(self.header_style or \"\") + get_style(\n                column.header_style\n            )\n            _append((header_style, column.header))\n        cell_style = get_style(column.style or \"\")\n        for cell in column.cells:\n            _append((cell_style, cell))\n        if self.show_footer:\n            footer_style = get_style(self.footer_style or \"\") + get_style(\n                column.footer_style\n            )\n            _append((footer_style, column.footer))\n\n        if any_padding:\n            _Padding = Padding\n            for first, last, (style, renderable) in loop_first_last(raw_cells):\n                yield _Cell(\n                    style,\n                    _Padding(renderable, get_padding(first, last)),\n                    getattr(renderable, \"vertical\", None) or column.vertical,\n                )\n        else:\n            for style, renderable in raw_cells:\n                yield _Cell(\n                    style,\n                    renderable,\n                    getattr(renderable, \"vertical\", None) or column.vertical,\n                )\n\n    def _get_padding_width(self, column_index: int) -> int:\n        \"\"\"Get extra width from padding.\"\"\"\n        _, pad_right, _, pad_left = self.padding\n        if self.collapse_padding:\n            if column_index > 0:\n                pad_left = max(0, pad_left - pad_right)\n        return pad_left + pad_right\n\n    def _measure_column(\n        self,\n        console: \"Console\",\n        options: \"ConsoleOptions\",\n        column: Column,\n    ) -> Measurement:\n        \"\"\"Get the minimum and maximum width of the column.\"\"\"\n\n        max_width = options.max_width\n        if max_width < 1:\n            return Measurement(0, 0)\n\n        padding_width = self._get_padding_width(column._index)\n\n        if column.width is not None:\n            # Fixed width column\n            return Measurement(\n                column.width + padding_width, column.width + padding_width\n            ).with_maximum(max_width)\n        # Flexible column, we need to measure contents\n        min_widths: List[int] = []\n        max_widths: List[int] = []\n        append_min = min_widths.append\n        append_max = max_widths.append\n        get_render_width = Measurement.get\n        for cell in self._get_cells(console, column._index, column):\n            _min, _max = get_render_width(console, options, cell.renderable)\n            append_min(_min)\n            append_max(_max)\n\n        measurement = Measurement(\n            max(min_widths) if min_widths else 1,\n            max(max_widths) if max_widths else max_width,\n        ).with_maximum(max_width)\n        measurement = measurement.clamp(\n            None if column.min_width is None else column.min_width + padding_width,\n            None if column.max_width is None else column.max_width + padding_width,\n        )\n        return measurement\n\n    def _render(\n        self, console: \"Console\", options: \"ConsoleOptions\", widths: List[int]\n    ) -> \"RenderResult\":\n        table_style = console.get_style(self.style or \"\")\n\n        border_style = table_style + console.get_style(self.border_style or \"\")\n        _column_cells = (\n            self._get_cells(console, column_index, column)\n            for column_index, column in enumerate(self.columns)\n        )\n        row_cells: List[Tuple[_Cell, ...]] = list(zip(*_column_cells))\n        _box = (\n            self.box.substitute(\n                options, safe=pick_bool(self.safe_box, console.safe_box)\n            )\n            if self.box\n            else None\n        )\n        _box = _box.get_plain_headed_box() if _box and not self.show_header else _box\n\n        new_line = Segment.line()\n\n        columns = self.columns\n        show_header = self.show_header\n        show_footer = self.show_footer\n        show_edge = self.show_edge\n        show_lines = self.show_lines\n        leading = self.leading\n\n        _Segment = Segment\n        if _box:\n            box_segments = [\n                (\n                    _Segment(_box.head_left, border_style),\n                    _Segment(_box.head_right, border_style),\n                    _Segment(_box.head_vertical, border_style),\n                ),\n                (\n                    _Segment(_box.mid_left, border_style),\n                    _Segment(_box.mid_right, border_style),\n                    _Segment(_box.mid_vertical, border_style),\n                ),\n                (\n                    _Segment(_box.foot_left, border_style),\n                    _Segment(_box.foot_right, border_style),\n                    _Segment(_box.foot_vertical, border_style),\n                ),\n            ]\n            if show_edge:\n                yield _Segment(_box.get_top(widths), border_style)\n                yield new_line\n        else:\n            box_segments = []\n\n        get_row_style = self.get_row_style\n        get_style = console.get_style\n\n        for index, (first, last, row_cell) in enumerate(loop_first_last(row_cells)):\n            header_row = first and show_header\n            footer_row = last and show_footer\n            row = (\n                self.rows[index - show_header]\n                if (not header_row and not footer_row)\n                else None\n            )\n            max_height = 1\n            cells: List[List[List[Segment]]] = []\n            if header_row or footer_row:\n                row_style = Style.null()\n            else:\n                row_style = get_style(\n                    get_row_style(console, index - 1 if show_header else index)\n                )\n            for width, cell, column in zip(widths, row_cell, columns):\n                render_options = options.update(\n                    width=width,\n                    justify=column.justify,\n                    no_wrap=column.no_wrap,\n                    overflow=column.overflow,\n                    height=None,\n                    highlight=column.highlight,\n                )\n                lines = console.render_lines(\n                    cell.renderable,\n                    render_options,\n                    style=get_style(cell.style) + row_style,\n                )\n                max_height = max(max_height, len(lines))\n                cells.append(lines)\n\n            row_height = max(len(cell) for cell in cells)\n\n            def align_cell(\n                cell: List[List[Segment]],\n                vertical: \"VerticalAlignMethod\",\n                width: int,\n                style: Style,\n            ) -> List[List[Segment]]:\n                if header_row:\n                    vertical = \"bottom\"\n                elif footer_row:\n                    vertical = \"top\"\n\n                if vertical == \"top\":\n                    return _Segment.align_top(cell, width, row_height, style)\n                elif vertical == \"middle\":\n                    return _Segment.align_middle(cell, width, row_height, style)\n                return _Segment.align_bottom(cell, width, row_height, style)\n\n            cells[:] = [\n                _Segment.set_shape(\n                    align_cell(\n                        cell,\n                        _cell.vertical,\n                        width,\n                        get_style(_cell.style) + row_style,\n                    ),\n                    width,\n                    max_height,\n                )\n                for width, _cell, cell, column in zip(widths, row_cell, cells, columns)\n            ]\n\n            if _box:\n                if last and show_footer:\n                    yield _Segment(\n                        _box.get_row(widths, \"foot\", edge=show_edge), border_style\n                    )\n                    yield new_line\n                left, right, _divider = box_segments[0 if first else (2 if last else 1)]\n\n                # If the column divider is whitespace also style it with the row background\n                divider = (\n                    _divider\n                    if _divider.text.strip()\n                    else _Segment(\n                        _divider.text, row_style.background_style + _divider.style\n                    )\n                )\n                for line_no in range(max_height):\n                    if show_edge:\n                        yield left\n                    for last_cell, rendered_cell in loop_last(cells):\n                        yield from rendered_cell[line_no]\n                        if not last_cell:\n                            yield divider\n                    if show_edge:\n                        yield right\n                    yield new_line\n            else:\n                for line_no in range(max_height):\n                    for rendered_cell in cells:\n                        yield from rendered_cell[line_no]\n                    yield new_line\n            if _box and first and show_header:\n                yield _Segment(\n                    _box.get_row(widths, \"head\", edge=show_edge), border_style\n                )\n                yield new_line\n            end_section = row and row.end_section\n            if _box and (show_lines or leading or end_section):\n                if (\n                    not last\n                    and not (show_footer and index >= len(row_cells) - 2)\n                    and not (show_header and header_row)\n                ):\n                    if leading:\n                        yield _Segment(\n                            _box.get_row(widths, \"mid\", edge=show_edge) * leading,\n                            border_style,\n                        )\n                    else:\n                        yield _Segment(\n                            _box.get_row(widths, \"row\", edge=show_edge), border_style\n                        )\n                    yield new_line\n\n        if _box and show_edge:\n            yield _Segment(_box.get_bottom(widths), border_style)\n            yield new_line\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    from pip._vendor.rich.console import Console\n    from pip._vendor.rich.highlighter import ReprHighlighter\n    from pip._vendor.rich.table import Table as Table\n\n    from ._timer import timer\n\n    with timer(\"Table render\"):\n        table = Table(\n            title=\"Star Wars Movies\",\n            caption=\"Rich example table\",\n            caption_justify=\"right\",\n        )\n\n        table.add_column(\n            \"Released\", header_style=\"bright_cyan\", style=\"cyan\", no_wrap=True\n        )\n        table.add_column(\"Title\", style=\"magenta\")\n        table.add_column(\"Box Office\", justify=\"right\", style=\"green\")\n\n        table.add_row(\n            \"Dec 20, 2019\",\n            \"Star Wars: The Rise of Skywalker\",\n            \"$952,110,690\",\n        )\n        table.add_row(\"May 25, 2018\", \"Solo: A Star Wars Story\", \"$393,151,347\")\n        table.add_row(\n            \"Dec 15, 2017\",\n            \"Star Wars Ep. V111: The Last Jedi\",\n            \"$1,332,539,889\",\n            style=\"on black\",\n            end_section=True,\n        )\n        table.add_row(\n            \"Dec 16, 2016\",\n            \"Rogue One: A Star Wars Story\",\n            \"$1,332,439,889\",\n        )\n\n        def header(text: str) -> None:\n            console.print()\n            console.rule(highlight(text))\n            console.print()\n\n        console = Console()\n        highlight = ReprHighlighter()\n        header(\"Example Table\")\n        console.print(table, justify=\"center\")\n\n        table.expand = True\n        header(\"expand=True\")\n        console.print(table)\n\n        table.width = 50\n        header(\"width=50\")\n\n        console.print(table, justify=\"center\")\n\n        table.width = None\n        table.expand = False\n        table.row_styles = [\"dim\", \"none\"]\n        header(\"row_styles=['dim', 'none']\")\n\n        console.print(table, justify=\"center\")\n\n        table.width = None\n        table.expand = False\n        table.row_styles = [\"dim\", \"none\"]\n        table.leading = 1\n        header(\"leading=1, row_styles=['dim', 'none']\")\n        console.print(table, justify=\"center\")\n\n        table.width = None\n        table.expand = False\n        table.row_styles = [\"dim\", \"none\"]\n        table.show_lines = True\n        table.leading = 0\n        header(\"show_lines=True, row_styles=['dim', 'none']\")\n        console.print(table, justify=\"center\")\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/pip-25.0.1-py3-none-any/pip/_vendor/rich/terminal_theme.py","size":3370,"sha1":"006b559781a41f7f79c70ac0bdedad9f603c4d13","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import List, Optional, Tuple\n\nfrom .color_triplet import ColorTriplet\nfrom .palette import Palette\n\n_ColorTuple = Tuple[int, int, int]\n\n\nclass TerminalTheme:\n    \"\"\"A color theme used when exporting console content.\n\n    Args:\n        background (Tuple[int, int, int]): The background color.\n        foreground (Tuple[int, int, int]): The foreground (text) color.\n        normal (List[Tuple[int, int, int]]): A list of 8 normal intensity colors.\n        bright (List[Tuple[int, int, int]], optional): A list of 8 bright colors, or None\n            to repeat normal intensity. Defaults to None.\n    \"\"\"\n\n    def __init__(\n        self,\n        background: _ColorTuple,\n        foreground: _ColorTuple,\n        normal: List[_ColorTuple],\n        bright: Optional[List[_ColorTuple]] = None,\n    ) -> None:\n        self.background_color = ColorTriplet(*background)\n        self.foreground_color = ColorTriplet(*foreground)\n        self.ansi_colors = Palette(normal + (bright or normal))\n\n\nDEFAULT_TERMINAL_THEME = TerminalTheme(\n    (255, 255, 255),\n    (0, 0, 0),\n    [\n        (0, 0, 0),\n        (128, 0, 0),\n        (0, 128, 0),\n        (128, 128, 0),\n        (0, 0, 128),\n        (128, 0, 128),\n        (0, 128, 128),\n        (192, 192, 192),\n    ],\n    [\n        (128, 128, 128),\n        (255, 0, 0),\n        (0, 255, 0),\n        (255, 255, 0),\n        (0, 0, 255),\n        (255, 0, 255),\n        (0, 255, 255),\n        (255, 255, 255),\n    ],\n)\n\nMONOKAI = TerminalTheme(\n    (12, 12, 12),\n    (217, 217, 217),\n    [\n        (26, 26, 26),\n        (244, 0, 95),\n        (152, 224, 36),\n        (253, 151, 31),\n        (157, 101, 255),\n        (244, 0, 95),\n        (88, 209, 235),\n        (196, 197, 181),\n        (98, 94, 76),\n    ],\n    [\n        (244, 0, 95),\n        (152, 224, 36),\n        (224, 213, 97),\n        (157, 101, 255),\n        (244, 0, 95),\n        (88, 209, 235),\n        (246, 246, 239),\n    ],\n)\nDIMMED_MONOKAI = TerminalTheme(\n    (25, 25, 25),\n    (185, 188, 186),\n    [\n        (58, 61, 67),\n        (190, 63, 72),\n        (135, 154, 59),\n        (197, 166, 53),\n        (79, 118, 161),\n        (133, 92, 141),\n        (87, 143, 164),\n        (185, 188, 186),\n        (136, 137, 135),\n    ],\n    [\n        (251, 0, 31),\n        (15, 114, 47),\n        (196, 112, 51),\n        (24, 109, 227),\n        (251, 0, 103),\n        (46, 112, 109),\n        (253, 255, 185),\n    ],\n)\nNIGHT_OWLISH = TerminalTheme(\n    (255, 255, 255),\n    (64, 63, 83),\n    [\n        (1, 22, 39),\n        (211, 66, 62),\n        (42, 162, 152),\n        (218, 170, 1),\n        (72, 118, 214),\n        (64, 63, 83),\n        (8, 145, 106),\n        (122, 129, 129),\n        (122, 129, 129),\n    ],\n    [\n        (247, 110, 110),\n        (73, 208, 197),\n        (218, 194, 107),\n        (92, 167, 228),\n        (105, 112, 152),\n        (0, 201, 144),\n        (152, 159, 177),\n    ],\n)\n\nSVG_EXPORT_THEME = TerminalTheme(\n    (41, 41, 41),\n    (197, 200, 198),\n    [\n        (75, 78, 85),\n        (204, 85, 90),\n        (152, 168, 75),\n        (208, 179, 68),\n        (96, 138, 177),\n        (152, 114, 159),\n        (104, 160, 179),\n        (197, 200, 198),\n        (154, 155, 153),\n    ],\n    [\n        (255, 38, 39),\n        (0, 130, 61),\n        (208, 132, 66),\n        (25, 132, 233),\n        (255, 44, 122),\n        (57, 130, 128),\n        (253, 253, 197),\n    ],\n)\n"}]}