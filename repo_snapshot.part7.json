{"generated_at":"2025-08-17T20:04:18.057896Z","root":"/home/runner/workspace","git":{"head":"7b7135163eb4227ef98e4c2d7b4ab78ea306bd73","branch":"main","status":" M corrections.db\n?? app_changes.json\n?? export_changes.py\n"},"filters":{"git_range":null,"since":null,"include_ext":[".cfg",".css",".env",".htm",".html",".ini",".jinja",".jinja2",".js",".json",".md",".py",".toml",".ts",".yaml",".yml"],"exclude_dirs":[".git",".ipynb_checkpoints",".mypy_cache",".pytest_cache",".pythonlibs",".venv","__pycache__","cache","chroma_db","data/exports","node_modules","venv"],"exclude_globs":["*.bmp","*.db","*.feather","*.gif","*.gz","*.ico","*.jpeg","*.jpg","*.jsonl","*.lock","*.log","*.parquet","*.png","*.sqlite","*.sqlite3","*.tar","*.webp","*.zip"],"max_file_bytes":400000},"summary":{"file_count":876,"total_bytes":9265289},"files":[{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/pkg_resources/tests/test_pkg_resources.py","size":15207,"sha1":"3529ba4bf6b4c32f5ef5b8c55b6addeb3831b754","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport builtins\nimport datetime\nimport os\nimport plistlib\nimport stat\nimport subprocess\nimport sys\nimport tempfile\nimport zipfile\nfrom unittest import mock\n\nimport pytest\n\nimport pkg_resources\nfrom pkg_resources import DistInfoDistribution, Distribution, EggInfoDistribution\n\nimport distutils.command.install_egg_info\nimport distutils.dist\n\n\nclass EggRemover(str):\n    def __call__(self):\n        if self in sys.path:\n            sys.path.remove(self)\n        if os.path.exists(self):\n            os.remove(self)\n\n\nclass TestZipProvider:\n    finalizers: list[EggRemover] = []\n\n    ref_time = datetime.datetime(2013, 5, 12, 13, 25, 0)\n    \"A reference time for a file modification\"\n\n    @classmethod\n    def setup_class(cls):\n        \"create a zip egg and add it to sys.path\"\n        egg = tempfile.NamedTemporaryFile(suffix='.egg', delete=False)\n        zip_egg = zipfile.ZipFile(egg, 'w')\n        zip_info = zipfile.ZipInfo()\n        zip_info.filename = 'mod.py'\n        zip_info.date_time = cls.ref_time.timetuple()\n        zip_egg.writestr(zip_info, 'x = 3\\n')\n        zip_info = zipfile.ZipInfo()\n        zip_info.filename = 'data.dat'\n        zip_info.date_time = cls.ref_time.timetuple()\n        zip_egg.writestr(zip_info, 'hello, world!')\n        zip_info = zipfile.ZipInfo()\n        zip_info.filename = 'subdir/mod2.py'\n        zip_info.date_time = cls.ref_time.timetuple()\n        zip_egg.writestr(zip_info, 'x = 6\\n')\n        zip_info = zipfile.ZipInfo()\n        zip_info.filename = 'subdir/data2.dat'\n        zip_info.date_time = cls.ref_time.timetuple()\n        zip_egg.writestr(zip_info, 'goodbye, world!')\n        zip_egg.close()\n        egg.close()\n\n        sys.path.append(egg.name)\n        subdir = os.path.join(egg.name, 'subdir')\n        sys.path.append(subdir)\n        cls.finalizers.append(EggRemover(subdir))\n        cls.finalizers.append(EggRemover(egg.name))\n\n    @classmethod\n    def teardown_class(cls):\n        for finalizer in cls.finalizers:\n            finalizer()\n\n    def test_resource_listdir(self):\n        import mod  # pyright: ignore[reportMissingImports] # Temporary package for test\n\n        zp = pkg_resources.ZipProvider(mod)\n\n        expected_root = ['data.dat', 'mod.py', 'subdir']\n        assert sorted(zp.resource_listdir('')) == expected_root\n\n        expected_subdir = ['data2.dat', 'mod2.py']\n        assert sorted(zp.resource_listdir('subdir')) == expected_subdir\n        assert sorted(zp.resource_listdir('subdir/')) == expected_subdir\n\n        assert zp.resource_listdir('nonexistent') == []\n        assert zp.resource_listdir('nonexistent/') == []\n\n        import mod2  # pyright: ignore[reportMissingImports] # Temporary package for test\n\n        zp2 = pkg_resources.ZipProvider(mod2)\n\n        assert sorted(zp2.resource_listdir('')) == expected_subdir\n\n        assert zp2.resource_listdir('subdir') == []\n        assert zp2.resource_listdir('subdir/') == []\n\n    def test_resource_filename_rewrites_on_change(self):\n        \"\"\"\n        If a previous call to get_resource_filename has saved the file, but\n        the file has been subsequently mutated with different file of the\n        same size and modification time, it should not be overwritten on a\n        subsequent call to get_resource_filename.\n        \"\"\"\n        import mod  # pyright: ignore[reportMissingImports] # Temporary package for test\n\n        manager = pkg_resources.ResourceManager()\n        zp = pkg_resources.ZipProvider(mod)\n        filename = zp.get_resource_filename(manager, 'data.dat')\n        actual = datetime.datetime.fromtimestamp(os.stat(filename).st_mtime)\n        assert actual == self.ref_time\n        f = open(filename, 'w', encoding=\"utf-8\")\n        f.write('hello, world?')\n        f.close()\n        ts = self.ref_time.timestamp()\n        os.utime(filename, (ts, ts))\n        filename = zp.get_resource_filename(manager, 'data.dat')\n        with open(filename, encoding=\"utf-8\") as f:\n            assert f.read() == 'hello, world!'\n        manager.cleanup_resources()\n\n\nclass TestResourceManager:\n    def test_get_cache_path(self):\n        mgr = pkg_resources.ResourceManager()\n        path = mgr.get_cache_path('foo')\n        type_ = str(type(path))\n        message = \"Unexpected type from get_cache_path: \" + type_\n        assert isinstance(path, str), message\n\n    def test_get_cache_path_race(self, tmpdir):\n        # Patch to os.path.isdir to create a race condition\n        def patched_isdir(dirname, unpatched_isdir=pkg_resources.isdir):\n            patched_isdir.dirnames.append(dirname)\n\n            was_dir = unpatched_isdir(dirname)\n            if not was_dir:\n                os.makedirs(dirname)\n            return was_dir\n\n        patched_isdir.dirnames = []\n\n        # Get a cache path with a \"race condition\"\n        mgr = pkg_resources.ResourceManager()\n        mgr.set_extraction_path(str(tmpdir))\n\n        archive_name = os.sep.join(('foo', 'bar', 'baz'))\n        with mock.patch.object(pkg_resources, 'isdir', new=patched_isdir):\n            mgr.get_cache_path(archive_name)\n\n        # Because this test relies on the implementation details of this\n        # function, these assertions are a sentinel to ensure that the\n        # test suite will not fail silently if the implementation changes.\n        called_dirnames = patched_isdir.dirnames\n        assert len(called_dirnames) == 2\n        assert called_dirnames[0].split(os.sep)[-2:] == ['foo', 'bar']\n        assert called_dirnames[1].split(os.sep)[-1:] == ['foo']\n\n    \"\"\"\n    Tests to ensure that pkg_resources runs independently from setuptools.\n    \"\"\"\n\n    def test_setuptools_not_imported(self):\n        \"\"\"\n        In a separate Python environment, import pkg_resources and assert\n        that action doesn't cause setuptools to be imported.\n        \"\"\"\n        lines = (\n            'import pkg_resources',\n            'import sys',\n            ('assert \"setuptools\" not in sys.modules, \"setuptools was imported\"'),\n        )\n        cmd = [sys.executable, '-c', '; '.join(lines)]\n        subprocess.check_call(cmd)\n\n\ndef make_test_distribution(metadata_path, metadata):\n    \"\"\"\n    Make a test Distribution object, and return it.\n\n    :param metadata_path: the path to the metadata file that should be\n        created. This should be inside a distribution directory that should\n        also be created. For example, an argument value might end with\n        \"<project>.dist-info/METADATA\".\n    :param metadata: the desired contents of the metadata file, as bytes.\n    \"\"\"\n    dist_dir = os.path.dirname(metadata_path)\n    os.mkdir(dist_dir)\n    with open(metadata_path, 'wb') as f:\n        f.write(metadata)\n    dists = list(pkg_resources.distributions_from_metadata(dist_dir))\n    (dist,) = dists\n\n    return dist\n\n\ndef test_get_metadata__bad_utf8(tmpdir):\n    \"\"\"\n    Test a metadata file with bytes that can't be decoded as utf-8.\n    \"\"\"\n    filename = 'METADATA'\n    # Convert the tmpdir LocalPath object to a string before joining.\n    metadata_path = os.path.join(str(tmpdir), 'foo.dist-info', filename)\n    # Encode a non-ascii string with the wrong encoding (not utf-8).\n    metadata = 'née'.encode('iso-8859-1')\n    dist = make_test_distribution(metadata_path, metadata=metadata)\n\n    with pytest.raises(UnicodeDecodeError) as excinfo:\n        dist.get_metadata(filename)\n\n    exc = excinfo.value\n    actual = str(exc)\n    expected = (\n        # The error message starts with \"'utf-8' codec ...\" However, the\n        # spelling of \"utf-8\" can vary (e.g. \"utf8\") so we don't include it\n        \"codec can't decode byte 0xe9 in position 1: \"\n        'invalid continuation byte in METADATA file at path: '\n    )\n    assert expected in actual, f'actual: {actual}'\n    assert actual.endswith(metadata_path), f'actual: {actual}'\n\n\ndef make_distribution_no_version(tmpdir, basename):\n    \"\"\"\n    Create a distribution directory with no file containing the version.\n    \"\"\"\n    dist_dir = tmpdir / basename\n    dist_dir.ensure_dir()\n    # Make the directory non-empty so distributions_from_metadata()\n    # will detect it and yield it.\n    dist_dir.join('temp.txt').ensure()\n\n    dists = list(pkg_resources.distributions_from_metadata(dist_dir))\n    assert len(dists) == 1\n    (dist,) = dists\n\n    return dist, dist_dir\n\n\n@pytest.mark.parametrize(\n    (\"suffix\", \"expected_filename\", \"expected_dist_type\"),\n    [\n        ('egg-info', 'PKG-INFO', EggInfoDistribution),\n        ('dist-info', 'METADATA', DistInfoDistribution),\n    ],\n)\n@pytest.mark.xfail(\n    sys.version_info[:2] == (3, 12) and sys.version_info.releaselevel != 'final',\n    reason=\"https://github.com/python/cpython/issues/103632\",\n)\ndef test_distribution_version_missing(\n    tmpdir, suffix, expected_filename, expected_dist_type\n):\n    \"\"\"\n    Test Distribution.version when the \"Version\" header is missing.\n    \"\"\"\n    basename = f'foo.{suffix}'\n    dist, dist_dir = make_distribution_no_version(tmpdir, basename)\n\n    expected_text = (\n        f\"Missing 'Version:' header and/or {expected_filename} file at path: \"\n    )\n    metadata_path = os.path.join(dist_dir, expected_filename)\n\n    # Now check the exception raised when the \"version\" attribute is accessed.\n    with pytest.raises(ValueError) as excinfo:\n        dist.version\n\n    err = str(excinfo.value)\n    # Include a string expression after the assert so the full strings\n    # will be visible for inspection on failure.\n    assert expected_text in err, str((expected_text, err))\n\n    # Also check the args passed to the ValueError.\n    msg, dist = excinfo.value.args\n    assert expected_text in msg\n    # Check that the message portion contains the path.\n    assert metadata_path in msg, str((metadata_path, msg))\n    assert type(dist) is expected_dist_type\n\n\n@pytest.mark.xfail(\n    sys.version_info[:2] == (3, 12) and sys.version_info.releaselevel != 'final',\n    reason=\"https://github.com/python/cpython/issues/103632\",\n)\ndef test_distribution_version_missing_undetected_path():\n    \"\"\"\n    Test Distribution.version when the \"Version\" header is missing and\n    the path can't be detected.\n    \"\"\"\n    # Create a Distribution object with no metadata argument, which results\n    # in an empty metadata provider.\n    dist = Distribution('/foo')\n    with pytest.raises(ValueError) as excinfo:\n        dist.version\n\n    msg, dist = excinfo.value.args\n    expected = (\n        \"Missing 'Version:' header and/or PKG-INFO file at path: [could not detect]\"\n    )\n    assert msg == expected\n\n\n@pytest.mark.parametrize('only', [False, True])\ndef test_dist_info_is_not_dir(tmp_path, only):\n    \"\"\"Test path containing a file with dist-info extension.\"\"\"\n    dist_info = tmp_path / 'foobar.dist-info'\n    dist_info.touch()\n    assert not pkg_resources.dist_factory(str(tmp_path), str(dist_info), only)\n\n\ndef test_macos_vers_fallback(monkeypatch, tmp_path):\n    \"\"\"Regression test for pkg_resources._macos_vers\"\"\"\n    orig_open = builtins.open\n\n    # Pretend we need to use the plist file\n    monkeypatch.setattr('platform.mac_ver', mock.Mock(return_value=('', (), '')))\n\n    # Create fake content for the fake plist file\n    with open(tmp_path / 'fake.plist', 'wb') as fake_file:\n        plistlib.dump({\"ProductVersion\": \"11.4\"}, fake_file)\n\n    # Pretend the fake file exists\n    monkeypatch.setattr('os.path.exists', mock.Mock(return_value=True))\n\n    def fake_open(file, *args, **kwargs):\n        return orig_open(tmp_path / 'fake.plist', *args, **kwargs)\n\n    # Ensure that the _macos_vers works correctly\n    with mock.patch('builtins.open', mock.Mock(side_effect=fake_open)) as m:\n        pkg_resources._macos_vers.cache_clear()\n        assert pkg_resources._macos_vers() == [\"11\", \"4\"]\n        pkg_resources._macos_vers.cache_clear()\n\n    m.assert_called()\n\n\nclass TestDeepVersionLookupDistutils:\n    @pytest.fixture\n    def env(self, tmpdir):\n        \"\"\"\n        Create a package environment, similar to a virtualenv,\n        in which packages are installed.\n        \"\"\"\n\n        class Environment(str):\n            pass\n\n        env = Environment(tmpdir)\n        tmpdir.chmod(stat.S_IRWXU)\n        subs = 'home', 'lib', 'scripts', 'data', 'egg-base'\n        env.paths = dict((dirname, str(tmpdir / dirname)) for dirname in subs)\n        list(map(os.mkdir, env.paths.values()))\n        return env\n\n    def create_foo_pkg(self, env, version):\n        \"\"\"\n        Create a foo package installed (distutils-style) to env.paths['lib']\n        as version.\n        \"\"\"\n        ld = \"This package has unicode metadata! ❄\"\n        attrs = dict(name='foo', version=version, long_description=ld)\n        dist = distutils.dist.Distribution(attrs)\n        iei_cmd = distutils.command.install_egg_info.install_egg_info(dist)\n        iei_cmd.initialize_options()\n        iei_cmd.install_dir = env.paths['lib']\n        iei_cmd.finalize_options()\n        iei_cmd.run()\n\n    def test_version_resolved_from_egg_info(self, env):\n        version = '1.11.0.dev0+2329eae'\n        self.create_foo_pkg(env, version)\n\n        # this requirement parsing will raise a VersionConflict unless the\n        # .egg-info file is parsed (see #419 on BitBucket)\n        req = pkg_resources.Requirement.parse('foo>=1.9')\n        dist = pkg_resources.WorkingSet([env.paths['lib']]).find(req)\n        assert dist.version == version\n\n    @pytest.mark.parametrize(\n        (\"unnormalized\", \"normalized\"),\n        [\n            ('foo', 'foo'),\n            ('foo/', 'foo'),\n            ('foo/bar', 'foo/bar'),\n            ('foo/bar/', 'foo/bar'),\n        ],\n    )\n    def test_normalize_path_trailing_sep(self, unnormalized, normalized):\n        \"\"\"Ensure the trailing slash is cleaned for path comparison.\n\n        See pypa/setuptools#1519.\n        \"\"\"\n        result_from_unnormalized = pkg_resources.normalize_path(unnormalized)\n        result_from_normalized = pkg_resources.normalize_path(normalized)\n        assert result_from_unnormalized == result_from_normalized\n\n    @pytest.mark.skipif(\n        os.path.normcase('A') != os.path.normcase('a'),\n        reason='Testing case-insensitive filesystems.',\n    )\n    @pytest.mark.parametrize(\n        (\"unnormalized\", \"normalized\"),\n        [\n            ('MiXeD/CasE', 'mixed/case'),\n        ],\n    )\n    def test_normalize_path_normcase(self, unnormalized, normalized):\n        \"\"\"Ensure mixed case is normalized on case-insensitive filesystems.\"\"\"\n        result_from_unnormalized = pkg_resources.normalize_path(unnormalized)\n        result_from_normalized = pkg_resources.normalize_path(normalized)\n        assert result_from_unnormalized == result_from_normalized\n\n    @pytest.mark.skipif(\n        os.path.sep != '\\\\',\n        reason='Testing systems using backslashes as path separators.',\n    )\n    @pytest.mark.parametrize(\n        (\"unnormalized\", \"expected\"),\n        [\n            ('forward/slash', 'forward\\\\slash'),\n            ('forward/slash/', 'forward\\\\slash'),\n            ('backward\\\\slash\\\\', 'backward\\\\slash'),\n        ],\n    )\n    def test_normalize_path_backslash_sep(self, unnormalized, expected):\n        \"\"\"Ensure path seps are cleaned on backslash path sep systems.\"\"\"\n        result = pkg_resources.normalize_path(unnormalized)\n        assert result.endswith(expected)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/pkg_resources/tests/test_resources.py","size":31252,"sha1":"68c83b69d23d91940b4908a066fe97056ba5f236","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import itertools\nimport os\nimport platform\nimport string\nimport sys\n\nimport pytest\nfrom packaging.specifiers import SpecifierSet\n\nimport pkg_resources\nfrom pkg_resources import (\n    Distribution,\n    EntryPoint,\n    Requirement,\n    VersionConflict,\n    WorkingSet,\n    parse_requirements,\n    parse_version,\n    safe_name,\n    safe_version,\n)\n\n\n# from Python 3.6 docs. Available from itertools on Python 3.10\ndef pairwise(iterable):\n    \"s -> (s0,s1), (s1,s2), (s2, s3), ...\"\n    a, b = itertools.tee(iterable)\n    next(b, None)\n    return zip(a, b)\n\n\nclass Metadata(pkg_resources.EmptyProvider):\n    \"\"\"Mock object to return metadata as if from an on-disk distribution\"\"\"\n\n    def __init__(self, *pairs) -> None:\n        self.metadata = dict(pairs)\n\n    def has_metadata(self, name) -> bool:\n        return name in self.metadata\n\n    def get_metadata(self, name):\n        return self.metadata[name]\n\n    def get_metadata_lines(self, name):\n        return pkg_resources.yield_lines(self.get_metadata(name))\n\n\ndist_from_fn = pkg_resources.Distribution.from_filename\n\n\nclass TestDistro:\n    def testCollection(self):\n        # empty path should produce no distributions\n        ad = pkg_resources.Environment([], platform=None, python=None)\n        assert list(ad) == []\n        assert ad['FooPkg'] == []\n        ad.add(dist_from_fn(\"FooPkg-1.3_1.egg\"))\n        ad.add(dist_from_fn(\"FooPkg-1.4-py2.4-win32.egg\"))\n        ad.add(dist_from_fn(\"FooPkg-1.2-py2.4.egg\"))\n\n        # Name is in there now\n        assert ad['FooPkg']\n        # But only 1 package\n        assert list(ad) == ['foopkg']\n\n        # Distributions sort by version\n        expected = ['1.4', '1.3-1', '1.2']\n        assert [dist.version for dist in ad['FooPkg']] == expected\n\n        # Removing a distribution leaves sequence alone\n        ad.remove(ad['FooPkg'][1])\n        assert [dist.version for dist in ad['FooPkg']] == ['1.4', '1.2']\n\n        # And inserting adds them in order\n        ad.add(dist_from_fn(\"FooPkg-1.9.egg\"))\n        assert [dist.version for dist in ad['FooPkg']] == ['1.9', '1.4', '1.2']\n\n        ws = WorkingSet([])\n        foo12 = dist_from_fn(\"FooPkg-1.2-py2.4.egg\")\n        foo14 = dist_from_fn(\"FooPkg-1.4-py2.4-win32.egg\")\n        (req,) = parse_requirements(\"FooPkg>=1.3\")\n\n        # Nominal case: no distros on path, should yield all applicable\n        assert ad.best_match(req, ws).version == '1.9'\n        # If a matching distro is already installed, should return only that\n        ws.add(foo14)\n        assert ad.best_match(req, ws).version == '1.4'\n\n        # If the first matching distro is unsuitable, it's a version conflict\n        ws = WorkingSet([])\n        ws.add(foo12)\n        ws.add(foo14)\n        with pytest.raises(VersionConflict):\n            ad.best_match(req, ws)\n\n        # If more than one match on the path, the first one takes precedence\n        ws = WorkingSet([])\n        ws.add(foo14)\n        ws.add(foo12)\n        ws.add(foo14)\n        assert ad.best_match(req, ws).version == '1.4'\n\n    def checkFooPkg(self, d):\n        assert d.project_name == \"FooPkg\"\n        assert d.key == \"foopkg\"\n        assert d.version == \"1.3.post1\"\n        assert d.py_version == \"2.4\"\n        assert d.platform == \"win32\"\n        assert d.parsed_version == parse_version(\"1.3-1\")\n\n    def testDistroBasics(self):\n        d = Distribution(\n            \"/some/path\",\n            project_name=\"FooPkg\",\n            version=\"1.3-1\",\n            py_version=\"2.4\",\n            platform=\"win32\",\n        )\n        self.checkFooPkg(d)\n\n        d = Distribution(\"/some/path\")\n        assert d.py_version == f'{sys.version_info.major}.{sys.version_info.minor}'\n        assert d.platform is None\n\n    def testDistroParse(self):\n        d = dist_from_fn(\"FooPkg-1.3.post1-py2.4-win32.egg\")\n        self.checkFooPkg(d)\n        d = dist_from_fn(\"FooPkg-1.3.post1-py2.4-win32.egg-info\")\n        self.checkFooPkg(d)\n\n    def testDistroMetadata(self):\n        d = Distribution(\n            \"/some/path\",\n            project_name=\"FooPkg\",\n            py_version=\"2.4\",\n            platform=\"win32\",\n            metadata=Metadata(('PKG-INFO', \"Metadata-Version: 1.0\\nVersion: 1.3-1\\n\")),\n        )\n        self.checkFooPkg(d)\n\n    def distRequires(self, txt):\n        return Distribution(\"/foo\", metadata=Metadata(('depends.txt', txt)))\n\n    def checkRequires(self, dist, txt, extras=()):\n        assert list(dist.requires(extras)) == list(parse_requirements(txt))\n\n    def testDistroDependsSimple(self):\n        for v in \"Twisted>=1.5\", \"Twisted>=1.5\\nZConfig>=2.0\":\n            self.checkRequires(self.distRequires(v), v)\n\n    needs_object_dir = pytest.mark.skipif(\n        not hasattr(object, '__dir__'),\n        reason='object.__dir__ necessary for self.__dir__ implementation',\n    )\n\n    def test_distribution_dir(self):\n        d = pkg_resources.Distribution()\n        dir(d)\n\n    @needs_object_dir\n    def test_distribution_dir_includes_provider_dir(self):\n        d = pkg_resources.Distribution()\n        before = d.__dir__()\n        assert 'test_attr' not in before\n        d._provider.test_attr = None\n        after = d.__dir__()\n        assert len(after) == len(before) + 1\n        assert 'test_attr' in after\n\n    @needs_object_dir\n    def test_distribution_dir_ignores_provider_dir_leading_underscore(self):\n        d = pkg_resources.Distribution()\n        before = d.__dir__()\n        assert '_test_attr' not in before\n        d._provider._test_attr = None\n        after = d.__dir__()\n        assert len(after) == len(before)\n        assert '_test_attr' not in after\n\n    def testResolve(self):\n        ad = pkg_resources.Environment([])\n        ws = WorkingSet([])\n        # Resolving no requirements -> nothing to install\n        assert list(ws.resolve([], ad)) == []\n        # Request something not in the collection -> DistributionNotFound\n        with pytest.raises(pkg_resources.DistributionNotFound):\n            ws.resolve(parse_requirements(\"Foo\"), ad)\n\n        Foo = Distribution.from_filename(\n            \"/foo_dir/Foo-1.2.egg\",\n            metadata=Metadata(('depends.txt', \"[bar]\\nBaz>=2.0\")),\n        )\n        ad.add(Foo)\n        ad.add(Distribution.from_filename(\"Foo-0.9.egg\"))\n\n        # Request thing(s) that are available -> list to activate\n        for i in range(3):\n            targets = list(ws.resolve(parse_requirements(\"Foo\"), ad))\n            assert targets == [Foo]\n            list(map(ws.add, targets))\n        with pytest.raises(VersionConflict):\n            ws.resolve(parse_requirements(\"Foo==0.9\"), ad)\n        ws = WorkingSet([])  # reset\n\n        # Request an extra that causes an unresolved dependency for \"Baz\"\n        with pytest.raises(pkg_resources.DistributionNotFound):\n            ws.resolve(parse_requirements(\"Foo[bar]\"), ad)\n        Baz = Distribution.from_filename(\n            \"/foo_dir/Baz-2.1.egg\", metadata=Metadata(('depends.txt', \"Foo\"))\n        )\n        ad.add(Baz)\n\n        # Activation list now includes resolved dependency\n        assert list(ws.resolve(parse_requirements(\"Foo[bar]\"), ad)) == [Foo, Baz]\n        # Requests for conflicting versions produce VersionConflict\n        with pytest.raises(VersionConflict) as vc:\n            ws.resolve(parse_requirements(\"Foo==1.2\\nFoo!=1.2\"), ad)\n\n        msg = 'Foo 0.9 is installed but Foo==1.2 is required'\n        assert vc.value.report() == msg\n\n    def test_environment_marker_evaluation_negative(self):\n        \"\"\"Environment markers are evaluated at resolution time.\"\"\"\n        ad = pkg_resources.Environment([])\n        ws = WorkingSet([])\n        res = ws.resolve(parse_requirements(\"Foo;python_version<'2'\"), ad)\n        assert list(res) == []\n\n    def test_environment_marker_evaluation_positive(self):\n        ad = pkg_resources.Environment([])\n        ws = WorkingSet([])\n        Foo = Distribution.from_filename(\"/foo_dir/Foo-1.2.dist-info\")\n        ad.add(Foo)\n        res = ws.resolve(parse_requirements(\"Foo;python_version>='2'\"), ad)\n        assert list(res) == [Foo]\n\n    def test_environment_marker_evaluation_called(self):\n        \"\"\"\n        If one package foo requires bar without any extras,\n        markers should pass for bar without extras.\n        \"\"\"\n        (parent_req,) = parse_requirements(\"foo\")\n        (req,) = parse_requirements(\"bar;python_version>='2'\")\n        req_extras = pkg_resources._ReqExtras({req: parent_req.extras})\n        assert req_extras.markers_pass(req)\n\n        (parent_req,) = parse_requirements(\"foo[]\")\n        (req,) = parse_requirements(\"bar;python_version>='2'\")\n        req_extras = pkg_resources._ReqExtras({req: parent_req.extras})\n        assert req_extras.markers_pass(req)\n\n    def test_marker_evaluation_with_extras(self):\n        \"\"\"Extras are also evaluated as markers at resolution time.\"\"\"\n        ad = pkg_resources.Environment([])\n        ws = WorkingSet([])\n        Foo = Distribution.from_filename(\n            \"/foo_dir/Foo-1.2.dist-info\",\n            metadata=Metadata((\n                \"METADATA\",\n                \"Provides-Extra: baz\\nRequires-Dist: quux; extra=='baz'\",\n            )),\n        )\n        ad.add(Foo)\n        assert list(ws.resolve(parse_requirements(\"Foo\"), ad)) == [Foo]\n        quux = Distribution.from_filename(\"/foo_dir/quux-1.0.dist-info\")\n        ad.add(quux)\n        res = list(ws.resolve(parse_requirements(\"Foo[baz]\"), ad))\n        assert res == [Foo, quux]\n\n    def test_marker_evaluation_with_extras_normlized(self):\n        \"\"\"Extras are also evaluated as markers at resolution time.\"\"\"\n        ad = pkg_resources.Environment([])\n        ws = WorkingSet([])\n        Foo = Distribution.from_filename(\n            \"/foo_dir/Foo-1.2.dist-info\",\n            metadata=Metadata((\n                \"METADATA\",\n                \"Provides-Extra: baz-lightyear\\n\"\n                \"Requires-Dist: quux; extra=='baz-lightyear'\",\n            )),\n        )\n        ad.add(Foo)\n        assert list(ws.resolve(parse_requirements(\"Foo\"), ad)) == [Foo]\n        quux = Distribution.from_filename(\"/foo_dir/quux-1.0.dist-info\")\n        ad.add(quux)\n        res = list(ws.resolve(parse_requirements(\"Foo[baz-lightyear]\"), ad))\n        assert res == [Foo, quux]\n\n    def test_marker_evaluation_with_multiple_extras(self):\n        ad = pkg_resources.Environment([])\n        ws = WorkingSet([])\n        Foo = Distribution.from_filename(\n            \"/foo_dir/Foo-1.2.dist-info\",\n            metadata=Metadata((\n                \"METADATA\",\n                \"Provides-Extra: baz\\n\"\n                \"Requires-Dist: quux; extra=='baz'\\n\"\n                \"Provides-Extra: bar\\n\"\n                \"Requires-Dist: fred; extra=='bar'\\n\",\n            )),\n        )\n        ad.add(Foo)\n        quux = Distribution.from_filename(\"/foo_dir/quux-1.0.dist-info\")\n        ad.add(quux)\n        fred = Distribution.from_filename(\"/foo_dir/fred-0.1.dist-info\")\n        ad.add(fred)\n        res = list(ws.resolve(parse_requirements(\"Foo[baz,bar]\"), ad))\n        assert sorted(res) == [fred, quux, Foo]\n\n    def test_marker_evaluation_with_extras_loop(self):\n        ad = pkg_resources.Environment([])\n        ws = WorkingSet([])\n        a = Distribution.from_filename(\n            \"/foo_dir/a-0.2.dist-info\",\n            metadata=Metadata((\"METADATA\", \"Requires-Dist: c[a]\")),\n        )\n        b = Distribution.from_filename(\n            \"/foo_dir/b-0.3.dist-info\",\n            metadata=Metadata((\"METADATA\", \"Requires-Dist: c[b]\")),\n        )\n        c = Distribution.from_filename(\n            \"/foo_dir/c-1.0.dist-info\",\n            metadata=Metadata((\n                \"METADATA\",\n                \"Provides-Extra: a\\n\"\n                \"Requires-Dist: b;extra=='a'\\n\"\n                \"Provides-Extra: b\\n\"\n                \"Requires-Dist: foo;extra=='b'\",\n            )),\n        )\n        foo = Distribution.from_filename(\"/foo_dir/foo-0.1.dist-info\")\n        for dist in (a, b, c, foo):\n            ad.add(dist)\n        res = list(ws.resolve(parse_requirements(\"a\"), ad))\n        assert res == [a, c, b, foo]\n\n    @pytest.mark.xfail(\n        sys.version_info[:2] == (3, 12) and sys.version_info.releaselevel != 'final',\n        reason=\"https://github.com/python/cpython/issues/103632\",\n    )\n    def testDistroDependsOptions(self):\n        d = self.distRequires(\n            \"\"\"\n            Twisted>=1.5\n            [docgen]\n            ZConfig>=2.0\n            docutils>=0.3\n            [fastcgi]\n            fcgiapp>=0.1\"\"\"\n        )\n        self.checkRequires(d, \"Twisted>=1.5\")\n        self.checkRequires(\n            d, \"Twisted>=1.5 ZConfig>=2.0 docutils>=0.3\".split(), [\"docgen\"]\n        )\n        self.checkRequires(d, \"Twisted>=1.5 fcgiapp>=0.1\".split(), [\"fastcgi\"])\n        self.checkRequires(\n            d,\n            \"Twisted>=1.5 ZConfig>=2.0 docutils>=0.3 fcgiapp>=0.1\".split(),\n            [\"docgen\", \"fastcgi\"],\n        )\n        self.checkRequires(\n            d,\n            \"Twisted>=1.5 fcgiapp>=0.1 ZConfig>=2.0 docutils>=0.3\".split(),\n            [\"fastcgi\", \"docgen\"],\n        )\n        with pytest.raises(pkg_resources.UnknownExtra):\n            d.requires([\"foo\"])\n\n\nclass TestWorkingSet:\n    def test_find_conflicting(self):\n        ws = WorkingSet([])\n        Foo = Distribution.from_filename(\"/foo_dir/Foo-1.2.egg\")\n        ws.add(Foo)\n\n        # create a requirement that conflicts with Foo 1.2\n        req = next(parse_requirements(\"Foo<1.2\"))\n\n        with pytest.raises(VersionConflict) as vc:\n            ws.find(req)\n\n        msg = 'Foo 1.2 is installed but Foo<1.2 is required'\n        assert vc.value.report() == msg\n\n    def test_resolve_conflicts_with_prior(self):\n        \"\"\"\n        A ContextualVersionConflict should be raised when a requirement\n        conflicts with a prior requirement for a different package.\n        \"\"\"\n        # Create installation where Foo depends on Baz 1.0 and Bar depends on\n        # Baz 2.0.\n        ws = WorkingSet([])\n        md = Metadata(('depends.txt', \"Baz==1.0\"))\n        Foo = Distribution.from_filename(\"/foo_dir/Foo-1.0.egg\", metadata=md)\n        ws.add(Foo)\n        md = Metadata(('depends.txt', \"Baz==2.0\"))\n        Bar = Distribution.from_filename(\"/foo_dir/Bar-1.0.egg\", metadata=md)\n        ws.add(Bar)\n        Baz = Distribution.from_filename(\"/foo_dir/Baz-1.0.egg\")\n        ws.add(Baz)\n        Baz = Distribution.from_filename(\"/foo_dir/Baz-2.0.egg\")\n        ws.add(Baz)\n\n        with pytest.raises(VersionConflict) as vc:\n            ws.resolve(parse_requirements(\"Foo\\nBar\\n\"))\n\n        msg = \"Baz 1.0 is installed but Baz==2.0 is required by \"\n        msg += repr(set(['Bar']))\n        assert vc.value.report() == msg\n\n\nclass TestEntryPoints:\n    def assertfields(self, ep):\n        assert ep.name == \"foo\"\n        assert ep.module_name == \"pkg_resources.tests.test_resources\"\n        assert ep.attrs == (\"TestEntryPoints\",)\n        assert ep.extras == (\"x\",)\n        assert ep.load() is TestEntryPoints\n        expect = \"foo = pkg_resources.tests.test_resources:TestEntryPoints [x]\"\n        assert str(ep) == expect\n\n    def setup_method(self, method):\n        self.dist = Distribution.from_filename(\n            \"FooPkg-1.2-py2.4.egg\", metadata=Metadata(('requires.txt', '[x]'))\n        )\n\n    def testBasics(self):\n        ep = EntryPoint(\n            \"foo\",\n            \"pkg_resources.tests.test_resources\",\n            [\"TestEntryPoints\"],\n            [\"x\"],\n            self.dist,\n        )\n        self.assertfields(ep)\n\n    def testParse(self):\n        s = \"foo = pkg_resources.tests.test_resources:TestEntryPoints [x]\"\n        ep = EntryPoint.parse(s, self.dist)\n        self.assertfields(ep)\n\n        ep = EntryPoint.parse(\"bar baz=  spammity[PING]\")\n        assert ep.name == \"bar baz\"\n        assert ep.module_name == \"spammity\"\n        assert ep.attrs == ()\n        assert ep.extras == (\"ping\",)\n\n        ep = EntryPoint.parse(\" fizzly =  wocka:foo\")\n        assert ep.name == \"fizzly\"\n        assert ep.module_name == \"wocka\"\n        assert ep.attrs == (\"foo\",)\n        assert ep.extras == ()\n\n        # plus in the name\n        spec = \"html+mako = mako.ext.pygmentplugin:MakoHtmlLexer\"\n        ep = EntryPoint.parse(spec)\n        assert ep.name == 'html+mako'\n\n    reject_specs = \"foo\", \"x=a:b:c\", \"q=x/na\", \"fez=pish:tush-z\", \"x=f[a]>2\"\n\n    @pytest.mark.parametrize(\"reject_spec\", reject_specs)\n    def test_reject_spec(self, reject_spec):\n        with pytest.raises(ValueError):\n            EntryPoint.parse(reject_spec)\n\n    def test_printable_name(self):\n        \"\"\"\n        Allow any printable character in the name.\n        \"\"\"\n        # Create a name with all printable characters; strip the whitespace.\n        name = string.printable.strip()\n        spec = \"{name} = module:attr\".format(**locals())\n        ep = EntryPoint.parse(spec)\n        assert ep.name == name\n\n    def checkSubMap(self, m):\n        assert len(m) == len(self.submap_expect)\n        for key, ep in self.submap_expect.items():\n            assert m.get(key).name == ep.name\n            assert m.get(key).module_name == ep.module_name\n            assert sorted(m.get(key).attrs) == sorted(ep.attrs)\n            assert sorted(m.get(key).extras) == sorted(ep.extras)\n\n    submap_expect = dict(\n        feature1=EntryPoint('feature1', 'somemodule', ['somefunction']),\n        feature2=EntryPoint(\n            'feature2', 'another.module', ['SomeClass'], ['extra1', 'extra2']\n        ),\n        feature3=EntryPoint('feature3', 'this.module', extras=['something']),\n    )\n    submap_str = \"\"\"\n            # define features for blah blah\n            feature1 = somemodule:somefunction\n            feature2 = another.module:SomeClass [extra1,extra2]\n            feature3 = this.module [something]\n    \"\"\"\n\n    def testParseList(self):\n        self.checkSubMap(EntryPoint.parse_group(\"xyz\", self.submap_str))\n        with pytest.raises(ValueError):\n            EntryPoint.parse_group(\"x a\", \"foo=bar\")\n        with pytest.raises(ValueError):\n            EntryPoint.parse_group(\"x\", [\"foo=baz\", \"foo=bar\"])\n\n    def testParseMap(self):\n        m = EntryPoint.parse_map({'xyz': self.submap_str})\n        self.checkSubMap(m['xyz'])\n        assert list(m.keys()) == ['xyz']\n        m = EntryPoint.parse_map(\"[xyz]\\n\" + self.submap_str)\n        self.checkSubMap(m['xyz'])\n        assert list(m.keys()) == ['xyz']\n        with pytest.raises(ValueError):\n            EntryPoint.parse_map([\"[xyz]\", \"[xyz]\"])\n        with pytest.raises(ValueError):\n            EntryPoint.parse_map(self.submap_str)\n\n    def testDeprecationWarnings(self):\n        ep = EntryPoint(\n            \"foo\", \"pkg_resources.tests.test_resources\", [\"TestEntryPoints\"], [\"x\"]\n        )\n        with pytest.warns(pkg_resources.PkgResourcesDeprecationWarning):\n            ep.load(require=False)\n\n\nclass TestRequirements:\n    def testBasics(self):\n        r = Requirement.parse(\"Twisted>=1.2\")\n        assert str(r) == \"Twisted>=1.2\"\n        assert repr(r) == \"Requirement.parse('Twisted>=1.2')\"\n        assert r == Requirement(\"Twisted>=1.2\")\n        assert r == Requirement(\"twisTed>=1.2\")\n        assert r != Requirement(\"Twisted>=2.0\")\n        assert r != Requirement(\"Zope>=1.2\")\n        assert r != Requirement(\"Zope>=3.0\")\n        assert r != Requirement(\"Twisted[extras]>=1.2\")\n\n    def testOrdering(self):\n        r1 = Requirement(\"Twisted==1.2c1,>=1.2\")\n        r2 = Requirement(\"Twisted>=1.2,==1.2c1\")\n        assert r1 == r2\n        assert str(r1) == str(r2)\n        assert str(r2) == \"Twisted==1.2c1,>=1.2\"\n        assert Requirement(\"Twisted\") != Requirement(\n            \"Twisted @ https://localhost/twisted.zip\"\n        )\n\n    def testBasicContains(self):\n        r = Requirement(\"Twisted>=1.2\")\n        foo_dist = Distribution.from_filename(\"FooPkg-1.3_1.egg\")\n        twist11 = Distribution.from_filename(\"Twisted-1.1.egg\")\n        twist12 = Distribution.from_filename(\"Twisted-1.2.egg\")\n        assert parse_version('1.2') in r\n        assert parse_version('1.1') not in r\n        assert '1.2' in r\n        assert '1.1' not in r\n        assert foo_dist not in r\n        assert twist11 not in r\n        assert twist12 in r\n\n    def testOptionsAndHashing(self):\n        r1 = Requirement.parse(\"Twisted[foo,bar]>=1.2\")\n        r2 = Requirement.parse(\"Twisted[bar,FOO]>=1.2\")\n        assert r1 == r2\n        assert set(r1.extras) == set((\"foo\", \"bar\"))\n        assert set(r2.extras) == set((\"foo\", \"bar\"))\n        assert hash(r1) == hash(r2)\n        assert hash(r1) == hash((\n            \"twisted\",\n            None,\n            SpecifierSet(\">=1.2\"),\n            frozenset([\"foo\", \"bar\"]),\n            None,\n        ))\n        assert hash(\n            Requirement.parse(\"Twisted @ https://localhost/twisted.zip\")\n        ) == hash((\n            \"twisted\",\n            \"https://localhost/twisted.zip\",\n            SpecifierSet(),\n            frozenset(),\n            None,\n        ))\n\n    def testVersionEquality(self):\n        r1 = Requirement.parse(\"foo==0.3a2\")\n        r2 = Requirement.parse(\"foo!=0.3a4\")\n        d = Distribution.from_filename\n\n        assert d(\"foo-0.3a4.egg\") not in r1\n        assert d(\"foo-0.3a1.egg\") not in r1\n        assert d(\"foo-0.3a4.egg\") not in r2\n\n        assert d(\"foo-0.3a2.egg\") in r1\n        assert d(\"foo-0.3a2.egg\") in r2\n        assert d(\"foo-0.3a3.egg\") in r2\n        assert d(\"foo-0.3a5.egg\") in r2\n\n    def testSetuptoolsProjectName(self):\n        \"\"\"\n        The setuptools project should implement the setuptools package.\n        \"\"\"\n\n        assert Requirement.parse('setuptools').project_name == 'setuptools'\n        # setuptools 0.7 and higher means setuptools.\n        assert Requirement.parse('setuptools == 0.7').project_name == 'setuptools'\n        assert Requirement.parse('setuptools == 0.7a1').project_name == 'setuptools'\n        assert Requirement.parse('setuptools >= 0.7').project_name == 'setuptools'\n\n\nclass TestParsing:\n    def testEmptyParse(self):\n        assert list(parse_requirements('')) == []\n\n    def testYielding(self):\n        for inp, out in [\n            ([], []),\n            ('x', ['x']),\n            ([[]], []),\n            (' x\\n y', ['x', 'y']),\n            (['x\\n\\n', 'y'], ['x', 'y']),\n        ]:\n            assert list(pkg_resources.yield_lines(inp)) == out\n\n    def testSplitting(self):\n        sample = \"\"\"\n                    x\n                    [Y]\n                    z\n\n                    a\n                    [b ]\n                    # foo\n                    c\n                    [ d]\n                    [q]\n                    v\n                    \"\"\"\n        assert list(pkg_resources.split_sections(sample)) == [\n            (None, [\"x\"]),\n            (\"Y\", [\"z\", \"a\"]),\n            (\"b\", [\"c\"]),\n            (\"d\", []),\n            (\"q\", [\"v\"]),\n        ]\n        with pytest.raises(ValueError):\n            list(pkg_resources.split_sections(\"[foo\"))\n\n    def testSafeName(self):\n        assert safe_name(\"adns-python\") == \"adns-python\"\n        assert safe_name(\"WSGI Utils\") == \"WSGI-Utils\"\n        assert safe_name(\"WSGI  Utils\") == \"WSGI-Utils\"\n        assert safe_name(\"Money$$$Maker\") == \"Money-Maker\"\n        assert safe_name(\"peak.web\") != \"peak-web\"\n\n    def testSafeVersion(self):\n        assert safe_version(\"1.2-1\") == \"1.2.post1\"\n        assert safe_version(\"1.2 alpha\") == \"1.2.alpha\"\n        assert safe_version(\"2.3.4 20050521\") == \"2.3.4.20050521\"\n        assert safe_version(\"Money$$$Maker\") == \"Money-Maker\"\n        assert safe_version(\"peak.web\") == \"peak.web\"\n\n    def testSimpleRequirements(self):\n        assert list(parse_requirements('Twis-Ted>=1.2-1')) == [\n            Requirement('Twis-Ted>=1.2-1')\n        ]\n        assert list(parse_requirements('Twisted >=1.2, \\\\ # more\\n<2.0')) == [\n            Requirement('Twisted>=1.2,<2.0')\n        ]\n        assert Requirement.parse(\"FooBar==1.99a3\") == Requirement(\"FooBar==1.99a3\")\n        with pytest.raises(ValueError):\n            Requirement.parse(\">=2.3\")\n        with pytest.raises(ValueError):\n            Requirement.parse(\"x\\\\\")\n        with pytest.raises(ValueError):\n            Requirement.parse(\"x==2 q\")\n        with pytest.raises(ValueError):\n            Requirement.parse(\"X==1\\nY==2\")\n        with pytest.raises(ValueError):\n            Requirement.parse(\"#\")\n\n    def test_requirements_with_markers(self):\n        assert Requirement.parse(\"foobar;os_name=='a'\") == Requirement.parse(\n            \"foobar;os_name=='a'\"\n        )\n        assert Requirement.parse(\n            \"name==1.1;python_version=='2.7'\"\n        ) != Requirement.parse(\"name==1.1;python_version=='3.6'\")\n        assert Requirement.parse(\n            \"name==1.0;python_version=='2.7'\"\n        ) != Requirement.parse(\"name==1.2;python_version=='2.7'\")\n        assert Requirement.parse(\n            \"name[foo]==1.0;python_version=='3.6'\"\n        ) != Requirement.parse(\"name[foo,bar]==1.0;python_version=='3.6'\")\n\n    def test_local_version(self):\n        parse_requirements('foo==1.0+org1')\n\n    def test_spaces_between_multiple_versions(self):\n        parse_requirements('foo>=1.0, <3')\n        parse_requirements('foo >= 1.0, < 3')\n\n    @pytest.mark.parametrize(\n        (\"lower\", \"upper\"),\n        [\n            ('1.2-rc1', '1.2rc1'),\n            ('0.4', '0.4.0'),\n            ('0.4.0.0', '0.4.0'),\n            ('0.4.0-0', '0.4-0'),\n            ('0post1', '0.0post1'),\n            ('0pre1', '0.0c1'),\n            ('0.0.0preview1', '0c1'),\n            ('0.0c1', '0-rc1'),\n            ('1.2a1', '1.2.a.1'),\n            ('1.2.a', '1.2a'),\n        ],\n    )\n    def testVersionEquality(self, lower, upper):\n        assert parse_version(lower) == parse_version(upper)\n\n    torture = \"\"\"\n        0.80.1-3 0.80.1-2 0.80.1-1 0.79.9999+0.80.0pre4-1\n        0.79.9999+0.80.0pre2-3 0.79.9999+0.80.0pre2-2\n        0.77.2-1 0.77.1-1 0.77.0-1\n        \"\"\"\n\n    @pytest.mark.parametrize(\n        (\"lower\", \"upper\"),\n        [\n            ('2.1', '2.1.1'),\n            ('2a1', '2b0'),\n            ('2a1', '2.1'),\n            ('2.3a1', '2.3'),\n            ('2.1-1', '2.1-2'),\n            ('2.1-1', '2.1.1'),\n            ('2.1', '2.1post4'),\n            ('2.1a0-20040501', '2.1'),\n            ('1.1', '02.1'),\n            ('3.2', '3.2.post0'),\n            ('3.2post1', '3.2post2'),\n            ('0.4', '4.0'),\n            ('0.0.4', '0.4.0'),\n            ('0post1', '0.4post1'),\n            ('2.1.0-rc1', '2.1.0'),\n            ('2.1dev', '2.1a0'),\n        ]\n        + list(pairwise(reversed(torture.split()))),\n    )\n    def testVersionOrdering(self, lower, upper):\n        assert parse_version(lower) < parse_version(upper)\n\n    def testVersionHashable(self):\n        \"\"\"\n        Ensure that our versions stay hashable even though we've subclassed\n        them and added some shim code to them.\n        \"\"\"\n        assert hash(parse_version(\"1.0\")) == hash(parse_version(\"1.0\"))\n\n\nclass TestNamespaces:\n    ns_str = \"__import__('pkg_resources').declare_namespace(__name__)\\n\"\n\n    @pytest.fixture\n    def symlinked_tmpdir(self, tmpdir):\n        \"\"\"\n        Where available, return the tempdir as a symlink,\n        which as revealed in #231 is more fragile than\n        a natural tempdir.\n        \"\"\"\n        if not hasattr(os, 'symlink'):\n            yield str(tmpdir)\n            return\n\n        link_name = str(tmpdir) + '-linked'\n        os.symlink(str(tmpdir), link_name)\n        try:\n            yield type(tmpdir)(link_name)\n        finally:\n            os.unlink(link_name)\n\n    @pytest.fixture(autouse=True)\n    def patched_path(self, tmpdir):\n        \"\"\"\n        Patch sys.path to include the 'site-pkgs' dir. Also\n        restore pkg_resources._namespace_packages to its\n        former state.\n        \"\"\"\n        saved_ns_pkgs = pkg_resources._namespace_packages.copy()\n        saved_sys_path = sys.path[:]\n        site_pkgs = tmpdir.mkdir('site-pkgs')\n        sys.path.append(str(site_pkgs))\n        try:\n            yield\n        finally:\n            pkg_resources._namespace_packages = saved_ns_pkgs\n            sys.path = saved_sys_path\n\n    issue591 = pytest.mark.xfail(platform.system() == 'Windows', reason=\"#591\")\n\n    @issue591\n    def test_two_levels_deep(self, symlinked_tmpdir):\n        \"\"\"\n        Test nested namespace packages\n        Create namespace packages in the following tree :\n            site-packages-1/pkg1/pkg2\n            site-packages-2/pkg1/pkg2\n        Check both are in the _namespace_packages dict and that their __path__\n        is correct\n        \"\"\"\n        real_tmpdir = symlinked_tmpdir.realpath()\n        tmpdir = symlinked_tmpdir\n        sys.path.append(str(tmpdir / 'site-pkgs2'))\n        site_dirs = tmpdir / 'site-pkgs', tmpdir / 'site-pkgs2'\n        for site in site_dirs:\n            pkg1 = site / 'pkg1'\n            pkg2 = pkg1 / 'pkg2'\n            pkg2.ensure_dir()\n            (pkg1 / '__init__.py').write_text(self.ns_str, encoding='utf-8')\n            (pkg2 / '__init__.py').write_text(self.ns_str, encoding='utf-8')\n        with pytest.warns(DeprecationWarning, match=\"pkg_resources.declare_namespace\"):\n            import pkg1  # pyright: ignore[reportMissingImports] # Temporary package for test\n        assert \"pkg1\" in pkg_resources._namespace_packages\n        # attempt to import pkg2 from site-pkgs2\n        with pytest.warns(DeprecationWarning, match=\"pkg_resources.declare_namespace\"):\n            import pkg1.pkg2  # pyright: ignore[reportMissingImports] # Temporary package for test\n        # check the _namespace_packages dict\n        assert \"pkg1.pkg2\" in pkg_resources._namespace_packages\n        assert pkg_resources._namespace_packages[\"pkg1\"] == [\"pkg1.pkg2\"]\n        # check the __path__ attribute contains both paths\n        expected = [\n            str(real_tmpdir / \"site-pkgs\" / \"pkg1\" / \"pkg2\"),\n            str(real_tmpdir / \"site-pkgs2\" / \"pkg1\" / \"pkg2\"),\n        ]\n        assert pkg1.pkg2.__path__ == expected\n\n    @issue591\n    def test_path_order(self, symlinked_tmpdir):\n        \"\"\"\n        Test that if multiple versions of the same namespace package subpackage\n        are on different sys.path entries, that only the one earliest on\n        sys.path is imported, and that the namespace package's __path__ is in\n        the correct order.\n\n        Regression test for https://github.com/pypa/setuptools/issues/207\n        \"\"\"\n\n        tmpdir = symlinked_tmpdir\n        site_dirs = (\n            tmpdir / \"site-pkgs\",\n            tmpdir / \"site-pkgs2\",\n            tmpdir / \"site-pkgs3\",\n        )\n\n        vers_str = \"__version__ = %r\"\n\n        for number, site in enumerate(site_dirs, 1):\n            if number > 1:\n                sys.path.append(str(site))\n            nspkg = site / 'nspkg'\n            subpkg = nspkg / 'subpkg'\n            subpkg.ensure_dir()\n            (nspkg / '__init__.py').write_text(self.ns_str, encoding='utf-8')\n            (subpkg / '__init__.py').write_text(vers_str % number, encoding='utf-8')\n\n        with pytest.warns(DeprecationWarning, match=\"pkg_resources.declare_namespace\"):\n            import nspkg  # pyright: ignore[reportMissingImports] # Temporary package for test\n            import nspkg.subpkg  # pyright: ignore[reportMissingImports] # Temporary package for test\n        expected = [str(site.realpath() / 'nspkg') for site in site_dirs]\n        assert nspkg.__path__ == expected\n        assert nspkg.subpkg.__version__ == 1\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/pkg_resources/tests/test_working_set.py","size":8539,"sha1":"01445cbf9fce1219b4799eb1de244cb638a078fc","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import functools\nimport inspect\nimport re\nimport textwrap\n\nimport pytest\n\nimport pkg_resources\n\nfrom .test_resources import Metadata\n\n\ndef strip_comments(s):\n    return '\\n'.join(\n        line\n        for line in s.split('\\n')\n        if line.strip() and not line.strip().startswith('#')\n    )\n\n\ndef parse_distributions(s):\n    \"\"\"\n    Parse a series of distribution specs of the form:\n    {project_name}-{version}\n       [optional, indented requirements specification]\n\n    Example:\n\n        foo-0.2\n        bar-1.0\n          foo>=3.0\n          [feature]\n          baz\n\n    yield 2 distributions:\n        - project_name=foo, version=0.2\n        - project_name=bar, version=1.0,\n          requires=['foo>=3.0', 'baz; extra==\"feature\"']\n    \"\"\"\n    s = s.strip()\n    for spec in re.split(r'\\n(?=[^\\s])', s):\n        if not spec:\n            continue\n        fields = spec.split('\\n', 1)\n        assert 1 <= len(fields) <= 2\n        name, version = fields.pop(0).rsplit('-', 1)\n        if fields:\n            requires = textwrap.dedent(fields.pop(0))\n            metadata = Metadata(('requires.txt', requires))\n        else:\n            metadata = None\n        dist = pkg_resources.Distribution(\n            project_name=name, version=version, metadata=metadata\n        )\n        yield dist\n\n\nclass FakeInstaller:\n    def __init__(self, installable_dists) -> None:\n        self._installable_dists = installable_dists\n\n    def __call__(self, req):\n        return next(\n            iter(filter(lambda dist: dist in req, self._installable_dists)), None\n        )\n\n\ndef parametrize_test_working_set_resolve(*test_list):\n    idlist = []\n    argvalues = []\n    for test in test_list:\n        (\n            name,\n            installed_dists,\n            installable_dists,\n            requirements,\n            expected1,\n            expected2,\n        ) = (\n            strip_comments(s.lstrip())\n            for s in textwrap.dedent(test).lstrip().split('\\n\\n', 5)\n        )\n        installed_dists = list(parse_distributions(installed_dists))\n        installable_dists = list(parse_distributions(installable_dists))\n        requirements = list(pkg_resources.parse_requirements(requirements))\n        for id_, replace_conflicting, expected in (\n            (name, False, expected1),\n            (name + '_replace_conflicting', True, expected2),\n        ):\n            idlist.append(id_)\n            expected = strip_comments(expected.strip())\n            if re.match(r'\\w+$', expected):\n                expected = getattr(pkg_resources, expected)\n                assert issubclass(expected, Exception)\n            else:\n                expected = list(parse_distributions(expected))\n            argvalues.append(\n                pytest.param(\n                    installed_dists,\n                    installable_dists,\n                    requirements,\n                    replace_conflicting,\n                    expected,\n                )\n            )\n    return pytest.mark.parametrize(\n        'installed_dists,installable_dists,'\n        'requirements,replace_conflicting,'\n        'resolved_dists_or_exception',\n        argvalues,\n        ids=idlist,\n    )\n\n\n@parametrize_test_working_set_resolve(\n    \"\"\"\n    # id\n    noop\n\n    # installed\n\n    # installable\n\n    # wanted\n\n    # resolved\n\n    # resolved [replace conflicting]\n    \"\"\",\n    \"\"\"\n    # id\n    already_installed\n\n    # installed\n    foo-3.0\n\n    # installable\n\n    # wanted\n    foo>=2.1,!=3.1,<4\n\n    # resolved\n    foo-3.0\n\n    # resolved [replace conflicting]\n    foo-3.0\n    \"\"\",\n    \"\"\"\n    # id\n    installable_not_installed\n\n    # installed\n\n    # installable\n    foo-3.0\n    foo-4.0\n\n    # wanted\n    foo>=2.1,!=3.1,<4\n\n    # resolved\n    foo-3.0\n\n    # resolved [replace conflicting]\n    foo-3.0\n    \"\"\",\n    \"\"\"\n    # id\n    not_installable\n\n    # installed\n\n    # installable\n\n    # wanted\n    foo>=2.1,!=3.1,<4\n\n    # resolved\n    DistributionNotFound\n\n    # resolved [replace conflicting]\n    DistributionNotFound\n    \"\"\",\n    \"\"\"\n    # id\n    no_matching_version\n\n    # installed\n\n    # installable\n    foo-3.1\n\n    # wanted\n    foo>=2.1,!=3.1,<4\n\n    # resolved\n    DistributionNotFound\n\n    # resolved [replace conflicting]\n    DistributionNotFound\n    \"\"\",\n    \"\"\"\n    # id\n    installable_with_installed_conflict\n\n    # installed\n    foo-3.1\n\n    # installable\n    foo-3.5\n\n    # wanted\n    foo>=2.1,!=3.1,<4\n\n    # resolved\n    VersionConflict\n\n    # resolved [replace conflicting]\n    foo-3.5\n    \"\"\",\n    \"\"\"\n    # id\n    not_installable_with_installed_conflict\n\n    # installed\n    foo-3.1\n\n    # installable\n\n    # wanted\n    foo>=2.1,!=3.1,<4\n\n    # resolved\n    VersionConflict\n\n    # resolved [replace conflicting]\n    DistributionNotFound\n    \"\"\",\n    \"\"\"\n    # id\n    installed_with_installed_require\n\n    # installed\n    foo-3.9\n    baz-0.1\n        foo>=2.1,!=3.1,<4\n\n    # installable\n\n    # wanted\n    baz\n\n    # resolved\n    foo-3.9\n    baz-0.1\n\n    # resolved [replace conflicting]\n    foo-3.9\n    baz-0.1\n    \"\"\",\n    \"\"\"\n    # id\n    installed_with_conflicting_installed_require\n\n    # installed\n    foo-5\n    baz-0.1\n        foo>=2.1,!=3.1,<4\n\n    # installable\n\n    # wanted\n    baz\n\n    # resolved\n    VersionConflict\n\n    # resolved [replace conflicting]\n    DistributionNotFound\n    \"\"\",\n    \"\"\"\n    # id\n    installed_with_installable_conflicting_require\n\n    # installed\n    foo-5\n    baz-0.1\n        foo>=2.1,!=3.1,<4\n\n    # installable\n    foo-2.9\n\n    # wanted\n    baz\n\n    # resolved\n    VersionConflict\n\n    # resolved [replace conflicting]\n    baz-0.1\n    foo-2.9\n    \"\"\",\n    \"\"\"\n    # id\n    installed_with_installable_require\n\n    # installed\n    baz-0.1\n        foo>=2.1,!=3.1,<4\n\n    # installable\n    foo-3.9\n\n    # wanted\n    baz\n\n    # resolved\n    foo-3.9\n    baz-0.1\n\n    # resolved [replace conflicting]\n    foo-3.9\n    baz-0.1\n    \"\"\",\n    \"\"\"\n    # id\n    installable_with_installed_require\n\n    # installed\n    foo-3.9\n\n    # installable\n    baz-0.1\n        foo>=2.1,!=3.1,<4\n\n    # wanted\n    baz\n\n    # resolved\n    foo-3.9\n    baz-0.1\n\n    # resolved [replace conflicting]\n    foo-3.9\n    baz-0.1\n    \"\"\",\n    \"\"\"\n    # id\n    installable_with_installable_require\n\n    # installed\n\n    # installable\n    foo-3.9\n    baz-0.1\n        foo>=2.1,!=3.1,<4\n\n    # wanted\n    baz\n\n    # resolved\n    foo-3.9\n    baz-0.1\n\n    # resolved [replace conflicting]\n    foo-3.9\n    baz-0.1\n    \"\"\",\n    \"\"\"\n    # id\n    installable_with_conflicting_installable_require\n\n    # installed\n    foo-5\n\n    # installable\n    foo-2.9\n    baz-0.1\n        foo>=2.1,!=3.1,<4\n\n    # wanted\n    baz\n\n    # resolved\n    VersionConflict\n\n    # resolved [replace conflicting]\n    baz-0.1\n    foo-2.9\n    \"\"\",\n    \"\"\"\n    # id\n    conflicting_installables\n\n    # installed\n\n    # installable\n    foo-2.9\n    foo-5.0\n\n    # wanted\n    foo>=2.1,!=3.1,<4\n    foo>=4\n\n    # resolved\n    VersionConflict\n\n    # resolved [replace conflicting]\n    VersionConflict\n    \"\"\",\n    \"\"\"\n    # id\n    installables_with_conflicting_requires\n\n    # installed\n\n    # installable\n    foo-2.9\n        dep==1.0\n    baz-5.0\n        dep==2.0\n    dep-1.0\n    dep-2.0\n\n    # wanted\n    foo\n    baz\n\n    # resolved\n    VersionConflict\n\n    # resolved [replace conflicting]\n    VersionConflict\n    \"\"\",\n    \"\"\"\n    # id\n    installables_with_conflicting_nested_requires\n\n    # installed\n\n    # installable\n    foo-2.9\n        dep1\n    dep1-1.0\n        subdep<1.0\n    baz-5.0\n        dep2\n    dep2-1.0\n        subdep>1.0\n    subdep-0.9\n    subdep-1.1\n\n    # wanted\n    foo\n    baz\n\n    # resolved\n    VersionConflict\n\n    # resolved [replace conflicting]\n    VersionConflict\n    \"\"\",\n    \"\"\"\n    # id\n    wanted_normalized_name_installed_canonical\n\n    # installed\n    foo.bar-3.6\n\n    # installable\n\n    # wanted\n    foo-bar==3.6\n\n    # resolved\n    foo.bar-3.6\n\n    # resolved [replace conflicting]\n    foo.bar-3.6\n    \"\"\",\n)\ndef test_working_set_resolve(\n    installed_dists,\n    installable_dists,\n    requirements,\n    replace_conflicting,\n    resolved_dists_or_exception,\n):\n    ws = pkg_resources.WorkingSet([])\n    list(map(ws.add, installed_dists))\n    resolve_call = functools.partial(\n        ws.resolve,\n        requirements,\n        installer=FakeInstaller(installable_dists),\n        replace_conflicting=replace_conflicting,\n    )\n    if inspect.isclass(resolved_dists_or_exception):\n        with pytest.raises(resolved_dists_or_exception):\n            resolve_call()\n    else:\n        assert sorted(resolve_call()) == sorted(resolved_dists_or_exception)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/__init__.py","size":10406,"sha1":"774fc540fcb60ad84172ac39eeb8f64034b0d780","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Extensions to the 'distutils' for large or complex distributions\"\"\"\n# mypy: disable_error_code=override\n# Command.reinitialize_command has an extra **kw param that distutils doesn't have\n# Can't disable on the exact line because distutils doesn't exists on Python 3.12\n# and mypy isn't aware of distutils_hack, causing distutils.core.Command to be Any,\n# and a [unused-ignore] to be raised on 3.12+\n\nfrom __future__ import annotations\n\nimport functools\nimport os\nimport re\nimport sys\nfrom abc import abstractmethod\nfrom collections.abc import Mapping\nfrom typing import TYPE_CHECKING, TypeVar, overload\n\nsys.path.extend(((vendor_path := os.path.join(os.path.dirname(os.path.dirname(__file__)), 'setuptools', '_vendor')) not in sys.path) * [vendor_path])  # fmt: skip\n# workaround for #4476\nsys.modules.pop('backports', None)\n\nimport _distutils_hack.override  # noqa: F401\n\nfrom . import logging, monkey\nfrom .depends import Require\nfrom .discovery import PackageFinder, PEP420PackageFinder\nfrom .dist import Distribution\nfrom .extension import Extension\nfrom .version import __version__ as __version__\nfrom .warnings import SetuptoolsDeprecationWarning\n\nimport distutils.core\nfrom distutils.errors import DistutilsOptionError\n\n__all__ = [\n    'setup',\n    'Distribution',\n    'Command',\n    'Extension',\n    'Require',\n    'SetuptoolsDeprecationWarning',\n    'find_packages',\n    'find_namespace_packages',\n]\n\n_CommandT = TypeVar(\"_CommandT\", bound=\"_Command\")\n\nbootstrap_install_from = None\n\nfind_packages = PackageFinder.find\nfind_namespace_packages = PEP420PackageFinder.find\n\n\ndef _install_setup_requires(attrs):\n    # Note: do not use `setuptools.Distribution` directly, as\n    # our PEP 517 backend patch `distutils.core.Distribution`.\n    class MinimalDistribution(distutils.core.Distribution):\n        \"\"\"\n        A minimal version of a distribution for supporting the\n        fetch_build_eggs interface.\n        \"\"\"\n\n        def __init__(self, attrs: Mapping[str, object]) -> None:\n            _incl = 'dependency_links', 'setup_requires'\n            filtered = {k: attrs[k] for k in set(_incl) & set(attrs)}\n            super().__init__(filtered)\n            # Prevent accidentally triggering discovery with incomplete set of attrs\n            self.set_defaults._disable()\n\n        def _get_project_config_files(self, filenames=None):\n            \"\"\"Ignore ``pyproject.toml``, they are not related to setup_requires\"\"\"\n            try:\n                cfg, _toml = super()._split_standard_project_metadata(filenames)\n            except Exception:\n                return filenames, ()\n            return cfg, ()\n\n        def finalize_options(self):\n            \"\"\"\n            Disable finalize_options to avoid building the working set.\n            Ref #2158.\n            \"\"\"\n\n    dist = MinimalDistribution(attrs)\n\n    # Honor setup.cfg's options.\n    dist.parse_config_files(ignore_option_errors=True)\n    if dist.setup_requires:\n        _fetch_build_eggs(dist)\n\n\ndef _fetch_build_eggs(dist: Distribution):\n    try:\n        dist.fetch_build_eggs(dist.setup_requires)\n    except Exception as ex:\n        msg = \"\"\"\n        It is possible a package already installed in your system\n        contains an version that is invalid according to PEP 440.\n        You can try `pip install --use-pep517` as a workaround for this problem,\n        or rely on a new virtual environment.\n\n        If the problem refers to a package that is not installed yet,\n        please contact that package's maintainers or distributors.\n        \"\"\"\n        if \"InvalidVersion\" in ex.__class__.__name__:\n            if hasattr(ex, \"add_note\"):\n                ex.add_note(msg)  # PEP 678\n            else:\n                dist.announce(f\"\\n{msg}\\n\")\n        raise\n\n\ndef setup(**attrs):\n    logging.configure()\n    # Make sure we have any requirements needed to interpret 'attrs'.\n    _install_setup_requires(attrs)\n    return distutils.core.setup(**attrs)\n\n\nsetup.__doc__ = distutils.core.setup.__doc__\n\nif TYPE_CHECKING:\n    # Work around a mypy issue where type[T] can't be used as a base: https://github.com/python/mypy/issues/10962\n    from distutils.core import Command as _Command\nelse:\n    _Command = monkey.get_unpatched(distutils.core.Command)\n\n\nclass Command(_Command):\n    \"\"\"\n    Setuptools internal actions are organized using a *command design pattern*.\n    This means that each action (or group of closely related actions) executed during\n    the build should be implemented as a ``Command`` subclass.\n\n    These commands are abstractions and do not necessarily correspond to a command that\n    can (or should) be executed via a terminal, in a CLI fashion (although historically\n    they would).\n\n    When creating a new command from scratch, custom defined classes **SHOULD** inherit\n    from ``setuptools.Command`` and implement a few mandatory methods.\n    Between these mandatory methods, are listed:\n    :meth:`initialize_options`, :meth:`finalize_options` and :meth:`run`.\n\n    A useful analogy for command classes is to think of them as subroutines with local\n    variables called \"options\".  The options are \"declared\" in :meth:`initialize_options`\n    and \"defined\" (given their final values, aka \"finalized\") in :meth:`finalize_options`,\n    both of which must be defined by every command class. The \"body\" of the subroutine,\n    (where it does all the work) is the :meth:`run` method.\n    Between :meth:`initialize_options` and :meth:`finalize_options`, ``setuptools`` may set\n    the values for options/attributes based on user's input (or circumstance),\n    which means that the implementation should be careful to not overwrite values in\n    :meth:`finalize_options` unless necessary.\n\n    Please note that other commands (or other parts of setuptools) may also overwrite\n    the values of the command's options/attributes multiple times during the build\n    process.\n    Therefore it is important to consistently implement :meth:`initialize_options` and\n    :meth:`finalize_options`. For example, all derived attributes (or attributes that\n    depend on the value of other attributes) **SHOULD** be recomputed in\n    :meth:`finalize_options`.\n\n    When overwriting existing commands, custom defined classes **MUST** abide by the\n    same APIs implemented by the original class. They also **SHOULD** inherit from the\n    original class.\n    \"\"\"\n\n    command_consumes_arguments = False\n    distribution: Distribution  # override distutils.dist.Distribution with setuptools.dist.Distribution\n\n    def __init__(self, dist: Distribution, **kw) -> None:\n        \"\"\"\n        Construct the command for dist, updating\n        vars(self) with any keyword parameters.\n        \"\"\"\n        super().__init__(dist)\n        vars(self).update(kw)\n\n    def _ensure_stringlike(self, option, what, default=None):\n        val = getattr(self, option)\n        if val is None:\n            setattr(self, option, default)\n            return default\n        elif not isinstance(val, str):\n            raise DistutilsOptionError(f\"'{option}' must be a {what} (got `{val}`)\")\n        return val\n\n    def ensure_string_list(self, option: str) -> None:\n        r\"\"\"Ensure that 'option' is a list of strings.  If 'option' is\n        currently a string, we split it either on /,\\s*/ or /\\s+/, so\n        \"foo bar baz\", \"foo,bar,baz\", and \"foo,   bar baz\" all become\n        [\"foo\", \"bar\", \"baz\"].\n\n        ..\n           TODO: This method seems to be similar to the one in ``distutils.cmd``\n           Probably it is just here for backward compatibility with old Python versions?\n\n        :meta private:\n        \"\"\"\n        val = getattr(self, option)\n        if val is None:\n            return\n        elif isinstance(val, str):\n            setattr(self, option, re.split(r',\\s*|\\s+', val))\n        else:\n            if isinstance(val, list):\n                ok = all(isinstance(v, str) for v in val)\n            else:\n                ok = False\n            if not ok:\n                raise DistutilsOptionError(\n                    f\"'{option}' must be a list of strings (got {val!r})\"\n                )\n\n    @overload\n    def reinitialize_command(\n        self, command: str, reinit_subcommands: bool = False, **kw\n    ) -> _Command: ...\n    @overload\n    def reinitialize_command(\n        self, command: _CommandT, reinit_subcommands: bool = False, **kw\n    ) -> _CommandT: ...\n    def reinitialize_command(\n        self, command: str | _Command, reinit_subcommands: bool = False, **kw\n    ) -> _Command:\n        cmd = _Command.reinitialize_command(self, command, reinit_subcommands)\n        vars(cmd).update(kw)\n        return cmd  # pyright: ignore[reportReturnType] # pypa/distutils#307\n\n    @abstractmethod\n    def initialize_options(self) -> None:\n        \"\"\"\n        Set or (reset) all options/attributes/caches used by the command\n        to their default values. Note that these values may be overwritten during\n        the build.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def finalize_options(self) -> None:\n        \"\"\"\n        Set final values for all options/attributes used by the command.\n        Most of the time, each option/attribute/cache should only be set if it does not\n        have any value yet (e.g. ``if self.attr is None: self.attr = val``).\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def run(self) -> None:\n        \"\"\"\n        Execute the actions intended by the command.\n        (Side effects **SHOULD** only take place when :meth:`run` is executed,\n        for example, creating new files or writing to the terminal output).\n        \"\"\"\n        raise NotImplementedError\n\n\ndef _find_all_simple(path):\n    \"\"\"\n    Find all files under 'path'\n    \"\"\"\n    results = (\n        os.path.join(base, file)\n        for base, dirs, files in os.walk(path, followlinks=True)\n        for file in files\n    )\n    return filter(os.path.isfile, results)\n\n\ndef findall(dir=os.curdir):\n    \"\"\"\n    Find all files under 'dir' and return the list of full filenames.\n    Unless dir is '.', return full filenames with dir prepended.\n    \"\"\"\n    files = _find_all_simple(dir)\n    if dir == os.curdir:\n        make_rel = functools.partial(os.path.relpath, start=dir)\n        files = map(make_rel, files)\n    return list(files)\n\n\nclass sic(str):\n    \"\"\"Treat this string as-is (https://en.wikipedia.org/wiki/Sic)\"\"\"\n\n\n# Apply monkey patches\nmonkey.patch_all()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_core_metadata.py","size":11070,"sha1":"9713e2f85959a2e313661bb27b5f483d723c135c","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nHandling of Core Metadata for Python packages (including reading and writing).\n\nSee: https://packaging.python.org/en/latest/specifications/core-metadata/\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport stat\nimport textwrap\nfrom email import message_from_file\nfrom email.message import Message\nfrom tempfile import NamedTemporaryFile\n\nfrom packaging.markers import Marker\nfrom packaging.requirements import Requirement\nfrom packaging.utils import canonicalize_name, canonicalize_version\nfrom packaging.version import Version\n\nfrom . import _normalization, _reqs\nfrom ._static import is_static\nfrom .warnings import SetuptoolsDeprecationWarning\n\nfrom distutils.util import rfc822_escape\n\n\ndef get_metadata_version(self):\n    mv = getattr(self, 'metadata_version', None)\n    if mv is None:\n        mv = Version('2.2')\n        self.metadata_version = mv\n    return mv\n\n\ndef rfc822_unescape(content: str) -> str:\n    \"\"\"Reverse RFC-822 escaping by removing leading whitespaces from content.\"\"\"\n    lines = content.splitlines()\n    if len(lines) == 1:\n        return lines[0].lstrip()\n    return '\\n'.join((lines[0].lstrip(), textwrap.dedent('\\n'.join(lines[1:]))))\n\n\ndef _read_field_from_msg(msg: Message, field: str) -> str | None:\n    \"\"\"Read Message header field.\"\"\"\n    value = msg[field]\n    if value == 'UNKNOWN':\n        return None\n    return value\n\n\ndef _read_field_unescaped_from_msg(msg: Message, field: str) -> str | None:\n    \"\"\"Read Message header field and apply rfc822_unescape.\"\"\"\n    value = _read_field_from_msg(msg, field)\n    if value is None:\n        return value\n    return rfc822_unescape(value)\n\n\ndef _read_list_from_msg(msg: Message, field: str) -> list[str] | None:\n    \"\"\"Read Message header field and return all results as list.\"\"\"\n    values = msg.get_all(field, None)\n    if values == []:\n        return None\n    return values\n\n\ndef _read_payload_from_msg(msg: Message) -> str | None:\n    value = str(msg.get_payload()).strip()\n    if value == 'UNKNOWN' or not value:\n        return None\n    return value\n\n\ndef read_pkg_file(self, file):\n    \"\"\"Reads the metadata values from a file object.\"\"\"\n    msg = message_from_file(file)\n\n    self.metadata_version = Version(msg['metadata-version'])\n    self.name = _read_field_from_msg(msg, 'name')\n    self.version = _read_field_from_msg(msg, 'version')\n    self.description = _read_field_from_msg(msg, 'summary')\n    # we are filling author only.\n    self.author = _read_field_from_msg(msg, 'author')\n    self.maintainer = None\n    self.author_email = _read_field_from_msg(msg, 'author-email')\n    self.maintainer_email = None\n    self.url = _read_field_from_msg(msg, 'home-page')\n    self.download_url = _read_field_from_msg(msg, 'download-url')\n    self.license = _read_field_unescaped_from_msg(msg, 'license')\n\n    self.long_description = _read_field_unescaped_from_msg(msg, 'description')\n    if self.long_description is None and self.metadata_version >= Version('2.1'):\n        self.long_description = _read_payload_from_msg(msg)\n    self.description = _read_field_from_msg(msg, 'summary')\n\n    if 'keywords' in msg:\n        self.keywords = _read_field_from_msg(msg, 'keywords').split(',')\n\n    self.platforms = _read_list_from_msg(msg, 'platform')\n    self.classifiers = _read_list_from_msg(msg, 'classifier')\n\n    # PEP 314 - these fields only exist in 1.1\n    if self.metadata_version == Version('1.1'):\n        self.requires = _read_list_from_msg(msg, 'requires')\n        self.provides = _read_list_from_msg(msg, 'provides')\n        self.obsoletes = _read_list_from_msg(msg, 'obsoletes')\n    else:\n        self.requires = None\n        self.provides = None\n        self.obsoletes = None\n\n    self.license_files = _read_list_from_msg(msg, 'license-file')\n\n\ndef single_line(val):\n    \"\"\"\n    Quick and dirty validation for Summary pypa/setuptools#1390.\n    \"\"\"\n    if '\\n' in val:\n        # TODO: Replace with `raise ValueError(\"newlines not allowed\")`\n        # after reviewing #2893.\n        msg = \"newlines are not allowed in `summary` and will break in the future\"\n        SetuptoolsDeprecationWarning.emit(\"Invalid config.\", msg)\n        # due_date is undefined. Controversial change, there was a lot of push back.\n        val = val.strip().split('\\n')[0]\n    return val\n\n\ndef write_pkg_info(self, base_dir):\n    \"\"\"Write the PKG-INFO file into the release tree.\"\"\"\n    temp = \"\"\n    final = os.path.join(base_dir, 'PKG-INFO')\n    try:\n        # Use a temporary file while writing to avoid race conditions\n        # (e.g. `importlib.metadata` reading `.egg-info/PKG-INFO`):\n        with NamedTemporaryFile(\"w\", encoding=\"utf-8\", dir=base_dir, delete=False) as f:\n            temp = f.name\n            self.write_pkg_file(f)\n        permissions = stat.S_IMODE(os.lstat(temp).st_mode)\n        os.chmod(temp, permissions | stat.S_IRGRP | stat.S_IROTH)\n        os.replace(temp, final)  # atomic operation.\n    finally:\n        if temp and os.path.exists(temp):\n            os.remove(temp)\n\n\n# Based on Python 3.5 version\ndef write_pkg_file(self, file):  # noqa: C901  # is too complex (14)  # FIXME\n    \"\"\"Write the PKG-INFO format data to a file object.\"\"\"\n    version = self.get_metadata_version()\n\n    def write_field(key, value):\n        file.write(f\"{key}: {value}\\n\")\n\n    write_field('Metadata-Version', str(version))\n    write_field('Name', self.get_name())\n    write_field('Version', self.get_version())\n\n    summary = self.get_description()\n    if summary:\n        write_field('Summary', single_line(summary))\n\n    optional_fields = (\n        ('Home-page', 'url'),\n        ('Download-URL', 'download_url'),\n        ('Author', 'author'),\n        ('Author-email', 'author_email'),\n        ('Maintainer', 'maintainer'),\n        ('Maintainer-email', 'maintainer_email'),\n    )\n\n    for field, attr in optional_fields:\n        attr_val = getattr(self, attr, None)\n        if attr_val is not None:\n            write_field(field, attr_val)\n\n    license = self.get_license()\n    if license:\n        write_field('License', rfc822_escape(license))\n\n    for label, url in self.project_urls.items():\n        write_field('Project-URL', f'{label}, {url}')\n\n    keywords = ','.join(self.get_keywords())\n    if keywords:\n        write_field('Keywords', keywords)\n\n    platforms = self.get_platforms() or []\n    for platform in platforms:\n        write_field('Platform', platform)\n\n    self._write_list(file, 'Classifier', self.get_classifiers())\n\n    # PEP 314\n    self._write_list(file, 'Requires', self.get_requires())\n    self._write_list(file, 'Provides', self.get_provides())\n    self._write_list(file, 'Obsoletes', self.get_obsoletes())\n\n    # Setuptools specific for PEP 345\n    if hasattr(self, 'python_requires'):\n        write_field('Requires-Python', self.python_requires)\n\n    # PEP 566\n    if self.long_description_content_type:\n        write_field('Description-Content-Type', self.long_description_content_type)\n\n    self._write_list(file, 'License-File', self.license_files or [])\n    _write_requirements(self, file)\n\n    for field, attr in _POSSIBLE_DYNAMIC_FIELDS.items():\n        if (val := getattr(self, attr, None)) and not is_static(val):\n            write_field('Dynamic', field)\n\n    long_description = self.get_long_description()\n    if long_description:\n        file.write(f\"\\n{long_description}\")\n        if not long_description.endswith(\"\\n\"):\n            file.write(\"\\n\")\n\n\ndef _write_requirements(self, file):\n    for req in _reqs.parse(self.install_requires):\n        file.write(f\"Requires-Dist: {req}\\n\")\n\n    processed_extras = {}\n    for augmented_extra, reqs in self.extras_require.items():\n        # Historically, setuptools allows \"augmented extras\": `<extra>:<condition>`\n        unsafe_extra, _, condition = augmented_extra.partition(\":\")\n        unsafe_extra = unsafe_extra.strip()\n        extra = _normalization.safe_extra(unsafe_extra)\n\n        if extra:\n            _write_provides_extra(file, processed_extras, extra, unsafe_extra)\n        for req in _reqs.parse_strings(reqs):\n            r = _include_extra(req, extra, condition.strip())\n            file.write(f\"Requires-Dist: {r}\\n\")\n\n    return processed_extras\n\n\ndef _include_extra(req: str, extra: str, condition: str) -> Requirement:\n    r = Requirement(req)  # create a fresh object that can be modified\n    parts = (\n        f\"({r.marker})\" if r.marker else None,\n        f\"({condition})\" if condition else None,\n        f\"extra == {extra!r}\" if extra else None,\n    )\n    r.marker = Marker(\" and \".join(x for x in parts if x))\n    return r\n\n\ndef _write_provides_extra(file, processed_extras, safe, unsafe):\n    previous = processed_extras.get(safe)\n    if previous == unsafe:\n        SetuptoolsDeprecationWarning.emit(\n            'Ambiguity during \"extra\" normalization for dependencies.',\n            f\"\"\"\n            {previous!r} and {unsafe!r} normalize to the same value:\\n\n                {safe!r}\\n\n            In future versions, setuptools might halt the build process.\n            \"\"\",\n            see_url=\"https://peps.python.org/pep-0685/\",\n        )\n    else:\n        processed_extras[safe] = unsafe\n        file.write(f\"Provides-Extra: {safe}\\n\")\n\n\n# from pypa/distutils#244; needed only until that logic is always available\ndef get_fullname(self):\n    return _distribution_fullname(self.get_name(), self.get_version())\n\n\ndef _distribution_fullname(name: str, version: str) -> str:\n    \"\"\"\n    >>> _distribution_fullname('setup.tools', '1.0-2')\n    'setup_tools-1.0.post2'\n    >>> _distribution_fullname('setup-tools', '1.2post2')\n    'setup_tools-1.2.post2'\n    >>> _distribution_fullname('setup-tools', '1.0-r2')\n    'setup_tools-1.0.post2'\n    >>> _distribution_fullname('setup.tools', '1.0.post')\n    'setup_tools-1.0.post0'\n    >>> _distribution_fullname('setup.tools', '1.0+ubuntu-1')\n    'setup_tools-1.0+ubuntu.1'\n    \"\"\"\n    return \"{}-{}\".format(\n        canonicalize_name(name).replace('-', '_'),\n        canonicalize_version(version, strip_trailing_zero=False),\n    )\n\n\n_POSSIBLE_DYNAMIC_FIELDS = {\n    # Core Metadata Field x related Distribution attribute\n    \"author\": \"author\",\n    \"author-email\": \"author_email\",\n    \"classifier\": \"classifiers\",\n    \"description\": \"long_description\",\n    \"description-content-type\": \"long_description_content_type\",\n    \"download-url\": \"download_url\",\n    \"home-page\": \"url\",\n    \"keywords\": \"keywords\",\n    \"license\": \"license\",\n    # \"license-file\": \"license_files\", # XXX: does PEP 639 exempt Dynamic ??\n    \"maintainer\": \"maintainer\",\n    \"maintainer-email\": \"maintainer_email\",\n    \"obsoletes\": \"obsoletes\",\n    # \"obsoletes-dist\": \"obsoletes_dist\",  # NOT USED\n    \"platform\": \"platforms\",\n    \"project-url\": \"project_urls\",\n    \"provides\": \"provides\",\n    # \"provides-dist\": \"provides_dist\",  # NOT USED\n    \"provides-extra\": \"extras_require\",\n    \"requires\": \"requires\",\n    \"requires-dist\": \"install_requires\",\n    # \"requires-external\": \"requires_external\",  # NOT USED\n    \"requires-python\": \"python_requires\",\n    \"summary\": \"description\",\n    # \"supported-platform\": \"supported_platforms\",  # NOT USED\n}\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/__init__.py","size":359,"sha1":"be943a7129bebdda3956dca88a764d5d9164ce62","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import importlib\nimport sys\n\n__version__, _, _ = sys.version.partition(' ')\n\n\ntry:\n    # Allow Debian and pkgsrc (only) to customize system\n    # behavior. Ref pypa/distutils#2 and pypa/distutils#16.\n    # This hook is deprecated and no other environments\n    # should use it.\n    importlib.import_module('_distutils_system_mod')\nexcept ImportError:\n    pass\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/_log.py","size":42,"sha1":"a09779293a4dab2f6c10e65e7da8e94dde1fcbbf","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import logging\n\nlog = logging.getLogger()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/_macos_compat.py","size":239,"sha1":"8bfb0e4a5d167eb613d5baef3c78fd480d541c99","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import importlib\nimport sys\n\n\ndef bypass_compiler_fixup(cmd, args):\n    return cmd\n\n\nif sys.platform == 'darwin':\n    compiler_fixup = importlib.import_module('_osx_support').compiler_fixup\nelse:\n    compiler_fixup = bypass_compiler_fixup\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/_modified.py","size":2446,"sha1":"cbe4119d57d8b56b522cd33c24f25c8dc63adb39","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Timestamp comparison of files and groups of files.\"\"\"\n\nimport functools\nimport os.path\n\nfrom jaraco.functools import splat\n\nfrom .compat.py39 import zip_strict\nfrom .errors import DistutilsFileError\n\n\ndef _newer(source, target):\n    return not os.path.exists(target) or (\n        os.path.getmtime(source) > os.path.getmtime(target)\n    )\n\n\ndef newer(source, target):\n    \"\"\"\n    Is source modified more recently than target.\n\n    Returns True if 'source' is modified more recently than\n    'target' or if 'target' does not exist.\n\n    Raises DistutilsFileError if 'source' does not exist.\n    \"\"\"\n    if not os.path.exists(source):\n        raise DistutilsFileError(f\"file '{os.path.abspath(source)}' does not exist\")\n\n    return _newer(source, target)\n\n\ndef newer_pairwise(sources, targets, newer=newer):\n    \"\"\"\n    Filter filenames where sources are newer than targets.\n\n    Walk two filename iterables in parallel, testing if each source is newer\n    than its corresponding target.  Returns a pair of lists (sources,\n    targets) where source is newer than target, according to the semantics\n    of 'newer()'.\n    \"\"\"\n    newer_pairs = filter(splat(newer), zip_strict(sources, targets))\n    return tuple(map(list, zip(*newer_pairs))) or ([], [])\n\n\ndef newer_group(sources, target, missing='error'):\n    \"\"\"\n    Is target out-of-date with respect to any file in sources.\n\n    Return True if 'target' is out-of-date with respect to any file\n    listed in 'sources'. In other words, if 'target' exists and is newer\n    than every file in 'sources', return False; otherwise return True.\n    ``missing`` controls how to handle a missing source file:\n\n    - error (default): allow the ``stat()`` call to fail.\n    - ignore: silently disregard any missing source files.\n    - newer: treat missing source files as \"target out of date\". This\n      mode is handy in \"dry-run\" mode: it will pretend to carry out\n      commands that wouldn't work because inputs are missing, but\n      that doesn't matter because dry-run won't run the commands.\n    \"\"\"\n\n    def missing_as_newer(source):\n        return missing == 'newer' and not os.path.exists(source)\n\n    ignored = os.path.exists if missing == 'ignore' else None\n    return not os.path.exists(target) or any(\n        missing_as_newer(source) or _newer(source, target)\n        for source in filter(ignored, sources)\n    )\n\n\nnewer_pairwise_group = functools.partial(newer_pairwise, newer=newer_group)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/_msvccompiler.py","size":20798,"sha1":"3b1db01efc5bbc7cae913235cd5d9a3f3965fd11","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils._msvccompiler\n\nContains MSVCCompiler, an implementation of the abstract CCompiler class\nfor Microsoft Visual Studio 2015.\n\nThis module requires VS 2015 or later.\n\"\"\"\n\n# Written by Perry Stoll\n# hacked by Robin Becker and Thomas Heller to do a better job of\n#   finding DevStudio (through the registry)\n# ported to VS 2005 and VS 2008 by Christian Heimes\n# ported to VS 2015 by Steve Dower\n\nimport contextlib\nimport os\nimport subprocess\nimport unittest.mock as mock\nimport warnings\n\nwith contextlib.suppress(ImportError):\n    import winreg\n\nfrom itertools import count\n\nfrom ._log import log\nfrom .ccompiler import CCompiler, gen_lib_options\nfrom .errors import (\n    CompileError,\n    DistutilsExecError,\n    DistutilsPlatformError,\n    LibError,\n    LinkError,\n)\nfrom .util import get_host_platform, get_platform\n\n\ndef _find_vc2015():\n    try:\n        key = winreg.OpenKeyEx(\n            winreg.HKEY_LOCAL_MACHINE,\n            r\"Software\\Microsoft\\VisualStudio\\SxS\\VC7\",\n            access=winreg.KEY_READ | winreg.KEY_WOW64_32KEY,\n        )\n    except OSError:\n        log.debug(\"Visual C++ is not registered\")\n        return None, None\n\n    best_version = 0\n    best_dir = None\n    with key:\n        for i in count():\n            try:\n                v, vc_dir, vt = winreg.EnumValue(key, i)\n            except OSError:\n                break\n            if v and vt == winreg.REG_SZ and os.path.isdir(vc_dir):\n                try:\n                    version = int(float(v))\n                except (ValueError, TypeError):\n                    continue\n                if version >= 14 and version > best_version:\n                    best_version, best_dir = version, vc_dir\n    return best_version, best_dir\n\n\ndef _find_vc2017():\n    \"\"\"Returns \"15, path\" based on the result of invoking vswhere.exe\n    If no install is found, returns \"None, None\"\n\n    The version is returned to avoid unnecessarily changing the function\n    result. It may be ignored when the path is not None.\n\n    If vswhere.exe is not available, by definition, VS 2017 is not\n    installed.\n    \"\"\"\n    root = os.environ.get(\"ProgramFiles(x86)\") or os.environ.get(\"ProgramFiles\")\n    if not root:\n        return None, None\n\n    variant = 'arm64' if get_platform() == 'win-arm64' else 'x86.x64'\n    suitable_components = (\n        f\"Microsoft.VisualStudio.Component.VC.Tools.{variant}\",\n        \"Microsoft.VisualStudio.Workload.WDExpress\",\n    )\n\n    for component in suitable_components:\n        # Workaround for `-requiresAny` (only available on VS 2017 > 15.6)\n        with contextlib.suppress(\n            subprocess.CalledProcessError, OSError, UnicodeDecodeError\n        ):\n            path = (\n                subprocess.check_output([\n                    os.path.join(\n                        root, \"Microsoft Visual Studio\", \"Installer\", \"vswhere.exe\"\n                    ),\n                    \"-latest\",\n                    \"-prerelease\",\n                    \"-requires\",\n                    component,\n                    \"-property\",\n                    \"installationPath\",\n                    \"-products\",\n                    \"*\",\n                ])\n                .decode(encoding=\"mbcs\", errors=\"strict\")\n                .strip()\n            )\n\n            path = os.path.join(path, \"VC\", \"Auxiliary\", \"Build\")\n            if os.path.isdir(path):\n                return 15, path\n\n    return None, None  # no suitable component found\n\n\nPLAT_SPEC_TO_RUNTIME = {\n    'x86': 'x86',\n    'x86_amd64': 'x64',\n    'x86_arm': 'arm',\n    'x86_arm64': 'arm64',\n}\n\n\ndef _find_vcvarsall(plat_spec):\n    # bpo-38597: Removed vcruntime return value\n    _, best_dir = _find_vc2017()\n\n    if not best_dir:\n        best_version, best_dir = _find_vc2015()\n\n    if not best_dir:\n        log.debug(\"No suitable Visual C++ version found\")\n        return None, None\n\n    vcvarsall = os.path.join(best_dir, \"vcvarsall.bat\")\n    if not os.path.isfile(vcvarsall):\n        log.debug(\"%s cannot be found\", vcvarsall)\n        return None, None\n\n    return vcvarsall, None\n\n\ndef _get_vc_env(plat_spec):\n    if os.getenv(\"DISTUTILS_USE_SDK\"):\n        return {key.lower(): value for key, value in os.environ.items()}\n\n    vcvarsall, _ = _find_vcvarsall(plat_spec)\n    if not vcvarsall:\n        raise DistutilsPlatformError(\n            'Microsoft Visual C++ 14.0 or greater is required. '\n            'Get it with \"Microsoft C++ Build Tools\": '\n            'https://visualstudio.microsoft.com/visual-cpp-build-tools/'\n        )\n\n    try:\n        out = subprocess.check_output(\n            f'cmd /u /c \"{vcvarsall}\" {plat_spec} && set',\n            stderr=subprocess.STDOUT,\n        ).decode('utf-16le', errors='replace')\n    except subprocess.CalledProcessError as exc:\n        log.error(exc.output)\n        raise DistutilsPlatformError(f\"Error executing {exc.cmd}\")\n\n    env = {\n        key.lower(): value\n        for key, _, value in (line.partition('=') for line in out.splitlines())\n        if key and value\n    }\n\n    return env\n\n\ndef _find_exe(exe, paths=None):\n    \"\"\"Return path to an MSVC executable program.\n\n    Tries to find the program in several places: first, one of the\n    MSVC program search paths from the registry; next, the directories\n    in the PATH environment variable.  If any of those work, return an\n    absolute path that is known to exist.  If none of them work, just\n    return the original program name, 'exe'.\n    \"\"\"\n    if not paths:\n        paths = os.getenv('path').split(os.pathsep)\n    for p in paths:\n        fn = os.path.join(os.path.abspath(p), exe)\n        if os.path.isfile(fn):\n            return fn\n    return exe\n\n\n_vcvars_names = {\n    'win32': 'x86',\n    'win-amd64': 'amd64',\n    'win-arm32': 'arm',\n    'win-arm64': 'arm64',\n}\n\n\ndef _get_vcvars_spec(host_platform, platform):\n    \"\"\"\n    Given a host platform and platform, determine the spec for vcvarsall.\n\n    Uses the native MSVC host if the host platform would need expensive\n    emulation for x86.\n\n    >>> _get_vcvars_spec('win-arm64', 'win32')\n    'arm64_x86'\n    >>> _get_vcvars_spec('win-arm64', 'win-amd64')\n    'arm64_amd64'\n\n    Otherwise, always cross-compile from x86 to work with the\n    lighter-weight MSVC installs that do not include native 64-bit tools.\n\n    >>> _get_vcvars_spec('win32', 'win32')\n    'x86'\n    >>> _get_vcvars_spec('win-arm32', 'win-arm32')\n    'x86_arm'\n    >>> _get_vcvars_spec('win-amd64', 'win-arm64')\n    'x86_arm64'\n    \"\"\"\n    if host_platform != 'win-arm64':\n        host_platform = 'win32'\n    vc_hp = _vcvars_names[host_platform]\n    vc_plat = _vcvars_names[platform]\n    return vc_hp if vc_hp == vc_plat else f'{vc_hp}_{vc_plat}'\n\n\nclass MSVCCompiler(CCompiler):\n    \"\"\"Concrete class that implements an interface to Microsoft Visual C++,\n    as defined by the CCompiler abstract class.\"\"\"\n\n    compiler_type = 'msvc'\n\n    # Just set this so CCompiler's constructor doesn't barf.  We currently\n    # don't use the 'set_executables()' bureaucracy provided by CCompiler,\n    # as it really isn't necessary for this sort of single-compiler class.\n    # Would be nice to have a consistent interface with UnixCCompiler,\n    # though, so it's worth thinking about.\n    executables = {}\n\n    # Private class data (need to distinguish C from C++ source for compiler)\n    _c_extensions = ['.c']\n    _cpp_extensions = ['.cc', '.cpp', '.cxx']\n    _rc_extensions = ['.rc']\n    _mc_extensions = ['.mc']\n\n    # Needed for the filename generation methods provided by the\n    # base class, CCompiler.\n    src_extensions = _c_extensions + _cpp_extensions + _rc_extensions + _mc_extensions\n    res_extension = '.res'\n    obj_extension = '.obj'\n    static_lib_extension = '.lib'\n    shared_lib_extension = '.dll'\n    static_lib_format = shared_lib_format = '%s%s'\n    exe_extension = '.exe'\n\n    def __init__(self, verbose=False, dry_run=False, force=False):\n        super().__init__(verbose, dry_run, force)\n        # target platform (.plat_name is consistent with 'bdist')\n        self.plat_name = None\n        self.initialized = False\n\n    @classmethod\n    def _configure(cls, vc_env):\n        \"\"\"\n        Set class-level include/lib dirs.\n        \"\"\"\n        cls.include_dirs = cls._parse_path(vc_env.get('include', ''))\n        cls.library_dirs = cls._parse_path(vc_env.get('lib', ''))\n\n    @staticmethod\n    def _parse_path(val):\n        return [dir.rstrip(os.sep) for dir in val.split(os.pathsep) if dir]\n\n    def initialize(self, plat_name=None):\n        # multi-init means we would need to check platform same each time...\n        assert not self.initialized, \"don't init multiple times\"\n        if plat_name is None:\n            plat_name = get_platform()\n        # sanity check for platforms to prevent obscure errors later.\n        if plat_name not in _vcvars_names:\n            raise DistutilsPlatformError(\n                f\"--plat-name must be one of {tuple(_vcvars_names)}\"\n            )\n\n        plat_spec = _get_vcvars_spec(get_host_platform(), plat_name)\n\n        vc_env = _get_vc_env(plat_spec)\n        if not vc_env:\n            raise DistutilsPlatformError(\n                \"Unable to find a compatible Visual Studio installation.\"\n            )\n        self._configure(vc_env)\n\n        self._paths = vc_env.get('path', '')\n        paths = self._paths.split(os.pathsep)\n        self.cc = _find_exe(\"cl.exe\", paths)\n        self.linker = _find_exe(\"link.exe\", paths)\n        self.lib = _find_exe(\"lib.exe\", paths)\n        self.rc = _find_exe(\"rc.exe\", paths)  # resource compiler\n        self.mc = _find_exe(\"mc.exe\", paths)  # message compiler\n        self.mt = _find_exe(\"mt.exe\", paths)  # message compiler\n\n        self.preprocess_options = None\n        # bpo-38597: Always compile with dynamic linking\n        # Future releases of Python 3.x will include all past\n        # versions of vcruntime*.dll for compatibility.\n        self.compile_options = ['/nologo', '/O2', '/W3', '/GL', '/DNDEBUG', '/MD']\n\n        self.compile_options_debug = [\n            '/nologo',\n            '/Od',\n            '/MDd',\n            '/Zi',\n            '/W3',\n            '/D_DEBUG',\n        ]\n\n        ldflags = ['/nologo', '/INCREMENTAL:NO', '/LTCG']\n\n        ldflags_debug = ['/nologo', '/INCREMENTAL:NO', '/LTCG', '/DEBUG:FULL']\n\n        self.ldflags_exe = [*ldflags, '/MANIFEST:EMBED,ID=1']\n        self.ldflags_exe_debug = [*ldflags_debug, '/MANIFEST:EMBED,ID=1']\n        self.ldflags_shared = [\n            *ldflags,\n            '/DLL',\n            '/MANIFEST:EMBED,ID=2',\n            '/MANIFESTUAC:NO',\n        ]\n        self.ldflags_shared_debug = [\n            *ldflags_debug,\n            '/DLL',\n            '/MANIFEST:EMBED,ID=2',\n            '/MANIFESTUAC:NO',\n        ]\n        self.ldflags_static = [*ldflags]\n        self.ldflags_static_debug = [*ldflags_debug]\n\n        self._ldflags = {\n            (CCompiler.EXECUTABLE, None): self.ldflags_exe,\n            (CCompiler.EXECUTABLE, False): self.ldflags_exe,\n            (CCompiler.EXECUTABLE, True): self.ldflags_exe_debug,\n            (CCompiler.SHARED_OBJECT, None): self.ldflags_shared,\n            (CCompiler.SHARED_OBJECT, False): self.ldflags_shared,\n            (CCompiler.SHARED_OBJECT, True): self.ldflags_shared_debug,\n            (CCompiler.SHARED_LIBRARY, None): self.ldflags_static,\n            (CCompiler.SHARED_LIBRARY, False): self.ldflags_static,\n            (CCompiler.SHARED_LIBRARY, True): self.ldflags_static_debug,\n        }\n\n        self.initialized = True\n\n    # -- Worker methods ------------------------------------------------\n\n    @property\n    def out_extensions(self):\n        return {\n            **super().out_extensions,\n            **{\n                ext: self.res_extension\n                for ext in self._rc_extensions + self._mc_extensions\n            },\n        }\n\n    def compile(  # noqa: C901\n        self,\n        sources,\n        output_dir=None,\n        macros=None,\n        include_dirs=None,\n        debug=False,\n        extra_preargs=None,\n        extra_postargs=None,\n        depends=None,\n    ):\n        if not self.initialized:\n            self.initialize()\n        compile_info = self._setup_compile(\n            output_dir, macros, include_dirs, sources, depends, extra_postargs\n        )\n        macros, objects, extra_postargs, pp_opts, build = compile_info\n\n        compile_opts = extra_preargs or []\n        compile_opts.append('/c')\n        if debug:\n            compile_opts.extend(self.compile_options_debug)\n        else:\n            compile_opts.extend(self.compile_options)\n\n        add_cpp_opts = False\n\n        for obj in objects:\n            try:\n                src, ext = build[obj]\n            except KeyError:\n                continue\n            if debug:\n                # pass the full pathname to MSVC in debug mode,\n                # this allows the debugger to find the source file\n                # without asking the user to browse for it\n                src = os.path.abspath(src)\n\n            if ext in self._c_extensions:\n                input_opt = \"/Tc\" + src\n            elif ext in self._cpp_extensions:\n                input_opt = \"/Tp\" + src\n                add_cpp_opts = True\n            elif ext in self._rc_extensions:\n                # compile .RC to .RES file\n                input_opt = src\n                output_opt = \"/fo\" + obj\n                try:\n                    self.spawn([self.rc] + pp_opts + [output_opt, input_opt])\n                except DistutilsExecError as msg:\n                    raise CompileError(msg)\n                continue\n            elif ext in self._mc_extensions:\n                # Compile .MC to .RC file to .RES file.\n                #   * '-h dir' specifies the directory for the\n                #     generated include file\n                #   * '-r dir' specifies the target directory of the\n                #     generated RC file and the binary message resource\n                #     it includes\n                #\n                # For now (since there are no options to change this),\n                # we use the source-directory for the include file and\n                # the build directory for the RC file and message\n                # resources. This works at least for win32all.\n                h_dir = os.path.dirname(src)\n                rc_dir = os.path.dirname(obj)\n                try:\n                    # first compile .MC to .RC and .H file\n                    self.spawn([self.mc, '-h', h_dir, '-r', rc_dir, src])\n                    base, _ = os.path.splitext(os.path.basename(src))\n                    rc_file = os.path.join(rc_dir, base + '.rc')\n                    # then compile .RC to .RES file\n                    self.spawn([self.rc, \"/fo\" + obj, rc_file])\n\n                except DistutilsExecError as msg:\n                    raise CompileError(msg)\n                continue\n            else:\n                # how to handle this file?\n                raise CompileError(f\"Don't know how to compile {src} to {obj}\")\n\n            args = [self.cc] + compile_opts + pp_opts\n            if add_cpp_opts:\n                args.append('/EHsc')\n            args.extend((input_opt, \"/Fo\" + obj))\n            args.extend(extra_postargs)\n\n            try:\n                self.spawn(args)\n            except DistutilsExecError as msg:\n                raise CompileError(msg)\n\n        return objects\n\n    def create_static_lib(\n        self, objects, output_libname, output_dir=None, debug=False, target_lang=None\n    ):\n        if not self.initialized:\n            self.initialize()\n        objects, output_dir = self._fix_object_args(objects, output_dir)\n        output_filename = self.library_filename(output_libname, output_dir=output_dir)\n\n        if self._need_link(objects, output_filename):\n            lib_args = objects + ['/OUT:' + output_filename]\n            if debug:\n                pass  # XXX what goes here?\n            try:\n                log.debug('Executing \"%s\" %s', self.lib, ' '.join(lib_args))\n                self.spawn([self.lib] + lib_args)\n            except DistutilsExecError as msg:\n                raise LibError(msg)\n        else:\n            log.debug(\"skipping %s (up-to-date)\", output_filename)\n\n    def link(\n        self,\n        target_desc,\n        objects,\n        output_filename,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        export_symbols=None,\n        debug=False,\n        extra_preargs=None,\n        extra_postargs=None,\n        build_temp=None,\n        target_lang=None,\n    ):\n        if not self.initialized:\n            self.initialize()\n        objects, output_dir = self._fix_object_args(objects, output_dir)\n        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)\n        libraries, library_dirs, runtime_library_dirs = fixed_args\n\n        if runtime_library_dirs:\n            self.warn(\n                \"I don't know what to do with 'runtime_library_dirs': \"\n                + str(runtime_library_dirs)\n            )\n\n        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)\n        if output_dir is not None:\n            output_filename = os.path.join(output_dir, output_filename)\n\n        if self._need_link(objects, output_filename):\n            ldflags = self._ldflags[target_desc, debug]\n\n            export_opts = [\"/EXPORT:\" + sym for sym in (export_symbols or [])]\n\n            ld_args = (\n                ldflags + lib_opts + export_opts + objects + ['/OUT:' + output_filename]\n            )\n\n            # The MSVC linker generates .lib and .exp files, which cannot be\n            # suppressed by any linker switches. The .lib files may even be\n            # needed! Make sure they are generated in the temporary build\n            # directory. Since they have different names for debug and release\n            # builds, they can go into the same directory.\n            build_temp = os.path.dirname(objects[0])\n            if export_symbols is not None:\n                (dll_name, dll_ext) = os.path.splitext(\n                    os.path.basename(output_filename)\n                )\n                implib_file = os.path.join(build_temp, self.library_filename(dll_name))\n                ld_args.append('/IMPLIB:' + implib_file)\n\n            if extra_preargs:\n                ld_args[:0] = extra_preargs\n            if extra_postargs:\n                ld_args.extend(extra_postargs)\n\n            output_dir = os.path.dirname(os.path.abspath(output_filename))\n            self.mkpath(output_dir)\n            try:\n                log.debug('Executing \"%s\" %s', self.linker, ' '.join(ld_args))\n                self.spawn([self.linker] + ld_args)\n            except DistutilsExecError as msg:\n                raise LinkError(msg)\n        else:\n            log.debug(\"skipping %s (up-to-date)\", output_filename)\n\n    def spawn(self, cmd):\n        env = dict(os.environ, PATH=self._paths)\n        with self._fallback_spawn(cmd, env) as fallback:\n            return super().spawn(cmd, env=env)\n        return fallback.value\n\n    @contextlib.contextmanager\n    def _fallback_spawn(self, cmd, env):\n        \"\"\"\n        Discovered in pypa/distutils#15, some tools monkeypatch the compiler,\n        so the 'env' kwarg causes a TypeError. Detect this condition and\n        restore the legacy, unsafe behavior.\n        \"\"\"\n        bag = type('Bag', (), {})()\n        try:\n            yield bag\n        except TypeError as exc:\n            if \"unexpected keyword argument 'env'\" not in str(exc):\n                raise\n        else:\n            return\n        warnings.warn(\"Fallback spawn triggered. Please update distutils monkeypatch.\")\n        with mock.patch.dict('os.environ', env):\n            bag.value = super().spawn(cmd)\n\n    # -- Miscellaneous methods -----------------------------------------\n    # These are all used by the 'gen_lib_options() function, in\n    # ccompiler.py.\n\n    def library_dir_option(self, dir):\n        return \"/LIBPATH:\" + dir\n\n    def runtime_library_dir_option(self, dir):\n        raise DistutilsPlatformError(\n            \"don't know how to set runtime library search path for MSVC\"\n        )\n\n    def library_option(self, lib):\n        return self.library_filename(lib)\n\n    def find_library_file(self, dirs, lib, debug=False):\n        # Prefer a debugging library if found (and requested), but deal\n        # with it if we don't have one.\n        if debug:\n            try_names = [lib + \"_d\", lib]\n        else:\n            try_names = [lib]\n        for dir in dirs:\n            for name in try_names:\n                libfile = os.path.join(dir, self.library_filename(name))\n                if os.path.isfile(libfile):\n                    return libfile\n        else:\n            # Oops, didn't find it in *any* of 'dirs'\n            return None\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/archive_util.py","size":7844,"sha1":"edf530824df3bcbafe0be307c14f6b1503dcbf63","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.archive_util\n\nUtility functions for creating archive files (tarballs, zip files,\nthat sort of thing).\"\"\"\n\nimport os\n\ntry:\n    import zipfile\nexcept ImportError:\n    zipfile = None\n\n\nfrom ._log import log\nfrom .dir_util import mkpath\nfrom .errors import DistutilsExecError\nfrom .spawn import spawn\n\ntry:\n    from pwd import getpwnam\nexcept ImportError:\n    getpwnam = None\n\ntry:\n    from grp import getgrnam\nexcept ImportError:\n    getgrnam = None\n\n\ndef _get_gid(name):\n    \"\"\"Returns a gid, given a group name.\"\"\"\n    if getgrnam is None or name is None:\n        return None\n    try:\n        result = getgrnam(name)\n    except KeyError:\n        result = None\n    if result is not None:\n        return result[2]\n    return None\n\n\ndef _get_uid(name):\n    \"\"\"Returns an uid, given a user name.\"\"\"\n    if getpwnam is None or name is None:\n        return None\n    try:\n        result = getpwnam(name)\n    except KeyError:\n        result = None\n    if result is not None:\n        return result[2]\n    return None\n\n\ndef make_tarball(\n    base_name,\n    base_dir,\n    compress=\"gzip\",\n    verbose=False,\n    dry_run=False,\n    owner=None,\n    group=None,\n):\n    \"\"\"Create a (possibly compressed) tar file from all the files under\n    'base_dir'.\n\n    'compress' must be \"gzip\" (the default), \"bzip2\", \"xz\", or None.\n\n    'owner' and 'group' can be used to define an owner and a group for the\n    archive that is being built. If not provided, the current owner and group\n    will be used.\n\n    The output tar file will be named 'base_dir' +  \".tar\", possibly plus\n    the appropriate compression extension (\".gz\", \".bz2\", \".xz\" or \".Z\").\n\n    Returns the output filename.\n    \"\"\"\n    tar_compression = {\n        'gzip': 'gz',\n        'bzip2': 'bz2',\n        'xz': 'xz',\n        None: '',\n    }\n    compress_ext = {'gzip': '.gz', 'bzip2': '.bz2', 'xz': '.xz'}\n\n    # flags for compression program, each element of list will be an argument\n    if compress is not None and compress not in compress_ext.keys():\n        raise ValueError(\n            \"bad value for 'compress': must be None, 'gzip', 'bzip2', 'xz'\"\n        )\n\n    archive_name = base_name + '.tar'\n    archive_name += compress_ext.get(compress, '')\n\n    mkpath(os.path.dirname(archive_name), dry_run=dry_run)\n\n    # creating the tarball\n    import tarfile  # late import so Python build itself doesn't break\n\n    log.info('Creating tar archive')\n\n    uid = _get_uid(owner)\n    gid = _get_gid(group)\n\n    def _set_uid_gid(tarinfo):\n        if gid is not None:\n            tarinfo.gid = gid\n            tarinfo.gname = group\n        if uid is not None:\n            tarinfo.uid = uid\n            tarinfo.uname = owner\n        return tarinfo\n\n    if not dry_run:\n        tar = tarfile.open(archive_name, f'w|{tar_compression[compress]}')\n        try:\n            tar.add(base_dir, filter=_set_uid_gid)\n        finally:\n            tar.close()\n\n    return archive_name\n\n\ndef make_zipfile(base_name, base_dir, verbose=False, dry_run=False):  # noqa: C901\n    \"\"\"Create a zip file from all the files under 'base_dir'.\n\n    The output zip file will be named 'base_name' + \".zip\".  Uses either the\n    \"zipfile\" Python module (if available) or the InfoZIP \"zip\" utility\n    (if installed and found on the default search path).  If neither tool is\n    available, raises DistutilsExecError.  Returns the name of the output zip\n    file.\n    \"\"\"\n    zip_filename = base_name + \".zip\"\n    mkpath(os.path.dirname(zip_filename), dry_run=dry_run)\n\n    # If zipfile module is not available, try spawning an external\n    # 'zip' command.\n    if zipfile is None:\n        if verbose:\n            zipoptions = \"-r\"\n        else:\n            zipoptions = \"-rq\"\n\n        try:\n            spawn([\"zip\", zipoptions, zip_filename, base_dir], dry_run=dry_run)\n        except DistutilsExecError:\n            # XXX really should distinguish between \"couldn't find\n            # external 'zip' command\" and \"zip failed\".\n            raise DistutilsExecError(\n                f\"unable to create zip file '{zip_filename}': \"\n                \"could neither import the 'zipfile' module nor \"\n                \"find a standalone zip utility\"\n            )\n\n    else:\n        log.info(\"creating '%s' and adding '%s' to it\", zip_filename, base_dir)\n\n        if not dry_run:\n            try:\n                zip = zipfile.ZipFile(\n                    zip_filename, \"w\", compression=zipfile.ZIP_DEFLATED\n                )\n            except RuntimeError:\n                zip = zipfile.ZipFile(zip_filename, \"w\", compression=zipfile.ZIP_STORED)\n\n            with zip:\n                if base_dir != os.curdir:\n                    path = os.path.normpath(os.path.join(base_dir, ''))\n                    zip.write(path, path)\n                    log.info(\"adding '%s'\", path)\n                for dirpath, dirnames, filenames in os.walk(base_dir):\n                    for name in dirnames:\n                        path = os.path.normpath(os.path.join(dirpath, name, ''))\n                        zip.write(path, path)\n                        log.info(\"adding '%s'\", path)\n                    for name in filenames:\n                        path = os.path.normpath(os.path.join(dirpath, name))\n                        if os.path.isfile(path):\n                            zip.write(path, path)\n                            log.info(\"adding '%s'\", path)\n\n    return zip_filename\n\n\nARCHIVE_FORMATS = {\n    'gztar': (make_tarball, [('compress', 'gzip')], \"gzip'ed tar-file\"),\n    'bztar': (make_tarball, [('compress', 'bzip2')], \"bzip2'ed tar-file\"),\n    'xztar': (make_tarball, [('compress', 'xz')], \"xz'ed tar-file\"),\n    'ztar': (make_tarball, [('compress', 'compress')], \"compressed tar file\"),\n    'tar': (make_tarball, [('compress', None)], \"uncompressed tar file\"),\n    'zip': (make_zipfile, [], \"ZIP file\"),\n}\n\n\ndef check_archive_formats(formats):\n    \"\"\"Returns the first format from the 'format' list that is unknown.\n\n    If all formats are known, returns None\n    \"\"\"\n    for format in formats:\n        if format not in ARCHIVE_FORMATS:\n            return format\n    return None\n\n\ndef make_archive(\n    base_name,\n    format,\n    root_dir=None,\n    base_dir=None,\n    verbose=False,\n    dry_run=False,\n    owner=None,\n    group=None,\n):\n    \"\"\"Create an archive file (eg. zip or tar).\n\n    'base_name' is the name of the file to create, minus any format-specific\n    extension; 'format' is the archive format: one of \"zip\", \"tar\", \"gztar\",\n    \"bztar\", \"xztar\", or \"ztar\".\n\n    'root_dir' is a directory that will be the root directory of the\n    archive; ie. we typically chdir into 'root_dir' before creating the\n    archive.  'base_dir' is the directory where we start archiving from;\n    ie. 'base_dir' will be the common prefix of all files and\n    directories in the archive.  'root_dir' and 'base_dir' both default\n    to the current directory.  Returns the name of the archive file.\n\n    'owner' and 'group' are used when creating a tar archive. By default,\n    uses the current owner and group.\n    \"\"\"\n    save_cwd = os.getcwd()\n    if root_dir is not None:\n        log.debug(\"changing into '%s'\", root_dir)\n        base_name = os.path.abspath(base_name)\n        if not dry_run:\n            os.chdir(root_dir)\n\n    if base_dir is None:\n        base_dir = os.curdir\n\n    kwargs = {'dry_run': dry_run}\n\n    try:\n        format_info = ARCHIVE_FORMATS[format]\n    except KeyError:\n        raise ValueError(f\"unknown archive format '{format}'\")\n\n    func = format_info[0]\n    kwargs.update(format_info[1])\n\n    if format != 'zip':\n        kwargs['owner'] = owner\n        kwargs['group'] = group\n\n    try:\n        filename = func(base_name, base_dir, **kwargs)\n    finally:\n        if root_dir is not None:\n            log.debug(\"changing back to '%s'\", save_cwd)\n            os.chdir(save_cwd)\n\n    return filename\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/ccompiler.py","size":49190,"sha1":"76d4fdcd2473f7fa9490aea3d6079293847cfab3","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.ccompiler\n\nContains CCompiler, an abstract base class that defines the interface\nfor the Distutils compiler abstraction model.\"\"\"\n\nimport os\nimport pathlib\nimport re\nimport sys\nimport types\nimport warnings\n\nfrom more_itertools import always_iterable\n\nfrom ._log import log\nfrom ._modified import newer_group\nfrom .dir_util import mkpath\nfrom .errors import (\n    CompileError,\n    DistutilsModuleError,\n    DistutilsPlatformError,\n    LinkError,\n    UnknownFileError,\n)\nfrom .file_util import move_file\nfrom .spawn import spawn\nfrom .util import execute, is_mingw, split_quoted\n\n\nclass CCompiler:\n    \"\"\"Abstract base class to define the interface that must be implemented\n    by real compiler classes.  Also has some utility methods used by\n    several compiler classes.\n\n    The basic idea behind a compiler abstraction class is that each\n    instance can be used for all the compile/link steps in building a\n    single project.  Thus, attributes common to all of those compile and\n    link steps -- include directories, macros to define, libraries to link\n    against, etc. -- are attributes of the compiler instance.  To allow for\n    variability in how individual files are treated, most of those\n    attributes may be varied on a per-compilation or per-link basis.\n    \"\"\"\n\n    # 'compiler_type' is a class attribute that identifies this class.  It\n    # keeps code that wants to know what kind of compiler it's dealing with\n    # from having to import all possible compiler classes just to do an\n    # 'isinstance'.  In concrete CCompiler subclasses, 'compiler_type'\n    # should really, really be one of the keys of the 'compiler_class'\n    # dictionary (see below -- used by the 'new_compiler()' factory\n    # function) -- authors of new compiler interface classes are\n    # responsible for updating 'compiler_class'!\n    compiler_type = None\n\n    # XXX things not handled by this compiler abstraction model:\n    #   * client can't provide additional options for a compiler,\n    #     e.g. warning, optimization, debugging flags.  Perhaps this\n    #     should be the domain of concrete compiler abstraction classes\n    #     (UnixCCompiler, MSVCCompiler, etc.) -- or perhaps the base\n    #     class should have methods for the common ones.\n    #   * can't completely override the include or library searchg\n    #     path, ie. no \"cc -I -Idir1 -Idir2\" or \"cc -L -Ldir1 -Ldir2\".\n    #     I'm not sure how widely supported this is even by Unix\n    #     compilers, much less on other platforms.  And I'm even less\n    #     sure how useful it is; maybe for cross-compiling, but\n    #     support for that is a ways off.  (And anyways, cross\n    #     compilers probably have a dedicated binary with the\n    #     right paths compiled in.  I hope.)\n    #   * can't do really freaky things with the library list/library\n    #     dirs, e.g. \"-Ldir1 -lfoo -Ldir2 -lfoo\" to link against\n    #     different versions of libfoo.a in different locations.  I\n    #     think this is useless without the ability to null out the\n    #     library search path anyways.\n\n    # Subclasses that rely on the standard filename generation methods\n    # implemented below should override these; see the comment near\n    # those methods ('object_filenames()' et. al.) for details:\n    src_extensions = None  # list of strings\n    obj_extension = None  # string\n    static_lib_extension = None\n    shared_lib_extension = None  # string\n    static_lib_format = None  # format string\n    shared_lib_format = None  # prob. same as static_lib_format\n    exe_extension = None  # string\n\n    # Default language settings. language_map is used to detect a source\n    # file or Extension target language, checking source filenames.\n    # language_order is used to detect the language precedence, when deciding\n    # what language to use when mixing source types. For example, if some\n    # extension has two files with \".c\" extension, and one with \".cpp\", it\n    # is still linked as c++.\n    language_map = {\n        \".c\": \"c\",\n        \".cc\": \"c++\",\n        \".cpp\": \"c++\",\n        \".cxx\": \"c++\",\n        \".m\": \"objc\",\n    }\n    language_order = [\"c++\", \"objc\", \"c\"]\n\n    include_dirs = []\n    \"\"\"\n    include dirs specific to this compiler class\n    \"\"\"\n\n    library_dirs = []\n    \"\"\"\n    library dirs specific to this compiler class\n    \"\"\"\n\n    def __init__(self, verbose=False, dry_run=False, force=False):\n        self.dry_run = dry_run\n        self.force = force\n        self.verbose = verbose\n\n        # 'output_dir': a common output directory for object, library,\n        # shared object, and shared library files\n        self.output_dir = None\n\n        # 'macros': a list of macro definitions (or undefinitions).  A\n        # macro definition is a 2-tuple (name, value), where the value is\n        # either a string or None (no explicit value).  A macro\n        # undefinition is a 1-tuple (name,).\n        self.macros = []\n\n        # 'include_dirs': a list of directories to search for include files\n        self.include_dirs = []\n\n        # 'libraries': a list of libraries to include in any link\n        # (library names, not filenames: eg. \"foo\" not \"libfoo.a\")\n        self.libraries = []\n\n        # 'library_dirs': a list of directories to search for libraries\n        self.library_dirs = []\n\n        # 'runtime_library_dirs': a list of directories to search for\n        # shared libraries/objects at runtime\n        self.runtime_library_dirs = []\n\n        # 'objects': a list of object files (or similar, such as explicitly\n        # named library files) to include on any link\n        self.objects = []\n\n        for key in self.executables.keys():\n            self.set_executable(key, self.executables[key])\n\n    def set_executables(self, **kwargs):\n        \"\"\"Define the executables (and options for them) that will be run\n        to perform the various stages of compilation.  The exact set of\n        executables that may be specified here depends on the compiler\n        class (via the 'executables' class attribute), but most will have:\n          compiler      the C/C++ compiler\n          linker_so     linker used to create shared objects and libraries\n          linker_exe    linker used to create binary executables\n          archiver      static library creator\n\n        On platforms with a command-line (Unix, DOS/Windows), each of these\n        is a string that will be split into executable name and (optional)\n        list of arguments.  (Splitting the string is done similarly to how\n        Unix shells operate: words are delimited by spaces, but quotes and\n        backslashes can override this.  See\n        'distutils.util.split_quoted()'.)\n        \"\"\"\n\n        # Note that some CCompiler implementation classes will define class\n        # attributes 'cpp', 'cc', etc. with hard-coded executable names;\n        # this is appropriate when a compiler class is for exactly one\n        # compiler/OS combination (eg. MSVCCompiler).  Other compiler\n        # classes (UnixCCompiler, in particular) are driven by information\n        # discovered at run-time, since there are many different ways to do\n        # basically the same things with Unix C compilers.\n\n        for key in kwargs:\n            if key not in self.executables:\n                raise ValueError(\n                    f\"unknown executable '{key}' for class {self.__class__.__name__}\"\n                )\n            self.set_executable(key, kwargs[key])\n\n    def set_executable(self, key, value):\n        if isinstance(value, str):\n            setattr(self, key, split_quoted(value))\n        else:\n            setattr(self, key, value)\n\n    def _find_macro(self, name):\n        i = 0\n        for defn in self.macros:\n            if defn[0] == name:\n                return i\n            i += 1\n        return None\n\n    def _check_macro_definitions(self, definitions):\n        \"\"\"Ensure that every element of 'definitions' is valid.\"\"\"\n        for defn in definitions:\n            self._check_macro_definition(*defn)\n\n    def _check_macro_definition(self, defn):\n        \"\"\"\n        Raise a TypeError if defn is not valid.\n\n        A valid definition is either a (name, value) 2-tuple or a (name,) tuple.\n        \"\"\"\n        if not isinstance(defn, tuple) or not self._is_valid_macro(*defn):\n            raise TypeError(\n                f\"invalid macro definition '{defn}': \"\n                \"must be tuple (string,), (string, string), or (string, None)\"\n            )\n\n    @staticmethod\n    def _is_valid_macro(name, value=None):\n        \"\"\"\n        A valid macro is a ``name : str`` and a ``value : str | None``.\n        \"\"\"\n        return isinstance(name, str) and isinstance(value, (str, types.NoneType))\n\n    # -- Bookkeeping methods -------------------------------------------\n\n    def define_macro(self, name, value=None):\n        \"\"\"Define a preprocessor macro for all compilations driven by this\n        compiler object.  The optional parameter 'value' should be a\n        string; if it is not supplied, then the macro will be defined\n        without an explicit value and the exact outcome depends on the\n        compiler used (XXX true? does ANSI say anything about this?)\n        \"\"\"\n        # Delete from the list of macro definitions/undefinitions if\n        # already there (so that this one will take precedence).\n        i = self._find_macro(name)\n        if i is not None:\n            del self.macros[i]\n\n        self.macros.append((name, value))\n\n    def undefine_macro(self, name):\n        \"\"\"Undefine a preprocessor macro for all compilations driven by\n        this compiler object.  If the same macro is defined by\n        'define_macro()' and undefined by 'undefine_macro()' the last call\n        takes precedence (including multiple redefinitions or\n        undefinitions).  If the macro is redefined/undefined on a\n        per-compilation basis (ie. in the call to 'compile()'), then that\n        takes precedence.\n        \"\"\"\n        # Delete from the list of macro definitions/undefinitions if\n        # already there (so that this one will take precedence).\n        i = self._find_macro(name)\n        if i is not None:\n            del self.macros[i]\n\n        undefn = (name,)\n        self.macros.append(undefn)\n\n    def add_include_dir(self, dir):\n        \"\"\"Add 'dir' to the list of directories that will be searched for\n        header files.  The compiler is instructed to search directories in\n        the order in which they are supplied by successive calls to\n        'add_include_dir()'.\n        \"\"\"\n        self.include_dirs.append(dir)\n\n    def set_include_dirs(self, dirs):\n        \"\"\"Set the list of directories that will be searched to 'dirs' (a\n        list of strings).  Overrides any preceding calls to\n        'add_include_dir()'; subsequence calls to 'add_include_dir()' add\n        to the list passed to 'set_include_dirs()'.  This does not affect\n        any list of standard include directories that the compiler may\n        search by default.\n        \"\"\"\n        self.include_dirs = dirs[:]\n\n    def add_library(self, libname):\n        \"\"\"Add 'libname' to the list of libraries that will be included in\n        all links driven by this compiler object.  Note that 'libname'\n        should *not* be the name of a file containing a library, but the\n        name of the library itself: the actual filename will be inferred by\n        the linker, the compiler, or the compiler class (depending on the\n        platform).\n\n        The linker will be instructed to link against libraries in the\n        order they were supplied to 'add_library()' and/or\n        'set_libraries()'.  It is perfectly valid to duplicate library\n        names; the linker will be instructed to link against libraries as\n        many times as they are mentioned.\n        \"\"\"\n        self.libraries.append(libname)\n\n    def set_libraries(self, libnames):\n        \"\"\"Set the list of libraries to be included in all links driven by\n        this compiler object to 'libnames' (a list of strings).  This does\n        not affect any standard system libraries that the linker may\n        include by default.\n        \"\"\"\n        self.libraries = libnames[:]\n\n    def add_library_dir(self, dir):\n        \"\"\"Add 'dir' to the list of directories that will be searched for\n        libraries specified to 'add_library()' and 'set_libraries()'.  The\n        linker will be instructed to search for libraries in the order they\n        are supplied to 'add_library_dir()' and/or 'set_library_dirs()'.\n        \"\"\"\n        self.library_dirs.append(dir)\n\n    def set_library_dirs(self, dirs):\n        \"\"\"Set the list of library search directories to 'dirs' (a list of\n        strings).  This does not affect any standard library search path\n        that the linker may search by default.\n        \"\"\"\n        self.library_dirs = dirs[:]\n\n    def add_runtime_library_dir(self, dir):\n        \"\"\"Add 'dir' to the list of directories that will be searched for\n        shared libraries at runtime.\n        \"\"\"\n        self.runtime_library_dirs.append(dir)\n\n    def set_runtime_library_dirs(self, dirs):\n        \"\"\"Set the list of directories to search for shared libraries at\n        runtime to 'dirs' (a list of strings).  This does not affect any\n        standard search path that the runtime linker may search by\n        default.\n        \"\"\"\n        self.runtime_library_dirs = dirs[:]\n\n    def add_link_object(self, object):\n        \"\"\"Add 'object' to the list of object files (or analogues, such as\n        explicitly named library files or the output of \"resource\n        compilers\") to be included in every link driven by this compiler\n        object.\n        \"\"\"\n        self.objects.append(object)\n\n    def set_link_objects(self, objects):\n        \"\"\"Set the list of object files (or analogues) to be included in\n        every link to 'objects'.  This does not affect any standard object\n        files that the linker may include by default (such as system\n        libraries).\n        \"\"\"\n        self.objects = objects[:]\n\n    # -- Private utility methods --------------------------------------\n    # (here for the convenience of subclasses)\n\n    # Helper method to prep compiler in subclass compile() methods\n\n    def _setup_compile(self, outdir, macros, incdirs, sources, depends, extra):\n        \"\"\"Process arguments and decide which source files to compile.\"\"\"\n        outdir, macros, incdirs = self._fix_compile_args(outdir, macros, incdirs)\n\n        if extra is None:\n            extra = []\n\n        # Get the list of expected output (object) files\n        objects = self.object_filenames(sources, strip_dir=False, output_dir=outdir)\n        assert len(objects) == len(sources)\n\n        pp_opts = gen_preprocess_options(macros, incdirs)\n\n        build = {}\n        for i in range(len(sources)):\n            src = sources[i]\n            obj = objects[i]\n            ext = os.path.splitext(src)[1]\n            self.mkpath(os.path.dirname(obj))\n            build[obj] = (src, ext)\n\n        return macros, objects, extra, pp_opts, build\n\n    def _get_cc_args(self, pp_opts, debug, before):\n        # works for unixccompiler, cygwinccompiler\n        cc_args = pp_opts + ['-c']\n        if debug:\n            cc_args[:0] = ['-g']\n        if before:\n            cc_args[:0] = before\n        return cc_args\n\n    def _fix_compile_args(self, output_dir, macros, include_dirs):\n        \"\"\"Typecheck and fix-up some of the arguments to the 'compile()'\n        method, and return fixed-up values.  Specifically: if 'output_dir'\n        is None, replaces it with 'self.output_dir'; ensures that 'macros'\n        is a list, and augments it with 'self.macros'; ensures that\n        'include_dirs' is a list, and augments it with 'self.include_dirs'.\n        Guarantees that the returned values are of the correct type,\n        i.e. for 'output_dir' either string or None, and for 'macros' and\n        'include_dirs' either list or None.\n        \"\"\"\n        if output_dir is None:\n            output_dir = self.output_dir\n        elif not isinstance(output_dir, str):\n            raise TypeError(\"'output_dir' must be a string or None\")\n\n        if macros is None:\n            macros = list(self.macros)\n        elif isinstance(macros, list):\n            macros = macros + (self.macros or [])\n        else:\n            raise TypeError(\"'macros' (if supplied) must be a list of tuples\")\n\n        if include_dirs is None:\n            include_dirs = list(self.include_dirs)\n        elif isinstance(include_dirs, (list, tuple)):\n            include_dirs = list(include_dirs) + (self.include_dirs or [])\n        else:\n            raise TypeError(\"'include_dirs' (if supplied) must be a list of strings\")\n\n        # add include dirs for class\n        include_dirs += self.__class__.include_dirs\n\n        return output_dir, macros, include_dirs\n\n    def _prep_compile(self, sources, output_dir, depends=None):\n        \"\"\"Decide which source files must be recompiled.\n\n        Determine the list of object files corresponding to 'sources',\n        and figure out which ones really need to be recompiled.\n        Return a list of all object files and a dictionary telling\n        which source files can be skipped.\n        \"\"\"\n        # Get the list of expected output (object) files\n        objects = self.object_filenames(sources, output_dir=output_dir)\n        assert len(objects) == len(sources)\n\n        # Return an empty dict for the \"which source files can be skipped\"\n        # return value to preserve API compatibility.\n        return objects, {}\n\n    def _fix_object_args(self, objects, output_dir):\n        \"\"\"Typecheck and fix up some arguments supplied to various methods.\n        Specifically: ensure that 'objects' is a list; if output_dir is\n        None, replace with self.output_dir.  Return fixed versions of\n        'objects' and 'output_dir'.\n        \"\"\"\n        if not isinstance(objects, (list, tuple)):\n            raise TypeError(\"'objects' must be a list or tuple of strings\")\n        objects = list(objects)\n\n        if output_dir is None:\n            output_dir = self.output_dir\n        elif not isinstance(output_dir, str):\n            raise TypeError(\"'output_dir' must be a string or None\")\n\n        return (objects, output_dir)\n\n    def _fix_lib_args(self, libraries, library_dirs, runtime_library_dirs):\n        \"\"\"Typecheck and fix up some of the arguments supplied to the\n        'link_*' methods.  Specifically: ensure that all arguments are\n        lists, and augment them with their permanent versions\n        (eg. 'self.libraries' augments 'libraries').  Return a tuple with\n        fixed versions of all arguments.\n        \"\"\"\n        if libraries is None:\n            libraries = list(self.libraries)\n        elif isinstance(libraries, (list, tuple)):\n            libraries = list(libraries) + (self.libraries or [])\n        else:\n            raise TypeError(\"'libraries' (if supplied) must be a list of strings\")\n\n        if library_dirs is None:\n            library_dirs = list(self.library_dirs)\n        elif isinstance(library_dirs, (list, tuple)):\n            library_dirs = list(library_dirs) + (self.library_dirs or [])\n        else:\n            raise TypeError(\"'library_dirs' (if supplied) must be a list of strings\")\n\n        # add library dirs for class\n        library_dirs += self.__class__.library_dirs\n\n        if runtime_library_dirs is None:\n            runtime_library_dirs = list(self.runtime_library_dirs)\n        elif isinstance(runtime_library_dirs, (list, tuple)):\n            runtime_library_dirs = list(runtime_library_dirs) + (\n                self.runtime_library_dirs or []\n            )\n        else:\n            raise TypeError(\n                \"'runtime_library_dirs' (if supplied) must be a list of strings\"\n            )\n\n        return (libraries, library_dirs, runtime_library_dirs)\n\n    def _need_link(self, objects, output_file):\n        \"\"\"Return true if we need to relink the files listed in 'objects'\n        to recreate 'output_file'.\n        \"\"\"\n        if self.force:\n            return True\n        else:\n            if self.dry_run:\n                newer = newer_group(objects, output_file, missing='newer')\n            else:\n                newer = newer_group(objects, output_file)\n            return newer\n\n    def detect_language(self, sources):\n        \"\"\"Detect the language of a given file, or list of files. Uses\n        language_map, and language_order to do the job.\n        \"\"\"\n        if not isinstance(sources, list):\n            sources = [sources]\n        lang = None\n        index = len(self.language_order)\n        for source in sources:\n            base, ext = os.path.splitext(source)\n            extlang = self.language_map.get(ext)\n            try:\n                extindex = self.language_order.index(extlang)\n                if extindex < index:\n                    lang = extlang\n                    index = extindex\n            except ValueError:\n                pass\n        return lang\n\n    # -- Worker methods ------------------------------------------------\n    # (must be implemented by subclasses)\n\n    def preprocess(\n        self,\n        source,\n        output_file=None,\n        macros=None,\n        include_dirs=None,\n        extra_preargs=None,\n        extra_postargs=None,\n    ):\n        \"\"\"Preprocess a single C/C++ source file, named in 'source'.\n        Output will be written to file named 'output_file', or stdout if\n        'output_file' not supplied.  'macros' is a list of macro\n        definitions as for 'compile()', which will augment the macros set\n        with 'define_macro()' and 'undefine_macro()'.  'include_dirs' is a\n        list of directory names that will be added to the default list.\n\n        Raises PreprocessError on failure.\n        \"\"\"\n        pass\n\n    def compile(\n        self,\n        sources,\n        output_dir=None,\n        macros=None,\n        include_dirs=None,\n        debug=False,\n        extra_preargs=None,\n        extra_postargs=None,\n        depends=None,\n    ):\n        \"\"\"Compile one or more source files.\n\n        'sources' must be a list of filenames, most likely C/C++\n        files, but in reality anything that can be handled by a\n        particular compiler and compiler class (eg. MSVCCompiler can\n        handle resource files in 'sources').  Return a list of object\n        filenames, one per source filename in 'sources'.  Depending on\n        the implementation, not all source files will necessarily be\n        compiled, but all corresponding object filenames will be\n        returned.\n\n        If 'output_dir' is given, object files will be put under it, while\n        retaining their original path component.  That is, \"foo/bar.c\"\n        normally compiles to \"foo/bar.o\" (for a Unix implementation); if\n        'output_dir' is \"build\", then it would compile to\n        \"build/foo/bar.o\".\n\n        'macros', if given, must be a list of macro definitions.  A macro\n        definition is either a (name, value) 2-tuple or a (name,) 1-tuple.\n        The former defines a macro; if the value is None, the macro is\n        defined without an explicit value.  The 1-tuple case undefines a\n        macro.  Later definitions/redefinitions/ undefinitions take\n        precedence.\n\n        'include_dirs', if given, must be a list of strings, the\n        directories to add to the default include file search path for this\n        compilation only.\n\n        'debug' is a boolean; if true, the compiler will be instructed to\n        output debug symbols in (or alongside) the object file(s).\n\n        'extra_preargs' and 'extra_postargs' are implementation- dependent.\n        On platforms that have the notion of a command-line (e.g. Unix,\n        DOS/Windows), they are most likely lists of strings: extra\n        command-line arguments to prepend/append to the compiler command\n        line.  On other platforms, consult the implementation class\n        documentation.  In any event, they are intended as an escape hatch\n        for those occasions when the abstract compiler framework doesn't\n        cut the mustard.\n\n        'depends', if given, is a list of filenames that all targets\n        depend on.  If a source file is older than any file in\n        depends, then the source file will be recompiled.  This\n        supports dependency tracking, but only at a coarse\n        granularity.\n\n        Raises CompileError on failure.\n        \"\"\"\n        # A concrete compiler class can either override this method\n        # entirely or implement _compile().\n        macros, objects, extra_postargs, pp_opts, build = self._setup_compile(\n            output_dir, macros, include_dirs, sources, depends, extra_postargs\n        )\n        cc_args = self._get_cc_args(pp_opts, debug, extra_preargs)\n\n        for obj in objects:\n            try:\n                src, ext = build[obj]\n            except KeyError:\n                continue\n            self._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)\n\n        # Return *all* object filenames, not just the ones we just built.\n        return objects\n\n    def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):\n        \"\"\"Compile 'src' to product 'obj'.\"\"\"\n        # A concrete compiler class that does not override compile()\n        # should implement _compile().\n        pass\n\n    def create_static_lib(\n        self, objects, output_libname, output_dir=None, debug=False, target_lang=None\n    ):\n        \"\"\"Link a bunch of stuff together to create a static library file.\n        The \"bunch of stuff\" consists of the list of object files supplied\n        as 'objects', the extra object files supplied to\n        'add_link_object()' and/or 'set_link_objects()', the libraries\n        supplied to 'add_library()' and/or 'set_libraries()', and the\n        libraries supplied as 'libraries' (if any).\n\n        'output_libname' should be a library name, not a filename; the\n        filename will be inferred from the library name.  'output_dir' is\n        the directory where the library file will be put.\n\n        'debug' is a boolean; if true, debugging information will be\n        included in the library (note that on most platforms, it is the\n        compile step where this matters: the 'debug' flag is included here\n        just for consistency).\n\n        'target_lang' is the target language for which the given objects\n        are being compiled. This allows specific linkage time treatment of\n        certain languages.\n\n        Raises LibError on failure.\n        \"\"\"\n        pass\n\n    # values for target_desc parameter in link()\n    SHARED_OBJECT = \"shared_object\"\n    SHARED_LIBRARY = \"shared_library\"\n    EXECUTABLE = \"executable\"\n\n    def link(\n        self,\n        target_desc,\n        objects,\n        output_filename,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        export_symbols=None,\n        debug=False,\n        extra_preargs=None,\n        extra_postargs=None,\n        build_temp=None,\n        target_lang=None,\n    ):\n        \"\"\"Link a bunch of stuff together to create an executable or\n        shared library file.\n\n        The \"bunch of stuff\" consists of the list of object files supplied\n        as 'objects'.  'output_filename' should be a filename.  If\n        'output_dir' is supplied, 'output_filename' is relative to it\n        (i.e. 'output_filename' can provide directory components if\n        needed).\n\n        'libraries' is a list of libraries to link against.  These are\n        library names, not filenames, since they're translated into\n        filenames in a platform-specific way (eg. \"foo\" becomes \"libfoo.a\"\n        on Unix and \"foo.lib\" on DOS/Windows).  However, they can include a\n        directory component, which means the linker will look in that\n        specific directory rather than searching all the normal locations.\n\n        'library_dirs', if supplied, should be a list of directories to\n        search for libraries that were specified as bare library names\n        (ie. no directory component).  These are on top of the system\n        default and those supplied to 'add_library_dir()' and/or\n        'set_library_dirs()'.  'runtime_library_dirs' is a list of\n        directories that will be embedded into the shared library and used\n        to search for other shared libraries that *it* depends on at\n        run-time.  (This may only be relevant on Unix.)\n\n        'export_symbols' is a list of symbols that the shared library will\n        export.  (This appears to be relevant only on Windows.)\n\n        'debug' is as for 'compile()' and 'create_static_lib()', with the\n        slight distinction that it actually matters on most platforms (as\n        opposed to 'create_static_lib()', which includes a 'debug' flag\n        mostly for form's sake).\n\n        'extra_preargs' and 'extra_postargs' are as for 'compile()' (except\n        of course that they supply command-line arguments for the\n        particular linker being used).\n\n        'target_lang' is the target language for which the given objects\n        are being compiled. This allows specific linkage time treatment of\n        certain languages.\n\n        Raises LinkError on failure.\n        \"\"\"\n        raise NotImplementedError\n\n    # Old 'link_*()' methods, rewritten to use the new 'link()' method.\n\n    def link_shared_lib(\n        self,\n        objects,\n        output_libname,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        export_symbols=None,\n        debug=False,\n        extra_preargs=None,\n        extra_postargs=None,\n        build_temp=None,\n        target_lang=None,\n    ):\n        self.link(\n            CCompiler.SHARED_LIBRARY,\n            objects,\n            self.library_filename(output_libname, lib_type='shared'),\n            output_dir,\n            libraries,\n            library_dirs,\n            runtime_library_dirs,\n            export_symbols,\n            debug,\n            extra_preargs,\n            extra_postargs,\n            build_temp,\n            target_lang,\n        )\n\n    def link_shared_object(\n        self,\n        objects,\n        output_filename,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        export_symbols=None,\n        debug=False,\n        extra_preargs=None,\n        extra_postargs=None,\n        build_temp=None,\n        target_lang=None,\n    ):\n        self.link(\n            CCompiler.SHARED_OBJECT,\n            objects,\n            output_filename,\n            output_dir,\n            libraries,\n            library_dirs,\n            runtime_library_dirs,\n            export_symbols,\n            debug,\n            extra_preargs,\n            extra_postargs,\n            build_temp,\n            target_lang,\n        )\n\n    def link_executable(\n        self,\n        objects,\n        output_progname,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        debug=False,\n        extra_preargs=None,\n        extra_postargs=None,\n        target_lang=None,\n    ):\n        self.link(\n            CCompiler.EXECUTABLE,\n            objects,\n            self.executable_filename(output_progname),\n            output_dir,\n            libraries,\n            library_dirs,\n            runtime_library_dirs,\n            None,\n            debug,\n            extra_preargs,\n            extra_postargs,\n            None,\n            target_lang,\n        )\n\n    # -- Miscellaneous methods -----------------------------------------\n    # These are all used by the 'gen_lib_options() function; there is\n    # no appropriate default implementation so subclasses should\n    # implement all of these.\n\n    def library_dir_option(self, dir):\n        \"\"\"Return the compiler option to add 'dir' to the list of\n        directories searched for libraries.\n        \"\"\"\n        raise NotImplementedError\n\n    def runtime_library_dir_option(self, dir):\n        \"\"\"Return the compiler option to add 'dir' to the list of\n        directories searched for runtime libraries.\n        \"\"\"\n        raise NotImplementedError\n\n    def library_option(self, lib):\n        \"\"\"Return the compiler option to add 'lib' to the list of libraries\n        linked into the shared library or executable.\n        \"\"\"\n        raise NotImplementedError\n\n    def has_function(  # noqa: C901\n        self,\n        funcname,\n        includes=None,\n        include_dirs=None,\n        libraries=None,\n        library_dirs=None,\n    ):\n        \"\"\"Return a boolean indicating whether funcname is provided as\n        a symbol on the current platform.  The optional arguments can\n        be used to augment the compilation environment.\n\n        The libraries argument is a list of flags to be passed to the\n        linker to make additional symbol definitions available for\n        linking.\n\n        The includes and include_dirs arguments are deprecated.\n        Usually, supplying include files with function declarations\n        will cause function detection to fail even in cases where the\n        symbol is available for linking.\n\n        \"\"\"\n        # this can't be included at module scope because it tries to\n        # import math which might not be available at that point - maybe\n        # the necessary logic should just be inlined?\n        import tempfile\n\n        if includes is None:\n            includes = []\n        else:\n            warnings.warn(\"includes is deprecated\", DeprecationWarning)\n        if include_dirs is None:\n            include_dirs = []\n        else:\n            warnings.warn(\"include_dirs is deprecated\", DeprecationWarning)\n        if libraries is None:\n            libraries = []\n        if library_dirs is None:\n            library_dirs = []\n        fd, fname = tempfile.mkstemp(\".c\", funcname, text=True)\n        with os.fdopen(fd, \"w\", encoding='utf-8') as f:\n            for incl in includes:\n                f.write(f\"\"\"#include \"{incl}\"\\n\"\"\")\n            if not includes:\n                # Use \"char func(void);\" as the prototype to follow\n                # what autoconf does.  This prototype does not match\n                # any well-known function the compiler might recognize\n                # as a builtin, so this ends up as a true link test.\n                # Without a fake prototype, the test would need to\n                # know the exact argument types, and the has_function\n                # interface does not provide that level of information.\n                f.write(\n                    f\"\"\"\\\n#ifdef __cplusplus\nextern \"C\"\n#endif\nchar {funcname}(void);\n\"\"\"\n                )\n            f.write(\n                f\"\"\"\\\nint main (int argc, char **argv) {{\n    {funcname}();\n    return 0;\n}}\n\"\"\"\n            )\n\n        try:\n            objects = self.compile([fname], include_dirs=include_dirs)\n        except CompileError:\n            return False\n        finally:\n            os.remove(fname)\n\n        try:\n            self.link_executable(\n                objects, \"a.out\", libraries=libraries, library_dirs=library_dirs\n            )\n        except (LinkError, TypeError):\n            return False\n        else:\n            os.remove(\n                self.executable_filename(\"a.out\", output_dir=self.output_dir or '')\n            )\n        finally:\n            for fn in objects:\n                os.remove(fn)\n        return True\n\n    def find_library_file(self, dirs, lib, debug=False):\n        \"\"\"Search the specified list of directories for a static or shared\n        library file 'lib' and return the full path to that file.  If\n        'debug' true, look for a debugging version (if that makes sense on\n        the current platform).  Return None if 'lib' wasn't found in any of\n        the specified directories.\n        \"\"\"\n        raise NotImplementedError\n\n    # -- Filename generation methods -----------------------------------\n\n    # The default implementation of the filename generating methods are\n    # prejudiced towards the Unix/DOS/Windows view of the world:\n    #   * object files are named by replacing the source file extension\n    #     (eg. .c/.cpp -> .o/.obj)\n    #   * library files (shared or static) are named by plugging the\n    #     library name and extension into a format string, eg.\n    #     \"lib%s.%s\" % (lib_name, \".a\") for Unix static libraries\n    #   * executables are named by appending an extension (possibly\n    #     empty) to the program name: eg. progname + \".exe\" for\n    #     Windows\n    #\n    # To reduce redundant code, these methods expect to find\n    # several attributes in the current object (presumably defined\n    # as class attributes):\n    #   * src_extensions -\n    #     list of C/C++ source file extensions, eg. ['.c', '.cpp']\n    #   * obj_extension -\n    #     object file extension, eg. '.o' or '.obj'\n    #   * static_lib_extension -\n    #     extension for static library files, eg. '.a' or '.lib'\n    #   * shared_lib_extension -\n    #     extension for shared library/object files, eg. '.so', '.dll'\n    #   * static_lib_format -\n    #     format string for generating static library filenames,\n    #     eg. 'lib%s.%s' or '%s.%s'\n    #   * shared_lib_format\n    #     format string for generating shared library filenames\n    #     (probably same as static_lib_format, since the extension\n    #     is one of the intended parameters to the format string)\n    #   * exe_extension -\n    #     extension for executable files, eg. '' or '.exe'\n\n    def object_filenames(self, source_filenames, strip_dir=False, output_dir=''):\n        if output_dir is None:\n            output_dir = ''\n        return list(\n            self._make_out_path(output_dir, strip_dir, src_name)\n            for src_name in source_filenames\n        )\n\n    @property\n    def out_extensions(self):\n        return dict.fromkeys(self.src_extensions, self.obj_extension)\n\n    def _make_out_path(self, output_dir, strip_dir, src_name):\n        return self._make_out_path_exts(\n            output_dir, strip_dir, src_name, self.out_extensions\n        )\n\n    @classmethod\n    def _make_out_path_exts(cls, output_dir, strip_dir, src_name, extensions):\n        r\"\"\"\n        >>> exts = {'.c': '.o'}\n        >>> CCompiler._make_out_path_exts('.', False, '/foo/bar.c', exts).replace('\\\\', '/')\n        './foo/bar.o'\n        >>> CCompiler._make_out_path_exts('.', True, '/foo/bar.c', exts).replace('\\\\', '/')\n        './bar.o'\n        \"\"\"\n        src = pathlib.PurePath(src_name)\n        # Ensure base is relative to honor output_dir (python/cpython#37775).\n        base = cls._make_relative(src)\n        try:\n            new_ext = extensions[src.suffix]\n        except LookupError:\n            raise UnknownFileError(f\"unknown file type '{src.suffix}' (from '{src}')\")\n        if strip_dir:\n            base = pathlib.PurePath(base.name)\n        return os.path.join(output_dir, base.with_suffix(new_ext))\n\n    @staticmethod\n    def _make_relative(base: pathlib.Path):\n        return base.relative_to(base.anchor)\n\n    def shared_object_filename(self, basename, strip_dir=False, output_dir=''):\n        assert output_dir is not None\n        if strip_dir:\n            basename = os.path.basename(basename)\n        return os.path.join(output_dir, basename + self.shared_lib_extension)\n\n    def executable_filename(self, basename, strip_dir=False, output_dir=''):\n        assert output_dir is not None\n        if strip_dir:\n            basename = os.path.basename(basename)\n        return os.path.join(output_dir, basename + (self.exe_extension or ''))\n\n    def library_filename(\n        self,\n        libname,\n        lib_type='static',\n        strip_dir=False,\n        output_dir='',  # or 'shared'\n    ):\n        assert output_dir is not None\n        expected = '\"static\", \"shared\", \"dylib\", \"xcode_stub\"'\n        if lib_type not in eval(expected):\n            raise ValueError(f\"'lib_type' must be {expected}\")\n        fmt = getattr(self, lib_type + \"_lib_format\")\n        ext = getattr(self, lib_type + \"_lib_extension\")\n\n        dir, base = os.path.split(libname)\n        filename = fmt % (base, ext)\n        if strip_dir:\n            dir = ''\n\n        return os.path.join(output_dir, dir, filename)\n\n    # -- Utility methods -----------------------------------------------\n\n    def announce(self, msg, level=1):\n        log.debug(msg)\n\n    def debug_print(self, msg):\n        from distutils.debug import DEBUG\n\n        if DEBUG:\n            print(msg)\n\n    def warn(self, msg):\n        sys.stderr.write(f\"warning: {msg}\\n\")\n\n    def execute(self, func, args, msg=None, level=1):\n        execute(func, args, msg, self.dry_run)\n\n    def spawn(self, cmd, **kwargs):\n        spawn(cmd, dry_run=self.dry_run, **kwargs)\n\n    def move_file(self, src, dst):\n        return move_file(src, dst, dry_run=self.dry_run)\n\n    def mkpath(self, name, mode=0o777):\n        mkpath(name, mode, dry_run=self.dry_run)\n\n\n# Map a sys.platform/os.name ('posix', 'nt') to the default compiler\n# type for that platform. Keys are interpreted as re match\n# patterns. Order is important; platform mappings are preferred over\n# OS names.\n_default_compilers = (\n    # Platform string mappings\n    # on a cygwin built python we can use gcc like an ordinary UNIXish\n    # compiler\n    ('cygwin.*', 'unix'),\n    ('zos', 'zos'),\n    # OS name mappings\n    ('posix', 'unix'),\n    ('nt', 'msvc'),\n)\n\n\ndef get_default_compiler(osname=None, platform=None):\n    \"\"\"Determine the default compiler to use for the given platform.\n\n    osname should be one of the standard Python OS names (i.e. the\n    ones returned by os.name) and platform the common value\n    returned by sys.platform for the platform in question.\n\n    The default values are os.name and sys.platform in case the\n    parameters are not given.\n    \"\"\"\n    if osname is None:\n        osname = os.name\n    if platform is None:\n        platform = sys.platform\n    # Mingw is a special case where sys.platform is 'win32' but we\n    # want to use the 'mingw32' compiler, so check it first\n    if is_mingw():\n        return 'mingw32'\n    for pattern, compiler in _default_compilers:\n        if (\n            re.match(pattern, platform) is not None\n            or re.match(pattern, osname) is not None\n        ):\n            return compiler\n    # Default to Unix compiler\n    return 'unix'\n\n\n# Map compiler types to (module_name, class_name) pairs -- ie. where to\n# find the code that implements an interface to this compiler.  (The module\n# is assumed to be in the 'distutils' package.)\ncompiler_class = {\n    'unix': ('unixccompiler', 'UnixCCompiler', \"standard UNIX-style compiler\"),\n    'msvc': ('_msvccompiler', 'MSVCCompiler', \"Microsoft Visual C++\"),\n    'cygwin': (\n        'cygwinccompiler',\n        'CygwinCCompiler',\n        \"Cygwin port of GNU C Compiler for Win32\",\n    ),\n    'mingw32': (\n        'cygwinccompiler',\n        'Mingw32CCompiler',\n        \"Mingw32 port of GNU C Compiler for Win32\",\n    ),\n    'bcpp': ('bcppcompiler', 'BCPPCompiler', \"Borland C++ Compiler\"),\n    'zos': ('zosccompiler', 'zOSCCompiler', 'IBM XL C/C++ Compilers'),\n}\n\n\ndef show_compilers():\n    \"\"\"Print list of available compilers (used by the \"--help-compiler\"\n    options to \"build\", \"build_ext\", \"build_clib\").\n    \"\"\"\n    # XXX this \"knows\" that the compiler option it's describing is\n    # \"--compiler\", which just happens to be the case for the three\n    # commands that use it.\n    from distutils.fancy_getopt import FancyGetopt\n\n    compilers = sorted(\n        (\"compiler=\" + compiler, None, compiler_class[compiler][2])\n        for compiler in compiler_class.keys()\n    )\n    pretty_printer = FancyGetopt(compilers)\n    pretty_printer.print_help(\"List of available compilers:\")\n\n\ndef new_compiler(plat=None, compiler=None, verbose=False, dry_run=False, force=False):\n    \"\"\"Generate an instance of some CCompiler subclass for the supplied\n    platform/compiler combination.  'plat' defaults to 'os.name'\n    (eg. 'posix', 'nt'), and 'compiler' defaults to the default compiler\n    for that platform.  Currently only 'posix' and 'nt' are supported, and\n    the default compilers are \"traditional Unix interface\" (UnixCCompiler\n    class) and Visual C++ (MSVCCompiler class).  Note that it's perfectly\n    possible to ask for a Unix compiler object under Windows, and a\n    Microsoft compiler object under Unix -- if you supply a value for\n    'compiler', 'plat' is ignored.\n    \"\"\"\n    if plat is None:\n        plat = os.name\n\n    try:\n        if compiler is None:\n            compiler = get_default_compiler(plat)\n\n        (module_name, class_name, long_description) = compiler_class[compiler]\n    except KeyError:\n        msg = f\"don't know how to compile C/C++ code on platform '{plat}'\"\n        if compiler is not None:\n            msg = msg + f\" with '{compiler}' compiler\"\n        raise DistutilsPlatformError(msg)\n\n    try:\n        module_name = \"distutils.\" + module_name\n        __import__(module_name)\n        module = sys.modules[module_name]\n        klass = vars(module)[class_name]\n    except ImportError:\n        raise DistutilsModuleError(\n            f\"can't compile C/C++ code: unable to load module '{module_name}'\"\n        )\n    except KeyError:\n        raise DistutilsModuleError(\n            f\"can't compile C/C++ code: unable to find class '{class_name}' \"\n            f\"in module '{module_name}'\"\n        )\n\n    # XXX The None is necessary to preserve backwards compatibility\n    # with classes that expect verbose to be the first positional\n    # argument.\n    return klass(None, dry_run, force)\n\n\ndef gen_preprocess_options(macros, include_dirs):\n    \"\"\"Generate C pre-processor options (-D, -U, -I) as used by at least\n    two types of compilers: the typical Unix compiler and Visual C++.\n    'macros' is the usual thing, a list of 1- or 2-tuples, where (name,)\n    means undefine (-U) macro 'name', and (name,value) means define (-D)\n    macro 'name' to 'value'.  'include_dirs' is just a list of directory\n    names to be added to the header file search path (-I).  Returns a list\n    of command-line options suitable for either Unix compilers or Visual\n    C++.\n    \"\"\"\n    # XXX it would be nice (mainly aesthetic, and so we don't generate\n    # stupid-looking command lines) to go over 'macros' and eliminate\n    # redundant definitions/undefinitions (ie. ensure that only the\n    # latest mention of a particular macro winds up on the command\n    # line).  I don't think it's essential, though, since most (all?)\n    # Unix C compilers only pay attention to the latest -D or -U\n    # mention of a macro on their command line.  Similar situation for\n    # 'include_dirs'.  I'm punting on both for now.  Anyways, weeding out\n    # redundancies like this should probably be the province of\n    # CCompiler, since the data structures used are inherited from it\n    # and therefore common to all CCompiler classes.\n    pp_opts = []\n    for macro in macros:\n        if not (isinstance(macro, tuple) and 1 <= len(macro) <= 2):\n            raise TypeError(\n                f\"bad macro definition '{macro}': \"\n                \"each element of 'macros' list must be a 1- or 2-tuple\"\n            )\n\n        if len(macro) == 1:  # undefine this macro\n            pp_opts.append(f\"-U{macro[0]}\")\n        elif len(macro) == 2:\n            if macro[1] is None:  # define with no explicit value\n                pp_opts.append(f\"-D{macro[0]}\")\n            else:\n                # XXX *don't* need to be clever about quoting the\n                # macro value here, because we're going to avoid the\n                # shell at all costs when we spawn the command!\n                pp_opts.append(\"-D{}={}\".format(*macro))\n\n    pp_opts.extend(f\"-I{dir}\" for dir in include_dirs)\n    return pp_opts\n\n\ndef gen_lib_options(compiler, library_dirs, runtime_library_dirs, libraries):\n    \"\"\"Generate linker options for searching library directories and\n    linking with specific libraries.  'libraries' and 'library_dirs' are,\n    respectively, lists of library names (not filenames!) and search\n    directories.  Returns a list of command-line options suitable for use\n    with some compiler (depending on the two format strings passed in).\n    \"\"\"\n    lib_opts = [compiler.library_dir_option(dir) for dir in library_dirs]\n\n    for dir in runtime_library_dirs:\n        lib_opts.extend(always_iterable(compiler.runtime_library_dir_option(dir)))\n\n    # XXX it's important that we *not* remove redundant library mentions!\n    # sometimes you really do have to say \"-lfoo -lbar -lfoo\" in order to\n    # resolve all symbols.  I just hope we never have to say \"-lfoo obj.o\n    # -lbar\" to get things to work -- that's certainly a possibility, but a\n    # pretty nasty way to arrange your C code.\n\n    for lib in libraries:\n        (lib_dir, lib_name) = os.path.split(lib)\n        if lib_dir:\n            lib_file = compiler.find_library_file([lib_dir], lib_name)\n            if lib_file:\n                lib_opts.append(lib_file)\n            else:\n                compiler.warn(\n                    f\"no library file corresponding to '{lib}' found (skipping)\"\n                )\n        else:\n            lib_opts.append(compiler.library_option(lib))\n    return lib_opts\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/cmd.py","size":18668,"sha1":"173bf746d13e8a78a58d0799788c2e261aa09f52","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.cmd\n\nProvides the Command class, the base class for the command classes\nin the distutils.command package.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport os\nimport re\nimport sys\nfrom collections.abc import Callable\nfrom typing import Any, ClassVar, TypeVar, overload\n\nfrom . import _modified, archive_util, dir_util, file_util, util\nfrom ._log import log\nfrom .errors import DistutilsOptionError\n\n_CommandT = TypeVar(\"_CommandT\", bound=\"Command\")\n\n\nclass Command:\n    \"\"\"Abstract base class for defining command classes, the \"worker bees\"\n    of the Distutils.  A useful analogy for command classes is to think of\n    them as subroutines with local variables called \"options\".  The options\n    are \"declared\" in 'initialize_options()' and \"defined\" (given their\n    final values, aka \"finalized\") in 'finalize_options()', both of which\n    must be defined by every command class.  The distinction between the\n    two is necessary because option values might come from the outside\n    world (command line, config file, ...), and any options dependent on\n    other options must be computed *after* these outside influences have\n    been processed -- hence 'finalize_options()'.  The \"body\" of the\n    subroutine, where it does all its work based on the values of its\n    options, is the 'run()' method, which must also be implemented by every\n    command class.\n    \"\"\"\n\n    # 'sub_commands' formalizes the notion of a \"family\" of commands,\n    # eg. \"install\" as the parent with sub-commands \"install_lib\",\n    # \"install_headers\", etc.  The parent of a family of commands\n    # defines 'sub_commands' as a class attribute; it's a list of\n    #    (command_name : string, predicate : unbound_method | string | None)\n    # tuples, where 'predicate' is a method of the parent command that\n    # determines whether the corresponding command is applicable in the\n    # current situation.  (Eg. we \"install_headers\" is only applicable if\n    # we have any C header files to install.)  If 'predicate' is None,\n    # that command is always applicable.\n    #\n    # 'sub_commands' is usually defined at the *end* of a class, because\n    # predicates can be unbound methods, so they must already have been\n    # defined.  The canonical example is the \"install\" command.\n    sub_commands: ClassVar[  # Any to work around variance issues\n        list[tuple[str, Callable[[Any], bool] | None]]\n    ] = []\n\n    user_options: ClassVar[\n        # Specifying both because list is invariant. Avoids mypy override assignment issues\n        list[tuple[str, str, str]] | list[tuple[str, str | None, str]]\n    ] = []\n\n    # -- Creation/initialization methods -------------------------------\n\n    def __init__(self, dist):\n        \"\"\"Create and initialize a new Command object.  Most importantly,\n        invokes the 'initialize_options()' method, which is the real\n        initializer and depends on the actual command being\n        instantiated.\n        \"\"\"\n        # late import because of mutual dependence between these classes\n        from distutils.dist import Distribution\n\n        if not isinstance(dist, Distribution):\n            raise TypeError(\"dist must be a Distribution instance\")\n        if self.__class__ is Command:\n            raise RuntimeError(\"Command is an abstract class\")\n\n        self.distribution = dist\n        self.initialize_options()\n\n        # Per-command versions of the global flags, so that the user can\n        # customize Distutils' behaviour command-by-command and let some\n        # commands fall back on the Distribution's behaviour.  None means\n        # \"not defined, check self.distribution's copy\", while 0 or 1 mean\n        # false and true (duh).  Note that this means figuring out the real\n        # value of each flag is a touch complicated -- hence \"self._dry_run\"\n        # will be handled by __getattr__, below.\n        # XXX This needs to be fixed.\n        self._dry_run = None\n\n        # verbose is largely ignored, but needs to be set for\n        # backwards compatibility (I think)?\n        self.verbose = dist.verbose\n\n        # Some commands define a 'self.force' option to ignore file\n        # timestamps, but methods defined *here* assume that\n        # 'self.force' exists for all commands.  So define it here\n        # just to be safe.\n        self.force = None\n\n        # The 'help' flag is just used for command-line parsing, so\n        # none of that complicated bureaucracy is needed.\n        self.help = False\n\n        # 'finalized' records whether or not 'finalize_options()' has been\n        # called.  'finalize_options()' itself should not pay attention to\n        # this flag: it is the business of 'ensure_finalized()', which\n        # always calls 'finalize_options()', to respect/update it.\n        self.finalized = False\n\n    # XXX A more explicit way to customize dry_run would be better.\n    def __getattr__(self, attr):\n        if attr == 'dry_run':\n            myval = getattr(self, \"_\" + attr)\n            if myval is None:\n                return getattr(self.distribution, attr)\n            else:\n                return myval\n        else:\n            raise AttributeError(attr)\n\n    def ensure_finalized(self):\n        if not self.finalized:\n            self.finalize_options()\n        self.finalized = True\n\n    # Subclasses must define:\n    #   initialize_options()\n    #     provide default values for all options; may be customized by\n    #     setup script, by options from config file(s), or by command-line\n    #     options\n    #   finalize_options()\n    #     decide on the final values for all options; this is called\n    #     after all possible intervention from the outside world\n    #     (command-line, option file, etc.) has been processed\n    #   run()\n    #     run the command: do whatever it is we're here to do,\n    #     controlled by the command's various option values\n\n    def initialize_options(self):\n        \"\"\"Set default values for all the options that this command\n        supports.  Note that these defaults may be overridden by other\n        commands, by the setup script, by config files, or by the\n        command-line.  Thus, this is not the place to code dependencies\n        between options; generally, 'initialize_options()' implementations\n        are just a bunch of \"self.foo = None\" assignments.\n\n        This method must be implemented by all command classes.\n        \"\"\"\n        raise RuntimeError(\n            f\"abstract method -- subclass {self.__class__} must override\"\n        )\n\n    def finalize_options(self):\n        \"\"\"Set final values for all the options that this command supports.\n        This is always called as late as possible, ie.  after any option\n        assignments from the command-line or from other commands have been\n        done.  Thus, this is the place to code option dependencies: if\n        'foo' depends on 'bar', then it is safe to set 'foo' from 'bar' as\n        long as 'foo' still has the same value it was assigned in\n        'initialize_options()'.\n\n        This method must be implemented by all command classes.\n        \"\"\"\n        raise RuntimeError(\n            f\"abstract method -- subclass {self.__class__} must override\"\n        )\n\n    def dump_options(self, header=None, indent=\"\"):\n        from distutils.fancy_getopt import longopt_xlate\n\n        if header is None:\n            header = f\"command options for '{self.get_command_name()}':\"\n        self.announce(indent + header, level=logging.INFO)\n        indent = indent + \"  \"\n        for option, _, _ in self.user_options:\n            option = option.translate(longopt_xlate)\n            if option[-1] == \"=\":\n                option = option[:-1]\n            value = getattr(self, option)\n            self.announce(indent + f\"{option} = {value}\", level=logging.INFO)\n\n    def run(self):\n        \"\"\"A command's raison d'etre: carry out the action it exists to\n        perform, controlled by the options initialized in\n        'initialize_options()', customized by other commands, the setup\n        script, the command-line, and config files, and finalized in\n        'finalize_options()'.  All terminal output and filesystem\n        interaction should be done by 'run()'.\n\n        This method must be implemented by all command classes.\n        \"\"\"\n        raise RuntimeError(\n            f\"abstract method -- subclass {self.__class__} must override\"\n        )\n\n    def announce(self, msg, level=logging.DEBUG):\n        log.log(level, msg)\n\n    def debug_print(self, msg):\n        \"\"\"Print 'msg' to stdout if the global DEBUG (taken from the\n        DISTUTILS_DEBUG environment variable) flag is true.\n        \"\"\"\n        from distutils.debug import DEBUG\n\n        if DEBUG:\n            print(msg)\n            sys.stdout.flush()\n\n    # -- Option validation methods -------------------------------------\n    # (these are very handy in writing the 'finalize_options()' method)\n    #\n    # NB. the general philosophy here is to ensure that a particular option\n    # value meets certain type and value constraints.  If not, we try to\n    # force it into conformance (eg. if we expect a list but have a string,\n    # split the string on comma and/or whitespace).  If we can't force the\n    # option into conformance, raise DistutilsOptionError.  Thus, command\n    # classes need do nothing more than (eg.)\n    #   self.ensure_string_list('foo')\n    # and they can be guaranteed that thereafter, self.foo will be\n    # a list of strings.\n\n    def _ensure_stringlike(self, option, what, default=None):\n        val = getattr(self, option)\n        if val is None:\n            setattr(self, option, default)\n            return default\n        elif not isinstance(val, str):\n            raise DistutilsOptionError(f\"'{option}' must be a {what} (got `{val}`)\")\n        return val\n\n    def ensure_string(self, option, default=None):\n        \"\"\"Ensure that 'option' is a string; if not defined, set it to\n        'default'.\n        \"\"\"\n        self._ensure_stringlike(option, \"string\", default)\n\n    def ensure_string_list(self, option):\n        r\"\"\"Ensure that 'option' is a list of strings.  If 'option' is\n        currently a string, we split it either on /,\\s*/ or /\\s+/, so\n        \"foo bar baz\", \"foo,bar,baz\", and \"foo,   bar baz\" all become\n        [\"foo\", \"bar\", \"baz\"].\n        \"\"\"\n        val = getattr(self, option)\n        if val is None:\n            return\n        elif isinstance(val, str):\n            setattr(self, option, re.split(r',\\s*|\\s+', val))\n        else:\n            if isinstance(val, list):\n                ok = all(isinstance(v, str) for v in val)\n            else:\n                ok = False\n            if not ok:\n                raise DistutilsOptionError(\n                    f\"'{option}' must be a list of strings (got {val!r})\"\n                )\n\n    def _ensure_tested_string(self, option, tester, what, error_fmt, default=None):\n        val = self._ensure_stringlike(option, what, default)\n        if val is not None and not tester(val):\n            raise DistutilsOptionError(\n                (\"error in '%s' option: \" + error_fmt) % (option, val)\n            )\n\n    def ensure_filename(self, option):\n        \"\"\"Ensure that 'option' is the name of an existing file.\"\"\"\n        self._ensure_tested_string(\n            option, os.path.isfile, \"filename\", \"'%s' does not exist or is not a file\"\n        )\n\n    def ensure_dirname(self, option):\n        self._ensure_tested_string(\n            option,\n            os.path.isdir,\n            \"directory name\",\n            \"'%s' does not exist or is not a directory\",\n        )\n\n    # -- Convenience methods for commands ------------------------------\n\n    def get_command_name(self):\n        if hasattr(self, 'command_name'):\n            return self.command_name\n        else:\n            return self.__class__.__name__\n\n    def set_undefined_options(self, src_cmd, *option_pairs):\n        \"\"\"Set the values of any \"undefined\" options from corresponding\n        option values in some other command object.  \"Undefined\" here means\n        \"is None\", which is the convention used to indicate that an option\n        has not been changed between 'initialize_options()' and\n        'finalize_options()'.  Usually called from 'finalize_options()' for\n        options that depend on some other command rather than another\n        option of the same command.  'src_cmd' is the other command from\n        which option values will be taken (a command object will be created\n        for it if necessary); the remaining arguments are\n        '(src_option,dst_option)' tuples which mean \"take the value of\n        'src_option' in the 'src_cmd' command object, and copy it to\n        'dst_option' in the current command object\".\n        \"\"\"\n        # Option_pairs: list of (src_option, dst_option) tuples\n        src_cmd_obj = self.distribution.get_command_obj(src_cmd)\n        src_cmd_obj.ensure_finalized()\n        for src_option, dst_option in option_pairs:\n            if getattr(self, dst_option) is None:\n                setattr(self, dst_option, getattr(src_cmd_obj, src_option))\n\n    def get_finalized_command(self, command, create=True):\n        \"\"\"Wrapper around Distribution's 'get_command_obj()' method: find\n        (create if necessary and 'create' is true) the command object for\n        'command', call its 'ensure_finalized()' method, and return the\n        finalized command object.\n        \"\"\"\n        cmd_obj = self.distribution.get_command_obj(command, create)\n        cmd_obj.ensure_finalized()\n        return cmd_obj\n\n    # XXX rename to 'get_reinitialized_command()'? (should do the\n    # same in dist.py, if so)\n    @overload\n    def reinitialize_command(\n        self, command: str, reinit_subcommands: bool = False\n    ) -> Command: ...\n    @overload\n    def reinitialize_command(\n        self, command: _CommandT, reinit_subcommands: bool = False\n    ) -> _CommandT: ...\n    def reinitialize_command(\n        self, command: str | Command, reinit_subcommands=False\n    ) -> Command:\n        return self.distribution.reinitialize_command(command, reinit_subcommands)\n\n    def run_command(self, command):\n        \"\"\"Run some other command: uses the 'run_command()' method of\n        Distribution, which creates and finalizes the command object if\n        necessary and then invokes its 'run()' method.\n        \"\"\"\n        self.distribution.run_command(command)\n\n    def get_sub_commands(self):\n        \"\"\"Determine the sub-commands that are relevant in the current\n        distribution (ie., that need to be run).  This is based on the\n        'sub_commands' class attribute: each tuple in that list may include\n        a method that we call to determine if the subcommand needs to be\n        run for the current distribution.  Return a list of command names.\n        \"\"\"\n        commands = []\n        for cmd_name, method in self.sub_commands:\n            if method is None or method(self):\n                commands.append(cmd_name)\n        return commands\n\n    # -- External world manipulation -----------------------------------\n\n    def warn(self, msg):\n        log.warning(\"warning: %s: %s\\n\", self.get_command_name(), msg)\n\n    def execute(self, func, args, msg=None, level=1):\n        util.execute(func, args, msg, dry_run=self.dry_run)\n\n    def mkpath(self, name, mode=0o777):\n        dir_util.mkpath(name, mode, dry_run=self.dry_run)\n\n    def copy_file(\n        self,\n        infile,\n        outfile,\n        preserve_mode=True,\n        preserve_times=True,\n        link=None,\n        level=1,\n    ):\n        \"\"\"Copy a file respecting verbose, dry-run and force flags.  (The\n        former two default to whatever is in the Distribution object, and\n        the latter defaults to false for commands that don't define it.)\"\"\"\n        return file_util.copy_file(\n            infile,\n            outfile,\n            preserve_mode,\n            preserve_times,\n            not self.force,\n            link,\n            dry_run=self.dry_run,\n        )\n\n    def copy_tree(\n        self,\n        infile,\n        outfile,\n        preserve_mode=True,\n        preserve_times=True,\n        preserve_symlinks=False,\n        level=1,\n    ):\n        \"\"\"Copy an entire directory tree respecting verbose, dry-run,\n        and force flags.\n        \"\"\"\n        return dir_util.copy_tree(\n            infile,\n            outfile,\n            preserve_mode,\n            preserve_times,\n            preserve_symlinks,\n            not self.force,\n            dry_run=self.dry_run,\n        )\n\n    def move_file(self, src, dst, level=1):\n        \"\"\"Move a file respecting dry-run flag.\"\"\"\n        return file_util.move_file(src, dst, dry_run=self.dry_run)\n\n    def spawn(self, cmd, search_path=True, level=1):\n        \"\"\"Spawn an external command respecting dry-run flag.\"\"\"\n        from distutils.spawn import spawn\n\n        spawn(cmd, search_path, dry_run=self.dry_run)\n\n    def make_archive(\n        self, base_name, format, root_dir=None, base_dir=None, owner=None, group=None\n    ):\n        return archive_util.make_archive(\n            base_name,\n            format,\n            root_dir,\n            base_dir,\n            dry_run=self.dry_run,\n            owner=owner,\n            group=group,\n        )\n\n    def make_file(\n        self, infiles, outfile, func, args, exec_msg=None, skip_msg=None, level=1\n    ):\n        \"\"\"Special case of 'execute()' for operations that process one or\n        more input files and generate one output file.  Works just like\n        'execute()', except the operation is skipped and a different\n        message printed if 'outfile' already exists and is newer than all\n        files listed in 'infiles'.  If the command defined 'self.force',\n        and it is true, then the command is unconditionally run -- does no\n        timestamp checks.\n        \"\"\"\n        if skip_msg is None:\n            skip_msg = f\"skipping {outfile} (inputs unchanged)\"\n\n        # Allow 'infiles' to be a single string\n        if isinstance(infiles, str):\n            infiles = (infiles,)\n        elif not isinstance(infiles, (list, tuple)):\n            raise TypeError(\"'infiles' must be a string, or a list or tuple of strings\")\n\n        if exec_msg is None:\n            exec_msg = \"generating {} from {}\".format(outfile, ', '.join(infiles))\n\n        # If 'outfile' must be regenerated (either because it doesn't\n        # exist, is out-of-date, or the 'force' flag is true) then\n        # perform the action that presumably regenerates it\n        if self.force or _modified.newer_group(infiles, outfile):\n            self.execute(func, args, exec_msg, level)\n        # Otherwise, print the \"skip\" message\n        else:\n            log.debug(skip_msg)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/command/__init__.py","size":386,"sha1":"80daaac27bce999eb68b5237398c307bc3808cac","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.command\n\nPackage containing implementation of all the standard Distutils\ncommands.\"\"\"\n\n__all__ = [\n    'build',\n    'build_py',\n    'build_ext',\n    'build_clib',\n    'build_scripts',\n    'clean',\n    'install',\n    'install_lib',\n    'install_headers',\n    'install_scripts',\n    'install_data',\n    'sdist',\n    'bdist',\n    'bdist_dumb',\n    'bdist_rpm',\n    'check',\n]\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/command/_framework_compat.py","size":1609,"sha1":"23034ea560a0df7b168b0e92390393d748fa363e","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nBackward compatibility for homebrew builds on macOS.\n\"\"\"\n\nimport functools\nimport os\nimport subprocess\nimport sys\nimport sysconfig\n\n\n@functools.lru_cache\ndef enabled():\n    \"\"\"\n    Only enabled for Python 3.9 framework homebrew builds\n    except ensurepip and venv.\n    \"\"\"\n    PY39 = (3, 9) < sys.version_info < (3, 10)\n    framework = sys.platform == 'darwin' and sys._framework\n    homebrew = \"Cellar\" in sysconfig.get_config_var('projectbase')\n    venv = sys.prefix != sys.base_prefix\n    ensurepip = os.environ.get(\"ENSUREPIP_OPTIONS\")\n    return PY39 and framework and homebrew and not venv and not ensurepip\n\n\nschemes = dict(\n    osx_framework_library=dict(\n        stdlib='{installed_base}/{platlibdir}/python{py_version_short}',\n        platstdlib='{platbase}/{platlibdir}/python{py_version_short}',\n        purelib='{homebrew_prefix}/lib/python{py_version_short}/site-packages',\n        platlib='{homebrew_prefix}/{platlibdir}/python{py_version_short}/site-packages',\n        include='{installed_base}/include/python{py_version_short}{abiflags}',\n        platinclude='{installed_platbase}/include/python{py_version_short}{abiflags}',\n        scripts='{homebrew_prefix}/bin',\n        data='{homebrew_prefix}',\n    )\n)\n\n\n@functools.lru_cache\ndef vars():\n    if not enabled():\n        return {}\n    homebrew_prefix = subprocess.check_output(['brew', '--prefix'], text=True).strip()\n    return locals()\n\n\ndef scheme(name):\n    \"\"\"\n    Override the selected scheme for posix_prefix.\n    \"\"\"\n    if not enabled() or not name.endswith('_prefix'):\n        return name\n    return 'osx_framework_library'\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/command/bdist.py","size":5423,"sha1":"d59184082333ddfff1dd194b0a53cafcc2aa5274","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.command.bdist\n\nImplements the Distutils 'bdist' command (create a built [binary]\ndistribution).\"\"\"\n\nimport os\nimport warnings\nfrom typing import ClassVar\n\nfrom ..core import Command\nfrom ..errors import DistutilsOptionError, DistutilsPlatformError\nfrom ..util import get_platform\n\n\ndef show_formats():\n    \"\"\"Print list of available formats (arguments to \"--format\" option).\"\"\"\n    from ..fancy_getopt import FancyGetopt\n\n    formats = [\n        (\"formats=\" + format, None, bdist.format_commands[format][1])\n        for format in bdist.format_commands\n    ]\n    pretty_printer = FancyGetopt(formats)\n    pretty_printer.print_help(\"List of available distribution formats:\")\n\n\nclass ListCompat(dict[str, tuple[str, str]]):\n    # adapter to allow for Setuptools compatibility in format_commands\n    def append(self, item):\n        warnings.warn(\n            \"\"\"format_commands is now a dict. append is deprecated.\"\"\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n\nclass bdist(Command):\n    description = \"create a built (binary) distribution\"\n\n    user_options = [\n        ('bdist-base=', 'b', \"temporary directory for creating built distributions\"),\n        (\n            'plat-name=',\n            'p',\n            \"platform name to embed in generated filenames \"\n            f\"[default: {get_platform()}]\",\n        ),\n        ('formats=', None, \"formats for distribution (comma-separated list)\"),\n        (\n            'dist-dir=',\n            'd',\n            \"directory to put final built distributions in [default: dist]\",\n        ),\n        ('skip-build', None, \"skip rebuilding everything (for testing/debugging)\"),\n        (\n            'owner=',\n            'u',\n            \"Owner name used when creating a tar file [default: current user]\",\n        ),\n        (\n            'group=',\n            'g',\n            \"Group name used when creating a tar file [default: current group]\",\n        ),\n    ]\n\n    boolean_options = ['skip-build']\n\n    help_options = [\n        ('help-formats', None, \"lists available distribution formats\", show_formats),\n    ]\n\n    # The following commands do not take a format option from bdist\n    no_format_option: ClassVar[tuple[str, ...]] = ('bdist_rpm',)\n\n    # This won't do in reality: will need to distinguish RPM-ish Linux,\n    # Debian-ish Linux, Solaris, FreeBSD, ..., Windows, Mac OS.\n    default_format = {'posix': 'gztar', 'nt': 'zip'}\n\n    # Define commands in preferred order for the --help-formats option\n    format_commands = ListCompat({\n        'rpm': ('bdist_rpm', \"RPM distribution\"),\n        'gztar': ('bdist_dumb', \"gzip'ed tar file\"),\n        'bztar': ('bdist_dumb', \"bzip2'ed tar file\"),\n        'xztar': ('bdist_dumb', \"xz'ed tar file\"),\n        'ztar': ('bdist_dumb', \"compressed tar file\"),\n        'tar': ('bdist_dumb', \"tar file\"),\n        'zip': ('bdist_dumb', \"ZIP file\"),\n    })\n\n    # for compatibility until consumers only reference format_commands\n    format_command = format_commands\n\n    def initialize_options(self):\n        self.bdist_base = None\n        self.plat_name = None\n        self.formats = None\n        self.dist_dir = None\n        self.skip_build = False\n        self.group = None\n        self.owner = None\n\n    def finalize_options(self):\n        # have to finalize 'plat_name' before 'bdist_base'\n        if self.plat_name is None:\n            if self.skip_build:\n                self.plat_name = get_platform()\n            else:\n                self.plat_name = self.get_finalized_command('build').plat_name\n\n        # 'bdist_base' -- parent of per-built-distribution-format\n        # temporary directories (eg. we'll probably have\n        # \"build/bdist.<plat>/dumb\", \"build/bdist.<plat>/rpm\", etc.)\n        if self.bdist_base is None:\n            build_base = self.get_finalized_command('build').build_base\n            self.bdist_base = os.path.join(build_base, 'bdist.' + self.plat_name)\n\n        self.ensure_string_list('formats')\n        if self.formats is None:\n            try:\n                self.formats = [self.default_format[os.name]]\n            except KeyError:\n                raise DistutilsPlatformError(\n                    \"don't know how to create built distributions \"\n                    f\"on platform {os.name}\"\n                )\n\n        if self.dist_dir is None:\n            self.dist_dir = \"dist\"\n\n    def run(self):\n        # Figure out which sub-commands we need to run.\n        commands = []\n        for format in self.formats:\n            try:\n                commands.append(self.format_commands[format][0])\n            except KeyError:\n                raise DistutilsOptionError(f\"invalid format '{format}'\")\n\n        # Reinitialize and run each command.\n        for i in range(len(self.formats)):\n            cmd_name = commands[i]\n            sub_cmd = self.reinitialize_command(cmd_name)\n            if cmd_name not in self.no_format_option:\n                sub_cmd.format = self.formats[i]\n\n            # passing the owner and group names for tar archiving\n            if cmd_name == 'bdist_dumb':\n                sub_cmd.owner = self.owner\n                sub_cmd.group = self.group\n\n            # If we're going to need to run this command again, tell it to\n            # keep its temporary files around so subsequent runs go faster.\n            if cmd_name in commands[i + 1 :]:\n                sub_cmd.keep_temp = True\n            self.run_command(cmd_name)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/command/bdist_dumb.py","size":4582,"sha1":"73a5cf003f9a2294c9da6bc78b56586d5b19f111","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.command.bdist_dumb\n\nImplements the Distutils 'bdist_dumb' command (create a \"dumb\" built\ndistribution -- i.e., just an archive to be unpacked under $prefix or\n$exec_prefix).\"\"\"\n\nimport os\nfrom distutils._log import log\n\nfrom ..core import Command\nfrom ..dir_util import ensure_relative, remove_tree\nfrom ..errors import DistutilsPlatformError\nfrom ..sysconfig import get_python_version\nfrom ..util import get_platform\n\n\nclass bdist_dumb(Command):\n    description = \"create a \\\"dumb\\\" built distribution\"\n\n    user_options = [\n        ('bdist-dir=', 'd', \"temporary directory for creating the distribution\"),\n        (\n            'plat-name=',\n            'p',\n            \"platform name to embed in generated filenames \"\n            f\"[default: {get_platform()}]\",\n        ),\n        (\n            'format=',\n            'f',\n            \"archive format to create (tar, gztar, bztar, xztar, ztar, zip)\",\n        ),\n        (\n            'keep-temp',\n            'k',\n            \"keep the pseudo-installation tree around after creating the distribution archive\",\n        ),\n        ('dist-dir=', 'd', \"directory to put final built distributions in\"),\n        ('skip-build', None, \"skip rebuilding everything (for testing/debugging)\"),\n        (\n            'relative',\n            None,\n            \"build the archive using relative paths [default: false]\",\n        ),\n        (\n            'owner=',\n            'u',\n            \"Owner name used when creating a tar file [default: current user]\",\n        ),\n        (\n            'group=',\n            'g',\n            \"Group name used when creating a tar file [default: current group]\",\n        ),\n    ]\n\n    boolean_options = ['keep-temp', 'skip-build', 'relative']\n\n    default_format = {'posix': 'gztar', 'nt': 'zip'}\n\n    def initialize_options(self):\n        self.bdist_dir = None\n        self.plat_name = None\n        self.format = None\n        self.keep_temp = False\n        self.dist_dir = None\n        self.skip_build = None\n        self.relative = False\n        self.owner = None\n        self.group = None\n\n    def finalize_options(self):\n        if self.bdist_dir is None:\n            bdist_base = self.get_finalized_command('bdist').bdist_base\n            self.bdist_dir = os.path.join(bdist_base, 'dumb')\n\n        if self.format is None:\n            try:\n                self.format = self.default_format[os.name]\n            except KeyError:\n                raise DistutilsPlatformError(\n                    \"don't know how to create dumb built distributions \"\n                    f\"on platform {os.name}\"\n                )\n\n        self.set_undefined_options(\n            'bdist',\n            ('dist_dir', 'dist_dir'),\n            ('plat_name', 'plat_name'),\n            ('skip_build', 'skip_build'),\n        )\n\n    def run(self):\n        if not self.skip_build:\n            self.run_command('build')\n\n        install = self.reinitialize_command('install', reinit_subcommands=True)\n        install.root = self.bdist_dir\n        install.skip_build = self.skip_build\n        install.warn_dir = False\n\n        log.info(\"installing to %s\", self.bdist_dir)\n        self.run_command('install')\n\n        # And make an archive relative to the root of the\n        # pseudo-installation tree.\n        archive_basename = f\"{self.distribution.get_fullname()}.{self.plat_name}\"\n\n        pseudoinstall_root = os.path.join(self.dist_dir, archive_basename)\n        if not self.relative:\n            archive_root = self.bdist_dir\n        else:\n            if self.distribution.has_ext_modules() and (\n                install.install_base != install.install_platbase\n            ):\n                raise DistutilsPlatformError(\n                    \"can't make a dumb built distribution where \"\n                    f\"base and platbase are different ({install.install_base!r}, {install.install_platbase!r})\"\n                )\n            else:\n                archive_root = os.path.join(\n                    self.bdist_dir, ensure_relative(install.install_base)\n                )\n\n        # Make the archive\n        filename = self.make_archive(\n            pseudoinstall_root,\n            self.format,\n            root_dir=archive_root,\n            owner=self.owner,\n            group=self.group,\n        )\n        if self.distribution.has_ext_modules():\n            pyversion = get_python_version()\n        else:\n            pyversion = 'any'\n        self.distribution.dist_files.append(('bdist_dumb', pyversion, filename))\n\n        if not self.keep_temp:\n            remove_tree(self.bdist_dir, dry_run=self.dry_run)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/command/bdist_rpm.py","size":21686,"sha1":"f9944becb573677b387ed9d2ba7570f862721ad0","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.command.bdist_rpm\n\nImplements the Distutils 'bdist_rpm' command (create RPM source and binary\ndistributions).\"\"\"\n\nimport os\nimport subprocess\nimport sys\nfrom distutils._log import log\n\nfrom ..core import Command\nfrom ..debug import DEBUG\nfrom ..errors import (\n    DistutilsExecError,\n    DistutilsFileError,\n    DistutilsOptionError,\n    DistutilsPlatformError,\n)\nfrom ..file_util import write_file\nfrom ..sysconfig import get_python_version\n\n\nclass bdist_rpm(Command):\n    description = \"create an RPM distribution\"\n\n    user_options = [\n        ('bdist-base=', None, \"base directory for creating built distributions\"),\n        (\n            'rpm-base=',\n            None,\n            \"base directory for creating RPMs (defaults to \\\"rpm\\\" under \"\n            \"--bdist-base; must be specified for RPM 2)\",\n        ),\n        (\n            'dist-dir=',\n            'd',\n            \"directory to put final RPM files in (and .spec files if --spec-only)\",\n        ),\n        (\n            'python=',\n            None,\n            \"path to Python interpreter to hard-code in the .spec file \"\n            \"[default: \\\"python\\\"]\",\n        ),\n        (\n            'fix-python',\n            None,\n            \"hard-code the exact path to the current Python interpreter in \"\n            \"the .spec file\",\n        ),\n        ('spec-only', None, \"only regenerate spec file\"),\n        ('source-only', None, \"only generate source RPM\"),\n        ('binary-only', None, \"only generate binary RPM\"),\n        ('use-bzip2', None, \"use bzip2 instead of gzip to create source distribution\"),\n        # More meta-data: too RPM-specific to put in the setup script,\n        # but needs to go in the .spec file -- so we make these options\n        # to \"bdist_rpm\".  The idea is that packagers would put this\n        # info in setup.cfg, although they are of course free to\n        # supply it on the command line.\n        (\n            'distribution-name=',\n            None,\n            \"name of the (Linux) distribution to which this \"\n            \"RPM applies (*not* the name of the module distribution!)\",\n        ),\n        ('group=', None, \"package classification [default: \\\"Development/Libraries\\\"]\"),\n        ('release=', None, \"RPM release number\"),\n        ('serial=', None, \"RPM serial number\"),\n        (\n            'vendor=',\n            None,\n            \"RPM \\\"vendor\\\" (eg. \\\"Joe Blow <joe@example.com>\\\") \"\n            \"[default: maintainer or author from setup script]\",\n        ),\n        (\n            'packager=',\n            None,\n            \"RPM packager (eg. \\\"Jane Doe <jane@example.net>\\\") [default: vendor]\",\n        ),\n        ('doc-files=', None, \"list of documentation files (space or comma-separated)\"),\n        ('changelog=', None, \"RPM changelog\"),\n        ('icon=', None, \"name of icon file\"),\n        ('provides=', None, \"capabilities provided by this package\"),\n        ('requires=', None, \"capabilities required by this package\"),\n        ('conflicts=', None, \"capabilities which conflict with this package\"),\n        ('build-requires=', None, \"capabilities required to build this package\"),\n        ('obsoletes=', None, \"capabilities made obsolete by this package\"),\n        ('no-autoreq', None, \"do not automatically calculate dependencies\"),\n        # Actions to take when building RPM\n        ('keep-temp', 'k', \"don't clean up RPM build directory\"),\n        ('no-keep-temp', None, \"clean up RPM build directory [default]\"),\n        (\n            'use-rpm-opt-flags',\n            None,\n            \"compile with RPM_OPT_FLAGS when building from source RPM\",\n        ),\n        ('no-rpm-opt-flags', None, \"do not pass any RPM CFLAGS to compiler\"),\n        ('rpm3-mode', None, \"RPM 3 compatibility mode (default)\"),\n        ('rpm2-mode', None, \"RPM 2 compatibility mode\"),\n        # Add the hooks necessary for specifying custom scripts\n        ('prep-script=', None, \"Specify a script for the PREP phase of RPM building\"),\n        ('build-script=', None, \"Specify a script for the BUILD phase of RPM building\"),\n        (\n            'pre-install=',\n            None,\n            \"Specify a script for the pre-INSTALL phase of RPM building\",\n        ),\n        (\n            'install-script=',\n            None,\n            \"Specify a script for the INSTALL phase of RPM building\",\n        ),\n        (\n            'post-install=',\n            None,\n            \"Specify a script for the post-INSTALL phase of RPM building\",\n        ),\n        (\n            'pre-uninstall=',\n            None,\n            \"Specify a script for the pre-UNINSTALL phase of RPM building\",\n        ),\n        (\n            'post-uninstall=',\n            None,\n            \"Specify a script for the post-UNINSTALL phase of RPM building\",\n        ),\n        ('clean-script=', None, \"Specify a script for the CLEAN phase of RPM building\"),\n        (\n            'verify-script=',\n            None,\n            \"Specify a script for the VERIFY phase of the RPM build\",\n        ),\n        # Allow a packager to explicitly force an architecture\n        ('force-arch=', None, \"Force an architecture onto the RPM build process\"),\n        ('quiet', 'q', \"Run the INSTALL phase of RPM building in quiet mode\"),\n    ]\n\n    boolean_options = [\n        'keep-temp',\n        'use-rpm-opt-flags',\n        'rpm3-mode',\n        'no-autoreq',\n        'quiet',\n    ]\n\n    negative_opt = {\n        'no-keep-temp': 'keep-temp',\n        'no-rpm-opt-flags': 'use-rpm-opt-flags',\n        'rpm2-mode': 'rpm3-mode',\n    }\n\n    def initialize_options(self):\n        self.bdist_base = None\n        self.rpm_base = None\n        self.dist_dir = None\n        self.python = None\n        self.fix_python = None\n        self.spec_only = None\n        self.binary_only = None\n        self.source_only = None\n        self.use_bzip2 = None\n\n        self.distribution_name = None\n        self.group = None\n        self.release = None\n        self.serial = None\n        self.vendor = None\n        self.packager = None\n        self.doc_files = None\n        self.changelog = None\n        self.icon = None\n\n        self.prep_script = None\n        self.build_script = None\n        self.install_script = None\n        self.clean_script = None\n        self.verify_script = None\n        self.pre_install = None\n        self.post_install = None\n        self.pre_uninstall = None\n        self.post_uninstall = None\n        self.prep = None\n        self.provides = None\n        self.requires = None\n        self.conflicts = None\n        self.build_requires = None\n        self.obsoletes = None\n\n        self.keep_temp = False\n        self.use_rpm_opt_flags = True\n        self.rpm3_mode = True\n        self.no_autoreq = False\n\n        self.force_arch = None\n        self.quiet = False\n\n    def finalize_options(self):\n        self.set_undefined_options('bdist', ('bdist_base', 'bdist_base'))\n        if self.rpm_base is None:\n            if not self.rpm3_mode:\n                raise DistutilsOptionError(\"you must specify --rpm-base in RPM 2 mode\")\n            self.rpm_base = os.path.join(self.bdist_base, \"rpm\")\n\n        if self.python is None:\n            if self.fix_python:\n                self.python = sys.executable\n            else:\n                self.python = \"python3\"\n        elif self.fix_python:\n            raise DistutilsOptionError(\n                \"--python and --fix-python are mutually exclusive options\"\n            )\n\n        if os.name != 'posix':\n            raise DistutilsPlatformError(\n                f\"don't know how to create RPM distributions on platform {os.name}\"\n            )\n        if self.binary_only and self.source_only:\n            raise DistutilsOptionError(\n                \"cannot supply both '--source-only' and '--binary-only'\"\n            )\n\n        # don't pass CFLAGS to pure python distributions\n        if not self.distribution.has_ext_modules():\n            self.use_rpm_opt_flags = False\n\n        self.set_undefined_options('bdist', ('dist_dir', 'dist_dir'))\n        self.finalize_package_data()\n\n    def finalize_package_data(self):\n        self.ensure_string('group', \"Development/Libraries\")\n        self.ensure_string(\n            'vendor',\n            f\"{self.distribution.get_contact()} <{self.distribution.get_contact_email()}>\",\n        )\n        self.ensure_string('packager')\n        self.ensure_string_list('doc_files')\n        if isinstance(self.doc_files, list):\n            for readme in ('README', 'README.txt'):\n                if os.path.exists(readme) and readme not in self.doc_files:\n                    self.doc_files.append(readme)\n\n        self.ensure_string('release', \"1\")\n        self.ensure_string('serial')  # should it be an int?\n\n        self.ensure_string('distribution_name')\n\n        self.ensure_string('changelog')\n        # Format changelog correctly\n        self.changelog = self._format_changelog(self.changelog)\n\n        self.ensure_filename('icon')\n\n        self.ensure_filename('prep_script')\n        self.ensure_filename('build_script')\n        self.ensure_filename('install_script')\n        self.ensure_filename('clean_script')\n        self.ensure_filename('verify_script')\n        self.ensure_filename('pre_install')\n        self.ensure_filename('post_install')\n        self.ensure_filename('pre_uninstall')\n        self.ensure_filename('post_uninstall')\n\n        # XXX don't forget we punted on summaries and descriptions -- they\n        # should be handled here eventually!\n\n        # Now *this* is some meta-data that belongs in the setup script...\n        self.ensure_string_list('provides')\n        self.ensure_string_list('requires')\n        self.ensure_string_list('conflicts')\n        self.ensure_string_list('build_requires')\n        self.ensure_string_list('obsoletes')\n\n        self.ensure_string('force_arch')\n\n    def run(self):  # noqa: C901\n        if DEBUG:\n            print(\"before _get_package_data():\")\n            print(\"vendor =\", self.vendor)\n            print(\"packager =\", self.packager)\n            print(\"doc_files =\", self.doc_files)\n            print(\"changelog =\", self.changelog)\n\n        # make directories\n        if self.spec_only:\n            spec_dir = self.dist_dir\n            self.mkpath(spec_dir)\n        else:\n            rpm_dir = {}\n            for d in ('SOURCES', 'SPECS', 'BUILD', 'RPMS', 'SRPMS'):\n                rpm_dir[d] = os.path.join(self.rpm_base, d)\n                self.mkpath(rpm_dir[d])\n            spec_dir = rpm_dir['SPECS']\n\n        # Spec file goes into 'dist_dir' if '--spec-only specified',\n        # build/rpm.<plat> otherwise.\n        spec_path = os.path.join(spec_dir, f\"{self.distribution.get_name()}.spec\")\n        self.execute(\n            write_file, (spec_path, self._make_spec_file()), f\"writing '{spec_path}'\"\n        )\n\n        if self.spec_only:  # stop if requested\n            return\n\n        # Make a source distribution and copy to SOURCES directory with\n        # optional icon.\n        saved_dist_files = self.distribution.dist_files[:]\n        sdist = self.reinitialize_command('sdist')\n        if self.use_bzip2:\n            sdist.formats = ['bztar']\n        else:\n            sdist.formats = ['gztar']\n        self.run_command('sdist')\n        self.distribution.dist_files = saved_dist_files\n\n        source = sdist.get_archive_files()[0]\n        source_dir = rpm_dir['SOURCES']\n        self.copy_file(source, source_dir)\n\n        if self.icon:\n            if os.path.exists(self.icon):\n                self.copy_file(self.icon, source_dir)\n            else:\n                raise DistutilsFileError(f\"icon file '{self.icon}' does not exist\")\n\n        # build package\n        log.info(\"building RPMs\")\n        rpm_cmd = ['rpmbuild']\n\n        if self.source_only:  # what kind of RPMs?\n            rpm_cmd.append('-bs')\n        elif self.binary_only:\n            rpm_cmd.append('-bb')\n        else:\n            rpm_cmd.append('-ba')\n        rpm_cmd.extend(['--define', f'__python {self.python}'])\n        if self.rpm3_mode:\n            rpm_cmd.extend(['--define', f'_topdir {os.path.abspath(self.rpm_base)}'])\n        if not self.keep_temp:\n            rpm_cmd.append('--clean')\n\n        if self.quiet:\n            rpm_cmd.append('--quiet')\n\n        rpm_cmd.append(spec_path)\n        # Determine the binary rpm names that should be built out of this spec\n        # file\n        # Note that some of these may not be really built (if the file\n        # list is empty)\n        nvr_string = \"%{name}-%{version}-%{release}\"\n        src_rpm = nvr_string + \".src.rpm\"\n        non_src_rpm = \"%{arch}/\" + nvr_string + \".%{arch}.rpm\"\n        q_cmd = rf\"rpm -q --qf '{src_rpm} {non_src_rpm}\\n' --specfile '{spec_path}'\"\n\n        out = os.popen(q_cmd)\n        try:\n            binary_rpms = []\n            source_rpm = None\n            while True:\n                line = out.readline()\n                if not line:\n                    break\n                ell = line.strip().split()\n                assert len(ell) == 2\n                binary_rpms.append(ell[1])\n                # The source rpm is named after the first entry in the spec file\n                if source_rpm is None:\n                    source_rpm = ell[0]\n\n            status = out.close()\n            if status:\n                raise DistutilsExecError(f\"Failed to execute: {q_cmd!r}\")\n\n        finally:\n            out.close()\n\n        self.spawn(rpm_cmd)\n\n        if not self.dry_run:\n            if self.distribution.has_ext_modules():\n                pyversion = get_python_version()\n            else:\n                pyversion = 'any'\n\n            if not self.binary_only:\n                srpm = os.path.join(rpm_dir['SRPMS'], source_rpm)\n                assert os.path.exists(srpm)\n                self.move_file(srpm, self.dist_dir)\n                filename = os.path.join(self.dist_dir, source_rpm)\n                self.distribution.dist_files.append(('bdist_rpm', pyversion, filename))\n\n            if not self.source_only:\n                for rpm in binary_rpms:\n                    rpm = os.path.join(rpm_dir['RPMS'], rpm)\n                    if os.path.exists(rpm):\n                        self.move_file(rpm, self.dist_dir)\n                        filename = os.path.join(self.dist_dir, os.path.basename(rpm))\n                        self.distribution.dist_files.append((\n                            'bdist_rpm',\n                            pyversion,\n                            filename,\n                        ))\n\n    def _dist_path(self, path):\n        return os.path.join(self.dist_dir, os.path.basename(path))\n\n    def _make_spec_file(self):  # noqa: C901\n        \"\"\"Generate the text of an RPM spec file and return it as a\n        list of strings (one per line).\n        \"\"\"\n        # definitions and headers\n        spec_file = [\n            '%define name ' + self.distribution.get_name(),\n            '%define version ' + self.distribution.get_version().replace('-', '_'),\n            '%define unmangled_version ' + self.distribution.get_version(),\n            '%define release ' + self.release.replace('-', '_'),\n            '',\n            'Summary: ' + (self.distribution.get_description() or \"UNKNOWN\"),\n        ]\n\n        # Workaround for #14443 which affects some RPM based systems such as\n        # RHEL6 (and probably derivatives)\n        vendor_hook = subprocess.getoutput('rpm --eval %{__os_install_post}')\n        # Generate a potential replacement value for __os_install_post (whilst\n        # normalizing the whitespace to simplify the test for whether the\n        # invocation of brp-python-bytecompile passes in __python):\n        vendor_hook = '\\n'.join([\n            f'  {line.strip()} \\\\' for line in vendor_hook.splitlines()\n        ])\n        problem = \"brp-python-bytecompile \\\\\\n\"\n        fixed = \"brp-python-bytecompile %{__python} \\\\\\n\"\n        fixed_hook = vendor_hook.replace(problem, fixed)\n        if fixed_hook != vendor_hook:\n            spec_file.append('# Workaround for https://bugs.python.org/issue14443')\n            spec_file.append('%define __os_install_post ' + fixed_hook + '\\n')\n\n        # put locale summaries into spec file\n        # XXX not supported for now (hard to put a dictionary\n        # in a config file -- arg!)\n        # for locale in self.summaries.keys():\n        #    spec_file.append('Summary(%s): %s' % (locale,\n        #                                          self.summaries[locale]))\n\n        spec_file.extend([\n            'Name: %{name}',\n            'Version: %{version}',\n            'Release: %{release}',\n        ])\n\n        # XXX yuck! this filename is available from the \"sdist\" command,\n        # but only after it has run: and we create the spec file before\n        # running \"sdist\", in case of --spec-only.\n        if self.use_bzip2:\n            spec_file.append('Source0: %{name}-%{unmangled_version}.tar.bz2')\n        else:\n            spec_file.append('Source0: %{name}-%{unmangled_version}.tar.gz')\n\n        spec_file.extend([\n            'License: ' + (self.distribution.get_license() or \"UNKNOWN\"),\n            'Group: ' + self.group,\n            'BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-buildroot',\n            'Prefix: %{_prefix}',\n        ])\n\n        if not self.force_arch:\n            # noarch if no extension modules\n            if not self.distribution.has_ext_modules():\n                spec_file.append('BuildArch: noarch')\n        else:\n            spec_file.append(f'BuildArch: {self.force_arch}')\n\n        for field in (\n            'Vendor',\n            'Packager',\n            'Provides',\n            'Requires',\n            'Conflicts',\n            'Obsoletes',\n        ):\n            val = getattr(self, field.lower())\n            if isinstance(val, list):\n                spec_file.append('{}: {}'.format(field, ' '.join(val)))\n            elif val is not None:\n                spec_file.append(f'{field}: {val}')\n\n        if self.distribution.get_url():\n            spec_file.append('Url: ' + self.distribution.get_url())\n\n        if self.distribution_name:\n            spec_file.append('Distribution: ' + self.distribution_name)\n\n        if self.build_requires:\n            spec_file.append('BuildRequires: ' + ' '.join(self.build_requires))\n\n        if self.icon:\n            spec_file.append('Icon: ' + os.path.basename(self.icon))\n\n        if self.no_autoreq:\n            spec_file.append('AutoReq: 0')\n\n        spec_file.extend([\n            '',\n            '%description',\n            self.distribution.get_long_description() or \"\",\n        ])\n\n        # put locale descriptions into spec file\n        # XXX again, suppressed because config file syntax doesn't\n        # easily support this ;-(\n        # for locale in self.descriptions.keys():\n        #    spec_file.extend([\n        #        '',\n        #        '%description -l ' + locale,\n        #        self.descriptions[locale],\n        #        ])\n\n        # rpm scripts\n        # figure out default build script\n        def_setup_call = f\"{self.python} {os.path.basename(sys.argv[0])}\"\n        def_build = f\"{def_setup_call} build\"\n        if self.use_rpm_opt_flags:\n            def_build = 'env CFLAGS=\"$RPM_OPT_FLAGS\" ' + def_build\n\n        # insert contents of files\n\n        # XXX this is kind of misleading: user-supplied options are files\n        # that we open and interpolate into the spec file, but the defaults\n        # are just text that we drop in as-is.  Hmmm.\n\n        install_cmd = f'{def_setup_call} install -O1 --root=$RPM_BUILD_ROOT --record=INSTALLED_FILES'\n\n        script_options = [\n            ('prep', 'prep_script', \"%setup -n %{name}-%{unmangled_version}\"),\n            ('build', 'build_script', def_build),\n            ('install', 'install_script', install_cmd),\n            ('clean', 'clean_script', \"rm -rf $RPM_BUILD_ROOT\"),\n            ('verifyscript', 'verify_script', None),\n            ('pre', 'pre_install', None),\n            ('post', 'post_install', None),\n            ('preun', 'pre_uninstall', None),\n            ('postun', 'post_uninstall', None),\n        ]\n\n        for rpm_opt, attr, default in script_options:\n            # Insert contents of file referred to, if no file is referred to\n            # use 'default' as contents of script\n            val = getattr(self, attr)\n            if val or default:\n                spec_file.extend([\n                    '',\n                    '%' + rpm_opt,\n                ])\n                if val:\n                    with open(val) as f:\n                        spec_file.extend(f.read().split('\\n'))\n                else:\n                    spec_file.append(default)\n\n        # files section\n        spec_file.extend([\n            '',\n            '%files -f INSTALLED_FILES',\n            '%defattr(-,root,root)',\n        ])\n\n        if self.doc_files:\n            spec_file.append('%doc ' + ' '.join(self.doc_files))\n\n        if self.changelog:\n            spec_file.extend([\n                '',\n                '%changelog',\n            ])\n            spec_file.extend(self.changelog)\n\n        return spec_file\n\n    def _format_changelog(self, changelog):\n        \"\"\"Format the changelog correctly and convert it to a list of strings\"\"\"\n        if not changelog:\n            return changelog\n        new_changelog = []\n        for line in changelog.strip().split('\\n'):\n            line = line.strip()\n            if line[0] == '*':\n                new_changelog.extend(['', line])\n            elif line[0] == '-':\n                new_changelog.append(line)\n            else:\n                new_changelog.append('  ' + line)\n\n        # strip trailing newline inserted by first changelog entry\n        if not new_changelog[0]:\n            del new_changelog[0]\n\n        return new_changelog\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/command/build.py","size":5768,"sha1":"280409f547453e8b2277ecd5fa6cf74bcc15a337","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.command.build\n\nImplements the Distutils 'build' command.\"\"\"\n\nimport os\nimport sys\nimport sysconfig\n\nfrom ..core import Command\nfrom ..errors import DistutilsOptionError\nfrom ..util import get_platform\n\n\ndef show_compilers():\n    from ..ccompiler import show_compilers\n\n    show_compilers()\n\n\nclass build(Command):\n    description = \"build everything needed to install\"\n\n    user_options = [\n        ('build-base=', 'b', \"base directory for build library\"),\n        ('build-purelib=', None, \"build directory for platform-neutral distributions\"),\n        ('build-platlib=', None, \"build directory for platform-specific distributions\"),\n        (\n            'build-lib=',\n            None,\n            \"build directory for all distribution (defaults to either build-purelib or build-platlib\",\n        ),\n        ('build-scripts=', None, \"build directory for scripts\"),\n        ('build-temp=', 't', \"temporary build directory\"),\n        (\n            'plat-name=',\n            'p',\n            f\"platform name to build for, if supported [default: {get_platform()}]\",\n        ),\n        ('compiler=', 'c', \"specify the compiler type\"),\n        ('parallel=', 'j', \"number of parallel build jobs\"),\n        ('debug', 'g', \"compile extensions and libraries with debugging information\"),\n        ('force', 'f', \"forcibly build everything (ignore file timestamps)\"),\n        ('executable=', 'e', \"specify final destination interpreter path (build.py)\"),\n    ]\n\n    boolean_options = ['debug', 'force']\n\n    help_options = [\n        ('help-compiler', None, \"list available compilers\", show_compilers),\n    ]\n\n    def initialize_options(self):\n        self.build_base = 'build'\n        # these are decided only after 'build_base' has its final value\n        # (unless overridden by the user or client)\n        self.build_purelib = None\n        self.build_platlib = None\n        self.build_lib = None\n        self.build_temp = None\n        self.build_scripts = None\n        self.compiler = None\n        self.plat_name = None\n        self.debug = None\n        self.force = False\n        self.executable = None\n        self.parallel = None\n\n    def finalize_options(self):  # noqa: C901\n        if self.plat_name is None:\n            self.plat_name = get_platform()\n        else:\n            # plat-name only supported for windows (other platforms are\n            # supported via ./configure flags, if at all).  Avoid misleading\n            # other platforms.\n            if os.name != 'nt':\n                raise DistutilsOptionError(\n                    \"--plat-name only supported on Windows (try \"\n                    \"using './configure --help' on your platform)\"\n                )\n\n        plat_specifier = f\".{self.plat_name}-{sys.implementation.cache_tag}\"\n\n        # Python 3.13+ with --disable-gil shouldn't share build directories\n        if sysconfig.get_config_var('Py_GIL_DISABLED'):\n            plat_specifier += 't'\n\n        # Make it so Python 2.x and Python 2.x with --with-pydebug don't\n        # share the same build directories. Doing so confuses the build\n        # process for C modules\n        if hasattr(sys, 'gettotalrefcount'):\n            plat_specifier += '-pydebug'\n\n        # 'build_purelib' and 'build_platlib' just default to 'lib' and\n        # 'lib.<plat>' under the base build directory.  We only use one of\n        # them for a given distribution, though --\n        if self.build_purelib is None:\n            self.build_purelib = os.path.join(self.build_base, 'lib')\n        if self.build_platlib is None:\n            self.build_platlib = os.path.join(self.build_base, 'lib' + plat_specifier)\n\n        # 'build_lib' is the actual directory that we will use for this\n        # particular module distribution -- if user didn't supply it, pick\n        # one of 'build_purelib' or 'build_platlib'.\n        if self.build_lib is None:\n            if self.distribution.has_ext_modules():\n                self.build_lib = self.build_platlib\n            else:\n                self.build_lib = self.build_purelib\n\n        # 'build_temp' -- temporary directory for compiler turds,\n        # \"build/temp.<plat>\"\n        if self.build_temp is None:\n            self.build_temp = os.path.join(self.build_base, 'temp' + plat_specifier)\n        if self.build_scripts is None:\n            self.build_scripts = os.path.join(\n                self.build_base,\n                f'scripts-{sys.version_info.major}.{sys.version_info.minor}',\n            )\n\n        if self.executable is None and sys.executable:\n            self.executable = os.path.normpath(sys.executable)\n\n        if isinstance(self.parallel, str):\n            try:\n                self.parallel = int(self.parallel)\n            except ValueError:\n                raise DistutilsOptionError(\"parallel should be an integer\")\n\n    def run(self):\n        # Run all relevant sub-commands.  This will be some subset of:\n        #  - build_py      - pure Python modules\n        #  - build_clib    - standalone C libraries\n        #  - build_ext     - Python extensions\n        #  - build_scripts - (Python) scripts\n        for cmd_name in self.get_sub_commands():\n            self.run_command(cmd_name)\n\n    # -- Predicates for the sub-command list ---------------------------\n\n    def has_pure_modules(self):\n        return self.distribution.has_pure_modules()\n\n    def has_c_libraries(self):\n        return self.distribution.has_c_libraries()\n\n    def has_ext_modules(self):\n        return self.distribution.has_ext_modules()\n\n    def has_scripts(self):\n        return self.distribution.has_scripts()\n\n    sub_commands = [\n        ('build_py', has_pure_modules),\n        ('build_clib', has_c_libraries),\n        ('build_ext', has_ext_modules),\n        ('build_scripts', has_scripts),\n    ]\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/command/build_clib.py","size":7727,"sha1":"7de989764088101a325d44f03e5acecf8f41b329","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.command.build_clib\n\nImplements the Distutils 'build_clib' command, to build a C/C++ library\nthat is included in the module distribution and needed by an extension\nmodule.\"\"\"\n\n\n# XXX this module has *lots* of code ripped-off quite transparently from\n# build_ext.py -- not surprisingly really, as the work required to build\n# a static library from a collection of C source files is not really all\n# that different from what's required to build a shared object file from\n# a collection of C source files.  Nevertheless, I haven't done the\n# necessary refactoring to account for the overlap in code between the\n# two modules, mainly because a number of subtle details changed in the\n# cut 'n paste.  Sigh.\n\nimport os\nfrom distutils._log import log\nfrom typing import ClassVar\n\nfrom ..core import Command\nfrom ..errors import DistutilsSetupError\nfrom ..sysconfig import customize_compiler\n\n\ndef show_compilers():\n    from ..ccompiler import show_compilers\n\n    show_compilers()\n\n\nclass build_clib(Command):\n    description = \"build C/C++ libraries used by Python extensions\"\n\n    user_options: ClassVar[list[tuple[str, str, str]]] = [\n        ('build-clib=', 'b', \"directory to build C/C++ libraries to\"),\n        ('build-temp=', 't', \"directory to put temporary build by-products\"),\n        ('debug', 'g', \"compile with debugging information\"),\n        ('force', 'f', \"forcibly build everything (ignore file timestamps)\"),\n        ('compiler=', 'c', \"specify the compiler type\"),\n    ]\n\n    boolean_options = ['debug', 'force']\n\n    help_options = [\n        ('help-compiler', None, \"list available compilers\", show_compilers),\n    ]\n\n    def initialize_options(self):\n        self.build_clib = None\n        self.build_temp = None\n\n        # List of libraries to build\n        self.libraries = None\n\n        # Compilation options for all libraries\n        self.include_dirs = None\n        self.define = None\n        self.undef = None\n        self.debug = None\n        self.force = False\n        self.compiler = None\n\n    def finalize_options(self):\n        # This might be confusing: both build-clib and build-temp default\n        # to build-temp as defined by the \"build\" command.  This is because\n        # I think that C libraries are really just temporary build\n        # by-products, at least from the point of view of building Python\n        # extensions -- but I want to keep my options open.\n        self.set_undefined_options(\n            'build',\n            ('build_temp', 'build_clib'),\n            ('build_temp', 'build_temp'),\n            ('compiler', 'compiler'),\n            ('debug', 'debug'),\n            ('force', 'force'),\n        )\n\n        self.libraries = self.distribution.libraries\n        if self.libraries:\n            self.check_library_list(self.libraries)\n\n        if self.include_dirs is None:\n            self.include_dirs = self.distribution.include_dirs or []\n        if isinstance(self.include_dirs, str):\n            self.include_dirs = self.include_dirs.split(os.pathsep)\n\n        # XXX same as for build_ext -- what about 'self.define' and\n        # 'self.undef' ?\n\n    def run(self):\n        if not self.libraries:\n            return\n\n        # Yech -- this is cut 'n pasted from build_ext.py!\n        from ..ccompiler import new_compiler\n\n        self.compiler = new_compiler(\n            compiler=self.compiler, dry_run=self.dry_run, force=self.force\n        )\n        customize_compiler(self.compiler)\n\n        if self.include_dirs is not None:\n            self.compiler.set_include_dirs(self.include_dirs)\n        if self.define is not None:\n            # 'define' option is a list of (name,value) tuples\n            for name, value in self.define:\n                self.compiler.define_macro(name, value)\n        if self.undef is not None:\n            for macro in self.undef:\n                self.compiler.undefine_macro(macro)\n\n        self.build_libraries(self.libraries)\n\n    def check_library_list(self, libraries):\n        \"\"\"Ensure that the list of libraries is valid.\n\n        `library` is presumably provided as a command option 'libraries'.\n        This method checks that it is a list of 2-tuples, where the tuples\n        are (library_name, build_info_dict).\n\n        Raise DistutilsSetupError if the structure is invalid anywhere;\n        just returns otherwise.\n        \"\"\"\n        if not isinstance(libraries, list):\n            raise DistutilsSetupError(\"'libraries' option must be a list of tuples\")\n\n        for lib in libraries:\n            if not isinstance(lib, tuple) and len(lib) != 2:\n                raise DistutilsSetupError(\"each element of 'libraries' must a 2-tuple\")\n\n            name, build_info = lib\n\n            if not isinstance(name, str):\n                raise DistutilsSetupError(\n                    \"first element of each tuple in 'libraries' \"\n                    \"must be a string (the library name)\"\n                )\n\n            if '/' in name or (os.sep != '/' and os.sep in name):\n                raise DistutilsSetupError(\n                    f\"bad library name '{lib[0]}': may not contain directory separators\"\n                )\n\n            if not isinstance(build_info, dict):\n                raise DistutilsSetupError(\n                    \"second element of each tuple in 'libraries' \"\n                    \"must be a dictionary (build info)\"\n                )\n\n    def get_library_names(self):\n        # Assume the library list is valid -- 'check_library_list()' is\n        # called from 'finalize_options()', so it should be!\n        if not self.libraries:\n            return None\n\n        lib_names = []\n        for lib_name, _build_info in self.libraries:\n            lib_names.append(lib_name)\n        return lib_names\n\n    def get_source_files(self):\n        self.check_library_list(self.libraries)\n        filenames = []\n        for lib_name, build_info in self.libraries:\n            sources = build_info.get('sources')\n            if sources is None or not isinstance(sources, (list, tuple)):\n                raise DistutilsSetupError(\n                    f\"in 'libraries' option (library '{lib_name}'), \"\n                    \"'sources' must be present and must be \"\n                    \"a list of source filenames\"\n                )\n\n            filenames.extend(sources)\n        return filenames\n\n    def build_libraries(self, libraries):\n        for lib_name, build_info in libraries:\n            sources = build_info.get('sources')\n            if sources is None or not isinstance(sources, (list, tuple)):\n                raise DistutilsSetupError(\n                    f\"in 'libraries' option (library '{lib_name}'), \"\n                    \"'sources' must be present and must be \"\n                    \"a list of source filenames\"\n                )\n            sources = list(sources)\n\n            log.info(\"building '%s' library\", lib_name)\n\n            # First, compile the source code to object files in the library\n            # directory.  (This should probably change to putting object\n            # files in a temporary build directory.)\n            macros = build_info.get('macros')\n            include_dirs = build_info.get('include_dirs')\n            objects = self.compiler.compile(\n                sources,\n                output_dir=self.build_temp,\n                macros=macros,\n                include_dirs=include_dirs,\n                debug=self.debug,\n            )\n\n            # Now \"link\" the object files together into a static library.\n            # (On Unix at least, this isn't really linking -- it just\n            # builds an archive.  Whatever.)\n            self.compiler.create_static_lib(\n                objects, lib_name, output_dir=self.build_clib, debug=self.debug\n            )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/command/build_ext.py","size":32048,"sha1":"40f3b0f8a2378ec58fcbfe9988c6efb213faa32e","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.command.build_ext\n\nImplements the Distutils 'build_ext' command, for building extension\nmodules (currently limited to C extensions, should accommodate C++\nextensions ASAP).\"\"\"\n\nimport contextlib\nimport os\nimport re\nimport sys\nfrom distutils._log import log\nfrom site import USER_BASE\n\nfrom .._modified import newer_group\nfrom ..core import Command\nfrom ..errors import (\n    CCompilerError,\n    CompileError,\n    DistutilsError,\n    DistutilsOptionError,\n    DistutilsPlatformError,\n    DistutilsSetupError,\n)\nfrom ..extension import Extension\nfrom ..sysconfig import customize_compiler, get_config_h_filename, get_python_version\nfrom ..util import get_platform, is_freethreaded, is_mingw\n\n# An extension name is just a dot-separated list of Python NAMEs (ie.\n# the same as a fully-qualified module name).\nextension_name_re = re.compile(r'^[a-zA-Z_][a-zA-Z_0-9]*(\\.[a-zA-Z_][a-zA-Z_0-9]*)*$')\n\n\ndef show_compilers():\n    from ..ccompiler import show_compilers\n\n    show_compilers()\n\n\nclass build_ext(Command):\n    description = \"build C/C++ extensions (compile/link to build directory)\"\n\n    # XXX thoughts on how to deal with complex command-line options like\n    # these, i.e. how to make it so fancy_getopt can suck them off the\n    # command line and make it look like setup.py defined the appropriate\n    # lists of tuples of what-have-you.\n    #   - each command needs a callback to process its command-line options\n    #   - Command.__init__() needs access to its share of the whole\n    #     command line (must ultimately come from\n    #     Distribution.parse_command_line())\n    #   - it then calls the current command class' option-parsing\n    #     callback to deal with weird options like -D, which have to\n    #     parse the option text and churn out some custom data\n    #     structure\n    #   - that data structure (in this case, a list of 2-tuples)\n    #     will then be present in the command object by the time\n    #     we get to finalize_options() (i.e. the constructor\n    #     takes care of both command-line and client options\n    #     in between initialize_options() and finalize_options())\n\n    sep_by = f\" (separated by '{os.pathsep}')\"\n    user_options = [\n        ('build-lib=', 'b', \"directory for compiled extension modules\"),\n        ('build-temp=', 't', \"directory for temporary files (build by-products)\"),\n        (\n            'plat-name=',\n            'p',\n            \"platform name to cross-compile for, if supported \"\n            f\"[default: {get_platform()}]\",\n        ),\n        (\n            'inplace',\n            'i',\n            \"ignore build-lib and put compiled extensions into the source \"\n            \"directory alongside your pure Python modules\",\n        ),\n        (\n            'include-dirs=',\n            'I',\n            \"list of directories to search for header files\" + sep_by,\n        ),\n        ('define=', 'D', \"C preprocessor macros to define\"),\n        ('undef=', 'U', \"C preprocessor macros to undefine\"),\n        ('libraries=', 'l', \"external C libraries to link with\"),\n        (\n            'library-dirs=',\n            'L',\n            \"directories to search for external C libraries\" + sep_by,\n        ),\n        ('rpath=', 'R', \"directories to search for shared C libraries at runtime\"),\n        ('link-objects=', 'O', \"extra explicit link objects to include in the link\"),\n        ('debug', 'g', \"compile/link with debugging information\"),\n        ('force', 'f', \"forcibly build everything (ignore file timestamps)\"),\n        ('compiler=', 'c', \"specify the compiler type\"),\n        ('parallel=', 'j', \"number of parallel build jobs\"),\n        ('swig-cpp', None, \"make SWIG create C++ files (default is C)\"),\n        ('swig-opts=', None, \"list of SWIG command line options\"),\n        ('swig=', None, \"path to the SWIG executable\"),\n        ('user', None, \"add user include, library and rpath\"),\n    ]\n\n    boolean_options = ['inplace', 'debug', 'force', 'swig-cpp', 'user']\n\n    help_options = [\n        ('help-compiler', None, \"list available compilers\", show_compilers),\n    ]\n\n    def initialize_options(self):\n        self.extensions = None\n        self.build_lib = None\n        self.plat_name = None\n        self.build_temp = None\n        self.inplace = False\n        self.package = None\n\n        self.include_dirs = None\n        self.define = None\n        self.undef = None\n        self.libraries = None\n        self.library_dirs = None\n        self.rpath = None\n        self.link_objects = None\n        self.debug = None\n        self.force = None\n        self.compiler = None\n        self.swig = None\n        self.swig_cpp = None\n        self.swig_opts = None\n        self.user = None\n        self.parallel = None\n\n    @staticmethod\n    def _python_lib_dir(sysconfig):\n        \"\"\"\n        Resolve Python's library directory for building extensions\n        that rely on a shared Python library.\n\n        See python/cpython#44264 and python/cpython#48686\n        \"\"\"\n        if not sysconfig.get_config_var('Py_ENABLE_SHARED'):\n            return\n\n        if sysconfig.python_build:\n            yield '.'\n            return\n\n        if sys.platform == 'zos':\n            # On z/OS, a user is not required to install Python to\n            # a predetermined path, but can use Python portably\n            installed_dir = sysconfig.get_config_var('base')\n            lib_dir = sysconfig.get_config_var('platlibdir')\n            yield os.path.join(installed_dir, lib_dir)\n        else:\n            # building third party extensions\n            yield sysconfig.get_config_var('LIBDIR')\n\n    def finalize_options(self):  # noqa: C901\n        from distutils import sysconfig\n\n        self.set_undefined_options(\n            'build',\n            ('build_lib', 'build_lib'),\n            ('build_temp', 'build_temp'),\n            ('compiler', 'compiler'),\n            ('debug', 'debug'),\n            ('force', 'force'),\n            ('parallel', 'parallel'),\n            ('plat_name', 'plat_name'),\n        )\n\n        if self.package is None:\n            self.package = self.distribution.ext_package\n\n        self.extensions = self.distribution.ext_modules\n\n        # Make sure Python's include directories (for Python.h, pyconfig.h,\n        # etc.) are in the include search path.\n        py_include = sysconfig.get_python_inc()\n        plat_py_include = sysconfig.get_python_inc(plat_specific=True)\n        if self.include_dirs is None:\n            self.include_dirs = self.distribution.include_dirs or []\n        if isinstance(self.include_dirs, str):\n            self.include_dirs = self.include_dirs.split(os.pathsep)\n\n        # If in a virtualenv, add its include directory\n        # Issue 16116\n        if sys.exec_prefix != sys.base_exec_prefix:\n            self.include_dirs.append(os.path.join(sys.exec_prefix, 'include'))\n\n        # Put the Python \"system\" include dir at the end, so that\n        # any local include dirs take precedence.\n        self.include_dirs.extend(py_include.split(os.path.pathsep))\n        if plat_py_include != py_include:\n            self.include_dirs.extend(plat_py_include.split(os.path.pathsep))\n\n        self.ensure_string_list('libraries')\n        self.ensure_string_list('link_objects')\n\n        # Life is easier if we're not forever checking for None, so\n        # simplify these options to empty lists if unset\n        if self.libraries is None:\n            self.libraries = []\n        if self.library_dirs is None:\n            self.library_dirs = []\n        elif isinstance(self.library_dirs, str):\n            self.library_dirs = self.library_dirs.split(os.pathsep)\n\n        if self.rpath is None:\n            self.rpath = []\n        elif isinstance(self.rpath, str):\n            self.rpath = self.rpath.split(os.pathsep)\n\n        # for extensions under windows use different directories\n        # for Release and Debug builds.\n        # also Python's library directory must be appended to library_dirs\n        if os.name == 'nt' and not is_mingw():\n            # the 'libs' directory is for binary installs - we assume that\n            # must be the *native* platform.  But we don't really support\n            # cross-compiling via a binary install anyway, so we let it go.\n            self.library_dirs.append(os.path.join(sys.exec_prefix, 'libs'))\n            if sys.base_exec_prefix != sys.prefix:  # Issue 16116\n                self.library_dirs.append(os.path.join(sys.base_exec_prefix, 'libs'))\n            if self.debug:\n                self.build_temp = os.path.join(self.build_temp, \"Debug\")\n            else:\n                self.build_temp = os.path.join(self.build_temp, \"Release\")\n\n            # Append the source distribution include and library directories,\n            # this allows distutils on windows to work in the source tree\n            self.include_dirs.append(os.path.dirname(get_config_h_filename()))\n            self.library_dirs.append(sys.base_exec_prefix)\n\n            # Use the .lib files for the correct architecture\n            if self.plat_name == 'win32':\n                suffix = 'win32'\n            else:\n                # win-amd64\n                suffix = self.plat_name[4:]\n            new_lib = os.path.join(sys.exec_prefix, 'PCbuild')\n            if suffix:\n                new_lib = os.path.join(new_lib, suffix)\n            self.library_dirs.append(new_lib)\n\n        # For extensions under Cygwin, Python's library directory must be\n        # appended to library_dirs\n        if sys.platform[:6] == 'cygwin':\n            if not sysconfig.python_build:\n                # building third party extensions\n                self.library_dirs.append(\n                    os.path.join(\n                        sys.prefix, \"lib\", \"python\" + get_python_version(), \"config\"\n                    )\n                )\n            else:\n                # building python standard extensions\n                self.library_dirs.append('.')\n\n        self.library_dirs.extend(self._python_lib_dir(sysconfig))\n\n        # The argument parsing will result in self.define being a string, but\n        # it has to be a list of 2-tuples.  All the preprocessor symbols\n        # specified by the 'define' option will be set to '1'.  Multiple\n        # symbols can be separated with commas.\n\n        if self.define:\n            defines = self.define.split(',')\n            self.define = [(symbol, '1') for symbol in defines]\n\n        # The option for macros to undefine is also a string from the\n        # option parsing, but has to be a list.  Multiple symbols can also\n        # be separated with commas here.\n        if self.undef:\n            self.undef = self.undef.split(',')\n\n        if self.swig_opts is None:\n            self.swig_opts = []\n        else:\n            self.swig_opts = self.swig_opts.split(' ')\n\n        # Finally add the user include and library directories if requested\n        if self.user:\n            user_include = os.path.join(USER_BASE, \"include\")\n            user_lib = os.path.join(USER_BASE, \"lib\")\n            if os.path.isdir(user_include):\n                self.include_dirs.append(user_include)\n            if os.path.isdir(user_lib):\n                self.library_dirs.append(user_lib)\n                self.rpath.append(user_lib)\n\n        if isinstance(self.parallel, str):\n            try:\n                self.parallel = int(self.parallel)\n            except ValueError:\n                raise DistutilsOptionError(\"parallel should be an integer\")\n\n    def run(self):  # noqa: C901\n        from ..ccompiler import new_compiler\n\n        # 'self.extensions', as supplied by setup.py, is a list of\n        # Extension instances.  See the documentation for Extension (in\n        # distutils.extension) for details.\n        #\n        # For backwards compatibility with Distutils 0.8.2 and earlier, we\n        # also allow the 'extensions' list to be a list of tuples:\n        #    (ext_name, build_info)\n        # where build_info is a dictionary containing everything that\n        # Extension instances do except the name, with a few things being\n        # differently named.  We convert these 2-tuples to Extension\n        # instances as needed.\n\n        if not self.extensions:\n            return\n\n        # If we were asked to build any C/C++ libraries, make sure that the\n        # directory where we put them is in the library search path for\n        # linking extensions.\n        if self.distribution.has_c_libraries():\n            build_clib = self.get_finalized_command('build_clib')\n            self.libraries.extend(build_clib.get_library_names() or [])\n            self.library_dirs.append(build_clib.build_clib)\n\n        # Setup the CCompiler object that we'll use to do all the\n        # compiling and linking\n        self.compiler = new_compiler(\n            compiler=self.compiler,\n            verbose=self.verbose,\n            dry_run=self.dry_run,\n            force=self.force,\n        )\n        customize_compiler(self.compiler)\n        # If we are cross-compiling, init the compiler now (if we are not\n        # cross-compiling, init would not hurt, but people may rely on\n        # late initialization of compiler even if they shouldn't...)\n        if os.name == 'nt' and self.plat_name != get_platform():\n            self.compiler.initialize(self.plat_name)\n\n        # The official Windows free threaded Python installer doesn't set\n        # Py_GIL_DISABLED because its pyconfig.h is shared with the\n        # default build, so define it here (pypa/setuptools#4662).\n        if os.name == 'nt' and is_freethreaded():\n            self.compiler.define_macro('Py_GIL_DISABLED', '1')\n\n        # And make sure that any compile/link-related options (which might\n        # come from the command-line or from the setup script) are set in\n        # that CCompiler object -- that way, they automatically apply to\n        # all compiling and linking done here.\n        if self.include_dirs is not None:\n            self.compiler.set_include_dirs(self.include_dirs)\n        if self.define is not None:\n            # 'define' option is a list of (name,value) tuples\n            for name, value in self.define:\n                self.compiler.define_macro(name, value)\n        if self.undef is not None:\n            for macro in self.undef:\n                self.compiler.undefine_macro(macro)\n        if self.libraries is not None:\n            self.compiler.set_libraries(self.libraries)\n        if self.library_dirs is not None:\n            self.compiler.set_library_dirs(self.library_dirs)\n        if self.rpath is not None:\n            self.compiler.set_runtime_library_dirs(self.rpath)\n        if self.link_objects is not None:\n            self.compiler.set_link_objects(self.link_objects)\n\n        # Now actually compile and link everything.\n        self.build_extensions()\n\n    def check_extensions_list(self, extensions):  # noqa: C901\n        \"\"\"Ensure that the list of extensions (presumably provided as a\n        command option 'extensions') is valid, i.e. it is a list of\n        Extension objects.  We also support the old-style list of 2-tuples,\n        where the tuples are (ext_name, build_info), which are converted to\n        Extension instances here.\n\n        Raise DistutilsSetupError if the structure is invalid anywhere;\n        just returns otherwise.\n        \"\"\"\n        if not isinstance(extensions, list):\n            raise DistutilsSetupError(\n                \"'ext_modules' option must be a list of Extension instances\"\n            )\n\n        for i, ext in enumerate(extensions):\n            if isinstance(ext, Extension):\n                continue  # OK! (assume type-checking done\n                # by Extension constructor)\n\n            if not isinstance(ext, tuple) or len(ext) != 2:\n                raise DistutilsSetupError(\n                    \"each element of 'ext_modules' option must be an \"\n                    \"Extension instance or 2-tuple\"\n                )\n\n            ext_name, build_info = ext\n\n            log.warning(\n                \"old-style (ext_name, build_info) tuple found in \"\n                \"ext_modules for extension '%s' \"\n                \"-- please convert to Extension instance\",\n                ext_name,\n            )\n\n            if not (isinstance(ext_name, str) and extension_name_re.match(ext_name)):\n                raise DistutilsSetupError(\n                    \"first element of each tuple in 'ext_modules' \"\n                    \"must be the extension name (a string)\"\n                )\n\n            if not isinstance(build_info, dict):\n                raise DistutilsSetupError(\n                    \"second element of each tuple in 'ext_modules' \"\n                    \"must be a dictionary (build info)\"\n                )\n\n            # OK, the (ext_name, build_info) dict is type-safe: convert it\n            # to an Extension instance.\n            ext = Extension(ext_name, build_info['sources'])\n\n            # Easy stuff: one-to-one mapping from dict elements to\n            # instance attributes.\n            for key in (\n                'include_dirs',\n                'library_dirs',\n                'libraries',\n                'extra_objects',\n                'extra_compile_args',\n                'extra_link_args',\n            ):\n                val = build_info.get(key)\n                if val is not None:\n                    setattr(ext, key, val)\n\n            # Medium-easy stuff: same syntax/semantics, different names.\n            ext.runtime_library_dirs = build_info.get('rpath')\n            if 'def_file' in build_info:\n                log.warning(\"'def_file' element of build info dict no longer supported\")\n\n            # Non-trivial stuff: 'macros' split into 'define_macros'\n            # and 'undef_macros'.\n            macros = build_info.get('macros')\n            if macros:\n                ext.define_macros = []\n                ext.undef_macros = []\n                for macro in macros:\n                    if not (isinstance(macro, tuple) and len(macro) in (1, 2)):\n                        raise DistutilsSetupError(\n                            \"'macros' element of build info dict must be 1- or 2-tuple\"\n                        )\n                    if len(macro) == 1:\n                        ext.undef_macros.append(macro[0])\n                    elif len(macro) == 2:\n                        ext.define_macros.append(macro)\n\n            extensions[i] = ext\n\n    def get_source_files(self):\n        self.check_extensions_list(self.extensions)\n        filenames = []\n\n        # Wouldn't it be neat if we knew the names of header files too...\n        for ext in self.extensions:\n            filenames.extend(ext.sources)\n        return filenames\n\n    def get_outputs(self):\n        # Sanity check the 'extensions' list -- can't assume this is being\n        # done in the same run as a 'build_extensions()' call (in fact, we\n        # can probably assume that it *isn't*!).\n        self.check_extensions_list(self.extensions)\n\n        # And build the list of output (built) filenames.  Note that this\n        # ignores the 'inplace' flag, and assumes everything goes in the\n        # \"build\" tree.\n        return [self.get_ext_fullpath(ext.name) for ext in self.extensions]\n\n    def build_extensions(self):\n        # First, sanity-check the 'extensions' list\n        self.check_extensions_list(self.extensions)\n        if self.parallel:\n            self._build_extensions_parallel()\n        else:\n            self._build_extensions_serial()\n\n    def _build_extensions_parallel(self):\n        workers = self.parallel\n        if self.parallel is True:\n            workers = os.cpu_count()  # may return None\n        try:\n            from concurrent.futures import ThreadPoolExecutor\n        except ImportError:\n            workers = None\n\n        if workers is None:\n            self._build_extensions_serial()\n            return\n\n        with ThreadPoolExecutor(max_workers=workers) as executor:\n            futures = [\n                executor.submit(self.build_extension, ext) for ext in self.extensions\n            ]\n            for ext, fut in zip(self.extensions, futures):\n                with self._filter_build_errors(ext):\n                    fut.result()\n\n    def _build_extensions_serial(self):\n        for ext in self.extensions:\n            with self._filter_build_errors(ext):\n                self.build_extension(ext)\n\n    @contextlib.contextmanager\n    def _filter_build_errors(self, ext):\n        try:\n            yield\n        except (CCompilerError, DistutilsError, CompileError) as e:\n            if not ext.optional:\n                raise\n            self.warn(f'building extension \"{ext.name}\" failed: {e}')\n\n    def build_extension(self, ext):\n        sources = ext.sources\n        if sources is None or not isinstance(sources, (list, tuple)):\n            raise DistutilsSetupError(\n                f\"in 'ext_modules' option (extension '{ext.name}'), \"\n                \"'sources' must be present and must be \"\n                \"a list of source filenames\"\n            )\n        # sort to make the resulting .so file build reproducible\n        sources = sorted(sources)\n\n        ext_path = self.get_ext_fullpath(ext.name)\n        depends = sources + ext.depends\n        if not (self.force or newer_group(depends, ext_path, 'newer')):\n            log.debug(\"skipping '%s' extension (up-to-date)\", ext.name)\n            return\n        else:\n            log.info(\"building '%s' extension\", ext.name)\n\n        # First, scan the sources for SWIG definition files (.i), run\n        # SWIG on 'em to create .c files, and modify the sources list\n        # accordingly.\n        sources = self.swig_sources(sources, ext)\n\n        # Next, compile the source code to object files.\n\n        # XXX not honouring 'define_macros' or 'undef_macros' -- the\n        # CCompiler API needs to change to accommodate this, and I\n        # want to do one thing at a time!\n\n        # Two possible sources for extra compiler arguments:\n        #   - 'extra_compile_args' in Extension object\n        #   - CFLAGS environment variable (not particularly\n        #     elegant, but people seem to expect it and I\n        #     guess it's useful)\n        # The environment variable should take precedence, and\n        # any sensible compiler will give precedence to later\n        # command line args.  Hence we combine them in order:\n        extra_args = ext.extra_compile_args or []\n\n        macros = ext.define_macros[:]\n        for undef in ext.undef_macros:\n            macros.append((undef,))\n\n        objects = self.compiler.compile(\n            sources,\n            output_dir=self.build_temp,\n            macros=macros,\n            include_dirs=ext.include_dirs,\n            debug=self.debug,\n            extra_postargs=extra_args,\n            depends=ext.depends,\n        )\n\n        # XXX outdated variable, kept here in case third-part code\n        # needs it.\n        self._built_objects = objects[:]\n\n        # Now link the object files together into a \"shared object\" --\n        # of course, first we have to figure out all the other things\n        # that go into the mix.\n        if ext.extra_objects:\n            objects.extend(ext.extra_objects)\n        extra_args = ext.extra_link_args or []\n\n        # Detect target language, if not provided\n        language = ext.language or self.compiler.detect_language(sources)\n\n        self.compiler.link_shared_object(\n            objects,\n            ext_path,\n            libraries=self.get_libraries(ext),\n            library_dirs=ext.library_dirs,\n            runtime_library_dirs=ext.runtime_library_dirs,\n            extra_postargs=extra_args,\n            export_symbols=self.get_export_symbols(ext),\n            debug=self.debug,\n            build_temp=self.build_temp,\n            target_lang=language,\n        )\n\n    def swig_sources(self, sources, extension):\n        \"\"\"Walk the list of source files in 'sources', looking for SWIG\n        interface (.i) files.  Run SWIG on all that are found, and\n        return a modified 'sources' list with SWIG source files replaced\n        by the generated C (or C++) files.\n        \"\"\"\n        new_sources = []\n        swig_sources = []\n        swig_targets = {}\n\n        # XXX this drops generated C/C++ files into the source tree, which\n        # is fine for developers who want to distribute the generated\n        # source -- but there should be an option to put SWIG output in\n        # the temp dir.\n\n        if self.swig_cpp:\n            log.warning(\"--swig-cpp is deprecated - use --swig-opts=-c++\")\n\n        if (\n            self.swig_cpp\n            or ('-c++' in self.swig_opts)\n            or ('-c++' in extension.swig_opts)\n        ):\n            target_ext = '.cpp'\n        else:\n            target_ext = '.c'\n\n        for source in sources:\n            (base, ext) = os.path.splitext(source)\n            if ext == \".i\":  # SWIG interface file\n                new_sources.append(base + '_wrap' + target_ext)\n                swig_sources.append(source)\n                swig_targets[source] = new_sources[-1]\n            else:\n                new_sources.append(source)\n\n        if not swig_sources:\n            return new_sources\n\n        swig = self.swig or self.find_swig()\n        swig_cmd = [swig, \"-python\"]\n        swig_cmd.extend(self.swig_opts)\n        if self.swig_cpp:\n            swig_cmd.append(\"-c++\")\n\n        # Do not override commandline arguments\n        if not self.swig_opts:\n            swig_cmd.extend(extension.swig_opts)\n\n        for source in swig_sources:\n            target = swig_targets[source]\n            log.info(\"swigging %s to %s\", source, target)\n            self.spawn(swig_cmd + [\"-o\", target, source])\n\n        return new_sources\n\n    def find_swig(self):\n        \"\"\"Return the name of the SWIG executable.  On Unix, this is\n        just \"swig\" -- it should be in the PATH.  Tries a bit harder on\n        Windows.\n        \"\"\"\n        if os.name == \"posix\":\n            return \"swig\"\n        elif os.name == \"nt\":\n            # Look for SWIG in its standard installation directory on\n            # Windows (or so I presume!).  If we find it there, great;\n            # if not, act like Unix and assume it's in the PATH.\n            for vers in (\"1.3\", \"1.2\", \"1.1\"):\n                fn = os.path.join(f\"c:\\\\swig{vers}\", \"swig.exe\")\n                if os.path.isfile(fn):\n                    return fn\n            else:\n                return \"swig.exe\"\n        else:\n            raise DistutilsPlatformError(\n                f\"I don't know how to find (much less run) SWIG on platform '{os.name}'\"\n            )\n\n    # -- Name generators -----------------------------------------------\n    # (extension names, filenames, whatever)\n    def get_ext_fullpath(self, ext_name):\n        \"\"\"Returns the path of the filename for a given extension.\n\n        The file is located in `build_lib` or directly in the package\n        (inplace option).\n        \"\"\"\n        fullname = self.get_ext_fullname(ext_name)\n        modpath = fullname.split('.')\n        filename = self.get_ext_filename(modpath[-1])\n\n        if not self.inplace:\n            # no further work needed\n            # returning :\n            #   build_dir/package/path/filename\n            filename = os.path.join(*modpath[:-1] + [filename])\n            return os.path.join(self.build_lib, filename)\n\n        # the inplace option requires to find the package directory\n        # using the build_py command for that\n        package = '.'.join(modpath[0:-1])\n        build_py = self.get_finalized_command('build_py')\n        package_dir = os.path.abspath(build_py.get_package_dir(package))\n\n        # returning\n        #   package_dir/filename\n        return os.path.join(package_dir, filename)\n\n    def get_ext_fullname(self, ext_name):\n        \"\"\"Returns the fullname of a given extension name.\n\n        Adds the `package.` prefix\"\"\"\n        if self.package is None:\n            return ext_name\n        else:\n            return self.package + '.' + ext_name\n\n    def get_ext_filename(self, ext_name):\n        r\"\"\"Convert the name of an extension (eg. \"foo.bar\") into the name\n        of the file from which it will be loaded (eg. \"foo/bar.so\", or\n        \"foo\\bar.pyd\").\n        \"\"\"\n        from ..sysconfig import get_config_var\n\n        ext_path = ext_name.split('.')\n        ext_suffix = get_config_var('EXT_SUFFIX')\n        return os.path.join(*ext_path) + ext_suffix\n\n    def get_export_symbols(self, ext):\n        \"\"\"Return the list of symbols that a shared extension has to\n        export.  This either uses 'ext.export_symbols' or, if it's not\n        provided, \"PyInit_\" + module_name.  Only relevant on Windows, where\n        the .pyd file (DLL) must export the module \"PyInit_\" function.\n        \"\"\"\n        name = ext.name.split('.')[-1]\n        try:\n            # Unicode module name support as defined in PEP-489\n            # https://peps.python.org/pep-0489/#export-hook-name\n            name.encode('ascii')\n        except UnicodeEncodeError:\n            suffix = 'U_' + name.encode('punycode').replace(b'-', b'_').decode('ascii')\n        else:\n            suffix = \"_\" + name\n\n        initfunc_name = \"PyInit\" + suffix\n        if initfunc_name not in ext.export_symbols:\n            ext.export_symbols.append(initfunc_name)\n        return ext.export_symbols\n\n    def get_libraries(self, ext):  # noqa: C901\n        \"\"\"Return the list of libraries to link against when building a\n        shared extension.  On most platforms, this is just 'ext.libraries';\n        on Windows, we add the Python library (eg. python20.dll).\n        \"\"\"\n        # The python library is always needed on Windows.  For MSVC, this\n        # is redundant, since the library is mentioned in a pragma in\n        # pyconfig.h that MSVC groks.  The other Windows compilers all seem\n        # to need it mentioned explicitly, though, so that's what we do.\n        # Append '_d' to the python import library on debug builds.\n        if sys.platform == \"win32\" and not is_mingw():\n            from .._msvccompiler import MSVCCompiler\n\n            if not isinstance(self.compiler, MSVCCompiler):\n                template = \"python%d%d\"\n                if self.debug:\n                    template = template + '_d'\n                pythonlib = template % (\n                    sys.hexversion >> 24,\n                    (sys.hexversion >> 16) & 0xFF,\n                )\n                # don't extend ext.libraries, it may be shared with other\n                # extensions, it is a reference to the original list\n                return ext.libraries + [pythonlib]\n        else:\n            # On Android only the main executable and LD_PRELOADs are considered\n            # to be RTLD_GLOBAL, all the dependencies of the main executable\n            # remain RTLD_LOCAL and so the shared libraries must be linked with\n            # libpython when python is built with a shared python library (issue\n            # bpo-21536).\n            # On Cygwin (and if required, other POSIX-like platforms based on\n            # Windows like MinGW) it is simply necessary that all symbols in\n            # shared libraries are resolved at link time.\n            from ..sysconfig import get_config_var\n\n            link_libpython = False\n            if get_config_var('Py_ENABLE_SHARED'):\n                # A native build on an Android device or on Cygwin\n                if hasattr(sys, 'getandroidapilevel'):\n                    link_libpython = True\n                elif sys.platform == 'cygwin' or is_mingw():\n                    link_libpython = True\n                elif '_PYTHON_HOST_PLATFORM' in os.environ:\n                    # We are cross-compiling for one of the relevant platforms\n                    if get_config_var('ANDROID_API_LEVEL') != 0:\n                        link_libpython = True\n                    elif get_config_var('MACHDEP') == 'cygwin':\n                        link_libpython = True\n\n            if link_libpython:\n                ldversion = get_config_var('LDVERSION')\n                return ext.libraries + ['python' + ldversion]\n\n        return ext.libraries\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/command/build_py.py","size":16552,"sha1":"2a03eb6d3f8bf03150c808080b50fbe2875f27ef","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.command.build_py\n\nImplements the Distutils 'build_py' command.\"\"\"\n\nimport glob\nimport importlib.util\nimport os\nimport sys\nfrom distutils._log import log\n\nfrom ..core import Command\nfrom ..errors import DistutilsFileError, DistutilsOptionError\nfrom ..util import convert_path\n\n\nclass build_py(Command):\n    description = \"\\\"build\\\" pure Python modules (copy to build directory)\"\n\n    user_options = [\n        ('build-lib=', 'd', \"directory to \\\"build\\\" (copy) to\"),\n        ('compile', 'c', \"compile .py to .pyc\"),\n        ('no-compile', None, \"don't compile .py files [default]\"),\n        (\n            'optimize=',\n            'O',\n            \"also compile with optimization: -O1 for \\\"python -O\\\", \"\n            \"-O2 for \\\"python -OO\\\", and -O0 to disable [default: -O0]\",\n        ),\n        ('force', 'f', \"forcibly build everything (ignore file timestamps)\"),\n    ]\n\n    boolean_options = ['compile', 'force']\n    negative_opt = {'no-compile': 'compile'}\n\n    def initialize_options(self):\n        self.build_lib = None\n        self.py_modules = None\n        self.package = None\n        self.package_data = None\n        self.package_dir = None\n        self.compile = False\n        self.optimize = 0\n        self.force = None\n\n    def finalize_options(self):\n        self.set_undefined_options(\n            'build', ('build_lib', 'build_lib'), ('force', 'force')\n        )\n\n        # Get the distribution options that are aliases for build_py\n        # options -- list of packages and list of modules.\n        self.packages = self.distribution.packages\n        self.py_modules = self.distribution.py_modules\n        self.package_data = self.distribution.package_data\n        self.package_dir = {}\n        if self.distribution.package_dir:\n            for name, path in self.distribution.package_dir.items():\n                self.package_dir[name] = convert_path(path)\n        self.data_files = self.get_data_files()\n\n        # Ick, copied straight from install_lib.py (fancy_getopt needs a\n        # type system!  Hell, *everything* needs a type system!!!)\n        if not isinstance(self.optimize, int):\n            try:\n                self.optimize = int(self.optimize)\n                assert 0 <= self.optimize <= 2\n            except (ValueError, AssertionError):\n                raise DistutilsOptionError(\"optimize must be 0, 1, or 2\")\n\n    def run(self):\n        # XXX copy_file by default preserves atime and mtime.  IMHO this is\n        # the right thing to do, but perhaps it should be an option -- in\n        # particular, a site administrator might want installed files to\n        # reflect the time of installation rather than the last\n        # modification time before the installed release.\n\n        # XXX copy_file by default preserves mode, which appears to be the\n        # wrong thing to do: if a file is read-only in the working\n        # directory, we want it to be installed read/write so that the next\n        # installation of the same module distribution can overwrite it\n        # without problems.  (This might be a Unix-specific issue.)  Thus\n        # we turn off 'preserve_mode' when copying to the build directory,\n        # since the build directory is supposed to be exactly what the\n        # installation will look like (ie. we preserve mode when\n        # installing).\n\n        # Two options control which modules will be installed: 'packages'\n        # and 'py_modules'.  The former lets us work with whole packages, not\n        # specifying individual modules at all; the latter is for\n        # specifying modules one-at-a-time.\n\n        if self.py_modules:\n            self.build_modules()\n        if self.packages:\n            self.build_packages()\n            self.build_package_data()\n\n        self.byte_compile(self.get_outputs(include_bytecode=False))\n\n    def get_data_files(self):\n        \"\"\"Generate list of '(package,src_dir,build_dir,filenames)' tuples\"\"\"\n        data = []\n        if not self.packages:\n            return data\n        for package in self.packages:\n            # Locate package source directory\n            src_dir = self.get_package_dir(package)\n\n            # Compute package build directory\n            build_dir = os.path.join(*([self.build_lib] + package.split('.')))\n\n            # Length of path to strip from found files\n            plen = 0\n            if src_dir:\n                plen = len(src_dir) + 1\n\n            # Strip directory from globbed filenames\n            filenames = [file[plen:] for file in self.find_data_files(package, src_dir)]\n            data.append((package, src_dir, build_dir, filenames))\n        return data\n\n    def find_data_files(self, package, src_dir):\n        \"\"\"Return filenames for package's data files in 'src_dir'\"\"\"\n        globs = self.package_data.get('', []) + self.package_data.get(package, [])\n        files = []\n        for pattern in globs:\n            # Each pattern has to be converted to a platform-specific path\n            filelist = glob.glob(\n                os.path.join(glob.escape(src_dir), convert_path(pattern))\n            )\n            # Files that match more than one pattern are only added once\n            files.extend([\n                fn for fn in filelist if fn not in files and os.path.isfile(fn)\n            ])\n        return files\n\n    def build_package_data(self):\n        \"\"\"Copy data files into build directory\"\"\"\n        for _package, src_dir, build_dir, filenames in self.data_files:\n            for filename in filenames:\n                target = os.path.join(build_dir, filename)\n                self.mkpath(os.path.dirname(target))\n                self.copy_file(\n                    os.path.join(src_dir, filename), target, preserve_mode=False\n                )\n\n    def get_package_dir(self, package):\n        \"\"\"Return the directory, relative to the top of the source\n        distribution, where package 'package' should be found\n        (at least according to the 'package_dir' option, if any).\"\"\"\n        path = package.split('.')\n\n        if not self.package_dir:\n            if path:\n                return os.path.join(*path)\n            else:\n                return ''\n        else:\n            tail = []\n            while path:\n                try:\n                    pdir = self.package_dir['.'.join(path)]\n                except KeyError:\n                    tail.insert(0, path[-1])\n                    del path[-1]\n                else:\n                    tail.insert(0, pdir)\n                    return os.path.join(*tail)\n            else:\n                # Oops, got all the way through 'path' without finding a\n                # match in package_dir.  If package_dir defines a directory\n                # for the root (nameless) package, then fallback on it;\n                # otherwise, we might as well have not consulted\n                # package_dir at all, as we just use the directory implied\n                # by 'tail' (which should be the same as the original value\n                # of 'path' at this point).\n                pdir = self.package_dir.get('')\n                if pdir is not None:\n                    tail.insert(0, pdir)\n\n                if tail:\n                    return os.path.join(*tail)\n                else:\n                    return ''\n\n    def check_package(self, package, package_dir):\n        # Empty dir name means current directory, which we can probably\n        # assume exists.  Also, os.path.exists and isdir don't know about\n        # my \"empty string means current dir\" convention, so we have to\n        # circumvent them.\n        if package_dir != \"\":\n            if not os.path.exists(package_dir):\n                raise DistutilsFileError(\n                    f\"package directory '{package_dir}' does not exist\"\n                )\n            if not os.path.isdir(package_dir):\n                raise DistutilsFileError(\n                    f\"supposed package directory '{package_dir}' exists, \"\n                    \"but is not a directory\"\n                )\n\n        # Directories without __init__.py are namespace packages (PEP 420).\n        if package:\n            init_py = os.path.join(package_dir, \"__init__.py\")\n            if os.path.isfile(init_py):\n                return init_py\n\n        # Either not in a package at all (__init__.py not expected), or\n        # __init__.py doesn't exist -- so don't return the filename.\n        return None\n\n    def check_module(self, module, module_file):\n        if not os.path.isfile(module_file):\n            log.warning(\"file %s (for module %s) not found\", module_file, module)\n            return False\n        else:\n            return True\n\n    def find_package_modules(self, package, package_dir):\n        self.check_package(package, package_dir)\n        module_files = glob.glob(os.path.join(glob.escape(package_dir), \"*.py\"))\n        modules = []\n        setup_script = os.path.abspath(self.distribution.script_name)\n\n        for f in module_files:\n            abs_f = os.path.abspath(f)\n            if abs_f != setup_script:\n                module = os.path.splitext(os.path.basename(f))[0]\n                modules.append((package, module, f))\n            else:\n                self.debug_print(f\"excluding {setup_script}\")\n        return modules\n\n    def find_modules(self):\n        \"\"\"Finds individually-specified Python modules, ie. those listed by\n        module name in 'self.py_modules'.  Returns a list of tuples (package,\n        module_base, filename): 'package' is a tuple of the path through\n        package-space to the module; 'module_base' is the bare (no\n        packages, no dots) module name, and 'filename' is the path to the\n        \".py\" file (relative to the distribution root) that implements the\n        module.\n        \"\"\"\n        # Map package names to tuples of useful info about the package:\n        #    (package_dir, checked)\n        # package_dir - the directory where we'll find source files for\n        #   this package\n        # checked - true if we have checked that the package directory\n        #   is valid (exists, contains __init__.py, ... ?)\n        packages = {}\n\n        # List of (package, module, filename) tuples to return\n        modules = []\n\n        # We treat modules-in-packages almost the same as toplevel modules,\n        # just the \"package\" for a toplevel is empty (either an empty\n        # string or empty list, depending on context).  Differences:\n        #   - don't check for __init__.py in directory for empty package\n        for module in self.py_modules:\n            path = module.split('.')\n            package = '.'.join(path[0:-1])\n            module_base = path[-1]\n\n            try:\n                (package_dir, checked) = packages[package]\n            except KeyError:\n                package_dir = self.get_package_dir(package)\n                checked = False\n\n            if not checked:\n                init_py = self.check_package(package, package_dir)\n                packages[package] = (package_dir, 1)\n                if init_py:\n                    modules.append((package, \"__init__\", init_py))\n\n            # XXX perhaps we should also check for just .pyc files\n            # (so greedy closed-source bastards can distribute Python\n            # modules too)\n            module_file = os.path.join(package_dir, module_base + \".py\")\n            if not self.check_module(module, module_file):\n                continue\n\n            modules.append((package, module_base, module_file))\n\n        return modules\n\n    def find_all_modules(self):\n        \"\"\"Compute the list of all modules that will be built, whether\n        they are specified one-module-at-a-time ('self.py_modules') or\n        by whole packages ('self.packages').  Return a list of tuples\n        (package, module, module_file), just like 'find_modules()' and\n        'find_package_modules()' do.\"\"\"\n        modules = []\n        if self.py_modules:\n            modules.extend(self.find_modules())\n        if self.packages:\n            for package in self.packages:\n                package_dir = self.get_package_dir(package)\n                m = self.find_package_modules(package, package_dir)\n                modules.extend(m)\n        return modules\n\n    def get_source_files(self):\n        return [module[-1] for module in self.find_all_modules()]\n\n    def get_module_outfile(self, build_dir, package, module):\n        outfile_path = [build_dir] + list(package) + [module + \".py\"]\n        return os.path.join(*outfile_path)\n\n    def get_outputs(self, include_bytecode=True):\n        modules = self.find_all_modules()\n        outputs = []\n        for package, module, _module_file in modules:\n            package = package.split('.')\n            filename = self.get_module_outfile(self.build_lib, package, module)\n            outputs.append(filename)\n            if include_bytecode:\n                if self.compile:\n                    outputs.append(\n                        importlib.util.cache_from_source(filename, optimization='')\n                    )\n                if self.optimize > 0:\n                    outputs.append(\n                        importlib.util.cache_from_source(\n                            filename, optimization=self.optimize\n                        )\n                    )\n\n        outputs += [\n            os.path.join(build_dir, filename)\n            for package, src_dir, build_dir, filenames in self.data_files\n            for filename in filenames\n        ]\n\n        return outputs\n\n    def build_module(self, module, module_file, package):\n        if isinstance(package, str):\n            package = package.split('.')\n        elif not isinstance(package, (list, tuple)):\n            raise TypeError(\n                \"'package' must be a string (dot-separated), list, or tuple\"\n            )\n\n        # Now put the module source file into the \"build\" area -- this is\n        # easy, we just copy it somewhere under self.build_lib (the build\n        # directory for Python source).\n        outfile = self.get_module_outfile(self.build_lib, package, module)\n        dir = os.path.dirname(outfile)\n        self.mkpath(dir)\n        return self.copy_file(module_file, outfile, preserve_mode=False)\n\n    def build_modules(self):\n        modules = self.find_modules()\n        for package, module, module_file in modules:\n            # Now \"build\" the module -- ie. copy the source file to\n            # self.build_lib (the build directory for Python source).\n            # (Actually, it gets copied to the directory for this package\n            # under self.build_lib.)\n            self.build_module(module, module_file, package)\n\n    def build_packages(self):\n        for package in self.packages:\n            # Get list of (package, module, module_file) tuples based on\n            # scanning the package directory.  'package' is only included\n            # in the tuple so that 'find_modules()' and\n            # 'find_package_tuples()' have a consistent interface; it's\n            # ignored here (apart from a sanity check).  Also, 'module' is\n            # the *unqualified* module name (ie. no dots, no package -- we\n            # already know its package!), and 'module_file' is the path to\n            # the .py file, relative to the current directory\n            # (ie. including 'package_dir').\n            package_dir = self.get_package_dir(package)\n            modules = self.find_package_modules(package, package_dir)\n\n            # Now loop over the modules we found, \"building\" each one (just\n            # copy it to self.build_lib).\n            for package_, module, module_file in modules:\n                assert package == package_\n                self.build_module(module, module_file, package)\n\n    def byte_compile(self, files):\n        if sys.dont_write_bytecode:\n            self.warn('byte-compiling is disabled, skipping.')\n            return\n\n        from ..util import byte_compile\n\n        prefix = self.build_lib\n        if prefix[-1] != os.sep:\n            prefix = prefix + os.sep\n\n        # XXX this code is essentially the same as the 'byte_compile()\n        # method of the \"install_lib\" command, except for the determination\n        # of the 'prefix' string.  Hmmm.\n        if self.compile:\n            byte_compile(\n                files, optimize=0, force=self.force, prefix=prefix, dry_run=self.dry_run\n            )\n        if self.optimize > 0:\n            byte_compile(\n                files,\n                optimize=self.optimize,\n                force=self.force,\n                prefix=prefix,\n                dry_run=self.dry_run,\n            )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/command/build_scripts.py","size":5600,"sha1":"0eadbd7904817c97409eb4f4b9b55a9ee57792b5","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.command.build_scripts\n\nImplements the Distutils 'build_scripts' command.\"\"\"\n\nimport os\nimport re\nimport tokenize\nfrom distutils import sysconfig\nfrom distutils._log import log\nfrom stat import ST_MODE\nfrom typing import ClassVar\n\nfrom .._modified import newer\nfrom ..core import Command\nfrom ..util import convert_path\n\nshebang_pattern = re.compile('^#!.*python[0-9.]*([ \\t].*)?$')\n\"\"\"\nPattern matching a Python interpreter indicated in first line of a script.\n\"\"\"\n\n# for Setuptools compatibility\nfirst_line_re = shebang_pattern\n\n\nclass build_scripts(Command):\n    description = \"\\\"build\\\" scripts (copy and fixup #! line)\"\n\n    user_options: ClassVar[list[tuple[str, str, str]]] = [\n        ('build-dir=', 'd', \"directory to \\\"build\\\" (copy) to\"),\n        ('force', 'f', \"forcibly build everything (ignore file timestamps\"),\n        ('executable=', 'e', \"specify final destination interpreter path\"),\n    ]\n\n    boolean_options = ['force']\n\n    def initialize_options(self):\n        self.build_dir = None\n        self.scripts = None\n        self.force = None\n        self.executable = None\n\n    def finalize_options(self):\n        self.set_undefined_options(\n            'build',\n            ('build_scripts', 'build_dir'),\n            ('force', 'force'),\n            ('executable', 'executable'),\n        )\n        self.scripts = self.distribution.scripts\n\n    def get_source_files(self):\n        return self.scripts\n\n    def run(self):\n        if not self.scripts:\n            return\n        self.copy_scripts()\n\n    def copy_scripts(self):\n        \"\"\"\n        Copy each script listed in ``self.scripts``.\n\n        If a script is marked as a Python script (first line matches\n        'shebang_pattern', i.e. starts with ``#!`` and contains\n        \"python\"), then adjust in the copy the first line to refer to\n        the current Python interpreter.\n        \"\"\"\n        self.mkpath(self.build_dir)\n        outfiles = []\n        updated_files = []\n        for script in self.scripts:\n            self._copy_script(script, outfiles, updated_files)\n\n        self._change_modes(outfiles)\n\n        return outfiles, updated_files\n\n    def _copy_script(self, script, outfiles, updated_files):  # noqa: C901\n        shebang_match = None\n        script = convert_path(script)\n        outfile = os.path.join(self.build_dir, os.path.basename(script))\n        outfiles.append(outfile)\n\n        if not self.force and not newer(script, outfile):\n            log.debug(\"not copying %s (up-to-date)\", script)\n            return\n\n        # Always open the file, but ignore failures in dry-run mode\n        # in order to attempt to copy directly.\n        try:\n            f = tokenize.open(script)\n        except OSError:\n            if not self.dry_run:\n                raise\n            f = None\n        else:\n            first_line = f.readline()\n            if not first_line:\n                self.warn(f\"{script} is an empty file (skipping)\")\n                return\n\n            shebang_match = shebang_pattern.match(first_line)\n\n        updated_files.append(outfile)\n        if shebang_match:\n            log.info(\"copying and adjusting %s -> %s\", script, self.build_dir)\n            if not self.dry_run:\n                if not sysconfig.python_build:\n                    executable = self.executable\n                else:\n                    executable = os.path.join(\n                        sysconfig.get_config_var(\"BINDIR\"),\n                        \"python{}{}\".format(\n                            sysconfig.get_config_var(\"VERSION\"),\n                            sysconfig.get_config_var(\"EXE\"),\n                        ),\n                    )\n                post_interp = shebang_match.group(1) or ''\n                shebang = \"#!\" + executable + post_interp + \"\\n\"\n                self._validate_shebang(shebang, f.encoding)\n                with open(outfile, \"w\", encoding=f.encoding) as outf:\n                    outf.write(shebang)\n                    outf.writelines(f.readlines())\n            if f:\n                f.close()\n        else:\n            if f:\n                f.close()\n            self.copy_file(script, outfile)\n\n    def _change_modes(self, outfiles):\n        if os.name != 'posix':\n            return\n\n        for file in outfiles:\n            self._change_mode(file)\n\n    def _change_mode(self, file):\n        if self.dry_run:\n            log.info(\"changing mode of %s\", file)\n            return\n\n        oldmode = os.stat(file)[ST_MODE] & 0o7777\n        newmode = (oldmode | 0o555) & 0o7777\n        if newmode != oldmode:\n            log.info(\"changing mode of %s from %o to %o\", file, oldmode, newmode)\n            os.chmod(file, newmode)\n\n    @staticmethod\n    def _validate_shebang(shebang, encoding):\n        # Python parser starts to read a script using UTF-8 until\n        # it gets a #coding:xxx cookie. The shebang has to be the\n        # first line of a file, the #coding:xxx cookie cannot be\n        # written before. So the shebang has to be encodable to\n        # UTF-8.\n        try:\n            shebang.encode('utf-8')\n        except UnicodeEncodeError:\n            raise ValueError(f\"The shebang ({shebang!r}) is not encodable to utf-8\")\n\n        # If the script is encoded to a custom encoding (use a\n        # #coding:xxx cookie), the shebang has to be encodable to\n        # the script encoding too.\n        try:\n            shebang.encode(encoding)\n        except UnicodeEncodeError:\n            raise ValueError(\n                f\"The shebang ({shebang!r}) is not encodable \"\n                f\"to the script encoding ({encoding})\"\n            )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/command/check.py","size":4912,"sha1":"70d8975f1aa4cdc5eca01036b61db390e77e7eea","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.command.check\n\nImplements the Distutils 'check' command.\n\"\"\"\n\nimport contextlib\nfrom typing import ClassVar\n\nfrom ..core import Command\nfrom ..errors import DistutilsSetupError\n\nwith contextlib.suppress(ImportError):\n    import docutils.frontend\n    import docutils.nodes\n    import docutils.parsers.rst\n    import docutils.utils\n\n    class SilentReporter(docutils.utils.Reporter):\n        def __init__(\n            self,\n            source,\n            report_level,\n            halt_level,\n            stream=None,\n            debug=False,\n            encoding='ascii',\n            error_handler='replace',\n        ):\n            self.messages = []\n            super().__init__(\n                source, report_level, halt_level, stream, debug, encoding, error_handler\n            )\n\n        def system_message(self, level, message, *children, **kwargs):\n            self.messages.append((level, message, children, kwargs))\n            return docutils.nodes.system_message(\n                message, *children, level=level, type=self.levels[level], **kwargs\n            )\n\n\nclass check(Command):\n    \"\"\"This command checks the meta-data of the package.\"\"\"\n\n    description = \"perform some checks on the package\"\n    user_options: ClassVar[list[tuple[str, str, str]]] = [\n        ('metadata', 'm', 'Verify meta-data'),\n        (\n            'restructuredtext',\n            'r',\n            'Checks if long string meta-data syntax are reStructuredText-compliant',\n        ),\n        ('strict', 's', 'Will exit with an error if a check fails'),\n    ]\n\n    boolean_options = ['metadata', 'restructuredtext', 'strict']\n\n    def initialize_options(self):\n        \"\"\"Sets default values for options.\"\"\"\n        self.restructuredtext = False\n        self.metadata = 1\n        self.strict = False\n        self._warnings = 0\n\n    def finalize_options(self):\n        pass\n\n    def warn(self, msg):\n        \"\"\"Counts the number of warnings that occurs.\"\"\"\n        self._warnings += 1\n        return Command.warn(self, msg)\n\n    def run(self):\n        \"\"\"Runs the command.\"\"\"\n        # perform the various tests\n        if self.metadata:\n            self.check_metadata()\n        if self.restructuredtext:\n            if 'docutils' in globals():\n                try:\n                    self.check_restructuredtext()\n                except TypeError as exc:\n                    raise DistutilsSetupError(str(exc))\n            elif self.strict:\n                raise DistutilsSetupError('The docutils package is needed.')\n\n        # let's raise an error in strict mode, if we have at least\n        # one warning\n        if self.strict and self._warnings > 0:\n            raise DistutilsSetupError('Please correct your package.')\n\n    def check_metadata(self):\n        \"\"\"Ensures that all required elements of meta-data are supplied.\n\n        Required fields:\n            name, version\n\n        Warns if any are missing.\n        \"\"\"\n        metadata = self.distribution.metadata\n\n        missing = [\n            attr for attr in ('name', 'version') if not getattr(metadata, attr, None)\n        ]\n\n        if missing:\n            self.warn(\"missing required meta-data: {}\".format(', '.join(missing)))\n\n    def check_restructuredtext(self):\n        \"\"\"Checks if the long string fields are reST-compliant.\"\"\"\n        data = self.distribution.get_long_description()\n        for warning in self._check_rst_data(data):\n            line = warning[-1].get('line')\n            if line is None:\n                warning = warning[1]\n            else:\n                warning = f'{warning[1]} (line {line})'\n            self.warn(warning)\n\n    def _check_rst_data(self, data):\n        \"\"\"Returns warnings when the provided data doesn't compile.\"\"\"\n        # the include and csv_table directives need this to be a path\n        source_path = self.distribution.script_name or 'setup.py'\n        parser = docutils.parsers.rst.Parser()\n        settings = docutils.frontend.OptionParser(\n            components=(docutils.parsers.rst.Parser,)\n        ).get_default_values()\n        settings.tab_width = 4\n        settings.pep_references = None\n        settings.rfc_references = None\n        reporter = SilentReporter(\n            source_path,\n            settings.report_level,\n            settings.halt_level,\n            stream=settings.warning_stream,\n            debug=settings.debug,\n            encoding=settings.error_encoding,\n            error_handler=settings.error_encoding_error_handler,\n        )\n\n        document = docutils.nodes.document(settings, reporter, source=source_path)\n        document.note_source(source_path, -1)\n        try:\n            parser.parse(data, document)\n        except AttributeError as e:\n            reporter.messages.append((\n                -1,\n                f'Could not finish the parsing: {e}.',\n                '',\n                {},\n            ))\n\n        return reporter.messages\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/command/clean.py","size":2595,"sha1":"18c3637182e5f8be7d38239a0400b1dcab24f9ee","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.command.clean\n\nImplements the Distutils 'clean' command.\"\"\"\n\n# contributed by Bastian Kleineidam <calvin@cs.uni-sb.de>, added 2000-03-18\n\nimport os\nfrom distutils._log import log\n\nfrom ..core import Command\nfrom ..dir_util import remove_tree\n\n\nclass clean(Command):\n    description = \"clean up temporary files from 'build' command\"\n    user_options = [\n        ('build-base=', 'b', \"base build directory [default: 'build.build-base']\"),\n        (\n            'build-lib=',\n            None,\n            \"build directory for all modules [default: 'build.build-lib']\",\n        ),\n        ('build-temp=', 't', \"temporary build directory [default: 'build.build-temp']\"),\n        (\n            'build-scripts=',\n            None,\n            \"build directory for scripts [default: 'build.build-scripts']\",\n        ),\n        ('bdist-base=', None, \"temporary directory for built distributions\"),\n        ('all', 'a', \"remove all build output, not just temporary by-products\"),\n    ]\n\n    boolean_options = ['all']\n\n    def initialize_options(self):\n        self.build_base = None\n        self.build_lib = None\n        self.build_temp = None\n        self.build_scripts = None\n        self.bdist_base = None\n        self.all = None\n\n    def finalize_options(self):\n        self.set_undefined_options(\n            'build',\n            ('build_base', 'build_base'),\n            ('build_lib', 'build_lib'),\n            ('build_scripts', 'build_scripts'),\n            ('build_temp', 'build_temp'),\n        )\n        self.set_undefined_options('bdist', ('bdist_base', 'bdist_base'))\n\n    def run(self):\n        # remove the build/temp.<plat> directory (unless it's already\n        # gone)\n        if os.path.exists(self.build_temp):\n            remove_tree(self.build_temp, dry_run=self.dry_run)\n        else:\n            log.debug(\"'%s' does not exist -- can't clean it\", self.build_temp)\n\n        if self.all:\n            # remove build directories\n            for directory in (self.build_lib, self.bdist_base, self.build_scripts):\n                if os.path.exists(directory):\n                    remove_tree(directory, dry_run=self.dry_run)\n                else:\n                    log.warning(\"'%s' does not exist -- can't clean it\", directory)\n\n        # just for the heck of it, try to remove the base build directory:\n        # we might have emptied it right now, but if not we don't care\n        if not self.dry_run:\n            try:\n                os.rmdir(self.build_base)\n                log.info(\"removing '%s'\", self.build_base)\n            except OSError:\n                pass\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/command/config.py","size":13008,"sha1":"c2e31b48c43c15685fb866eebec24a80f8c132e2","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.command.config\n\nImplements the Distutils 'config' command, a (mostly) empty command class\nthat exists mainly to be sub-classed by specific module distributions and\napplications.  The idea is that while every \"config\" command is different,\nat least they're all named the same, and users always see \"config\" in the\nlist of standard commands.  Also, this is a good place to put common\nconfigure-like tasks: \"try to compile this C code\", or \"figure out where\nthis header file lives\".\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport pathlib\nimport re\nfrom collections.abc import Sequence\nfrom distutils._log import log\n\nfrom ..core import Command\nfrom ..errors import DistutilsExecError\nfrom ..sysconfig import customize_compiler\n\nLANG_EXT = {\"c\": \".c\", \"c++\": \".cxx\"}\n\n\nclass config(Command):\n    description = \"prepare to build\"\n\n    user_options = [\n        ('compiler=', None, \"specify the compiler type\"),\n        ('cc=', None, \"specify the compiler executable\"),\n        ('include-dirs=', 'I', \"list of directories to search for header files\"),\n        ('define=', 'D', \"C preprocessor macros to define\"),\n        ('undef=', 'U', \"C preprocessor macros to undefine\"),\n        ('libraries=', 'l', \"external C libraries to link with\"),\n        ('library-dirs=', 'L', \"directories to search for external C libraries\"),\n        ('noisy', None, \"show every action (compile, link, run, ...) taken\"),\n        (\n            'dump-source',\n            None,\n            \"dump generated source files before attempting to compile them\",\n        ),\n    ]\n\n    # The three standard command methods: since the \"config\" command\n    # does nothing by default, these are empty.\n\n    def initialize_options(self):\n        self.compiler = None\n        self.cc = None\n        self.include_dirs = None\n        self.libraries = None\n        self.library_dirs = None\n\n        # maximal output for now\n        self.noisy = 1\n        self.dump_source = 1\n\n        # list of temporary files generated along-the-way that we have\n        # to clean at some point\n        self.temp_files = []\n\n    def finalize_options(self):\n        if self.include_dirs is None:\n            self.include_dirs = self.distribution.include_dirs or []\n        elif isinstance(self.include_dirs, str):\n            self.include_dirs = self.include_dirs.split(os.pathsep)\n\n        if self.libraries is None:\n            self.libraries = []\n        elif isinstance(self.libraries, str):\n            self.libraries = [self.libraries]\n\n        if self.library_dirs is None:\n            self.library_dirs = []\n        elif isinstance(self.library_dirs, str):\n            self.library_dirs = self.library_dirs.split(os.pathsep)\n\n    def run(self):\n        pass\n\n    # Utility methods for actual \"config\" commands.  The interfaces are\n    # loosely based on Autoconf macros of similar names.  Sub-classes\n    # may use these freely.\n\n    def _check_compiler(self):\n        \"\"\"Check that 'self.compiler' really is a CCompiler object;\n        if not, make it one.\n        \"\"\"\n        # We do this late, and only on-demand, because this is an expensive\n        # import.\n        from ..ccompiler import CCompiler, new_compiler\n\n        if not isinstance(self.compiler, CCompiler):\n            self.compiler = new_compiler(\n                compiler=self.compiler, dry_run=self.dry_run, force=True\n            )\n            customize_compiler(self.compiler)\n            if self.include_dirs:\n                self.compiler.set_include_dirs(self.include_dirs)\n            if self.libraries:\n                self.compiler.set_libraries(self.libraries)\n            if self.library_dirs:\n                self.compiler.set_library_dirs(self.library_dirs)\n\n    def _gen_temp_sourcefile(self, body, headers, lang):\n        filename = \"_configtest\" + LANG_EXT[lang]\n        with open(filename, \"w\", encoding='utf-8') as file:\n            if headers:\n                for header in headers:\n                    file.write(f\"#include <{header}>\\n\")\n                file.write(\"\\n\")\n            file.write(body)\n            if body[-1] != \"\\n\":\n                file.write(\"\\n\")\n        return filename\n\n    def _preprocess(self, body, headers, include_dirs, lang):\n        src = self._gen_temp_sourcefile(body, headers, lang)\n        out = \"_configtest.i\"\n        self.temp_files.extend([src, out])\n        self.compiler.preprocess(src, out, include_dirs=include_dirs)\n        return (src, out)\n\n    def _compile(self, body, headers, include_dirs, lang):\n        src = self._gen_temp_sourcefile(body, headers, lang)\n        if self.dump_source:\n            dump_file(src, f\"compiling '{src}':\")\n        (obj,) = self.compiler.object_filenames([src])\n        self.temp_files.extend([src, obj])\n        self.compiler.compile([src], include_dirs=include_dirs)\n        return (src, obj)\n\n    def _link(self, body, headers, include_dirs, libraries, library_dirs, lang):\n        (src, obj) = self._compile(body, headers, include_dirs, lang)\n        prog = os.path.splitext(os.path.basename(src))[0]\n        self.compiler.link_executable(\n            [obj],\n            prog,\n            libraries=libraries,\n            library_dirs=library_dirs,\n            target_lang=lang,\n        )\n\n        if self.compiler.exe_extension is not None:\n            prog = prog + self.compiler.exe_extension\n        self.temp_files.append(prog)\n\n        return (src, obj, prog)\n\n    def _clean(self, *filenames):\n        if not filenames:\n            filenames = self.temp_files\n            self.temp_files = []\n        log.info(\"removing: %s\", ' '.join(filenames))\n        for filename in filenames:\n            try:\n                os.remove(filename)\n            except OSError:\n                pass\n\n    # XXX these ignore the dry-run flag: what to do, what to do? even if\n    # you want a dry-run build, you still need some sort of configuration\n    # info.  My inclination is to make it up to the real config command to\n    # consult 'dry_run', and assume a default (minimal) configuration if\n    # true.  The problem with trying to do it here is that you'd have to\n    # return either true or false from all the 'try' methods, neither of\n    # which is correct.\n\n    # XXX need access to the header search path and maybe default macros.\n\n    def try_cpp(self, body=None, headers=None, include_dirs=None, lang=\"c\"):\n        \"\"\"Construct a source file from 'body' (a string containing lines\n        of C/C++ code) and 'headers' (a list of header files to include)\n        and run it through the preprocessor.  Return true if the\n        preprocessor succeeded, false if there were any errors.\n        ('body' probably isn't of much use, but what the heck.)\n        \"\"\"\n        from ..ccompiler import CompileError\n\n        self._check_compiler()\n        ok = True\n        try:\n            self._preprocess(body, headers, include_dirs, lang)\n        except CompileError:\n            ok = False\n\n        self._clean()\n        return ok\n\n    def search_cpp(self, pattern, body=None, headers=None, include_dirs=None, lang=\"c\"):\n        \"\"\"Construct a source file (just like 'try_cpp()'), run it through\n        the preprocessor, and return true if any line of the output matches\n        'pattern'.  'pattern' should either be a compiled regex object or a\n        string containing a regex.  If both 'body' and 'headers' are None,\n        preprocesses an empty file -- which can be useful to determine the\n        symbols the preprocessor and compiler set by default.\n        \"\"\"\n        self._check_compiler()\n        src, out = self._preprocess(body, headers, include_dirs, lang)\n\n        if isinstance(pattern, str):\n            pattern = re.compile(pattern)\n\n        with open(out, encoding='utf-8') as file:\n            match = any(pattern.search(line) for line in file)\n\n        self._clean()\n        return match\n\n    def try_compile(self, body, headers=None, include_dirs=None, lang=\"c\"):\n        \"\"\"Try to compile a source file built from 'body' and 'headers'.\n        Return true on success, false otherwise.\n        \"\"\"\n        from ..ccompiler import CompileError\n\n        self._check_compiler()\n        try:\n            self._compile(body, headers, include_dirs, lang)\n            ok = True\n        except CompileError:\n            ok = False\n\n        log.info(ok and \"success!\" or \"failure.\")\n        self._clean()\n        return ok\n\n    def try_link(\n        self,\n        body,\n        headers=None,\n        include_dirs=None,\n        libraries=None,\n        library_dirs=None,\n        lang=\"c\",\n    ):\n        \"\"\"Try to compile and link a source file, built from 'body' and\n        'headers', to executable form.  Return true on success, false\n        otherwise.\n        \"\"\"\n        from ..ccompiler import CompileError, LinkError\n\n        self._check_compiler()\n        try:\n            self._link(body, headers, include_dirs, libraries, library_dirs, lang)\n            ok = True\n        except (CompileError, LinkError):\n            ok = False\n\n        log.info(ok and \"success!\" or \"failure.\")\n        self._clean()\n        return ok\n\n    def try_run(\n        self,\n        body,\n        headers=None,\n        include_dirs=None,\n        libraries=None,\n        library_dirs=None,\n        lang=\"c\",\n    ):\n        \"\"\"Try to compile, link to an executable, and run a program\n        built from 'body' and 'headers'.  Return true on success, false\n        otherwise.\n        \"\"\"\n        from ..ccompiler import CompileError, LinkError\n\n        self._check_compiler()\n        try:\n            src, obj, exe = self._link(\n                body, headers, include_dirs, libraries, library_dirs, lang\n            )\n            self.spawn([exe])\n            ok = True\n        except (CompileError, LinkError, DistutilsExecError):\n            ok = False\n\n        log.info(ok and \"success!\" or \"failure.\")\n        self._clean()\n        return ok\n\n    # -- High-level methods --------------------------------------------\n    # (these are the ones that are actually likely to be useful\n    # when implementing a real-world config command!)\n\n    def check_func(\n        self,\n        func,\n        headers=None,\n        include_dirs=None,\n        libraries=None,\n        library_dirs=None,\n        decl=False,\n        call=False,\n    ):\n        \"\"\"Determine if function 'func' is available by constructing a\n        source file that refers to 'func', and compiles and links it.\n        If everything succeeds, returns true; otherwise returns false.\n\n        The constructed source file starts out by including the header\n        files listed in 'headers'.  If 'decl' is true, it then declares\n        'func' (as \"int func()\"); you probably shouldn't supply 'headers'\n        and set 'decl' true in the same call, or you might get errors about\n        a conflicting declarations for 'func'.  Finally, the constructed\n        'main()' function either references 'func' or (if 'call' is true)\n        calls it.  'libraries' and 'library_dirs' are used when\n        linking.\n        \"\"\"\n        self._check_compiler()\n        body = []\n        if decl:\n            body.append(f\"int {func} ();\")\n        body.append(\"int main () {\")\n        if call:\n            body.append(f\"  {func}();\")\n        else:\n            body.append(f\"  {func};\")\n        body.append(\"}\")\n        body = \"\\n\".join(body) + \"\\n\"\n\n        return self.try_link(body, headers, include_dirs, libraries, library_dirs)\n\n    def check_lib(\n        self,\n        library,\n        library_dirs=None,\n        headers=None,\n        include_dirs=None,\n        other_libraries: Sequence[str] = [],\n    ):\n        \"\"\"Determine if 'library' is available to be linked against,\n        without actually checking that any particular symbols are provided\n        by it.  'headers' will be used in constructing the source file to\n        be compiled, but the only effect of this is to check if all the\n        header files listed are available.  Any libraries listed in\n        'other_libraries' will be included in the link, in case 'library'\n        has symbols that depend on other libraries.\n        \"\"\"\n        self._check_compiler()\n        return self.try_link(\n            \"int main (void) { }\",\n            headers,\n            include_dirs,\n            [library] + list(other_libraries),\n            library_dirs,\n        )\n\n    def check_header(self, header, include_dirs=None, library_dirs=None, lang=\"c\"):\n        \"\"\"Determine if the system header file named by 'header_file'\n        exists and can be found by the preprocessor; return true if so,\n        false otherwise.\n        \"\"\"\n        return self.try_cpp(\n            body=\"/* No body */\", headers=[header], include_dirs=include_dirs\n        )\n\n\ndef dump_file(filename, head=None):\n    \"\"\"Dumps a file content into log.info.\n\n    If head is not None, will be dumped before the file content.\n    \"\"\"\n    if head is None:\n        log.info('%s', filename)\n    else:\n        log.info(head)\n    log.info(pathlib.Path(filename).read_text(encoding='utf-8'))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/command/install.py","size":30122,"sha1":"66749c9b839c97f52df8738b9238615ff909b960","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.command.install\n\nImplements the Distutils 'install' command.\"\"\"\n\nimport contextlib\nimport itertools\nimport os\nimport sys\nimport sysconfig\nfrom distutils._log import log\nfrom site import USER_BASE, USER_SITE\n\nimport jaraco.collections\n\nfrom ..core import Command\nfrom ..debug import DEBUG\nfrom ..errors import DistutilsOptionError, DistutilsPlatformError\nfrom ..file_util import write_file\nfrom ..sysconfig import get_config_vars\nfrom ..util import change_root, convert_path, get_platform, subst_vars\nfrom . import _framework_compat as fw\n\nHAS_USER_SITE = True\n\nWINDOWS_SCHEME = {\n    'purelib': '{base}/Lib/site-packages',\n    'platlib': '{base}/Lib/site-packages',\n    'headers': '{base}/Include/{dist_name}',\n    'scripts': '{base}/Scripts',\n    'data': '{base}',\n}\n\nINSTALL_SCHEMES = {\n    'posix_prefix': {\n        'purelib': '{base}/lib/{implementation_lower}{py_version_short}/site-packages',\n        'platlib': '{platbase}/{platlibdir}/{implementation_lower}'\n        '{py_version_short}/site-packages',\n        'headers': '{base}/include/{implementation_lower}'\n        '{py_version_short}{abiflags}/{dist_name}',\n        'scripts': '{base}/bin',\n        'data': '{base}',\n    },\n    'posix_home': {\n        'purelib': '{base}/lib/{implementation_lower}',\n        'platlib': '{base}/{platlibdir}/{implementation_lower}',\n        'headers': '{base}/include/{implementation_lower}/{dist_name}',\n        'scripts': '{base}/bin',\n        'data': '{base}',\n    },\n    'nt': WINDOWS_SCHEME,\n    'pypy': {\n        'purelib': '{base}/site-packages',\n        'platlib': '{base}/site-packages',\n        'headers': '{base}/include/{dist_name}',\n        'scripts': '{base}/bin',\n        'data': '{base}',\n    },\n    'pypy_nt': {\n        'purelib': '{base}/site-packages',\n        'platlib': '{base}/site-packages',\n        'headers': '{base}/include/{dist_name}',\n        'scripts': '{base}/Scripts',\n        'data': '{base}',\n    },\n}\n\n# user site schemes\nif HAS_USER_SITE:\n    INSTALL_SCHEMES['nt_user'] = {\n        'purelib': '{usersite}',\n        'platlib': '{usersite}',\n        'headers': '{userbase}/{implementation}{py_version_nodot_plat}'\n        '/Include/{dist_name}',\n        'scripts': '{userbase}/{implementation}{py_version_nodot_plat}/Scripts',\n        'data': '{userbase}',\n    }\n\n    INSTALL_SCHEMES['posix_user'] = {\n        'purelib': '{usersite}',\n        'platlib': '{usersite}',\n        'headers': '{userbase}/include/{implementation_lower}'\n        '{py_version_short}{abiflags}/{dist_name}',\n        'scripts': '{userbase}/bin',\n        'data': '{userbase}',\n    }\n\n\nINSTALL_SCHEMES.update(fw.schemes)\n\n\n# The keys to an installation scheme; if any new types of files are to be\n# installed, be sure to add an entry to every installation scheme above,\n# and to SCHEME_KEYS here.\nSCHEME_KEYS = ('purelib', 'platlib', 'headers', 'scripts', 'data')\n\n\ndef _load_sysconfig_schemes():\n    with contextlib.suppress(AttributeError):\n        return {\n            scheme: sysconfig.get_paths(scheme, expand=False)\n            for scheme in sysconfig.get_scheme_names()\n        }\n\n\ndef _load_schemes():\n    \"\"\"\n    Extend default schemes with schemes from sysconfig.\n    \"\"\"\n\n    sysconfig_schemes = _load_sysconfig_schemes() or {}\n\n    return {\n        scheme: {\n            **INSTALL_SCHEMES.get(scheme, {}),\n            **sysconfig_schemes.get(scheme, {}),\n        }\n        for scheme in set(itertools.chain(INSTALL_SCHEMES, sysconfig_schemes))\n    }\n\n\ndef _get_implementation():\n    if hasattr(sys, 'pypy_version_info'):\n        return 'PyPy'\n    else:\n        return 'Python'\n\n\ndef _select_scheme(ob, name):\n    scheme = _inject_headers(name, _load_scheme(_resolve_scheme(name)))\n    vars(ob).update(_remove_set(ob, _scheme_attrs(scheme)))\n\n\ndef _remove_set(ob, attrs):\n    \"\"\"\n    Include only attrs that are None in ob.\n    \"\"\"\n    return {key: value for key, value in attrs.items() if getattr(ob, key) is None}\n\n\ndef _resolve_scheme(name):\n    os_name, sep, key = name.partition('_')\n    try:\n        resolved = sysconfig.get_preferred_scheme(key)\n    except Exception:\n        resolved = fw.scheme(_pypy_hack(name))\n    return resolved\n\n\ndef _load_scheme(name):\n    return _load_schemes()[name]\n\n\ndef _inject_headers(name, scheme):\n    \"\"\"\n    Given a scheme name and the resolved scheme,\n    if the scheme does not include headers, resolve\n    the fallback scheme for the name and use headers\n    from it. pypa/distutils#88\n    \"\"\"\n    # Bypass the preferred scheme, which may not\n    # have defined headers.\n    fallback = _load_scheme(_pypy_hack(name))\n    scheme.setdefault('headers', fallback['headers'])\n    return scheme\n\n\ndef _scheme_attrs(scheme):\n    \"\"\"Resolve install directories by applying the install schemes.\"\"\"\n    return {f'install_{key}': scheme[key] for key in SCHEME_KEYS}\n\n\ndef _pypy_hack(name):\n    PY37 = sys.version_info < (3, 8)\n    old_pypy = hasattr(sys, 'pypy_version_info') and PY37\n    prefix = not name.endswith(('_user', '_home'))\n    pypy_name = 'pypy' + '_nt' * (os.name == 'nt')\n    return pypy_name if old_pypy and prefix else name\n\n\nclass install(Command):\n    description = \"install everything from build directory\"\n\n    user_options = [\n        # Select installation scheme and set base director(y|ies)\n        ('prefix=', None, \"installation prefix\"),\n        ('exec-prefix=', None, \"(Unix only) prefix for platform-specific files\"),\n        ('home=', None, \"(Unix only) home directory to install under\"),\n        # Or, just set the base director(y|ies)\n        (\n            'install-base=',\n            None,\n            \"base installation directory (instead of --prefix or --home)\",\n        ),\n        (\n            'install-platbase=',\n            None,\n            \"base installation directory for platform-specific files (instead of --exec-prefix or --home)\",\n        ),\n        ('root=', None, \"install everything relative to this alternate root directory\"),\n        # Or, explicitly set the installation scheme\n        (\n            'install-purelib=',\n            None,\n            \"installation directory for pure Python module distributions\",\n        ),\n        (\n            'install-platlib=',\n            None,\n            \"installation directory for non-pure module distributions\",\n        ),\n        (\n            'install-lib=',\n            None,\n            \"installation directory for all module distributions (overrides --install-purelib and --install-platlib)\",\n        ),\n        ('install-headers=', None, \"installation directory for C/C++ headers\"),\n        ('install-scripts=', None, \"installation directory for Python scripts\"),\n        ('install-data=', None, \"installation directory for data files\"),\n        # Byte-compilation options -- see install_lib.py for details, as\n        # these are duplicated from there (but only install_lib does\n        # anything with them).\n        ('compile', 'c', \"compile .py to .pyc [default]\"),\n        ('no-compile', None, \"don't compile .py files\"),\n        (\n            'optimize=',\n            'O',\n            \"also compile with optimization: -O1 for \\\"python -O\\\", \"\n            \"-O2 for \\\"python -OO\\\", and -O0 to disable [default: -O0]\",\n        ),\n        # Miscellaneous control options\n        ('force', 'f', \"force installation (overwrite any existing files)\"),\n        ('skip-build', None, \"skip rebuilding everything (for testing/debugging)\"),\n        # Where to install documentation (eventually!)\n        # ('doc-format=', None, \"format of documentation to generate\"),\n        # ('install-man=', None, \"directory for Unix man pages\"),\n        # ('install-html=', None, \"directory for HTML documentation\"),\n        # ('install-info=', None, \"directory for GNU info files\"),\n        ('record=', None, \"filename in which to record list of installed files\"),\n    ]\n\n    boolean_options = ['compile', 'force', 'skip-build']\n\n    if HAS_USER_SITE:\n        user_options.append((\n            'user',\n            None,\n            f\"install in user site-package '{USER_SITE}'\",\n        ))\n        boolean_options.append('user')\n\n    negative_opt = {'no-compile': 'compile'}\n\n    def initialize_options(self):\n        \"\"\"Initializes options.\"\"\"\n        # High-level options: these select both an installation base\n        # and scheme.\n        self.prefix = None\n        self.exec_prefix = None\n        self.home = None\n        self.user = False\n\n        # These select only the installation base; it's up to the user to\n        # specify the installation scheme (currently, that means supplying\n        # the --install-{platlib,purelib,scripts,data} options).\n        self.install_base = None\n        self.install_platbase = None\n        self.root = None\n\n        # These options are the actual installation directories; if not\n        # supplied by the user, they are filled in using the installation\n        # scheme implied by prefix/exec-prefix/home and the contents of\n        # that installation scheme.\n        self.install_purelib = None  # for pure module distributions\n        self.install_platlib = None  # non-pure (dists w/ extensions)\n        self.install_headers = None  # for C/C++ headers\n        self.install_lib = None  # set to either purelib or platlib\n        self.install_scripts = None\n        self.install_data = None\n        self.install_userbase = USER_BASE\n        self.install_usersite = USER_SITE\n\n        self.compile = None\n        self.optimize = None\n\n        # Deprecated\n        # These two are for putting non-packagized distributions into their\n        # own directory and creating a .pth file if it makes sense.\n        # 'extra_path' comes from the setup file; 'install_path_file' can\n        # be turned off if it makes no sense to install a .pth file.  (But\n        # better to install it uselessly than to guess wrong and not\n        # install it when it's necessary and would be used!)  Currently,\n        # 'install_path_file' is always true unless some outsider meddles\n        # with it.\n        self.extra_path = None\n        self.install_path_file = True\n\n        # 'force' forces installation, even if target files are not\n        # out-of-date.  'skip_build' skips running the \"build\" command,\n        # handy if you know it's not necessary.  'warn_dir' (which is *not*\n        # a user option, it's just there so the bdist_* commands can turn\n        # it off) determines whether we warn about installing to a\n        # directory not in sys.path.\n        self.force = False\n        self.skip_build = False\n        self.warn_dir = True\n\n        # These are only here as a conduit from the 'build' command to the\n        # 'install_*' commands that do the real work.  ('build_base' isn't\n        # actually used anywhere, but it might be useful in future.)  They\n        # are not user options, because if the user told the install\n        # command where the build directory is, that wouldn't affect the\n        # build command.\n        self.build_base = None\n        self.build_lib = None\n\n        # Not defined yet because we don't know anything about\n        # documentation yet.\n        # self.install_man = None\n        # self.install_html = None\n        # self.install_info = None\n\n        self.record = None\n\n    # -- Option finalizing methods -------------------------------------\n    # (This is rather more involved than for most commands,\n    # because this is where the policy for installing third-\n    # party Python modules on various platforms given a wide\n    # array of user input is decided.  Yes, it's quite complex!)\n\n    def finalize_options(self):  # noqa: C901\n        \"\"\"Finalizes options.\"\"\"\n        # This method (and its helpers, like 'finalize_unix()',\n        # 'finalize_other()', and 'select_scheme()') is where the default\n        # installation directories for modules, extension modules, and\n        # anything else we care to install from a Python module\n        # distribution.  Thus, this code makes a pretty important policy\n        # statement about how third-party stuff is added to a Python\n        # installation!  Note that the actual work of installation is done\n        # by the relatively simple 'install_*' commands; they just take\n        # their orders from the installation directory options determined\n        # here.\n\n        # Check for errors/inconsistencies in the options; first, stuff\n        # that's wrong on any platform.\n\n        if (self.prefix or self.exec_prefix or self.home) and (\n            self.install_base or self.install_platbase\n        ):\n            raise DistutilsOptionError(\n                \"must supply either prefix/exec-prefix/home or install-base/install-platbase -- not both\"\n            )\n\n        if self.home and (self.prefix or self.exec_prefix):\n            raise DistutilsOptionError(\n                \"must supply either home or prefix/exec-prefix -- not both\"\n            )\n\n        if self.user and (\n            self.prefix\n            or self.exec_prefix\n            or self.home\n            or self.install_base\n            or self.install_platbase\n        ):\n            raise DistutilsOptionError(\n                \"can't combine user with prefix, \"\n                \"exec_prefix/home, or install_(plat)base\"\n            )\n\n        # Next, stuff that's wrong (or dubious) only on certain platforms.\n        if os.name != \"posix\":\n            if self.exec_prefix:\n                self.warn(\"exec-prefix option ignored on this platform\")\n                self.exec_prefix = None\n\n        # Now the interesting logic -- so interesting that we farm it out\n        # to other methods.  The goal of these methods is to set the final\n        # values for the install_{lib,scripts,data,...}  options, using as\n        # input a heady brew of prefix, exec_prefix, home, install_base,\n        # install_platbase, user-supplied versions of\n        # install_{purelib,platlib,lib,scripts,data,...}, and the\n        # install schemes.  Phew!\n\n        self.dump_dirs(\"pre-finalize_{unix,other}\")\n\n        if os.name == 'posix':\n            self.finalize_unix()\n        else:\n            self.finalize_other()\n\n        self.dump_dirs(\"post-finalize_{unix,other}()\")\n\n        # Expand configuration variables, tilde, etc. in self.install_base\n        # and self.install_platbase -- that way, we can use $base or\n        # $platbase in the other installation directories and not worry\n        # about needing recursive variable expansion (shudder).\n\n        py_version = sys.version.split()[0]\n        (prefix, exec_prefix) = get_config_vars('prefix', 'exec_prefix')\n        try:\n            abiflags = sys.abiflags\n        except AttributeError:\n            # sys.abiflags may not be defined on all platforms.\n            abiflags = ''\n        local_vars = {\n            'dist_name': self.distribution.get_name(),\n            'dist_version': self.distribution.get_version(),\n            'dist_fullname': self.distribution.get_fullname(),\n            'py_version': py_version,\n            'py_version_short': f'{sys.version_info.major}.{sys.version_info.minor}',\n            'py_version_nodot': f'{sys.version_info.major}{sys.version_info.minor}',\n            'sys_prefix': prefix,\n            'prefix': prefix,\n            'sys_exec_prefix': exec_prefix,\n            'exec_prefix': exec_prefix,\n            'abiflags': abiflags,\n            'platlibdir': getattr(sys, 'platlibdir', 'lib'),\n            'implementation_lower': _get_implementation().lower(),\n            'implementation': _get_implementation(),\n        }\n\n        # vars for compatibility on older Pythons\n        compat_vars = dict(\n            # Python 3.9 and earlier\n            py_version_nodot_plat=getattr(sys, 'winver', '').replace('.', ''),\n        )\n\n        if HAS_USER_SITE:\n            local_vars['userbase'] = self.install_userbase\n            local_vars['usersite'] = self.install_usersite\n\n        self.config_vars = jaraco.collections.DictStack([\n            fw.vars(),\n            compat_vars,\n            sysconfig.get_config_vars(),\n            local_vars,\n        ])\n\n        self.expand_basedirs()\n\n        self.dump_dirs(\"post-expand_basedirs()\")\n\n        # Now define config vars for the base directories so we can expand\n        # everything else.\n        local_vars['base'] = self.install_base\n        local_vars['platbase'] = self.install_platbase\n\n        if DEBUG:\n            from pprint import pprint\n\n            print(\"config vars:\")\n            pprint(dict(self.config_vars))\n\n        # Expand \"~\" and configuration variables in the installation\n        # directories.\n        self.expand_dirs()\n\n        self.dump_dirs(\"post-expand_dirs()\")\n\n        # Create directories in the home dir:\n        if self.user:\n            self.create_home_path()\n\n        # Pick the actual directory to install all modules to: either\n        # install_purelib or install_platlib, depending on whether this\n        # module distribution is pure or not.  Of course, if the user\n        # already specified install_lib, use their selection.\n        if self.install_lib is None:\n            if self.distribution.has_ext_modules():  # has extensions: non-pure\n                self.install_lib = self.install_platlib\n            else:\n                self.install_lib = self.install_purelib\n\n        # Convert directories from Unix /-separated syntax to the local\n        # convention.\n        self.convert_paths(\n            'lib',\n            'purelib',\n            'platlib',\n            'scripts',\n            'data',\n            'headers',\n            'userbase',\n            'usersite',\n        )\n\n        # Deprecated\n        # Well, we're not actually fully completely finalized yet: we still\n        # have to deal with 'extra_path', which is the hack for allowing\n        # non-packagized module distributions (hello, Numerical Python!) to\n        # get their own directories.\n        self.handle_extra_path()\n        self.install_libbase = self.install_lib  # needed for .pth file\n        self.install_lib = os.path.join(self.install_lib, self.extra_dirs)\n\n        # If a new root directory was supplied, make all the installation\n        # dirs relative to it.\n        if self.root is not None:\n            self.change_roots(\n                'libbase', 'lib', 'purelib', 'platlib', 'scripts', 'data', 'headers'\n            )\n\n        self.dump_dirs(\"after prepending root\")\n\n        # Find out the build directories, ie. where to install from.\n        self.set_undefined_options(\n            'build', ('build_base', 'build_base'), ('build_lib', 'build_lib')\n        )\n\n        # Punt on doc directories for now -- after all, we're punting on\n        # documentation completely!\n\n    def dump_dirs(self, msg):\n        \"\"\"Dumps the list of user options.\"\"\"\n        if not DEBUG:\n            return\n        from ..fancy_getopt import longopt_xlate\n\n        log.debug(msg + \":\")\n        for opt in self.user_options:\n            opt_name = opt[0]\n            if opt_name[-1] == \"=\":\n                opt_name = opt_name[0:-1]\n            if opt_name in self.negative_opt:\n                opt_name = self.negative_opt[opt_name]\n                opt_name = opt_name.translate(longopt_xlate)\n                val = not getattr(self, opt_name)\n            else:\n                opt_name = opt_name.translate(longopt_xlate)\n                val = getattr(self, opt_name)\n            log.debug(\"  %s: %s\", opt_name, val)\n\n    def finalize_unix(self):\n        \"\"\"Finalizes options for posix platforms.\"\"\"\n        if self.install_base is not None or self.install_platbase is not None:\n            incomplete_scheme = (\n                (\n                    self.install_lib is None\n                    and self.install_purelib is None\n                    and self.install_platlib is None\n                )\n                or self.install_headers is None\n                or self.install_scripts is None\n                or self.install_data is None\n            )\n            if incomplete_scheme:\n                raise DistutilsOptionError(\n                    \"install-base or install-platbase supplied, but \"\n                    \"installation scheme is incomplete\"\n                )\n            return\n\n        if self.user:\n            if self.install_userbase is None:\n                raise DistutilsPlatformError(\"User base directory is not specified\")\n            self.install_base = self.install_platbase = self.install_userbase\n            self.select_scheme(\"posix_user\")\n        elif self.home is not None:\n            self.install_base = self.install_platbase = self.home\n            self.select_scheme(\"posix_home\")\n        else:\n            if self.prefix is None:\n                if self.exec_prefix is not None:\n                    raise DistutilsOptionError(\n                        \"must not supply exec-prefix without prefix\"\n                    )\n\n                # Allow Fedora to add components to the prefix\n                _prefix_addition = getattr(sysconfig, '_prefix_addition', \"\")\n\n                self.prefix = os.path.normpath(sys.prefix) + _prefix_addition\n                self.exec_prefix = os.path.normpath(sys.exec_prefix) + _prefix_addition\n\n            else:\n                if self.exec_prefix is None:\n                    self.exec_prefix = self.prefix\n\n            self.install_base = self.prefix\n            self.install_platbase = self.exec_prefix\n            self.select_scheme(\"posix_prefix\")\n\n    def finalize_other(self):\n        \"\"\"Finalizes options for non-posix platforms\"\"\"\n        if self.user:\n            if self.install_userbase is None:\n                raise DistutilsPlatformError(\"User base directory is not specified\")\n            self.install_base = self.install_platbase = self.install_userbase\n            self.select_scheme(os.name + \"_user\")\n        elif self.home is not None:\n            self.install_base = self.install_platbase = self.home\n            self.select_scheme(\"posix_home\")\n        else:\n            if self.prefix is None:\n                self.prefix = os.path.normpath(sys.prefix)\n\n            self.install_base = self.install_platbase = self.prefix\n            try:\n                self.select_scheme(os.name)\n            except KeyError:\n                raise DistutilsPlatformError(\n                    f\"I don't know how to install stuff on '{os.name}'\"\n                )\n\n    def select_scheme(self, name):\n        _select_scheme(self, name)\n\n    def _expand_attrs(self, attrs):\n        for attr in attrs:\n            val = getattr(self, attr)\n            if val is not None:\n                if os.name in ('posix', 'nt'):\n                    val = os.path.expanduser(val)\n                val = subst_vars(val, self.config_vars)\n                setattr(self, attr, val)\n\n    def expand_basedirs(self):\n        \"\"\"Calls `os.path.expanduser` on install_base, install_platbase and\n        root.\"\"\"\n        self._expand_attrs(['install_base', 'install_platbase', 'root'])\n\n    def expand_dirs(self):\n        \"\"\"Calls `os.path.expanduser` on install dirs.\"\"\"\n        self._expand_attrs([\n            'install_purelib',\n            'install_platlib',\n            'install_lib',\n            'install_headers',\n            'install_scripts',\n            'install_data',\n        ])\n\n    def convert_paths(self, *names):\n        \"\"\"Call `convert_path` over `names`.\"\"\"\n        for name in names:\n            attr = \"install_\" + name\n            setattr(self, attr, convert_path(getattr(self, attr)))\n\n    def handle_extra_path(self):\n        \"\"\"Set `path_file` and `extra_dirs` using `extra_path`.\"\"\"\n        if self.extra_path is None:\n            self.extra_path = self.distribution.extra_path\n\n        if self.extra_path is not None:\n            log.warning(\n                \"Distribution option extra_path is deprecated. \"\n                \"See issue27919 for details.\"\n            )\n            if isinstance(self.extra_path, str):\n                self.extra_path = self.extra_path.split(',')\n\n            if len(self.extra_path) == 1:\n                path_file = extra_dirs = self.extra_path[0]\n            elif len(self.extra_path) == 2:\n                path_file, extra_dirs = self.extra_path\n            else:\n                raise DistutilsOptionError(\n                    \"'extra_path' option must be a list, tuple, or \"\n                    \"comma-separated string with 1 or 2 elements\"\n                )\n\n            # convert to local form in case Unix notation used (as it\n            # should be in setup scripts)\n            extra_dirs = convert_path(extra_dirs)\n        else:\n            path_file = None\n            extra_dirs = ''\n\n        # XXX should we warn if path_file and not extra_dirs? (in which\n        # case the path file would be harmless but pointless)\n        self.path_file = path_file\n        self.extra_dirs = extra_dirs\n\n    def change_roots(self, *names):\n        \"\"\"Change the install directories pointed by name using root.\"\"\"\n        for name in names:\n            attr = \"install_\" + name\n            setattr(self, attr, change_root(self.root, getattr(self, attr)))\n\n    def create_home_path(self):\n        \"\"\"Create directories under ~.\"\"\"\n        if not self.user:\n            return\n        home = convert_path(os.path.expanduser(\"~\"))\n        for path in self.config_vars.values():\n            if str(path).startswith(home) and not os.path.isdir(path):\n                self.debug_print(f\"os.makedirs('{path}', 0o700)\")\n                os.makedirs(path, 0o700)\n\n    # -- Command execution methods -------------------------------------\n\n    def run(self):\n        \"\"\"Runs the command.\"\"\"\n        # Obviously have to build before we can install\n        if not self.skip_build:\n            self.run_command('build')\n            # If we built for any other platform, we can't install.\n            build_plat = self.distribution.get_command_obj('build').plat_name\n            # check warn_dir - it is a clue that the 'install' is happening\n            # internally, and not to sys.path, so we don't check the platform\n            # matches what we are running.\n            if self.warn_dir and build_plat != get_platform():\n                raise DistutilsPlatformError(\"Can't install when cross-compiling\")\n\n        # Run all sub-commands (at least those that need to be run)\n        for cmd_name in self.get_sub_commands():\n            self.run_command(cmd_name)\n\n        if self.path_file:\n            self.create_path_file()\n\n        # write list of installed files, if requested.\n        if self.record:\n            outputs = self.get_outputs()\n            if self.root:  # strip any package prefix\n                root_len = len(self.root)\n                for counter in range(len(outputs)):\n                    outputs[counter] = outputs[counter][root_len:]\n            self.execute(\n                write_file,\n                (self.record, outputs),\n                f\"writing list of installed files to '{self.record}'\",\n            )\n\n        sys_path = map(os.path.normpath, sys.path)\n        sys_path = map(os.path.normcase, sys_path)\n        install_lib = os.path.normcase(os.path.normpath(self.install_lib))\n        if (\n            self.warn_dir\n            and not (self.path_file and self.install_path_file)\n            and install_lib not in sys_path\n        ):\n            log.debug(\n                (\n                    \"modules installed to '%s', which is not in \"\n                    \"Python's module search path (sys.path) -- \"\n                    \"you'll have to change the search path yourself\"\n                ),\n                self.install_lib,\n            )\n\n    def create_path_file(self):\n        \"\"\"Creates the .pth file\"\"\"\n        filename = os.path.join(self.install_libbase, self.path_file + \".pth\")\n        if self.install_path_file:\n            self.execute(\n                write_file, (filename, [self.extra_dirs]), f\"creating {filename}\"\n            )\n        else:\n            self.warn(f\"path file '{filename}' not created\")\n\n    # -- Reporting methods ---------------------------------------------\n\n    def get_outputs(self):\n        \"\"\"Assembles the outputs of all the sub-commands.\"\"\"\n        outputs = []\n        for cmd_name in self.get_sub_commands():\n            cmd = self.get_finalized_command(cmd_name)\n            # Add the contents of cmd.get_outputs(), ensuring\n            # that outputs doesn't contain duplicate entries\n            for filename in cmd.get_outputs():\n                if filename not in outputs:\n                    outputs.append(filename)\n\n        if self.path_file and self.install_path_file:\n            outputs.append(os.path.join(self.install_libbase, self.path_file + \".pth\"))\n\n        return outputs\n\n    def get_inputs(self):\n        \"\"\"Returns the inputs of all the sub-commands\"\"\"\n        # XXX gee, this looks familiar ;-(\n        inputs = []\n        for cmd_name in self.get_sub_commands():\n            cmd = self.get_finalized_command(cmd_name)\n            inputs.extend(cmd.get_inputs())\n\n        return inputs\n\n    # -- Predicates for sub-command list -------------------------------\n\n    def has_lib(self):\n        \"\"\"Returns true if the current distribution has any Python\n        modules to install.\"\"\"\n        return (\n            self.distribution.has_pure_modules() or self.distribution.has_ext_modules()\n        )\n\n    def has_headers(self):\n        \"\"\"Returns true if the current distribution has any headers to\n        install.\"\"\"\n        return self.distribution.has_headers()\n\n    def has_scripts(self):\n        \"\"\"Returns true if the current distribution has any scripts to.\n        install.\"\"\"\n        return self.distribution.has_scripts()\n\n    def has_data(self):\n        \"\"\"Returns true if the current distribution has any data to.\n        install.\"\"\"\n        return self.distribution.has_data_files()\n\n    # 'sub_commands': a list of commands this command might have to run to\n    # get its work done.  See cmd.py for more info.\n    sub_commands = [\n        ('install_lib', has_lib),\n        ('install_headers', has_headers),\n        ('install_scripts', has_scripts),\n        ('install_data', has_data),\n        ('install_egg_info', lambda self: True),\n    ]\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/command/install_data.py","size":2810,"sha1":"297e82ca468249e716e27b4468afe64a6ca4d8ad","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.command.install_data\n\nImplements the Distutils 'install_data' command, for installing\nplatform-independent data files.\"\"\"\n\n# contributed by Bastian Kleineidam\n\nfrom __future__ import annotations\n\nimport functools\nimport os\nfrom collections.abc import Iterable\n\nfrom ..core import Command\nfrom ..util import change_root, convert_path\n\n\nclass install_data(Command):\n    description = \"install data files\"\n\n    user_options = [\n        (\n            'install-dir=',\n            'd',\n            \"base directory for installing data files [default: installation base dir]\",\n        ),\n        ('root=', None, \"install everything relative to this alternate root directory\"),\n        ('force', 'f', \"force installation (overwrite existing files)\"),\n    ]\n\n    boolean_options = ['force']\n\n    def initialize_options(self):\n        self.install_dir = None\n        self.outfiles = []\n        self.root = None\n        self.force = False\n        self.data_files = self.distribution.data_files\n        self.warn_dir = True\n\n    def finalize_options(self):\n        self.set_undefined_options(\n            'install',\n            ('install_data', 'install_dir'),\n            ('root', 'root'),\n            ('force', 'force'),\n        )\n\n    def run(self):\n        self.mkpath(self.install_dir)\n        for f in self.data_files:\n            self._copy(f)\n\n    @functools.singledispatchmethod\n    def _copy(self, f: tuple[str | os.PathLike, Iterable[str | os.PathLike]]):\n        # it's a tuple with path to install to and a list of files\n        dir = convert_path(f[0])\n        if not os.path.isabs(dir):\n            dir = os.path.join(self.install_dir, dir)\n        elif self.root:\n            dir = change_root(self.root, dir)\n        self.mkpath(dir)\n\n        if f[1] == []:\n            # If there are no files listed, the user must be\n            # trying to create an empty directory, so add the\n            # directory to the list of output files.\n            self.outfiles.append(dir)\n        else:\n            # Copy files, adding them to the list of output files.\n            for data in f[1]:\n                data = convert_path(data)\n                (out, _) = self.copy_file(data, dir)\n                self.outfiles.append(out)\n\n    @_copy.register(str)\n    @_copy.register(os.PathLike)\n    def _(self, f: str | os.PathLike):\n        # it's a simple file, so copy it\n        f = convert_path(f)\n        if self.warn_dir:\n            self.warn(\n                \"setup script did not provide a directory for \"\n                f\"'{f}' -- installing right in '{self.install_dir}'\"\n            )\n        (out, _) = self.copy_file(f, self.install_dir)\n        self.outfiles.append(out)\n\n    def get_inputs(self):\n        return self.data_files or []\n\n    def get_outputs(self):\n        return self.outfiles\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/command/install_egg_info.py","size":2868,"sha1":"7acbb9da9aeb8e9b08bc84543d5cf34096f84cae","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\ndistutils.command.install_egg_info\n\nImplements the Distutils 'install_egg_info' command, for installing\na package's PKG-INFO metadata.\n\"\"\"\n\nimport os\nimport re\nimport sys\nfrom typing import ClassVar\n\nfrom .. import dir_util\nfrom .._log import log\nfrom ..cmd import Command\n\n\nclass install_egg_info(Command):\n    \"\"\"Install an .egg-info file for the package\"\"\"\n\n    description = \"Install package's PKG-INFO metadata as an .egg-info file\"\n    user_options: ClassVar[list[tuple[str, str, str]]] = [\n        ('install-dir=', 'd', \"directory to install to\"),\n    ]\n\n    def initialize_options(self):\n        self.install_dir = None\n\n    @property\n    def basename(self):\n        \"\"\"\n        Allow basename to be overridden by child class.\n        Ref pypa/distutils#2.\n        \"\"\"\n        name = to_filename(safe_name(self.distribution.get_name()))\n        version = to_filename(safe_version(self.distribution.get_version()))\n        return f\"{name}-{version}-py{sys.version_info.major}.{sys.version_info.minor}.egg-info\"\n\n    def finalize_options(self):\n        self.set_undefined_options('install_lib', ('install_dir', 'install_dir'))\n        self.target = os.path.join(self.install_dir, self.basename)\n        self.outputs = [self.target]\n\n    def run(self):\n        target = self.target\n        if os.path.isdir(target) and not os.path.islink(target):\n            dir_util.remove_tree(target, dry_run=self.dry_run)\n        elif os.path.exists(target):\n            self.execute(os.unlink, (self.target,), \"Removing \" + target)\n        elif not os.path.isdir(self.install_dir):\n            self.execute(\n                os.makedirs, (self.install_dir,), \"Creating \" + self.install_dir\n            )\n        log.info(\"Writing %s\", target)\n        if not self.dry_run:\n            with open(target, 'w', encoding='UTF-8') as f:\n                self.distribution.metadata.write_pkg_file(f)\n\n    def get_outputs(self):\n        return self.outputs\n\n\n# The following routines are taken from setuptools' pkg_resources module and\n# can be replaced by importing them from pkg_resources once it is included\n# in the stdlib.\n\n\ndef safe_name(name):\n    \"\"\"Convert an arbitrary string to a standard distribution name\n\n    Any runs of non-alphanumeric/. characters are replaced with a single '-'.\n    \"\"\"\n    return re.sub('[^A-Za-z0-9.]+', '-', name)\n\n\ndef safe_version(version):\n    \"\"\"Convert an arbitrary string to a standard version string\n\n    Spaces become dots, and all other non-alphanumeric characters become\n    dashes, with runs of multiple dashes condensed to a single dash.\n    \"\"\"\n    version = version.replace(' ', '.')\n    return re.sub('[^A-Za-z0-9.]+', '-', version)\n\n\ndef to_filename(name):\n    \"\"\"Convert a project or version name to its filename-escaped form\n\n    Any '-' characters are currently replaced with '_'.\n    \"\"\"\n    return name.replace('-', '_')\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/command/install_headers.py","size":1251,"sha1":"42ac46fe55bee9d5b7be8737f2fde3d1572aa7bb","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.command.install_headers\n\nImplements the Distutils 'install_headers' command, to install C/C++ header\nfiles to the Python include directory.\"\"\"\n\nfrom typing import ClassVar\n\nfrom ..core import Command\n\n\n# XXX force is never used\nclass install_headers(Command):\n    description = \"install C/C++ header files\"\n\n    user_options: ClassVar[list[tuple[str, str, str]]] = [\n        ('install-dir=', 'd', \"directory to install header files to\"),\n        ('force', 'f', \"force installation (overwrite existing files)\"),\n    ]\n\n    boolean_options = ['force']\n\n    def initialize_options(self):\n        self.install_dir = None\n        self.force = False\n        self.outfiles = []\n\n    def finalize_options(self):\n        self.set_undefined_options(\n            'install', ('install_headers', 'install_dir'), ('force', 'force')\n        )\n\n    def run(self):\n        headers = self.distribution.headers\n        if not headers:\n            return\n\n        self.mkpath(self.install_dir)\n        for header in headers:\n            (out, _) = self.copy_file(header, self.install_dir)\n            self.outfiles.append(out)\n\n    def get_inputs(self):\n        return self.distribution.headers or []\n\n    def get_outputs(self):\n        return self.outfiles\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/command/install_lib.py","size":8330,"sha1":"b504e6f3909c1650ba8cc9e3309462512ef9a3d9","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.command.install_lib\n\nImplements the Distutils 'install_lib' command\n(install all Python modules).\"\"\"\n\nimport importlib.util\nimport os\nimport sys\n\nfrom ..core import Command\nfrom ..errors import DistutilsOptionError\n\n# Extension for Python source files.\nPYTHON_SOURCE_EXTENSION = \".py\"\n\n\nclass install_lib(Command):\n    description = \"install all Python modules (extensions and pure Python)\"\n\n    # The byte-compilation options are a tad confusing.  Here are the\n    # possible scenarios:\n    #   1) no compilation at all (--no-compile --no-optimize)\n    #   2) compile .pyc only (--compile --no-optimize; default)\n    #   3) compile .pyc and \"opt-1\" .pyc (--compile --optimize)\n    #   4) compile \"opt-1\" .pyc only (--no-compile --optimize)\n    #   5) compile .pyc and \"opt-2\" .pyc (--compile --optimize-more)\n    #   6) compile \"opt-2\" .pyc only (--no-compile --optimize-more)\n    #\n    # The UI for this is two options, 'compile' and 'optimize'.\n    # 'compile' is strictly boolean, and only decides whether to\n    # generate .pyc files.  'optimize' is three-way (0, 1, or 2), and\n    # decides both whether to generate .pyc files and what level of\n    # optimization to use.\n\n    user_options = [\n        ('install-dir=', 'd', \"directory to install to\"),\n        ('build-dir=', 'b', \"build directory (where to install from)\"),\n        ('force', 'f', \"force installation (overwrite existing files)\"),\n        ('compile', 'c', \"compile .py to .pyc [default]\"),\n        ('no-compile', None, \"don't compile .py files\"),\n        (\n            'optimize=',\n            'O',\n            \"also compile with optimization: -O1 for \\\"python -O\\\", \"\n            \"-O2 for \\\"python -OO\\\", and -O0 to disable [default: -O0]\",\n        ),\n        ('skip-build', None, \"skip the build steps\"),\n    ]\n\n    boolean_options = ['force', 'compile', 'skip-build']\n    negative_opt = {'no-compile': 'compile'}\n\n    def initialize_options(self):\n        # let the 'install' command dictate our installation directory\n        self.install_dir = None\n        self.build_dir = None\n        self.force = False\n        self.compile = None\n        self.optimize = None\n        self.skip_build = None\n\n    def finalize_options(self):\n        # Get all the information we need to install pure Python modules\n        # from the umbrella 'install' command -- build (source) directory,\n        # install (target) directory, and whether to compile .py files.\n        self.set_undefined_options(\n            'install',\n            ('build_lib', 'build_dir'),\n            ('install_lib', 'install_dir'),\n            ('force', 'force'),\n            ('compile', 'compile'),\n            ('optimize', 'optimize'),\n            ('skip_build', 'skip_build'),\n        )\n\n        if self.compile is None:\n            self.compile = True\n        if self.optimize is None:\n            self.optimize = False\n\n        if not isinstance(self.optimize, int):\n            try:\n                self.optimize = int(self.optimize)\n            except ValueError:\n                pass\n            if self.optimize not in (0, 1, 2):\n                raise DistutilsOptionError(\"optimize must be 0, 1, or 2\")\n\n    def run(self):\n        # Make sure we have built everything we need first\n        self.build()\n\n        # Install everything: simply dump the entire contents of the build\n        # directory to the installation directory (that's the beauty of\n        # having a build directory!)\n        outfiles = self.install()\n\n        # (Optionally) compile .py to .pyc\n        if outfiles is not None and self.distribution.has_pure_modules():\n            self.byte_compile(outfiles)\n\n    # -- Top-level worker functions ------------------------------------\n    # (called from 'run()')\n\n    def build(self):\n        if not self.skip_build:\n            if self.distribution.has_pure_modules():\n                self.run_command('build_py')\n            if self.distribution.has_ext_modules():\n                self.run_command('build_ext')\n\n    def install(self):\n        if os.path.isdir(self.build_dir):\n            outfiles = self.copy_tree(self.build_dir, self.install_dir)\n        else:\n            self.warn(\n                f\"'{self.build_dir}' does not exist -- no Python modules to install\"\n            )\n            return\n        return outfiles\n\n    def byte_compile(self, files):\n        if sys.dont_write_bytecode:\n            self.warn('byte-compiling is disabled, skipping.')\n            return\n\n        from ..util import byte_compile\n\n        # Get the \"--root\" directory supplied to the \"install\" command,\n        # and use it as a prefix to strip off the purported filename\n        # encoded in bytecode files.  This is far from complete, but it\n        # should at least generate usable bytecode in RPM distributions.\n        install_root = self.get_finalized_command('install').root\n\n        if self.compile:\n            byte_compile(\n                files,\n                optimize=0,\n                force=self.force,\n                prefix=install_root,\n                dry_run=self.dry_run,\n            )\n        if self.optimize > 0:\n            byte_compile(\n                files,\n                optimize=self.optimize,\n                force=self.force,\n                prefix=install_root,\n                verbose=self.verbose,\n                dry_run=self.dry_run,\n            )\n\n    # -- Utility methods -----------------------------------------------\n\n    def _mutate_outputs(self, has_any, build_cmd, cmd_option, output_dir):\n        if not has_any:\n            return []\n\n        build_cmd = self.get_finalized_command(build_cmd)\n        build_files = build_cmd.get_outputs()\n        build_dir = getattr(build_cmd, cmd_option)\n\n        prefix_len = len(build_dir) + len(os.sep)\n        outputs = [os.path.join(output_dir, file[prefix_len:]) for file in build_files]\n\n        return outputs\n\n    def _bytecode_filenames(self, py_filenames):\n        bytecode_files = []\n        for py_file in py_filenames:\n            # Since build_py handles package data installation, the\n            # list of outputs can contain more than just .py files.\n            # Make sure we only report bytecode for the .py files.\n            ext = os.path.splitext(os.path.normcase(py_file))[1]\n            if ext != PYTHON_SOURCE_EXTENSION:\n                continue\n            if self.compile:\n                bytecode_files.append(\n                    importlib.util.cache_from_source(py_file, optimization='')\n                )\n            if self.optimize > 0:\n                bytecode_files.append(\n                    importlib.util.cache_from_source(\n                        py_file, optimization=self.optimize\n                    )\n                )\n\n        return bytecode_files\n\n    # -- External interface --------------------------------------------\n    # (called by outsiders)\n\n    def get_outputs(self):\n        \"\"\"Return the list of files that would be installed if this command\n        were actually run.  Not affected by the \"dry-run\" flag or whether\n        modules have actually been built yet.\n        \"\"\"\n        pure_outputs = self._mutate_outputs(\n            self.distribution.has_pure_modules(),\n            'build_py',\n            'build_lib',\n            self.install_dir,\n        )\n        if self.compile:\n            bytecode_outputs = self._bytecode_filenames(pure_outputs)\n        else:\n            bytecode_outputs = []\n\n        ext_outputs = self._mutate_outputs(\n            self.distribution.has_ext_modules(),\n            'build_ext',\n            'build_lib',\n            self.install_dir,\n        )\n\n        return pure_outputs + bytecode_outputs + ext_outputs\n\n    def get_inputs(self):\n        \"\"\"Get the list of files that are input to this command, ie. the\n        files that get installed as they are named in the build tree.\n        The files in this list correspond one-to-one to the output\n        filenames returned by 'get_outputs()'.\n        \"\"\"\n        inputs = []\n\n        if self.distribution.has_pure_modules():\n            build_py = self.get_finalized_command('build_py')\n            inputs.extend(build_py.get_outputs())\n\n        if self.distribution.has_ext_modules():\n            build_ext = self.get_finalized_command('build_ext')\n            inputs.extend(build_ext.get_outputs())\n\n        return inputs\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/command/install_scripts.py","size":1937,"sha1":"ff0d81afb24ae49c01c57e14eecdb0b91af33fd9","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.command.install_scripts\n\nImplements the Distutils 'install_scripts' command, for installing\nPython scripts.\"\"\"\n\n# contributed by Bastian Kleineidam\n\nimport os\nfrom distutils._log import log\nfrom stat import ST_MODE\n\nfrom ..core import Command\n\n\nclass install_scripts(Command):\n    description = \"install scripts (Python or otherwise)\"\n\n    user_options = [\n        ('install-dir=', 'd', \"directory to install scripts to\"),\n        ('build-dir=', 'b', \"build directory (where to install from)\"),\n        ('force', 'f', \"force installation (overwrite existing files)\"),\n        ('skip-build', None, \"skip the build steps\"),\n    ]\n\n    boolean_options = ['force', 'skip-build']\n\n    def initialize_options(self):\n        self.install_dir = None\n        self.force = False\n        self.build_dir = None\n        self.skip_build = None\n\n    def finalize_options(self):\n        self.set_undefined_options('build', ('build_scripts', 'build_dir'))\n        self.set_undefined_options(\n            'install',\n            ('install_scripts', 'install_dir'),\n            ('force', 'force'),\n            ('skip_build', 'skip_build'),\n        )\n\n    def run(self):\n        if not self.skip_build:\n            self.run_command('build_scripts')\n        self.outfiles = self.copy_tree(self.build_dir, self.install_dir)\n        if os.name == 'posix':\n            # Set the executable bits (owner, group, and world) on\n            # all the scripts we just installed.\n            for file in self.get_outputs():\n                if self.dry_run:\n                    log.info(\"changing mode of %s\", file)\n                else:\n                    mode = ((os.stat(file)[ST_MODE]) | 0o555) & 0o7777\n                    log.info(\"changing mode of %s to %o\", file, mode)\n                    os.chmod(file, mode)\n\n    def get_inputs(self):\n        return self.distribution.scripts or []\n\n    def get_outputs(self):\n        return self.outfiles or []\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/command/sdist.py","size":18837,"sha1":"6b42ea6228d6c43da730c3f5a1748aa141dfc04c","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.command.sdist\n\nImplements the Distutils 'sdist' command (create a source distribution).\"\"\"\n\nimport os\nimport sys\nfrom distutils import archive_util, dir_util, file_util\nfrom distutils._log import log\nfrom glob import glob\nfrom itertools import filterfalse\nfrom typing import ClassVar\n\nfrom ..core import Command\nfrom ..errors import DistutilsOptionError, DistutilsTemplateError\nfrom ..filelist import FileList\nfrom ..text_file import TextFile\nfrom ..util import convert_path\n\n\ndef show_formats():\n    \"\"\"Print all possible values for the 'formats' option (used by\n    the \"--help-formats\" command-line option).\n    \"\"\"\n    from ..archive_util import ARCHIVE_FORMATS\n    from ..fancy_getopt import FancyGetopt\n\n    formats = sorted(\n        (\"formats=\" + format, None, ARCHIVE_FORMATS[format][2])\n        for format in ARCHIVE_FORMATS.keys()\n    )\n    FancyGetopt(formats).print_help(\"List of available source distribution formats:\")\n\n\nclass sdist(Command):\n    description = \"create a source distribution (tarball, zip file, etc.)\"\n\n    def checking_metadata(self):\n        \"\"\"Callable used for the check sub-command.\n\n        Placed here so user_options can view it\"\"\"\n        return self.metadata_check\n\n    user_options = [\n        ('template=', 't', \"name of manifest template file [default: MANIFEST.in]\"),\n        ('manifest=', 'm', \"name of manifest file [default: MANIFEST]\"),\n        (\n            'use-defaults',\n            None,\n            \"include the default file set in the manifest \"\n            \"[default; disable with --no-defaults]\",\n        ),\n        ('no-defaults', None, \"don't include the default file set\"),\n        (\n            'prune',\n            None,\n            \"specifically exclude files/directories that should not be \"\n            \"distributed (build tree, RCS/CVS dirs, etc.) \"\n            \"[default; disable with --no-prune]\",\n        ),\n        ('no-prune', None, \"don't automatically exclude anything\"),\n        (\n            'manifest-only',\n            'o',\n            \"just regenerate the manifest and then stop (implies --force-manifest)\",\n        ),\n        (\n            'force-manifest',\n            'f',\n            \"forcibly regenerate the manifest and carry on as usual. \"\n            \"Deprecated: now the manifest is always regenerated.\",\n        ),\n        ('formats=', None, \"formats for source distribution (comma-separated list)\"),\n        (\n            'keep-temp',\n            'k',\n            \"keep the distribution tree around after creating \" + \"archive file(s)\",\n        ),\n        (\n            'dist-dir=',\n            'd',\n            \"directory to put the source distribution archive(s) in [default: dist]\",\n        ),\n        (\n            'metadata-check',\n            None,\n            \"Ensure that all required elements of meta-data \"\n            \"are supplied. Warn if any missing. [default]\",\n        ),\n        (\n            'owner=',\n            'u',\n            \"Owner name used when creating a tar file [default: current user]\",\n        ),\n        (\n            'group=',\n            'g',\n            \"Group name used when creating a tar file [default: current group]\",\n        ),\n    ]\n\n    boolean_options = [\n        'use-defaults',\n        'prune',\n        'manifest-only',\n        'force-manifest',\n        'keep-temp',\n        'metadata-check',\n    ]\n\n    help_options = [\n        ('help-formats', None, \"list available distribution formats\", show_formats),\n    ]\n\n    negative_opt = {'no-defaults': 'use-defaults', 'no-prune': 'prune'}\n\n    sub_commands = [('check', checking_metadata)]\n\n    READMES: ClassVar[tuple[str, ...]] = ('README', 'README.txt', 'README.rst')\n\n    def initialize_options(self):\n        # 'template' and 'manifest' are, respectively, the names of\n        # the manifest template and manifest file.\n        self.template = None\n        self.manifest = None\n\n        # 'use_defaults': if true, we will include the default file set\n        # in the manifest\n        self.use_defaults = True\n        self.prune = True\n\n        self.manifest_only = False\n        self.force_manifest = False\n\n        self.formats = ['gztar']\n        self.keep_temp = False\n        self.dist_dir = None\n\n        self.archive_files = None\n        self.metadata_check = 1\n        self.owner = None\n        self.group = None\n\n    def finalize_options(self):\n        if self.manifest is None:\n            self.manifest = \"MANIFEST\"\n        if self.template is None:\n            self.template = \"MANIFEST.in\"\n\n        self.ensure_string_list('formats')\n\n        bad_format = archive_util.check_archive_formats(self.formats)\n        if bad_format:\n            raise DistutilsOptionError(f\"unknown archive format '{bad_format}'\")\n\n        if self.dist_dir is None:\n            self.dist_dir = \"dist\"\n\n    def run(self):\n        # 'filelist' contains the list of files that will make up the\n        # manifest\n        self.filelist = FileList()\n\n        # Run sub commands\n        for cmd_name in self.get_sub_commands():\n            self.run_command(cmd_name)\n\n        # Do whatever it takes to get the list of files to process\n        # (process the manifest template, read an existing manifest,\n        # whatever).  File list is accumulated in 'self.filelist'.\n        self.get_file_list()\n\n        # If user just wanted us to regenerate the manifest, stop now.\n        if self.manifest_only:\n            return\n\n        # Otherwise, go ahead and create the source distribution tarball,\n        # or zipfile, or whatever.\n        self.make_distribution()\n\n    def get_file_list(self):\n        \"\"\"Figure out the list of files to include in the source\n        distribution, and put it in 'self.filelist'.  This might involve\n        reading the manifest template (and writing the manifest), or just\n        reading the manifest, or just using the default file set -- it all\n        depends on the user's options.\n        \"\"\"\n        # new behavior when using a template:\n        # the file list is recalculated every time because\n        # even if MANIFEST.in or setup.py are not changed\n        # the user might have added some files in the tree that\n        # need to be included.\n        #\n        #  This makes --force the default and only behavior with templates.\n        template_exists = os.path.isfile(self.template)\n        if not template_exists and self._manifest_is_not_generated():\n            self.read_manifest()\n            self.filelist.sort()\n            self.filelist.remove_duplicates()\n            return\n\n        if not template_exists:\n            self.warn(\n                (\"manifest template '%s' does not exist \" + \"(using default file list)\")\n                % self.template\n            )\n        self.filelist.findall()\n\n        if self.use_defaults:\n            self.add_defaults()\n\n        if template_exists:\n            self.read_template()\n\n        if self.prune:\n            self.prune_file_list()\n\n        self.filelist.sort()\n        self.filelist.remove_duplicates()\n        self.write_manifest()\n\n    def add_defaults(self):\n        \"\"\"Add all the default files to self.filelist:\n          - README or README.txt\n          - setup.py\n          - tests/test*.py and test/test*.py\n          - all pure Python modules mentioned in setup script\n          - all files pointed by package_data (build_py)\n          - all files defined in data_files.\n          - all files defined as scripts.\n          - all C sources listed as part of extensions or C libraries\n            in the setup script (doesn't catch C headers!)\n        Warns if (README or README.txt) or setup.py are missing; everything\n        else is optional.\n        \"\"\"\n        self._add_defaults_standards()\n        self._add_defaults_optional()\n        self._add_defaults_python()\n        self._add_defaults_data_files()\n        self._add_defaults_ext()\n        self._add_defaults_c_libs()\n        self._add_defaults_scripts()\n\n    @staticmethod\n    def _cs_path_exists(fspath):\n        \"\"\"\n        Case-sensitive path existence check\n\n        >>> sdist._cs_path_exists(__file__)\n        True\n        >>> sdist._cs_path_exists(__file__.upper())\n        False\n        \"\"\"\n        if not os.path.exists(fspath):\n            return False\n        # make absolute so we always have a directory\n        abspath = os.path.abspath(fspath)\n        directory, filename = os.path.split(abspath)\n        return filename in os.listdir(directory)\n\n    def _add_defaults_standards(self):\n        standards = [self.READMES, self.distribution.script_name]\n        for fn in standards:\n            if isinstance(fn, tuple):\n                alts = fn\n                got_it = False\n                for fn in alts:\n                    if self._cs_path_exists(fn):\n                        got_it = True\n                        self.filelist.append(fn)\n                        break\n\n                if not got_it:\n                    self.warn(\n                        \"standard file not found: should have one of \" + ', '.join(alts)\n                    )\n            else:\n                if self._cs_path_exists(fn):\n                    self.filelist.append(fn)\n                else:\n                    self.warn(f\"standard file '{fn}' not found\")\n\n    def _add_defaults_optional(self):\n        optional = ['tests/test*.py', 'test/test*.py', 'setup.cfg']\n        for pattern in optional:\n            files = filter(os.path.isfile, glob(pattern))\n            self.filelist.extend(files)\n\n    def _add_defaults_python(self):\n        # build_py is used to get:\n        #  - python modules\n        #  - files defined in package_data\n        build_py = self.get_finalized_command('build_py')\n\n        # getting python files\n        if self.distribution.has_pure_modules():\n            self.filelist.extend(build_py.get_source_files())\n\n        # getting package_data files\n        # (computed in build_py.data_files by build_py.finalize_options)\n        for _pkg, src_dir, _build_dir, filenames in build_py.data_files:\n            for filename in filenames:\n                self.filelist.append(os.path.join(src_dir, filename))\n\n    def _add_defaults_data_files(self):\n        # getting distribution.data_files\n        if self.distribution.has_data_files():\n            for item in self.distribution.data_files:\n                if isinstance(item, str):\n                    # plain file\n                    item = convert_path(item)\n                    if os.path.isfile(item):\n                        self.filelist.append(item)\n                else:\n                    # a (dirname, filenames) tuple\n                    dirname, filenames = item\n                    for f in filenames:\n                        f = convert_path(f)\n                        if os.path.isfile(f):\n                            self.filelist.append(f)\n\n    def _add_defaults_ext(self):\n        if self.distribution.has_ext_modules():\n            build_ext = self.get_finalized_command('build_ext')\n            self.filelist.extend(build_ext.get_source_files())\n\n    def _add_defaults_c_libs(self):\n        if self.distribution.has_c_libraries():\n            build_clib = self.get_finalized_command('build_clib')\n            self.filelist.extend(build_clib.get_source_files())\n\n    def _add_defaults_scripts(self):\n        if self.distribution.has_scripts():\n            build_scripts = self.get_finalized_command('build_scripts')\n            self.filelist.extend(build_scripts.get_source_files())\n\n    def read_template(self):\n        \"\"\"Read and parse manifest template file named by self.template.\n\n        (usually \"MANIFEST.in\") The parsing and processing is done by\n        'self.filelist', which updates itself accordingly.\n        \"\"\"\n        log.info(\"reading manifest template '%s'\", self.template)\n        template = TextFile(\n            self.template,\n            strip_comments=True,\n            skip_blanks=True,\n            join_lines=True,\n            lstrip_ws=True,\n            rstrip_ws=True,\n            collapse_join=True,\n        )\n\n        try:\n            while True:\n                line = template.readline()\n                if line is None:  # end of file\n                    break\n\n                try:\n                    self.filelist.process_template_line(line)\n                # the call above can raise a DistutilsTemplateError for\n                # malformed lines, or a ValueError from the lower-level\n                # convert_path function\n                except (DistutilsTemplateError, ValueError) as msg:\n                    self.warn(\n                        f\"{template.filename}, line {int(template.current_line)}: {msg}\"\n                    )\n        finally:\n            template.close()\n\n    def prune_file_list(self):\n        \"\"\"Prune off branches that might slip into the file list as created\n        by 'read_template()', but really don't belong there:\n          * the build tree (typically \"build\")\n          * the release tree itself (only an issue if we ran \"sdist\"\n            previously with --keep-temp, or it aborted)\n          * any RCS, CVS, .svn, .hg, .git, .bzr, _darcs directories\n        \"\"\"\n        build = self.get_finalized_command('build')\n        base_dir = self.distribution.get_fullname()\n\n        self.filelist.exclude_pattern(None, prefix=os.fspath(build.build_base))\n        self.filelist.exclude_pattern(None, prefix=base_dir)\n\n        if sys.platform == 'win32':\n            seps = r'/|\\\\'\n        else:\n            seps = '/'\n\n        vcs_dirs = ['RCS', 'CVS', r'\\.svn', r'\\.hg', r'\\.git', r'\\.bzr', '_darcs']\n        vcs_ptrn = r'(^|{})({})({}).*'.format(seps, '|'.join(vcs_dirs), seps)\n        self.filelist.exclude_pattern(vcs_ptrn, is_regex=True)\n\n    def write_manifest(self):\n        \"\"\"Write the file list in 'self.filelist' (presumably as filled in\n        by 'add_defaults()' and 'read_template()') to the manifest file\n        named by 'self.manifest'.\n        \"\"\"\n        if self._manifest_is_not_generated():\n            log.info(\n                f\"not writing to manually maintained manifest file '{self.manifest}'\"\n            )\n            return\n\n        content = self.filelist.files[:]\n        content.insert(0, '# file GENERATED by distutils, do NOT edit')\n        self.execute(\n            file_util.write_file,\n            (self.manifest, content),\n            f\"writing manifest file '{self.manifest}'\",\n        )\n\n    def _manifest_is_not_generated(self):\n        # check for special comment used in 3.1.3 and higher\n        if not os.path.isfile(self.manifest):\n            return False\n\n        with open(self.manifest, encoding='utf-8') as fp:\n            first_line = next(fp)\n        return first_line != '# file GENERATED by distutils, do NOT edit\\n'\n\n    def read_manifest(self):\n        \"\"\"Read the manifest file (named by 'self.manifest') and use it to\n        fill in 'self.filelist', the list of files to include in the source\n        distribution.\n        \"\"\"\n        log.info(\"reading manifest file '%s'\", self.manifest)\n        with open(self.manifest, encoding='utf-8') as lines:\n            self.filelist.extend(\n                # ignore comments and blank lines\n                filter(None, filterfalse(is_comment, map(str.strip, lines)))\n            )\n\n    def make_release_tree(self, base_dir, files):\n        \"\"\"Create the directory tree that will become the source\n        distribution archive.  All directories implied by the filenames in\n        'files' are created under 'base_dir', and then we hard link or copy\n        (if hard linking is unavailable) those files into place.\n        Essentially, this duplicates the developer's source tree, but in a\n        directory named after the distribution, containing only the files\n        to be distributed.\n        \"\"\"\n        # Create all the directories under 'base_dir' necessary to\n        # put 'files' there; the 'mkpath()' is just so we don't die\n        # if the manifest happens to be empty.\n        self.mkpath(base_dir)\n        dir_util.create_tree(base_dir, files, dry_run=self.dry_run)\n\n        # And walk over the list of files, either making a hard link (if\n        # os.link exists) to each one that doesn't already exist in its\n        # corresponding location under 'base_dir', or copying each file\n        # that's out-of-date in 'base_dir'.  (Usually, all files will be\n        # out-of-date, because by default we blow away 'base_dir' when\n        # we're done making the distribution archives.)\n\n        if hasattr(os, 'link'):  # can make hard links on this system\n            link = 'hard'\n            msg = f\"making hard links in {base_dir}...\"\n        else:  # nope, have to copy\n            link = None\n            msg = f\"copying files to {base_dir}...\"\n\n        if not files:\n            log.warning(\"no files to distribute -- empty manifest?\")\n        else:\n            log.info(msg)\n        for file in files:\n            if not os.path.isfile(file):\n                log.warning(\"'%s' not a regular file -- skipping\", file)\n            else:\n                dest = os.path.join(base_dir, file)\n                self.copy_file(file, dest, link=link)\n\n        self.distribution.metadata.write_pkg_info(base_dir)\n\n    def make_distribution(self):\n        \"\"\"Create the source distribution(s).  First, we create the release\n        tree with 'make_release_tree()'; then, we create all required\n        archive files (according to 'self.formats') from the release tree.\n        Finally, we clean up by blowing away the release tree (unless\n        'self.keep_temp' is true).  The list of archive files created is\n        stored so it can be retrieved later by 'get_archive_files()'.\n        \"\"\"\n        # Don't warn about missing meta-data here -- should be (and is!)\n        # done elsewhere.\n        base_dir = self.distribution.get_fullname()\n        base_name = os.path.join(self.dist_dir, base_dir)\n\n        self.make_release_tree(base_dir, self.filelist.files)\n        archive_files = []  # remember names of files we create\n        # tar archive must be created last to avoid overwrite and remove\n        if 'tar' in self.formats:\n            self.formats.append(self.formats.pop(self.formats.index('tar')))\n\n        for fmt in self.formats:\n            file = self.make_archive(\n                base_name, fmt, base_dir=base_dir, owner=self.owner, group=self.group\n            )\n            archive_files.append(file)\n            self.distribution.dist_files.append(('sdist', '', file))\n\n        self.archive_files = archive_files\n\n        if not self.keep_temp:\n            dir_util.remove_tree(base_dir, dry_run=self.dry_run)\n\n    def get_archive_files(self):\n        \"\"\"Return the list of archive files created when the command\n        was run, or None if the command hasn't run yet.\n        \"\"\"\n        return self.archive_files\n\n\ndef is_comment(line):\n    return line.startswith('#')\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/compat/__init__.py","size":396,"sha1":"b05db1ed917be44b1a83eddbe654a7921287152a","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\n\ndef consolidate_linker_args(args: list[str]) -> list[str] | str:\n    \"\"\"\n    Ensure the return value is a string for backward compatibility.\n\n    Retain until at least 2025-04-31. See pypa/distutils#246\n    \"\"\"\n\n    if not all(arg.startswith('-Wl,') for arg in args):\n        return args\n    return '-Wl,' + ','.join(arg.removeprefix('-Wl,') for arg in args)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/compat/py39.py","size":1964,"sha1":"a1b47772916e2c7f25f2d8e6c8c26b5c81716b67","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import functools\nimport itertools\nimport platform\nimport sys\n\n\ndef add_ext_suffix_39(vars):\n    \"\"\"\n    Ensure vars contains 'EXT_SUFFIX'. pypa/distutils#130\n    \"\"\"\n    import _imp\n\n    ext_suffix = _imp.extension_suffixes()[0]\n    vars.update(\n        EXT_SUFFIX=ext_suffix,\n        # sysconfig sets SO to match EXT_SUFFIX, so maintain\n        # that expectation.\n        # https://github.com/python/cpython/blob/785cc6770588de087d09e89a69110af2542be208/Lib/sysconfig.py#L671-L673\n        SO=ext_suffix,\n    )\n\n\nneeds_ext_suffix = sys.version_info < (3, 10) and platform.system() == 'Windows'\nadd_ext_suffix = add_ext_suffix_39 if needs_ext_suffix else lambda vars: None\n\n\n# from more_itertools\nclass UnequalIterablesError(ValueError):\n    def __init__(self, details=None):\n        msg = 'Iterables have different lengths'\n        if details is not None:\n            msg += (': index 0 has length {}; index {} has length {}').format(*details)\n\n        super().__init__(msg)\n\n\n# from more_itertools\ndef _zip_equal_generator(iterables):\n    _marker = object()\n    for combo in itertools.zip_longest(*iterables, fillvalue=_marker):\n        for val in combo:\n            if val is _marker:\n                raise UnequalIterablesError()\n        yield combo\n\n\n# from more_itertools\ndef _zip_equal(*iterables):\n    # Check whether the iterables are all the same size.\n    try:\n        first_size = len(iterables[0])\n        for i, it in enumerate(iterables[1:], 1):\n            size = len(it)\n            if size != first_size:\n                raise UnequalIterablesError(details=(first_size, i, size))\n        # All sizes are equal, we can use the built-in zip.\n        return zip(*iterables)\n    # If any one of the iterables didn't have a length, start reading\n    # them until one runs out.\n    except TypeError:\n        return _zip_equal_generator(iterables)\n\n\nzip_strict = (\n    _zip_equal if sys.version_info < (3, 10) else functools.partial(zip, strict=True)\n)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/core.py","size":9364,"sha1":"7431e240c65ce8e0e848c1211eed4ea2ef1b2d56","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.core\n\nThe only module that needs to be imported to use the Distutils; provides\nthe 'setup' function (which is to be called from the setup script).  Also\nindirectly provides the Distribution and Command classes, although they are\nreally defined in distutils.dist and distutils.cmd.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport sys\nimport tokenize\nfrom collections.abc import Iterable\n\nfrom .cmd import Command\nfrom .debug import DEBUG\n\n# Mainly import these so setup scripts can \"from distutils.core import\" them.\nfrom .dist import Distribution\nfrom .errors import (\n    CCompilerError,\n    DistutilsArgError,\n    DistutilsError,\n    DistutilsSetupError,\n)\nfrom .extension import Extension\n\n__all__ = ['Distribution', 'Command', 'Extension', 'setup']\n\n# This is a barebones help message generated displayed when the user\n# runs the setup script with no arguments at all.  More useful help\n# is generated with various --help options: global help, list commands,\n# and per-command help.\nUSAGE = \"\"\"\\\nusage: %(script)s [global_opts] cmd1 [cmd1_opts] [cmd2 [cmd2_opts] ...]\n   or: %(script)s --help [cmd1 cmd2 ...]\n   or: %(script)s --help-commands\n   or: %(script)s cmd --help\n\"\"\"\n\n\ndef gen_usage(script_name):\n    script = os.path.basename(script_name)\n    return USAGE % locals()\n\n\n# Some mild magic to control the behaviour of 'setup()' from 'run_setup()'.\n_setup_stop_after = None\n_setup_distribution = None\n\n# Legal keyword arguments for the setup() function\nsetup_keywords = (\n    'distclass',\n    'script_name',\n    'script_args',\n    'options',\n    'name',\n    'version',\n    'author',\n    'author_email',\n    'maintainer',\n    'maintainer_email',\n    'url',\n    'license',\n    'description',\n    'long_description',\n    'keywords',\n    'platforms',\n    'classifiers',\n    'download_url',\n    'requires',\n    'provides',\n    'obsoletes',\n)\n\n# Legal keyword arguments for the Extension constructor\nextension_keywords = (\n    'name',\n    'sources',\n    'include_dirs',\n    'define_macros',\n    'undef_macros',\n    'library_dirs',\n    'libraries',\n    'runtime_library_dirs',\n    'extra_objects',\n    'extra_compile_args',\n    'extra_link_args',\n    'swig_opts',\n    'export_symbols',\n    'depends',\n    'language',\n)\n\n\ndef setup(**attrs):  # noqa: C901\n    \"\"\"The gateway to the Distutils: do everything your setup script needs\n    to do, in a highly flexible and user-driven way.  Briefly: create a\n    Distribution instance; find and parse config files; parse the command\n    line; run each Distutils command found there, customized by the options\n    supplied to 'setup()' (as keyword arguments), in config files, and on\n    the command line.\n\n    The Distribution instance might be an instance of a class supplied via\n    the 'distclass' keyword argument to 'setup'; if no such class is\n    supplied, then the Distribution class (in dist.py) is instantiated.\n    All other arguments to 'setup' (except for 'cmdclass') are used to set\n    attributes of the Distribution instance.\n\n    The 'cmdclass' argument, if supplied, is a dictionary mapping command\n    names to command classes.  Each command encountered on the command line\n    will be turned into a command class, which is in turn instantiated; any\n    class found in 'cmdclass' is used in place of the default, which is\n    (for command 'foo_bar') class 'foo_bar' in module\n    'distutils.command.foo_bar'.  The command class must provide a\n    'user_options' attribute which is a list of option specifiers for\n    'distutils.fancy_getopt'.  Any command-line options between the current\n    and the next command are used to set attributes of the current command\n    object.\n\n    When the entire command-line has been successfully parsed, calls the\n    'run()' method on each command object in turn.  This method will be\n    driven entirely by the Distribution object (which each command object\n    has a reference to, thanks to its constructor), and the\n    command-specific options that became attributes of each command\n    object.\n    \"\"\"\n\n    global _setup_stop_after, _setup_distribution\n\n    # Determine the distribution class -- either caller-supplied or\n    # our Distribution (see below).\n    klass = attrs.get('distclass')\n    if klass:\n        attrs.pop('distclass')\n    else:\n        klass = Distribution\n\n    if 'script_name' not in attrs:\n        attrs['script_name'] = os.path.basename(sys.argv[0])\n    if 'script_args' not in attrs:\n        attrs['script_args'] = sys.argv[1:]\n\n    # Create the Distribution instance, using the remaining arguments\n    # (ie. everything except distclass) to initialize it\n    try:\n        _setup_distribution = dist = klass(attrs)\n    except DistutilsSetupError as msg:\n        if 'name' not in attrs:\n            raise SystemExit(f\"error in setup command: {msg}\")\n        else:\n            raise SystemExit(\"error in {} setup command: {}\".format(attrs['name'], msg))\n\n    if _setup_stop_after == \"init\":\n        return dist\n\n    # Find and parse the config file(s): they will override options from\n    # the setup script, but be overridden by the command line.\n    dist.parse_config_files()\n\n    if DEBUG:\n        print(\"options (after parsing config files):\")\n        dist.dump_option_dicts()\n\n    if _setup_stop_after == \"config\":\n        return dist\n\n    # Parse the command line and override config files; any\n    # command-line errors are the end user's fault, so turn them into\n    # SystemExit to suppress tracebacks.\n    try:\n        ok = dist.parse_command_line()\n    except DistutilsArgError as msg:\n        raise SystemExit(gen_usage(dist.script_name) + f\"\\nerror: {msg}\")\n\n    if DEBUG:\n        print(\"options (after parsing command line):\")\n        dist.dump_option_dicts()\n\n    if _setup_stop_after == \"commandline\":\n        return dist\n\n    # And finally, run all the commands found on the command line.\n    if ok:\n        return run_commands(dist)\n\n    return dist\n\n\n# setup ()\n\n\ndef run_commands(dist):\n    \"\"\"Given a Distribution object run all the commands,\n    raising ``SystemExit`` errors in the case of failure.\n\n    This function assumes that either ``sys.argv`` or ``dist.script_args``\n    is already set accordingly.\n    \"\"\"\n    try:\n        dist.run_commands()\n    except KeyboardInterrupt:\n        raise SystemExit(\"interrupted\")\n    except OSError as exc:\n        if DEBUG:\n            sys.stderr.write(f\"error: {exc}\\n\")\n            raise\n        else:\n            raise SystemExit(f\"error: {exc}\")\n\n    except (DistutilsError, CCompilerError) as msg:\n        if DEBUG:\n            raise\n        else:\n            raise SystemExit(\"error: \" + str(msg))\n\n    return dist\n\n\ndef run_setup(script_name, script_args: Iterable[str] | None = None, stop_after=\"run\"):\n    \"\"\"Run a setup script in a somewhat controlled environment, and\n    return the Distribution instance that drives things.  This is useful\n    if you need to find out the distribution meta-data (passed as\n    keyword args from 'script' to 'setup()', or the contents of the\n    config files or command-line.\n\n    'script_name' is a file that will be read and run with 'exec()';\n    'sys.argv[0]' will be replaced with 'script' for the duration of the\n    call.  'script_args' is a list of strings; if supplied,\n    'sys.argv[1:]' will be replaced by 'script_args' for the duration of\n    the call.\n\n    'stop_after' tells 'setup()' when to stop processing; possible\n    values:\n      init\n        stop after the Distribution instance has been created and\n        populated with the keyword arguments to 'setup()'\n      config\n        stop after config files have been parsed (and their data\n        stored in the Distribution instance)\n      commandline\n        stop after the command-line ('sys.argv[1:]' or 'script_args')\n        have been parsed (and the data stored in the Distribution)\n      run [default]\n        stop after all commands have been run (the same as if 'setup()'\n        had been called in the usual way\n\n    Returns the Distribution instance, which provides all information\n    used to drive the Distutils.\n    \"\"\"\n    if stop_after not in ('init', 'config', 'commandline', 'run'):\n        raise ValueError(f\"invalid value for 'stop_after': {stop_after!r}\")\n\n    global _setup_stop_after, _setup_distribution\n    _setup_stop_after = stop_after\n\n    save_argv = sys.argv.copy()\n    g = {'__file__': script_name, '__name__': '__main__'}\n    try:\n        try:\n            sys.argv[0] = script_name\n            if script_args is not None:\n                sys.argv[1:] = script_args\n            # tokenize.open supports automatic encoding detection\n            with tokenize.open(script_name) as f:\n                code = f.read().replace(r'\\r\\n', r'\\n')\n                exec(code, g)\n        finally:\n            sys.argv = save_argv\n            _setup_stop_after = None\n    except SystemExit:\n        # Hmm, should we do something if exiting with a non-zero code\n        # (ie. error)?\n        pass\n\n    if _setup_distribution is None:\n        raise RuntimeError(\n            \"'distutils.core.setup()' was never called -- \"\n            f\"perhaps '{script_name}' is not a Distutils setup script?\"\n        )\n\n    # I wonder if the setup script's namespace -- g and l -- would be of\n    # any interest to callers?\n    # print \"_setup_distribution:\", _setup_distribution\n    return _setup_distribution\n\n\n# run_setup ()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/cygwinccompiler.py","size":11891,"sha1":"c8b58572b8e90a98eb2e2806d43c85f5b731384e","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.cygwinccompiler\n\nProvides the CygwinCCompiler class, a subclass of UnixCCompiler that\nhandles the Cygwin port of the GNU C compiler to Windows.  It also contains\nthe Mingw32CCompiler class which handles the mingw32 port of GCC (same as\ncygwin in no-cygwin mode).\n\"\"\"\n\nimport copy\nimport os\nimport pathlib\nimport shlex\nimport sys\nimport warnings\nfrom subprocess import check_output\n\nfrom .errors import (\n    CCompilerError,\n    CompileError,\n    DistutilsExecError,\n    DistutilsPlatformError,\n)\nfrom .file_util import write_file\nfrom .sysconfig import get_config_vars\nfrom .unixccompiler import UnixCCompiler\nfrom .version import LooseVersion, suppress_known_deprecation\n\n\ndef get_msvcr():\n    \"\"\"No longer needed, but kept for backward compatibility.\"\"\"\n    return []\n\n\n_runtime_library_dirs_msg = (\n    \"Unable to set runtime library search path on Windows, \"\n    \"usually indicated by `runtime_library_dirs` parameter to Extension\"\n)\n\n\nclass CygwinCCompiler(UnixCCompiler):\n    \"\"\"Handles the Cygwin port of the GNU C compiler to Windows.\"\"\"\n\n    compiler_type = 'cygwin'\n    obj_extension = \".o\"\n    static_lib_extension = \".a\"\n    shared_lib_extension = \".dll.a\"\n    dylib_lib_extension = \".dll\"\n    static_lib_format = \"lib%s%s\"\n    shared_lib_format = \"lib%s%s\"\n    dylib_lib_format = \"cyg%s%s\"\n    exe_extension = \".exe\"\n\n    def __init__(self, verbose=False, dry_run=False, force=False):\n        super().__init__(verbose, dry_run, force)\n\n        status, details = check_config_h()\n        self.debug_print(f\"Python's GCC status: {status} (details: {details})\")\n        if status is not CONFIG_H_OK:\n            self.warn(\n                \"Python's pyconfig.h doesn't seem to support your compiler. \"\n                f\"Reason: {details}. \"\n                \"Compiling may fail because of undefined preprocessor macros.\"\n            )\n\n        self.cc, self.cxx = get_config_vars('CC', 'CXX')\n\n        # Override 'CC' and 'CXX' environment variables for\n        # building using MINGW compiler for MSVC python.\n        self.cc = os.environ.get('CC', self.cc or 'gcc')\n        self.cxx = os.environ.get('CXX', self.cxx or 'g++')\n\n        self.linker_dll = self.cc\n        self.linker_dll_cxx = self.cxx\n        shared_option = \"-shared\"\n\n        self.set_executables(\n            compiler=f'{self.cc} -mcygwin -O -Wall',\n            compiler_so=f'{self.cc} -mcygwin -mdll -O -Wall',\n            compiler_cxx=f'{self.cxx} -mcygwin -O -Wall',\n            compiler_so_cxx=f'{self.cxx} -mcygwin -mdll -O -Wall',\n            linker_exe=f'{self.cc} -mcygwin',\n            linker_so=f'{self.linker_dll} -mcygwin {shared_option}',\n            linker_exe_cxx=f'{self.cxx} -mcygwin',\n            linker_so_cxx=f'{self.linker_dll_cxx} -mcygwin {shared_option}',\n        )\n\n        self.dll_libraries = get_msvcr()\n\n    @property\n    def gcc_version(self):\n        # Older numpy depended on this existing to check for ancient\n        # gcc versions. This doesn't make much sense with clang etc so\n        # just hardcode to something recent.\n        # https://github.com/numpy/numpy/pull/20333\n        warnings.warn(\n            \"gcc_version attribute of CygwinCCompiler is deprecated. \"\n            \"Instead of returning actual gcc version a fixed value 11.2.0 is returned.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        with suppress_known_deprecation():\n            return LooseVersion(\"11.2.0\")\n\n    def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):\n        \"\"\"Compiles the source by spawning GCC and windres if needed.\"\"\"\n        if ext in ('.rc', '.res'):\n            # gcc needs '.res' and '.rc' compiled to object files !!!\n            try:\n                self.spawn([\"windres\", \"-i\", src, \"-o\", obj])\n            except DistutilsExecError as msg:\n                raise CompileError(msg)\n        else:  # for other files use the C-compiler\n            try:\n                if self.detect_language(src) == 'c++':\n                    self.spawn(\n                        self.compiler_so_cxx\n                        + cc_args\n                        + [src, '-o', obj]\n                        + extra_postargs\n                    )\n                else:\n                    self.spawn(\n                        self.compiler_so + cc_args + [src, '-o', obj] + extra_postargs\n                    )\n            except DistutilsExecError as msg:\n                raise CompileError(msg)\n\n    def link(\n        self,\n        target_desc,\n        objects,\n        output_filename,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        export_symbols=None,\n        debug=False,\n        extra_preargs=None,\n        extra_postargs=None,\n        build_temp=None,\n        target_lang=None,\n    ):\n        \"\"\"Link the objects.\"\"\"\n        # use separate copies, so we can modify the lists\n        extra_preargs = copy.copy(extra_preargs or [])\n        libraries = copy.copy(libraries or [])\n        objects = copy.copy(objects or [])\n\n        if runtime_library_dirs:\n            self.warn(_runtime_library_dirs_msg)\n\n        # Additional libraries\n        libraries.extend(self.dll_libraries)\n\n        # handle export symbols by creating a def-file\n        # with executables this only works with gcc/ld as linker\n        if (export_symbols is not None) and (\n            target_desc != self.EXECUTABLE or self.linker_dll == \"gcc\"\n        ):\n            # (The linker doesn't do anything if output is up-to-date.\n            # So it would probably better to check if we really need this,\n            # but for this we had to insert some unchanged parts of\n            # UnixCCompiler, and this is not what we want.)\n\n            # we want to put some files in the same directory as the\n            # object files are, build_temp doesn't help much\n            # where are the object files\n            temp_dir = os.path.dirname(objects[0])\n            # name of dll to give the helper files the same base name\n            (dll_name, dll_extension) = os.path.splitext(\n                os.path.basename(output_filename)\n            )\n\n            # generate the filenames for these files\n            def_file = os.path.join(temp_dir, dll_name + \".def\")\n\n            # Generate .def file\n            contents = [f\"LIBRARY {os.path.basename(output_filename)}\", \"EXPORTS\"]\n            contents.extend(export_symbols)\n            self.execute(write_file, (def_file, contents), f\"writing {def_file}\")\n\n            # next add options for def-file\n\n            # for gcc/ld the def-file is specified as any object files\n            objects.append(def_file)\n\n        # end: if ((export_symbols is not None) and\n        #        (target_desc != self.EXECUTABLE or self.linker_dll == \"gcc\")):\n\n        # who wants symbols and a many times larger output file\n        # should explicitly switch the debug mode on\n        # otherwise we let ld strip the output file\n        # (On my machine: 10KiB < stripped_file < ??100KiB\n        #   unstripped_file = stripped_file + XXX KiB\n        #  ( XXX=254 for a typical python extension))\n        if not debug:\n            extra_preargs.append(\"-s\")\n\n        UnixCCompiler.link(\n            self,\n            target_desc,\n            objects,\n            output_filename,\n            output_dir,\n            libraries,\n            library_dirs,\n            runtime_library_dirs,\n            None,  # export_symbols, we do this in our def-file\n            debug,\n            extra_preargs,\n            extra_postargs,\n            build_temp,\n            target_lang,\n        )\n\n    def runtime_library_dir_option(self, dir):\n        # cygwin doesn't support rpath. While in theory we could error\n        # out like MSVC does, code might expect it to work like on Unix, so\n        # just warn and hope for the best.\n        self.warn(_runtime_library_dirs_msg)\n        return []\n\n    # -- Miscellaneous methods -----------------------------------------\n\n    def _make_out_path(self, output_dir, strip_dir, src_name):\n        # use normcase to make sure '.rc' is really '.rc' and not '.RC'\n        norm_src_name = os.path.normcase(src_name)\n        return super()._make_out_path(output_dir, strip_dir, norm_src_name)\n\n    @property\n    def out_extensions(self):\n        \"\"\"\n        Add support for rc and res files.\n        \"\"\"\n        return {\n            **super().out_extensions,\n            **{ext: ext + self.obj_extension for ext in ('.res', '.rc')},\n        }\n\n\n# the same as cygwin plus some additional parameters\nclass Mingw32CCompiler(CygwinCCompiler):\n    \"\"\"Handles the Mingw32 port of the GNU C compiler to Windows.\"\"\"\n\n    compiler_type = 'mingw32'\n\n    def __init__(self, verbose=False, dry_run=False, force=False):\n        super().__init__(verbose, dry_run, force)\n\n        shared_option = \"-shared\"\n\n        if is_cygwincc(self.cc):\n            raise CCompilerError('Cygwin gcc cannot be used with --compiler=mingw32')\n\n        self.set_executables(\n            compiler=f'{self.cc} -O -Wall',\n            compiler_so=f'{self.cc} -shared -O -Wall',\n            compiler_so_cxx=f'{self.cxx} -shared -O -Wall',\n            compiler_cxx=f'{self.cxx} -O -Wall',\n            linker_exe=f'{self.cc}',\n            linker_so=f'{self.linker_dll} {shared_option}',\n            linker_exe_cxx=f'{self.cxx}',\n            linker_so_cxx=f'{self.linker_dll_cxx} {shared_option}',\n        )\n\n    def runtime_library_dir_option(self, dir):\n        raise DistutilsPlatformError(_runtime_library_dirs_msg)\n\n\n# Because these compilers aren't configured in Python's pyconfig.h file by\n# default, we should at least warn the user if he is using an unmodified\n# version.\n\nCONFIG_H_OK = \"ok\"\nCONFIG_H_NOTOK = \"not ok\"\nCONFIG_H_UNCERTAIN = \"uncertain\"\n\n\ndef check_config_h():\n    \"\"\"Check if the current Python installation appears amenable to building\n    extensions with GCC.\n\n    Returns a tuple (status, details), where 'status' is one of the following\n    constants:\n\n    - CONFIG_H_OK: all is well, go ahead and compile\n    - CONFIG_H_NOTOK: doesn't look good\n    - CONFIG_H_UNCERTAIN: not sure -- unable to read pyconfig.h\n\n    'details' is a human-readable string explaining the situation.\n\n    Note there are two ways to conclude \"OK\": either 'sys.version' contains\n    the string \"GCC\" (implying that this Python was built with GCC), or the\n    installed \"pyconfig.h\" contains the string \"__GNUC__\".\n    \"\"\"\n\n    # XXX since this function also checks sys.version, it's not strictly a\n    # \"pyconfig.h\" check -- should probably be renamed...\n\n    from distutils import sysconfig\n\n    # if sys.version contains GCC then python was compiled with GCC, and the\n    # pyconfig.h file should be OK\n    if \"GCC\" in sys.version:\n        return CONFIG_H_OK, \"sys.version mentions 'GCC'\"\n\n    # Clang would also work\n    if \"Clang\" in sys.version:\n        return CONFIG_H_OK, \"sys.version mentions 'Clang'\"\n\n    # let's see if __GNUC__ is mentioned in python.h\n    fn = sysconfig.get_config_h_filename()\n    try:\n        config_h = pathlib.Path(fn).read_text(encoding='utf-8')\n    except OSError as exc:\n        return (CONFIG_H_UNCERTAIN, f\"couldn't read '{fn}': {exc.strerror}\")\n    else:\n        substring = '__GNUC__'\n        if substring in config_h:\n            code = CONFIG_H_OK\n            mention_inflected = 'mentions'\n        else:\n            code = CONFIG_H_NOTOK\n            mention_inflected = 'does not mention'\n        return code, f\"{fn!r} {mention_inflected} {substring!r}\"\n\n\ndef is_cygwincc(cc):\n    \"\"\"Try to determine if the compiler that would be used is from cygwin.\"\"\"\n    out_string = check_output(shlex.split(cc) + ['-dumpmachine'])\n    return out_string.strip().endswith(b'cygwin')\n\n\nget_versions = None\n\"\"\"\nA stand-in for the previous get_versions() function to prevent failures\nwhen monkeypatched. See pypa/setuptools#2969.\n\"\"\"\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/debug.py","size":139,"sha1":"366246d9ab8f12833b1b2765fade51bb635d49ca","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import os\n\n# If DISTUTILS_DEBUG is anything other than the empty string, we run in\n# debug mode.\nDEBUG = os.environ.get('DISTUTILS_DEBUG')\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/dep_util.py","size":349,"sha1":"43b455f34c55d6f18a4b066733e2aeffb0db045c","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import warnings\n\nfrom . import _modified\n\n\ndef __getattr__(name):\n    if name not in ['newer', 'newer_group', 'newer_pairwise']:\n        raise AttributeError(name)\n    warnings.warn(\n        \"dep_util is Deprecated. Use functions from setuptools instead.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return getattr(_modified, name)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/dir_util.py","size":7236,"sha1":"298ba04fe389e875f01670f336102da865c2267d","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.dir_util\n\nUtility functions for manipulating directories and directory trees.\"\"\"\n\nimport functools\nimport itertools\nimport os\nimport pathlib\n\nfrom . import file_util\nfrom ._log import log\nfrom .errors import DistutilsFileError, DistutilsInternalError\n\n\nclass SkipRepeatAbsolutePaths(set):\n    \"\"\"\n    Cache for mkpath.\n\n    In addition to cheapening redundant calls, eliminates redundant\n    \"creating /foo/bar/baz\" messages in dry-run mode.\n    \"\"\"\n\n    def __init__(self):\n        SkipRepeatAbsolutePaths.instance = self\n\n    @classmethod\n    def clear(cls):\n        super(cls, cls.instance).clear()\n\n    def wrap(self, func):\n        @functools.wraps(func)\n        def wrapper(path, *args, **kwargs):\n            if path.absolute() in self:\n                return\n            result = func(path, *args, **kwargs)\n            self.add(path.absolute())\n            return result\n\n        return wrapper\n\n\n# Python 3.8 compatibility\nwrapper = SkipRepeatAbsolutePaths().wrap\n\n\n@functools.singledispatch\n@wrapper\ndef mkpath(name: pathlib.Path, mode=0o777, verbose=True, dry_run=False) -> None:\n    \"\"\"Create a directory and any missing ancestor directories.\n\n    If the directory already exists (or if 'name' is the empty string, which\n    means the current directory, which of course exists), then do nothing.\n    Raise DistutilsFileError if unable to create some directory along the way\n    (eg. some sub-path exists, but is a file rather than a directory).\n    If 'verbose' is true, log the directory created.\n    \"\"\"\n    if verbose and not name.is_dir():\n        log.info(\"creating %s\", name)\n\n    try:\n        dry_run or name.mkdir(mode=mode, parents=True, exist_ok=True)\n    except OSError as exc:\n        raise DistutilsFileError(f\"could not create '{name}': {exc.args[-1]}\")\n\n\n@mkpath.register\ndef _(name: str, *args, **kwargs):\n    return mkpath(pathlib.Path(name), *args, **kwargs)\n\n\n@mkpath.register\ndef _(name: None, *args, **kwargs):\n    \"\"\"\n    Detect a common bug -- name is None.\n    \"\"\"\n    raise DistutilsInternalError(f\"mkpath: 'name' must be a string (got {name!r})\")\n\n\ndef create_tree(base_dir, files, mode=0o777, verbose=True, dry_run=False):\n    \"\"\"Create all the empty directories under 'base_dir' needed to put 'files'\n    there.\n\n    'base_dir' is just the name of a directory which doesn't necessarily\n    exist yet; 'files' is a list of filenames to be interpreted relative to\n    'base_dir'.  'base_dir' + the directory portion of every file in 'files'\n    will be created if it doesn't already exist.  'mode', 'verbose' and\n    'dry_run' flags are as for 'mkpath()'.\n    \"\"\"\n    # First get the list of directories to create\n    need_dir = set(os.path.join(base_dir, os.path.dirname(file)) for file in files)\n\n    # Now create them\n    for dir in sorted(need_dir):\n        mkpath(dir, mode, verbose=verbose, dry_run=dry_run)\n\n\ndef copy_tree(\n    src,\n    dst,\n    preserve_mode=True,\n    preserve_times=True,\n    preserve_symlinks=False,\n    update=False,\n    verbose=True,\n    dry_run=False,\n):\n    \"\"\"Copy an entire directory tree 'src' to a new location 'dst'.\n\n    Both 'src' and 'dst' must be directory names.  If 'src' is not a\n    directory, raise DistutilsFileError.  If 'dst' does not exist, it is\n    created with 'mkpath()'.  The end result of the copy is that every\n    file in 'src' is copied to 'dst', and directories under 'src' are\n    recursively copied to 'dst'.  Return the list of files that were\n    copied or might have been copied, using their output name.  The\n    return value is unaffected by 'update' or 'dry_run': it is simply\n    the list of all files under 'src', with the names changed to be\n    under 'dst'.\n\n    'preserve_mode' and 'preserve_times' are the same as for\n    'copy_file'; note that they only apply to regular files, not to\n    directories.  If 'preserve_symlinks' is true, symlinks will be\n    copied as symlinks (on platforms that support them!); otherwise\n    (the default), the destination of the symlink will be copied.\n    'update' and 'verbose' are the same as for 'copy_file'.\n    \"\"\"\n    if not dry_run and not os.path.isdir(src):\n        raise DistutilsFileError(f\"cannot copy tree '{src}': not a directory\")\n    try:\n        names = os.listdir(src)\n    except OSError as e:\n        if dry_run:\n            names = []\n        else:\n            raise DistutilsFileError(f\"error listing files in '{src}': {e.strerror}\")\n\n    if not dry_run:\n        mkpath(dst, verbose=verbose)\n\n    copy_one = functools.partial(\n        _copy_one,\n        src=src,\n        dst=dst,\n        preserve_symlinks=preserve_symlinks,\n        verbose=verbose,\n        dry_run=dry_run,\n        preserve_mode=preserve_mode,\n        preserve_times=preserve_times,\n        update=update,\n    )\n    return list(itertools.chain.from_iterable(map(copy_one, names)))\n\n\ndef _copy_one(\n    name,\n    *,\n    src,\n    dst,\n    preserve_symlinks,\n    verbose,\n    dry_run,\n    preserve_mode,\n    preserve_times,\n    update,\n):\n    src_name = os.path.join(src, name)\n    dst_name = os.path.join(dst, name)\n\n    if name.startswith('.nfs'):\n        # skip NFS rename files\n        return\n\n    if preserve_symlinks and os.path.islink(src_name):\n        link_dest = os.readlink(src_name)\n        if verbose >= 1:\n            log.info(\"linking %s -> %s\", dst_name, link_dest)\n        if not dry_run:\n            os.symlink(link_dest, dst_name)\n        yield dst_name\n\n    elif os.path.isdir(src_name):\n        yield from copy_tree(\n            src_name,\n            dst_name,\n            preserve_mode,\n            preserve_times,\n            preserve_symlinks,\n            update,\n            verbose=verbose,\n            dry_run=dry_run,\n        )\n    else:\n        file_util.copy_file(\n            src_name,\n            dst_name,\n            preserve_mode,\n            preserve_times,\n            update,\n            verbose=verbose,\n            dry_run=dry_run,\n        )\n        yield dst_name\n\n\ndef _build_cmdtuple(path, cmdtuples):\n    \"\"\"Helper for remove_tree().\"\"\"\n    for f in os.listdir(path):\n        real_f = os.path.join(path, f)\n        if os.path.isdir(real_f) and not os.path.islink(real_f):\n            _build_cmdtuple(real_f, cmdtuples)\n        else:\n            cmdtuples.append((os.remove, real_f))\n    cmdtuples.append((os.rmdir, path))\n\n\ndef remove_tree(directory, verbose=True, dry_run=False):\n    \"\"\"Recursively remove an entire directory tree.\n\n    Any errors are ignored (apart from being reported to stdout if 'verbose'\n    is true).\n    \"\"\"\n    if verbose >= 1:\n        log.info(\"removing '%s' (and everything under it)\", directory)\n    if dry_run:\n        return\n    cmdtuples = []\n    _build_cmdtuple(directory, cmdtuples)\n    for cmd in cmdtuples:\n        try:\n            cmd[0](cmd[1])\n            # Clear the cache\n            SkipRepeatAbsolutePaths.clear()\n        except OSError as exc:\n            log.warning(\"error removing %s: %s\", directory, exc)\n\n\ndef ensure_relative(path):\n    \"\"\"Take the full path 'path', and make it a relative path.\n\n    This is useful to make 'path' the second argument to os.path.join().\n    \"\"\"\n    drive, path = os.path.splitdrive(path)\n    if path[0:1] == os.sep:\n        path = drive + path[1:]\n    return path\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/dist.py","size":51529,"sha1":"bb7cb3a5d4a0a8c667280baa0e4a3ce14736ed6d","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.dist\n\nProvides the Distribution class, which represents the module distribution\nbeing built/installed/distributed.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport contextlib\nimport logging\nimport os\nimport pathlib\nimport re\nimport sys\nimport warnings\nfrom collections.abc import Iterable\nfrom email import message_from_file\nfrom typing import TYPE_CHECKING, Literal, TypeVar, overload\n\nfrom packaging.utils import canonicalize_name, canonicalize_version\n\nfrom ._log import log\nfrom .debug import DEBUG\nfrom .errors import (\n    DistutilsArgError,\n    DistutilsClassError,\n    DistutilsModuleError,\n    DistutilsOptionError,\n)\nfrom .fancy_getopt import FancyGetopt, translate_longopt\nfrom .util import check_environ, rfc822_escape, strtobool\n\nif TYPE_CHECKING:\n    # type-only import because of mutual dependence between these modules\n    from .cmd import Command\n\n_CommandT = TypeVar(\"_CommandT\", bound=\"Command\")\n\n# Regex to define acceptable Distutils command names.  This is not *quite*\n# the same as a Python NAME -- I don't allow leading underscores.  The fact\n# that they're very similar is no coincidence; the default naming scheme is\n# to look for a Python module named after the command.\ncommand_re = re.compile(r'^[a-zA-Z]([a-zA-Z0-9_]*)$')\n\n\ndef _ensure_list(value, fieldname):\n    if isinstance(value, str):\n        # a string containing comma separated values is okay.  It will\n        # be converted to a list by Distribution.finalize_options().\n        pass\n    elif not isinstance(value, list):\n        # passing a tuple or an iterator perhaps, warn and convert\n        typename = type(value).__name__\n        msg = \"Warning: '{fieldname}' should be a list, got type '{typename}'\"\n        msg = msg.format(**locals())\n        log.warning(msg)\n        value = list(value)\n    return value\n\n\nclass Distribution:\n    \"\"\"The core of the Distutils.  Most of the work hiding behind 'setup'\n    is really done within a Distribution instance, which farms the work out\n    to the Distutils commands specified on the command line.\n\n    Setup scripts will almost never instantiate Distribution directly,\n    unless the 'setup()' function is totally inadequate to their needs.\n    However, it is conceivable that a setup script might wish to subclass\n    Distribution for some specialized purpose, and then pass the subclass\n    to 'setup()' as the 'distclass' keyword argument.  If so, it is\n    necessary to respect the expectations that 'setup' has of Distribution.\n    See the code for 'setup()', in core.py, for details.\n    \"\"\"\n\n    # 'global_options' describes the command-line options that may be\n    # supplied to the setup script prior to any actual commands.\n    # Eg. \"./setup.py -n\" or \"./setup.py --quiet\" both take advantage of\n    # these global options.  This list should be kept to a bare minimum,\n    # since every global option is also valid as a command option -- and we\n    # don't want to pollute the commands with too many options that they\n    # have minimal control over.\n    # The fourth entry for verbose means that it can be repeated.\n    global_options = [\n        ('verbose', 'v', \"run verbosely (default)\", 1),\n        ('quiet', 'q', \"run quietly (turns verbosity off)\"),\n        ('dry-run', 'n', \"don't actually do anything\"),\n        ('help', 'h', \"show detailed help message\"),\n        ('no-user-cfg', None, 'ignore pydistutils.cfg in your home directory'),\n    ]\n\n    # 'common_usage' is a short (2-3 line) string describing the common\n    # usage of the setup script.\n    common_usage = \"\"\"\\\nCommon commands: (see '--help-commands' for more)\n\n  setup.py build      will build the package underneath 'build/'\n  setup.py install    will install the package\n\"\"\"\n\n    # options that are not propagated to the commands\n    display_options = [\n        ('help-commands', None, \"list all available commands\"),\n        ('name', None, \"print package name\"),\n        ('version', 'V', \"print package version\"),\n        ('fullname', None, \"print <package name>-<version>\"),\n        ('author', None, \"print the author's name\"),\n        ('author-email', None, \"print the author's email address\"),\n        ('maintainer', None, \"print the maintainer's name\"),\n        ('maintainer-email', None, \"print the maintainer's email address\"),\n        ('contact', None, \"print the maintainer's name if known, else the author's\"),\n        (\n            'contact-email',\n            None,\n            \"print the maintainer's email address if known, else the author's\",\n        ),\n        ('url', None, \"print the URL for this package\"),\n        ('license', None, \"print the license of the package\"),\n        ('licence', None, \"alias for --license\"),\n        ('description', None, \"print the package description\"),\n        ('long-description', None, \"print the long package description\"),\n        ('platforms', None, \"print the list of platforms\"),\n        ('classifiers', None, \"print the list of classifiers\"),\n        ('keywords', None, \"print the list of keywords\"),\n        ('provides', None, \"print the list of packages/modules provided\"),\n        ('requires', None, \"print the list of packages/modules required\"),\n        ('obsoletes', None, \"print the list of packages/modules made obsolete\"),\n    ]\n    display_option_names = [translate_longopt(x[0]) for x in display_options]\n\n    # negative options are options that exclude other options\n    negative_opt = {'quiet': 'verbose'}\n\n    # -- Creation/initialization methods -------------------------------\n\n    def __init__(self, attrs=None):  # noqa: C901\n        \"\"\"Construct a new Distribution instance: initialize all the\n        attributes of a Distribution, and then use 'attrs' (a dictionary\n        mapping attribute names to values) to assign some of those\n        attributes their \"real\" values.  (Any attributes not mentioned in\n        'attrs' will be assigned to some null value: 0, None, an empty list\n        or dictionary, etc.)  Most importantly, initialize the\n        'command_obj' attribute to the empty dictionary; this will be\n        filled in with real command objects by 'parse_command_line()'.\n        \"\"\"\n\n        # Default values for our command-line options\n        self.verbose = True\n        self.dry_run = False\n        self.help = False\n        for attr in self.display_option_names:\n            setattr(self, attr, False)\n\n        # Store the distribution meta-data (name, version, author, and so\n        # forth) in a separate object -- we're getting to have enough\n        # information here (and enough command-line options) that it's\n        # worth it.  Also delegate 'get_XXX()' methods to the 'metadata'\n        # object in a sneaky and underhanded (but efficient!) way.\n        self.metadata = DistributionMetadata()\n        for basename in self.metadata._METHOD_BASENAMES:\n            method_name = \"get_\" + basename\n            setattr(self, method_name, getattr(self.metadata, method_name))\n\n        # 'cmdclass' maps command names to class objects, so we\n        # can 1) quickly figure out which class to instantiate when\n        # we need to create a new command object, and 2) have a way\n        # for the setup script to override command classes\n        self.cmdclass = {}\n\n        # 'command_packages' is a list of packages in which commands\n        # are searched for.  The factory for command 'foo' is expected\n        # to be named 'foo' in the module 'foo' in one of the packages\n        # named here.  This list is searched from the left; an error\n        # is raised if no named package provides the command being\n        # searched for.  (Always access using get_command_packages().)\n        self.command_packages = None\n\n        # 'script_name' and 'script_args' are usually set to sys.argv[0]\n        # and sys.argv[1:], but they can be overridden when the caller is\n        # not necessarily a setup script run from the command-line.\n        self.script_name = None\n        self.script_args: list[str] | None = None\n\n        # 'command_options' is where we store command options between\n        # parsing them (from config files, the command-line, etc.) and when\n        # they are actually needed -- ie. when the command in question is\n        # instantiated.  It is a dictionary of dictionaries of 2-tuples:\n        #   command_options = { command_name : { option : (source, value) } }\n        self.command_options = {}\n\n        # 'dist_files' is the list of (command, pyversion, file) that\n        # have been created by any dist commands run so far. This is\n        # filled regardless of whether the run is dry or not. pyversion\n        # gives sysconfig.get_python_version() if the dist file is\n        # specific to a Python version, 'any' if it is good for all\n        # Python versions on the target platform, and '' for a source\n        # file. pyversion should not be used to specify minimum or\n        # maximum required Python versions; use the metainfo for that\n        # instead.\n        self.dist_files = []\n\n        # These options are really the business of various commands, rather\n        # than of the Distribution itself.  We provide aliases for them in\n        # Distribution as a convenience to the developer.\n        self.packages = None\n        self.package_data = {}\n        self.package_dir = None\n        self.py_modules = None\n        self.libraries = None\n        self.headers = None\n        self.ext_modules = None\n        self.ext_package = None\n        self.include_dirs = None\n        self.extra_path = None\n        self.scripts = None\n        self.data_files = None\n        self.password = ''\n\n        # And now initialize bookkeeping stuff that can't be supplied by\n        # the caller at all.  'command_obj' maps command names to\n        # Command instances -- that's how we enforce that every command\n        # class is a singleton.\n        self.command_obj = {}\n\n        # 'have_run' maps command names to boolean values; it keeps track\n        # of whether we have actually run a particular command, to make it\n        # cheap to \"run\" a command whenever we think we might need to -- if\n        # it's already been done, no need for expensive filesystem\n        # operations, we just check the 'have_run' dictionary and carry on.\n        # It's only safe to query 'have_run' for a command class that has\n        # been instantiated -- a false value will be inserted when the\n        # command object is created, and replaced with a true value when\n        # the command is successfully run.  Thus it's probably best to use\n        # '.get()' rather than a straight lookup.\n        self.have_run = {}\n\n        # Now we'll use the attrs dictionary (ultimately, keyword args from\n        # the setup script) to possibly override any or all of these\n        # distribution options.\n\n        if attrs:\n            # Pull out the set of command options and work on them\n            # specifically.  Note that this order guarantees that aliased\n            # command options will override any supplied redundantly\n            # through the general options dictionary.\n            options = attrs.get('options')\n            if options is not None:\n                del attrs['options']\n                for command, cmd_options in options.items():\n                    opt_dict = self.get_option_dict(command)\n                    for opt, val in cmd_options.items():\n                        opt_dict[opt] = (\"setup script\", val)\n\n            if 'licence' in attrs:\n                attrs['license'] = attrs['licence']\n                del attrs['licence']\n                msg = \"'licence' distribution option is deprecated; use 'license'\"\n                warnings.warn(msg)\n\n            # Now work on the rest of the attributes.  Any attribute that's\n            # not already defined is invalid!\n            for key, val in attrs.items():\n                if hasattr(self.metadata, \"set_\" + key):\n                    getattr(self.metadata, \"set_\" + key)(val)\n                elif hasattr(self.metadata, key):\n                    setattr(self.metadata, key, val)\n                elif hasattr(self, key):\n                    setattr(self, key, val)\n                else:\n                    msg = f\"Unknown distribution option: {key!r}\"\n                    warnings.warn(msg)\n\n        # no-user-cfg is handled before other command line args\n        # because other args override the config files, and this\n        # one is needed before we can load the config files.\n        # If attrs['script_args'] wasn't passed, assume false.\n        #\n        # This also make sure we just look at the global options\n        self.want_user_cfg = True\n\n        if self.script_args is not None:\n            # Coerce any possible iterable from attrs into a list\n            self.script_args = list(self.script_args)\n            for arg in self.script_args:\n                if not arg.startswith('-'):\n                    break\n                if arg == '--no-user-cfg':\n                    self.want_user_cfg = False\n                    break\n\n        self.finalize_options()\n\n    def get_option_dict(self, command):\n        \"\"\"Get the option dictionary for a given command.  If that\n        command's option dictionary hasn't been created yet, then create it\n        and return the new dictionary; otherwise, return the existing\n        option dictionary.\n        \"\"\"\n        dict = self.command_options.get(command)\n        if dict is None:\n            dict = self.command_options[command] = {}\n        return dict\n\n    def dump_option_dicts(self, header=None, commands=None, indent=\"\"):\n        from pprint import pformat\n\n        if commands is None:  # dump all command option dicts\n            commands = sorted(self.command_options.keys())\n\n        if header is not None:\n            self.announce(indent + header)\n            indent = indent + \"  \"\n\n        if not commands:\n            self.announce(indent + \"no commands known yet\")\n            return\n\n        for cmd_name in commands:\n            opt_dict = self.command_options.get(cmd_name)\n            if opt_dict is None:\n                self.announce(indent + f\"no option dict for '{cmd_name}' command\")\n            else:\n                self.announce(indent + f\"option dict for '{cmd_name}' command:\")\n                out = pformat(opt_dict)\n                for line in out.split('\\n'):\n                    self.announce(indent + \"  \" + line)\n\n    # -- Config file finding/parsing methods ---------------------------\n\n    def find_config_files(self):\n        \"\"\"Find as many configuration files as should be processed for this\n        platform, and return a list of filenames in the order in which they\n        should be parsed.  The filenames returned are guaranteed to exist\n        (modulo nasty race conditions).\n\n        There are multiple possible config files:\n        - distutils.cfg in the Distutils installation directory (i.e.\n          where the top-level Distutils __inst__.py file lives)\n        - a file in the user's home directory named .pydistutils.cfg\n          on Unix and pydistutils.cfg on Windows/Mac; may be disabled\n          with the ``--no-user-cfg`` option\n        - setup.cfg in the current directory\n        - a file named by an environment variable\n        \"\"\"\n        check_environ()\n        files = [str(path) for path in self._gen_paths() if os.path.isfile(path)]\n\n        if DEBUG:\n            self.announce(\"using config files: {}\".format(', '.join(files)))\n\n        return files\n\n    def _gen_paths(self):\n        # The system-wide Distutils config file\n        sys_dir = pathlib.Path(sys.modules['distutils'].__file__).parent\n        yield sys_dir / \"distutils.cfg\"\n\n        # The per-user config file\n        prefix = '.' * (os.name == 'posix')\n        filename = prefix + 'pydistutils.cfg'\n        if self.want_user_cfg:\n            with contextlib.suppress(RuntimeError):\n                yield pathlib.Path('~').expanduser() / filename\n\n        # All platforms support local setup.cfg\n        yield pathlib.Path('setup.cfg')\n\n        # Additional config indicated in the environment\n        with contextlib.suppress(TypeError):\n            yield pathlib.Path(os.getenv(\"DIST_EXTRA_CONFIG\"))\n\n    def parse_config_files(self, filenames=None):  # noqa: C901\n        from configparser import ConfigParser\n\n        # Ignore install directory options if we have a venv\n        if sys.prefix != sys.base_prefix:\n            ignore_options = [\n                'install-base',\n                'install-platbase',\n                'install-lib',\n                'install-platlib',\n                'install-purelib',\n                'install-headers',\n                'install-scripts',\n                'install-data',\n                'prefix',\n                'exec-prefix',\n                'home',\n                'user',\n                'root',\n            ]\n        else:\n            ignore_options = []\n\n        ignore_options = frozenset(ignore_options)\n\n        if filenames is None:\n            filenames = self.find_config_files()\n\n        if DEBUG:\n            self.announce(\"Distribution.parse_config_files():\")\n\n        parser = ConfigParser()\n        for filename in filenames:\n            if DEBUG:\n                self.announce(f\"  reading {filename}\")\n            parser.read(filename, encoding='utf-8')\n            for section in parser.sections():\n                options = parser.options(section)\n                opt_dict = self.get_option_dict(section)\n\n                for opt in options:\n                    if opt != '__name__' and opt not in ignore_options:\n                        val = parser.get(section, opt)\n                        opt = opt.replace('-', '_')\n                        opt_dict[opt] = (filename, val)\n\n            # Make the ConfigParser forget everything (so we retain\n            # the original filenames that options come from)\n            parser.__init__()\n\n        # If there was a \"global\" section in the config file, use it\n        # to set Distribution options.\n\n        if 'global' in self.command_options:\n            for opt, (_src, val) in self.command_options['global'].items():\n                alias = self.negative_opt.get(opt)\n                try:\n                    if alias:\n                        setattr(self, alias, not strtobool(val))\n                    elif opt in ('verbose', 'dry_run'):  # ugh!\n                        setattr(self, opt, strtobool(val))\n                    else:\n                        setattr(self, opt, val)\n                except ValueError as msg:\n                    raise DistutilsOptionError(msg)\n\n    # -- Command-line parsing methods ----------------------------------\n\n    def parse_command_line(self):\n        \"\"\"Parse the setup script's command line, taken from the\n        'script_args' instance attribute (which defaults to 'sys.argv[1:]'\n        -- see 'setup()' in core.py).  This list is first processed for\n        \"global options\" -- options that set attributes of the Distribution\n        instance.  Then, it is alternately scanned for Distutils commands\n        and options for that command.  Each new command terminates the\n        options for the previous command.  The allowed options for a\n        command are determined by the 'user_options' attribute of the\n        command class -- thus, we have to be able to load command classes\n        in order to parse the command line.  Any error in that 'options'\n        attribute raises DistutilsGetoptError; any error on the\n        command-line raises DistutilsArgError.  If no Distutils commands\n        were found on the command line, raises DistutilsArgError.  Return\n        true if command-line was successfully parsed and we should carry\n        on with executing commands; false if no errors but we shouldn't\n        execute commands (currently, this only happens if user asks for\n        help).\n        \"\"\"\n        #\n        # We now have enough information to show the Macintosh dialog\n        # that allows the user to interactively specify the \"command line\".\n        #\n        toplevel_options = self._get_toplevel_options()\n\n        # We have to parse the command line a bit at a time -- global\n        # options, then the first command, then its options, and so on --\n        # because each command will be handled by a different class, and\n        # the options that are valid for a particular class aren't known\n        # until we have loaded the command class, which doesn't happen\n        # until we know what the command is.\n\n        self.commands = []\n        parser = FancyGetopt(toplevel_options + self.display_options)\n        parser.set_negative_aliases(self.negative_opt)\n        parser.set_aliases({'licence': 'license'})\n        args = parser.getopt(args=self.script_args, object=self)\n        option_order = parser.get_option_order()\n        logging.getLogger().setLevel(logging.WARN - 10 * self.verbose)\n\n        # for display options we return immediately\n        if self.handle_display_options(option_order):\n            return\n        while args:\n            args = self._parse_command_opts(parser, args)\n            if args is None:  # user asked for help (and got it)\n                return\n\n        # Handle the cases of --help as a \"global\" option, ie.\n        # \"setup.py --help\" and \"setup.py --help command ...\".  For the\n        # former, we show global options (--verbose, --dry-run, etc.)\n        # and display-only options (--name, --version, etc.); for the\n        # latter, we omit the display-only options and show help for\n        # each command listed on the command line.\n        if self.help:\n            self._show_help(\n                parser, display_options=len(self.commands) == 0, commands=self.commands\n            )\n            return\n\n        # Oops, no commands found -- an end-user error\n        if not self.commands:\n            raise DistutilsArgError(\"no commands supplied\")\n\n        # All is well: return true\n        return True\n\n    def _get_toplevel_options(self):\n        \"\"\"Return the non-display options recognized at the top level.\n\n        This includes options that are recognized *only* at the top\n        level as well as options recognized for commands.\n        \"\"\"\n        return self.global_options + [\n            (\n                \"command-packages=\",\n                None,\n                \"list of packages that provide distutils commands\",\n            ),\n        ]\n\n    def _parse_command_opts(self, parser, args):  # noqa: C901\n        \"\"\"Parse the command-line options for a single command.\n        'parser' must be a FancyGetopt instance; 'args' must be the list\n        of arguments, starting with the current command (whose options\n        we are about to parse).  Returns a new version of 'args' with\n        the next command at the front of the list; will be the empty\n        list if there are no more commands on the command line.  Returns\n        None if the user asked for help on this command.\n        \"\"\"\n        # late import because of mutual dependence between these modules\n        from distutils.cmd import Command\n\n        # Pull the current command from the head of the command line\n        command = args[0]\n        if not command_re.match(command):\n            raise SystemExit(f\"invalid command name '{command}'\")\n        self.commands.append(command)\n\n        # Dig up the command class that implements this command, so we\n        # 1) know that it's a valid command, and 2) know which options\n        # it takes.\n        try:\n            cmd_class = self.get_command_class(command)\n        except DistutilsModuleError as msg:\n            raise DistutilsArgError(msg)\n\n        # Require that the command class be derived from Command -- want\n        # to be sure that the basic \"command\" interface is implemented.\n        if not issubclass(cmd_class, Command):\n            raise DistutilsClassError(\n                f\"command class {cmd_class} must subclass Command\"\n            )\n\n        # Also make sure that the command object provides a list of its\n        # known options.\n        if not (\n            hasattr(cmd_class, 'user_options')\n            and isinstance(cmd_class.user_options, list)\n        ):\n            msg = (\n                \"command class %s must provide \"\n                \"'user_options' attribute (a list of tuples)\"\n            )\n            raise DistutilsClassError(msg % cmd_class)\n\n        # If the command class has a list of negative alias options,\n        # merge it in with the global negative aliases.\n        negative_opt = self.negative_opt\n        if hasattr(cmd_class, 'negative_opt'):\n            negative_opt = negative_opt.copy()\n            negative_opt.update(cmd_class.negative_opt)\n\n        # Check for help_options in command class.  They have a different\n        # format (tuple of four) so we need to preprocess them here.\n        if hasattr(cmd_class, 'help_options') and isinstance(\n            cmd_class.help_options, list\n        ):\n            help_options = fix_help_options(cmd_class.help_options)\n        else:\n            help_options = []\n\n        # All commands support the global options too, just by adding\n        # in 'global_options'.\n        parser.set_option_table(\n            self.global_options + cmd_class.user_options + help_options\n        )\n        parser.set_negative_aliases(negative_opt)\n        (args, opts) = parser.getopt(args[1:])\n        if hasattr(opts, 'help') and opts.help:\n            self._show_help(parser, display_options=False, commands=[cmd_class])\n            return\n\n        if hasattr(cmd_class, 'help_options') and isinstance(\n            cmd_class.help_options, list\n        ):\n            help_option_found = 0\n            for help_option, _short, _desc, func in cmd_class.help_options:\n                if hasattr(opts, parser.get_attr_name(help_option)):\n                    help_option_found = 1\n                    if callable(func):\n                        func()\n                    else:\n                        raise DistutilsClassError(\n                            f\"invalid help function {func!r} for help option '{help_option}': \"\n                            \"must be a callable object (function, etc.)\"\n                        )\n\n            if help_option_found:\n                return\n\n        # Put the options from the command-line into their official\n        # holding pen, the 'command_options' dictionary.\n        opt_dict = self.get_option_dict(command)\n        for name, value in vars(opts).items():\n            opt_dict[name] = (\"command line\", value)\n\n        return args\n\n    def finalize_options(self):\n        \"\"\"Set final values for all the options on the Distribution\n        instance, analogous to the .finalize_options() method of Command\n        objects.\n        \"\"\"\n        for attr in ('keywords', 'platforms'):\n            value = getattr(self.metadata, attr)\n            if value is None:\n                continue\n            if isinstance(value, str):\n                value = [elm.strip() for elm in value.split(',')]\n                setattr(self.metadata, attr, value)\n\n    def _show_help(\n        self, parser, global_options=True, display_options=True, commands: Iterable = ()\n    ):\n        \"\"\"Show help for the setup script command-line in the form of\n        several lists of command-line options.  'parser' should be a\n        FancyGetopt instance; do not expect it to be returned in the\n        same state, as its option table will be reset to make it\n        generate the correct help text.\n\n        If 'global_options' is true, lists the global options:\n        --verbose, --dry-run, etc.  If 'display_options' is true, lists\n        the \"display-only\" options: --name, --version, etc.  Finally,\n        lists per-command help for every command name or command class\n        in 'commands'.\n        \"\"\"\n        # late import because of mutual dependence between these modules\n        from distutils.cmd import Command\n        from distutils.core import gen_usage\n\n        if global_options:\n            if display_options:\n                options = self._get_toplevel_options()\n            else:\n                options = self.global_options\n            parser.set_option_table(options)\n            parser.print_help(self.common_usage + \"\\nGlobal options:\")\n            print()\n\n        if display_options:\n            parser.set_option_table(self.display_options)\n            parser.print_help(\n                \"Information display options (just display information, ignore any commands)\"\n            )\n            print()\n\n        for command in commands:\n            if isinstance(command, type) and issubclass(command, Command):\n                klass = command\n            else:\n                klass = self.get_command_class(command)\n            if hasattr(klass, 'help_options') and isinstance(klass.help_options, list):\n                parser.set_option_table(\n                    klass.user_options + fix_help_options(klass.help_options)\n                )\n            else:\n                parser.set_option_table(klass.user_options)\n            parser.print_help(f\"Options for '{klass.__name__}' command:\")\n            print()\n\n        print(gen_usage(self.script_name))\n\n    def handle_display_options(self, option_order):\n        \"\"\"If there were any non-global \"display-only\" options\n        (--help-commands or the metadata display options) on the command\n        line, display the requested info and return true; else return\n        false.\n        \"\"\"\n        from distutils.core import gen_usage\n\n        # User just wants a list of commands -- we'll print it out and stop\n        # processing now (ie. if they ran \"setup --help-commands foo bar\",\n        # we ignore \"foo bar\").\n        if self.help_commands:\n            self.print_commands()\n            print()\n            print(gen_usage(self.script_name))\n            return 1\n\n        # If user supplied any of the \"display metadata\" options, then\n        # display that metadata in the order in which the user supplied the\n        # metadata options.\n        any_display_options = 0\n        is_display_option = set()\n        for option in self.display_options:\n            is_display_option.add(option[0])\n\n        for opt, val in option_order:\n            if val and opt in is_display_option:\n                opt = translate_longopt(opt)\n                value = getattr(self.metadata, \"get_\" + opt)()\n                if opt in ('keywords', 'platforms'):\n                    print(','.join(value))\n                elif opt in ('classifiers', 'provides', 'requires', 'obsoletes'):\n                    print('\\n'.join(value))\n                else:\n                    print(value)\n                any_display_options = 1\n\n        return any_display_options\n\n    def print_command_list(self, commands, header, max_length):\n        \"\"\"Print a subset of the list of all commands -- used by\n        'print_commands()'.\n        \"\"\"\n        print(header + \":\")\n\n        for cmd in commands:\n            klass = self.cmdclass.get(cmd)\n            if not klass:\n                klass = self.get_command_class(cmd)\n            try:\n                description = klass.description\n            except AttributeError:\n                description = \"(no description available)\"\n\n            print(f\"  {cmd:<{max_length}}  {description}\")\n\n    def print_commands(self):\n        \"\"\"Print out a help message listing all available commands with a\n        description of each.  The list is divided into \"standard commands\"\n        (listed in distutils.command.__all__) and \"extra commands\"\n        (mentioned in self.cmdclass, but not a standard command).  The\n        descriptions come from the command class attribute\n        'description'.\n        \"\"\"\n        import distutils.command\n\n        std_commands = distutils.command.__all__\n        is_std = set(std_commands)\n\n        extra_commands = [cmd for cmd in self.cmdclass.keys() if cmd not in is_std]\n\n        max_length = 0\n        for cmd in std_commands + extra_commands:\n            if len(cmd) > max_length:\n                max_length = len(cmd)\n\n        self.print_command_list(std_commands, \"Standard commands\", max_length)\n        if extra_commands:\n            print()\n            self.print_command_list(extra_commands, \"Extra commands\", max_length)\n\n    def get_command_list(self):\n        \"\"\"Get a list of (command, description) tuples.\n        The list is divided into \"standard commands\" (listed in\n        distutils.command.__all__) and \"extra commands\" (mentioned in\n        self.cmdclass, but not a standard command).  The descriptions come\n        from the command class attribute 'description'.\n        \"\"\"\n        # Currently this is only used on Mac OS, for the Mac-only GUI\n        # Distutils interface (by Jack Jansen)\n        import distutils.command\n\n        std_commands = distutils.command.__all__\n        is_std = set(std_commands)\n\n        extra_commands = [cmd for cmd in self.cmdclass.keys() if cmd not in is_std]\n\n        rv = []\n        for cmd in std_commands + extra_commands:\n            klass = self.cmdclass.get(cmd)\n            if not klass:\n                klass = self.get_command_class(cmd)\n            try:\n                description = klass.description\n            except AttributeError:\n                description = \"(no description available)\"\n            rv.append((cmd, description))\n        return rv\n\n    # -- Command class/object methods ----------------------------------\n\n    def get_command_packages(self):\n        \"\"\"Return a list of packages from which commands are loaded.\"\"\"\n        pkgs = self.command_packages\n        if not isinstance(pkgs, list):\n            if pkgs is None:\n                pkgs = ''\n            pkgs = [pkg.strip() for pkg in pkgs.split(',') if pkg != '']\n            if \"distutils.command\" not in pkgs:\n                pkgs.insert(0, \"distutils.command\")\n            self.command_packages = pkgs\n        return pkgs\n\n    def get_command_class(self, command):\n        \"\"\"Return the class that implements the Distutils command named by\n        'command'.  First we check the 'cmdclass' dictionary; if the\n        command is mentioned there, we fetch the class object from the\n        dictionary and return it.  Otherwise we load the command module\n        (\"distutils.command.\" + command) and fetch the command class from\n        the module.  The loaded class is also stored in 'cmdclass'\n        to speed future calls to 'get_command_class()'.\n\n        Raises DistutilsModuleError if the expected module could not be\n        found, or if that module does not define the expected class.\n        \"\"\"\n        klass = self.cmdclass.get(command)\n        if klass:\n            return klass\n\n        for pkgname in self.get_command_packages():\n            module_name = f\"{pkgname}.{command}\"\n            klass_name = command\n\n            try:\n                __import__(module_name)\n                module = sys.modules[module_name]\n            except ImportError:\n                continue\n\n            try:\n                klass = getattr(module, klass_name)\n            except AttributeError:\n                raise DistutilsModuleError(\n                    f\"invalid command '{command}' (no class '{klass_name}' in module '{module_name}')\"\n                )\n\n            self.cmdclass[command] = klass\n            return klass\n\n        raise DistutilsModuleError(f\"invalid command '{command}'\")\n\n    @overload\n    def get_command_obj(\n        self, command: str, create: Literal[True] = True\n    ) -> Command: ...\n    @overload\n    def get_command_obj(\n        self, command: str, create: Literal[False]\n    ) -> Command | None: ...\n    def get_command_obj(self, command: str, create: bool = True) -> Command | None:\n        \"\"\"Return the command object for 'command'.  Normally this object\n        is cached on a previous call to 'get_command_obj()'; if no command\n        object for 'command' is in the cache, then we either create and\n        return it (if 'create' is true) or return None.\n        \"\"\"\n        cmd_obj = self.command_obj.get(command)\n        if not cmd_obj and create:\n            if DEBUG:\n                self.announce(\n                    \"Distribution.get_command_obj(): \"\n                    f\"creating '{command}' command object\"\n                )\n\n            klass = self.get_command_class(command)\n            cmd_obj = self.command_obj[command] = klass(self)\n            self.have_run[command] = False\n\n            # Set any options that were supplied in config files\n            # or on the command line.  (NB. support for error\n            # reporting is lame here: any errors aren't reported\n            # until 'finalize_options()' is called, which means\n            # we won't report the source of the error.)\n            options = self.command_options.get(command)\n            if options:\n                self._set_command_options(cmd_obj, options)\n\n        return cmd_obj\n\n    def _set_command_options(self, command_obj, option_dict=None):  # noqa: C901\n        \"\"\"Set the options for 'command_obj' from 'option_dict'.  Basically\n        this means copying elements of a dictionary ('option_dict') to\n        attributes of an instance ('command').\n\n        'command_obj' must be a Command instance.  If 'option_dict' is not\n        supplied, uses the standard option dictionary for this command\n        (from 'self.command_options').\n        \"\"\"\n        command_name = command_obj.get_command_name()\n        if option_dict is None:\n            option_dict = self.get_option_dict(command_name)\n\n        if DEBUG:\n            self.announce(f\"  setting options for '{command_name}' command:\")\n        for option, (source, value) in option_dict.items():\n            if DEBUG:\n                self.announce(f\"    {option} = {value} (from {source})\")\n            try:\n                bool_opts = [translate_longopt(o) for o in command_obj.boolean_options]\n            except AttributeError:\n                bool_opts = []\n            try:\n                neg_opt = command_obj.negative_opt\n            except AttributeError:\n                neg_opt = {}\n\n            try:\n                is_string = isinstance(value, str)\n                if option in neg_opt and is_string:\n                    setattr(command_obj, neg_opt[option], not strtobool(value))\n                elif option in bool_opts and is_string:\n                    setattr(command_obj, option, strtobool(value))\n                elif hasattr(command_obj, option):\n                    setattr(command_obj, option, value)\n                else:\n                    raise DistutilsOptionError(\n                        f\"error in {source}: command '{command_name}' has no such option '{option}'\"\n                    )\n            except ValueError as msg:\n                raise DistutilsOptionError(msg)\n\n    @overload\n    def reinitialize_command(\n        self, command: str, reinit_subcommands: bool = False\n    ) -> Command: ...\n    @overload\n    def reinitialize_command(\n        self, command: _CommandT, reinit_subcommands: bool = False\n    ) -> _CommandT: ...\n    def reinitialize_command(\n        self, command: str | Command, reinit_subcommands=False\n    ) -> Command:\n        \"\"\"Reinitializes a command to the state it was in when first\n        returned by 'get_command_obj()': ie., initialized but not yet\n        finalized.  This provides the opportunity to sneak option\n        values in programmatically, overriding or supplementing\n        user-supplied values from the config files and command line.\n        You'll have to re-finalize the command object (by calling\n        'finalize_options()' or 'ensure_finalized()') before using it for\n        real.\n\n        'command' should be a command name (string) or command object.  If\n        'reinit_subcommands' is true, also reinitializes the command's\n        sub-commands, as declared by the 'sub_commands' class attribute (if\n        it has one).  See the \"install\" command for an example.  Only\n        reinitializes the sub-commands that actually matter, ie. those\n        whose test predicates return true.\n\n        Returns the reinitialized command object.\n        \"\"\"\n        from distutils.cmd import Command\n\n        if not isinstance(command, Command):\n            command_name = command\n            command = self.get_command_obj(command_name)\n        else:\n            command_name = command.get_command_name()\n\n        if not command.finalized:\n            return command\n        command.initialize_options()\n        command.finalized = False\n        self.have_run[command_name] = False\n        self._set_command_options(command)\n\n        if reinit_subcommands:\n            for sub in command.get_sub_commands():\n                self.reinitialize_command(sub, reinit_subcommands)\n\n        return command\n\n    # -- Methods that operate on the Distribution ----------------------\n\n    def announce(self, msg, level=logging.INFO):\n        log.log(level, msg)\n\n    def run_commands(self):\n        \"\"\"Run each command that was seen on the setup script command line.\n        Uses the list of commands found and cache of command objects\n        created by 'get_command_obj()'.\n        \"\"\"\n        for cmd in self.commands:\n            self.run_command(cmd)\n\n    # -- Methods that operate on its Commands --------------------------\n\n    def run_command(self, command):\n        \"\"\"Do whatever it takes to run a command (including nothing at all,\n        if the command has already been run).  Specifically: if we have\n        already created and run the command named by 'command', return\n        silently without doing anything.  If the command named by 'command'\n        doesn't even have a command object yet, create one.  Then invoke\n        'run()' on that command object (or an existing one).\n        \"\"\"\n        # Already been here, done that? then return silently.\n        if self.have_run.get(command):\n            return\n\n        log.info(\"running %s\", command)\n        cmd_obj = self.get_command_obj(command)\n        cmd_obj.ensure_finalized()\n        cmd_obj.run()\n        self.have_run[command] = True\n\n    # -- Distribution query methods ------------------------------------\n\n    def has_pure_modules(self):\n        return len(self.packages or self.py_modules or []) > 0\n\n    def has_ext_modules(self):\n        return self.ext_modules and len(self.ext_modules) > 0\n\n    def has_c_libraries(self):\n        return self.libraries and len(self.libraries) > 0\n\n    def has_modules(self):\n        return self.has_pure_modules() or self.has_ext_modules()\n\n    def has_headers(self):\n        return self.headers and len(self.headers) > 0\n\n    def has_scripts(self):\n        return self.scripts and len(self.scripts) > 0\n\n    def has_data_files(self):\n        return self.data_files and len(self.data_files) > 0\n\n    def is_pure(self):\n        return (\n            self.has_pure_modules()\n            and not self.has_ext_modules()\n            and not self.has_c_libraries()\n        )\n\n    # -- Metadata query methods ----------------------------------------\n\n    # If you're looking for 'get_name()', 'get_version()', and so forth,\n    # they are defined in a sneaky way: the constructor binds self.get_XXX\n    # to self.metadata.get_XXX.  The actual code is in the\n    # DistributionMetadata class, below.\n\n\nclass DistributionMetadata:\n    \"\"\"Dummy class to hold the distribution meta-data: name, version,\n    author, and so forth.\n    \"\"\"\n\n    _METHOD_BASENAMES = (\n        \"name\",\n        \"version\",\n        \"author\",\n        \"author_email\",\n        \"maintainer\",\n        \"maintainer_email\",\n        \"url\",\n        \"license\",\n        \"description\",\n        \"long_description\",\n        \"keywords\",\n        \"platforms\",\n        \"fullname\",\n        \"contact\",\n        \"contact_email\",\n        \"classifiers\",\n        \"download_url\",\n        # PEP 314\n        \"provides\",\n        \"requires\",\n        \"obsoletes\",\n    )\n\n    def __init__(self, path=None):\n        if path is not None:\n            self.read_pkg_file(open(path))\n        else:\n            self.name = None\n            self.version = None\n            self.author = None\n            self.author_email = None\n            self.maintainer = None\n            self.maintainer_email = None\n            self.url = None\n            self.license = None\n            self.description = None\n            self.long_description = None\n            self.keywords = None\n            self.platforms = None\n            self.classifiers = None\n            self.download_url = None\n            # PEP 314\n            self.provides = None\n            self.requires = None\n            self.obsoletes = None\n\n    def read_pkg_file(self, file):\n        \"\"\"Reads the metadata values from a file object.\"\"\"\n        msg = message_from_file(file)\n\n        def _read_field(name):\n            value = msg[name]\n            if value and value != \"UNKNOWN\":\n                return value\n\n        def _read_list(name):\n            values = msg.get_all(name, None)\n            if values == []:\n                return None\n            return values\n\n        metadata_version = msg['metadata-version']\n        self.name = _read_field('name')\n        self.version = _read_field('version')\n        self.description = _read_field('summary')\n        # we are filling author only.\n        self.author = _read_field('author')\n        self.maintainer = None\n        self.author_email = _read_field('author-email')\n        self.maintainer_email = None\n        self.url = _read_field('home-page')\n        self.license = _read_field('license')\n\n        if 'download-url' in msg:\n            self.download_url = _read_field('download-url')\n        else:\n            self.download_url = None\n\n        self.long_description = _read_field('description')\n        self.description = _read_field('summary')\n\n        if 'keywords' in msg:\n            self.keywords = _read_field('keywords').split(',')\n\n        self.platforms = _read_list('platform')\n        self.classifiers = _read_list('classifier')\n\n        # PEP 314 - these fields only exist in 1.1\n        if metadata_version == '1.1':\n            self.requires = _read_list('requires')\n            self.provides = _read_list('provides')\n            self.obsoletes = _read_list('obsoletes')\n        else:\n            self.requires = None\n            self.provides = None\n            self.obsoletes = None\n\n    def write_pkg_info(self, base_dir):\n        \"\"\"Write the PKG-INFO file into the release tree.\"\"\"\n        with open(\n            os.path.join(base_dir, 'PKG-INFO'), 'w', encoding='UTF-8'\n        ) as pkg_info:\n            self.write_pkg_file(pkg_info)\n\n    def write_pkg_file(self, file):\n        \"\"\"Write the PKG-INFO format data to a file object.\"\"\"\n        version = '1.0'\n        if (\n            self.provides\n            or self.requires\n            or self.obsoletes\n            or self.classifiers\n            or self.download_url\n        ):\n            version = '1.1'\n\n        # required fields\n        file.write(f'Metadata-Version: {version}\\n')\n        file.write(f'Name: {self.get_name()}\\n')\n        file.write(f'Version: {self.get_version()}\\n')\n\n        def maybe_write(header, val):\n            if val:\n                file.write(f\"{header}: {val}\\n\")\n\n        # optional fields\n        maybe_write(\"Summary\", self.get_description())\n        maybe_write(\"Home-page\", self.get_url())\n        maybe_write(\"Author\", self.get_contact())\n        maybe_write(\"Author-email\", self.get_contact_email())\n        maybe_write(\"License\", self.get_license())\n        maybe_write(\"Download-URL\", self.download_url)\n        maybe_write(\"Description\", rfc822_escape(self.get_long_description() or \"\"))\n        maybe_write(\"Keywords\", \",\".join(self.get_keywords()))\n\n        self._write_list(file, 'Platform', self.get_platforms())\n        self._write_list(file, 'Classifier', self.get_classifiers())\n\n        # PEP 314\n        self._write_list(file, 'Requires', self.get_requires())\n        self._write_list(file, 'Provides', self.get_provides())\n        self._write_list(file, 'Obsoletes', self.get_obsoletes())\n\n    def _write_list(self, file, name, values):\n        values = values or []\n        for value in values:\n            file.write(f'{name}: {value}\\n')\n\n    # -- Metadata query methods ----------------------------------------\n\n    def get_name(self):\n        return self.name or \"UNKNOWN\"\n\n    def get_version(self):\n        return self.version or \"0.0.0\"\n\n    def get_fullname(self):\n        return self._fullname(self.get_name(), self.get_version())\n\n    @staticmethod\n    def _fullname(name: str, version: str) -> str:\n        \"\"\"\n        >>> DistributionMetadata._fullname('setup.tools', '1.0-2')\n        'setup_tools-1.0.post2'\n        >>> DistributionMetadata._fullname('setup-tools', '1.2post2')\n        'setup_tools-1.2.post2'\n        >>> DistributionMetadata._fullname('setup-tools', '1.0-r2')\n        'setup_tools-1.0.post2'\n        >>> DistributionMetadata._fullname('setup.tools', '1.0.post')\n        'setup_tools-1.0.post0'\n        >>> DistributionMetadata._fullname('setup.tools', '1.0+ubuntu-1')\n        'setup_tools-1.0+ubuntu.1'\n        \"\"\"\n        return \"{}-{}\".format(\n            canonicalize_name(name).replace('-', '_'),\n            canonicalize_version(version, strip_trailing_zero=False),\n        )\n\n    def get_author(self):\n        return self.author\n\n    def get_author_email(self):\n        return self.author_email\n\n    def get_maintainer(self):\n        return self.maintainer\n\n    def get_maintainer_email(self):\n        return self.maintainer_email\n\n    def get_contact(self):\n        return self.maintainer or self.author\n\n    def get_contact_email(self):\n        return self.maintainer_email or self.author_email\n\n    def get_url(self):\n        return self.url\n\n    def get_license(self):\n        return self.license\n\n    get_licence = get_license\n\n    def get_description(self):\n        return self.description\n\n    def get_long_description(self):\n        return self.long_description\n\n    def get_keywords(self):\n        return self.keywords or []\n\n    def set_keywords(self, value):\n        self.keywords = _ensure_list(value, 'keywords')\n\n    def get_platforms(self):\n        return self.platforms\n\n    def set_platforms(self, value):\n        self.platforms = _ensure_list(value, 'platforms')\n\n    def get_classifiers(self):\n        return self.classifiers or []\n\n    def set_classifiers(self, value):\n        self.classifiers = _ensure_list(value, 'classifiers')\n\n    def get_download_url(self):\n        return self.download_url\n\n    # PEP 314\n    def get_requires(self):\n        return self.requires or []\n\n    def set_requires(self, value):\n        import distutils.versionpredicate\n\n        for v in value:\n            distutils.versionpredicate.VersionPredicate(v)\n        self.requires = list(value)\n\n    def get_provides(self):\n        return self.provides or []\n\n    def set_provides(self, value):\n        value = [v.strip() for v in value]\n        for v in value:\n            import distutils.versionpredicate\n\n            distutils.versionpredicate.split_provision(v)\n        self.provides = value\n\n    def get_obsoletes(self):\n        return self.obsoletes or []\n\n    def set_obsoletes(self, value):\n        import distutils.versionpredicate\n\n        for v in value:\n            distutils.versionpredicate.VersionPredicate(v)\n        self.obsoletes = list(value)\n\n\ndef fix_help_options(options):\n    \"\"\"Convert a 4-tuple 'help_options' list as found in various command\n    classes to the 3-tuple form required by FancyGetopt.\n    \"\"\"\n    return [opt[0:3] for opt in options]\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/errors.py","size":3325,"sha1":"74b8dac5c60550d60e2326a524e011053823e90e","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nExceptions used by the Distutils modules.\n\nDistutils modules may raise these or standard exceptions,\nincluding :exc:`SystemExit`.\n\"\"\"\n\n\nclass DistutilsError(Exception):\n    \"\"\"The root of all Distutils evil.\"\"\"\n\n    pass\n\n\nclass DistutilsModuleError(DistutilsError):\n    \"\"\"Unable to load an expected module, or to find an expected class\n    within some module (in particular, command modules and classes).\"\"\"\n\n    pass\n\n\nclass DistutilsClassError(DistutilsError):\n    \"\"\"Some command class (or possibly distribution class, if anyone\n    feels a need to subclass Distribution) is found not to be holding\n    up its end of the bargain, ie. implementing some part of the\n    \"command \"interface.\"\"\"\n\n    pass\n\n\nclass DistutilsGetoptError(DistutilsError):\n    \"\"\"The option table provided to 'fancy_getopt()' is bogus.\"\"\"\n\n    pass\n\n\nclass DistutilsArgError(DistutilsError):\n    \"\"\"Raised by fancy_getopt in response to getopt.error -- ie. an\n    error in the command line usage.\"\"\"\n\n    pass\n\n\nclass DistutilsFileError(DistutilsError):\n    \"\"\"Any problems in the filesystem: expected file not found, etc.\n    Typically this is for problems that we detect before OSError\n    could be raised.\"\"\"\n\n    pass\n\n\nclass DistutilsOptionError(DistutilsError):\n    \"\"\"Syntactic/semantic errors in command options, such as use of\n    mutually conflicting options, or inconsistent options,\n    badly-spelled values, etc.  No distinction is made between option\n    values originating in the setup script, the command line, config\n    files, or what-have-you -- but if we *know* something originated in\n    the setup script, we'll raise DistutilsSetupError instead.\"\"\"\n\n    pass\n\n\nclass DistutilsSetupError(DistutilsError):\n    \"\"\"For errors that can be definitely blamed on the setup script,\n    such as invalid keyword arguments to 'setup()'.\"\"\"\n\n    pass\n\n\nclass DistutilsPlatformError(DistutilsError):\n    \"\"\"We don't know how to do something on the current platform (but\n    we do know how to do it on some platform) -- eg. trying to compile\n    C files on a platform not supported by a CCompiler subclass.\"\"\"\n\n    pass\n\n\nclass DistutilsExecError(DistutilsError):\n    \"\"\"Any problems executing an external program (such as the C\n    compiler, when compiling C files).\"\"\"\n\n    pass\n\n\nclass DistutilsInternalError(DistutilsError):\n    \"\"\"Internal inconsistencies or impossibilities (obviously, this\n    should never be seen if the code is working!).\"\"\"\n\n    pass\n\n\nclass DistutilsTemplateError(DistutilsError):\n    \"\"\"Syntax error in a file list template.\"\"\"\n\n\nclass DistutilsByteCompileError(DistutilsError):\n    \"\"\"Byte compile error.\"\"\"\n\n\n# Exception classes used by the CCompiler implementation classes\nclass CCompilerError(Exception):\n    \"\"\"Some compile/link operation failed.\"\"\"\n\n\nclass PreprocessError(CCompilerError):\n    \"\"\"Failure to preprocess one or more C/C++ files.\"\"\"\n\n\nclass CompileError(CCompilerError):\n    \"\"\"Failure to compile one or more C/C++ source files.\"\"\"\n\n\nclass LibError(CCompilerError):\n    \"\"\"Failure to create a static library from one or more C/C++ object\n    files.\"\"\"\n\n\nclass LinkError(CCompilerError):\n    \"\"\"Failure to link one or more C/C++ object files into an executable\n    or shared library file.\"\"\"\n\n\nclass UnknownFileError(CCompilerError):\n    \"\"\"Attempt to process an unknown file type.\"\"\"\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/extension.py","size":10755,"sha1":"b4200c136bdad0b3108314c93c63c7acc3692a41","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.extension\n\nProvides the Extension class, used to describe C/C++ extension\nmodules in setup scripts.\"\"\"\n\nimport os\nimport warnings\n\n# This class is really only used by the \"build_ext\" command, so it might\n# make sense to put it in distutils.command.build_ext.  However, that\n# module is already big enough, and I want to make this class a bit more\n# complex to simplify some common cases (\"foo\" module in \"foo.c\") and do\n# better error-checking (\"foo.c\" actually exists).\n#\n# Also, putting this in build_ext.py means every setup script would have to\n# import that large-ish module (indirectly, through distutils.core) in\n# order to do anything.\n\n\nclass Extension:\n    \"\"\"Just a collection of attributes that describes an extension\n    module and everything needed to build it (hopefully in a portable\n    way, but there are hooks that let you be as unportable as you need).\n\n    Instance attributes:\n      name : string\n        the full name of the extension, including any packages -- ie.\n        *not* a filename or pathname, but Python dotted name\n      sources : Iterable[string | os.PathLike]\n        iterable of source filenames (except strings, which could be misinterpreted\n        as a single filename), relative to the distribution root (where the setup\n        script lives), in Unix form (slash-separated) for portability. Can be any\n        non-string iterable (list, tuple, set, etc.) containing strings or\n        PathLike objects. Source files may be C, C++, SWIG (.i), platform-specific\n        resource files, or whatever else is recognized by the \"build_ext\" command\n        as source for a Python extension.\n      include_dirs : [string]\n        list of directories to search for C/C++ header files (in Unix\n        form for portability)\n      define_macros : [(name : string, value : string|None)]\n        list of macros to define; each macro is defined using a 2-tuple,\n        where 'value' is either the string to define it to or None to\n        define it without a particular value (equivalent of \"#define\n        FOO\" in source or -DFOO on Unix C compiler command line)\n      undef_macros : [string]\n        list of macros to undefine explicitly\n      library_dirs : [string]\n        list of directories to search for C/C++ libraries at link time\n      libraries : [string]\n        list of library names (not filenames or paths) to link against\n      runtime_library_dirs : [string]\n        list of directories to search for C/C++ libraries at run time\n        (for shared extensions, this is when the extension is loaded)\n      extra_objects : [string]\n        list of extra files to link with (eg. object files not implied\n        by 'sources', static library that must be explicitly specified,\n        binary resource files, etc.)\n      extra_compile_args : [string]\n        any extra platform- and compiler-specific information to use\n        when compiling the source files in 'sources'.  For platforms and\n        compilers where \"command line\" makes sense, this is typically a\n        list of command-line arguments, but for other platforms it could\n        be anything.\n      extra_link_args : [string]\n        any extra platform- and compiler-specific information to use\n        when linking object files together to create the extension (or\n        to create a new static Python interpreter).  Similar\n        interpretation as for 'extra_compile_args'.\n      export_symbols : [string]\n        list of symbols to be exported from a shared extension.  Not\n        used on all platforms, and not generally necessary for Python\n        extensions, which typically export exactly one symbol: \"init\" +\n        extension_name.\n      swig_opts : [string]\n        any extra options to pass to SWIG if a source file has the .i\n        extension.\n      depends : [string]\n        list of files that the extension depends on\n      language : string\n        extension language (i.e. \"c\", \"c++\", \"objc\"). Will be detected\n        from the source extensions if not provided.\n      optional : boolean\n        specifies that a build failure in the extension should not abort the\n        build process, but simply not install the failing extension.\n    \"\"\"\n\n    # When adding arguments to this constructor, be sure to update\n    # setup_keywords in core.py.\n    def __init__(\n        self,\n        name,\n        sources,\n        include_dirs=None,\n        define_macros=None,\n        undef_macros=None,\n        library_dirs=None,\n        libraries=None,\n        runtime_library_dirs=None,\n        extra_objects=None,\n        extra_compile_args=None,\n        extra_link_args=None,\n        export_symbols=None,\n        swig_opts=None,\n        depends=None,\n        language=None,\n        optional=None,\n        **kw,  # To catch unknown keywords\n    ):\n        if not isinstance(name, str):\n            raise TypeError(\"'name' must be a string\")\n\n        # handle the string case first; since strings are iterable, disallow them\n        if isinstance(sources, str):\n            raise TypeError(\n                \"'sources' must be an iterable of strings or PathLike objects, not a string\"\n            )\n\n        # now we check if it's iterable and contains valid types\n        try:\n            self.sources = list(map(os.fspath, sources))\n        except TypeError:\n            raise TypeError(\n                \"'sources' must be an iterable of strings or PathLike objects\"\n            )\n\n        self.name = name\n        self.include_dirs = include_dirs or []\n        self.define_macros = define_macros or []\n        self.undef_macros = undef_macros or []\n        self.library_dirs = library_dirs or []\n        self.libraries = libraries or []\n        self.runtime_library_dirs = runtime_library_dirs or []\n        self.extra_objects = extra_objects or []\n        self.extra_compile_args = extra_compile_args or []\n        self.extra_link_args = extra_link_args or []\n        self.export_symbols = export_symbols or []\n        self.swig_opts = swig_opts or []\n        self.depends = depends or []\n        self.language = language\n        self.optional = optional\n\n        # If there are unknown keyword options, warn about them\n        if len(kw) > 0:\n            options = [repr(option) for option in kw]\n            options = ', '.join(sorted(options))\n            msg = f\"Unknown Extension options: {options}\"\n            warnings.warn(msg)\n\n    def __repr__(self):\n        return f'<{self.__class__.__module__}.{self.__class__.__qualname__}({self.name!r}) at {id(self):#x}>'\n\n\ndef read_setup_file(filename):  # noqa: C901\n    \"\"\"Reads a Setup file and returns Extension instances.\"\"\"\n    from distutils.sysconfig import _variable_rx, expand_makefile_vars, parse_makefile\n    from distutils.text_file import TextFile\n    from distutils.util import split_quoted\n\n    # First pass over the file to gather \"VAR = VALUE\" assignments.\n    vars = parse_makefile(filename)\n\n    # Second pass to gobble up the real content: lines of the form\n    #   <module> ... [<sourcefile> ...] [<cpparg> ...] [<library> ...]\n    file = TextFile(\n        filename,\n        strip_comments=True,\n        skip_blanks=True,\n        join_lines=True,\n        lstrip_ws=True,\n        rstrip_ws=True,\n    )\n    try:\n        extensions = []\n\n        while True:\n            line = file.readline()\n            if line is None:  # eof\n                break\n            if _variable_rx.match(line):  # VAR=VALUE, handled in first pass\n                continue\n\n            if line[0] == line[-1] == \"*\":\n                file.warn(f\"'{line}' lines not handled yet\")\n                continue\n\n            line = expand_makefile_vars(line, vars)\n            words = split_quoted(line)\n\n            # NB. this parses a slightly different syntax than the old\n            # makesetup script: here, there must be exactly one extension per\n            # line, and it must be the first word of the line.  I have no idea\n            # why the old syntax supported multiple extensions per line, as\n            # they all wind up being the same.\n\n            module = words[0]\n            ext = Extension(module, [])\n            append_next_word = None\n\n            for word in words[1:]:\n                if append_next_word is not None:\n                    append_next_word.append(word)\n                    append_next_word = None\n                    continue\n\n                suffix = os.path.splitext(word)[1]\n                switch = word[0:2]\n                value = word[2:]\n\n                if suffix in (\".c\", \".cc\", \".cpp\", \".cxx\", \".c++\", \".m\", \".mm\"):\n                    # hmm, should we do something about C vs. C++ sources?\n                    # or leave it up to the CCompiler implementation to\n                    # worry about?\n                    ext.sources.append(word)\n                elif switch == \"-I\":\n                    ext.include_dirs.append(value)\n                elif switch == \"-D\":\n                    equals = value.find(\"=\")\n                    if equals == -1:  # bare \"-DFOO\" -- no value\n                        ext.define_macros.append((value, None))\n                    else:  # \"-DFOO=blah\"\n                        ext.define_macros.append((value[0:equals], value[equals + 2 :]))\n                elif switch == \"-U\":\n                    ext.undef_macros.append(value)\n                elif switch == \"-C\":  # only here 'cause makesetup has it!\n                    ext.extra_compile_args.append(word)\n                elif switch == \"-l\":\n                    ext.libraries.append(value)\n                elif switch == \"-L\":\n                    ext.library_dirs.append(value)\n                elif switch == \"-R\":\n                    ext.runtime_library_dirs.append(value)\n                elif word == \"-rpath\":\n                    append_next_word = ext.runtime_library_dirs\n                elif word == \"-Xlinker\":\n                    append_next_word = ext.extra_link_args\n                elif word == \"-Xcompiler\":\n                    append_next_word = ext.extra_compile_args\n                elif switch == \"-u\":\n                    ext.extra_link_args.append(word)\n                    if not value:\n                        append_next_word = ext.extra_link_args\n                elif suffix in (\".a\", \".so\", \".sl\", \".o\", \".dylib\"):\n                    # NB. a really faithful emulation of makesetup would\n                    # append a .o file to extra_objects only if it\n                    # had a slash in it; otherwise, it would s/.o/.c/\n                    # and append it to sources.  Hmmmm.\n                    ext.extra_objects.append(word)\n                else:\n                    file.warn(f\"unrecognized argument '{word}'\")\n\n            extensions.append(ext)\n    finally:\n        file.close()\n\n    return extensions\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/fancy_getopt.py","size":17895,"sha1":"00a0e2eeeb1a8c4a9d68b727f7b5e74916d3772e","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.fancy_getopt\n\nWrapper around the standard getopt module that provides the following\nadditional features:\n  * short and long options are tied together\n  * options have help strings, so fancy_getopt could potentially\n    create a complete usage summary\n  * options set attributes of a passed-in object\n\"\"\"\n\nfrom __future__ import annotations\n\nimport getopt\nimport re\nimport string\nimport sys\nfrom collections.abc import Sequence\nfrom typing import Any\n\nfrom .errors import DistutilsArgError, DistutilsGetoptError\n\n# Much like command_re in distutils.core, this is close to but not quite\n# the same as a Python NAME -- except, in the spirit of most GNU\n# utilities, we use '-' in place of '_'.  (The spirit of LISP lives on!)\n# The similarities to NAME are again not a coincidence...\nlongopt_pat = r'[a-zA-Z](?:[a-zA-Z0-9-]*)'\nlongopt_re = re.compile(rf'^{longopt_pat}$')\n\n# For recognizing \"negative alias\" options, eg. \"quiet=!verbose\"\nneg_alias_re = re.compile(f\"^({longopt_pat})=!({longopt_pat})$\")\n\n# This is used to translate long options to legitimate Python identifiers\n# (for use as attributes of some object).\nlongopt_xlate = str.maketrans('-', '_')\n\n\nclass FancyGetopt:\n    \"\"\"Wrapper around the standard 'getopt()' module that provides some\n    handy extra functionality:\n      * short and long options are tied together\n      * options have help strings, and help text can be assembled\n        from them\n      * options set attributes of a passed-in object\n      * boolean options can have \"negative aliases\" -- eg. if\n        --quiet is the \"negative alias\" of --verbose, then \"--quiet\"\n        on the command line sets 'verbose' to false\n    \"\"\"\n\n    def __init__(self, option_table=None):\n        # The option table is (currently) a list of tuples.  The\n        # tuples may have 3 or four values:\n        #   (long_option, short_option, help_string [, repeatable])\n        # if an option takes an argument, its long_option should have '='\n        # appended; short_option should just be a single character, no ':'\n        # in any case.  If a long_option doesn't have a corresponding\n        # short_option, short_option should be None.  All option tuples\n        # must have long options.\n        self.option_table = option_table\n\n        # 'option_index' maps long option names to entries in the option\n        # table (ie. those 3-tuples).\n        self.option_index = {}\n        if self.option_table:\n            self._build_index()\n\n        # 'alias' records (duh) alias options; {'foo': 'bar'} means\n        # --foo is an alias for --bar\n        self.alias = {}\n\n        # 'negative_alias' keeps track of options that are the boolean\n        # opposite of some other option\n        self.negative_alias = {}\n\n        # These keep track of the information in the option table.  We\n        # don't actually populate these structures until we're ready to\n        # parse the command-line, since the 'option_table' passed in here\n        # isn't necessarily the final word.\n        self.short_opts = []\n        self.long_opts = []\n        self.short2long = {}\n        self.attr_name = {}\n        self.takes_arg = {}\n\n        # And 'option_order' is filled up in 'getopt()'; it records the\n        # original order of options (and their values) on the command-line,\n        # but expands short options, converts aliases, etc.\n        self.option_order = []\n\n    def _build_index(self):\n        self.option_index.clear()\n        for option in self.option_table:\n            self.option_index[option[0]] = option\n\n    def set_option_table(self, option_table):\n        self.option_table = option_table\n        self._build_index()\n\n    def add_option(self, long_option, short_option=None, help_string=None):\n        if long_option in self.option_index:\n            raise DistutilsGetoptError(\n                f\"option conflict: already an option '{long_option}'\"\n            )\n        else:\n            option = (long_option, short_option, help_string)\n            self.option_table.append(option)\n            self.option_index[long_option] = option\n\n    def has_option(self, long_option):\n        \"\"\"Return true if the option table for this parser has an\n        option with long name 'long_option'.\"\"\"\n        return long_option in self.option_index\n\n    def get_attr_name(self, long_option):\n        \"\"\"Translate long option name 'long_option' to the form it\n        has as an attribute of some object: ie., translate hyphens\n        to underscores.\"\"\"\n        return long_option.translate(longopt_xlate)\n\n    def _check_alias_dict(self, aliases, what):\n        assert isinstance(aliases, dict)\n        for alias, opt in aliases.items():\n            if alias not in self.option_index:\n                raise DistutilsGetoptError(\n                    f\"invalid {what} '{alias}': option '{alias}' not defined\"\n                )\n            if opt not in self.option_index:\n                raise DistutilsGetoptError(\n                    f\"invalid {what} '{alias}': aliased option '{opt}' not defined\"\n                )\n\n    def set_aliases(self, alias):\n        \"\"\"Set the aliases for this option parser.\"\"\"\n        self._check_alias_dict(alias, \"alias\")\n        self.alias = alias\n\n    def set_negative_aliases(self, negative_alias):\n        \"\"\"Set the negative aliases for this option parser.\n        'negative_alias' should be a dictionary mapping option names to\n        option names, both the key and value must already be defined\n        in the option table.\"\"\"\n        self._check_alias_dict(negative_alias, \"negative alias\")\n        self.negative_alias = negative_alias\n\n    def _grok_option_table(self):  # noqa: C901\n        \"\"\"Populate the various data structures that keep tabs on the\n        option table.  Called by 'getopt()' before it can do anything\n        worthwhile.\n        \"\"\"\n        self.long_opts = []\n        self.short_opts = []\n        self.short2long.clear()\n        self.repeat = {}\n\n        for option in self.option_table:\n            if len(option) == 3:\n                long, short, help = option\n                repeat = 0\n            elif len(option) == 4:\n                long, short, help, repeat = option\n            else:\n                # the option table is part of the code, so simply\n                # assert that it is correct\n                raise ValueError(f\"invalid option tuple: {option!r}\")\n\n            # Type- and value-check the option names\n            if not isinstance(long, str) or len(long) < 2:\n                raise DistutilsGetoptError(\n                    f\"invalid long option '{long}': must be a string of length >= 2\"\n                )\n\n            if not ((short is None) or (isinstance(short, str) and len(short) == 1)):\n                raise DistutilsGetoptError(\n                    f\"invalid short option '{short}': must a single character or None\"\n                )\n\n            self.repeat[long] = repeat\n            self.long_opts.append(long)\n\n            if long[-1] == '=':  # option takes an argument?\n                if short:\n                    short = short + ':'\n                long = long[0:-1]\n                self.takes_arg[long] = True\n            else:\n                # Is option is a \"negative alias\" for some other option (eg.\n                # \"quiet\" == \"!verbose\")?\n                alias_to = self.negative_alias.get(long)\n                if alias_to is not None:\n                    if self.takes_arg[alias_to]:\n                        raise DistutilsGetoptError(\n                            f\"invalid negative alias '{long}': \"\n                            f\"aliased option '{alias_to}' takes a value\"\n                        )\n\n                    self.long_opts[-1] = long  # XXX redundant?!\n                self.takes_arg[long] = False\n\n            # If this is an alias option, make sure its \"takes arg\" flag is\n            # the same as the option it's aliased to.\n            alias_to = self.alias.get(long)\n            if alias_to is not None:\n                if self.takes_arg[long] != self.takes_arg[alias_to]:\n                    raise DistutilsGetoptError(\n                        f\"invalid alias '{long}': inconsistent with \"\n                        f\"aliased option '{alias_to}' (one of them takes a value, \"\n                        \"the other doesn't\"\n                    )\n\n            # Now enforce some bondage on the long option name, so we can\n            # later translate it to an attribute name on some object.  Have\n            # to do this a bit late to make sure we've removed any trailing\n            # '='.\n            if not longopt_re.match(long):\n                raise DistutilsGetoptError(\n                    f\"invalid long option name '{long}' \"\n                    \"(must be letters, numbers, hyphens only\"\n                )\n\n            self.attr_name[long] = self.get_attr_name(long)\n            if short:\n                self.short_opts.append(short)\n                self.short2long[short[0]] = long\n\n    def getopt(self, args: Sequence[str] | None = None, object=None):  # noqa: C901\n        \"\"\"Parse command-line options in args. Store as attributes on object.\n\n        If 'args' is None or not supplied, uses 'sys.argv[1:]'.  If\n        'object' is None or not supplied, creates a new OptionDummy\n        object, stores option values there, and returns a tuple (args,\n        object).  If 'object' is supplied, it is modified in place and\n        'getopt()' just returns 'args'; in both cases, the returned\n        'args' is a modified copy of the passed-in 'args' list, which\n        is left untouched.\n        \"\"\"\n        if args is None:\n            args = sys.argv[1:]\n        if object is None:\n            object = OptionDummy()\n            created_object = True\n        else:\n            created_object = False\n\n        self._grok_option_table()\n\n        short_opts = ' '.join(self.short_opts)\n        try:\n            opts, args = getopt.getopt(args, short_opts, self.long_opts)\n        except getopt.error as msg:\n            raise DistutilsArgError(msg)\n\n        for opt, val in opts:\n            if len(opt) == 2 and opt[0] == '-':  # it's a short option\n                opt = self.short2long[opt[1]]\n            else:\n                assert len(opt) > 2 and opt[:2] == '--'\n                opt = opt[2:]\n\n            alias = self.alias.get(opt)\n            if alias:\n                opt = alias\n\n            if not self.takes_arg[opt]:  # boolean option?\n                assert val == '', \"boolean option can't have value\"\n                alias = self.negative_alias.get(opt)\n                if alias:\n                    opt = alias\n                    val = 0\n                else:\n                    val = 1\n\n            attr = self.attr_name[opt]\n            # The only repeating option at the moment is 'verbose'.\n            # It has a negative option -q quiet, which should set verbose = False.\n            if val and self.repeat.get(attr) is not None:\n                val = getattr(object, attr, 0) + 1\n            setattr(object, attr, val)\n            self.option_order.append((opt, val))\n\n        # for opts\n        if created_object:\n            return args, object\n        else:\n            return args\n\n    def get_option_order(self):\n        \"\"\"Returns the list of (option, value) tuples processed by the\n        previous run of 'getopt()'.  Raises RuntimeError if\n        'getopt()' hasn't been called yet.\n        \"\"\"\n        if self.option_order is None:\n            raise RuntimeError(\"'getopt()' hasn't been called yet\")\n        else:\n            return self.option_order\n\n    def generate_help(self, header=None):  # noqa: C901\n        \"\"\"Generate help text (a list of strings, one per suggested line of\n        output) from the option table for this FancyGetopt object.\n        \"\"\"\n        # Blithely assume the option table is good: probably wouldn't call\n        # 'generate_help()' unless you've already called 'getopt()'.\n\n        # First pass: determine maximum length of long option names\n        max_opt = 0\n        for option in self.option_table:\n            long = option[0]\n            short = option[1]\n            ell = len(long)\n            if long[-1] == '=':\n                ell = ell - 1\n            if short is not None:\n                ell = ell + 5  # \" (-x)\" where short == 'x'\n            if ell > max_opt:\n                max_opt = ell\n\n        opt_width = max_opt + 2 + 2 + 2  # room for indent + dashes + gutter\n\n        # Typical help block looks like this:\n        #   --foo       controls foonabulation\n        # Help block for longest option looks like this:\n        #   --flimflam  set the flim-flam level\n        # and with wrapped text:\n        #   --flimflam  set the flim-flam level (must be between\n        #               0 and 100, except on Tuesdays)\n        # Options with short names will have the short name shown (but\n        # it doesn't contribute to max_opt):\n        #   --foo (-f)  controls foonabulation\n        # If adding the short option would make the left column too wide,\n        # we push the explanation off to the next line\n        #   --flimflam (-l)\n        #               set the flim-flam level\n        # Important parameters:\n        #   - 2 spaces before option block start lines\n        #   - 2 dashes for each long option name\n        #   - min. 2 spaces between option and explanation (gutter)\n        #   - 5 characters (incl. space) for short option name\n\n        # Now generate lines of help text.  (If 80 columns were good enough\n        # for Jesus, then 78 columns are good enough for me!)\n        line_width = 78\n        text_width = line_width - opt_width\n        big_indent = ' ' * opt_width\n        if header:\n            lines = [header]\n        else:\n            lines = ['Option summary:']\n\n        for option in self.option_table:\n            long, short, help = option[:3]\n            text = wrap_text(help, text_width)\n            if long[-1] == '=':\n                long = long[0:-1]\n\n            # Case 1: no short option at all (makes life easy)\n            if short is None:\n                if text:\n                    lines.append(f\"  --{long:<{max_opt}}  {text[0]}\")\n                else:\n                    lines.append(f\"  --{long:<{max_opt}}\")\n\n            # Case 2: we have a short option, so we have to include it\n            # just after the long option\n            else:\n                opt_names = f\"{long} (-{short})\"\n                if text:\n                    lines.append(f\"  --{opt_names:<{max_opt}}  {text[0]}\")\n                else:\n                    lines.append(f\"  --{opt_names:<{max_opt}}\")\n\n            for ell in text[1:]:\n                lines.append(big_indent + ell)\n        return lines\n\n    def print_help(self, header=None, file=None):\n        if file is None:\n            file = sys.stdout\n        for line in self.generate_help(header):\n            file.write(line + \"\\n\")\n\n\ndef fancy_getopt(options, negative_opt, object, args: Sequence[str] | None):\n    parser = FancyGetopt(options)\n    parser.set_negative_aliases(negative_opt)\n    return parser.getopt(args, object)\n\n\nWS_TRANS = {ord(_wschar): ' ' for _wschar in string.whitespace}\n\n\ndef wrap_text(text, width):\n    \"\"\"wrap_text(text : string, width : int) -> [string]\n\n    Split 'text' into multiple lines of no more than 'width' characters\n    each, and return the list of strings that results.\n    \"\"\"\n    if text is None:\n        return []\n    if len(text) <= width:\n        return [text]\n\n    text = text.expandtabs()\n    text = text.translate(WS_TRANS)\n    chunks = re.split(r'( +|-+)', text)\n    chunks = [ch for ch in chunks if ch]  # ' - ' results in empty strings\n    lines = []\n\n    while chunks:\n        cur_line = []  # list of chunks (to-be-joined)\n        cur_len = 0  # length of current line\n\n        while chunks:\n            ell = len(chunks[0])\n            if cur_len + ell <= width:  # can squeeze (at least) this chunk in\n                cur_line.append(chunks[0])\n                del chunks[0]\n                cur_len = cur_len + ell\n            else:  # this line is full\n                # drop last chunk if all space\n                if cur_line and cur_line[-1][0] == ' ':\n                    del cur_line[-1]\n                break\n\n        if chunks:  # any chunks left to process?\n            # if the current line is still empty, then we had a single\n            # chunk that's too big too fit on a line -- so we break\n            # down and break it up at the line width\n            if cur_len == 0:\n                cur_line.append(chunks[0][0:width])\n                chunks[0] = chunks[0][width:]\n\n            # all-whitespace chunks at the end of a line can be discarded\n            # (and we know from the re.split above that if a chunk has\n            # *any* whitespace, it is *all* whitespace)\n            if chunks[0][0] == ' ':\n                del chunks[0]\n\n        # and store this line in the list-of-all-lines -- as a single\n        # string, of course!\n        lines.append(''.join(cur_line))\n\n    return lines\n\n\ndef translate_longopt(opt):\n    \"\"\"Convert a long option name to a valid Python identifier by\n    changing \"-\" to \"_\".\n    \"\"\"\n    return opt.translate(longopt_xlate)\n\n\nclass OptionDummy:\n    \"\"\"Dummy class just used as a place to hold command-line option\n    values as instance attributes.\"\"\"\n\n    def __init__(self, options: Sequence[Any] = []):\n        \"\"\"Create a new OptionDummy instance.  The attributes listed in\n        'options' will be initialized to None.\"\"\"\n        for opt in options:\n            setattr(self, opt, None)\n\n\nif __name__ == \"__main__\":\n    text = \"\"\"\\\nTra-la-la, supercalifragilisticexpialidocious.\nHow *do* you spell that odd word, anyways?\n(Someone ask Mary -- she'll know [or she'll\nsay, \"How should I know?\"].)\"\"\"\n\n    for w in (10, 20, 30, 40):\n        print(f\"width: {w}\")\n        print(\"\\n\".join(wrap_text(text, w)))\n        print()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/file_util.py","size":7978,"sha1":"c9d0bbb9b9b0cd652062edb04cb7c021a0ff31db","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.file_util\n\nUtility functions for operating on single files.\n\"\"\"\n\nimport os\n\nfrom ._log import log\nfrom .errors import DistutilsFileError\n\n# for generating verbose output in 'copy_file()'\n_copy_action = {None: 'copying', 'hard': 'hard linking', 'sym': 'symbolically linking'}\n\n\ndef _copy_file_contents(src, dst, buffer_size=16 * 1024):  # noqa: C901\n    \"\"\"Copy the file 'src' to 'dst'; both must be filenames.  Any error\n    opening either file, reading from 'src', or writing to 'dst', raises\n    DistutilsFileError.  Data is read/written in chunks of 'buffer_size'\n    bytes (default 16k).  No attempt is made to handle anything apart from\n    regular files.\n    \"\"\"\n    # Stolen from shutil module in the standard library, but with\n    # custom error-handling added.\n    fsrc = None\n    fdst = None\n    try:\n        try:\n            fsrc = open(src, 'rb')\n        except OSError as e:\n            raise DistutilsFileError(f\"could not open '{src}': {e.strerror}\")\n\n        if os.path.exists(dst):\n            try:\n                os.unlink(dst)\n            except OSError as e:\n                raise DistutilsFileError(f\"could not delete '{dst}': {e.strerror}\")\n\n        try:\n            fdst = open(dst, 'wb')\n        except OSError as e:\n            raise DistutilsFileError(f\"could not create '{dst}': {e.strerror}\")\n\n        while True:\n            try:\n                buf = fsrc.read(buffer_size)\n            except OSError as e:\n                raise DistutilsFileError(f\"could not read from '{src}': {e.strerror}\")\n\n            if not buf:\n                break\n\n            try:\n                fdst.write(buf)\n            except OSError as e:\n                raise DistutilsFileError(f\"could not write to '{dst}': {e.strerror}\")\n    finally:\n        if fdst:\n            fdst.close()\n        if fsrc:\n            fsrc.close()\n\n\ndef copy_file(  # noqa: C901\n    src,\n    dst,\n    preserve_mode=True,\n    preserve_times=True,\n    update=False,\n    link=None,\n    verbose=True,\n    dry_run=False,\n):\n    \"\"\"Copy a file 'src' to 'dst'.  If 'dst' is a directory, then 'src' is\n    copied there with the same name; otherwise, it must be a filename.  (If\n    the file exists, it will be ruthlessly clobbered.)  If 'preserve_mode'\n    is true (the default), the file's mode (type and permission bits, or\n    whatever is analogous on the current platform) is copied.  If\n    'preserve_times' is true (the default), the last-modified and\n    last-access times are copied as well.  If 'update' is true, 'src' will\n    only be copied if 'dst' does not exist, or if 'dst' does exist but is\n    older than 'src'.\n\n    'link' allows you to make hard links (os.link) or symbolic links\n    (os.symlink) instead of copying: set it to \"hard\" or \"sym\"; if it is\n    None (the default), files are copied.  Don't set 'link' on systems that\n    don't support it: 'copy_file()' doesn't check if hard or symbolic\n    linking is available. If hardlink fails, falls back to\n    _copy_file_contents().\n\n    Under Mac OS, uses the native file copy function in macostools; on\n    other systems, uses '_copy_file_contents()' to copy file contents.\n\n    Return a tuple (dest_name, copied): 'dest_name' is the actual name of\n    the output file, and 'copied' is true if the file was copied (or would\n    have been copied, if 'dry_run' true).\n    \"\"\"\n    # XXX if the destination file already exists, we clobber it if\n    # copying, but blow up if linking.  Hmmm.  And I don't know what\n    # macostools.copyfile() does.  Should definitely be consistent, and\n    # should probably blow up if destination exists and we would be\n    # changing it (ie. it's not already a hard/soft link to src OR\n    # (not update) and (src newer than dst).\n\n    from distutils._modified import newer\n    from stat import S_IMODE, ST_ATIME, ST_MODE, ST_MTIME\n\n    if not os.path.isfile(src):\n        raise DistutilsFileError(\n            f\"can't copy '{src}': doesn't exist or not a regular file\"\n        )\n\n    if os.path.isdir(dst):\n        dir = dst\n        dst = os.path.join(dst, os.path.basename(src))\n    else:\n        dir = os.path.dirname(dst)\n\n    if update and not newer(src, dst):\n        if verbose >= 1:\n            log.debug(\"not copying %s (output up-to-date)\", src)\n        return (dst, False)\n\n    try:\n        action = _copy_action[link]\n    except KeyError:\n        raise ValueError(f\"invalid value '{link}' for 'link' argument\")\n\n    if verbose >= 1:\n        if os.path.basename(dst) == os.path.basename(src):\n            log.info(\"%s %s -> %s\", action, src, dir)\n        else:\n            log.info(\"%s %s -> %s\", action, src, dst)\n\n    if dry_run:\n        return (dst, True)\n\n    # If linking (hard or symbolic), use the appropriate system call\n    # (Unix only, of course, but that's the caller's responsibility)\n    elif link == 'hard':\n        if not (os.path.exists(dst) and os.path.samefile(src, dst)):\n            try:\n                os.link(src, dst)\n            except OSError:\n                # If hard linking fails, fall back on copying file\n                # (some special filesystems don't support hard linking\n                #  even under Unix, see issue #8876).\n                pass\n            else:\n                return (dst, True)\n    elif link == 'sym':\n        if not (os.path.exists(dst) and os.path.samefile(src, dst)):\n            os.symlink(src, dst)\n            return (dst, True)\n\n    # Otherwise (non-Mac, not linking), copy the file contents and\n    # (optionally) copy the times and mode.\n    _copy_file_contents(src, dst)\n    if preserve_mode or preserve_times:\n        st = os.stat(src)\n\n        # According to David Ascher <da@ski.org>, utime() should be done\n        # before chmod() (at least under NT).\n        if preserve_times:\n            os.utime(dst, (st[ST_ATIME], st[ST_MTIME]))\n        if preserve_mode:\n            os.chmod(dst, S_IMODE(st[ST_MODE]))\n\n    return (dst, True)\n\n\n# XXX I suspect this is Unix-specific -- need porting help!\ndef move_file(src, dst, verbose=True, dry_run=False):  # noqa: C901\n    \"\"\"Move a file 'src' to 'dst'.  If 'dst' is a directory, the file will\n    be moved into it with the same name; otherwise, 'src' is just renamed\n    to 'dst'.  Return the new full name of the file.\n\n    Handles cross-device moves on Unix using 'copy_file()'.  What about\n    other systems???\n    \"\"\"\n    import errno\n    from os.path import basename, dirname, exists, isdir, isfile\n\n    if verbose >= 1:\n        log.info(\"moving %s -> %s\", src, dst)\n\n    if dry_run:\n        return dst\n\n    if not isfile(src):\n        raise DistutilsFileError(f\"can't move '{src}': not a regular file\")\n\n    if isdir(dst):\n        dst = os.path.join(dst, basename(src))\n    elif exists(dst):\n        raise DistutilsFileError(\n            f\"can't move '{src}': destination '{dst}' already exists\"\n        )\n\n    if not isdir(dirname(dst)):\n        raise DistutilsFileError(\n            f\"can't move '{src}': destination '{dst}' not a valid path\"\n        )\n\n    copy_it = False\n    try:\n        os.rename(src, dst)\n    except OSError as e:\n        (num, msg) = e.args\n        if num == errno.EXDEV:\n            copy_it = True\n        else:\n            raise DistutilsFileError(f\"couldn't move '{src}' to '{dst}': {msg}\")\n\n    if copy_it:\n        copy_file(src, dst, verbose=verbose)\n        try:\n            os.unlink(src)\n        except OSError as e:\n            (num, msg) = e.args\n            try:\n                os.unlink(dst)\n            except OSError:\n                pass\n            raise DistutilsFileError(\n                f\"couldn't move '{src}' to '{dst}' by copy/delete: \"\n                f\"delete '{src}' failed: {msg}\"\n            )\n    return dst\n\n\ndef write_file(filename, contents):\n    \"\"\"Create a file with the specified name and write 'contents' (a\n    sequence of strings without line terminators) to it.\n    \"\"\"\n    with open(filename, 'w', encoding='utf-8') as f:\n        f.writelines(line + '\\n' for line in contents)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/filelist.py","size":13567,"sha1":"1c627bbae9222bd1da176b3f4bf7d0c789b01ba4","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.filelist\n\nProvides the FileList class, used for poking about the filesystem\nand building lists of files.\n\"\"\"\n\nimport fnmatch\nimport functools\nimport os\nimport re\n\nfrom ._log import log\nfrom .errors import DistutilsInternalError, DistutilsTemplateError\nfrom .util import convert_path\n\n\nclass FileList:\n    \"\"\"A list of files built by on exploring the filesystem and filtered by\n    applying various patterns to what we find there.\n\n    Instance attributes:\n      dir\n        directory from which files will be taken -- only used if\n        'allfiles' not supplied to constructor\n      files\n        list of filenames currently being built/filtered/manipulated\n      allfiles\n        complete list of files under consideration (ie. without any\n        filtering applied)\n    \"\"\"\n\n    def __init__(self, warn=None, debug_print=None):\n        # ignore argument to FileList, but keep them for backwards\n        # compatibility\n        self.allfiles = None\n        self.files = []\n\n    def set_allfiles(self, allfiles):\n        self.allfiles = allfiles\n\n    def findall(self, dir=os.curdir):\n        self.allfiles = findall(dir)\n\n    def debug_print(self, msg):\n        \"\"\"Print 'msg' to stdout if the global DEBUG (taken from the\n        DISTUTILS_DEBUG environment variable) flag is true.\n        \"\"\"\n        from distutils.debug import DEBUG\n\n        if DEBUG:\n            print(msg)\n\n    # Collection methods\n\n    def append(self, item):\n        self.files.append(item)\n\n    def extend(self, items):\n        self.files.extend(items)\n\n    def sort(self):\n        # Not a strict lexical sort!\n        sortable_files = sorted(map(os.path.split, self.files))\n        self.files = []\n        for sort_tuple in sortable_files:\n            self.files.append(os.path.join(*sort_tuple))\n\n    # Other miscellaneous utility methods\n\n    def remove_duplicates(self):\n        # Assumes list has been sorted!\n        for i in range(len(self.files) - 1, 0, -1):\n            if self.files[i] == self.files[i - 1]:\n                del self.files[i]\n\n    # \"File template\" methods\n\n    def _parse_template_line(self, line):\n        words = line.split()\n        action = words[0]\n\n        patterns = dir = dir_pattern = None\n\n        if action in ('include', 'exclude', 'global-include', 'global-exclude'):\n            if len(words) < 2:\n                raise DistutilsTemplateError(\n                    f\"'{action}' expects <pattern1> <pattern2> ...\"\n                )\n            patterns = [convert_path(w) for w in words[1:]]\n        elif action in ('recursive-include', 'recursive-exclude'):\n            if len(words) < 3:\n                raise DistutilsTemplateError(\n                    f\"'{action}' expects <dir> <pattern1> <pattern2> ...\"\n                )\n            dir = convert_path(words[1])\n            patterns = [convert_path(w) for w in words[2:]]\n        elif action in ('graft', 'prune'):\n            if len(words) != 2:\n                raise DistutilsTemplateError(\n                    f\"'{action}' expects a single <dir_pattern>\"\n                )\n            dir_pattern = convert_path(words[1])\n        else:\n            raise DistutilsTemplateError(f\"unknown action '{action}'\")\n\n        return (action, patterns, dir, dir_pattern)\n\n    def process_template_line(self, line):  # noqa: C901\n        # Parse the line: split it up, make sure the right number of words\n        # is there, and return the relevant words.  'action' is always\n        # defined: it's the first word of the line.  Which of the other\n        # three are defined depends on the action; it'll be either\n        # patterns, (dir and patterns), or (dir_pattern).\n        (action, patterns, dir, dir_pattern) = self._parse_template_line(line)\n\n        # OK, now we know that the action is valid and we have the\n        # right number of words on the line for that action -- so we\n        # can proceed with minimal error-checking.\n        if action == 'include':\n            self.debug_print(\"include \" + ' '.join(patterns))\n            for pattern in patterns:\n                if not self.include_pattern(pattern, anchor=True):\n                    log.warning(\"warning: no files found matching '%s'\", pattern)\n\n        elif action == 'exclude':\n            self.debug_print(\"exclude \" + ' '.join(patterns))\n            for pattern in patterns:\n                if not self.exclude_pattern(pattern, anchor=True):\n                    log.warning(\n                        \"warning: no previously-included files found matching '%s'\",\n                        pattern,\n                    )\n\n        elif action == 'global-include':\n            self.debug_print(\"global-include \" + ' '.join(patterns))\n            for pattern in patterns:\n                if not self.include_pattern(pattern, anchor=False):\n                    log.warning(\n                        (\n                            \"warning: no files found matching '%s' \"\n                            \"anywhere in distribution\"\n                        ),\n                        pattern,\n                    )\n\n        elif action == 'global-exclude':\n            self.debug_print(\"global-exclude \" + ' '.join(patterns))\n            for pattern in patterns:\n                if not self.exclude_pattern(pattern, anchor=False):\n                    log.warning(\n                        (\n                            \"warning: no previously-included files matching \"\n                            \"'%s' found anywhere in distribution\"\n                        ),\n                        pattern,\n                    )\n\n        elif action == 'recursive-include':\n            self.debug_print(\"recursive-include {} {}\".format(dir, ' '.join(patterns)))\n            for pattern in patterns:\n                if not self.include_pattern(pattern, prefix=dir):\n                    msg = \"warning: no files found matching '%s' under directory '%s'\"\n                    log.warning(msg, pattern, dir)\n\n        elif action == 'recursive-exclude':\n            self.debug_print(\"recursive-exclude {} {}\".format(dir, ' '.join(patterns)))\n            for pattern in patterns:\n                if not self.exclude_pattern(pattern, prefix=dir):\n                    log.warning(\n                        (\n                            \"warning: no previously-included files matching \"\n                            \"'%s' found under directory '%s'\"\n                        ),\n                        pattern,\n                        dir,\n                    )\n\n        elif action == 'graft':\n            self.debug_print(\"graft \" + dir_pattern)\n            if not self.include_pattern(None, prefix=dir_pattern):\n                log.warning(\"warning: no directories found matching '%s'\", dir_pattern)\n\n        elif action == 'prune':\n            self.debug_print(\"prune \" + dir_pattern)\n            if not self.exclude_pattern(None, prefix=dir_pattern):\n                log.warning(\n                    (\"no previously-included directories found matching '%s'\"),\n                    dir_pattern,\n                )\n        else:\n            raise DistutilsInternalError(\n                f\"this cannot happen: invalid action '{action}'\"\n            )\n\n    # Filtering/selection methods\n\n    def include_pattern(self, pattern, anchor=True, prefix=None, is_regex=False):\n        \"\"\"Select strings (presumably filenames) from 'self.files' that\n        match 'pattern', a Unix-style wildcard (glob) pattern.  Patterns\n        are not quite the same as implemented by the 'fnmatch' module: '*'\n        and '?'  match non-special characters, where \"special\" is platform-\n        dependent: slash on Unix; colon, slash, and backslash on\n        DOS/Windows; and colon on Mac OS.\n\n        If 'anchor' is true (the default), then the pattern match is more\n        stringent: \"*.py\" will match \"foo.py\" but not \"foo/bar.py\".  If\n        'anchor' is false, both of these will match.\n\n        If 'prefix' is supplied, then only filenames starting with 'prefix'\n        (itself a pattern) and ending with 'pattern', with anything in between\n        them, will match.  'anchor' is ignored in this case.\n\n        If 'is_regex' is true, 'anchor' and 'prefix' are ignored, and\n        'pattern' is assumed to be either a string containing a regex or a\n        regex object -- no translation is done, the regex is just compiled\n        and used as-is.\n\n        Selected strings will be added to self.files.\n\n        Return True if files are found, False otherwise.\n        \"\"\"\n        # XXX docstring lying about what the special chars are?\n        files_found = False\n        pattern_re = translate_pattern(pattern, anchor, prefix, is_regex)\n        self.debug_print(f\"include_pattern: applying regex r'{pattern_re.pattern}'\")\n\n        # delayed loading of allfiles list\n        if self.allfiles is None:\n            self.findall()\n\n        for name in self.allfiles:\n            if pattern_re.search(name):\n                self.debug_print(\" adding \" + name)\n                self.files.append(name)\n                files_found = True\n        return files_found\n\n    def exclude_pattern(self, pattern, anchor=True, prefix=None, is_regex=False):\n        \"\"\"Remove strings (presumably filenames) from 'files' that match\n        'pattern'.  Other parameters are the same as for\n        'include_pattern()', above.\n        The list 'self.files' is modified in place.\n        Return True if files are found, False otherwise.\n        \"\"\"\n        files_found = False\n        pattern_re = translate_pattern(pattern, anchor, prefix, is_regex)\n        self.debug_print(f\"exclude_pattern: applying regex r'{pattern_re.pattern}'\")\n        for i in range(len(self.files) - 1, -1, -1):\n            if pattern_re.search(self.files[i]):\n                self.debug_print(\" removing \" + self.files[i])\n                del self.files[i]\n                files_found = True\n        return files_found\n\n\n# Utility functions\n\n\ndef _find_all_simple(path):\n    \"\"\"\n    Find all files under 'path'\n    \"\"\"\n    all_unique = _UniqueDirs.filter(os.walk(path, followlinks=True))\n    results = (\n        os.path.join(base, file) for base, dirs, files in all_unique for file in files\n    )\n    return filter(os.path.isfile, results)\n\n\nclass _UniqueDirs(set):\n    \"\"\"\n    Exclude previously-seen dirs from walk results,\n    avoiding infinite recursion.\n    Ref https://bugs.python.org/issue44497.\n    \"\"\"\n\n    def __call__(self, walk_item):\n        \"\"\"\n        Given an item from an os.walk result, determine\n        if the item represents a unique dir for this instance\n        and if not, prevent further traversal.\n        \"\"\"\n        base, dirs, files = walk_item\n        stat = os.stat(base)\n        candidate = stat.st_dev, stat.st_ino\n        found = candidate in self\n        if found:\n            del dirs[:]\n        self.add(candidate)\n        return not found\n\n    @classmethod\n    def filter(cls, items):\n        return filter(cls(), items)\n\n\ndef findall(dir=os.curdir):\n    \"\"\"\n    Find all files under 'dir' and return the list of full filenames.\n    Unless dir is '.', return full filenames with dir prepended.\n    \"\"\"\n    files = _find_all_simple(dir)\n    if dir == os.curdir:\n        make_rel = functools.partial(os.path.relpath, start=dir)\n        files = map(make_rel, files)\n    return list(files)\n\n\ndef glob_to_re(pattern):\n    \"\"\"Translate a shell-like glob pattern to a regular expression; return\n    a string containing the regex.  Differs from 'fnmatch.translate()' in\n    that '*' does not match \"special characters\" (which are\n    platform-specific).\n    \"\"\"\n    pattern_re = fnmatch.translate(pattern)\n\n    # '?' and '*' in the glob pattern become '.' and '.*' in the RE, which\n    # IMHO is wrong -- '?' and '*' aren't supposed to match slash in Unix,\n    # and by extension they shouldn't match such \"special characters\" under\n    # any OS.  So change all non-escaped dots in the RE to match any\n    # character except the special characters (currently: just os.sep).\n    sep = os.sep\n    if os.sep == '\\\\':\n        # we're using a regex to manipulate a regex, so we need\n        # to escape the backslash twice\n        sep = r'\\\\\\\\'\n    escaped = rf'\\1[^{sep}]'\n    pattern_re = re.sub(r'((?<!\\\\)(\\\\\\\\)*)\\.', escaped, pattern_re)\n    return pattern_re\n\n\ndef translate_pattern(pattern, anchor=True, prefix=None, is_regex=False):\n    \"\"\"Translate a shell-like wildcard pattern to a compiled regular\n    expression.  Return the compiled regex.  If 'is_regex' true,\n    then 'pattern' is directly compiled to a regex (if it's a string)\n    or just returned as-is (assumes it's a regex object).\n    \"\"\"\n    if is_regex:\n        if isinstance(pattern, str):\n            return re.compile(pattern)\n        else:\n            return pattern\n\n    # ditch start and end characters\n    start, _, end = glob_to_re('_').partition('_')\n\n    if pattern:\n        pattern_re = glob_to_re(pattern)\n        assert pattern_re.startswith(start) and pattern_re.endswith(end)\n    else:\n        pattern_re = ''\n\n    if prefix is not None:\n        prefix_re = glob_to_re(prefix)\n        assert prefix_re.startswith(start) and prefix_re.endswith(end)\n        prefix_re = prefix_re[len(start) : len(prefix_re) - len(end)]\n        sep = os.sep\n        if os.sep == '\\\\':\n            sep = r'\\\\'\n        pattern_re = pattern_re[len(start) : len(pattern_re) - len(end)]\n        pattern_re = rf'{start}\\A{prefix_re}{sep}.*{pattern_re}{end}'\n    else:  # no prefix -- respect anchor flag\n        if anchor:\n            pattern_re = rf'{start}\\A{pattern_re[len(start) :]}'\n\n    return re.compile(pattern_re)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/log.py","size":1200,"sha1":"e953ec66c246b8691c497b9cc8f419032315b9f8","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nA simple log mechanism styled after PEP 282.\n\nRetained for compatibility and should not be used.\n\"\"\"\n\nimport logging\nimport warnings\n\nfrom ._log import log as _global_log\n\nDEBUG = logging.DEBUG\nINFO = logging.INFO\nWARN = logging.WARN\nERROR = logging.ERROR\nFATAL = logging.FATAL\n\nlog = _global_log.log\ndebug = _global_log.debug\ninfo = _global_log.info\nwarn = _global_log.warning\nerror = _global_log.error\nfatal = _global_log.fatal\n\n\ndef set_threshold(level):\n    orig = _global_log.level\n    _global_log.setLevel(level)\n    return orig\n\n\ndef set_verbosity(v):\n    if v <= 0:\n        set_threshold(logging.WARN)\n    elif v == 1:\n        set_threshold(logging.INFO)\n    elif v >= 2:\n        set_threshold(logging.DEBUG)\n\n\nclass Log(logging.Logger):\n    \"\"\"distutils.log.Log is deprecated, please use an alternative from `logging`.\"\"\"\n\n    def __init__(self, threshold=WARN):\n        warnings.warn(Log.__doc__)  # avoid DeprecationWarning to ensure warn is shown\n        super().__init__(__name__, level=threshold)\n\n    @property\n    def threshold(self):\n        return self.level\n\n    @threshold.setter\n    def threshold(self, level):\n        self.setLevel(level)\n\n    warn = logging.Logger.warning\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/spawn.py","size":3634,"sha1":"4f97e0bd7647164cbf2697a645a7a824484ac414","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.spawn\n\nProvides the 'spawn()' function, a front-end to various platform-\nspecific functions for launching another program in a sub-process.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport platform\nimport shutil\nimport subprocess\nimport sys\nimport warnings\nfrom collections.abc import Mapping\n\nfrom ._log import log\nfrom .debug import DEBUG\nfrom .errors import DistutilsExecError\n\n\ndef _debug(cmd):\n    \"\"\"\n    Render a subprocess command differently depending on DEBUG.\n    \"\"\"\n    return cmd if DEBUG else cmd[0]\n\n\ndef _inject_macos_ver(env: Mapping[str:str] | None) -> Mapping[str:str] | None:\n    if platform.system() != 'Darwin':\n        return env\n\n    from .util import MACOSX_VERSION_VAR, get_macosx_target_ver\n\n    target_ver = get_macosx_target_ver()\n    update = {MACOSX_VERSION_VAR: target_ver} if target_ver else {}\n    return {**_resolve(env), **update}\n\n\ndef _resolve(env: Mapping[str:str] | None) -> Mapping[str:str]:\n    return os.environ if env is None else env\n\n\ndef spawn(cmd, search_path=True, verbose=False, dry_run=False, env=None):\n    \"\"\"Run another program, specified as a command list 'cmd', in a new process.\n\n    'cmd' is just the argument list for the new process, ie.\n    cmd[0] is the program to run and cmd[1:] are the rest of its arguments.\n    There is no way to run a program with a name different from that of its\n    executable.\n\n    If 'search_path' is true (the default), the system's executable\n    search path will be used to find the program; otherwise, cmd[0]\n    must be the exact path to the executable.  If 'dry_run' is true,\n    the command will not actually be run.\n\n    Raise DistutilsExecError if running the program fails in any way; just\n    return on success.\n    \"\"\"\n    log.info(subprocess.list2cmdline(cmd))\n    if dry_run:\n        return\n\n    if search_path:\n        executable = shutil.which(cmd[0])\n        if executable is not None:\n            cmd[0] = executable\n\n    try:\n        subprocess.check_call(cmd, env=_inject_macos_ver(env))\n    except OSError as exc:\n        raise DistutilsExecError(\n            f\"command {_debug(cmd)!r} failed: {exc.args[-1]}\"\n        ) from exc\n    except subprocess.CalledProcessError as err:\n        raise DistutilsExecError(\n            f\"command {_debug(cmd)!r} failed with exit code {err.returncode}\"\n        ) from err\n\n\ndef find_executable(executable, path=None):\n    \"\"\"Tries to find 'executable' in the directories listed in 'path'.\n\n    A string listing directories separated by 'os.pathsep'; defaults to\n    os.environ['PATH'].  Returns the complete filename or None if not found.\n    \"\"\"\n    warnings.warn(\n        'Use shutil.which instead of find_executable', DeprecationWarning, stacklevel=2\n    )\n    _, ext = os.path.splitext(executable)\n    if (sys.platform == 'win32') and (ext != '.exe'):\n        executable = executable + '.exe'\n\n    if os.path.isfile(executable):\n        return executable\n\n    if path is None:\n        path = os.environ.get('PATH', None)\n        # bpo-35755: Don't fall through if PATH is the empty string\n        if path is None:\n            try:\n                path = os.confstr(\"CS_PATH\")\n            except (AttributeError, ValueError):\n                # os.confstr() or CS_PATH is not available\n                path = os.defpath\n\n    # PATH='' doesn't match, whereas PATH=':' looks in the current directory\n    if not path:\n        return None\n\n    paths = path.split(os.pathsep)\n    for p in paths:\n        f = os.path.join(p, executable)\n        if os.path.isfile(f):\n            # the file exists, we have a shot at spawn working\n            return f\n    return None\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/sysconfig.py","size":19266,"sha1":"451edbcdabd5db6bd50f15aa30773af059ab6bcc","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Provide access to Python's configuration information.  The specific\nconfiguration variables available depend heavily on the platform and\nconfiguration.  The values may be retrieved using\nget_config_var(name), and the list of variables is available via\nget_config_vars().keys().  Additional convenience functions are also\navailable.\n\nWritten by:   Fred L. Drake, Jr.\nEmail:        <fdrake@acm.org>\n\"\"\"\n\nimport functools\nimport os\nimport pathlib\nimport re\nimport sys\nimport sysconfig\n\nfrom jaraco.functools import pass_none\n\nfrom .compat import py39\nfrom .errors import DistutilsPlatformError\nfrom .util import is_mingw\n\nIS_PYPY = '__pypy__' in sys.builtin_module_names\n\n# These are needed in a couple of spots, so just compute them once.\nPREFIX = os.path.normpath(sys.prefix)\nEXEC_PREFIX = os.path.normpath(sys.exec_prefix)\nBASE_PREFIX = os.path.normpath(sys.base_prefix)\nBASE_EXEC_PREFIX = os.path.normpath(sys.base_exec_prefix)\n\n# Path to the base directory of the project. On Windows the binary may\n# live in project/PCbuild/win32 or project/PCbuild/amd64.\n# set for cross builds\nif \"_PYTHON_PROJECT_BASE\" in os.environ:\n    project_base = os.path.abspath(os.environ[\"_PYTHON_PROJECT_BASE\"])\nelse:\n    if sys.executable:\n        project_base = os.path.dirname(os.path.abspath(sys.executable))\n    else:\n        # sys.executable can be empty if argv[0] has been changed and Python is\n        # unable to retrieve the real program name\n        project_base = os.getcwd()\n\n\ndef _is_python_source_dir(d):\n    \"\"\"\n    Return True if the target directory appears to point to an\n    un-installed Python.\n    \"\"\"\n    modules = pathlib.Path(d).joinpath('Modules')\n    return any(modules.joinpath(fn).is_file() for fn in ('Setup', 'Setup.local'))\n\n\n_sys_home = getattr(sys, '_home', None)\n\n\ndef _is_parent(dir_a, dir_b):\n    \"\"\"\n    Return True if a is a parent of b.\n    \"\"\"\n    return os.path.normcase(dir_a).startswith(os.path.normcase(dir_b))\n\n\nif os.name == 'nt':\n\n    @pass_none\n    def _fix_pcbuild(d):\n        # In a venv, sys._home will be inside BASE_PREFIX rather than PREFIX.\n        prefixes = PREFIX, BASE_PREFIX\n        matched = (\n            prefix\n            for prefix in prefixes\n            if _is_parent(d, os.path.join(prefix, \"PCbuild\"))\n        )\n        return next(matched, d)\n\n    project_base = _fix_pcbuild(project_base)\n    _sys_home = _fix_pcbuild(_sys_home)\n\n\ndef _python_build():\n    if _sys_home:\n        return _is_python_source_dir(_sys_home)\n    return _is_python_source_dir(project_base)\n\n\npython_build = _python_build()\n\n\n# Calculate the build qualifier flags if they are defined.  Adding the flags\n# to the include and lib directories only makes sense for an installation, not\n# an in-source build.\nbuild_flags = ''\ntry:\n    if not python_build:\n        build_flags = sys.abiflags\nexcept AttributeError:\n    # It's not a configure-based build, so the sys module doesn't have\n    # this attribute, which is fine.\n    pass\n\n\ndef get_python_version():\n    \"\"\"Return a string containing the major and minor Python version,\n    leaving off the patchlevel.  Sample return values could be '1.5'\n    or '2.2'.\n    \"\"\"\n    return f'{sys.version_info.major}.{sys.version_info.minor}'\n\n\ndef get_python_inc(plat_specific=False, prefix=None):\n    \"\"\"Return the directory containing installed Python header files.\n\n    If 'plat_specific' is false (the default), this is the path to the\n    non-platform-specific header files, i.e. Python.h and so on;\n    otherwise, this is the path to platform-specific header files\n    (namely pyconfig.h).\n\n    If 'prefix' is supplied, use it instead of sys.base_prefix or\n    sys.base_exec_prefix -- i.e., ignore 'plat_specific'.\n    \"\"\"\n    default_prefix = BASE_EXEC_PREFIX if plat_specific else BASE_PREFIX\n    resolved_prefix = prefix if prefix is not None else default_prefix\n    # MinGW imitates posix like layout, but os.name != posix\n    os_name = \"posix\" if is_mingw() else os.name\n    try:\n        getter = globals()[f'_get_python_inc_{os_name}']\n    except KeyError:\n        raise DistutilsPlatformError(\n            \"I don't know where Python installs its C header files \"\n            f\"on platform '{os.name}'\"\n        )\n    return getter(resolved_prefix, prefix, plat_specific)\n\n\n@pass_none\ndef _extant(path):\n    \"\"\"\n    Replace path with None if it doesn't exist.\n    \"\"\"\n    return path if os.path.exists(path) else None\n\n\ndef _get_python_inc_posix(prefix, spec_prefix, plat_specific):\n    if IS_PYPY and sys.version_info < (3, 8):\n        return os.path.join(prefix, 'include')\n    return (\n        _get_python_inc_posix_python(plat_specific)\n        or _extant(_get_python_inc_from_config(plat_specific, spec_prefix))\n        or _get_python_inc_posix_prefix(prefix)\n    )\n\n\ndef _get_python_inc_posix_python(plat_specific):\n    \"\"\"\n    Assume the executable is in the build directory. The\n    pyconfig.h file should be in the same directory. Since\n    the build directory may not be the source directory,\n    use \"srcdir\" from the makefile to find the \"Include\"\n    directory.\n    \"\"\"\n    if not python_build:\n        return\n    if plat_specific:\n        return _sys_home or project_base\n    incdir = os.path.join(get_config_var('srcdir'), 'Include')\n    return os.path.normpath(incdir)\n\n\ndef _get_python_inc_from_config(plat_specific, spec_prefix):\n    \"\"\"\n    If no prefix was explicitly specified, provide the include\n    directory from the config vars. Useful when\n    cross-compiling, since the config vars may come from\n    the host\n    platform Python installation, while the current Python\n    executable is from the build platform installation.\n\n    >>> monkeypatch = getfixture('monkeypatch')\n    >>> gpifc = _get_python_inc_from_config\n    >>> monkeypatch.setitem(gpifc.__globals__, 'get_config_var', str.lower)\n    >>> gpifc(False, '/usr/bin/')\n    >>> gpifc(False, '')\n    >>> gpifc(False, None)\n    'includepy'\n    >>> gpifc(True, None)\n    'confincludepy'\n    \"\"\"\n    if spec_prefix is None:\n        return get_config_var('CONF' * plat_specific + 'INCLUDEPY')\n\n\ndef _get_python_inc_posix_prefix(prefix):\n    implementation = 'pypy' if IS_PYPY else 'python'\n    python_dir = implementation + get_python_version() + build_flags\n    return os.path.join(prefix, \"include\", python_dir)\n\n\ndef _get_python_inc_nt(prefix, spec_prefix, plat_specific):\n    if python_build:\n        # Include both include dirs to ensure we can find pyconfig.h\n        return (\n            os.path.join(prefix, \"include\")\n            + os.path.pathsep\n            + os.path.dirname(sysconfig.get_config_h_filename())\n        )\n    return os.path.join(prefix, \"include\")\n\n\n# allow this behavior to be monkey-patched. Ref pypa/distutils#2.\ndef _posix_lib(standard_lib, libpython, early_prefix, prefix):\n    if standard_lib:\n        return libpython\n    else:\n        return os.path.join(libpython, \"site-packages\")\n\n\ndef get_python_lib(plat_specific=False, standard_lib=False, prefix=None):\n    \"\"\"Return the directory containing the Python library (standard or\n    site additions).\n\n    If 'plat_specific' is true, return the directory containing\n    platform-specific modules, i.e. any module from a non-pure-Python\n    module distribution; otherwise, return the platform-shared library\n    directory.  If 'standard_lib' is true, return the directory\n    containing standard Python library modules; otherwise, return the\n    directory for site-specific modules.\n\n    If 'prefix' is supplied, use it instead of sys.base_prefix or\n    sys.base_exec_prefix -- i.e., ignore 'plat_specific'.\n    \"\"\"\n\n    if IS_PYPY and sys.version_info < (3, 8):\n        # PyPy-specific schema\n        if prefix is None:\n            prefix = PREFIX\n        if standard_lib:\n            return os.path.join(prefix, \"lib-python\", sys.version_info.major)\n        return os.path.join(prefix, 'site-packages')\n\n    early_prefix = prefix\n\n    if prefix is None:\n        if standard_lib:\n            prefix = plat_specific and BASE_EXEC_PREFIX or BASE_PREFIX\n        else:\n            prefix = plat_specific and EXEC_PREFIX or PREFIX\n\n    if os.name == \"posix\" or is_mingw():\n        if plat_specific or standard_lib:\n            # Platform-specific modules (any module from a non-pure-Python\n            # module distribution) or standard Python library modules.\n            libdir = getattr(sys, \"platlibdir\", \"lib\")\n        else:\n            # Pure Python\n            libdir = \"lib\"\n        implementation = 'pypy' if IS_PYPY else 'python'\n        libpython = os.path.join(prefix, libdir, implementation + get_python_version())\n        return _posix_lib(standard_lib, libpython, early_prefix, prefix)\n    elif os.name == \"nt\":\n        if standard_lib:\n            return os.path.join(prefix, \"Lib\")\n        else:\n            return os.path.join(prefix, \"Lib\", \"site-packages\")\n    else:\n        raise DistutilsPlatformError(\n            f\"I don't know where Python installs its library on platform '{os.name}'\"\n        )\n\n\n@functools.lru_cache\ndef _customize_macos():\n    \"\"\"\n    Perform first-time customization of compiler-related\n    config vars on macOS. Use after a compiler is known\n    to be needed. This customization exists primarily to support Pythons\n    from binary installers. The kind and paths to build tools on\n    the user system may vary significantly from the system\n    that Python itself was built on.  Also the user OS\n    version and build tools may not support the same set\n    of CPU architectures for universal builds.\n    \"\"\"\n\n    sys.platform == \"darwin\" and __import__('_osx_support').customize_compiler(\n        get_config_vars()\n    )\n\n\ndef customize_compiler(compiler):\n    \"\"\"Do any platform-specific customization of a CCompiler instance.\n\n    Mainly needed on Unix, so we can plug in the information that\n    varies across Unices and is stored in Python's Makefile.\n    \"\"\"\n    if compiler.compiler_type in [\"unix\", \"cygwin\"] or (\n        compiler.compiler_type == \"mingw32\" and is_mingw()\n    ):\n        _customize_macos()\n\n        (\n            cc,\n            cxx,\n            cflags,\n            ccshared,\n            ldshared,\n            ldcxxshared,\n            shlib_suffix,\n            ar,\n            ar_flags,\n        ) = get_config_vars(\n            'CC',\n            'CXX',\n            'CFLAGS',\n            'CCSHARED',\n            'LDSHARED',\n            'LDCXXSHARED',\n            'SHLIB_SUFFIX',\n            'AR',\n            'ARFLAGS',\n        )\n\n        cxxflags = cflags\n\n        if 'CC' in os.environ:\n            newcc = os.environ['CC']\n            if 'LDSHARED' not in os.environ and ldshared.startswith(cc):\n                # If CC is overridden, use that as the default\n                #       command for LDSHARED as well\n                ldshared = newcc + ldshared[len(cc) :]\n            cc = newcc\n        cxx = os.environ.get('CXX', cxx)\n        ldshared = os.environ.get('LDSHARED', ldshared)\n        ldcxxshared = os.environ.get('LDCXXSHARED', ldcxxshared)\n        cpp = os.environ.get(\n            'CPP',\n            cc + \" -E\",  # not always\n        )\n\n        ldshared = _add_flags(ldshared, 'LD')\n        ldcxxshared = _add_flags(ldcxxshared, 'LD')\n        cflags = os.environ.get('CFLAGS', cflags)\n        ldshared = _add_flags(ldshared, 'C')\n        cxxflags = os.environ.get('CXXFLAGS', cxxflags)\n        ldcxxshared = _add_flags(ldcxxshared, 'CXX')\n        cpp = _add_flags(cpp, 'CPP')\n        cflags = _add_flags(cflags, 'CPP')\n        cxxflags = _add_flags(cxxflags, 'CPP')\n        ldshared = _add_flags(ldshared, 'CPP')\n        ldcxxshared = _add_flags(ldcxxshared, 'CPP')\n\n        ar = os.environ.get('AR', ar)\n\n        archiver = ar + ' ' + os.environ.get('ARFLAGS', ar_flags)\n        cc_cmd = cc + ' ' + cflags\n        cxx_cmd = cxx + ' ' + cxxflags\n\n        compiler.set_executables(\n            preprocessor=cpp,\n            compiler=cc_cmd,\n            compiler_so=cc_cmd + ' ' + ccshared,\n            compiler_cxx=cxx_cmd,\n            compiler_so_cxx=cxx_cmd + ' ' + ccshared,\n            linker_so=ldshared,\n            linker_so_cxx=ldcxxshared,\n            linker_exe=cc,\n            linker_exe_cxx=cxx,\n            archiver=archiver,\n        )\n\n        if 'RANLIB' in os.environ and compiler.executables.get('ranlib', None):\n            compiler.set_executables(ranlib=os.environ['RANLIB'])\n\n        compiler.shared_lib_extension = shlib_suffix\n\n\ndef get_config_h_filename():\n    \"\"\"Return full pathname of installed pyconfig.h file.\"\"\"\n    return sysconfig.get_config_h_filename()\n\n\ndef get_makefile_filename():\n    \"\"\"Return full pathname of installed Makefile from the Python build.\"\"\"\n    return sysconfig.get_makefile_filename()\n\n\ndef parse_config_h(fp, g=None):\n    \"\"\"Parse a config.h-style file.\n\n    A dictionary containing name/value pairs is returned.  If an\n    optional dictionary is passed in as the second argument, it is\n    used instead of a new dictionary.\n    \"\"\"\n    return sysconfig.parse_config_h(fp, vars=g)\n\n\n# Regexes needed for parsing Makefile (and similar syntaxes,\n# like old-style Setup files).\n_variable_rx = re.compile(r\"([a-zA-Z][a-zA-Z0-9_]+)\\s*=\\s*(.*)\")\n_findvar1_rx = re.compile(r\"\\$\\(([A-Za-z][A-Za-z0-9_]*)\\)\")\n_findvar2_rx = re.compile(r\"\\${([A-Za-z][A-Za-z0-9_]*)}\")\n\n\ndef parse_makefile(fn, g=None):  # noqa: C901\n    \"\"\"Parse a Makefile-style file.\n\n    A dictionary containing name/value pairs is returned.  If an\n    optional dictionary is passed in as the second argument, it is\n    used instead of a new dictionary.\n    \"\"\"\n    from distutils.text_file import TextFile\n\n    fp = TextFile(\n        fn,\n        strip_comments=True,\n        skip_blanks=True,\n        join_lines=True,\n        errors=\"surrogateescape\",\n    )\n\n    if g is None:\n        g = {}\n    done = {}\n    notdone = {}\n\n    while True:\n        line = fp.readline()\n        if line is None:  # eof\n            break\n        m = _variable_rx.match(line)\n        if m:\n            n, v = m.group(1, 2)\n            v = v.strip()\n            # `$$' is a literal `$' in make\n            tmpv = v.replace('$$', '')\n\n            if \"$\" in tmpv:\n                notdone[n] = v\n            else:\n                try:\n                    v = int(v)\n                except ValueError:\n                    # insert literal `$'\n                    done[n] = v.replace('$$', '$')\n                else:\n                    done[n] = v\n\n    # Variables with a 'PY_' prefix in the makefile. These need to\n    # be made available without that prefix through sysconfig.\n    # Special care is needed to ensure that variable expansion works, even\n    # if the expansion uses the name without a prefix.\n    renamed_variables = ('CFLAGS', 'LDFLAGS', 'CPPFLAGS')\n\n    # do variable interpolation here\n    while notdone:\n        for name in list(notdone):\n            value = notdone[name]\n            m = _findvar1_rx.search(value) or _findvar2_rx.search(value)\n            if m:\n                n = m.group(1)\n                found = True\n                if n in done:\n                    item = str(done[n])\n                elif n in notdone:\n                    # get it on a subsequent round\n                    found = False\n                elif n in os.environ:\n                    # do it like make: fall back to environment\n                    item = os.environ[n]\n\n                elif n in renamed_variables:\n                    if name.startswith('PY_') and name[3:] in renamed_variables:\n                        item = \"\"\n\n                    elif 'PY_' + n in notdone:\n                        found = False\n\n                    else:\n                        item = str(done['PY_' + n])\n                else:\n                    done[n] = item = \"\"\n                if found:\n                    after = value[m.end() :]\n                    value = value[: m.start()] + item + after\n                    if \"$\" in after:\n                        notdone[name] = value\n                    else:\n                        try:\n                            value = int(value)\n                        except ValueError:\n                            done[name] = value.strip()\n                        else:\n                            done[name] = value\n                        del notdone[name]\n\n                        if name.startswith('PY_') and name[3:] in renamed_variables:\n                            name = name[3:]\n                            if name not in done:\n                                done[name] = value\n            else:\n                # bogus variable reference; just drop it since we can't deal\n                del notdone[name]\n\n    fp.close()\n\n    # strip spurious spaces\n    for k, v in done.items():\n        if isinstance(v, str):\n            done[k] = v.strip()\n\n    # save the results in the global dictionary\n    g.update(done)\n    return g\n\n\ndef expand_makefile_vars(s, vars):\n    \"\"\"Expand Makefile-style variables -- \"${foo}\" or \"$(foo)\" -- in\n    'string' according to 'vars' (a dictionary mapping variable names to\n    values).  Variables not present in 'vars' are silently expanded to the\n    empty string.  The variable values in 'vars' should not contain further\n    variable expansions; if 'vars' is the output of 'parse_makefile()',\n    you're fine.  Returns a variable-expanded version of 's'.\n    \"\"\"\n\n    # This algorithm does multiple expansion, so if vars['foo'] contains\n    # \"${bar}\", it will expand ${foo} to ${bar}, and then expand\n    # ${bar}... and so forth.  This is fine as long as 'vars' comes from\n    # 'parse_makefile()', which takes care of such expansions eagerly,\n    # according to make's variable expansion semantics.\n\n    while True:\n        m = _findvar1_rx.search(s) or _findvar2_rx.search(s)\n        if m:\n            (beg, end) = m.span()\n            s = s[0:beg] + vars.get(m.group(1)) + s[end:]\n        else:\n            break\n    return s\n\n\n_config_vars = None\n\n\ndef get_config_vars(*args):\n    \"\"\"With no arguments, return a dictionary of all configuration\n    variables relevant for the current platform.  Generally this includes\n    everything needed to build extensions and install both pure modules and\n    extensions.  On Unix, this means every variable defined in Python's\n    installed Makefile; on Windows it's a much smaller set.\n\n    With arguments, return a list of values that result from looking up\n    each argument in the configuration variable dictionary.\n    \"\"\"\n    global _config_vars\n    if _config_vars is None:\n        _config_vars = sysconfig.get_config_vars().copy()\n        py39.add_ext_suffix(_config_vars)\n\n    return [_config_vars.get(name) for name in args] if args else _config_vars\n\n\ndef get_config_var(name):\n    \"\"\"Return the value of a single variable using the dictionary\n    returned by 'get_config_vars()'.  Equivalent to\n    get_config_vars().get(name)\n    \"\"\"\n    if name == 'SO':\n        import warnings\n\n        warnings.warn('SO is deprecated, use EXT_SUFFIX', DeprecationWarning, 2)\n    return get_config_vars().get(name)\n\n\n@pass_none\ndef _add_flags(value: str, type: str) -> str:\n    \"\"\"\n    Add any flags from the environment for the given type.\n\n    type is the prefix to FLAGS in the environment key (e.g. \"C\" for \"CFLAGS\").\n    \"\"\"\n    flags = os.environ.get(f'{type}FLAGS')\n    return f'{value} {flags}' if flags else value\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/__init__.py","size":1485,"sha1":"1ad511cf2be53588dc01514c28de64f27c066b55","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nTest suite for distutils.\n\nTests for the command classes in the distutils.command package are\nincluded in distutils.tests as well, instead of using a separate\ndistutils.command.tests package, since command identification is done\nby import rather than matching pre-defined names.\n\"\"\"\n\nimport shutil\nfrom collections.abc import Sequence\n\n\ndef missing_compiler_executable(cmd_names: Sequence[str] = []):  # pragma: no cover\n    \"\"\"Check if the compiler components used to build the interpreter exist.\n\n    Check for the existence of the compiler executables whose names are listed\n    in 'cmd_names' or all the compiler executables when 'cmd_names' is empty\n    and return the first missing executable or None when none is found\n    missing.\n\n    \"\"\"\n    from distutils import ccompiler, errors, sysconfig\n\n    compiler = ccompiler.new_compiler()\n    sysconfig.customize_compiler(compiler)\n    if compiler.compiler_type == \"msvc\":\n        # MSVC has no executables, so check whether initialization succeeds\n        try:\n            compiler.initialize()\n        except errors.DistutilsPlatformError:\n            return \"msvc\"\n    for name in compiler.executables:\n        if cmd_names and name not in cmd_names:\n            continue\n        cmd = getattr(compiler, name)\n        if cmd_names:\n            assert cmd is not None, f\"the '{name}' executable is not configured\"\n        elif not cmd:\n            continue\n        if shutil.which(cmd[0]) is None:\n            return cmd[0]\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/compat/__init__.py","size":0,"sha1":"da39a3ee5e6b4b0d3255bfef95601890afd80709","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":""},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/compat/py39.py","size":1026,"sha1":"f73d5fa544b4566f11b2d5c3f7511528da717e81","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\n\nif sys.version_info >= (3, 10):\n    from test.support.import_helper import (\n        CleanImport as CleanImport,\n    )\n    from test.support.import_helper import (\n        DirsOnSysPath as DirsOnSysPath,\n    )\n    from test.support.os_helper import (\n        EnvironmentVarGuard as EnvironmentVarGuard,\n    )\n    from test.support.os_helper import (\n        rmtree as rmtree,\n    )\n    from test.support.os_helper import (\n        skip_unless_symlink as skip_unless_symlink,\n    )\n    from test.support.os_helper import (\n        unlink as unlink,\n    )\nelse:\n    from test.support import (\n        CleanImport as CleanImport,\n    )\n    from test.support import (\n        DirsOnSysPath as DirsOnSysPath,\n    )\n    from test.support import (\n        EnvironmentVarGuard as EnvironmentVarGuard,\n    )\n    from test.support import (\n        rmtree as rmtree,\n    )\n    from test.support import (\n        skip_unless_symlink as skip_unless_symlink,\n    )\n    from test.support import (\n        unlink as unlink,\n    )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/support.py","size":4099,"sha1":"6a40af00a71519dc49e73d3343fcdde552965e5b","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Support code for distutils test cases.\"\"\"\n\nimport itertools\nimport os\nimport pathlib\nimport shutil\nimport sys\nimport sysconfig\nimport tempfile\nfrom distutils.core import Distribution\n\nimport pytest\nfrom more_itertools import always_iterable\n\n\n@pytest.mark.usefixtures('distutils_managed_tempdir')\nclass TempdirManager:\n    \"\"\"\n    Mix-in class that handles temporary directories for test cases.\n    \"\"\"\n\n    def mkdtemp(self):\n        \"\"\"Create a temporary directory that will be cleaned up.\n\n        Returns the path of the directory.\n        \"\"\"\n        d = tempfile.mkdtemp()\n        self.tempdirs.append(d)\n        return d\n\n    def write_file(self, path, content='xxx'):\n        \"\"\"Writes a file in the given path.\n\n        path can be a string or a sequence.\n        \"\"\"\n        pathlib.Path(*always_iterable(path)).write_text(content, encoding='utf-8')\n\n    def create_dist(self, pkg_name='foo', **kw):\n        \"\"\"Will generate a test environment.\n\n        This function creates:\n         - a Distribution instance using keywords\n         - a temporary directory with a package structure\n\n        It returns the package directory and the distribution\n        instance.\n        \"\"\"\n        tmp_dir = self.mkdtemp()\n        pkg_dir = os.path.join(tmp_dir, pkg_name)\n        os.mkdir(pkg_dir)\n        dist = Distribution(attrs=kw)\n\n        return pkg_dir, dist\n\n\nclass DummyCommand:\n    \"\"\"Class to store options for retrieval via set_undefined_options().\"\"\"\n\n    def __init__(self, **kwargs):\n        vars(self).update(kwargs)\n\n    def ensure_finalized(self):\n        pass\n\n\ndef copy_xxmodule_c(directory):\n    \"\"\"Helper for tests that need the xxmodule.c source file.\n\n    Example use:\n\n        def test_compile(self):\n            copy_xxmodule_c(self.tmpdir)\n            self.assertIn('xxmodule.c', os.listdir(self.tmpdir))\n\n    If the source file can be found, it will be copied to *directory*.  If not,\n    the test will be skipped.  Errors during copy are not caught.\n    \"\"\"\n    shutil.copy(_get_xxmodule_path(), os.path.join(directory, 'xxmodule.c'))\n\n\ndef _get_xxmodule_path():\n    source_name = 'xxmodule.c' if sys.version_info > (3, 9) else 'xxmodule-3.8.c'\n    return os.path.join(os.path.dirname(__file__), source_name)\n\n\ndef fixup_build_ext(cmd):\n    \"\"\"Function needed to make build_ext tests pass.\n\n    When Python was built with --enable-shared on Unix, -L. is not enough to\n    find libpython<blah>.so, because regrtest runs in a tempdir, not in the\n    source directory where the .so lives.\n\n    When Python was built with in debug mode on Windows, build_ext commands\n    need their debug attribute set, and it is not done automatically for\n    some reason.\n\n    This function handles both of these things.  Example use:\n\n        cmd = build_ext(dist)\n        support.fixup_build_ext(cmd)\n        cmd.ensure_finalized()\n\n    Unlike most other Unix platforms, Mac OS X embeds absolute paths\n    to shared libraries into executables, so the fixup is not needed there.\n    \"\"\"\n    if os.name == 'nt':\n        cmd.debug = sys.executable.endswith('_d.exe')\n    elif sysconfig.get_config_var('Py_ENABLE_SHARED'):\n        # To further add to the shared builds fun on Unix, we can't just add\n        # library_dirs to the Extension() instance because that doesn't get\n        # plumbed through to the final compiler command.\n        runshared = sysconfig.get_config_var('RUNSHARED')\n        if runshared is None:\n            cmd.library_dirs = ['.']\n        else:\n            if sys.platform == 'darwin':\n                cmd.library_dirs = []\n            else:\n                name, equals, value = runshared.partition('=')\n                cmd.library_dirs = [d for d in value.split(os.pathsep) if d]\n\n\ndef combine_markers(cls):\n    \"\"\"\n    pytest will honor markers as found on the class, but when\n    markers are on multiple subclasses, only one appears. Use\n    this decorator to combine those markers.\n    \"\"\"\n    cls.pytestmark = [\n        mark\n        for base in itertools.chain([cls], cls.__bases__)\n        for mark in getattr(base, 'pytestmark', [])\n    ]\n    return cls\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_archive_util.py","size":11787,"sha1":"224bda165ea55986c772ca7ebab461a475670bfe","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.archive_util.\"\"\"\n\nimport functools\nimport operator\nimport os\nimport pathlib\nimport sys\nimport tarfile\nfrom distutils import archive_util\nfrom distutils.archive_util import (\n    ARCHIVE_FORMATS,\n    check_archive_formats,\n    make_archive,\n    make_tarball,\n    make_zipfile,\n)\nfrom distutils.spawn import spawn\nfrom distutils.tests import support\nfrom os.path import splitdrive\n\nimport path\nimport pytest\nfrom test.support import patch\n\nfrom .unix_compat import UID_0_SUPPORT, grp, pwd, require_uid_0, require_unix_id\n\n\ndef can_fs_encode(filename):\n    \"\"\"\n    Return True if the filename can be saved in the file system.\n    \"\"\"\n    if os.path.supports_unicode_filenames:\n        return True\n    try:\n        filename.encode(sys.getfilesystemencoding())\n    except UnicodeEncodeError:\n        return False\n    return True\n\n\ndef all_equal(values):\n    return functools.reduce(operator.eq, values)\n\n\ndef same_drive(*paths):\n    return all_equal(pathlib.Path(path).drive for path in paths)\n\n\nclass ArchiveUtilTestCase(support.TempdirManager):\n    @pytest.mark.usefixtures('needs_zlib')\n    def test_make_tarball(self, name='archive'):\n        # creating something to tar\n        tmpdir = self._create_files()\n        self._make_tarball(tmpdir, name, '.tar.gz')\n        # trying an uncompressed one\n        self._make_tarball(tmpdir, name, '.tar', compress=None)\n\n    @pytest.mark.usefixtures('needs_zlib')\n    def test_make_tarball_gzip(self):\n        tmpdir = self._create_files()\n        self._make_tarball(tmpdir, 'archive', '.tar.gz', compress='gzip')\n\n    def test_make_tarball_bzip2(self):\n        pytest.importorskip('bz2')\n        tmpdir = self._create_files()\n        self._make_tarball(tmpdir, 'archive', '.tar.bz2', compress='bzip2')\n\n    def test_make_tarball_xz(self):\n        pytest.importorskip('lzma')\n        tmpdir = self._create_files()\n        self._make_tarball(tmpdir, 'archive', '.tar.xz', compress='xz')\n\n    @pytest.mark.skipif(\"not can_fs_encode('årchiv')\")\n    def test_make_tarball_latin1(self):\n        \"\"\"\n        Mirror test_make_tarball, except filename contains latin characters.\n        \"\"\"\n        self.test_make_tarball('årchiv')  # note this isn't a real word\n\n    @pytest.mark.skipif(\"not can_fs_encode('のアーカイブ')\")\n    def test_make_tarball_extended(self):\n        \"\"\"\n        Mirror test_make_tarball, except filename contains extended\n        characters outside the latin charset.\n        \"\"\"\n        self.test_make_tarball('のアーカイブ')  # japanese for archive\n\n    def _make_tarball(self, tmpdir, target_name, suffix, **kwargs):\n        tmpdir2 = self.mkdtemp()\n        if same_drive(tmpdir, tmpdir2):\n            pytest.skip(\"source and target should be on same drive\")\n\n        base_name = os.path.join(tmpdir2, target_name)\n\n        # working with relative paths to avoid tar warnings\n        with path.Path(tmpdir):\n            make_tarball(splitdrive(base_name)[1], 'dist', **kwargs)\n\n        # check if the compressed tarball was created\n        tarball = base_name + suffix\n        assert os.path.exists(tarball)\n        assert self._tarinfo(tarball) == self._created_files\n\n    def _tarinfo(self, path):\n        tar = tarfile.open(path)\n        try:\n            names = tar.getnames()\n            names.sort()\n            return names\n        finally:\n            tar.close()\n\n    _zip_created_files = [\n        'dist/',\n        'dist/file1',\n        'dist/file2',\n        'dist/sub/',\n        'dist/sub/file3',\n        'dist/sub2/',\n    ]\n    _created_files = [p.rstrip('/') for p in _zip_created_files]\n\n    def _create_files(self):\n        # creating something to tar\n        tmpdir = self.mkdtemp()\n        dist = os.path.join(tmpdir, 'dist')\n        os.mkdir(dist)\n        self.write_file([dist, 'file1'], 'xxx')\n        self.write_file([dist, 'file2'], 'xxx')\n        os.mkdir(os.path.join(dist, 'sub'))\n        self.write_file([dist, 'sub', 'file3'], 'xxx')\n        os.mkdir(os.path.join(dist, 'sub2'))\n        return tmpdir\n\n    @pytest.mark.usefixtures('needs_zlib')\n    @pytest.mark.skipif(\"not (shutil.which('tar') and shutil.which('gzip'))\")\n    def test_tarfile_vs_tar(self):\n        tmpdir = self._create_files()\n        tmpdir2 = self.mkdtemp()\n        base_name = os.path.join(tmpdir2, 'archive')\n        old_dir = os.getcwd()\n        os.chdir(tmpdir)\n        try:\n            make_tarball(base_name, 'dist')\n        finally:\n            os.chdir(old_dir)\n\n        # check if the compressed tarball was created\n        tarball = base_name + '.tar.gz'\n        assert os.path.exists(tarball)\n\n        # now create another tarball using `tar`\n        tarball2 = os.path.join(tmpdir, 'archive2.tar.gz')\n        tar_cmd = ['tar', '-cf', 'archive2.tar', 'dist']\n        gzip_cmd = ['gzip', '-f', '-9', 'archive2.tar']\n        old_dir = os.getcwd()\n        os.chdir(tmpdir)\n        try:\n            spawn(tar_cmd)\n            spawn(gzip_cmd)\n        finally:\n            os.chdir(old_dir)\n\n        assert os.path.exists(tarball2)\n        # let's compare both tarballs\n        assert self._tarinfo(tarball) == self._created_files\n        assert self._tarinfo(tarball2) == self._created_files\n\n        # trying an uncompressed one\n        base_name = os.path.join(tmpdir2, 'archive')\n        old_dir = os.getcwd()\n        os.chdir(tmpdir)\n        try:\n            make_tarball(base_name, 'dist', compress=None)\n        finally:\n            os.chdir(old_dir)\n        tarball = base_name + '.tar'\n        assert os.path.exists(tarball)\n\n        # now for a dry_run\n        base_name = os.path.join(tmpdir2, 'archive')\n        old_dir = os.getcwd()\n        os.chdir(tmpdir)\n        try:\n            make_tarball(base_name, 'dist', compress=None, dry_run=True)\n        finally:\n            os.chdir(old_dir)\n        tarball = base_name + '.tar'\n        assert os.path.exists(tarball)\n\n    @pytest.mark.usefixtures('needs_zlib')\n    def test_make_zipfile(self):\n        zipfile = pytest.importorskip('zipfile')\n        # creating something to tar\n        tmpdir = self._create_files()\n        base_name = os.path.join(self.mkdtemp(), 'archive')\n        with path.Path(tmpdir):\n            make_zipfile(base_name, 'dist')\n\n        # check if the compressed tarball was created\n        tarball = base_name + '.zip'\n        assert os.path.exists(tarball)\n        with zipfile.ZipFile(tarball) as zf:\n            assert sorted(zf.namelist()) == self._zip_created_files\n\n    def test_make_zipfile_no_zlib(self):\n        zipfile = pytest.importorskip('zipfile')\n        patch(self, archive_util.zipfile, 'zlib', None)  # force zlib ImportError\n\n        called = []\n        zipfile_class = zipfile.ZipFile\n\n        def fake_zipfile(*a, **kw):\n            if kw.get('compression', None) == zipfile.ZIP_STORED:\n                called.append((a, kw))\n            return zipfile_class(*a, **kw)\n\n        patch(self, archive_util.zipfile, 'ZipFile', fake_zipfile)\n\n        # create something to tar and compress\n        tmpdir = self._create_files()\n        base_name = os.path.join(self.mkdtemp(), 'archive')\n        with path.Path(tmpdir):\n            make_zipfile(base_name, 'dist')\n\n        tarball = base_name + '.zip'\n        assert called == [((tarball, \"w\"), {'compression': zipfile.ZIP_STORED})]\n        assert os.path.exists(tarball)\n        with zipfile.ZipFile(tarball) as zf:\n            assert sorted(zf.namelist()) == self._zip_created_files\n\n    def test_check_archive_formats(self):\n        assert check_archive_formats(['gztar', 'xxx', 'zip']) == 'xxx'\n        assert (\n            check_archive_formats(['gztar', 'bztar', 'xztar', 'ztar', 'tar', 'zip'])\n            is None\n        )\n\n    def test_make_archive(self):\n        tmpdir = self.mkdtemp()\n        base_name = os.path.join(tmpdir, 'archive')\n        with pytest.raises(ValueError):\n            make_archive(base_name, 'xxx')\n\n    def test_make_archive_cwd(self):\n        current_dir = os.getcwd()\n\n        def _breaks(*args, **kw):\n            raise RuntimeError()\n\n        ARCHIVE_FORMATS['xxx'] = (_breaks, [], 'xxx file')\n        try:\n            try:\n                make_archive('xxx', 'xxx', root_dir=self.mkdtemp())\n            except Exception:\n                pass\n            assert os.getcwd() == current_dir\n        finally:\n            ARCHIVE_FORMATS.pop('xxx')\n\n    def test_make_archive_tar(self):\n        base_dir = self._create_files()\n        base_name = os.path.join(self.mkdtemp(), 'archive')\n        res = make_archive(base_name, 'tar', base_dir, 'dist')\n        assert os.path.exists(res)\n        assert os.path.basename(res) == 'archive.tar'\n        assert self._tarinfo(res) == self._created_files\n\n    @pytest.mark.usefixtures('needs_zlib')\n    def test_make_archive_gztar(self):\n        base_dir = self._create_files()\n        base_name = os.path.join(self.mkdtemp(), 'archive')\n        res = make_archive(base_name, 'gztar', base_dir, 'dist')\n        assert os.path.exists(res)\n        assert os.path.basename(res) == 'archive.tar.gz'\n        assert self._tarinfo(res) == self._created_files\n\n    def test_make_archive_bztar(self):\n        pytest.importorskip('bz2')\n        base_dir = self._create_files()\n        base_name = os.path.join(self.mkdtemp(), 'archive')\n        res = make_archive(base_name, 'bztar', base_dir, 'dist')\n        assert os.path.exists(res)\n        assert os.path.basename(res) == 'archive.tar.bz2'\n        assert self._tarinfo(res) == self._created_files\n\n    def test_make_archive_xztar(self):\n        pytest.importorskip('lzma')\n        base_dir = self._create_files()\n        base_name = os.path.join(self.mkdtemp(), 'archive')\n        res = make_archive(base_name, 'xztar', base_dir, 'dist')\n        assert os.path.exists(res)\n        assert os.path.basename(res) == 'archive.tar.xz'\n        assert self._tarinfo(res) == self._created_files\n\n    def test_make_archive_owner_group(self):\n        # testing make_archive with owner and group, with various combinations\n        # this works even if there's not gid/uid support\n        if UID_0_SUPPORT:\n            group = grp.getgrgid(0)[0]\n            owner = pwd.getpwuid(0)[0]\n        else:\n            group = owner = 'root'\n\n        base_dir = self._create_files()\n        root_dir = self.mkdtemp()\n        base_name = os.path.join(self.mkdtemp(), 'archive')\n        res = make_archive(\n            base_name, 'zip', root_dir, base_dir, owner=owner, group=group\n        )\n        assert os.path.exists(res)\n\n        res = make_archive(base_name, 'zip', root_dir, base_dir)\n        assert os.path.exists(res)\n\n        res = make_archive(\n            base_name, 'tar', root_dir, base_dir, owner=owner, group=group\n        )\n        assert os.path.exists(res)\n\n        res = make_archive(\n            base_name, 'tar', root_dir, base_dir, owner='kjhkjhkjg', group='oihohoh'\n        )\n        assert os.path.exists(res)\n\n    @pytest.mark.usefixtures('needs_zlib')\n    @require_unix_id\n    @require_uid_0\n    def test_tarfile_root_owner(self):\n        tmpdir = self._create_files()\n        base_name = os.path.join(self.mkdtemp(), 'archive')\n        old_dir = os.getcwd()\n        os.chdir(tmpdir)\n        group = grp.getgrgid(0)[0]\n        owner = pwd.getpwuid(0)[0]\n        try:\n            archive_name = make_tarball(\n                base_name, 'dist', compress=None, owner=owner, group=group\n            )\n        finally:\n            os.chdir(old_dir)\n\n        # check if the compressed tarball was created\n        assert os.path.exists(archive_name)\n\n        # now checks the rights\n        archive = tarfile.open(archive_name)\n        try:\n            for member in archive.getmembers():\n                assert member.uid == 0\n                assert member.gid == 0\n        finally:\n            archive.close()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_bdist.py","size":1396,"sha1":"29cd817a0a04fe08d62322f4b54033305b3a71a4","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.command.bdist.\"\"\"\n\nfrom distutils.command.bdist import bdist\nfrom distutils.tests import support\n\n\nclass TestBuild(support.TempdirManager):\n    def test_formats(self):\n        # let's create a command and make sure\n        # we can set the format\n        dist = self.create_dist()[1]\n        cmd = bdist(dist)\n        cmd.formats = ['gztar']\n        cmd.ensure_finalized()\n        assert cmd.formats == ['gztar']\n\n        # what formats does bdist offer?\n        formats = [\n            'bztar',\n            'gztar',\n            'rpm',\n            'tar',\n            'xztar',\n            'zip',\n            'ztar',\n        ]\n        found = sorted(cmd.format_commands)\n        assert found == formats\n\n    def test_skip_build(self):\n        # bug #10946: bdist --skip-build should trickle down to subcommands\n        dist = self.create_dist()[1]\n        cmd = bdist(dist)\n        cmd.skip_build = True\n        cmd.ensure_finalized()\n        dist.command_obj['bdist'] = cmd\n\n        names = [\n            'bdist_dumb',\n        ]  # bdist_rpm does not support --skip-build\n\n        for name in names:\n            subcmd = cmd.get_finalized_command(name)\n            if getattr(subcmd, '_unsupported', False):\n                # command is not supported on this build\n                continue\n            assert subcmd.skip_build, f'{name} should take --skip-build from bdist'\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_bdist_dumb.py","size":2247,"sha1":"725f51ffea0612f86f54d1b463dae45e525bfcfb","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.command.bdist_dumb.\"\"\"\n\nimport os\nimport sys\nimport zipfile\nfrom distutils.command.bdist_dumb import bdist_dumb\nfrom distutils.core import Distribution\nfrom distutils.tests import support\n\nimport pytest\n\nSETUP_PY = \"\"\"\\\nfrom distutils.core import setup\nimport foo\n\nsetup(name='foo', version='0.1', py_modules=['foo'],\n      url='xxx', author='xxx', author_email='xxx')\n\n\"\"\"\n\n\n@support.combine_markers\n@pytest.mark.usefixtures('save_env')\n@pytest.mark.usefixtures('save_argv')\n@pytest.mark.usefixtures('save_cwd')\nclass TestBuildDumb(\n    support.TempdirManager,\n):\n    @pytest.mark.usefixtures('needs_zlib')\n    def test_simple_built(self):\n        # let's create a simple package\n        tmp_dir = self.mkdtemp()\n        pkg_dir = os.path.join(tmp_dir, 'foo')\n        os.mkdir(pkg_dir)\n        self.write_file((pkg_dir, 'setup.py'), SETUP_PY)\n        self.write_file((pkg_dir, 'foo.py'), '#')\n        self.write_file((pkg_dir, 'MANIFEST.in'), 'include foo.py')\n        self.write_file((pkg_dir, 'README'), '')\n\n        dist = Distribution({\n            'name': 'foo',\n            'version': '0.1',\n            'py_modules': ['foo'],\n            'url': 'xxx',\n            'author': 'xxx',\n            'author_email': 'xxx',\n        })\n        dist.script_name = 'setup.py'\n        os.chdir(pkg_dir)\n\n        sys.argv = ['setup.py']\n        cmd = bdist_dumb(dist)\n\n        # so the output is the same no matter\n        # what is the platform\n        cmd.format = 'zip'\n\n        cmd.ensure_finalized()\n        cmd.run()\n\n        # see what we have\n        dist_created = os.listdir(os.path.join(pkg_dir, 'dist'))\n        base = f\"{dist.get_fullname()}.{cmd.plat_name}.zip\"\n\n        assert dist_created == [base]\n\n        # now let's check what we have in the zip file\n        fp = zipfile.ZipFile(os.path.join('dist', base))\n        try:\n            contents = fp.namelist()\n        finally:\n            fp.close()\n\n        contents = sorted(filter(None, map(os.path.basename, contents)))\n        wanted = ['foo-0.1-py{}.{}.egg-info'.format(*sys.version_info[:2]), 'foo.py']\n        if not sys.dont_write_bytecode:\n            wanted.append(f'foo.{sys.implementation.cache_tag}.pyc')\n        assert contents == sorted(wanted)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_bdist_rpm.py","size":3932,"sha1":"0e8432519fcc8edc8b77308bfc49f53dee867b2b","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.command.bdist_rpm.\"\"\"\n\nimport os\nimport shutil  # noqa: F401\nimport sys\nfrom distutils.command.bdist_rpm import bdist_rpm\nfrom distutils.core import Distribution\nfrom distutils.tests import support\n\nimport pytest\nfrom test.support import requires_zlib\n\nSETUP_PY = \"\"\"\\\nfrom distutils.core import setup\nimport foo\n\nsetup(name='foo', version='0.1', py_modules=['foo'],\n      url='xxx', author='xxx', author_email='xxx')\n\n\"\"\"\n\n\n@pytest.fixture(autouse=True)\ndef sys_executable_encodable():\n    try:\n        sys.executable.encode('UTF-8')\n    except UnicodeEncodeError:\n        pytest.skip(\"sys.executable is not encodable to UTF-8\")\n\n\nmac_woes = pytest.mark.skipif(\n    \"not sys.platform.startswith('linux')\",\n    reason='spurious sdtout/stderr output under macOS',\n)\n\n\n@pytest.mark.usefixtures('save_env')\n@pytest.mark.usefixtures('save_argv')\n@pytest.mark.usefixtures('save_cwd')\nclass TestBuildRpm(\n    support.TempdirManager,\n):\n    @mac_woes\n    @requires_zlib()\n    @pytest.mark.skipif(\"not shutil.which('rpm')\")\n    @pytest.mark.skipif(\"not shutil.which('rpmbuild')\")\n    def test_quiet(self):\n        # let's create a package\n        tmp_dir = self.mkdtemp()\n        os.environ['HOME'] = tmp_dir  # to confine dir '.rpmdb' creation\n        pkg_dir = os.path.join(tmp_dir, 'foo')\n        os.mkdir(pkg_dir)\n        self.write_file((pkg_dir, 'setup.py'), SETUP_PY)\n        self.write_file((pkg_dir, 'foo.py'), '#')\n        self.write_file((pkg_dir, 'MANIFEST.in'), 'include foo.py')\n        self.write_file((pkg_dir, 'README'), '')\n\n        dist = Distribution({\n            'name': 'foo',\n            'version': '0.1',\n            'py_modules': ['foo'],\n            'url': 'xxx',\n            'author': 'xxx',\n            'author_email': 'xxx',\n        })\n        dist.script_name = 'setup.py'\n        os.chdir(pkg_dir)\n\n        sys.argv = ['setup.py']\n        cmd = bdist_rpm(dist)\n        cmd.fix_python = True\n\n        # running in quiet mode\n        cmd.quiet = True\n        cmd.ensure_finalized()\n        cmd.run()\n\n        dist_created = os.listdir(os.path.join(pkg_dir, 'dist'))\n        assert 'foo-0.1-1.noarch.rpm' in dist_created\n\n        # bug #2945: upload ignores bdist_rpm files\n        assert ('bdist_rpm', 'any', 'dist/foo-0.1-1.src.rpm') in dist.dist_files\n        assert ('bdist_rpm', 'any', 'dist/foo-0.1-1.noarch.rpm') in dist.dist_files\n\n    @mac_woes\n    @requires_zlib()\n    # https://bugs.python.org/issue1533164\n    @pytest.mark.skipif(\"not shutil.which('rpm')\")\n    @pytest.mark.skipif(\"not shutil.which('rpmbuild')\")\n    def test_no_optimize_flag(self):\n        # let's create a package that breaks bdist_rpm\n        tmp_dir = self.mkdtemp()\n        os.environ['HOME'] = tmp_dir  # to confine dir '.rpmdb' creation\n        pkg_dir = os.path.join(tmp_dir, 'foo')\n        os.mkdir(pkg_dir)\n        self.write_file((pkg_dir, 'setup.py'), SETUP_PY)\n        self.write_file((pkg_dir, 'foo.py'), '#')\n        self.write_file((pkg_dir, 'MANIFEST.in'), 'include foo.py')\n        self.write_file((pkg_dir, 'README'), '')\n\n        dist = Distribution({\n            'name': 'foo',\n            'version': '0.1',\n            'py_modules': ['foo'],\n            'url': 'xxx',\n            'author': 'xxx',\n            'author_email': 'xxx',\n        })\n        dist.script_name = 'setup.py'\n        os.chdir(pkg_dir)\n\n        sys.argv = ['setup.py']\n        cmd = bdist_rpm(dist)\n        cmd.fix_python = True\n\n        cmd.quiet = True\n        cmd.ensure_finalized()\n        cmd.run()\n\n        dist_created = os.listdir(os.path.join(pkg_dir, 'dist'))\n        assert 'foo-0.1-1.noarch.rpm' in dist_created\n\n        # bug #2945: upload ignores bdist_rpm files\n        assert ('bdist_rpm', 'any', 'dist/foo-0.1-1.src.rpm') in dist.dist_files\n        assert ('bdist_rpm', 'any', 'dist/foo-0.1-1.noarch.rpm') in dist.dist_files\n\n        os.remove(os.path.join(pkg_dir, 'dist', 'foo-0.1-1.noarch.rpm'))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_build.py","size":1742,"sha1":"9d5b458f621c897a097591ae6f395f55afd58319","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.command.build.\"\"\"\n\nimport os\nimport sys\nfrom distutils.command.build import build\nfrom distutils.tests import support\nfrom sysconfig import get_config_var, get_platform\n\n\nclass TestBuild(support.TempdirManager):\n    def test_finalize_options(self):\n        pkg_dir, dist = self.create_dist()\n        cmd = build(dist)\n        cmd.finalize_options()\n\n        # if not specified, plat_name gets the current platform\n        assert cmd.plat_name == get_platform()\n\n        # build_purelib is build + lib\n        wanted = os.path.join(cmd.build_base, 'lib')\n        assert cmd.build_purelib == wanted\n\n        # build_platlib is 'build/lib.platform-cache_tag[-pydebug]'\n        # examples:\n        #   build/lib.macosx-10.3-i386-cpython39\n        plat_spec = f'.{cmd.plat_name}-{sys.implementation.cache_tag}'\n        if get_config_var('Py_GIL_DISABLED'):\n            plat_spec += 't'\n        if hasattr(sys, 'gettotalrefcount'):\n            assert cmd.build_platlib.endswith('-pydebug')\n            plat_spec += '-pydebug'\n        wanted = os.path.join(cmd.build_base, 'lib' + plat_spec)\n        assert cmd.build_platlib == wanted\n\n        # by default, build_lib = build_purelib\n        assert cmd.build_lib == cmd.build_purelib\n\n        # build_temp is build/temp.<plat>\n        wanted = os.path.join(cmd.build_base, 'temp' + plat_spec)\n        assert cmd.build_temp == wanted\n\n        # build_scripts is build/scripts-x.x\n        wanted = os.path.join(\n            cmd.build_base, f'scripts-{sys.version_info.major}.{sys.version_info.minor}'\n        )\n        assert cmd.build_scripts == wanted\n\n        # executable is os.path.normpath(sys.executable)\n        assert cmd.executable == os.path.normpath(sys.executable)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_build_clib.py","size":4331,"sha1":"3bc53a1a2190d22beb38ac6c568bdaf547c762c3","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.command.build_clib.\"\"\"\n\nimport os\nfrom distutils.command.build_clib import build_clib\nfrom distutils.errors import DistutilsSetupError\nfrom distutils.tests import missing_compiler_executable, support\n\nimport pytest\n\n\nclass TestBuildCLib(support.TempdirManager):\n    def test_check_library_dist(self):\n        pkg_dir, dist = self.create_dist()\n        cmd = build_clib(dist)\n\n        # 'libraries' option must be a list\n        with pytest.raises(DistutilsSetupError):\n            cmd.check_library_list('foo')\n\n        # each element of 'libraries' must a 2-tuple\n        with pytest.raises(DistutilsSetupError):\n            cmd.check_library_list(['foo1', 'foo2'])\n\n        # first element of each tuple in 'libraries'\n        # must be a string (the library name)\n        with pytest.raises(DistutilsSetupError):\n            cmd.check_library_list([(1, 'foo1'), ('name', 'foo2')])\n\n        # library name may not contain directory separators\n        with pytest.raises(DistutilsSetupError):\n            cmd.check_library_list(\n                [('name', 'foo1'), ('another/name', 'foo2')],\n            )\n\n        # second element of each tuple must be a dictionary (build info)\n        with pytest.raises(DistutilsSetupError):\n            cmd.check_library_list(\n                [('name', {}), ('another', 'foo2')],\n            )\n\n        # those work\n        libs = [('name', {}), ('name', {'ok': 'good'})]\n        cmd.check_library_list(libs)\n\n    def test_get_source_files(self):\n        pkg_dir, dist = self.create_dist()\n        cmd = build_clib(dist)\n\n        # \"in 'libraries' option 'sources' must be present and must be\n        # a list of source filenames\n        cmd.libraries = [('name', {})]\n        with pytest.raises(DistutilsSetupError):\n            cmd.get_source_files()\n\n        cmd.libraries = [('name', {'sources': 1})]\n        with pytest.raises(DistutilsSetupError):\n            cmd.get_source_files()\n\n        cmd.libraries = [('name', {'sources': ['a', 'b']})]\n        assert cmd.get_source_files() == ['a', 'b']\n\n        cmd.libraries = [('name', {'sources': ('a', 'b')})]\n        assert cmd.get_source_files() == ['a', 'b']\n\n        cmd.libraries = [\n            ('name', {'sources': ('a', 'b')}),\n            ('name2', {'sources': ['c', 'd']}),\n        ]\n        assert cmd.get_source_files() == ['a', 'b', 'c', 'd']\n\n    def test_build_libraries(self):\n        pkg_dir, dist = self.create_dist()\n        cmd = build_clib(dist)\n\n        class FakeCompiler:\n            def compile(*args, **kw):\n                pass\n\n            create_static_lib = compile\n\n        cmd.compiler = FakeCompiler()\n\n        # build_libraries is also doing a bit of typo checking\n        lib = [('name', {'sources': 'notvalid'})]\n        with pytest.raises(DistutilsSetupError):\n            cmd.build_libraries(lib)\n\n        lib = [('name', {'sources': list()})]\n        cmd.build_libraries(lib)\n\n        lib = [('name', {'sources': tuple()})]\n        cmd.build_libraries(lib)\n\n    def test_finalize_options(self):\n        pkg_dir, dist = self.create_dist()\n        cmd = build_clib(dist)\n\n        cmd.include_dirs = 'one-dir'\n        cmd.finalize_options()\n        assert cmd.include_dirs == ['one-dir']\n\n        cmd.include_dirs = None\n        cmd.finalize_options()\n        assert cmd.include_dirs == []\n\n        cmd.distribution.libraries = 'WONTWORK'\n        with pytest.raises(DistutilsSetupError):\n            cmd.finalize_options()\n\n    @pytest.mark.skipif('platform.system() == \"Windows\"')\n    def test_run(self):\n        pkg_dir, dist = self.create_dist()\n        cmd = build_clib(dist)\n\n        foo_c = os.path.join(pkg_dir, 'foo.c')\n        self.write_file(foo_c, 'int main(void) { return 1;}\\n')\n        cmd.libraries = [('foo', {'sources': [foo_c]})]\n\n        build_temp = os.path.join(pkg_dir, 'build')\n        os.mkdir(build_temp)\n        cmd.build_temp = build_temp\n        cmd.build_clib = build_temp\n\n        # Before we run the command, we want to make sure\n        # all commands are present on the system.\n        ccmd = missing_compiler_executable()\n        if ccmd is not None:\n            self.skipTest(f'The {ccmd!r} command is not found')\n\n        # this should work\n        cmd.run()\n\n        # let's check the result\n        assert 'libfoo.a' in os.listdir(build_temp)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_build_ext.py","size":19954,"sha1":"efd7bb2259ad76d4d2be48fa5cbcac0c66e2708a","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import contextlib\nimport importlib\nimport os\nimport platform\nimport re\nimport shutil\nimport site\nimport sys\nimport tempfile\nimport textwrap\nfrom distutils import sysconfig\nfrom distutils.command.build_ext import build_ext\nfrom distutils.core import Distribution\nfrom distutils.errors import (\n    CompileError,\n    DistutilsPlatformError,\n    DistutilsSetupError,\n    UnknownFileError,\n)\nfrom distutils.extension import Extension\nfrom distutils.tests import missing_compiler_executable\nfrom distutils.tests.support import TempdirManager, copy_xxmodule_c, fixup_build_ext\nfrom io import StringIO\n\nimport jaraco.path\nimport path\nimport pytest\nfrom test import support\n\nfrom .compat import py39 as import_helper\n\n\n@pytest.fixture()\ndef user_site_dir(request):\n    self = request.instance\n    self.tmp_dir = self.mkdtemp()\n    self.tmp_path = path.Path(self.tmp_dir)\n    from distutils.command import build_ext\n\n    orig_user_base = site.USER_BASE\n\n    site.USER_BASE = self.mkdtemp()\n    build_ext.USER_BASE = site.USER_BASE\n\n    # bpo-30132: On Windows, a .pdb file may be created in the current\n    # working directory. Create a temporary working directory to cleanup\n    # everything at the end of the test.\n    with self.tmp_path:\n        yield\n\n    site.USER_BASE = orig_user_base\n    build_ext.USER_BASE = orig_user_base\n\n\n@contextlib.contextmanager\ndef safe_extension_import(name, path):\n    with import_helper.CleanImport(name):\n        with extension_redirect(name, path) as new_path:\n            with import_helper.DirsOnSysPath(new_path):\n                yield\n\n\n@contextlib.contextmanager\ndef extension_redirect(mod, path):\n    \"\"\"\n    Tests will fail to tear down an extension module if it's been imported.\n\n    Before importing, copy the file to a temporary directory that won't\n    be cleaned up. Yield the new path.\n    \"\"\"\n    if platform.system() != \"Windows\" and sys.platform != \"cygwin\":\n        yield path\n        return\n    with import_helper.DirsOnSysPath(path):\n        spec = importlib.util.find_spec(mod)\n    filename = os.path.basename(spec.origin)\n    trash_dir = tempfile.mkdtemp(prefix='deleteme')\n    dest = os.path.join(trash_dir, os.path.basename(filename))\n    shutil.copy(spec.origin, dest)\n    yield trash_dir\n    # TODO: can the file be scheduled for deletion?\n\n\n@pytest.mark.usefixtures('user_site_dir')\nclass TestBuildExt(TempdirManager):\n    def build_ext(self, *args, **kwargs):\n        return build_ext(*args, **kwargs)\n\n    def test_build_ext(self):\n        missing_compiler_executable()\n        copy_xxmodule_c(self.tmp_dir)\n        xx_c = os.path.join(self.tmp_dir, 'xxmodule.c')\n        xx_ext = Extension('xx', [xx_c])\n        dist = Distribution({'name': 'xx', 'ext_modules': [xx_ext]})\n        dist.package_dir = self.tmp_dir\n        cmd = self.build_ext(dist)\n        fixup_build_ext(cmd)\n        cmd.build_lib = self.tmp_dir\n        cmd.build_temp = self.tmp_dir\n\n        old_stdout = sys.stdout\n        if not support.verbose:\n            # silence compiler output\n            sys.stdout = StringIO()\n        try:\n            cmd.ensure_finalized()\n            cmd.run()\n        finally:\n            sys.stdout = old_stdout\n\n        with safe_extension_import('xx', self.tmp_dir):\n            self._test_xx()\n\n    @staticmethod\n    def _test_xx():\n        import xx\n\n        for attr in ('error', 'foo', 'new', 'roj'):\n            assert hasattr(xx, attr)\n\n        assert xx.foo(2, 5) == 7\n        assert xx.foo(13, 15) == 28\n        assert xx.new().demo() is None\n        if support.HAVE_DOCSTRINGS:\n            doc = 'This is a template module just for instruction.'\n            assert xx.__doc__ == doc\n        assert isinstance(xx.Null(), xx.Null)\n        assert isinstance(xx.Str(), xx.Str)\n\n    def test_solaris_enable_shared(self):\n        dist = Distribution({'name': 'xx'})\n        cmd = self.build_ext(dist)\n        old = sys.platform\n\n        sys.platform = 'sunos'  # fooling finalize_options\n        from distutils.sysconfig import _config_vars\n\n        old_var = _config_vars.get('Py_ENABLE_SHARED')\n        _config_vars['Py_ENABLE_SHARED'] = True\n        try:\n            cmd.ensure_finalized()\n        finally:\n            sys.platform = old\n            if old_var is None:\n                del _config_vars['Py_ENABLE_SHARED']\n            else:\n                _config_vars['Py_ENABLE_SHARED'] = old_var\n\n        # make sure we get some library dirs under solaris\n        assert len(cmd.library_dirs) > 0\n\n    def test_user_site(self):\n        import site\n\n        dist = Distribution({'name': 'xx'})\n        cmd = self.build_ext(dist)\n\n        # making sure the user option is there\n        options = [name for name, short, label in cmd.user_options]\n        assert 'user' in options\n\n        # setting a value\n        cmd.user = True\n\n        # setting user based lib and include\n        lib = os.path.join(site.USER_BASE, 'lib')\n        incl = os.path.join(site.USER_BASE, 'include')\n        os.mkdir(lib)\n        os.mkdir(incl)\n\n        # let's run finalize\n        cmd.ensure_finalized()\n\n        # see if include_dirs and library_dirs\n        # were set\n        assert lib in cmd.library_dirs\n        assert lib in cmd.rpath\n        assert incl in cmd.include_dirs\n\n    def test_optional_extension(self):\n        # this extension will fail, but let's ignore this failure\n        # with the optional argument.\n        modules = [Extension('foo', ['xxx'], optional=False)]\n        dist = Distribution({'name': 'xx', 'ext_modules': modules})\n        cmd = self.build_ext(dist)\n        cmd.ensure_finalized()\n        with pytest.raises((UnknownFileError, CompileError)):\n            cmd.run()  # should raise an error\n\n        modules = [Extension('foo', ['xxx'], optional=True)]\n        dist = Distribution({'name': 'xx', 'ext_modules': modules})\n        cmd = self.build_ext(dist)\n        cmd.ensure_finalized()\n        cmd.run()  # should pass\n\n    def test_finalize_options(self):\n        # Make sure Python's include directories (for Python.h, pyconfig.h,\n        # etc.) are in the include search path.\n        modules = [Extension('foo', ['xxx'], optional=False)]\n        dist = Distribution({'name': 'xx', 'ext_modules': modules})\n        cmd = self.build_ext(dist)\n        cmd.finalize_options()\n\n        py_include = sysconfig.get_python_inc()\n        for p in py_include.split(os.path.pathsep):\n            assert p in cmd.include_dirs\n\n        plat_py_include = sysconfig.get_python_inc(plat_specific=True)\n        for p in plat_py_include.split(os.path.pathsep):\n            assert p in cmd.include_dirs\n\n        # make sure cmd.libraries is turned into a list\n        # if it's a string\n        cmd = self.build_ext(dist)\n        cmd.libraries = 'my_lib, other_lib lastlib'\n        cmd.finalize_options()\n        assert cmd.libraries == ['my_lib', 'other_lib', 'lastlib']\n\n        # make sure cmd.library_dirs is turned into a list\n        # if it's a string\n        cmd = self.build_ext(dist)\n        cmd.library_dirs = f'my_lib_dir{os.pathsep}other_lib_dir'\n        cmd.finalize_options()\n        assert 'my_lib_dir' in cmd.library_dirs\n        assert 'other_lib_dir' in cmd.library_dirs\n\n        # make sure rpath is turned into a list\n        # if it's a string\n        cmd = self.build_ext(dist)\n        cmd.rpath = f'one{os.pathsep}two'\n        cmd.finalize_options()\n        assert cmd.rpath == ['one', 'two']\n\n        # make sure cmd.link_objects is turned into a list\n        # if it's a string\n        cmd = build_ext(dist)\n        cmd.link_objects = 'one two,three'\n        cmd.finalize_options()\n        assert cmd.link_objects == ['one', 'two', 'three']\n\n        # XXX more tests to perform for win32\n\n        # make sure define is turned into 2-tuples\n        # strings if they are ','-separated strings\n        cmd = self.build_ext(dist)\n        cmd.define = 'one,two'\n        cmd.finalize_options()\n        assert cmd.define == [('one', '1'), ('two', '1')]\n\n        # make sure undef is turned into a list of\n        # strings if they are ','-separated strings\n        cmd = self.build_ext(dist)\n        cmd.undef = 'one,two'\n        cmd.finalize_options()\n        assert cmd.undef == ['one', 'two']\n\n        # make sure swig_opts is turned into a list\n        cmd = self.build_ext(dist)\n        cmd.swig_opts = None\n        cmd.finalize_options()\n        assert cmd.swig_opts == []\n\n        cmd = self.build_ext(dist)\n        cmd.swig_opts = '1 2'\n        cmd.finalize_options()\n        assert cmd.swig_opts == ['1', '2']\n\n    def test_check_extensions_list(self):\n        dist = Distribution()\n        cmd = self.build_ext(dist)\n        cmd.finalize_options()\n\n        # 'extensions' option must be a list of Extension instances\n        with pytest.raises(DistutilsSetupError):\n            cmd.check_extensions_list('foo')\n\n        # each element of 'ext_modules' option must be an\n        # Extension instance or 2-tuple\n        exts = [('bar', 'foo', 'bar'), 'foo']\n        with pytest.raises(DistutilsSetupError):\n            cmd.check_extensions_list(exts)\n\n        # first element of each tuple in 'ext_modules'\n        # must be the extension name (a string) and match\n        # a python dotted-separated name\n        exts = [('foo-bar', '')]\n        with pytest.raises(DistutilsSetupError):\n            cmd.check_extensions_list(exts)\n\n        # second element of each tuple in 'ext_modules'\n        # must be a dictionary (build info)\n        exts = [('foo.bar', '')]\n        with pytest.raises(DistutilsSetupError):\n            cmd.check_extensions_list(exts)\n\n        # ok this one should pass\n        exts = [('foo.bar', {'sources': [''], 'libraries': 'foo', 'some': 'bar'})]\n        cmd.check_extensions_list(exts)\n        ext = exts[0]\n        assert isinstance(ext, Extension)\n\n        # check_extensions_list adds in ext the values passed\n        # when they are in ('include_dirs', 'library_dirs', 'libraries'\n        # 'extra_objects', 'extra_compile_args', 'extra_link_args')\n        assert ext.libraries == 'foo'\n        assert not hasattr(ext, 'some')\n\n        # 'macros' element of build info dict must be 1- or 2-tuple\n        exts = [\n            (\n                'foo.bar',\n                {\n                    'sources': [''],\n                    'libraries': 'foo',\n                    'some': 'bar',\n                    'macros': [('1', '2', '3'), 'foo'],\n                },\n            )\n        ]\n        with pytest.raises(DistutilsSetupError):\n            cmd.check_extensions_list(exts)\n\n        exts[0][1]['macros'] = [('1', '2'), ('3',)]\n        cmd.check_extensions_list(exts)\n        assert exts[0].undef_macros == ['3']\n        assert exts[0].define_macros == [('1', '2')]\n\n    def test_get_source_files(self):\n        modules = [Extension('foo', ['xxx'], optional=False)]\n        dist = Distribution({'name': 'xx', 'ext_modules': modules})\n        cmd = self.build_ext(dist)\n        cmd.ensure_finalized()\n        assert cmd.get_source_files() == ['xxx']\n\n    def test_unicode_module_names(self):\n        modules = [\n            Extension('foo', ['aaa'], optional=False),\n            Extension('föö', ['uuu'], optional=False),\n        ]\n        dist = Distribution({'name': 'xx', 'ext_modules': modules})\n        cmd = self.build_ext(dist)\n        cmd.ensure_finalized()\n        assert re.search(r'foo(_d)?\\..*', cmd.get_ext_filename(modules[0].name))\n        assert re.search(r'föö(_d)?\\..*', cmd.get_ext_filename(modules[1].name))\n        assert cmd.get_export_symbols(modules[0]) == ['PyInit_foo']\n        assert cmd.get_export_symbols(modules[1]) == ['PyInitU_f_1gaa']\n\n    def test_compiler_option(self):\n        # cmd.compiler is an option and\n        # should not be overridden by a compiler instance\n        # when the command is run\n        dist = Distribution()\n        cmd = self.build_ext(dist)\n        cmd.compiler = 'unix'\n        cmd.ensure_finalized()\n        cmd.run()\n        assert cmd.compiler == 'unix'\n\n    def test_get_outputs(self):\n        missing_compiler_executable()\n        tmp_dir = self.mkdtemp()\n        c_file = os.path.join(tmp_dir, 'foo.c')\n        self.write_file(c_file, 'void PyInit_foo(void) {}\\n')\n        ext = Extension('foo', [c_file], optional=False)\n        dist = Distribution({'name': 'xx', 'ext_modules': [ext]})\n        cmd = self.build_ext(dist)\n        fixup_build_ext(cmd)\n        cmd.ensure_finalized()\n        assert len(cmd.get_outputs()) == 1\n\n        cmd.build_lib = os.path.join(self.tmp_dir, 'build')\n        cmd.build_temp = os.path.join(self.tmp_dir, 'tempt')\n\n        # issue #5977 : distutils build_ext.get_outputs\n        # returns wrong result with --inplace\n        other_tmp_dir = os.path.realpath(self.mkdtemp())\n        old_wd = os.getcwd()\n        os.chdir(other_tmp_dir)\n        try:\n            cmd.inplace = True\n            cmd.run()\n            so_file = cmd.get_outputs()[0]\n        finally:\n            os.chdir(old_wd)\n        assert os.path.exists(so_file)\n        ext_suffix = sysconfig.get_config_var('EXT_SUFFIX')\n        assert so_file.endswith(ext_suffix)\n        so_dir = os.path.dirname(so_file)\n        assert so_dir == other_tmp_dir\n\n        cmd.inplace = False\n        cmd.compiler = None\n        cmd.run()\n        so_file = cmd.get_outputs()[0]\n        assert os.path.exists(so_file)\n        assert so_file.endswith(ext_suffix)\n        so_dir = os.path.dirname(so_file)\n        assert so_dir == cmd.build_lib\n\n        # inplace = False, cmd.package = 'bar'\n        build_py = cmd.get_finalized_command('build_py')\n        build_py.package_dir = {'': 'bar'}\n        path = cmd.get_ext_fullpath('foo')\n        # checking that the last directory is the build_dir\n        path = os.path.split(path)[0]\n        assert path == cmd.build_lib\n\n        # inplace = True, cmd.package = 'bar'\n        cmd.inplace = True\n        other_tmp_dir = os.path.realpath(self.mkdtemp())\n        old_wd = os.getcwd()\n        os.chdir(other_tmp_dir)\n        try:\n            path = cmd.get_ext_fullpath('foo')\n        finally:\n            os.chdir(old_wd)\n        # checking that the last directory is bar\n        path = os.path.split(path)[0]\n        lastdir = os.path.split(path)[-1]\n        assert lastdir == 'bar'\n\n    def test_ext_fullpath(self):\n        ext = sysconfig.get_config_var('EXT_SUFFIX')\n        # building lxml.etree inplace\n        # etree_c = os.path.join(self.tmp_dir, 'lxml.etree.c')\n        # etree_ext = Extension('lxml.etree', [etree_c])\n        # dist = Distribution({'name': 'lxml', 'ext_modules': [etree_ext]})\n        dist = Distribution()\n        cmd = self.build_ext(dist)\n        cmd.inplace = True\n        cmd.distribution.package_dir = {'': 'src'}\n        cmd.distribution.packages = ['lxml', 'lxml.html']\n        curdir = os.getcwd()\n        wanted = os.path.join(curdir, 'src', 'lxml', 'etree' + ext)\n        path = cmd.get_ext_fullpath('lxml.etree')\n        assert wanted == path\n\n        # building lxml.etree not inplace\n        cmd.inplace = False\n        cmd.build_lib = os.path.join(curdir, 'tmpdir')\n        wanted = os.path.join(curdir, 'tmpdir', 'lxml', 'etree' + ext)\n        path = cmd.get_ext_fullpath('lxml.etree')\n        assert wanted == path\n\n        # building twisted.runner.portmap not inplace\n        build_py = cmd.get_finalized_command('build_py')\n        build_py.package_dir = {}\n        cmd.distribution.packages = ['twisted', 'twisted.runner.portmap']\n        path = cmd.get_ext_fullpath('twisted.runner.portmap')\n        wanted = os.path.join(curdir, 'tmpdir', 'twisted', 'runner', 'portmap' + ext)\n        assert wanted == path\n\n        # building twisted.runner.portmap inplace\n        cmd.inplace = True\n        path = cmd.get_ext_fullpath('twisted.runner.portmap')\n        wanted = os.path.join(curdir, 'twisted', 'runner', 'portmap' + ext)\n        assert wanted == path\n\n    @pytest.mark.skipif('platform.system() != \"Darwin\"')\n    @pytest.mark.usefixtures('save_env')\n    def test_deployment_target_default(self):\n        # Issue 9516: Test that, in the absence of the environment variable,\n        # an extension module is compiled with the same deployment target as\n        #  the interpreter.\n        self._try_compile_deployment_target('==', None)\n\n    @pytest.mark.skipif('platform.system() != \"Darwin\"')\n    @pytest.mark.usefixtures('save_env')\n    def test_deployment_target_too_low(self):\n        # Issue 9516: Test that an extension module is not allowed to be\n        # compiled with a deployment target less than that of the interpreter.\n        with pytest.raises(DistutilsPlatformError):\n            self._try_compile_deployment_target('>', '10.1')\n\n    @pytest.mark.skipif('platform.system() != \"Darwin\"')\n    @pytest.mark.usefixtures('save_env')\n    def test_deployment_target_higher_ok(self):  # pragma: no cover\n        # Issue 9516: Test that an extension module can be compiled with a\n        # deployment target higher than that of the interpreter: the ext\n        # module may depend on some newer OS feature.\n        deptarget = sysconfig.get_config_var('MACOSX_DEPLOYMENT_TARGET')\n        if deptarget:\n            # increment the minor version number (i.e. 10.6 -> 10.7)\n            deptarget = [int(x) for x in deptarget.split('.')]\n            deptarget[-1] += 1\n            deptarget = '.'.join(str(i) for i in deptarget)\n            self._try_compile_deployment_target('<', deptarget)\n\n    def _try_compile_deployment_target(self, operator, target):  # pragma: no cover\n        if target is None:\n            if os.environ.get('MACOSX_DEPLOYMENT_TARGET'):\n                del os.environ['MACOSX_DEPLOYMENT_TARGET']\n        else:\n            os.environ['MACOSX_DEPLOYMENT_TARGET'] = target\n\n        jaraco.path.build(\n            {\n                'deptargetmodule.c': textwrap.dedent(f\"\"\"\\\n                    #include <AvailabilityMacros.h>\n\n                    int dummy;\n\n                    #if TARGET {operator} MAC_OS_X_VERSION_MIN_REQUIRED\n                    #else\n                    #error \"Unexpected target\"\n                    #endif\n\n                    \"\"\"),\n            },\n            self.tmp_path,\n        )\n\n        # get the deployment target that the interpreter was built with\n        target = sysconfig.get_config_var('MACOSX_DEPLOYMENT_TARGET')\n        target = tuple(map(int, target.split('.')[0:2]))\n        # format the target value as defined in the Apple\n        # Availability Macros.  We can't use the macro names since\n        # at least one value we test with will not exist yet.\n        if target[:2] < (10, 10):\n            # for 10.1 through 10.9.x -> \"10n0\"\n            tmpl = '{:02}{:01}0'\n        else:\n            # for 10.10 and beyond -> \"10nn00\"\n            if len(target) >= 2:\n                tmpl = '{:02}{:02}00'\n            else:\n                # 11 and later can have no minor version (11 instead of 11.0)\n                tmpl = '{:02}0000'\n        target = tmpl.format(*target)\n        deptarget_ext = Extension(\n            'deptarget',\n            [self.tmp_path / 'deptargetmodule.c'],\n            extra_compile_args=[f'-DTARGET={target}'],\n        )\n        dist = Distribution({'name': 'deptarget', 'ext_modules': [deptarget_ext]})\n        dist.package_dir = self.tmp_dir\n        cmd = self.build_ext(dist)\n        cmd.build_lib = self.tmp_dir\n        cmd.build_temp = self.tmp_dir\n\n        try:\n            old_stdout = sys.stdout\n            if not support.verbose:\n                # silence compiler output\n                sys.stdout = StringIO()\n            try:\n                cmd.ensure_finalized()\n                cmd.run()\n            finally:\n                sys.stdout = old_stdout\n\n        except CompileError:\n            self.fail(\"Wrong deployment target during compilation\")\n\n\nclass TestParallelBuildExt(TestBuildExt):\n    def build_ext(self, *args, **kwargs):\n        build_ext = super().build_ext(*args, **kwargs)\n        build_ext.parallel = True\n        return build_ext\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_build_py.py","size":6882,"sha1":"19259455cc83bce0f925fd2f346348a2a5c2e30e","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.command.build_py.\"\"\"\n\nimport os\nimport sys\nfrom distutils.command.build_py import build_py\nfrom distutils.core import Distribution\nfrom distutils.errors import DistutilsFileError\nfrom distutils.tests import support\n\nimport jaraco.path\nimport pytest\n\n\n@support.combine_markers\nclass TestBuildPy(support.TempdirManager):\n    def test_package_data(self):\n        sources = self.mkdtemp()\n        jaraco.path.build(\n            {\n                '__init__.py': \"# Pretend this is a package.\",\n                'README.txt': 'Info about this package',\n            },\n            sources,\n        )\n\n        destination = self.mkdtemp()\n\n        dist = Distribution({\"packages\": [\"pkg\"], \"package_dir\": {\"pkg\": sources}})\n        # script_name need not exist, it just need to be initialized\n        dist.script_name = os.path.join(sources, \"setup.py\")\n        dist.command_obj[\"build\"] = support.DummyCommand(\n            force=False, build_lib=destination\n        )\n        dist.packages = [\"pkg\"]\n        dist.package_data = {\"pkg\": [\"README.txt\"]}\n        dist.package_dir = {\"pkg\": sources}\n\n        cmd = build_py(dist)\n        cmd.compile = True\n        cmd.ensure_finalized()\n        assert cmd.package_data == dist.package_data\n\n        cmd.run()\n\n        # This makes sure the list of outputs includes byte-compiled\n        # files for Python modules but not for package data files\n        # (there shouldn't *be* byte-code files for those!).\n        assert len(cmd.get_outputs()) == 3\n        pkgdest = os.path.join(destination, \"pkg\")\n        files = os.listdir(pkgdest)\n        pycache_dir = os.path.join(pkgdest, \"__pycache__\")\n        assert \"__init__.py\" in files\n        assert \"README.txt\" in files\n        if sys.dont_write_bytecode:\n            assert not os.path.exists(pycache_dir)\n        else:\n            pyc_files = os.listdir(pycache_dir)\n            assert f\"__init__.{sys.implementation.cache_tag}.pyc\" in pyc_files\n\n    def test_empty_package_dir(self):\n        # See bugs #1668596/#1720897\n        sources = self.mkdtemp()\n        jaraco.path.build({'__init__.py': '', 'doc': {'testfile': ''}}, sources)\n\n        os.chdir(sources)\n        dist = Distribution({\n            \"packages\": [\"pkg\"],\n            \"package_dir\": {\"pkg\": \"\"},\n            \"package_data\": {\"pkg\": [\"doc/*\"]},\n        })\n        # script_name need not exist, it just need to be initialized\n        dist.script_name = os.path.join(sources, \"setup.py\")\n        dist.script_args = [\"build\"]\n        dist.parse_command_line()\n\n        try:\n            dist.run_commands()\n        except DistutilsFileError:\n            self.fail(\"failed package_data test when package_dir is ''\")\n\n    @pytest.mark.skipif('sys.dont_write_bytecode')\n    def test_byte_compile(self):\n        project_dir, dist = self.create_dist(py_modules=['boiledeggs'])\n        os.chdir(project_dir)\n        self.write_file('boiledeggs.py', 'import antigravity')\n        cmd = build_py(dist)\n        cmd.compile = True\n        cmd.build_lib = 'here'\n        cmd.finalize_options()\n        cmd.run()\n\n        found = os.listdir(cmd.build_lib)\n        assert sorted(found) == ['__pycache__', 'boiledeggs.py']\n        found = os.listdir(os.path.join(cmd.build_lib, '__pycache__'))\n        assert found == [f'boiledeggs.{sys.implementation.cache_tag}.pyc']\n\n    @pytest.mark.skipif('sys.dont_write_bytecode')\n    def test_byte_compile_optimized(self):\n        project_dir, dist = self.create_dist(py_modules=['boiledeggs'])\n        os.chdir(project_dir)\n        self.write_file('boiledeggs.py', 'import antigravity')\n        cmd = build_py(dist)\n        cmd.compile = False\n        cmd.optimize = 1\n        cmd.build_lib = 'here'\n        cmd.finalize_options()\n        cmd.run()\n\n        found = os.listdir(cmd.build_lib)\n        assert sorted(found) == ['__pycache__', 'boiledeggs.py']\n        found = os.listdir(os.path.join(cmd.build_lib, '__pycache__'))\n        expect = f'boiledeggs.{sys.implementation.cache_tag}.opt-1.pyc'\n        assert sorted(found) == [expect]\n\n    def test_dir_in_package_data(self):\n        \"\"\"\n        A directory in package_data should not be added to the filelist.\n        \"\"\"\n        # See bug 19286\n        sources = self.mkdtemp()\n        jaraco.path.build(\n            {\n                'pkg': {\n                    '__init__.py': '',\n                    'doc': {\n                        'testfile': '',\n                        # create a directory that could be incorrectly detected as a file\n                        'otherdir': {},\n                    },\n                }\n            },\n            sources,\n        )\n\n        os.chdir(sources)\n        dist = Distribution({\"packages\": [\"pkg\"], \"package_data\": {\"pkg\": [\"doc/*\"]}})\n        # script_name need not exist, it just need to be initialized\n        dist.script_name = os.path.join(sources, \"setup.py\")\n        dist.script_args = [\"build\"]\n        dist.parse_command_line()\n\n        try:\n            dist.run_commands()\n        except DistutilsFileError:\n            self.fail(\"failed package_data when data dir includes a dir\")\n\n    def test_dont_write_bytecode(self, caplog):\n        # makes sure byte_compile is not used\n        dist = self.create_dist()[1]\n        cmd = build_py(dist)\n        cmd.compile = True\n        cmd.optimize = 1\n\n        old_dont_write_bytecode = sys.dont_write_bytecode\n        sys.dont_write_bytecode = True\n        try:\n            cmd.byte_compile([])\n        finally:\n            sys.dont_write_bytecode = old_dont_write_bytecode\n\n        assert 'byte-compiling is disabled' in caplog.records[0].message\n\n    def test_namespace_package_does_not_warn(self, caplog):\n        \"\"\"\n        Originally distutils implementation did not account for PEP 420\n        and included warns for package directories that did not contain\n        ``__init__.py`` files.\n        After the acceptance of PEP 420, these warnings don't make more sense\n        so we want to ensure there are not displayed to not confuse the users.\n        \"\"\"\n        # Create a fake project structure with a package namespace:\n        tmp = self.mkdtemp()\n        jaraco.path.build({'ns': {'pkg': {'module.py': ''}}}, tmp)\n        os.chdir(tmp)\n\n        # Configure the package:\n        attrs = {\n            \"name\": \"ns.pkg\",\n            \"packages\": [\"ns\", \"ns.pkg\"],\n            \"script_name\": \"setup.py\",\n        }\n        dist = Distribution(attrs)\n\n        # Run code paths that would trigger the trap:\n        cmd = dist.get_command_obj(\"build_py\")\n        cmd.finalize_options()\n        modules = cmd.find_all_modules()\n        assert len(modules) == 1\n        module_path = modules[0][-1]\n        assert module_path.replace(os.sep, \"/\") == \"ns/pkg/module.py\"\n\n        cmd.run()\n\n        assert not any(\n            \"package init file\" in msg and \"not found\" in msg for msg in caplog.messages\n        )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_build_scripts.py","size":2880,"sha1":"69028d0cead908a2f7f399ff65d08d6abc56b39a","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.command.build_scripts.\"\"\"\n\nimport os\nimport textwrap\nfrom distutils import sysconfig\nfrom distutils.command.build_scripts import build_scripts\nfrom distutils.core import Distribution\nfrom distutils.tests import support\n\nimport jaraco.path\n\n\nclass TestBuildScripts(support.TempdirManager):\n    def test_default_settings(self):\n        cmd = self.get_build_scripts_cmd(\"/foo/bar\", [])\n        assert not cmd.force\n        assert cmd.build_dir is None\n\n        cmd.finalize_options()\n\n        assert cmd.force\n        assert cmd.build_dir == \"/foo/bar\"\n\n    def test_build(self):\n        source = self.mkdtemp()\n        target = self.mkdtemp()\n        expected = self.write_sample_scripts(source)\n\n        cmd = self.get_build_scripts_cmd(\n            target, [os.path.join(source, fn) for fn in expected]\n        )\n        cmd.finalize_options()\n        cmd.run()\n\n        built = os.listdir(target)\n        for name in expected:\n            assert name in built\n\n    def get_build_scripts_cmd(self, target, scripts):\n        import sys\n\n        dist = Distribution()\n        dist.scripts = scripts\n        dist.command_obj[\"build\"] = support.DummyCommand(\n            build_scripts=target, force=True, executable=sys.executable\n        )\n        return build_scripts(dist)\n\n    @staticmethod\n    def write_sample_scripts(dir):\n        spec = {\n            'script1.py': textwrap.dedent(\"\"\"\n                #! /usr/bin/env python2.3\n                # bogus script w/ Python sh-bang\n                pass\n                \"\"\").lstrip(),\n            'script2.py': textwrap.dedent(\"\"\"\n                #!/usr/bin/python\n                # bogus script w/ Python sh-bang\n                pass\n                \"\"\").lstrip(),\n            'shell.sh': textwrap.dedent(\"\"\"\n                #!/bin/sh\n                # bogus shell script w/ sh-bang\n                exit 0\n                \"\"\").lstrip(),\n        }\n        jaraco.path.build(spec, dir)\n        return list(spec)\n\n    def test_version_int(self):\n        source = self.mkdtemp()\n        target = self.mkdtemp()\n        expected = self.write_sample_scripts(source)\n\n        cmd = self.get_build_scripts_cmd(\n            target, [os.path.join(source, fn) for fn in expected]\n        )\n        cmd.finalize_options()\n\n        # https://bugs.python.org/issue4524\n        #\n        # On linux-g++-32 with command line `./configure --enable-ipv6\n        # --with-suffix=3`, python is compiled okay but the build scripts\n        # failed when writing the name of the executable\n        old = sysconfig.get_config_vars().get('VERSION')\n        sysconfig._config_vars['VERSION'] = 4\n        try:\n            cmd.run()\n        finally:\n            if old is not None:\n                sysconfig._config_vars['VERSION'] = old\n\n        built = os.listdir(target)\n        for name in expected:\n            assert name in built\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_ccompiler.py","size":3026,"sha1":"3d8d19516b0c53c3cbe78ab34ef951104b1856b3","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import os\nimport platform\nimport sys\nimport sysconfig\nimport textwrap\nfrom distutils import ccompiler\n\nimport pytest\n\npytestmark = pytest.mark.usefixtures('suppress_path_mangle')\n\n\ndef _make_strs(paths):\n    \"\"\"\n    Convert paths to strings for legacy compatibility.\n    \"\"\"\n    if sys.version_info > (3, 8) and platform.system() != \"Windows\":\n        return paths\n    return list(map(os.fspath, paths))\n\n\n@pytest.fixture\ndef c_file(tmp_path):\n    c_file = tmp_path / 'foo.c'\n    gen_headers = ('Python.h',)\n    is_windows = platform.system() == \"Windows\"\n    plat_headers = ('windows.h',) * is_windows\n    all_headers = gen_headers + plat_headers\n    headers = '\\n'.join(f'#include <{header}>\\n' for header in all_headers)\n    payload = (\n        textwrap.dedent(\n            \"\"\"\n        #headers\n        void PyInit_foo(void) {}\n        \"\"\"\n        )\n        .lstrip()\n        .replace('#headers', headers)\n    )\n    c_file.write_text(payload, encoding='utf-8')\n    return c_file\n\n\ndef test_set_include_dirs(c_file):\n    \"\"\"\n    Extensions should build even if set_include_dirs is invoked.\n    In particular, compiler-specific paths should not be overridden.\n    \"\"\"\n    compiler = ccompiler.new_compiler()\n    python = sysconfig.get_paths()['include']\n    compiler.set_include_dirs([python])\n    compiler.compile(_make_strs([c_file]))\n\n    # do it again, setting include dirs after any initialization\n    compiler.set_include_dirs([python])\n    compiler.compile(_make_strs([c_file]))\n\n\ndef test_has_function_prototype():\n    # Issue https://github.com/pypa/setuptools/issues/3648\n    # Test prototype-generating behavior.\n\n    compiler = ccompiler.new_compiler()\n\n    # Every C implementation should have these.\n    assert compiler.has_function('abort')\n    assert compiler.has_function('exit')\n    with pytest.deprecated_call(match='includes is deprecated'):\n        # abort() is a valid expression with the <stdlib.h> prototype.\n        assert compiler.has_function('abort', includes=['stdlib.h'])\n    with pytest.deprecated_call(match='includes is deprecated'):\n        # But exit() is not valid with the actual prototype in scope.\n        assert not compiler.has_function('exit', includes=['stdlib.h'])\n    # And setuptools_does_not_exist is not declared or defined at all.\n    assert not compiler.has_function('setuptools_does_not_exist')\n    with pytest.deprecated_call(match='includes is deprecated'):\n        assert not compiler.has_function(\n            'setuptools_does_not_exist', includes=['stdio.h']\n        )\n\n\ndef test_include_dirs_after_multiple_compile_calls(c_file):\n    \"\"\"\n    Calling compile multiple times should not change the include dirs\n    (regression test for setuptools issue #3591).\n    \"\"\"\n    compiler = ccompiler.new_compiler()\n    python = sysconfig.get_paths()['include']\n    compiler.set_include_dirs([python])\n    compiler.compile(_make_strs([c_file]))\n    assert compiler.include_dirs == [python]\n    compiler.compile(_make_strs([c_file]))\n    assert compiler.include_dirs == [python]\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_check.py","size":6226,"sha1":"bf0be65bd9c0ee8b698ac296bf60a448935f235a","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.command.check.\"\"\"\n\nimport os\nimport textwrap\nfrom distutils.command.check import check\nfrom distutils.errors import DistutilsSetupError\nfrom distutils.tests import support\n\nimport pytest\n\ntry:\n    import pygments\nexcept ImportError:\n    pygments = None\n\n\nHERE = os.path.dirname(__file__)\n\n\n@support.combine_markers\nclass TestCheck(support.TempdirManager):\n    def _run(self, metadata=None, cwd=None, **options):\n        if metadata is None:\n            metadata = {}\n        if cwd is not None:\n            old_dir = os.getcwd()\n            os.chdir(cwd)\n        pkg_info, dist = self.create_dist(**metadata)\n        cmd = check(dist)\n        cmd.initialize_options()\n        for name, value in options.items():\n            setattr(cmd, name, value)\n        cmd.ensure_finalized()\n        cmd.run()\n        if cwd is not None:\n            os.chdir(old_dir)\n        return cmd\n\n    def test_check_metadata(self):\n        # let's run the command with no metadata at all\n        # by default, check is checking the metadata\n        # should have some warnings\n        cmd = self._run()\n        assert cmd._warnings == 1\n\n        # now let's add the required fields\n        # and run it again, to make sure we don't get\n        # any warning anymore\n        metadata = {\n            'url': 'xxx',\n            'author': 'xxx',\n            'author_email': 'xxx',\n            'name': 'xxx',\n            'version': 'xxx',\n        }\n        cmd = self._run(metadata)\n        assert cmd._warnings == 0\n\n        # now with the strict mode, we should\n        # get an error if there are missing metadata\n        with pytest.raises(DistutilsSetupError):\n            self._run({}, **{'strict': 1})\n\n        # and of course, no error when all metadata are present\n        cmd = self._run(metadata, strict=True)\n        assert cmd._warnings == 0\n\n        # now a test with non-ASCII characters\n        metadata = {\n            'url': 'xxx',\n            'author': '\\u00c9ric',\n            'author_email': 'xxx',\n            'name': 'xxx',\n            'version': 'xxx',\n            'description': 'Something about esszet \\u00df',\n            'long_description': 'More things about esszet \\u00df',\n        }\n        cmd = self._run(metadata)\n        assert cmd._warnings == 0\n\n    def test_check_author_maintainer(self):\n        for kind in (\"author\", \"maintainer\"):\n            # ensure no warning when author_email or maintainer_email is given\n            # (the spec allows these fields to take the form \"Name <email>\")\n            metadata = {\n                'url': 'xxx',\n                kind + '_email': 'Name <name@email.com>',\n                'name': 'xxx',\n                'version': 'xxx',\n            }\n            cmd = self._run(metadata)\n            assert cmd._warnings == 0\n\n            # the check should not warn if only email is given\n            metadata[kind + '_email'] = 'name@email.com'\n            cmd = self._run(metadata)\n            assert cmd._warnings == 0\n\n            # the check should not warn if only the name is given\n            metadata[kind] = \"Name\"\n            del metadata[kind + '_email']\n            cmd = self._run(metadata)\n            assert cmd._warnings == 0\n\n    def test_check_document(self):\n        pytest.importorskip('docutils')\n        pkg_info, dist = self.create_dist()\n        cmd = check(dist)\n\n        # let's see if it detects broken rest\n        broken_rest = 'title\\n===\\n\\ntest'\n        msgs = cmd._check_rst_data(broken_rest)\n        assert len(msgs) == 1\n\n        # and non-broken rest\n        rest = 'title\\n=====\\n\\ntest'\n        msgs = cmd._check_rst_data(rest)\n        assert len(msgs) == 0\n\n    def test_check_restructuredtext(self):\n        pytest.importorskip('docutils')\n        # let's see if it detects broken rest in long_description\n        broken_rest = 'title\\n===\\n\\ntest'\n        pkg_info, dist = self.create_dist(long_description=broken_rest)\n        cmd = check(dist)\n        cmd.check_restructuredtext()\n        assert cmd._warnings == 1\n\n        # let's see if we have an error with strict=True\n        metadata = {\n            'url': 'xxx',\n            'author': 'xxx',\n            'author_email': 'xxx',\n            'name': 'xxx',\n            'version': 'xxx',\n            'long_description': broken_rest,\n        }\n        with pytest.raises(DistutilsSetupError):\n            self._run(metadata, **{'strict': 1, 'restructuredtext': 1})\n\n        # and non-broken rest, including a non-ASCII character to test #12114\n        metadata['long_description'] = 'title\\n=====\\n\\ntest \\u00df'\n        cmd = self._run(metadata, strict=True, restructuredtext=True)\n        assert cmd._warnings == 0\n\n        # check that includes work to test #31292\n        metadata['long_description'] = 'title\\n=====\\n\\n.. include:: includetest.rst'\n        cmd = self._run(metadata, cwd=HERE, strict=True, restructuredtext=True)\n        assert cmd._warnings == 0\n\n    def test_check_restructuredtext_with_syntax_highlight(self):\n        pytest.importorskip('docutils')\n        # Don't fail if there is a `code` or `code-block` directive\n\n        example_rst_docs = [\n            textwrap.dedent(\n                \"\"\"\\\n            Here's some code:\n\n            .. code:: python\n\n                def foo():\n                    pass\n            \"\"\"\n            ),\n            textwrap.dedent(\n                \"\"\"\\\n            Here's some code:\n\n            .. code-block:: python\n\n                def foo():\n                    pass\n            \"\"\"\n            ),\n        ]\n\n        for rest_with_code in example_rst_docs:\n            pkg_info, dist = self.create_dist(long_description=rest_with_code)\n            cmd = check(dist)\n            cmd.check_restructuredtext()\n            msgs = cmd._check_rst_data(rest_with_code)\n            if pygments is not None:\n                assert len(msgs) == 0\n            else:\n                assert len(msgs) == 1\n                assert (\n                    str(msgs[0][1])\n                    == 'Cannot analyze code. Pygments package not found.'\n                )\n\n    def test_check_all(self):\n        with pytest.raises(DistutilsSetupError):\n            self._run({}, **{'strict': 1, 'restructuredtext': 1})\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_clean.py","size":1240,"sha1":"cd94f1bafbc33fad9768405754622faccd68ce9d","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.command.clean.\"\"\"\n\nimport os\nfrom distutils.command.clean import clean\nfrom distutils.tests import support\n\n\nclass TestClean(support.TempdirManager):\n    def test_simple_run(self):\n        pkg_dir, dist = self.create_dist()\n        cmd = clean(dist)\n\n        # let's add some elements clean should remove\n        dirs = [\n            (d, os.path.join(pkg_dir, d))\n            for d in (\n                'build_temp',\n                'build_lib',\n                'bdist_base',\n                'build_scripts',\n                'build_base',\n            )\n        ]\n\n        for name, path in dirs:\n            os.mkdir(path)\n            setattr(cmd, name, path)\n            if name == 'build_base':\n                continue\n            for f in ('one', 'two', 'three'):\n                self.write_file(os.path.join(path, f))\n\n        # let's run the command\n        cmd.all = 1\n        cmd.ensure_finalized()\n        cmd.run()\n\n        # make sure the files where removed\n        for _name, path in dirs:\n            assert not os.path.exists(path), f'{path} was not removed'\n\n        # let's run the command again (should spit warnings but succeed)\n        cmd.all = 1\n        cmd.ensure_finalized()\n        cmd.run()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_cmd.py","size":3254,"sha1":"31919b527cdfbd8ad4f9435d5d92eaca9737e999","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.cmd.\"\"\"\n\nimport os\nfrom distutils import debug\nfrom distutils.cmd import Command\nfrom distutils.dist import Distribution\nfrom distutils.errors import DistutilsOptionError\n\nimport pytest\n\n\nclass MyCmd(Command):\n    def initialize_options(self):\n        pass\n\n\n@pytest.fixture\ndef cmd(request):\n    return MyCmd(Distribution())\n\n\nclass TestCommand:\n    def test_ensure_string_list(self, cmd):\n        cmd.not_string_list = ['one', 2, 'three']\n        cmd.yes_string_list = ['one', 'two', 'three']\n        cmd.not_string_list2 = object()\n        cmd.yes_string_list2 = 'ok'\n        cmd.ensure_string_list('yes_string_list')\n        cmd.ensure_string_list('yes_string_list2')\n\n        with pytest.raises(DistutilsOptionError):\n            cmd.ensure_string_list('not_string_list')\n\n        with pytest.raises(DistutilsOptionError):\n            cmd.ensure_string_list('not_string_list2')\n\n        cmd.option1 = 'ok,dok'\n        cmd.ensure_string_list('option1')\n        assert cmd.option1 == ['ok', 'dok']\n\n        cmd.option2 = ['xxx', 'www']\n        cmd.ensure_string_list('option2')\n\n        cmd.option3 = ['ok', 2]\n        with pytest.raises(DistutilsOptionError):\n            cmd.ensure_string_list('option3')\n\n    def test_make_file(self, cmd):\n        # making sure it raises when infiles is not a string or a list/tuple\n        with pytest.raises(TypeError):\n            cmd.make_file(infiles=True, outfile='', func='func', args=())\n\n        # making sure execute gets called properly\n        def _execute(func, args, exec_msg, level):\n            assert exec_msg == 'generating out from in'\n\n        cmd.force = True\n        cmd.execute = _execute\n        cmd.make_file(infiles='in', outfile='out', func='func', args=())\n\n    def test_dump_options(self, cmd):\n        msgs = []\n\n        def _announce(msg, level):\n            msgs.append(msg)\n\n        cmd.announce = _announce\n        cmd.option1 = 1\n        cmd.option2 = 1\n        cmd.user_options = [('option1', '', ''), ('option2', '', '')]\n        cmd.dump_options()\n\n        wanted = [\"command options for 'MyCmd':\", '  option1 = 1', '  option2 = 1']\n        assert msgs == wanted\n\n    def test_ensure_string(self, cmd):\n        cmd.option1 = 'ok'\n        cmd.ensure_string('option1')\n\n        cmd.option2 = None\n        cmd.ensure_string('option2', 'xxx')\n        assert hasattr(cmd, 'option2')\n\n        cmd.option3 = 1\n        with pytest.raises(DistutilsOptionError):\n            cmd.ensure_string('option3')\n\n    def test_ensure_filename(self, cmd):\n        cmd.option1 = __file__\n        cmd.ensure_filename('option1')\n        cmd.option2 = 'xxx'\n        with pytest.raises(DistutilsOptionError):\n            cmd.ensure_filename('option2')\n\n    def test_ensure_dirname(self, cmd):\n        cmd.option1 = os.path.dirname(__file__) or os.curdir\n        cmd.ensure_dirname('option1')\n        cmd.option2 = 'xxx'\n        with pytest.raises(DistutilsOptionError):\n            cmd.ensure_dirname('option2')\n\n    def test_debug_print(self, cmd, capsys, monkeypatch):\n        cmd.debug_print('xxx')\n        assert capsys.readouterr().out == ''\n        monkeypatch.setattr(debug, 'DEBUG', True)\n        cmd.debug_print('xxx')\n        assert capsys.readouterr().out == 'xxx\\n'\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_config_cmd.py","size":2664,"sha1":"39a1a6954e486c265c1b528abe5c1d58ad9b746e","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.command.config.\"\"\"\n\nimport os\nimport sys\nfrom distutils._log import log\nfrom distutils.command.config import config, dump_file\nfrom distutils.tests import missing_compiler_executable, support\n\nimport more_itertools\nimport path\nimport pytest\n\n\n@pytest.fixture(autouse=True)\ndef info_log(request, monkeypatch):\n    self = request.instance\n    self._logs = []\n    monkeypatch.setattr(log, 'info', self._info)\n\n\n@support.combine_markers\nclass TestConfig(support.TempdirManager):\n    def _info(self, msg, *args):\n        for line in msg.splitlines():\n            self._logs.append(line)\n\n    def test_dump_file(self):\n        this_file = path.Path(__file__).with_suffix('.py')\n        with this_file.open(encoding='utf-8') as f:\n            numlines = more_itertools.ilen(f)\n\n        dump_file(this_file, 'I am the header')\n        assert len(self._logs) == numlines + 1\n\n    @pytest.mark.skipif('platform.system() == \"Windows\"')\n    def test_search_cpp(self):\n        cmd = missing_compiler_executable(['preprocessor'])\n        if cmd is not None:\n            self.skipTest(f'The {cmd!r} command is not found')\n        pkg_dir, dist = self.create_dist()\n        cmd = config(dist)\n        cmd._check_compiler()\n        compiler = cmd.compiler\n        if sys.platform[:3] == \"aix\" and \"xlc\" in compiler.preprocessor[0].lower():\n            self.skipTest(\n                'xlc: The -E option overrides the -P, -o, and -qsyntaxonly options'\n            )\n\n        # simple pattern searches\n        match = cmd.search_cpp(pattern='xxx', body='/* xxx */')\n        assert match == 0\n\n        match = cmd.search_cpp(pattern='_configtest', body='/* xxx */')\n        assert match == 1\n\n    def test_finalize_options(self):\n        # finalize_options does a bit of transformation\n        # on options\n        pkg_dir, dist = self.create_dist()\n        cmd = config(dist)\n        cmd.include_dirs = f'one{os.pathsep}two'\n        cmd.libraries = 'one'\n        cmd.library_dirs = f'three{os.pathsep}four'\n        cmd.ensure_finalized()\n\n        assert cmd.include_dirs == ['one', 'two']\n        assert cmd.libraries == ['one']\n        assert cmd.library_dirs == ['three', 'four']\n\n    def test_clean(self):\n        # _clean removes files\n        tmp_dir = self.mkdtemp()\n        f1 = os.path.join(tmp_dir, 'one')\n        f2 = os.path.join(tmp_dir, 'two')\n\n        self.write_file(f1, 'xxx')\n        self.write_file(f2, 'xxx')\n\n        for f in (f1, f2):\n            assert os.path.exists(f)\n\n        pkg_dir, dist = self.create_dist()\n        cmd = config(dist)\n        cmd._clean(f1, f2)\n\n        for f in (f1, f2):\n            assert not os.path.exists(f)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_core.py","size":3829,"sha1":"9f0506126c46203bed605259b4d13304f26a2a20","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.core.\"\"\"\n\nimport distutils.core\nimport io\nimport os\nimport sys\nfrom distutils.dist import Distribution\n\nimport pytest\n\n# setup script that uses __file__\nsetup_using___file__ = \"\"\"\\\n\n__file__\n\nfrom distutils.core import setup\nsetup()\n\"\"\"\n\nsetup_prints_cwd = \"\"\"\\\n\nimport os\nprint(os.getcwd())\n\nfrom distutils.core import setup\nsetup()\n\"\"\"\n\nsetup_does_nothing = \"\"\"\\\nfrom distutils.core import setup\nsetup()\n\"\"\"\n\n\nsetup_defines_subclass = \"\"\"\\\nfrom distutils.core import setup\nfrom distutils.command.install import install as _install\n\nclass install(_install):\n    sub_commands = _install.sub_commands + ['cmd']\n\nsetup(cmdclass={'install': install})\n\"\"\"\n\nsetup_within_if_main = \"\"\"\\\nfrom distutils.core import setup\n\ndef main():\n    return setup(name=\"setup_within_if_main\")\n\nif __name__ == \"__main__\":\n    main()\n\"\"\"\n\n\n@pytest.fixture(autouse=True)\ndef save_stdout(monkeypatch):\n    monkeypatch.setattr(sys, 'stdout', sys.stdout)\n\n\n@pytest.fixture\ndef temp_file(tmp_path):\n    return tmp_path / 'file'\n\n\n@pytest.mark.usefixtures('save_env')\n@pytest.mark.usefixtures('save_argv')\nclass TestCore:\n    def test_run_setup_provides_file(self, temp_file):\n        # Make sure the script can use __file__; if that's missing, the test\n        # setup.py script will raise NameError.\n        temp_file.write_text(setup_using___file__, encoding='utf-8')\n        distutils.core.run_setup(temp_file)\n\n    def test_run_setup_preserves_sys_argv(self, temp_file):\n        # Make sure run_setup does not clobber sys.argv\n        argv_copy = sys.argv.copy()\n        temp_file.write_text(setup_does_nothing, encoding='utf-8')\n        distutils.core.run_setup(temp_file)\n        assert sys.argv == argv_copy\n\n    def test_run_setup_defines_subclass(self, temp_file):\n        # Make sure the script can use __file__; if that's missing, the test\n        # setup.py script will raise NameError.\n        temp_file.write_text(setup_defines_subclass, encoding='utf-8')\n        dist = distutils.core.run_setup(temp_file)\n        install = dist.get_command_obj('install')\n        assert 'cmd' in install.sub_commands\n\n    def test_run_setup_uses_current_dir(self, tmp_path):\n        \"\"\"\n        Test that the setup script is run with the current directory\n        as its own current directory.\n        \"\"\"\n        sys.stdout = io.StringIO()\n        cwd = os.getcwd()\n\n        # Create a directory and write the setup.py file there:\n        setup_py = tmp_path / 'setup.py'\n        setup_py.write_text(setup_prints_cwd, encoding='utf-8')\n        distutils.core.run_setup(setup_py)\n\n        output = sys.stdout.getvalue()\n        if output.endswith(\"\\n\"):\n            output = output[:-1]\n        assert cwd == output\n\n    def test_run_setup_within_if_main(self, temp_file):\n        temp_file.write_text(setup_within_if_main, encoding='utf-8')\n        dist = distutils.core.run_setup(temp_file, stop_after=\"config\")\n        assert isinstance(dist, Distribution)\n        assert dist.get_name() == \"setup_within_if_main\"\n\n    def test_run_commands(self, temp_file):\n        sys.argv = ['setup.py', 'build']\n        temp_file.write_text(setup_within_if_main, encoding='utf-8')\n        dist = distutils.core.run_setup(temp_file, stop_after=\"commandline\")\n        assert 'build' not in dist.have_run\n        distutils.core.run_commands(dist)\n        assert 'build' in dist.have_run\n\n    def test_debug_mode(self, capsys, monkeypatch):\n        # this covers the code called when DEBUG is set\n        sys.argv = ['setup.py', '--name']\n        distutils.core.setup(name='bar')\n        assert capsys.readouterr().out == 'bar\\n'\n        monkeypatch.setattr(distutils.core, 'DEBUG', True)\n        distutils.core.setup(name='bar')\n        wanted = \"options (after parsing config files):\\n\"\n        assert capsys.readouterr().out.startswith(wanted)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_cygwinccompiler.py","size":2753,"sha1":"83fd03f78b24bebbb7ff60b772e5b7ee1f8b948e","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.cygwinccompiler.\"\"\"\n\nimport os\nimport sys\nfrom distutils import sysconfig\nfrom distutils.cygwinccompiler import (\n    CONFIG_H_NOTOK,\n    CONFIG_H_OK,\n    CONFIG_H_UNCERTAIN,\n    check_config_h,\n    get_msvcr,\n)\nfrom distutils.tests import support\n\nimport pytest\n\n\n@pytest.fixture(autouse=True)\ndef stuff(request, monkeypatch, distutils_managed_tempdir):\n    self = request.instance\n    self.python_h = os.path.join(self.mkdtemp(), 'python.h')\n    monkeypatch.setattr(sysconfig, 'get_config_h_filename', self._get_config_h_filename)\n    monkeypatch.setattr(sys, 'version', sys.version)\n\n\nclass TestCygwinCCompiler(support.TempdirManager):\n    def _get_config_h_filename(self):\n        return self.python_h\n\n    @pytest.mark.skipif('sys.platform != \"cygwin\"')\n    @pytest.mark.skipif('not os.path.exists(\"/usr/lib/libbash.dll.a\")')\n    def test_find_library_file(self):\n        from distutils.cygwinccompiler import CygwinCCompiler\n\n        compiler = CygwinCCompiler()\n        link_name = \"bash\"\n        linkable_file = compiler.find_library_file([\"/usr/lib\"], link_name)\n        assert linkable_file is not None\n        assert os.path.exists(linkable_file)\n        assert linkable_file == f\"/usr/lib/lib{link_name:s}.dll.a\"\n\n    @pytest.mark.skipif('sys.platform != \"cygwin\"')\n    def test_runtime_library_dir_option(self):\n        from distutils.cygwinccompiler import CygwinCCompiler\n\n        compiler = CygwinCCompiler()\n        assert compiler.runtime_library_dir_option('/foo') == []\n\n    def test_check_config_h(self):\n        # check_config_h looks for \"GCC\" in sys.version first\n        # returns CONFIG_H_OK if found\n        sys.version = (\n            '2.6.1 (r261:67515, Dec  6 2008, 16:42:21) \\n[GCC '\n            '4.0.1 (Apple Computer, Inc. build 5370)]'\n        )\n\n        assert check_config_h()[0] == CONFIG_H_OK\n\n        # then it tries to see if it can find \"__GNUC__\" in pyconfig.h\n        sys.version = 'something without the *CC word'\n\n        # if the file doesn't exist it returns  CONFIG_H_UNCERTAIN\n        assert check_config_h()[0] == CONFIG_H_UNCERTAIN\n\n        # if it exists but does not contain __GNUC__, it returns CONFIG_H_NOTOK\n        self.write_file(self.python_h, 'xxx')\n        assert check_config_h()[0] == CONFIG_H_NOTOK\n\n        # and CONFIG_H_OK if __GNUC__ is found\n        self.write_file(self.python_h, 'xxx __GNUC__ xxx')\n        assert check_config_h()[0] == CONFIG_H_OK\n\n    def test_get_msvcr(self):\n        assert get_msvcr() == []\n\n    @pytest.mark.skipif('sys.platform != \"cygwin\"')\n    def test_dll_libraries_not_none(self):\n        from distutils.cygwinccompiler import CygwinCCompiler\n\n        compiler = CygwinCCompiler()\n        assert compiler.dll_libraries is not None\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_dir_util.py","size":4500,"sha1":"c0c723501995bcfb7036c2c5e3511cd9950937a6","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.dir_util.\"\"\"\n\nimport os\nimport pathlib\nimport stat\nimport sys\nimport unittest.mock as mock\nfrom distutils import dir_util, errors\nfrom distutils.dir_util import (\n    copy_tree,\n    create_tree,\n    ensure_relative,\n    mkpath,\n    remove_tree,\n)\nfrom distutils.tests import support\n\nimport jaraco.path\nimport path\nimport pytest\n\n\n@pytest.fixture(autouse=True)\ndef stuff(request, monkeypatch, distutils_managed_tempdir):\n    self = request.instance\n    tmp_dir = self.mkdtemp()\n    self.root_target = os.path.join(tmp_dir, 'deep')\n    self.target = os.path.join(self.root_target, 'here')\n    self.target2 = os.path.join(tmp_dir, 'deep2')\n\n\nclass TestDirUtil(support.TempdirManager):\n    def test_mkpath_remove_tree_verbosity(self, caplog):\n        mkpath(self.target, verbose=False)\n        assert not caplog.records\n        remove_tree(self.root_target, verbose=False)\n\n        mkpath(self.target, verbose=True)\n        wanted = [f'creating {self.target}']\n        assert caplog.messages == wanted\n        caplog.clear()\n\n        remove_tree(self.root_target, verbose=True)\n        wanted = [f\"removing '{self.root_target}' (and everything under it)\"]\n        assert caplog.messages == wanted\n\n    @pytest.mark.skipif(\"platform.system() == 'Windows'\")\n    def test_mkpath_with_custom_mode(self):\n        # Get and set the current umask value for testing mode bits.\n        umask = os.umask(0o002)\n        os.umask(umask)\n        mkpath(self.target, 0o700)\n        assert stat.S_IMODE(os.stat(self.target).st_mode) == 0o700 & ~umask\n        mkpath(self.target2, 0o555)\n        assert stat.S_IMODE(os.stat(self.target2).st_mode) == 0o555 & ~umask\n\n    def test_create_tree_verbosity(self, caplog):\n        create_tree(self.root_target, ['one', 'two', 'three'], verbose=False)\n        assert caplog.messages == []\n        remove_tree(self.root_target, verbose=False)\n\n        wanted = [f'creating {self.root_target}']\n        create_tree(self.root_target, ['one', 'two', 'three'], verbose=True)\n        assert caplog.messages == wanted\n\n        remove_tree(self.root_target, verbose=False)\n\n    def test_copy_tree_verbosity(self, caplog):\n        mkpath(self.target, verbose=False)\n\n        copy_tree(self.target, self.target2, verbose=False)\n        assert caplog.messages == []\n\n        remove_tree(self.root_target, verbose=False)\n\n        mkpath(self.target, verbose=False)\n        a_file = path.Path(self.target) / 'ok.txt'\n        jaraco.path.build({'ok.txt': 'some content'}, self.target)\n\n        wanted = [f'copying {a_file} -> {self.target2}']\n        copy_tree(self.target, self.target2, verbose=True)\n        assert caplog.messages == wanted\n\n        remove_tree(self.root_target, verbose=False)\n        remove_tree(self.target2, verbose=False)\n\n    def test_copy_tree_skips_nfs_temp_files(self):\n        mkpath(self.target, verbose=False)\n\n        jaraco.path.build({'ok.txt': 'some content', '.nfs123abc': ''}, self.target)\n\n        copy_tree(self.target, self.target2)\n        assert os.listdir(self.target2) == ['ok.txt']\n\n        remove_tree(self.root_target, verbose=False)\n        remove_tree(self.target2, verbose=False)\n\n    def test_ensure_relative(self):\n        if os.sep == '/':\n            assert ensure_relative('/home/foo') == 'home/foo'\n            assert ensure_relative('some/path') == 'some/path'\n        else:  # \\\\\n            assert ensure_relative('c:\\\\home\\\\foo') == 'c:home\\\\foo'\n            assert ensure_relative('home\\\\foo') == 'home\\\\foo'\n\n    def test_copy_tree_exception_in_listdir(self):\n        \"\"\"\n        An exception in listdir should raise a DistutilsFileError\n        \"\"\"\n        with (\n            mock.patch(\"os.listdir\", side_effect=OSError()),\n            pytest.raises(errors.DistutilsFileError),\n        ):\n            src = self.tempdirs[-1]\n            dir_util.copy_tree(src, None)\n\n    def test_mkpath_exception_uncached(self, monkeypatch, tmp_path):\n        \"\"\"\n        Caching should not remember failed attempts.\n\n        pypa/distutils#304\n        \"\"\"\n\n        class FailPath(pathlib.Path):\n            def mkdir(self, *args, **kwargs):\n                raise OSError(\"Failed to create directory\")\n\n            if sys.version_info < (3, 12):\n                _flavour = pathlib.Path()._flavour\n\n        target = tmp_path / 'foodir'\n\n        with pytest.raises(errors.DistutilsFileError):\n            mkpath(FailPath(target))\n\n        assert not target.exists()\n\n        mkpath(target)\n        assert target.exists()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_dist.py","size":18793,"sha1":"048eac9809a41410a19e12eeeb97f66eab1a32ce","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.dist.\"\"\"\n\nimport email\nimport email.generator\nimport email.policy\nimport functools\nimport io\nimport os\nimport sys\nimport textwrap\nimport unittest.mock as mock\nimport warnings\nfrom distutils.cmd import Command\nfrom distutils.dist import Distribution, fix_help_options\nfrom distutils.tests import support\nfrom typing import ClassVar\n\nimport jaraco.path\nimport pytest\n\npydistutils_cfg = '.' * (os.name == 'posix') + 'pydistutils.cfg'\n\n\nclass test_dist(Command):\n    \"\"\"Sample distutils extension command.\"\"\"\n\n    user_options: ClassVar[list[tuple[str, str, str]]] = [\n        (\"sample-option=\", \"S\", \"help text\"),\n    ]\n\n    def initialize_options(self):\n        self.sample_option = None\n\n\nclass TestDistribution(Distribution):\n    \"\"\"Distribution subclasses that avoids the default search for\n    configuration files.\n\n    The ._config_files attribute must be set before\n    .parse_config_files() is called.\n    \"\"\"\n\n    def find_config_files(self):\n        return self._config_files\n\n\n@pytest.fixture\ndef clear_argv():\n    del sys.argv[1:]\n\n\n@support.combine_markers\n@pytest.mark.usefixtures('save_env')\n@pytest.mark.usefixtures('save_argv')\nclass TestDistributionBehavior(support.TempdirManager):\n    def create_distribution(self, configfiles=()):\n        d = TestDistribution()\n        d._config_files = configfiles\n        d.parse_config_files()\n        d.parse_command_line()\n        return d\n\n    def test_command_packages_unspecified(self, clear_argv):\n        sys.argv.append(\"build\")\n        d = self.create_distribution()\n        assert d.get_command_packages() == [\"distutils.command\"]\n\n    def test_command_packages_cmdline(self, clear_argv):\n        from distutils.tests.test_dist import test_dist\n\n        sys.argv.extend([\n            \"--command-packages\",\n            \"foo.bar,distutils.tests\",\n            \"test_dist\",\n            \"-Ssometext\",\n        ])\n        d = self.create_distribution()\n        # let's actually try to load our test command:\n        assert d.get_command_packages() == [\n            \"distutils.command\",\n            \"foo.bar\",\n            \"distutils.tests\",\n        ]\n        cmd = d.get_command_obj(\"test_dist\")\n        assert isinstance(cmd, test_dist)\n        assert cmd.sample_option == \"sometext\"\n\n    @pytest.mark.skipif(\n        'distutils' not in Distribution.parse_config_files.__module__,\n        reason='Cannot test when virtualenv has monkey-patched Distribution',\n    )\n    def test_venv_install_options(self, tmp_path, clear_argv):\n        sys.argv.append(\"install\")\n        file = str(tmp_path / 'file')\n\n        fakepath = '/somedir'\n\n        jaraco.path.build({\n            file: f\"\"\"\n                    [install]\n                    install-base = {fakepath}\n                    install-platbase = {fakepath}\n                    install-lib = {fakepath}\n                    install-platlib = {fakepath}\n                    install-purelib = {fakepath}\n                    install-headers = {fakepath}\n                    install-scripts = {fakepath}\n                    install-data = {fakepath}\n                    prefix = {fakepath}\n                    exec-prefix = {fakepath}\n                    home = {fakepath}\n                    user = {fakepath}\n                    root = {fakepath}\n                    \"\"\",\n        })\n\n        # Base case: Not in a Virtual Environment\n        with mock.patch.multiple(sys, prefix='/a', base_prefix='/a'):\n            d = self.create_distribution([file])\n\n        option_tuple = (file, fakepath)\n\n        result_dict = {\n            'install_base': option_tuple,\n            'install_platbase': option_tuple,\n            'install_lib': option_tuple,\n            'install_platlib': option_tuple,\n            'install_purelib': option_tuple,\n            'install_headers': option_tuple,\n            'install_scripts': option_tuple,\n            'install_data': option_tuple,\n            'prefix': option_tuple,\n            'exec_prefix': option_tuple,\n            'home': option_tuple,\n            'user': option_tuple,\n            'root': option_tuple,\n        }\n\n        assert sorted(d.command_options.get('install').keys()) == sorted(\n            result_dict.keys()\n        )\n\n        for key, value in d.command_options.get('install').items():\n            assert value == result_dict[key]\n\n        # Test case: In a Virtual Environment\n        with mock.patch.multiple(sys, prefix='/a', base_prefix='/b'):\n            d = self.create_distribution([file])\n\n        for key in result_dict.keys():\n            assert key not in d.command_options.get('install', {})\n\n    def test_command_packages_configfile(self, tmp_path, clear_argv):\n        sys.argv.append(\"build\")\n        file = str(tmp_path / \"file\")\n        jaraco.path.build({\n            file: \"\"\"\n                    [global]\n                    command_packages = foo.bar, splat\n                    \"\"\",\n        })\n\n        d = self.create_distribution([file])\n        assert d.get_command_packages() == [\"distutils.command\", \"foo.bar\", \"splat\"]\n\n        # ensure command line overrides config:\n        sys.argv[1:] = [\"--command-packages\", \"spork\", \"build\"]\n        d = self.create_distribution([file])\n        assert d.get_command_packages() == [\"distutils.command\", \"spork\"]\n\n        # Setting --command-packages to '' should cause the default to\n        # be used even if a config file specified something else:\n        sys.argv[1:] = [\"--command-packages\", \"\", \"build\"]\n        d = self.create_distribution([file])\n        assert d.get_command_packages() == [\"distutils.command\"]\n\n    def test_empty_options(self, request):\n        # an empty options dictionary should not stay in the\n        # list of attributes\n\n        # catching warnings\n        warns = []\n\n        def _warn(msg):\n            warns.append(msg)\n\n        request.addfinalizer(\n            functools.partial(setattr, warnings, 'warn', warnings.warn)\n        )\n        warnings.warn = _warn\n        dist = Distribution(\n            attrs={\n                'author': 'xxx',\n                'name': 'xxx',\n                'version': 'xxx',\n                'url': 'xxxx',\n                'options': {},\n            }\n        )\n\n        assert len(warns) == 0\n        assert 'options' not in dir(dist)\n\n    def test_finalize_options(self):\n        attrs = {'keywords': 'one,two', 'platforms': 'one,two'}\n\n        dist = Distribution(attrs=attrs)\n        dist.finalize_options()\n\n        # finalize_option splits platforms and keywords\n        assert dist.metadata.platforms == ['one', 'two']\n        assert dist.metadata.keywords == ['one', 'two']\n\n        attrs = {'keywords': 'foo bar', 'platforms': 'foo bar'}\n        dist = Distribution(attrs=attrs)\n        dist.finalize_options()\n        assert dist.metadata.platforms == ['foo bar']\n        assert dist.metadata.keywords == ['foo bar']\n\n    def test_get_command_packages(self):\n        dist = Distribution()\n        assert dist.command_packages is None\n        cmds = dist.get_command_packages()\n        assert cmds == ['distutils.command']\n        assert dist.command_packages == ['distutils.command']\n\n        dist.command_packages = 'one,two'\n        cmds = dist.get_command_packages()\n        assert cmds == ['distutils.command', 'one', 'two']\n\n    def test_announce(self):\n        # make sure the level is known\n        dist = Distribution()\n        with pytest.raises(TypeError):\n            dist.announce('ok', level='ok2')\n\n    def test_find_config_files_disable(self, temp_home):\n        # Ticket #1180: Allow user to disable their home config file.\n        jaraco.path.build({pydistutils_cfg: '[distutils]\\n'}, temp_home)\n\n        d = Distribution()\n        all_files = d.find_config_files()\n\n        d = Distribution(attrs={'script_args': ['--no-user-cfg']})\n        files = d.find_config_files()\n\n        # make sure --no-user-cfg disables the user cfg file\n        assert len(all_files) - 1 == len(files)\n\n    def test_script_args_list_coercion(self):\n        d = Distribution(attrs={'script_args': ('build', '--no-user-cfg')})\n\n        # make sure script_args is a list even if it started as a different iterable\n        assert d.script_args == ['build', '--no-user-cfg']\n\n    @pytest.mark.skipif(\n        'platform.system() == \"Windows\"',\n        reason='Windows does not honor chmod 000',\n    )\n    def test_find_config_files_permission_error(self, fake_home):\n        \"\"\"\n        Finding config files should not fail when directory is inaccessible.\n        \"\"\"\n        fake_home.joinpath(pydistutils_cfg).write_text('', encoding='utf-8')\n        fake_home.chmod(0o000)\n        Distribution().find_config_files()\n\n\n@pytest.mark.usefixtures('save_env')\n@pytest.mark.usefixtures('save_argv')\nclass TestMetadata(support.TempdirManager):\n    def format_metadata(self, dist):\n        sio = io.StringIO()\n        dist.metadata.write_pkg_file(sio)\n        return sio.getvalue()\n\n    def test_simple_metadata(self):\n        attrs = {\"name\": \"package\", \"version\": \"1.0\"}\n        dist = Distribution(attrs)\n        meta = self.format_metadata(dist)\n        assert \"Metadata-Version: 1.0\" in meta\n        assert \"provides:\" not in meta.lower()\n        assert \"requires:\" not in meta.lower()\n        assert \"obsoletes:\" not in meta.lower()\n\n    def test_provides(self):\n        attrs = {\n            \"name\": \"package\",\n            \"version\": \"1.0\",\n            \"provides\": [\"package\", \"package.sub\"],\n        }\n        dist = Distribution(attrs)\n        assert dist.metadata.get_provides() == [\"package\", \"package.sub\"]\n        assert dist.get_provides() == [\"package\", \"package.sub\"]\n        meta = self.format_metadata(dist)\n        assert \"Metadata-Version: 1.1\" in meta\n        assert \"requires:\" not in meta.lower()\n        assert \"obsoletes:\" not in meta.lower()\n\n    def test_provides_illegal(self):\n        with pytest.raises(ValueError):\n            Distribution(\n                {\"name\": \"package\", \"version\": \"1.0\", \"provides\": [\"my.pkg (splat)\"]},\n            )\n\n    def test_requires(self):\n        attrs = {\n            \"name\": \"package\",\n            \"version\": \"1.0\",\n            \"requires\": [\"other\", \"another (==1.0)\"],\n        }\n        dist = Distribution(attrs)\n        assert dist.metadata.get_requires() == [\"other\", \"another (==1.0)\"]\n        assert dist.get_requires() == [\"other\", \"another (==1.0)\"]\n        meta = self.format_metadata(dist)\n        assert \"Metadata-Version: 1.1\" in meta\n        assert \"provides:\" not in meta.lower()\n        assert \"Requires: other\" in meta\n        assert \"Requires: another (==1.0)\" in meta\n        assert \"obsoletes:\" not in meta.lower()\n\n    def test_requires_illegal(self):\n        with pytest.raises(ValueError):\n            Distribution(\n                {\"name\": \"package\", \"version\": \"1.0\", \"requires\": [\"my.pkg (splat)\"]},\n            )\n\n    def test_requires_to_list(self):\n        attrs = {\"name\": \"package\", \"requires\": iter([\"other\"])}\n        dist = Distribution(attrs)\n        assert isinstance(dist.metadata.requires, list)\n\n    def test_obsoletes(self):\n        attrs = {\n            \"name\": \"package\",\n            \"version\": \"1.0\",\n            \"obsoletes\": [\"other\", \"another (<1.0)\"],\n        }\n        dist = Distribution(attrs)\n        assert dist.metadata.get_obsoletes() == [\"other\", \"another (<1.0)\"]\n        assert dist.get_obsoletes() == [\"other\", \"another (<1.0)\"]\n        meta = self.format_metadata(dist)\n        assert \"Metadata-Version: 1.1\" in meta\n        assert \"provides:\" not in meta.lower()\n        assert \"requires:\" not in meta.lower()\n        assert \"Obsoletes: other\" in meta\n        assert \"Obsoletes: another (<1.0)\" in meta\n\n    def test_obsoletes_illegal(self):\n        with pytest.raises(ValueError):\n            Distribution(\n                {\"name\": \"package\", \"version\": \"1.0\", \"obsoletes\": [\"my.pkg (splat)\"]},\n            )\n\n    def test_obsoletes_to_list(self):\n        attrs = {\"name\": \"package\", \"obsoletes\": iter([\"other\"])}\n        dist = Distribution(attrs)\n        assert isinstance(dist.metadata.obsoletes, list)\n\n    def test_classifier(self):\n        attrs = {\n            'name': 'Boa',\n            'version': '3.0',\n            'classifiers': ['Programming Language :: Python :: 3'],\n        }\n        dist = Distribution(attrs)\n        assert dist.get_classifiers() == ['Programming Language :: Python :: 3']\n        meta = self.format_metadata(dist)\n        assert 'Metadata-Version: 1.1' in meta\n\n    def test_classifier_invalid_type(self, caplog):\n        attrs = {\n            'name': 'Boa',\n            'version': '3.0',\n            'classifiers': ('Programming Language :: Python :: 3',),\n        }\n        d = Distribution(attrs)\n        # should have warning about passing a non-list\n        assert 'should be a list' in caplog.messages[0]\n        # should be converted to a list\n        assert isinstance(d.metadata.classifiers, list)\n        assert d.metadata.classifiers == list(attrs['classifiers'])\n\n    def test_keywords(self):\n        attrs = {\n            'name': 'Monty',\n            'version': '1.0',\n            'keywords': ['spam', 'eggs', 'life of brian'],\n        }\n        dist = Distribution(attrs)\n        assert dist.get_keywords() == ['spam', 'eggs', 'life of brian']\n\n    def test_keywords_invalid_type(self, caplog):\n        attrs = {\n            'name': 'Monty',\n            'version': '1.0',\n            'keywords': ('spam', 'eggs', 'life of brian'),\n        }\n        d = Distribution(attrs)\n        # should have warning about passing a non-list\n        assert 'should be a list' in caplog.messages[0]\n        # should be converted to a list\n        assert isinstance(d.metadata.keywords, list)\n        assert d.metadata.keywords == list(attrs['keywords'])\n\n    def test_platforms(self):\n        attrs = {\n            'name': 'Monty',\n            'version': '1.0',\n            'platforms': ['GNU/Linux', 'Some Evil Platform'],\n        }\n        dist = Distribution(attrs)\n        assert dist.get_platforms() == ['GNU/Linux', 'Some Evil Platform']\n\n    def test_platforms_invalid_types(self, caplog):\n        attrs = {\n            'name': 'Monty',\n            'version': '1.0',\n            'platforms': ('GNU/Linux', 'Some Evil Platform'),\n        }\n        d = Distribution(attrs)\n        # should have warning about passing a non-list\n        assert 'should be a list' in caplog.messages[0]\n        # should be converted to a list\n        assert isinstance(d.metadata.platforms, list)\n        assert d.metadata.platforms == list(attrs['platforms'])\n\n    def test_download_url(self):\n        attrs = {\n            'name': 'Boa',\n            'version': '3.0',\n            'download_url': 'http://example.org/boa',\n        }\n        dist = Distribution(attrs)\n        meta = self.format_metadata(dist)\n        assert 'Metadata-Version: 1.1' in meta\n\n    def test_long_description(self):\n        long_desc = textwrap.dedent(\n            \"\"\"\\\n        example::\n              We start here\n            and continue here\n          and end here.\"\"\"\n        )\n        attrs = {\"name\": \"package\", \"version\": \"1.0\", \"long_description\": long_desc}\n\n        dist = Distribution(attrs)\n        meta = self.format_metadata(dist)\n        meta = meta.replace('\\n' + 8 * ' ', '\\n')\n        assert long_desc in meta\n\n    def test_custom_pydistutils(self, temp_home):\n        \"\"\"\n        pydistutils.cfg is found\n        \"\"\"\n        jaraco.path.build({pydistutils_cfg: ''}, temp_home)\n        config_path = temp_home / pydistutils_cfg\n\n        assert str(config_path) in Distribution().find_config_files()\n\n    def test_extra_pydistutils(self, monkeypatch, tmp_path):\n        jaraco.path.build({'overrides.cfg': ''}, tmp_path)\n        filename = tmp_path / 'overrides.cfg'\n        monkeypatch.setenv('DIST_EXTRA_CONFIG', str(filename))\n        assert str(filename) in Distribution().find_config_files()\n\n    def test_fix_help_options(self):\n        help_tuples = [('a', 'b', 'c', 'd'), (1, 2, 3, 4)]\n        fancy_options = fix_help_options(help_tuples)\n        assert fancy_options[0] == ('a', 'b', 'c')\n        assert fancy_options[1] == (1, 2, 3)\n\n    def test_show_help(self, request, capsys):\n        # smoke test, just makes sure some help is displayed\n        dist = Distribution()\n        sys.argv = []\n        dist.help = True\n        dist.script_name = 'setup.py'\n        dist.parse_command_line()\n\n        output = [\n            line for line in capsys.readouterr().out.split('\\n') if line.strip() != ''\n        ]\n        assert output\n\n    def test_read_metadata(self):\n        attrs = {\n            \"name\": \"package\",\n            \"version\": \"1.0\",\n            \"long_description\": \"desc\",\n            \"description\": \"xxx\",\n            \"download_url\": \"http://example.com\",\n            \"keywords\": ['one', 'two'],\n            \"requires\": ['foo'],\n        }\n\n        dist = Distribution(attrs)\n        metadata = dist.metadata\n\n        # write it then reloads it\n        PKG_INFO = io.StringIO()\n        metadata.write_pkg_file(PKG_INFO)\n        PKG_INFO.seek(0)\n        metadata.read_pkg_file(PKG_INFO)\n\n        assert metadata.name == \"package\"\n        assert metadata.version == \"1.0\"\n        assert metadata.description == \"xxx\"\n        assert metadata.download_url == 'http://example.com'\n        assert metadata.keywords == ['one', 'two']\n        assert metadata.platforms is None\n        assert metadata.obsoletes is None\n        assert metadata.requires == ['foo']\n\n    def test_round_trip_through_email_generator(self):\n        \"\"\"\n        In pypa/setuptools#4033, it was shown that once PKG-INFO is\n        re-generated using ``email.generator.Generator``, some control\n        characters might cause problems.\n        \"\"\"\n        # Given a PKG-INFO file ...\n        attrs = {\n            \"name\": \"package\",\n            \"version\": \"1.0\",\n            \"long_description\": \"hello\\x0b\\nworld\\n\",\n        }\n        dist = Distribution(attrs)\n        metadata = dist.metadata\n\n        with io.StringIO() as buffer:\n            metadata.write_pkg_file(buffer)\n            msg = buffer.getvalue()\n\n        # ... when it is read and re-written using stdlib's email library,\n        orig = email.message_from_string(msg)\n        policy = email.policy.EmailPolicy(\n            utf8=True,\n            mangle_from_=False,\n            max_line_length=0,\n        )\n        with io.StringIO() as buffer:\n            email.generator.Generator(buffer, policy=policy).flatten(orig)\n\n            buffer.seek(0)\n            regen = email.message_from_file(buffer)\n\n        # ... then it should be the same as the original\n        # (except for the specific line break characters)\n        orig_desc = set(orig[\"Description\"].splitlines())\n        regen_desc = set(regen[\"Description\"].splitlines())\n        assert regen_desc == orig_desc\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_extension.py","size":3670,"sha1":"3a9c40e4b77b3b3fa3ba1822dde53924b6e44e75","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.extension.\"\"\"\n\nimport os\nimport pathlib\nimport warnings\nfrom distutils.extension import Extension, read_setup_file\n\nimport pytest\nfrom test.support.warnings_helper import check_warnings\n\n\nclass TestExtension:\n    def test_read_setup_file(self):\n        # trying to read a Setup file\n        # (sample extracted from the PyGame project)\n        setup = os.path.join(os.path.dirname(__file__), 'Setup.sample')\n\n        exts = read_setup_file(setup)\n        names = [ext.name for ext in exts]\n        names.sort()\n\n        # here are the extensions read_setup_file should have created\n        # out of the file\n        wanted = [\n            '_arraysurfarray',\n            '_camera',\n            '_numericsndarray',\n            '_numericsurfarray',\n            'base',\n            'bufferproxy',\n            'cdrom',\n            'color',\n            'constants',\n            'display',\n            'draw',\n            'event',\n            'fastevent',\n            'font',\n            'gfxdraw',\n            'image',\n            'imageext',\n            'joystick',\n            'key',\n            'mask',\n            'mixer',\n            'mixer_music',\n            'mouse',\n            'movie',\n            'overlay',\n            'pixelarray',\n            'pypm',\n            'rect',\n            'rwobject',\n            'scrap',\n            'surface',\n            'surflock',\n            'time',\n            'transform',\n        ]\n\n        assert names == wanted\n\n    def test_extension_init(self):\n        # the first argument, which is the name, must be a string\n        with pytest.raises(TypeError):\n            Extension(1, [])\n        ext = Extension('name', [])\n        assert ext.name == 'name'\n\n        # the second argument, which is the list of files, must\n        # be an iterable of strings or PathLike objects, and not a string\n        with pytest.raises(TypeError):\n            Extension('name', 'file')\n        with pytest.raises(TypeError):\n            Extension('name', ['file', 1])\n        ext = Extension('name', ['file1', 'file2'])\n        assert ext.sources == ['file1', 'file2']\n        ext = Extension('name', [pathlib.Path('file1'), pathlib.Path('file2')])\n        assert ext.sources == ['file1', 'file2']\n\n        # any non-string iterable of strings or PathLike objects should work\n        ext = Extension('name', ('file1', 'file2'))  # tuple\n        assert ext.sources == ['file1', 'file2']\n        ext = Extension('name', {'file1', 'file2'})  # set\n        assert sorted(ext.sources) == ['file1', 'file2']\n        ext = Extension('name', iter(['file1', 'file2']))  # iterator\n        assert ext.sources == ['file1', 'file2']\n        ext = Extension('name', [pathlib.Path('file1'), 'file2'])  # mixed types\n        assert ext.sources == ['file1', 'file2']\n\n        # others arguments have defaults\n        for attr in (\n            'include_dirs',\n            'define_macros',\n            'undef_macros',\n            'library_dirs',\n            'libraries',\n            'runtime_library_dirs',\n            'extra_objects',\n            'extra_compile_args',\n            'extra_link_args',\n            'export_symbols',\n            'swig_opts',\n            'depends',\n        ):\n            assert getattr(ext, attr) == []\n\n        assert ext.language is None\n        assert ext.optional is None\n\n        # if there are unknown keyword options, warn about them\n        with check_warnings() as w:\n            warnings.simplefilter('always')\n            ext = Extension('name', ['file1', 'file2'], chic=True)\n\n        assert len(w.warnings) == 1\n        assert str(w.warnings[0].message) == \"Unknown Extension options: 'chic'\"\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_file_util.py","size":3522,"sha1":"b325e01cd46d39e741db372b92502954b2e7db5f","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.file_util.\"\"\"\n\nimport errno\nimport os\nimport unittest.mock as mock\nfrom distutils.errors import DistutilsFileError\nfrom distutils.file_util import copy_file, move_file\n\nimport jaraco.path\nimport pytest\n\n\n@pytest.fixture(autouse=True)\ndef stuff(request, tmp_path):\n    self = request.instance\n    self.source = tmp_path / 'f1'\n    self.target = tmp_path / 'f2'\n    self.target_dir = tmp_path / 'd1'\n\n\nclass TestFileUtil:\n    def test_move_file_verbosity(self, caplog):\n        jaraco.path.build({self.source: 'some content'})\n\n        move_file(self.source, self.target, verbose=False)\n        assert not caplog.messages\n\n        # back to original state\n        move_file(self.target, self.source, verbose=False)\n\n        move_file(self.source, self.target, verbose=True)\n        wanted = [f'moving {self.source} -> {self.target}']\n        assert caplog.messages == wanted\n\n        # back to original state\n        move_file(self.target, self.source, verbose=False)\n\n        caplog.clear()\n        # now the target is a dir\n        os.mkdir(self.target_dir)\n        move_file(self.source, self.target_dir, verbose=True)\n        wanted = [f'moving {self.source} -> {self.target_dir}']\n        assert caplog.messages == wanted\n\n    def test_move_file_exception_unpacking_rename(self):\n        # see issue 22182\n        with (\n            mock.patch(\"os.rename\", side_effect=OSError(\"wrong\", 1)),\n            pytest.raises(DistutilsFileError),\n        ):\n            jaraco.path.build({self.source: 'spam eggs'})\n            move_file(self.source, self.target, verbose=False)\n\n    def test_move_file_exception_unpacking_unlink(self):\n        # see issue 22182\n        with (\n            mock.patch(\"os.rename\", side_effect=OSError(errno.EXDEV, \"wrong\")),\n            mock.patch(\"os.unlink\", side_effect=OSError(\"wrong\", 1)),\n            pytest.raises(DistutilsFileError),\n        ):\n            jaraco.path.build({self.source: 'spam eggs'})\n            move_file(self.source, self.target, verbose=False)\n\n    def test_copy_file_hard_link(self):\n        jaraco.path.build({self.source: 'some content'})\n        # Check first that copy_file() will not fall back on copying the file\n        # instead of creating the hard link.\n        try:\n            os.link(self.source, self.target)\n        except OSError as e:\n            self.skipTest(f'os.link: {e}')\n        else:\n            self.target.unlink()\n        st = os.stat(self.source)\n        copy_file(self.source, self.target, link='hard')\n        st2 = os.stat(self.source)\n        st3 = os.stat(self.target)\n        assert os.path.samestat(st, st2), (st, st2)\n        assert os.path.samestat(st2, st3), (st2, st3)\n        assert self.source.read_text(encoding='utf-8') == 'some content'\n\n    def test_copy_file_hard_link_failure(self):\n        # If hard linking fails, copy_file() falls back on copying file\n        # (some special filesystems don't support hard linking even under\n        #  Unix, see issue #8876).\n        jaraco.path.build({self.source: 'some content'})\n        st = os.stat(self.source)\n        with mock.patch(\"os.link\", side_effect=OSError(0, \"linking unsupported\")):\n            copy_file(self.source, self.target, link='hard')\n        st2 = os.stat(self.source)\n        st3 = os.stat(self.target)\n        assert os.path.samestat(st, st2), (st, st2)\n        assert not os.path.samestat(st2, st3), (st2, st3)\n        for fn in (self.source, self.target):\n            assert fn.read_text(encoding='utf-8') == 'some content'\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_filelist.py","size":10766,"sha1":"e3e154db1027ca7e147f5c094be68f22bd4d299c","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.filelist.\"\"\"\n\nimport logging\nimport os\nimport re\nfrom distutils import debug, filelist\nfrom distutils.errors import DistutilsTemplateError\nfrom distutils.filelist import FileList, glob_to_re, translate_pattern\n\nimport jaraco.path\nimport pytest\n\nfrom .compat import py39 as os_helper\n\nMANIFEST_IN = \"\"\"\\\ninclude ok\ninclude xo\nexclude xo\ninclude foo.tmp\ninclude buildout.cfg\nglobal-include *.x\nglobal-include *.txt\nglobal-exclude *.tmp\nrecursive-include f *.oo\nrecursive-exclude global *.x\ngraft dir\nprune dir3\n\"\"\"\n\n\ndef make_local_path(s):\n    \"\"\"Converts '/' in a string to os.sep\"\"\"\n    return s.replace('/', os.sep)\n\n\nclass TestFileList:\n    def assertNoWarnings(self, caplog):\n        warnings = [rec for rec in caplog.records if rec.levelno == logging.WARNING]\n        assert not warnings\n        caplog.clear()\n\n    def assertWarnings(self, caplog):\n        warnings = [rec for rec in caplog.records if rec.levelno == logging.WARNING]\n        assert warnings\n        caplog.clear()\n\n    def test_glob_to_re(self):\n        sep = os.sep\n        if os.sep == '\\\\':\n            sep = re.escape(os.sep)\n\n        for glob, regex in (\n            # simple cases\n            ('foo*', r'(?s:foo[^%(sep)s]*)\\Z'),\n            ('foo?', r'(?s:foo[^%(sep)s])\\Z'),\n            ('foo??', r'(?s:foo[^%(sep)s][^%(sep)s])\\Z'),\n            # special cases\n            (r'foo\\\\*', r'(?s:foo\\\\\\\\[^%(sep)s]*)\\Z'),\n            (r'foo\\\\\\*', r'(?s:foo\\\\\\\\\\\\[^%(sep)s]*)\\Z'),\n            ('foo????', r'(?s:foo[^%(sep)s][^%(sep)s][^%(sep)s][^%(sep)s])\\Z'),\n            (r'foo\\\\??', r'(?s:foo\\\\\\\\[^%(sep)s][^%(sep)s])\\Z'),\n        ):\n            regex = regex % {'sep': sep}\n            assert glob_to_re(glob) == regex\n\n    def test_process_template_line(self):\n        # testing  all MANIFEST.in template patterns\n        file_list = FileList()\n        mlp = make_local_path\n\n        # simulated file list\n        file_list.allfiles = [\n            'foo.tmp',\n            'ok',\n            'xo',\n            'four.txt',\n            'buildout.cfg',\n            # filelist does not filter out VCS directories,\n            # it's sdist that does\n            mlp('.hg/last-message.txt'),\n            mlp('global/one.txt'),\n            mlp('global/two.txt'),\n            mlp('global/files.x'),\n            mlp('global/here.tmp'),\n            mlp('f/o/f.oo'),\n            mlp('dir/graft-one'),\n            mlp('dir/dir2/graft2'),\n            mlp('dir3/ok'),\n            mlp('dir3/sub/ok.txt'),\n        ]\n\n        for line in MANIFEST_IN.split('\\n'):\n            if line.strip() == '':\n                continue\n            file_list.process_template_line(line)\n\n        wanted = [\n            'ok',\n            'buildout.cfg',\n            'four.txt',\n            mlp('.hg/last-message.txt'),\n            mlp('global/one.txt'),\n            mlp('global/two.txt'),\n            mlp('f/o/f.oo'),\n            mlp('dir/graft-one'),\n            mlp('dir/dir2/graft2'),\n        ]\n\n        assert file_list.files == wanted\n\n    def test_debug_print(self, capsys, monkeypatch):\n        file_list = FileList()\n        file_list.debug_print('xxx')\n        assert capsys.readouterr().out == ''\n\n        monkeypatch.setattr(debug, 'DEBUG', True)\n        file_list.debug_print('xxx')\n        assert capsys.readouterr().out == 'xxx\\n'\n\n    def test_set_allfiles(self):\n        file_list = FileList()\n        files = ['a', 'b', 'c']\n        file_list.set_allfiles(files)\n        assert file_list.allfiles == files\n\n    def test_remove_duplicates(self):\n        file_list = FileList()\n        file_list.files = ['a', 'b', 'a', 'g', 'c', 'g']\n        # files must be sorted beforehand (sdist does it)\n        file_list.sort()\n        file_list.remove_duplicates()\n        assert file_list.files == ['a', 'b', 'c', 'g']\n\n    def test_translate_pattern(self):\n        # not regex\n        assert hasattr(translate_pattern('a', anchor=True, is_regex=False), 'search')\n\n        # is a regex\n        regex = re.compile('a')\n        assert translate_pattern(regex, anchor=True, is_regex=True) == regex\n\n        # plain string flagged as regex\n        assert hasattr(translate_pattern('a', anchor=True, is_regex=True), 'search')\n\n        # glob support\n        assert translate_pattern('*.py', anchor=True, is_regex=False).search(\n            'filelist.py'\n        )\n\n    def test_exclude_pattern(self):\n        # return False if no match\n        file_list = FileList()\n        assert not file_list.exclude_pattern('*.py')\n\n        # return True if files match\n        file_list = FileList()\n        file_list.files = ['a.py', 'b.py']\n        assert file_list.exclude_pattern('*.py')\n\n        # test excludes\n        file_list = FileList()\n        file_list.files = ['a.py', 'a.txt']\n        file_list.exclude_pattern('*.py')\n        assert file_list.files == ['a.txt']\n\n    def test_include_pattern(self):\n        # return False if no match\n        file_list = FileList()\n        file_list.set_allfiles([])\n        assert not file_list.include_pattern('*.py')\n\n        # return True if files match\n        file_list = FileList()\n        file_list.set_allfiles(['a.py', 'b.txt'])\n        assert file_list.include_pattern('*.py')\n\n        # test * matches all files\n        file_list = FileList()\n        assert file_list.allfiles is None\n        file_list.set_allfiles(['a.py', 'b.txt'])\n        file_list.include_pattern('*')\n        assert file_list.allfiles == ['a.py', 'b.txt']\n\n    def test_process_template(self, caplog):\n        mlp = make_local_path\n        # invalid lines\n        file_list = FileList()\n        for action in (\n            'include',\n            'exclude',\n            'global-include',\n            'global-exclude',\n            'recursive-include',\n            'recursive-exclude',\n            'graft',\n            'prune',\n            'blarg',\n        ):\n            with pytest.raises(DistutilsTemplateError):\n                file_list.process_template_line(action)\n\n        # include\n        file_list = FileList()\n        file_list.set_allfiles(['a.py', 'b.txt', mlp('d/c.py')])\n\n        file_list.process_template_line('include *.py')\n        assert file_list.files == ['a.py']\n        self.assertNoWarnings(caplog)\n\n        file_list.process_template_line('include *.rb')\n        assert file_list.files == ['a.py']\n        self.assertWarnings(caplog)\n\n        # exclude\n        file_list = FileList()\n        file_list.files = ['a.py', 'b.txt', mlp('d/c.py')]\n\n        file_list.process_template_line('exclude *.py')\n        assert file_list.files == ['b.txt', mlp('d/c.py')]\n        self.assertNoWarnings(caplog)\n\n        file_list.process_template_line('exclude *.rb')\n        assert file_list.files == ['b.txt', mlp('d/c.py')]\n        self.assertWarnings(caplog)\n\n        # global-include\n        file_list = FileList()\n        file_list.set_allfiles(['a.py', 'b.txt', mlp('d/c.py')])\n\n        file_list.process_template_line('global-include *.py')\n        assert file_list.files == ['a.py', mlp('d/c.py')]\n        self.assertNoWarnings(caplog)\n\n        file_list.process_template_line('global-include *.rb')\n        assert file_list.files == ['a.py', mlp('d/c.py')]\n        self.assertWarnings(caplog)\n\n        # global-exclude\n        file_list = FileList()\n        file_list.files = ['a.py', 'b.txt', mlp('d/c.py')]\n\n        file_list.process_template_line('global-exclude *.py')\n        assert file_list.files == ['b.txt']\n        self.assertNoWarnings(caplog)\n\n        file_list.process_template_line('global-exclude *.rb')\n        assert file_list.files == ['b.txt']\n        self.assertWarnings(caplog)\n\n        # recursive-include\n        file_list = FileList()\n        file_list.set_allfiles(['a.py', mlp('d/b.py'), mlp('d/c.txt'), mlp('d/d/e.py')])\n\n        file_list.process_template_line('recursive-include d *.py')\n        assert file_list.files == [mlp('d/b.py'), mlp('d/d/e.py')]\n        self.assertNoWarnings(caplog)\n\n        file_list.process_template_line('recursive-include e *.py')\n        assert file_list.files == [mlp('d/b.py'), mlp('d/d/e.py')]\n        self.assertWarnings(caplog)\n\n        # recursive-exclude\n        file_list = FileList()\n        file_list.files = ['a.py', mlp('d/b.py'), mlp('d/c.txt'), mlp('d/d/e.py')]\n\n        file_list.process_template_line('recursive-exclude d *.py')\n        assert file_list.files == ['a.py', mlp('d/c.txt')]\n        self.assertNoWarnings(caplog)\n\n        file_list.process_template_line('recursive-exclude e *.py')\n        assert file_list.files == ['a.py', mlp('d/c.txt')]\n        self.assertWarnings(caplog)\n\n        # graft\n        file_list = FileList()\n        file_list.set_allfiles(['a.py', mlp('d/b.py'), mlp('d/d/e.py'), mlp('f/f.py')])\n\n        file_list.process_template_line('graft d')\n        assert file_list.files == [mlp('d/b.py'), mlp('d/d/e.py')]\n        self.assertNoWarnings(caplog)\n\n        file_list.process_template_line('graft e')\n        assert file_list.files == [mlp('d/b.py'), mlp('d/d/e.py')]\n        self.assertWarnings(caplog)\n\n        # prune\n        file_list = FileList()\n        file_list.files = ['a.py', mlp('d/b.py'), mlp('d/d/e.py'), mlp('f/f.py')]\n\n        file_list.process_template_line('prune d')\n        assert file_list.files == ['a.py', mlp('f/f.py')]\n        self.assertNoWarnings(caplog)\n\n        file_list.process_template_line('prune e')\n        assert file_list.files == ['a.py', mlp('f/f.py')]\n        self.assertWarnings(caplog)\n\n\nclass TestFindAll:\n    @os_helper.skip_unless_symlink\n    def test_missing_symlink(self, temp_cwd):\n        os.symlink('foo', 'bar')\n        assert filelist.findall() == []\n\n    def test_basic_discovery(self, temp_cwd):\n        \"\"\"\n        When findall is called with no parameters or with\n        '.' as the parameter, the dot should be omitted from\n        the results.\n        \"\"\"\n        jaraco.path.build({'foo': {'file1.txt': ''}, 'bar': {'file2.txt': ''}})\n        file1 = os.path.join('foo', 'file1.txt')\n        file2 = os.path.join('bar', 'file2.txt')\n        expected = [file2, file1]\n        assert sorted(filelist.findall()) == expected\n\n    def test_non_local_discovery(self, tmp_path):\n        \"\"\"\n        When findall is called with another path, the full\n        path name should be returned.\n        \"\"\"\n        jaraco.path.build({'file1.txt': ''}, tmp_path)\n        expected = [str(tmp_path / 'file1.txt')]\n        assert filelist.findall(tmp_path) == expected\n\n    @os_helper.skip_unless_symlink\n    def test_symlink_loop(self, tmp_path):\n        jaraco.path.build(\n            {\n                'link-to-parent': jaraco.path.Symlink('.'),\n                'somefile': '',\n            },\n            tmp_path,\n        )\n        files = filelist.findall(tmp_path)\n        assert len(files) == 1\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_install.py","size":8618,"sha1":"381bb105a147fc2a99320db664b1e654e64658bc","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.command.install.\"\"\"\n\nimport logging\nimport os\nimport pathlib\nimport site\nimport sys\nfrom distutils import sysconfig\nfrom distutils.command import install as install_module\nfrom distutils.command.build_ext import build_ext\nfrom distutils.command.install import INSTALL_SCHEMES, install\nfrom distutils.core import Distribution\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.extension import Extension\nfrom distutils.tests import missing_compiler_executable, support\nfrom distutils.util import is_mingw\n\nimport pytest\n\n\ndef _make_ext_name(modname):\n    return modname + sysconfig.get_config_var('EXT_SUFFIX')\n\n\n@support.combine_markers\n@pytest.mark.usefixtures('save_env')\nclass TestInstall(\n    support.TempdirManager,\n):\n    @pytest.mark.xfail(\n        'platform.system() == \"Windows\" and sys.version_info > (3, 11)',\n        reason=\"pypa/distutils#148\",\n    )\n    def test_home_installation_scheme(self):\n        # This ensure two things:\n        # - that --home generates the desired set of directory names\n        # - test --home is supported on all platforms\n        builddir = self.mkdtemp()\n        destination = os.path.join(builddir, \"installation\")\n\n        dist = Distribution({\"name\": \"foopkg\"})\n        # script_name need not exist, it just need to be initialized\n        dist.script_name = os.path.join(builddir, \"setup.py\")\n        dist.command_obj[\"build\"] = support.DummyCommand(\n            build_base=builddir,\n            build_lib=os.path.join(builddir, \"lib\"),\n        )\n\n        cmd = install(dist)\n        cmd.home = destination\n        cmd.ensure_finalized()\n\n        assert cmd.install_base == destination\n        assert cmd.install_platbase == destination\n\n        def check_path(got, expected):\n            got = os.path.normpath(got)\n            expected = os.path.normpath(expected)\n            assert got == expected\n\n        impl_name = sys.implementation.name.replace(\"cpython\", \"python\")\n        libdir = os.path.join(destination, \"lib\", impl_name)\n        check_path(cmd.install_lib, libdir)\n        _platlibdir = getattr(sys, \"platlibdir\", \"lib\")\n        platlibdir = os.path.join(destination, _platlibdir, impl_name)\n        check_path(cmd.install_platlib, platlibdir)\n        check_path(cmd.install_purelib, libdir)\n        check_path(\n            cmd.install_headers,\n            os.path.join(destination, \"include\", impl_name, \"foopkg\"),\n        )\n        check_path(cmd.install_scripts, os.path.join(destination, \"bin\"))\n        check_path(cmd.install_data, destination)\n\n    def test_user_site(self, monkeypatch):\n        # test install with --user\n        # preparing the environment for the test\n        self.tmpdir = self.mkdtemp()\n        orig_site = site.USER_SITE\n        orig_base = site.USER_BASE\n        monkeypatch.setattr(site, 'USER_BASE', os.path.join(self.tmpdir, 'B'))\n        monkeypatch.setattr(site, 'USER_SITE', os.path.join(self.tmpdir, 'S'))\n        monkeypatch.setattr(install_module, 'USER_BASE', site.USER_BASE)\n        monkeypatch.setattr(install_module, 'USER_SITE', site.USER_SITE)\n\n        def _expanduser(path):\n            if path.startswith('~'):\n                return os.path.normpath(self.tmpdir + path[1:])\n            return path\n\n        monkeypatch.setattr(os.path, 'expanduser', _expanduser)\n\n        for key in ('nt_user', 'posix_user'):\n            assert key in INSTALL_SCHEMES\n\n        dist = Distribution({'name': 'xx'})\n        cmd = install(dist)\n\n        # making sure the user option is there\n        options = [name for name, short, label in cmd.user_options]\n        assert 'user' in options\n\n        # setting a value\n        cmd.user = True\n\n        # user base and site shouldn't be created yet\n        assert not os.path.exists(site.USER_BASE)\n        assert not os.path.exists(site.USER_SITE)\n\n        # let's run finalize\n        cmd.ensure_finalized()\n\n        # now they should\n        assert os.path.exists(site.USER_BASE)\n        assert os.path.exists(site.USER_SITE)\n\n        assert 'userbase' in cmd.config_vars\n        assert 'usersite' in cmd.config_vars\n\n        actual_headers = os.path.relpath(cmd.install_headers, site.USER_BASE)\n        if os.name == 'nt' and not is_mingw():\n            site_path = os.path.relpath(os.path.dirname(orig_site), orig_base)\n            include = os.path.join(site_path, 'Include')\n        else:\n            include = sysconfig.get_python_inc(0, '')\n        expect_headers = os.path.join(include, 'xx')\n\n        assert os.path.normcase(actual_headers) == os.path.normcase(expect_headers)\n\n    def test_handle_extra_path(self):\n        dist = Distribution({'name': 'xx', 'extra_path': 'path,dirs'})\n        cmd = install(dist)\n\n        # two elements\n        cmd.handle_extra_path()\n        assert cmd.extra_path == ['path', 'dirs']\n        assert cmd.extra_dirs == 'dirs'\n        assert cmd.path_file == 'path'\n\n        # one element\n        cmd.extra_path = ['path']\n        cmd.handle_extra_path()\n        assert cmd.extra_path == ['path']\n        assert cmd.extra_dirs == 'path'\n        assert cmd.path_file == 'path'\n\n        # none\n        dist.extra_path = cmd.extra_path = None\n        cmd.handle_extra_path()\n        assert cmd.extra_path is None\n        assert cmd.extra_dirs == ''\n        assert cmd.path_file is None\n\n        # three elements (no way !)\n        cmd.extra_path = 'path,dirs,again'\n        with pytest.raises(DistutilsOptionError):\n            cmd.handle_extra_path()\n\n    def test_finalize_options(self):\n        dist = Distribution({'name': 'xx'})\n        cmd = install(dist)\n\n        # must supply either prefix/exec-prefix/home or\n        # install-base/install-platbase -- not both\n        cmd.prefix = 'prefix'\n        cmd.install_base = 'base'\n        with pytest.raises(DistutilsOptionError):\n            cmd.finalize_options()\n\n        # must supply either home or prefix/exec-prefix -- not both\n        cmd.install_base = None\n        cmd.home = 'home'\n        with pytest.raises(DistutilsOptionError):\n            cmd.finalize_options()\n\n        # can't combine user with prefix/exec_prefix/home or\n        # install_(plat)base\n        cmd.prefix = None\n        cmd.user = 'user'\n        with pytest.raises(DistutilsOptionError):\n            cmd.finalize_options()\n\n    def test_record(self):\n        install_dir = self.mkdtemp()\n        project_dir, dist = self.create_dist(py_modules=['hello'], scripts=['sayhi'])\n        os.chdir(project_dir)\n        self.write_file('hello.py', \"def main(): print('o hai')\")\n        self.write_file('sayhi', 'from hello import main; main()')\n\n        cmd = install(dist)\n        dist.command_obj['install'] = cmd\n        cmd.root = install_dir\n        cmd.record = os.path.join(project_dir, 'filelist')\n        cmd.ensure_finalized()\n        cmd.run()\n\n        content = pathlib.Path(cmd.record).read_text(encoding='utf-8')\n\n        found = [pathlib.Path(line).name for line in content.splitlines()]\n        expected = [\n            'hello.py',\n            f'hello.{sys.implementation.cache_tag}.pyc',\n            'sayhi',\n            'UNKNOWN-0.0.0-py{}.{}.egg-info'.format(*sys.version_info[:2]),\n        ]\n        assert found == expected\n\n    def test_record_extensions(self):\n        cmd = missing_compiler_executable()\n        if cmd is not None:\n            pytest.skip(f'The {cmd!r} command is not found')\n        install_dir = self.mkdtemp()\n        project_dir, dist = self.create_dist(\n            ext_modules=[Extension('xx', ['xxmodule.c'])]\n        )\n        os.chdir(project_dir)\n        support.copy_xxmodule_c(project_dir)\n\n        buildextcmd = build_ext(dist)\n        support.fixup_build_ext(buildextcmd)\n        buildextcmd.ensure_finalized()\n\n        cmd = install(dist)\n        dist.command_obj['install'] = cmd\n        dist.command_obj['build_ext'] = buildextcmd\n        cmd.root = install_dir\n        cmd.record = os.path.join(project_dir, 'filelist')\n        cmd.ensure_finalized()\n        cmd.run()\n\n        content = pathlib.Path(cmd.record).read_text(encoding='utf-8')\n\n        found = [pathlib.Path(line).name for line in content.splitlines()]\n        expected = [\n            _make_ext_name('xx'),\n            'UNKNOWN-0.0.0-py{}.{}.egg-info'.format(*sys.version_info[:2]),\n        ]\n        assert found == expected\n\n    def test_debug_mode(self, caplog, monkeypatch):\n        # this covers the code called when DEBUG is set\n        monkeypatch.setattr(install_module, 'DEBUG', True)\n        caplog.set_level(logging.DEBUG)\n        self.test_record()\n        assert any(rec for rec in caplog.records if rec.levelno == logging.DEBUG)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_install_data.py","size":2464,"sha1":"47b231b73bfe2970b41c38089fec57188da95d20","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.command.install_data.\"\"\"\n\nimport os\nimport pathlib\nfrom distutils.command.install_data import install_data\nfrom distutils.tests import support\n\nimport pytest\n\n\n@pytest.mark.usefixtures('save_env')\nclass TestInstallData(\n    support.TempdirManager,\n):\n    def test_simple_run(self):\n        pkg_dir, dist = self.create_dist()\n        cmd = install_data(dist)\n        cmd.install_dir = inst = os.path.join(pkg_dir, 'inst')\n\n        # data_files can contain\n        #  - simple files\n        #  - a Path object\n        #  - a tuple with a path, and a list of file\n        one = os.path.join(pkg_dir, 'one')\n        self.write_file(one, 'xxx')\n        inst2 = os.path.join(pkg_dir, 'inst2')\n        two = os.path.join(pkg_dir, 'two')\n        self.write_file(two, 'xxx')\n        three = pathlib.Path(pkg_dir) / 'three'\n        self.write_file(three, 'xxx')\n\n        cmd.data_files = [one, (inst2, [two]), three]\n        assert cmd.get_inputs() == [one, (inst2, [two]), three]\n\n        # let's run the command\n        cmd.ensure_finalized()\n        cmd.run()\n\n        # let's check the result\n        assert len(cmd.get_outputs()) == 3\n        rthree = os.path.split(one)[-1]\n        assert os.path.exists(os.path.join(inst, rthree))\n        rtwo = os.path.split(two)[-1]\n        assert os.path.exists(os.path.join(inst2, rtwo))\n        rone = os.path.split(one)[-1]\n        assert os.path.exists(os.path.join(inst, rone))\n        cmd.outfiles = []\n\n        # let's try with warn_dir one\n        cmd.warn_dir = True\n        cmd.ensure_finalized()\n        cmd.run()\n\n        # let's check the result\n        assert len(cmd.get_outputs()) == 3\n        assert os.path.exists(os.path.join(inst, rthree))\n        assert os.path.exists(os.path.join(inst2, rtwo))\n        assert os.path.exists(os.path.join(inst, rone))\n        cmd.outfiles = []\n\n        # now using root and empty dir\n        cmd.root = os.path.join(pkg_dir, 'root')\n        inst5 = os.path.join(pkg_dir, 'inst5')\n        four = os.path.join(cmd.install_dir, 'four')\n        self.write_file(four, 'xx')\n        cmd.data_files = [one, (inst2, [two]), three, ('inst5', [four]), (inst5, [])]\n        cmd.ensure_finalized()\n        cmd.run()\n\n        # let's check the result\n        assert len(cmd.get_outputs()) == 5\n        assert os.path.exists(os.path.join(inst, rthree))\n        assert os.path.exists(os.path.join(inst2, rtwo))\n        assert os.path.exists(os.path.join(inst, rone))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_install_headers.py","size":936,"sha1":"6adbba009248b5ba6b33556a44afb6e937a12a3a","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.command.install_headers.\"\"\"\n\nimport os\nfrom distutils.command.install_headers import install_headers\nfrom distutils.tests import support\n\nimport pytest\n\n\n@pytest.mark.usefixtures('save_env')\nclass TestInstallHeaders(\n    support.TempdirManager,\n):\n    def test_simple_run(self):\n        # we have two headers\n        header_list = self.mkdtemp()\n        header1 = os.path.join(header_list, 'header1')\n        header2 = os.path.join(header_list, 'header2')\n        self.write_file(header1)\n        self.write_file(header2)\n        headers = [header1, header2]\n\n        pkg_dir, dist = self.create_dist(headers=headers)\n        cmd = install_headers(dist)\n        assert cmd.get_inputs() == headers\n\n        # let's run the command\n        cmd.install_dir = os.path.join(pkg_dir, 'inst')\n        cmd.ensure_finalized()\n        cmd.run()\n\n        # let's check the results\n        assert len(cmd.get_outputs()) == 2\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_install_lib.py","size":3612,"sha1":"107d3f578a4d3b2fdd9e6189a4fc998a0c2974d3","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.command.install_data.\"\"\"\n\nimport importlib.util\nimport os\nimport sys\nfrom distutils.command.install_lib import install_lib\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.extension import Extension\nfrom distutils.tests import support\n\nimport pytest\n\n\n@support.combine_markers\n@pytest.mark.usefixtures('save_env')\nclass TestInstallLib(\n    support.TempdirManager,\n):\n    def test_finalize_options(self):\n        dist = self.create_dist()[1]\n        cmd = install_lib(dist)\n\n        cmd.finalize_options()\n        assert cmd.compile == 1\n        assert cmd.optimize == 0\n\n        # optimize must be 0, 1, or 2\n        cmd.optimize = 'foo'\n        with pytest.raises(DistutilsOptionError):\n            cmd.finalize_options()\n        cmd.optimize = '4'\n        with pytest.raises(DistutilsOptionError):\n            cmd.finalize_options()\n\n        cmd.optimize = '2'\n        cmd.finalize_options()\n        assert cmd.optimize == 2\n\n    @pytest.mark.skipif('sys.dont_write_bytecode')\n    def test_byte_compile(self):\n        project_dir, dist = self.create_dist()\n        os.chdir(project_dir)\n        cmd = install_lib(dist)\n        cmd.compile = cmd.optimize = 1\n\n        f = os.path.join(project_dir, 'foo.py')\n        self.write_file(f, '# python file')\n        cmd.byte_compile([f])\n        pyc_file = importlib.util.cache_from_source('foo.py', optimization='')\n        pyc_opt_file = importlib.util.cache_from_source(\n            'foo.py', optimization=cmd.optimize\n        )\n        assert os.path.exists(pyc_file)\n        assert os.path.exists(pyc_opt_file)\n\n    def test_get_outputs(self):\n        project_dir, dist = self.create_dist()\n        os.chdir(project_dir)\n        os.mkdir('spam')\n        cmd = install_lib(dist)\n\n        # setting up a dist environment\n        cmd.compile = cmd.optimize = 1\n        cmd.install_dir = self.mkdtemp()\n        f = os.path.join(project_dir, 'spam', '__init__.py')\n        self.write_file(f, '# python package')\n        cmd.distribution.ext_modules = [Extension('foo', ['xxx'])]\n        cmd.distribution.packages = ['spam']\n        cmd.distribution.script_name = 'setup.py'\n\n        # get_outputs should return 4 elements: spam/__init__.py and .pyc,\n        # foo.import-tag-abiflags.so / foo.pyd\n        outputs = cmd.get_outputs()\n        assert len(outputs) == 4, outputs\n\n    def test_get_inputs(self):\n        project_dir, dist = self.create_dist()\n        os.chdir(project_dir)\n        os.mkdir('spam')\n        cmd = install_lib(dist)\n\n        # setting up a dist environment\n        cmd.compile = cmd.optimize = 1\n        cmd.install_dir = self.mkdtemp()\n        f = os.path.join(project_dir, 'spam', '__init__.py')\n        self.write_file(f, '# python package')\n        cmd.distribution.ext_modules = [Extension('foo', ['xxx'])]\n        cmd.distribution.packages = ['spam']\n        cmd.distribution.script_name = 'setup.py'\n\n        # get_inputs should return 2 elements: spam/__init__.py and\n        # foo.import-tag-abiflags.so / foo.pyd\n        inputs = cmd.get_inputs()\n        assert len(inputs) == 2, inputs\n\n    def test_dont_write_bytecode(self, caplog):\n        # makes sure byte_compile is not used\n        dist = self.create_dist()[1]\n        cmd = install_lib(dist)\n        cmd.compile = True\n        cmd.optimize = 1\n\n        old_dont_write_bytecode = sys.dont_write_bytecode\n        sys.dont_write_bytecode = True\n        try:\n            cmd.byte_compile([])\n        finally:\n            sys.dont_write_bytecode = old_dont_write_bytecode\n\n        assert 'byte-compiling is disabled' in caplog.messages[0]\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_install_scripts.py","size":1600,"sha1":"39cf15baab00b5499debfdf5c0b2eb2a07909351","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.command.install_scripts.\"\"\"\n\nimport os\nfrom distutils.command.install_scripts import install_scripts\nfrom distutils.core import Distribution\nfrom distutils.tests import support\n\nfrom . import test_build_scripts\n\n\nclass TestInstallScripts(support.TempdirManager):\n    def test_default_settings(self):\n        dist = Distribution()\n        dist.command_obj[\"build\"] = support.DummyCommand(build_scripts=\"/foo/bar\")\n        dist.command_obj[\"install\"] = support.DummyCommand(\n            install_scripts=\"/splat/funk\",\n            force=True,\n            skip_build=True,\n        )\n        cmd = install_scripts(dist)\n        assert not cmd.force\n        assert not cmd.skip_build\n        assert cmd.build_dir is None\n        assert cmd.install_dir is None\n\n        cmd.finalize_options()\n\n        assert cmd.force\n        assert cmd.skip_build\n        assert cmd.build_dir == \"/foo/bar\"\n        assert cmd.install_dir == \"/splat/funk\"\n\n    def test_installation(self):\n        source = self.mkdtemp()\n\n        expected = test_build_scripts.TestBuildScripts.write_sample_scripts(source)\n\n        target = self.mkdtemp()\n        dist = Distribution()\n        dist.command_obj[\"build\"] = support.DummyCommand(build_scripts=source)\n        dist.command_obj[\"install\"] = support.DummyCommand(\n            install_scripts=target,\n            force=True,\n            skip_build=True,\n        )\n        cmd = install_scripts(dist)\n        cmd.finalize_options()\n        cmd.run()\n\n        installed = os.listdir(target)\n        for name in expected:\n            assert name in installed\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_log.py","size":323,"sha1":"c5a64333c53f39682255104fa1c70a15c1976004","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.log\"\"\"\n\nimport logging\nfrom distutils._log import log\n\n\nclass TestLog:\n    def test_non_ascii(self, caplog):\n        caplog.set_level(logging.DEBUG)\n        log.debug('Dεbug\\tMėssãge')\n        log.fatal('Fαtal\\tÈrrōr')\n        assert caplog.messages == ['Dεbug\\tMėssãge', 'Fαtal\\tÈrrōr']\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_mingwccompiler.py","size":2202,"sha1":"8d9b0dfbb56fff6b8f230b3003c53e89450d329c","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from distutils import sysconfig\nfrom distutils.errors import CCompilerError, DistutilsPlatformError\nfrom distutils.util import is_mingw, split_quoted\n\nimport pytest\n\n\nclass TestMingw32CCompiler:\n    @pytest.mark.skipif(not is_mingw(), reason='not on mingw')\n    def test_compiler_type(self):\n        from distutils.cygwinccompiler import Mingw32CCompiler\n\n        compiler = Mingw32CCompiler()\n        assert compiler.compiler_type == 'mingw32'\n\n    @pytest.mark.skipif(not is_mingw(), reason='not on mingw')\n    def test_set_executables(self, monkeypatch):\n        from distutils.cygwinccompiler import Mingw32CCompiler\n\n        monkeypatch.setenv('CC', 'cc')\n        monkeypatch.setenv('CXX', 'c++')\n\n        compiler = Mingw32CCompiler()\n\n        assert compiler.compiler == split_quoted('cc -O -Wall')\n        assert compiler.compiler_so == split_quoted('cc -shared -O -Wall')\n        assert compiler.compiler_cxx == split_quoted('c++ -O -Wall')\n        assert compiler.linker_exe == split_quoted('cc')\n        assert compiler.linker_so == split_quoted('cc -shared')\n\n    @pytest.mark.skipif(not is_mingw(), reason='not on mingw')\n    def test_runtime_library_dir_option(self):\n        from distutils.cygwinccompiler import Mingw32CCompiler\n\n        compiler = Mingw32CCompiler()\n        with pytest.raises(DistutilsPlatformError):\n            compiler.runtime_library_dir_option('/usr/lib')\n\n    @pytest.mark.skipif(not is_mingw(), reason='not on mingw')\n    def test_cygwincc_error(self, monkeypatch):\n        import distutils.cygwinccompiler\n\n        monkeypatch.setattr(distutils.cygwinccompiler, 'is_cygwincc', lambda _: True)\n\n        with pytest.raises(CCompilerError):\n            distutils.cygwinccompiler.Mingw32CCompiler()\n\n    @pytest.mark.skipif('sys.platform == \"cygwin\"')\n    def test_customize_compiler_with_msvc_python(self):\n        from distutils.cygwinccompiler import Mingw32CCompiler\n\n        # In case we have an MSVC Python build, but still want to use\n        # Mingw32CCompiler, then customize_compiler() shouldn't fail at least.\n        # https://github.com/pypa/setuptools/issues/4456\n        compiler = Mingw32CCompiler()\n        sysconfig.customize_compiler(compiler)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_modified.py","size":4221,"sha1":"2c5fb0ef1e7f6257e086117da6005db7b66274f0","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils._modified.\"\"\"\n\nimport os\nimport types\nfrom distutils._modified import newer, newer_group, newer_pairwise, newer_pairwise_group\nfrom distutils.errors import DistutilsFileError\nfrom distutils.tests import support\n\nimport pytest\n\n\nclass TestDepUtil(support.TempdirManager):\n    def test_newer(self):\n        tmpdir = self.mkdtemp()\n        new_file = os.path.join(tmpdir, 'new')\n        old_file = os.path.abspath(__file__)\n\n        # Raise DistutilsFileError if 'new_file' does not exist.\n        with pytest.raises(DistutilsFileError):\n            newer(new_file, old_file)\n\n        # Return true if 'new_file' exists and is more recently modified than\n        # 'old_file', or if 'new_file' exists and 'old_file' doesn't.\n        self.write_file(new_file)\n        assert newer(new_file, 'I_dont_exist')\n        assert newer(new_file, old_file)\n\n        # Return false if both exist and 'old_file' is the same age or younger\n        # than 'new_file'.\n        assert not newer(old_file, new_file)\n\n    def _setup_1234(self):\n        tmpdir = self.mkdtemp()\n        sources = os.path.join(tmpdir, 'sources')\n        targets = os.path.join(tmpdir, 'targets')\n        os.mkdir(sources)\n        os.mkdir(targets)\n        one = os.path.join(sources, 'one')\n        two = os.path.join(sources, 'two')\n        three = os.path.abspath(__file__)  # I am the old file\n        four = os.path.join(targets, 'four')\n        self.write_file(one)\n        self.write_file(two)\n        self.write_file(four)\n        return one, two, three, four\n\n    def test_newer_pairwise(self):\n        one, two, three, four = self._setup_1234()\n\n        assert newer_pairwise([one, two], [three, four]) == ([one], [three])\n\n    def test_newer_pairwise_mismatch(self):\n        one, two, three, four = self._setup_1234()\n\n        with pytest.raises(ValueError):\n            newer_pairwise([one], [three, four])\n\n        with pytest.raises(ValueError):\n            newer_pairwise([one, two], [three])\n\n    def test_newer_pairwise_empty(self):\n        assert newer_pairwise([], []) == ([], [])\n\n    def test_newer_pairwise_fresh(self):\n        one, two, three, four = self._setup_1234()\n\n        assert newer_pairwise([one, three], [two, four]) == ([], [])\n\n    def test_newer_group(self):\n        tmpdir = self.mkdtemp()\n        sources = os.path.join(tmpdir, 'sources')\n        os.mkdir(sources)\n        one = os.path.join(sources, 'one')\n        two = os.path.join(sources, 'two')\n        three = os.path.join(sources, 'three')\n        old_file = os.path.abspath(__file__)\n\n        # return true if 'old_file' is out-of-date with respect to any file\n        # listed in 'sources'.\n        self.write_file(one)\n        self.write_file(two)\n        self.write_file(three)\n        assert newer_group([one, two, three], old_file)\n        assert not newer_group([one, two, old_file], three)\n\n        # missing handling\n        os.remove(one)\n        with pytest.raises(OSError):\n            newer_group([one, two, old_file], three)\n\n        assert not newer_group([one, two, old_file], three, missing='ignore')\n\n        assert newer_group([one, two, old_file], three, missing='newer')\n\n\n@pytest.fixture\ndef groups_target(tmp_path):\n    \"\"\"\n    Set up some older sources, a target, and newer sources.\n\n    Returns a simple namespace with these values.\n    \"\"\"\n    filenames = ['older.c', 'older.h', 'target.o', 'newer.c', 'newer.h']\n    paths = [tmp_path / name for name in filenames]\n\n    for mtime, path in enumerate(paths):\n        path.write_text('', encoding='utf-8')\n\n        # make sure modification times are sequential\n        os.utime(path, (mtime, mtime))\n\n    return types.SimpleNamespace(older=paths[:2], target=paths[2], newer=paths[3:])\n\n\ndef test_newer_pairwise_group(groups_target):\n    older = newer_pairwise_group([groups_target.older], [groups_target.target])\n    newer = newer_pairwise_group([groups_target.newer], [groups_target.target])\n    assert older == ([], [])\n    assert newer == ([groups_target.newer], [groups_target.target])\n\n\ndef test_newer_group_no_sources_no_target(tmp_path):\n    \"\"\"\n    Consider no sources and no target \"newer\".\n    \"\"\"\n    assert newer_group([], str(tmp_path / 'does-not-exist'))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_msvccompiler.py","size":4301,"sha1":"580052c7399c7f3dea1290337c022cb3fc9e916b","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils._msvccompiler.\"\"\"\n\nimport os\nimport sys\nimport sysconfig\nimport threading\nimport unittest.mock as mock\nfrom distutils import _msvccompiler\nfrom distutils.errors import DistutilsPlatformError\nfrom distutils.tests import support\nfrom distutils.util import get_platform\n\nimport pytest\n\nneeds_winreg = pytest.mark.skipif('not hasattr(_msvccompiler, \"winreg\")')\n\n\nclass Testmsvccompiler(support.TempdirManager):\n    def test_no_compiler(self, monkeypatch):\n        # makes sure query_vcvarsall raises\n        # a DistutilsPlatformError if the compiler\n        # is not found\n        def _find_vcvarsall(plat_spec):\n            return None, None\n\n        monkeypatch.setattr(_msvccompiler, '_find_vcvarsall', _find_vcvarsall)\n\n        with pytest.raises(DistutilsPlatformError):\n            _msvccompiler._get_vc_env(\n                'wont find this version',\n            )\n\n    @pytest.mark.skipif(\n        not sysconfig.get_platform().startswith(\"win\"),\n        reason=\"Only run test for non-mingw Windows platforms\",\n    )\n    @pytest.mark.parametrize(\n        \"plat_name, expected\",\n        [\n            (\"win-arm64\", \"win-arm64\"),\n            (\"win-amd64\", \"win-amd64\"),\n            (None, get_platform()),\n        ],\n    )\n    def test_cross_platform_compilation_paths(self, monkeypatch, plat_name, expected):\n        \"\"\"\n        Ensure a specified target platform is passed to _get_vcvars_spec.\n        \"\"\"\n        compiler = _msvccompiler.MSVCCompiler()\n\n        def _get_vcvars_spec(host_platform, platform):\n            assert platform == expected\n\n        monkeypatch.setattr(_msvccompiler, '_get_vcvars_spec', _get_vcvars_spec)\n        compiler.initialize(plat_name)\n\n    @needs_winreg\n    def test_get_vc_env_unicode(self):\n        test_var = 'ṰḖṤṪ┅ṼẨṜ'\n        test_value = '₃⁴₅'\n\n        # Ensure we don't early exit from _get_vc_env\n        old_distutils_use_sdk = os.environ.pop('DISTUTILS_USE_SDK', None)\n        os.environ[test_var] = test_value\n        try:\n            env = _msvccompiler._get_vc_env('x86')\n            assert test_var.lower() in env\n            assert test_value == env[test_var.lower()]\n        finally:\n            os.environ.pop(test_var)\n            if old_distutils_use_sdk:\n                os.environ['DISTUTILS_USE_SDK'] = old_distutils_use_sdk\n\n    @needs_winreg\n    @pytest.mark.parametrize('ver', (2015, 2017))\n    def test_get_vc(self, ver):\n        # This function cannot be mocked, so pass if VC is found\n        # and skip otherwise.\n        lookup = getattr(_msvccompiler, f'_find_vc{ver}')\n        expected_version = {2015: 14, 2017: 15}[ver]\n        version, path = lookup()\n        if not version:\n            pytest.skip(f\"VS {ver} is not installed\")\n        assert version >= expected_version\n        assert os.path.isdir(path)\n\n\nclass CheckThread(threading.Thread):\n    exc_info = None\n\n    def run(self):\n        try:\n            super().run()\n        except Exception:\n            self.exc_info = sys.exc_info()\n\n    def __bool__(self):\n        return not self.exc_info\n\n\nclass TestSpawn:\n    def test_concurrent_safe(self):\n        \"\"\"\n        Concurrent calls to spawn should have consistent results.\n        \"\"\"\n        compiler = _msvccompiler.MSVCCompiler()\n        compiler._paths = \"expected\"\n        inner_cmd = 'import os; assert os.environ[\"PATH\"] == \"expected\"'\n        command = [sys.executable, '-c', inner_cmd]\n\n        threads = [\n            CheckThread(target=compiler.spawn, args=[command]) for n in range(100)\n        ]\n        for thread in threads:\n            thread.start()\n        for thread in threads:\n            thread.join()\n        assert all(threads)\n\n    def test_concurrent_safe_fallback(self):\n        \"\"\"\n        If CCompiler.spawn has been monkey-patched without support\n        for an env, it should still execute.\n        \"\"\"\n        from distutils import ccompiler\n\n        compiler = _msvccompiler.MSVCCompiler()\n        compiler._paths = \"expected\"\n\n        def CCompiler_spawn(self, cmd):\n            \"A spawn without an env argument.\"\n            assert os.environ[\"PATH\"] == \"expected\"\n\n        with mock.patch.object(ccompiler.CCompiler, 'spawn', CCompiler_spawn):\n            compiler.spawn([\"n/a\"])\n\n        assert os.environ.get(\"PATH\") != \"expected\"\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_sdist.py","size":15058,"sha1":"19c00147bba66d12b27ffe790ea8046731aa1916","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.command.sdist.\"\"\"\n\nimport os\nimport pathlib\nimport shutil  # noqa: F401\nimport tarfile\nimport zipfile\nfrom distutils.archive_util import ARCHIVE_FORMATS\nfrom distutils.command.sdist import sdist, show_formats\nfrom distutils.core import Distribution\nfrom distutils.errors import DistutilsOptionError\nfrom distutils.filelist import FileList\nfrom os.path import join\nfrom textwrap import dedent\n\nimport jaraco.path\nimport path\nimport pytest\nfrom more_itertools import ilen\n\nfrom . import support\nfrom .unix_compat import grp, pwd, require_uid_0, require_unix_id\n\nSETUP_PY = \"\"\"\nfrom distutils.core import setup\nimport somecode\n\nsetup(name='fake')\n\"\"\"\n\nMANIFEST = \"\"\"\\\n# file GENERATED by distutils, do NOT edit\nREADME\nbuildout.cfg\ninroot.txt\nsetup.py\ndata%(sep)sdata.dt\nscripts%(sep)sscript.py\nsome%(sep)sfile.txt\nsome%(sep)sother_file.txt\nsomecode%(sep)s__init__.py\nsomecode%(sep)sdoc.dat\nsomecode%(sep)sdoc.txt\n\"\"\"\n\n\n@pytest.fixture(autouse=True)\ndef project_dir(request, distutils_managed_tempdir):\n    self = request.instance\n    self.tmp_dir = self.mkdtemp()\n    jaraco.path.build(\n        {\n            'somecode': {\n                '__init__.py': '#',\n            },\n            'README': 'xxx',\n            'setup.py': SETUP_PY,\n        },\n        self.tmp_dir,\n    )\n    with path.Path(self.tmp_dir):\n        yield\n\n\ndef clean_lines(filepath):\n    with pathlib.Path(filepath).open(encoding='utf-8') as f:\n        yield from filter(None, map(str.strip, f))\n\n\nclass TestSDist(support.TempdirManager):\n    def get_cmd(self, metadata=None):\n        \"\"\"Returns a cmd\"\"\"\n        if metadata is None:\n            metadata = {\n                'name': 'ns.fake--pkg',\n                'version': '1.0',\n                'url': 'xxx',\n                'author': 'xxx',\n                'author_email': 'xxx',\n            }\n        dist = Distribution(metadata)\n        dist.script_name = 'setup.py'\n        dist.packages = ['somecode']\n        dist.include_package_data = True\n        cmd = sdist(dist)\n        cmd.dist_dir = 'dist'\n        return dist, cmd\n\n    @pytest.mark.usefixtures('needs_zlib')\n    def test_prune_file_list(self):\n        # this test creates a project with some VCS dirs and an NFS rename\n        # file, then launches sdist to check they get pruned on all systems\n\n        # creating VCS directories with some files in them\n        os.mkdir(join(self.tmp_dir, 'somecode', '.svn'))\n        self.write_file((self.tmp_dir, 'somecode', '.svn', 'ok.py'), 'xxx')\n\n        os.mkdir(join(self.tmp_dir, 'somecode', '.hg'))\n        self.write_file((self.tmp_dir, 'somecode', '.hg', 'ok'), 'xxx')\n\n        os.mkdir(join(self.tmp_dir, 'somecode', '.git'))\n        self.write_file((self.tmp_dir, 'somecode', '.git', 'ok'), 'xxx')\n\n        self.write_file((self.tmp_dir, 'somecode', '.nfs0001'), 'xxx')\n\n        # now building a sdist\n        dist, cmd = self.get_cmd()\n\n        # zip is available universally\n        # (tar might not be installed under win32)\n        cmd.formats = ['zip']\n\n        cmd.ensure_finalized()\n        cmd.run()\n\n        # now let's check what we have\n        dist_folder = join(self.tmp_dir, 'dist')\n        files = os.listdir(dist_folder)\n        assert files == ['ns_fake_pkg-1.0.zip']\n\n        zip_file = zipfile.ZipFile(join(dist_folder, 'ns_fake_pkg-1.0.zip'))\n        try:\n            content = zip_file.namelist()\n        finally:\n            zip_file.close()\n\n        # making sure everything has been pruned correctly\n        expected = [\n            '',\n            'PKG-INFO',\n            'README',\n            'setup.py',\n            'somecode/',\n            'somecode/__init__.py',\n        ]\n        assert sorted(content) == ['ns_fake_pkg-1.0/' + x for x in expected]\n\n    @pytest.mark.usefixtures('needs_zlib')\n    @pytest.mark.skipif(\"not shutil.which('tar')\")\n    @pytest.mark.skipif(\"not shutil.which('gzip')\")\n    def test_make_distribution(self):\n        # now building a sdist\n        dist, cmd = self.get_cmd()\n\n        # creating a gztar then a tar\n        cmd.formats = ['gztar', 'tar']\n        cmd.ensure_finalized()\n        cmd.run()\n\n        # making sure we have two files\n        dist_folder = join(self.tmp_dir, 'dist')\n        result = os.listdir(dist_folder)\n        result.sort()\n        assert result == ['ns_fake_pkg-1.0.tar', 'ns_fake_pkg-1.0.tar.gz']\n\n        os.remove(join(dist_folder, 'ns_fake_pkg-1.0.tar'))\n        os.remove(join(dist_folder, 'ns_fake_pkg-1.0.tar.gz'))\n\n        # now trying a tar then a gztar\n        cmd.formats = ['tar', 'gztar']\n\n        cmd.ensure_finalized()\n        cmd.run()\n\n        result = os.listdir(dist_folder)\n        result.sort()\n        assert result == ['ns_fake_pkg-1.0.tar', 'ns_fake_pkg-1.0.tar.gz']\n\n    @pytest.mark.usefixtures('needs_zlib')\n    def test_add_defaults(self):\n        # https://bugs.python.org/issue2279\n\n        # add_default should also include\n        # data_files and package_data\n        dist, cmd = self.get_cmd()\n\n        # filling data_files by pointing files\n        # in package_data\n        dist.package_data = {'': ['*.cfg', '*.dat'], 'somecode': ['*.txt']}\n        self.write_file((self.tmp_dir, 'somecode', 'doc.txt'), '#')\n        self.write_file((self.tmp_dir, 'somecode', 'doc.dat'), '#')\n\n        # adding some data in data_files\n        data_dir = join(self.tmp_dir, 'data')\n        os.mkdir(data_dir)\n        self.write_file((data_dir, 'data.dt'), '#')\n        some_dir = join(self.tmp_dir, 'some')\n        os.mkdir(some_dir)\n        # make sure VCS directories are pruned (#14004)\n        hg_dir = join(self.tmp_dir, '.hg')\n        os.mkdir(hg_dir)\n        self.write_file((hg_dir, 'last-message.txt'), '#')\n        # a buggy regex used to prevent this from working on windows (#6884)\n        self.write_file((self.tmp_dir, 'buildout.cfg'), '#')\n        self.write_file((self.tmp_dir, 'inroot.txt'), '#')\n        self.write_file((some_dir, 'file.txt'), '#')\n        self.write_file((some_dir, 'other_file.txt'), '#')\n\n        dist.data_files = [\n            ('data', ['data/data.dt', 'buildout.cfg', 'inroot.txt', 'notexisting']),\n            'some/file.txt',\n            'some/other_file.txt',\n        ]\n\n        # adding a script\n        script_dir = join(self.tmp_dir, 'scripts')\n        os.mkdir(script_dir)\n        self.write_file((script_dir, 'script.py'), '#')\n        dist.scripts = [join('scripts', 'script.py')]\n\n        cmd.formats = ['zip']\n        cmd.use_defaults = True\n\n        cmd.ensure_finalized()\n        cmd.run()\n\n        # now let's check what we have\n        dist_folder = join(self.tmp_dir, 'dist')\n        files = os.listdir(dist_folder)\n        assert files == ['ns_fake_pkg-1.0.zip']\n\n        zip_file = zipfile.ZipFile(join(dist_folder, 'ns_fake_pkg-1.0.zip'))\n        try:\n            content = zip_file.namelist()\n        finally:\n            zip_file.close()\n\n        # making sure everything was added\n        expected = [\n            '',\n            'PKG-INFO',\n            'README',\n            'buildout.cfg',\n            'data/',\n            'data/data.dt',\n            'inroot.txt',\n            'scripts/',\n            'scripts/script.py',\n            'setup.py',\n            'some/',\n            'some/file.txt',\n            'some/other_file.txt',\n            'somecode/',\n            'somecode/__init__.py',\n            'somecode/doc.dat',\n            'somecode/doc.txt',\n        ]\n        assert sorted(content) == ['ns_fake_pkg-1.0/' + x for x in expected]\n\n        # checking the MANIFEST\n        manifest = pathlib.Path(self.tmp_dir, 'MANIFEST').read_text(encoding='utf-8')\n        assert manifest == MANIFEST % {'sep': os.sep}\n\n    @staticmethod\n    def warnings(messages, prefix='warning: '):\n        return [msg for msg in messages if msg.startswith(prefix)]\n\n    @pytest.mark.usefixtures('needs_zlib')\n    def test_metadata_check_option(self, caplog):\n        # testing the `medata-check` option\n        dist, cmd = self.get_cmd(metadata={})\n\n        # this should raise some warnings !\n        # with the `check` subcommand\n        cmd.ensure_finalized()\n        cmd.run()\n        assert len(self.warnings(caplog.messages, 'warning: check: ')) == 1\n\n        # trying with a complete set of metadata\n        caplog.clear()\n        dist, cmd = self.get_cmd()\n        cmd.ensure_finalized()\n        cmd.metadata_check = 0\n        cmd.run()\n        assert len(self.warnings(caplog.messages, 'warning: check: ')) == 0\n\n    def test_show_formats(self, capsys):\n        show_formats()\n\n        # the output should be a header line + one line per format\n        num_formats = len(ARCHIVE_FORMATS.keys())\n        output = [\n            line\n            for line in capsys.readouterr().out.split('\\n')\n            if line.strip().startswith('--formats=')\n        ]\n        assert len(output) == num_formats\n\n    def test_finalize_options(self):\n        dist, cmd = self.get_cmd()\n        cmd.finalize_options()\n\n        # default options set by finalize\n        assert cmd.manifest == 'MANIFEST'\n        assert cmd.template == 'MANIFEST.in'\n        assert cmd.dist_dir == 'dist'\n\n        # formats has to be a string splitable on (' ', ',') or\n        # a stringlist\n        cmd.formats = 1\n        with pytest.raises(DistutilsOptionError):\n            cmd.finalize_options()\n        cmd.formats = ['zip']\n        cmd.finalize_options()\n\n        # formats has to be known\n        cmd.formats = 'supazipa'\n        with pytest.raises(DistutilsOptionError):\n            cmd.finalize_options()\n\n    # the following tests make sure there is a nice error message instead\n    # of a traceback when parsing an invalid manifest template\n\n    def _check_template(self, content, caplog):\n        dist, cmd = self.get_cmd()\n        os.chdir(self.tmp_dir)\n        self.write_file('MANIFEST.in', content)\n        cmd.ensure_finalized()\n        cmd.filelist = FileList()\n        cmd.read_template()\n        assert len(self.warnings(caplog.messages)) == 1\n\n    def test_invalid_template_unknown_command(self, caplog):\n        self._check_template('taunt knights *', caplog)\n\n    def test_invalid_template_wrong_arguments(self, caplog):\n        # this manifest command takes one argument\n        self._check_template('prune', caplog)\n\n    @pytest.mark.skipif(\"platform.system() != 'Windows'\")\n    def test_invalid_template_wrong_path(self, caplog):\n        # on Windows, trailing slashes are not allowed\n        # this used to crash instead of raising a warning: #8286\n        self._check_template('include examples/', caplog)\n\n    @pytest.mark.usefixtures('needs_zlib')\n    def test_get_file_list(self):\n        # make sure MANIFEST is recalculated\n        dist, cmd = self.get_cmd()\n\n        # filling data_files by pointing files in package_data\n        dist.package_data = {'somecode': ['*.txt']}\n        self.write_file((self.tmp_dir, 'somecode', 'doc.txt'), '#')\n        cmd.formats = ['gztar']\n        cmd.ensure_finalized()\n        cmd.run()\n\n        assert ilen(clean_lines(cmd.manifest)) == 5\n\n        # adding a file\n        self.write_file((self.tmp_dir, 'somecode', 'doc2.txt'), '#')\n\n        # make sure build_py is reinitialized, like a fresh run\n        build_py = dist.get_command_obj('build_py')\n        build_py.finalized = False\n        build_py.ensure_finalized()\n\n        cmd.run()\n\n        manifest2 = list(clean_lines(cmd.manifest))\n\n        # do we have the new file in MANIFEST ?\n        assert len(manifest2) == 6\n        assert 'doc2.txt' in manifest2[-1]\n\n    @pytest.mark.usefixtures('needs_zlib')\n    def test_manifest_marker(self):\n        # check that autogenerated MANIFESTs have a marker\n        dist, cmd = self.get_cmd()\n        cmd.ensure_finalized()\n        cmd.run()\n\n        assert (\n            next(clean_lines(cmd.manifest))\n            == '# file GENERATED by distutils, do NOT edit'\n        )\n\n    @pytest.mark.usefixtures('needs_zlib')\n    def test_manifest_comments(self):\n        # make sure comments don't cause exceptions or wrong includes\n        contents = dedent(\n            \"\"\"\\\n            # bad.py\n            #bad.py\n            good.py\n            \"\"\"\n        )\n        dist, cmd = self.get_cmd()\n        cmd.ensure_finalized()\n        self.write_file((self.tmp_dir, cmd.manifest), contents)\n        self.write_file((self.tmp_dir, 'good.py'), '# pick me!')\n        self.write_file((self.tmp_dir, 'bad.py'), \"# don't pick me!\")\n        self.write_file((self.tmp_dir, '#bad.py'), \"# don't pick me!\")\n        cmd.run()\n        assert cmd.filelist.files == ['good.py']\n\n    @pytest.mark.usefixtures('needs_zlib')\n    def test_manual_manifest(self):\n        # check that a MANIFEST without a marker is left alone\n        dist, cmd = self.get_cmd()\n        cmd.formats = ['gztar']\n        cmd.ensure_finalized()\n        self.write_file((self.tmp_dir, cmd.manifest), 'README.manual')\n        self.write_file(\n            (self.tmp_dir, 'README.manual'),\n            'This project maintains its MANIFEST file itself.',\n        )\n        cmd.run()\n        assert cmd.filelist.files == ['README.manual']\n\n        assert list(clean_lines(cmd.manifest)) == ['README.manual']\n\n        archive_name = join(self.tmp_dir, 'dist', 'ns_fake_pkg-1.0.tar.gz')\n        archive = tarfile.open(archive_name)\n        try:\n            filenames = [tarinfo.name for tarinfo in archive]\n        finally:\n            archive.close()\n        assert sorted(filenames) == [\n            'ns_fake_pkg-1.0',\n            'ns_fake_pkg-1.0/PKG-INFO',\n            'ns_fake_pkg-1.0/README.manual',\n        ]\n\n    @pytest.mark.usefixtures('needs_zlib')\n    @require_unix_id\n    @require_uid_0\n    @pytest.mark.skipif(\"not shutil.which('tar')\")\n    @pytest.mark.skipif(\"not shutil.which('gzip')\")\n    def test_make_distribution_owner_group(self):\n        # now building a sdist\n        dist, cmd = self.get_cmd()\n\n        # creating a gztar and specifying the owner+group\n        cmd.formats = ['gztar']\n        cmd.owner = pwd.getpwuid(0)[0]\n        cmd.group = grp.getgrgid(0)[0]\n        cmd.ensure_finalized()\n        cmd.run()\n\n        # making sure we have the good rights\n        archive_name = join(self.tmp_dir, 'dist', 'ns_fake_pkg-1.0.tar.gz')\n        archive = tarfile.open(archive_name)\n        try:\n            for member in archive.getmembers():\n                assert member.uid == 0\n                assert member.gid == 0\n        finally:\n            archive.close()\n\n        # building a sdist again\n        dist, cmd = self.get_cmd()\n\n        # creating a gztar\n        cmd.formats = ['gztar']\n        cmd.ensure_finalized()\n        cmd.run()\n\n        # making sure we have the good rights\n        archive_name = join(self.tmp_dir, 'dist', 'ns_fake_pkg-1.0.tar.gz')\n        archive = tarfile.open(archive_name)\n\n        # note that we are not testing the group ownership here\n        # because, depending on the platforms and the container\n        # rights (see #7408)\n        try:\n            for member in archive.getmembers():\n                assert member.uid == os.getuid()\n        finally:\n            archive.close()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_spawn.py","size":4803,"sha1":"891a43ab3b20e2ac716c3e7c03d27439c7a1e0dd","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.spawn.\"\"\"\n\nimport os\nimport stat\nimport sys\nimport unittest.mock as mock\nfrom distutils.errors import DistutilsExecError\nfrom distutils.spawn import find_executable, spawn\nfrom distutils.tests import support\n\nimport path\nimport pytest\nfrom test.support import unix_shell\n\nfrom .compat import py39 as os_helper\n\n\nclass TestSpawn(support.TempdirManager):\n    @pytest.mark.skipif(\"os.name not in ('nt', 'posix')\")\n    def test_spawn(self):\n        tmpdir = self.mkdtemp()\n\n        # creating something executable\n        # through the shell that returns 1\n        if sys.platform != 'win32':\n            exe = os.path.join(tmpdir, 'foo.sh')\n            self.write_file(exe, f'#!{unix_shell}\\nexit 1')\n        else:\n            exe = os.path.join(tmpdir, 'foo.bat')\n            self.write_file(exe, 'exit 1')\n\n        os.chmod(exe, 0o777)\n        with pytest.raises(DistutilsExecError):\n            spawn([exe])\n\n        # now something that works\n        if sys.platform != 'win32':\n            exe = os.path.join(tmpdir, 'foo.sh')\n            self.write_file(exe, f'#!{unix_shell}\\nexit 0')\n        else:\n            exe = os.path.join(tmpdir, 'foo.bat')\n            self.write_file(exe, 'exit 0')\n\n        os.chmod(exe, 0o777)\n        spawn([exe])  # should work without any error\n\n    def test_find_executable(self, tmp_path):\n        program_path = self._make_executable(tmp_path, '.exe')\n        program = program_path.name\n        program_noeext = program_path.with_suffix('').name\n        filename = str(program_path)\n        tmp_dir = path.Path(tmp_path)\n\n        # test path parameter\n        rv = find_executable(program, path=tmp_dir)\n        assert rv == filename\n\n        if sys.platform == 'win32':\n            # test without \".exe\" extension\n            rv = find_executable(program_noeext, path=tmp_dir)\n            assert rv == filename\n\n        # test find in the current directory\n        with tmp_dir:\n            rv = find_executable(program)\n            assert rv == program\n\n        # test non-existent program\n        dont_exist_program = \"dontexist_\" + program\n        rv = find_executable(dont_exist_program, path=tmp_dir)\n        assert rv is None\n\n        # PATH='': no match, except in the current directory\n        with os_helper.EnvironmentVarGuard() as env:\n            env['PATH'] = ''\n            with (\n                mock.patch(\n                    'distutils.spawn.os.confstr', return_value=tmp_dir, create=True\n                ),\n                mock.patch('distutils.spawn.os.defpath', tmp_dir),\n            ):\n                rv = find_executable(program)\n                assert rv is None\n\n                # look in current directory\n                with tmp_dir:\n                    rv = find_executable(program)\n                    assert rv == program\n\n        # PATH=':': explicitly looks in the current directory\n        with os_helper.EnvironmentVarGuard() as env:\n            env['PATH'] = os.pathsep\n            with (\n                mock.patch('distutils.spawn.os.confstr', return_value='', create=True),\n                mock.patch('distutils.spawn.os.defpath', ''),\n            ):\n                rv = find_executable(program)\n                assert rv is None\n\n                # look in current directory\n                with tmp_dir:\n                    rv = find_executable(program)\n                    assert rv == program\n\n        # missing PATH: test os.confstr(\"CS_PATH\") and os.defpath\n        with os_helper.EnvironmentVarGuard() as env:\n            env.pop('PATH', None)\n\n            # without confstr\n            with (\n                mock.patch(\n                    'distutils.spawn.os.confstr', side_effect=ValueError, create=True\n                ),\n                mock.patch('distutils.spawn.os.defpath', tmp_dir),\n            ):\n                rv = find_executable(program)\n                assert rv == filename\n\n            # with confstr\n            with (\n                mock.patch(\n                    'distutils.spawn.os.confstr', return_value=tmp_dir, create=True\n                ),\n                mock.patch('distutils.spawn.os.defpath', ''),\n            ):\n                rv = find_executable(program)\n                assert rv == filename\n\n    @staticmethod\n    def _make_executable(tmp_path, ext):\n        # Give the temporary program a suffix regardless of platform.\n        # It's needed on Windows and not harmful on others.\n        program = tmp_path.joinpath('program').with_suffix(ext)\n        program.write_text(\"\", encoding='utf-8')\n        program.chmod(stat.S_IXUSR)\n        return program\n\n    def test_spawn_missing_exe(self):\n        with pytest.raises(DistutilsExecError) as ctx:\n            spawn(['does-not-exist'])\n        assert \"command 'does-not-exist' failed\" in str(ctx.value)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_sysconfig.py","size":11986,"sha1":"f9e8b5eac1d5b444d9018dad341612bb8c9168b2","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.sysconfig.\"\"\"\n\nimport contextlib\nimport distutils\nimport os\nimport pathlib\nimport subprocess\nimport sys\nfrom distutils import sysconfig\nfrom distutils.ccompiler import new_compiler  # noqa: F401\nfrom distutils.unixccompiler import UnixCCompiler\n\nimport jaraco.envs\nimport path\nimport pytest\nfrom jaraco.text import trim\nfrom test.support import swap_item\n\n\ndef _gen_makefile(root, contents):\n    jaraco.path.build({'Makefile': trim(contents)}, root)\n    return root / 'Makefile'\n\n\n@pytest.mark.usefixtures('save_env')\nclass TestSysconfig:\n    def test_get_config_h_filename(self):\n        config_h = sysconfig.get_config_h_filename()\n        assert os.path.isfile(config_h)\n\n    @pytest.mark.skipif(\"platform.system() == 'Windows'\")\n    @pytest.mark.skipif(\"sys.implementation.name != 'cpython'\")\n    def test_get_makefile_filename(self):\n        makefile = sysconfig.get_makefile_filename()\n        assert os.path.isfile(makefile)\n\n    def test_get_python_lib(self, tmp_path):\n        assert sysconfig.get_python_lib() != sysconfig.get_python_lib(prefix=tmp_path)\n\n    def test_get_config_vars(self):\n        cvars = sysconfig.get_config_vars()\n        assert isinstance(cvars, dict)\n        assert cvars\n\n    @pytest.mark.skipif('sysconfig.IS_PYPY')\n    @pytest.mark.skipif('sysconfig.python_build')\n    @pytest.mark.xfail('platform.system() == \"Windows\"')\n    def test_srcdir_simple(self):\n        # See #15364.\n        srcdir = pathlib.Path(sysconfig.get_config_var('srcdir'))\n\n        assert srcdir.absolute()\n        assert srcdir.is_dir()\n\n        makefile = pathlib.Path(sysconfig.get_makefile_filename())\n        assert makefile.parent.samefile(srcdir)\n\n    @pytest.mark.skipif('sysconfig.IS_PYPY')\n    @pytest.mark.skipif('not sysconfig.python_build')\n    def test_srcdir_python_build(self):\n        # See #15364.\n        srcdir = pathlib.Path(sysconfig.get_config_var('srcdir'))\n\n        # The python executable has not been installed so srcdir\n        # should be a full source checkout.\n        Python_h = srcdir.joinpath('Include', 'Python.h')\n        assert Python_h.is_file()\n        assert sysconfig._is_python_source_dir(srcdir)\n        assert sysconfig._is_python_source_dir(str(srcdir))\n\n    def test_srcdir_independent_of_cwd(self):\n        \"\"\"\n        srcdir should be independent of the current working directory\n        \"\"\"\n        # See #15364.\n        srcdir = sysconfig.get_config_var('srcdir')\n        with path.Path('..'):\n            srcdir2 = sysconfig.get_config_var('srcdir')\n        assert srcdir == srcdir2\n\n    def customize_compiler(self):\n        # make sure AR gets caught\n        class compiler:\n            compiler_type = 'unix'\n            executables = UnixCCompiler.executables\n\n            def __init__(self):\n                self.exes = {}\n\n            def set_executables(self, **kw):\n                for k, v in kw.items():\n                    self.exes[k] = v\n\n        sysconfig_vars = {\n            'AR': 'sc_ar',\n            'CC': 'sc_cc',\n            'CXX': 'sc_cxx',\n            'ARFLAGS': '--sc-arflags',\n            'CFLAGS': '--sc-cflags',\n            'CCSHARED': '--sc-ccshared',\n            'LDSHARED': 'sc_ldshared',\n            'SHLIB_SUFFIX': 'sc_shutil_suffix',\n        }\n\n        comp = compiler()\n        with contextlib.ExitStack() as cm:\n            for key, value in sysconfig_vars.items():\n                cm.enter_context(swap_item(sysconfig._config_vars, key, value))\n            sysconfig.customize_compiler(comp)\n\n        return comp\n\n    @pytest.mark.skipif(\"not isinstance(new_compiler(), UnixCCompiler)\")\n    @pytest.mark.usefixtures('disable_macos_customization')\n    def test_customize_compiler(self):\n        # Make sure that sysconfig._config_vars is initialized\n        sysconfig.get_config_vars()\n\n        os.environ['AR'] = 'env_ar'\n        os.environ['CC'] = 'env_cc'\n        os.environ['CPP'] = 'env_cpp'\n        os.environ['CXX'] = 'env_cxx --env-cxx-flags'\n        os.environ['LDSHARED'] = 'env_ldshared'\n        os.environ['LDFLAGS'] = '--env-ldflags'\n        os.environ['ARFLAGS'] = '--env-arflags'\n        os.environ['CFLAGS'] = '--env-cflags'\n        os.environ['CPPFLAGS'] = '--env-cppflags'\n        os.environ['RANLIB'] = 'env_ranlib'\n\n        comp = self.customize_compiler()\n        assert comp.exes['archiver'] == 'env_ar --env-arflags'\n        assert comp.exes['preprocessor'] == 'env_cpp --env-cppflags'\n        assert comp.exes['compiler'] == 'env_cc --env-cflags --env-cppflags'\n        assert comp.exes['compiler_so'] == (\n            'env_cc --env-cflags --env-cppflags --sc-ccshared'\n        )\n        assert (\n            comp.exes['compiler_cxx']\n            == 'env_cxx --env-cxx-flags --sc-cflags --env-cppflags'\n        )\n        assert comp.exes['linker_exe'] == 'env_cc'\n        assert comp.exes['linker_so'] == (\n            'env_ldshared --env-ldflags --env-cflags --env-cppflags'\n        )\n        assert comp.shared_lib_extension == 'sc_shutil_suffix'\n\n        if sys.platform == \"darwin\":\n            assert comp.exes['ranlib'] == 'env_ranlib'\n        else:\n            assert 'ranlib' not in comp.exes\n\n        del os.environ['AR']\n        del os.environ['CC']\n        del os.environ['CPP']\n        del os.environ['CXX']\n        del os.environ['LDSHARED']\n        del os.environ['LDFLAGS']\n        del os.environ['ARFLAGS']\n        del os.environ['CFLAGS']\n        del os.environ['CPPFLAGS']\n        del os.environ['RANLIB']\n\n        comp = self.customize_compiler()\n        assert comp.exes['archiver'] == 'sc_ar --sc-arflags'\n        assert comp.exes['preprocessor'] == 'sc_cc -E'\n        assert comp.exes['compiler'] == 'sc_cc --sc-cflags'\n        assert comp.exes['compiler_so'] == 'sc_cc --sc-cflags --sc-ccshared'\n        assert comp.exes['compiler_cxx'] == 'sc_cxx --sc-cflags'\n        assert comp.exes['linker_exe'] == 'sc_cc'\n        assert comp.exes['linker_so'] == 'sc_ldshared'\n        assert comp.shared_lib_extension == 'sc_shutil_suffix'\n        assert 'ranlib' not in comp.exes\n\n    def test_parse_makefile_base(self, tmp_path):\n        makefile = _gen_makefile(\n            tmp_path,\n            \"\"\"\n            CONFIG_ARGS=  '--arg1=optarg1' 'ENV=LIB'\n            VAR=$OTHER\n            OTHER=foo\n            \"\"\",\n        )\n        d = sysconfig.parse_makefile(makefile)\n        assert d == {'CONFIG_ARGS': \"'--arg1=optarg1' 'ENV=LIB'\", 'OTHER': 'foo'}\n\n    def test_parse_makefile_literal_dollar(self, tmp_path):\n        makefile = _gen_makefile(\n            tmp_path,\n            \"\"\"\n            CONFIG_ARGS=  '--arg1=optarg1' 'ENV=\\\\$$LIB'\n            VAR=$OTHER\n            OTHER=foo\n            \"\"\",\n        )\n        d = sysconfig.parse_makefile(makefile)\n        assert d == {'CONFIG_ARGS': r\"'--arg1=optarg1' 'ENV=\\$LIB'\", 'OTHER': 'foo'}\n\n    def test_sysconfig_module(self):\n        import sysconfig as global_sysconfig\n\n        assert global_sysconfig.get_config_var('CFLAGS') == sysconfig.get_config_var(\n            'CFLAGS'\n        )\n        assert global_sysconfig.get_config_var('LDFLAGS') == sysconfig.get_config_var(\n            'LDFLAGS'\n        )\n\n    # On macOS, binary installers support extension module building on\n    # various levels of the operating system with differing Xcode\n    # configurations, requiring customization of some of the\n    # compiler configuration directives to suit the environment on\n    # the installed machine. Some of these customizations may require\n    # running external programs and are thus deferred until needed by\n    # the first extension module build. Only\n    # the Distutils version of sysconfig is used for extension module\n    # builds, which happens earlier in the Distutils tests. This may\n    # cause the following tests to fail since no tests have caused\n    # the global version of sysconfig to call the customization yet.\n    # The solution for now is to simply skip this test in this case.\n    # The longer-term solution is to only have one version of sysconfig.\n    @pytest.mark.skipif(\"sysconfig.get_config_var('CUSTOMIZED_OSX_COMPILER')\")\n    def test_sysconfig_compiler_vars(self):\n        import sysconfig as global_sysconfig\n\n        if sysconfig.get_config_var('CUSTOMIZED_OSX_COMPILER'):\n            pytest.skip('compiler flags customized')\n        assert global_sysconfig.get_config_var('LDSHARED') == sysconfig.get_config_var(\n            'LDSHARED'\n        )\n        assert global_sysconfig.get_config_var('CC') == sysconfig.get_config_var('CC')\n\n    @pytest.mark.skipif(\"not sysconfig.get_config_var('EXT_SUFFIX')\")\n    def test_SO_deprecation(self):\n        with pytest.warns(DeprecationWarning):\n            sysconfig.get_config_var('SO')\n\n    def test_customize_compiler_before_get_config_vars(self, tmp_path):\n        # Issue #21923: test that a Distribution compiler\n        # instance can be called without an explicit call to\n        # get_config_vars().\n        jaraco.path.build(\n            {\n                'file': trim(\"\"\"\n                    from distutils.core import Distribution\n                    config = Distribution().get_command_obj('config')\n                    # try_compile may pass or it may fail if no compiler\n                    # is found but it should not raise an exception.\n                    rc = config.try_compile('int x;')\n                    \"\"\")\n            },\n            tmp_path,\n        )\n        p = subprocess.Popen(\n            [sys.executable, tmp_path / 'file'],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            universal_newlines=True,\n            encoding='utf-8',\n        )\n        outs, errs = p.communicate()\n        assert 0 == p.returncode, \"Subprocess failed: \" + outs\n\n    def test_parse_config_h(self):\n        config_h = sysconfig.get_config_h_filename()\n        input = {}\n        with open(config_h, encoding=\"utf-8\") as f:\n            result = sysconfig.parse_config_h(f, g=input)\n        assert input is result\n        with open(config_h, encoding=\"utf-8\") as f:\n            result = sysconfig.parse_config_h(f)\n        assert isinstance(result, dict)\n\n    @pytest.mark.skipif(\"platform.system() != 'Windows'\")\n    @pytest.mark.skipif(\"sys.implementation.name != 'cpython'\")\n    def test_win_ext_suffix(self):\n        assert sysconfig.get_config_var(\"EXT_SUFFIX\").endswith(\".pyd\")\n        assert sysconfig.get_config_var(\"EXT_SUFFIX\") != \".pyd\"\n\n    @pytest.mark.skipif(\"platform.system() != 'Windows'\")\n    @pytest.mark.skipif(\"sys.implementation.name != 'cpython'\")\n    @pytest.mark.skipif(\n        '\\\\PCbuild\\\\'.casefold() not in sys.executable.casefold(),\n        reason='Need sys.executable to be in a source tree',\n    )\n    def test_win_build_venv_from_source_tree(self, tmp_path):\n        \"\"\"Ensure distutils.sysconfig detects venvs from source tree builds.\"\"\"\n        env = jaraco.envs.VEnv()\n        env.create_opts = env.clean_opts\n        env.root = tmp_path\n        env.ensure_env()\n        cmd = [\n            env.exe(),\n            \"-c\",\n            \"import distutils.sysconfig; print(distutils.sysconfig.python_build)\",\n        ]\n        distutils_path = os.path.dirname(os.path.dirname(distutils.__file__))\n        out = subprocess.check_output(\n            cmd, env={**os.environ, \"PYTHONPATH\": distutils_path}\n        )\n        assert out == \"True\"\n\n    def test_get_python_inc_missing_config_dir(self, monkeypatch):\n        \"\"\"\n        In portable Python installations, the sysconfig will be broken,\n        pointing to the directories where the installation was built and\n        not where it currently is. In this case, ensure that the missing\n        directory isn't used for get_python_inc.\n\n        See pypa/distutils#178.\n        \"\"\"\n\n        def override(name):\n            if name == 'INCLUDEPY':\n                return '/does-not-exist'\n            return sysconfig.get_config_var(name)\n\n        monkeypatch.setattr(sysconfig, 'get_config_var', override)\n\n        assert os.path.exists(sysconfig.get_python_inc())\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_text_file.py","size":3460,"sha1":"c542ab3e54c7756330b6f6534af9e34877252e49","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.text_file.\"\"\"\n\nfrom distutils.tests import support\nfrom distutils.text_file import TextFile\n\nimport jaraco.path\nimport path\n\nTEST_DATA = \"\"\"# test file\n\nline 3 \\\\\n# intervening comment\n  continues on next line\n\"\"\"\n\n\nclass TestTextFile(support.TempdirManager):\n    def test_class(self):\n        # old tests moved from text_file.__main__\n        # so they are really called by the buildbots\n\n        # result 1: no fancy options\n        result1 = [\n            '# test file\\n',\n            '\\n',\n            'line 3 \\\\\\n',\n            '# intervening comment\\n',\n            '  continues on next line\\n',\n        ]\n\n        # result 2: just strip comments\n        result2 = [\"\\n\", \"line 3 \\\\\\n\", \"  continues on next line\\n\"]\n\n        # result 3: just strip blank lines\n        result3 = [\n            \"# test file\\n\",\n            \"line 3 \\\\\\n\",\n            \"# intervening comment\\n\",\n            \"  continues on next line\\n\",\n        ]\n\n        # result 4: default, strip comments, blank lines,\n        # and trailing whitespace\n        result4 = [\"line 3 \\\\\", \"  continues on next line\"]\n\n        # result 5: strip comments and blanks, plus join lines (but don't\n        # \"collapse\" joined lines\n        result5 = [\"line 3   continues on next line\"]\n\n        # result 6: strip comments and blanks, plus join lines (and\n        # \"collapse\" joined lines\n        result6 = [\"line 3 continues on next line\"]\n\n        def test_input(count, description, file, expected_result):\n            result = file.readlines()\n            assert result == expected_result\n\n        tmp_path = path.Path(self.mkdtemp())\n        filename = tmp_path / 'test.txt'\n        jaraco.path.build({filename.name: TEST_DATA}, tmp_path)\n\n        in_file = TextFile(\n            filename,\n            strip_comments=False,\n            skip_blanks=False,\n            lstrip_ws=False,\n            rstrip_ws=False,\n        )\n        try:\n            test_input(1, \"no processing\", in_file, result1)\n        finally:\n            in_file.close()\n\n        in_file = TextFile(\n            filename,\n            strip_comments=True,\n            skip_blanks=False,\n            lstrip_ws=False,\n            rstrip_ws=False,\n        )\n        try:\n            test_input(2, \"strip comments\", in_file, result2)\n        finally:\n            in_file.close()\n\n        in_file = TextFile(\n            filename,\n            strip_comments=False,\n            skip_blanks=True,\n            lstrip_ws=False,\n            rstrip_ws=False,\n        )\n        try:\n            test_input(3, \"strip blanks\", in_file, result3)\n        finally:\n            in_file.close()\n\n        in_file = TextFile(filename)\n        try:\n            test_input(4, \"default processing\", in_file, result4)\n        finally:\n            in_file.close()\n\n        in_file = TextFile(\n            filename,\n            strip_comments=True,\n            skip_blanks=True,\n            join_lines=True,\n            rstrip_ws=True,\n        )\n        try:\n            test_input(5, \"join lines without collapsing\", in_file, result5)\n        finally:\n            in_file.close()\n\n        in_file = TextFile(\n            filename,\n            strip_comments=True,\n            skip_blanks=True,\n            join_lines=True,\n            rstrip_ws=True,\n            collapse_join=True,\n        )\n        try:\n            test_input(6, \"join lines with collapsing\", in_file, result6)\n        finally:\n            in_file.close()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_unixccompiler.py","size":11835,"sha1":"32279b48bfbd200f4bfb0fef0f8fddabaddf5361","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.unixccompiler.\"\"\"\n\nimport os\nimport sys\nimport unittest.mock as mock\nfrom distutils import sysconfig\nfrom distutils.compat import consolidate_linker_args\nfrom distutils.errors import DistutilsPlatformError\nfrom distutils.unixccompiler import UnixCCompiler\nfrom distutils.util import _clear_cached_macosx_ver\n\nimport pytest\n\nfrom . import support\nfrom .compat.py39 import EnvironmentVarGuard\n\n\n@pytest.fixture(autouse=True)\ndef save_values(monkeypatch):\n    monkeypatch.setattr(sys, 'platform', sys.platform)\n    monkeypatch.setattr(sysconfig, 'get_config_var', sysconfig.get_config_var)\n    monkeypatch.setattr(sysconfig, 'get_config_vars', sysconfig.get_config_vars)\n\n\n@pytest.fixture(autouse=True)\ndef compiler_wrapper(request):\n    class CompilerWrapper(UnixCCompiler):\n        def rpath_foo(self):\n            return self.runtime_library_dir_option('/foo')\n\n    request.instance.cc = CompilerWrapper()\n\n\nclass TestUnixCCompiler(support.TempdirManager):\n    @pytest.mark.skipif('platform.system == \"Windows\"')\n    def test_runtime_libdir_option(self):  # noqa: C901\n        # Issue #5900; GitHub Issue #37\n        #\n        # Ensure RUNPATH is added to extension modules with RPATH if\n        # GNU ld is used\n\n        # darwin\n        sys.platform = 'darwin'\n        darwin_ver_var = 'MACOSX_DEPLOYMENT_TARGET'\n        darwin_rpath_flag = '-Wl,-rpath,/foo'\n        darwin_lib_flag = '-L/foo'\n\n        # (macOS version from syscfg, macOS version from env var) -> flag\n        # Version value of None generates two tests: as None and as empty string\n        # Expected flag value of None means an mismatch exception is expected\n        darwin_test_cases = [\n            ((None, None), darwin_lib_flag),\n            ((None, '11'), darwin_rpath_flag),\n            (('10', None), darwin_lib_flag),\n            (('10.3', None), darwin_lib_flag),\n            (('10.3.1', None), darwin_lib_flag),\n            (('10.5', None), darwin_rpath_flag),\n            (('10.5.1', None), darwin_rpath_flag),\n            (('10.3', '10.3'), darwin_lib_flag),\n            (('10.3', '10.5'), darwin_rpath_flag),\n            (('10.5', '10.3'), darwin_lib_flag),\n            (('10.5', '11'), darwin_rpath_flag),\n            (('10.4', '10'), None),\n        ]\n\n        def make_darwin_gcv(syscfg_macosx_ver):\n            def gcv(var):\n                if var == darwin_ver_var:\n                    return syscfg_macosx_ver\n                return \"xxx\"\n\n            return gcv\n\n        def do_darwin_test(syscfg_macosx_ver, env_macosx_ver, expected_flag):\n            env = os.environ\n            msg = f\"macOS version = (sysconfig={syscfg_macosx_ver!r}, env={env_macosx_ver!r})\"\n\n            # Save\n            old_gcv = sysconfig.get_config_var\n            old_env_macosx_ver = env.get(darwin_ver_var)\n\n            # Setup environment\n            _clear_cached_macosx_ver()\n            sysconfig.get_config_var = make_darwin_gcv(syscfg_macosx_ver)\n            if env_macosx_ver is not None:\n                env[darwin_ver_var] = env_macosx_ver\n            elif darwin_ver_var in env:\n                env.pop(darwin_ver_var)\n\n            # Run the test\n            if expected_flag is not None:\n                assert self.cc.rpath_foo() == expected_flag, msg\n            else:\n                with pytest.raises(\n                    DistutilsPlatformError, match=darwin_ver_var + r' mismatch'\n                ):\n                    self.cc.rpath_foo()\n\n            # Restore\n            if old_env_macosx_ver is not None:\n                env[darwin_ver_var] = old_env_macosx_ver\n            elif darwin_ver_var in env:\n                env.pop(darwin_ver_var)\n            sysconfig.get_config_var = old_gcv\n            _clear_cached_macosx_ver()\n\n        for macosx_vers, expected_flag in darwin_test_cases:\n            syscfg_macosx_ver, env_macosx_ver = macosx_vers\n            do_darwin_test(syscfg_macosx_ver, env_macosx_ver, expected_flag)\n            # Bonus test cases with None interpreted as empty string\n            if syscfg_macosx_ver is None:\n                do_darwin_test(\"\", env_macosx_ver, expected_flag)\n            if env_macosx_ver is None:\n                do_darwin_test(syscfg_macosx_ver, \"\", expected_flag)\n            if syscfg_macosx_ver is None and env_macosx_ver is None:\n                do_darwin_test(\"\", \"\", expected_flag)\n\n        old_gcv = sysconfig.get_config_var\n\n        # hp-ux\n        sys.platform = 'hp-ux'\n\n        def gcv(v):\n            return 'xxx'\n\n        sysconfig.get_config_var = gcv\n        assert self.cc.rpath_foo() == ['+s', '-L/foo']\n\n        def gcv(v):\n            return 'gcc'\n\n        sysconfig.get_config_var = gcv\n        assert self.cc.rpath_foo() == ['-Wl,+s', '-L/foo']\n\n        def gcv(v):\n            return 'g++'\n\n        sysconfig.get_config_var = gcv\n        assert self.cc.rpath_foo() == ['-Wl,+s', '-L/foo']\n\n        sysconfig.get_config_var = old_gcv\n\n        # GCC GNULD\n        sys.platform = 'bar'\n\n        def gcv(v):\n            if v == 'CC':\n                return 'gcc'\n            elif v == 'GNULD':\n                return 'yes'\n\n        sysconfig.get_config_var = gcv\n        assert self.cc.rpath_foo() == consolidate_linker_args([\n            '-Wl,--enable-new-dtags',\n            '-Wl,-rpath,/foo',\n        ])\n\n        def gcv(v):\n            if v == 'CC':\n                return 'gcc -pthread -B /bar'\n            elif v == 'GNULD':\n                return 'yes'\n\n        sysconfig.get_config_var = gcv\n        assert self.cc.rpath_foo() == consolidate_linker_args([\n            '-Wl,--enable-new-dtags',\n            '-Wl,-rpath,/foo',\n        ])\n\n        # GCC non-GNULD\n        sys.platform = 'bar'\n\n        def gcv(v):\n            if v == 'CC':\n                return 'gcc'\n            elif v == 'GNULD':\n                return 'no'\n\n        sysconfig.get_config_var = gcv\n        assert self.cc.rpath_foo() == '-Wl,-R/foo'\n\n        # GCC GNULD with fully qualified configuration prefix\n        # see #7617\n        sys.platform = 'bar'\n\n        def gcv(v):\n            if v == 'CC':\n                return 'x86_64-pc-linux-gnu-gcc-4.4.2'\n            elif v == 'GNULD':\n                return 'yes'\n\n        sysconfig.get_config_var = gcv\n        assert self.cc.rpath_foo() == consolidate_linker_args([\n            '-Wl,--enable-new-dtags',\n            '-Wl,-rpath,/foo',\n        ])\n\n        # non-GCC GNULD\n        sys.platform = 'bar'\n\n        def gcv(v):\n            if v == 'CC':\n                return 'cc'\n            elif v == 'GNULD':\n                return 'yes'\n\n        sysconfig.get_config_var = gcv\n        assert self.cc.rpath_foo() == consolidate_linker_args([\n            '-Wl,--enable-new-dtags',\n            '-Wl,-rpath,/foo',\n        ])\n\n        # non-GCC non-GNULD\n        sys.platform = 'bar'\n\n        def gcv(v):\n            if v == 'CC':\n                return 'cc'\n            elif v == 'GNULD':\n                return 'no'\n\n        sysconfig.get_config_var = gcv\n        assert self.cc.rpath_foo() == '-Wl,-R/foo'\n\n    @pytest.mark.skipif('platform.system == \"Windows\"')\n    def test_cc_overrides_ldshared(self):\n        # Issue #18080:\n        # ensure that setting CC env variable also changes default linker\n        def gcv(v):\n            if v == 'LDSHARED':\n                return 'gcc-4.2 -bundle -undefined dynamic_lookup '\n            return 'gcc-4.2'\n\n        def gcvs(*args, _orig=sysconfig.get_config_vars):\n            if args:\n                return list(map(sysconfig.get_config_var, args))\n            return _orig()\n\n        sysconfig.get_config_var = gcv\n        sysconfig.get_config_vars = gcvs\n        with EnvironmentVarGuard() as env:\n            env['CC'] = 'my_cc'\n            del env['LDSHARED']\n            sysconfig.customize_compiler(self.cc)\n        assert self.cc.linker_so[0] == 'my_cc'\n\n    @pytest.mark.skipif('platform.system == \"Windows\"')\n    @pytest.mark.usefixtures('disable_macos_customization')\n    def test_cc_overrides_ldshared_for_cxx_correctly(self):\n        \"\"\"\n        Ensure that setting CC env variable also changes default linker\n        correctly when building C++ extensions.\n\n        pypa/distutils#126\n        \"\"\"\n\n        def gcv(v):\n            if v == 'LDSHARED':\n                return 'gcc-4.2 -bundle -undefined dynamic_lookup '\n            elif v == 'LDCXXSHARED':\n                return 'g++-4.2 -bundle -undefined dynamic_lookup '\n            elif v == 'CXX':\n                return 'g++-4.2'\n            elif v == 'CC':\n                return 'gcc-4.2'\n            return ''\n\n        def gcvs(*args, _orig=sysconfig.get_config_vars):\n            if args:\n                return list(map(sysconfig.get_config_var, args))\n            return _orig()\n\n        sysconfig.get_config_var = gcv\n        sysconfig.get_config_vars = gcvs\n        with (\n            mock.patch.object(self.cc, 'spawn', return_value=None) as mock_spawn,\n            mock.patch.object(self.cc, '_need_link', return_value=True),\n            mock.patch.object(self.cc, 'mkpath', return_value=None),\n            EnvironmentVarGuard() as env,\n        ):\n            env['CC'] = 'ccache my_cc'\n            env['CXX'] = 'my_cxx'\n            del env['LDSHARED']\n            sysconfig.customize_compiler(self.cc)\n            assert self.cc.linker_so[0:2] == ['ccache', 'my_cc']\n            self.cc.link(None, [], 'a.out', target_lang='c++')\n            call_args = mock_spawn.call_args[0][0]\n            expected = ['my_cxx', '-bundle', '-undefined', 'dynamic_lookup']\n            assert call_args[:4] == expected\n\n    @pytest.mark.skipif('platform.system == \"Windows\"')\n    def test_explicit_ldshared(self):\n        # Issue #18080:\n        # ensure that setting CC env variable does not change\n        #   explicit LDSHARED setting for linker\n        def gcv(v):\n            if v == 'LDSHARED':\n                return 'gcc-4.2 -bundle -undefined dynamic_lookup '\n            return 'gcc-4.2'\n\n        def gcvs(*args, _orig=sysconfig.get_config_vars):\n            if args:\n                return list(map(sysconfig.get_config_var, args))\n            return _orig()\n\n        sysconfig.get_config_var = gcv\n        sysconfig.get_config_vars = gcvs\n        with EnvironmentVarGuard() as env:\n            env['CC'] = 'my_cc'\n            env['LDSHARED'] = 'my_ld -bundle -dynamic'\n            sysconfig.customize_compiler(self.cc)\n        assert self.cc.linker_so[0] == 'my_ld'\n\n    def test_has_function(self):\n        # Issue https://github.com/pypa/distutils/issues/64:\n        # ensure that setting output_dir does not raise\n        # FileNotFoundError: [Errno 2] No such file or directory: 'a.out'\n        self.cc.output_dir = 'scratch'\n        os.chdir(self.mkdtemp())\n        self.cc.has_function('abort')\n\n    def test_find_library_file(self, monkeypatch):\n        compiler = UnixCCompiler()\n        compiler._library_root = lambda dir: dir\n        monkeypatch.setattr(os.path, 'exists', lambda d: 'existing' in d)\n\n        libname = 'libabc.dylib' if sys.platform != 'cygwin' else 'cygabc.dll'\n        dirs = ('/foo/bar/missing', '/foo/bar/existing')\n        assert (\n            compiler.find_library_file(dirs, 'abc').replace('\\\\', '/')\n            == f'/foo/bar/existing/{libname}'\n        )\n        assert (\n            compiler.find_library_file(reversed(dirs), 'abc').replace('\\\\', '/')\n            == f'/foo/bar/existing/{libname}'\n        )\n\n        monkeypatch.setattr(\n            os.path,\n            'exists',\n            lambda d: 'existing' in d and '.a' in d and '.dll.a' not in d,\n        )\n        assert (\n            compiler.find_library_file(dirs, 'abc').replace('\\\\', '/')\n            == '/foo/bar/existing/libabc.a'\n        )\n        assert (\n            compiler.find_library_file(reversed(dirs), 'abc').replace('\\\\', '/')\n            == '/foo/bar/existing/libabc.a'\n        )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_util.py","size":7988,"sha1":"fa76d4c6dc95e772a778679e20f8409dee1b4ca3","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.util.\"\"\"\n\nimport email\nimport email.generator\nimport email.policy\nimport io\nimport os\nimport pathlib\nimport sys\nimport sysconfig as stdlib_sysconfig\nimport unittest.mock as mock\nfrom copy import copy\nfrom distutils import sysconfig, util\nfrom distutils.errors import DistutilsByteCompileError, DistutilsPlatformError\nfrom distutils.util import (\n    byte_compile,\n    change_root,\n    check_environ,\n    convert_path,\n    get_host_platform,\n    get_platform,\n    grok_environment_error,\n    rfc822_escape,\n    split_quoted,\n    strtobool,\n)\n\nimport pytest\n\n\n@pytest.fixture(autouse=True)\ndef environment(monkeypatch):\n    monkeypatch.setattr(os, 'name', os.name)\n    monkeypatch.setattr(sys, 'platform', sys.platform)\n    monkeypatch.setattr(sys, 'version', sys.version)\n    monkeypatch.setattr(os, 'sep', os.sep)\n    monkeypatch.setattr(os.path, 'join', os.path.join)\n    monkeypatch.setattr(os.path, 'isabs', os.path.isabs)\n    monkeypatch.setattr(os.path, 'splitdrive', os.path.splitdrive)\n    monkeypatch.setattr(sysconfig, '_config_vars', copy(sysconfig._config_vars))\n\n\n@pytest.mark.usefixtures('save_env')\nclass TestUtil:\n    def test_get_host_platform(self):\n        with mock.patch('os.name', 'nt'):\n            with mock.patch('sys.version', '... [... (ARM64)]'):\n                assert get_host_platform() == 'win-arm64'\n            with mock.patch('sys.version', '... [... (ARM)]'):\n                assert get_host_platform() == 'win-arm32'\n\n        with mock.patch('sys.version_info', (3, 9, 0, 'final', 0)):\n            assert get_host_platform() == stdlib_sysconfig.get_platform()\n\n    def test_get_platform(self):\n        with mock.patch('os.name', 'nt'):\n            with mock.patch.dict('os.environ', {'VSCMD_ARG_TGT_ARCH': 'x86'}):\n                assert get_platform() == 'win32'\n            with mock.patch.dict('os.environ', {'VSCMD_ARG_TGT_ARCH': 'x64'}):\n                assert get_platform() == 'win-amd64'\n            with mock.patch.dict('os.environ', {'VSCMD_ARG_TGT_ARCH': 'arm'}):\n                assert get_platform() == 'win-arm32'\n            with mock.patch.dict('os.environ', {'VSCMD_ARG_TGT_ARCH': 'arm64'}):\n                assert get_platform() == 'win-arm64'\n\n    def test_convert_path(self):\n        expected = os.sep.join(('', 'home', 'to', 'my', 'stuff'))\n        assert convert_path('/home/to/my/stuff') == expected\n        assert convert_path(pathlib.Path('/home/to/my/stuff')) == expected\n        assert convert_path('.') == os.curdir\n\n    def test_change_root(self):\n        # linux/mac\n        os.name = 'posix'\n\n        def _isabs(path):\n            return path[0] == '/'\n\n        os.path.isabs = _isabs\n\n        def _join(*path):\n            return '/'.join(path)\n\n        os.path.join = _join\n\n        assert change_root('/root', '/old/its/here') == '/root/old/its/here'\n        assert change_root('/root', 'its/here') == '/root/its/here'\n\n        # windows\n        os.name = 'nt'\n        os.sep = '\\\\'\n\n        def _isabs(path):\n            return path.startswith('c:\\\\')\n\n        os.path.isabs = _isabs\n\n        def _splitdrive(path):\n            if path.startswith('c:'):\n                return ('', path.replace('c:', ''))\n            return ('', path)\n\n        os.path.splitdrive = _splitdrive\n\n        def _join(*path):\n            return '\\\\'.join(path)\n\n        os.path.join = _join\n\n        assert (\n            change_root('c:\\\\root', 'c:\\\\old\\\\its\\\\here') == 'c:\\\\root\\\\old\\\\its\\\\here'\n        )\n        assert change_root('c:\\\\root', 'its\\\\here') == 'c:\\\\root\\\\its\\\\here'\n\n        # BugsBunny os (it's a great os)\n        os.name = 'BugsBunny'\n        with pytest.raises(DistutilsPlatformError):\n            change_root('c:\\\\root', 'its\\\\here')\n\n        # XXX platforms to be covered: mac\n\n    def test_check_environ(self):\n        util.check_environ.cache_clear()\n        os.environ.pop('HOME', None)\n\n        check_environ()\n\n        assert os.environ['PLAT'] == get_platform()\n\n    @pytest.mark.skipif(\"os.name != 'posix'\")\n    def test_check_environ_getpwuid(self):\n        util.check_environ.cache_clear()\n        os.environ.pop('HOME', None)\n\n        import pwd\n\n        # only set pw_dir field, other fields are not used\n        result = pwd.struct_passwd((\n            None,\n            None,\n            None,\n            None,\n            None,\n            '/home/distutils',\n            None,\n        ))\n        with mock.patch.object(pwd, 'getpwuid', return_value=result):\n            check_environ()\n            assert os.environ['HOME'] == '/home/distutils'\n\n        util.check_environ.cache_clear()\n        os.environ.pop('HOME', None)\n\n        # bpo-10496: Catch pwd.getpwuid() error\n        with mock.patch.object(pwd, 'getpwuid', side_effect=KeyError):\n            check_environ()\n            assert 'HOME' not in os.environ\n\n    def test_split_quoted(self):\n        assert split_quoted('\"\"one\"\" \"two\" \\'three\\' \\\\four') == [\n            'one',\n            'two',\n            'three',\n            'four',\n        ]\n\n    def test_strtobool(self):\n        yes = ('y', 'Y', 'yes', 'True', 't', 'true', 'True', 'On', 'on', '1')\n        no = ('n', 'no', 'f', 'false', 'off', '0', 'Off', 'No', 'N')\n\n        for y in yes:\n            assert strtobool(y)\n\n        for n in no:\n            assert not strtobool(n)\n\n    indent = 8 * ' '\n\n    @pytest.mark.parametrize(\n        \"given,wanted\",\n        [\n            # 0x0b, 0x0c, ..., etc are also considered a line break by Python\n            (\"hello\\x0b\\nworld\\n\", f\"hello\\x0b{indent}\\n{indent}world\\n{indent}\"),\n            (\"hello\\x1eworld\", f\"hello\\x1e{indent}world\"),\n            (\"\", \"\"),\n            (\n                \"I am a\\npoor\\nlonesome\\nheader\\n\",\n                f\"I am a\\n{indent}poor\\n{indent}lonesome\\n{indent}header\\n{indent}\",\n            ),\n        ],\n    )\n    def test_rfc822_escape(self, given, wanted):\n        \"\"\"\n        We want to ensure a multi-line header parses correctly.\n\n        For interoperability, the escaped value should also \"round-trip\" over\n        `email.generator.Generator.flatten` and `email.message_from_*`\n        (see pypa/setuptools#4033).\n\n        The main issue is that internally `email.policy.EmailPolicy` uses\n        `splitlines` which will split on some control chars. If all the new lines\n        are not prefixed with spaces, the parser will interrupt reading\n        the current header and produce an incomplete value, while\n        incorrectly interpreting the rest of the headers as part of the payload.\n        \"\"\"\n        res = rfc822_escape(given)\n\n        policy = email.policy.EmailPolicy(\n            utf8=True,\n            mangle_from_=False,\n            max_line_length=0,\n        )\n        with io.StringIO() as buffer:\n            raw = f\"header: {res}\\nother-header: 42\\n\\npayload\\n\"\n            orig = email.message_from_string(raw)\n            email.generator.Generator(buffer, policy=policy).flatten(orig)\n            buffer.seek(0)\n            regen = email.message_from_file(buffer)\n\n        for msg in (orig, regen):\n            assert msg.get_payload() == \"payload\\n\"\n            assert msg[\"other-header\"] == \"42\"\n            # Generator may replace control chars with `\\n`\n            assert set(msg[\"header\"].splitlines()) == set(res.splitlines())\n\n        assert res == wanted\n\n    def test_dont_write_bytecode(self):\n        # makes sure byte_compile raise a DistutilsError\n        # if sys.dont_write_bytecode is True\n        old_dont_write_bytecode = sys.dont_write_bytecode\n        sys.dont_write_bytecode = True\n        try:\n            with pytest.raises(DistutilsByteCompileError):\n                byte_compile([])\n        finally:\n            sys.dont_write_bytecode = old_dont_write_bytecode\n\n    def test_grok_environment_error(self):\n        # test obsolete function to ensure backward compat (#4931)\n        exc = OSError(\"Unable to find batch file\")\n        msg = grok_environment_error(exc)\n        assert msg == \"error: Unable to find batch file\"\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_version.py","size":2750,"sha1":"60dcf2795834ef6396cc26477edb1932e7eadfc8","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for distutils.version.\"\"\"\n\nimport distutils\nfrom distutils.version import LooseVersion, StrictVersion\n\nimport pytest\n\n\n@pytest.fixture(autouse=True)\ndef suppress_deprecation():\n    with distutils.version.suppress_known_deprecation():\n        yield\n\n\nclass TestVersion:\n    def test_prerelease(self):\n        version = StrictVersion('1.2.3a1')\n        assert version.version == (1, 2, 3)\n        assert version.prerelease == ('a', 1)\n        assert str(version) == '1.2.3a1'\n\n        version = StrictVersion('1.2.0')\n        assert str(version) == '1.2'\n\n    def test_cmp_strict(self):\n        versions = (\n            ('1.5.1', '1.5.2b2', -1),\n            ('161', '3.10a', ValueError),\n            ('8.02', '8.02', 0),\n            ('3.4j', '1996.07.12', ValueError),\n            ('3.2.pl0', '3.1.1.6', ValueError),\n            ('2g6', '11g', ValueError),\n            ('0.9', '2.2', -1),\n            ('1.2.1', '1.2', 1),\n            ('1.1', '1.2.2', -1),\n            ('1.2', '1.1', 1),\n            ('1.2.1', '1.2.2', -1),\n            ('1.2.2', '1.2', 1),\n            ('1.2', '1.2.2', -1),\n            ('0.4.0', '0.4', 0),\n            ('1.13++', '5.5.kw', ValueError),\n        )\n\n        for v1, v2, wanted in versions:\n            try:\n                res = StrictVersion(v1)._cmp(StrictVersion(v2))\n            except ValueError:\n                if wanted is ValueError:\n                    continue\n                else:\n                    raise AssertionError(f\"cmp({v1}, {v2}) shouldn't raise ValueError\")\n            assert res == wanted, f'cmp({v1}, {v2}) should be {wanted}, got {res}'\n            res = StrictVersion(v1)._cmp(v2)\n            assert res == wanted, f'cmp({v1}, {v2}) should be {wanted}, got {res}'\n            res = StrictVersion(v1)._cmp(object())\n            assert res is NotImplemented, (\n                f'cmp({v1}, {v2}) should be NotImplemented, got {res}'\n            )\n\n    def test_cmp(self):\n        versions = (\n            ('1.5.1', '1.5.2b2', -1),\n            ('161', '3.10a', 1),\n            ('8.02', '8.02', 0),\n            ('3.4j', '1996.07.12', -1),\n            ('3.2.pl0', '3.1.1.6', 1),\n            ('2g6', '11g', -1),\n            ('0.960923', '2.2beta29', -1),\n            ('1.13++', '5.5.kw', -1),\n        )\n\n        for v1, v2, wanted in versions:\n            res = LooseVersion(v1)._cmp(LooseVersion(v2))\n            assert res == wanted, f'cmp({v1}, {v2}) should be {wanted}, got {res}'\n            res = LooseVersion(v1)._cmp(v2)\n            assert res == wanted, f'cmp({v1}, {v2}) should be {wanted}, got {res}'\n            res = LooseVersion(v1)._cmp(object())\n            assert res is NotImplemented, (\n                f'cmp({v1}, {v2}) should be NotImplemented, got {res}'\n            )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/test_versionpredicate.py","size":0,"sha1":"da39a3ee5e6b4b0d3255bfef95601890afd80709","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":""},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/tests/unix_compat.py","size":386,"sha1":"b1b470c3fb736369f9e9045eccf80402df47a7e0","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\n\ntry:\n    import grp\n    import pwd\nexcept ImportError:\n    grp = pwd = None\n\nimport pytest\n\nUNIX_ID_SUPPORT = grp and pwd\nUID_0_SUPPORT = UNIX_ID_SUPPORT and sys.platform != \"cygwin\"\n\nrequire_unix_id = pytest.mark.skipif(\n    not UNIX_ID_SUPPORT, reason=\"Requires grp and pwd support\"\n)\nrequire_uid_0 = pytest.mark.skipif(not UID_0_SUPPORT, reason=\"Requires UID 0 support\")\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/text_file.py","size":12101,"sha1":"a82f681f3632ea22ce39a92cbd8197993099989b","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"text_file\n\nprovides the TextFile class, which gives an interface to text files\nthat (optionally) takes care of stripping comments, ignoring blank\nlines, and joining lines with backslashes.\"\"\"\n\nimport sys\n\n\nclass TextFile:\n    \"\"\"Provides a file-like object that takes care of all the things you\n    commonly want to do when processing a text file that has some\n    line-by-line syntax: strip comments (as long as \"#\" is your\n    comment character), skip blank lines, join adjacent lines by\n    escaping the newline (ie. backslash at end of line), strip\n    leading and/or trailing whitespace.  All of these are optional\n    and independently controllable.\n\n    Provides a 'warn()' method so you can generate warning messages that\n    report physical line number, even if the logical line in question\n    spans multiple physical lines.  Also provides 'unreadline()' for\n    implementing line-at-a-time lookahead.\n\n    Constructor is called as:\n\n        TextFile (filename=None, file=None, **options)\n\n    It bombs (RuntimeError) if both 'filename' and 'file' are None;\n    'filename' should be a string, and 'file' a file object (or\n    something that provides 'readline()' and 'close()' methods).  It is\n    recommended that you supply at least 'filename', so that TextFile\n    can include it in warning messages.  If 'file' is not supplied,\n    TextFile creates its own using 'io.open()'.\n\n    The options are all boolean, and affect the value returned by\n    'readline()':\n      strip_comments [default: true]\n        strip from \"#\" to end-of-line, as well as any whitespace\n        leading up to the \"#\" -- unless it is escaped by a backslash\n      lstrip_ws [default: false]\n        strip leading whitespace from each line before returning it\n      rstrip_ws [default: true]\n        strip trailing whitespace (including line terminator!) from\n        each line before returning it\n      skip_blanks [default: true}\n        skip lines that are empty *after* stripping comments and\n        whitespace.  (If both lstrip_ws and rstrip_ws are false,\n        then some lines may consist of solely whitespace: these will\n        *not* be skipped, even if 'skip_blanks' is true.)\n      join_lines [default: false]\n        if a backslash is the last non-newline character on a line\n        after stripping comments and whitespace, join the following line\n        to it to form one \"logical line\"; if N consecutive lines end\n        with a backslash, then N+1 physical lines will be joined to\n        form one logical line.\n      collapse_join [default: false]\n        strip leading whitespace from lines that are joined to their\n        predecessor; only matters if (join_lines and not lstrip_ws)\n      errors [default: 'strict']\n        error handler used to decode the file content\n\n    Note that since 'rstrip_ws' can strip the trailing newline, the\n    semantics of 'readline()' must differ from those of the builtin file\n    object's 'readline()' method!  In particular, 'readline()' returns\n    None for end-of-file: an empty string might just be a blank line (or\n    an all-whitespace line), if 'rstrip_ws' is true but 'skip_blanks' is\n    not.\"\"\"\n\n    default_options = {\n        'strip_comments': 1,\n        'skip_blanks': 1,\n        'lstrip_ws': 0,\n        'rstrip_ws': 1,\n        'join_lines': 0,\n        'collapse_join': 0,\n        'errors': 'strict',\n    }\n\n    def __init__(self, filename=None, file=None, **options):\n        \"\"\"Construct a new TextFile object.  At least one of 'filename'\n        (a string) and 'file' (a file-like object) must be supplied.\n        They keyword argument options are described above and affect\n        the values returned by 'readline()'.\"\"\"\n        if filename is None and file is None:\n            raise RuntimeError(\n                \"you must supply either or both of 'filename' and 'file'\"\n            )\n\n        # set values for all options -- either from client option hash\n        # or fallback to default_options\n        for opt in self.default_options.keys():\n            if opt in options:\n                setattr(self, opt, options[opt])\n            else:\n                setattr(self, opt, self.default_options[opt])\n\n        # sanity check client option hash\n        for opt in options.keys():\n            if opt not in self.default_options:\n                raise KeyError(f\"invalid TextFile option '{opt}'\")\n\n        if file is None:\n            self.open(filename)\n        else:\n            self.filename = filename\n            self.file = file\n            self.current_line = 0  # assuming that file is at BOF!\n\n        # 'linebuf' is a stack of lines that will be emptied before we\n        # actually read from the file; it's only populated by an\n        # 'unreadline()' operation\n        self.linebuf = []\n\n    def open(self, filename):\n        \"\"\"Open a new file named 'filename'.  This overrides both the\n        'filename' and 'file' arguments to the constructor.\"\"\"\n        self.filename = filename\n        self.file = open(self.filename, errors=self.errors, encoding='utf-8')\n        self.current_line = 0\n\n    def close(self):\n        \"\"\"Close the current file and forget everything we know about it\n        (filename, current line number).\"\"\"\n        file = self.file\n        self.file = None\n        self.filename = None\n        self.current_line = None\n        file.close()\n\n    def gen_error(self, msg, line=None):\n        outmsg = []\n        if line is None:\n            line = self.current_line\n        outmsg.append(self.filename + \", \")\n        if isinstance(line, (list, tuple)):\n            outmsg.append(\"lines {}-{}: \".format(*line))\n        else:\n            outmsg.append(f\"line {int(line)}: \")\n        outmsg.append(str(msg))\n        return \"\".join(outmsg)\n\n    def error(self, msg, line=None):\n        raise ValueError(\"error: \" + self.gen_error(msg, line))\n\n    def warn(self, msg, line=None):\n        \"\"\"Print (to stderr) a warning message tied to the current logical\n        line in the current file.  If the current logical line in the\n        file spans multiple physical lines, the warning refers to the\n        whole range, eg. \"lines 3-5\".  If 'line' supplied, it overrides\n        the current line number; it may be a list or tuple to indicate a\n        range of physical lines, or an integer for a single physical\n        line.\"\"\"\n        sys.stderr.write(\"warning: \" + self.gen_error(msg, line) + \"\\n\")\n\n    def readline(self):  # noqa: C901\n        \"\"\"Read and return a single logical line from the current file (or\n        from an internal buffer if lines have previously been \"unread\"\n        with 'unreadline()').  If the 'join_lines' option is true, this\n        may involve reading multiple physical lines concatenated into a\n        single string.  Updates the current line number, so calling\n        'warn()' after 'readline()' emits a warning about the physical\n        line(s) just read.  Returns None on end-of-file, since the empty\n        string can occur if 'rstrip_ws' is true but 'strip_blanks' is\n        not.\"\"\"\n        # If any \"unread\" lines waiting in 'linebuf', return the top\n        # one.  (We don't actually buffer read-ahead data -- lines only\n        # get put in 'linebuf' if the client explicitly does an\n        # 'unreadline()'.\n        if self.linebuf:\n            line = self.linebuf[-1]\n            del self.linebuf[-1]\n            return line\n\n        buildup_line = ''\n\n        while True:\n            # read the line, make it None if EOF\n            line = self.file.readline()\n            if line == '':\n                line = None\n\n            if self.strip_comments and line:\n                # Look for the first \"#\" in the line.  If none, never\n                # mind.  If we find one and it's the first character, or\n                # is not preceded by \"\\\", then it starts a comment --\n                # strip the comment, strip whitespace before it, and\n                # carry on.  Otherwise, it's just an escaped \"#\", so\n                # unescape it (and any other escaped \"#\"'s that might be\n                # lurking in there) and otherwise leave the line alone.\n\n                pos = line.find(\"#\")\n                if pos == -1:  # no \"#\" -- no comments\n                    pass\n\n                # It's definitely a comment -- either \"#\" is the first\n                # character, or it's elsewhere and unescaped.\n                elif pos == 0 or line[pos - 1] != \"\\\\\":\n                    # Have to preserve the trailing newline, because it's\n                    # the job of a later step (rstrip_ws) to remove it --\n                    # and if rstrip_ws is false, we'd better preserve it!\n                    # (NB. this means that if the final line is all comment\n                    # and has no trailing newline, we will think that it's\n                    # EOF; I think that's OK.)\n                    eol = (line[-1] == '\\n') and '\\n' or ''\n                    line = line[0:pos] + eol\n\n                    # If all that's left is whitespace, then skip line\n                    # *now*, before we try to join it to 'buildup_line' --\n                    # that way constructs like\n                    #   hello \\\\\n                    #   # comment that should be ignored\n                    #   there\n                    # result in \"hello there\".\n                    if line.strip() == \"\":\n                        continue\n                else:  # it's an escaped \"#\"\n                    line = line.replace(\"\\\\#\", \"#\")\n\n            # did previous line end with a backslash? then accumulate\n            if self.join_lines and buildup_line:\n                # oops: end of file\n                if line is None:\n                    self.warn(\"continuation line immediately precedes end-of-file\")\n                    return buildup_line\n\n                if self.collapse_join:\n                    line = line.lstrip()\n                line = buildup_line + line\n\n                # careful: pay attention to line number when incrementing it\n                if isinstance(self.current_line, list):\n                    self.current_line[1] = self.current_line[1] + 1\n                else:\n                    self.current_line = [self.current_line, self.current_line + 1]\n            # just an ordinary line, read it as usual\n            else:\n                if line is None:  # eof\n                    return None\n\n                # still have to be careful about incrementing the line number!\n                if isinstance(self.current_line, list):\n                    self.current_line = self.current_line[1] + 1\n                else:\n                    self.current_line = self.current_line + 1\n\n            # strip whitespace however the client wants (leading and\n            # trailing, or one or the other, or neither)\n            if self.lstrip_ws and self.rstrip_ws:\n                line = line.strip()\n            elif self.lstrip_ws:\n                line = line.lstrip()\n            elif self.rstrip_ws:\n                line = line.rstrip()\n\n            # blank line (whether we rstrip'ed or not)? skip to next line\n            # if appropriate\n            if line in ('', '\\n') and self.skip_blanks:\n                continue\n\n            if self.join_lines:\n                if line[-1] == '\\\\':\n                    buildup_line = line[:-1]\n                    continue\n\n                if line[-2:] == '\\\\\\n':\n                    buildup_line = line[0:-2] + '\\n'\n                    continue\n\n            # well, I guess there's some actual content there: return it\n            return line\n\n    def readlines(self):\n        \"\"\"Read and return the list of all logical lines remaining in the\n        current file.\"\"\"\n        lines = []\n        while True:\n            line = self.readline()\n            if line is None:\n                return lines\n            lines.append(line)\n\n    def unreadline(self, line):\n        \"\"\"Push 'line' (a string) onto an internal buffer that will be\n        checked by future 'readline()' calls.  Handy for implementing\n        a parser with line-at-a-time lookahead.\"\"\"\n        self.linebuf.append(line)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/unixccompiler.py","size":15437,"sha1":"78b095dbe2eee7c7ad99144f0bdeee580a518219","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.unixccompiler\n\nContains the UnixCCompiler class, a subclass of CCompiler that handles\nthe \"typical\" Unix-style command-line C compiler:\n  * macros defined with -Dname[=value]\n  * macros undefined with -Uname\n  * include search directories specified with -Idir\n  * libraries specified with -lllib\n  * library search directories specified with -Ldir\n  * compile handled by 'cc' (or similar) executable with -c option:\n    compiles .c to .o\n  * link static library handled by 'ar' command (possibly with 'ranlib')\n  * link shared library handled by 'cc -shared'\n\"\"\"\n\nfrom __future__ import annotations\n\nimport itertools\nimport os\nimport re\nimport shlex\nimport sys\n\nfrom . import sysconfig\nfrom ._log import log\nfrom ._macos_compat import compiler_fixup\nfrom ._modified import newer\nfrom .ccompiler import CCompiler, gen_lib_options, gen_preprocess_options\nfrom .compat import consolidate_linker_args\nfrom .errors import CompileError, DistutilsExecError, LibError, LinkError\n\n# XXX Things not currently handled:\n#   * optimization/debug/warning flags; we just use whatever's in Python's\n#     Makefile and live with it.  Is this adequate?  If not, we might\n#     have to have a bunch of subclasses GNUCCompiler, SGICCompiler,\n#     SunCCompiler, and I suspect down that road lies madness.\n#   * even if we don't know a warning flag from an optimization flag,\n#     we need some way for outsiders to feed preprocessor/compiler/linker\n#     flags in to us -- eg. a sysadmin might want to mandate certain flags\n#     via a site config file, or a user might want to set something for\n#     compiling this module distribution only via the setup.py command\n#     line, whatever.  As long as these options come from something on the\n#     current system, they can be as system-dependent as they like, and we\n#     should just happily stuff them into the preprocessor/compiler/linker\n#     options and carry on.\n\n\ndef _split_env(cmd):\n    \"\"\"\n    For macOS, split command into 'env' portion (if any)\n    and the rest of the linker command.\n\n    >>> _split_env(['a', 'b', 'c'])\n    ([], ['a', 'b', 'c'])\n    >>> _split_env(['/usr/bin/env', 'A=3', 'gcc'])\n    (['/usr/bin/env', 'A=3'], ['gcc'])\n    \"\"\"\n    pivot = 0\n    if os.path.basename(cmd[0]) == \"env\":\n        pivot = 1\n        while '=' in cmd[pivot]:\n            pivot += 1\n    return cmd[:pivot], cmd[pivot:]\n\n\ndef _split_aix(cmd):\n    \"\"\"\n    AIX platforms prefix the compiler with the ld_so_aix\n    script, so split that from the linker command.\n\n    >>> _split_aix(['a', 'b', 'c'])\n    ([], ['a', 'b', 'c'])\n    >>> _split_aix(['/bin/foo/ld_so_aix', 'gcc'])\n    (['/bin/foo/ld_so_aix'], ['gcc'])\n    \"\"\"\n    pivot = os.path.basename(cmd[0]) == 'ld_so_aix'\n    return cmd[:pivot], cmd[pivot:]\n\n\ndef _linker_params(linker_cmd, compiler_cmd):\n    \"\"\"\n    The linker command usually begins with the compiler\n    command (possibly multiple elements), followed by zero or more\n    params for shared library building.\n\n    If the LDSHARED env variable overrides the linker command,\n    however, the commands may not match.\n\n    Return the best guess of the linker parameters by stripping\n    the linker command. If the compiler command does not\n    match the linker command, assume the linker command is\n    just the first element.\n\n    >>> _linker_params('gcc foo bar'.split(), ['gcc'])\n    ['foo', 'bar']\n    >>> _linker_params('gcc foo bar'.split(), ['other'])\n    ['foo', 'bar']\n    >>> _linker_params('ccache gcc foo bar'.split(), 'ccache gcc'.split())\n    ['foo', 'bar']\n    >>> _linker_params(['gcc'], ['gcc'])\n    []\n    \"\"\"\n    c_len = len(compiler_cmd)\n    pivot = c_len if linker_cmd[:c_len] == compiler_cmd else 1\n    return linker_cmd[pivot:]\n\n\nclass UnixCCompiler(CCompiler):\n    compiler_type = 'unix'\n\n    # These are used by CCompiler in two places: the constructor sets\n    # instance attributes 'preprocessor', 'compiler', etc. from them, and\n    # 'set_executable()' allows any of these to be set.  The defaults here\n    # are pretty generic; they will probably have to be set by an outsider\n    # (eg. using information discovered by the sysconfig about building\n    # Python extensions).\n    executables = {\n        'preprocessor': None,\n        'compiler': [\"cc\"],\n        'compiler_so': [\"cc\"],\n        'compiler_cxx': [\"c++\"],\n        'compiler_so_cxx': [\"c++\"],\n        'linker_so': [\"cc\", \"-shared\"],\n        'linker_so_cxx': [\"c++\", \"-shared\"],\n        'linker_exe': [\"cc\"],\n        'linker_exe_cxx': [\"c++\", \"-shared\"],\n        'archiver': [\"ar\", \"-cr\"],\n        'ranlib': None,\n    }\n\n    if sys.platform[:6] == \"darwin\":\n        executables['ranlib'] = [\"ranlib\"]\n\n    # Needed for the filename generation methods provided by the base\n    # class, CCompiler.  NB. whoever instantiates/uses a particular\n    # UnixCCompiler instance should set 'shared_lib_ext' -- we set a\n    # reasonable common default here, but it's not necessarily used on all\n    # Unices!\n\n    src_extensions = [\".c\", \".C\", \".cc\", \".cxx\", \".cpp\", \".m\"]\n    obj_extension = \".o\"\n    static_lib_extension = \".a\"\n    shared_lib_extension = \".so\"\n    dylib_lib_extension = \".dylib\"\n    xcode_stub_lib_extension = \".tbd\"\n    static_lib_format = shared_lib_format = dylib_lib_format = \"lib%s%s\"\n    xcode_stub_lib_format = dylib_lib_format\n    if sys.platform == \"cygwin\":\n        exe_extension = \".exe\"\n        shared_lib_extension = \".dll.a\"\n        dylib_lib_extension = \".dll\"\n        dylib_lib_format = \"cyg%s%s\"\n\n    def preprocess(\n        self,\n        source,\n        output_file=None,\n        macros=None,\n        include_dirs=None,\n        extra_preargs=None,\n        extra_postargs=None,\n    ):\n        fixed_args = self._fix_compile_args(None, macros, include_dirs)\n        ignore, macros, include_dirs = fixed_args\n        pp_opts = gen_preprocess_options(macros, include_dirs)\n        pp_args = self.preprocessor + pp_opts\n        if output_file:\n            pp_args.extend(['-o', output_file])\n        if extra_preargs:\n            pp_args[:0] = extra_preargs\n        if extra_postargs:\n            pp_args.extend(extra_postargs)\n        pp_args.append(source)\n\n        # reasons to preprocess:\n        # - force is indicated\n        # - output is directed to stdout\n        # - source file is newer than the target\n        preprocess = self.force or output_file is None or newer(source, output_file)\n        if not preprocess:\n            return\n\n        if output_file:\n            self.mkpath(os.path.dirname(output_file))\n\n        try:\n            self.spawn(pp_args)\n        except DistutilsExecError as msg:\n            raise CompileError(msg)\n\n    def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):\n        compiler_so = compiler_fixup(self.compiler_so, cc_args + extra_postargs)\n        compiler_so_cxx = compiler_fixup(self.compiler_so_cxx, cc_args + extra_postargs)\n        try:\n            if self.detect_language(src) == 'c++':\n                self.spawn(\n                    compiler_so_cxx + cc_args + [src, '-o', obj] + extra_postargs\n                )\n            else:\n                self.spawn(compiler_so + cc_args + [src, '-o', obj] + extra_postargs)\n        except DistutilsExecError as msg:\n            raise CompileError(msg)\n\n    def create_static_lib(\n        self, objects, output_libname, output_dir=None, debug=False, target_lang=None\n    ):\n        objects, output_dir = self._fix_object_args(objects, output_dir)\n\n        output_filename = self.library_filename(output_libname, output_dir=output_dir)\n\n        if self._need_link(objects, output_filename):\n            self.mkpath(os.path.dirname(output_filename))\n            self.spawn(self.archiver + [output_filename] + objects + self.objects)\n\n            # Not many Unices required ranlib anymore -- SunOS 4.x is, I\n            # think the only major Unix that does.  Maybe we need some\n            # platform intelligence here to skip ranlib if it's not\n            # needed -- or maybe Python's configure script took care of\n            # it for us, hence the check for leading colon.\n            if self.ranlib:\n                try:\n                    self.spawn(self.ranlib + [output_filename])\n                except DistutilsExecError as msg:\n                    raise LibError(msg)\n        else:\n            log.debug(\"skipping %s (up-to-date)\", output_filename)\n\n    def link(\n        self,\n        target_desc,\n        objects,\n        output_filename,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        export_symbols=None,\n        debug=False,\n        extra_preargs=None,\n        extra_postargs=None,\n        build_temp=None,\n        target_lang=None,\n    ):\n        objects, output_dir = self._fix_object_args(objects, output_dir)\n        fixed_args = self._fix_lib_args(libraries, library_dirs, runtime_library_dirs)\n        libraries, library_dirs, runtime_library_dirs = fixed_args\n\n        lib_opts = gen_lib_options(self, library_dirs, runtime_library_dirs, libraries)\n        if not isinstance(output_dir, (str, type(None))):\n            raise TypeError(\"'output_dir' must be a string or None\")\n        if output_dir is not None:\n            output_filename = os.path.join(output_dir, output_filename)\n\n        if self._need_link(objects, output_filename):\n            ld_args = objects + self.objects + lib_opts + ['-o', output_filename]\n            if debug:\n                ld_args[:0] = ['-g']\n            if extra_preargs:\n                ld_args[:0] = extra_preargs\n            if extra_postargs:\n                ld_args.extend(extra_postargs)\n            self.mkpath(os.path.dirname(output_filename))\n            try:\n                # Select a linker based on context: linker_exe when\n                # building an executable or linker_so (with shared options)\n                # when building a shared library.\n                building_exe = target_desc == CCompiler.EXECUTABLE\n                linker = (\n                    self.linker_exe\n                    if building_exe\n                    else (\n                        self.linker_so_cxx if target_lang == \"c++\" else self.linker_so\n                    )\n                )[:]\n\n                if target_lang == \"c++\" and self.compiler_cxx:\n                    env, linker_ne = _split_env(linker)\n                    aix, linker_na = _split_aix(linker_ne)\n                    _, compiler_cxx_ne = _split_env(self.compiler_cxx)\n                    _, linker_exe_ne = _split_env(self.linker_exe)\n\n                    params = _linker_params(linker_na, linker_exe_ne)\n                    linker = env + aix + compiler_cxx_ne + params\n\n                linker = compiler_fixup(linker, ld_args)\n\n                self.spawn(linker + ld_args)\n            except DistutilsExecError as msg:\n                raise LinkError(msg)\n        else:\n            log.debug(\"skipping %s (up-to-date)\", output_filename)\n\n    # -- Miscellaneous methods -----------------------------------------\n    # These are all used by the 'gen_lib_options() function, in\n    # ccompiler.py.\n\n    def library_dir_option(self, dir):\n        return \"-L\" + dir\n\n    def _is_gcc(self):\n        cc_var = sysconfig.get_config_var(\"CC\")\n        compiler = os.path.basename(shlex.split(cc_var)[0])\n        return \"gcc\" in compiler or \"g++\" in compiler\n\n    def runtime_library_dir_option(self, dir: str) -> str | list[str]:\n        # XXX Hackish, at the very least.  See Python bug #445902:\n        # https://bugs.python.org/issue445902\n        # Linkers on different platforms need different options to\n        # specify that directories need to be added to the list of\n        # directories searched for dependencies when a dynamic library\n        # is sought.  GCC on GNU systems (Linux, FreeBSD, ...) has to\n        # be told to pass the -R option through to the linker, whereas\n        # other compilers and gcc on other systems just know this.\n        # Other compilers may need something slightly different.  At\n        # this time, there's no way to determine this information from\n        # the configuration data stored in the Python installation, so\n        # we use this hack.\n        if sys.platform[:6] == \"darwin\":\n            from distutils.util import get_macosx_target_ver, split_version\n\n            macosx_target_ver = get_macosx_target_ver()\n            if macosx_target_ver and split_version(macosx_target_ver) >= [10, 5]:\n                return \"-Wl,-rpath,\" + dir\n            else:  # no support for -rpath on earlier macOS versions\n                return \"-L\" + dir\n        elif sys.platform[:7] == \"freebsd\":\n            return \"-Wl,-rpath=\" + dir\n        elif sys.platform[:5] == \"hp-ux\":\n            return [\n                \"-Wl,+s\" if self._is_gcc() else \"+s\",\n                \"-L\" + dir,\n            ]\n\n        # For all compilers, `-Wl` is the presumed way to pass a\n        # compiler option to the linker\n        if sysconfig.get_config_var(\"GNULD\") == \"yes\":\n            return consolidate_linker_args([\n                # Force RUNPATH instead of RPATH\n                \"-Wl,--enable-new-dtags\",\n                \"-Wl,-rpath,\" + dir,\n            ])\n        else:\n            return \"-Wl,-R\" + dir\n\n    def library_option(self, lib):\n        return \"-l\" + lib\n\n    @staticmethod\n    def _library_root(dir):\n        \"\"\"\n        macOS users can specify an alternate SDK using'-isysroot'.\n        Calculate the SDK root if it is specified.\n\n        Note that, as of Xcode 7, Apple SDKs may contain textual stub\n        libraries with .tbd extensions rather than the normal .dylib\n        shared libraries installed in /.  The Apple compiler tool\n        chain handles this transparently but it can cause problems\n        for programs that are being built with an SDK and searching\n        for specific libraries.  Callers of find_library_file need to\n        keep in mind that the base filename of the returned SDK library\n        file might have a different extension from that of the library\n        file installed on the running system, for example:\n          /Applications/Xcode.app/Contents/Developer/Platforms/\n              MacOSX.platform/Developer/SDKs/MacOSX10.11.sdk/\n              usr/lib/libedit.tbd\n        vs\n          /usr/lib/libedit.dylib\n        \"\"\"\n        cflags = sysconfig.get_config_var('CFLAGS')\n        match = re.search(r'-isysroot\\s*(\\S+)', cflags)\n\n        apply_root = (\n            sys.platform == 'darwin'\n            and match\n            and (\n                dir.startswith('/System/')\n                or (dir.startswith('/usr/') and not dir.startswith('/usr/local/'))\n            )\n        )\n\n        return os.path.join(match.group(1), dir[1:]) if apply_root else dir\n\n    def find_library_file(self, dirs, lib, debug=False):\n        \"\"\"\n        Second-guess the linker with not much hard\n        data to go on: GCC seems to prefer the shared library, so\n        assume that *all* Unix C compilers do,\n        ignoring even GCC's \"-static\" option.\n        \"\"\"\n        lib_names = (\n            self.library_filename(lib, lib_type=type)\n            for type in 'dylib xcode_stub shared static'.split()\n        )\n\n        roots = map(self._library_root, dirs)\n\n        searched = itertools.starmap(os.path.join, itertools.product(roots, lib_names))\n\n        found = filter(os.path.exists, searched)\n\n        # Return None if it could not be found in any dir.\n        return next(found, None)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/util.py","size":17493,"sha1":"b3317a66f427d7a3fb6e6d6b515323306fbedcd7","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.util\n\nMiscellaneous utility functions -- anything that doesn't fit into\none of the other *util.py modules.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport functools\nimport importlib.util\nimport os\nimport pathlib\nimport re\nimport string\nimport subprocess\nimport sys\nimport sysconfig\nimport tempfile\n\nfrom jaraco.functools import pass_none\n\nfrom ._log import log\nfrom ._modified import newer\nfrom .errors import DistutilsByteCompileError, DistutilsPlatformError\nfrom .spawn import spawn\n\n\ndef get_host_platform() -> str:\n    \"\"\"\n    Return a string that identifies the current platform. Use this\n    function to distinguish platform-specific build directories and\n    platform-specific built distributions.\n    \"\"\"\n\n    # This function initially exposed platforms as defined in Python 3.9\n    # even with older Python versions when distutils was split out.\n    # Now it delegates to stdlib sysconfig.\n\n    return sysconfig.get_platform()\n\n\ndef get_platform():\n    if os.name == 'nt':\n        TARGET_TO_PLAT = {\n            'x86': 'win32',\n            'x64': 'win-amd64',\n            'arm': 'win-arm32',\n            'arm64': 'win-arm64',\n        }\n        target = os.environ.get('VSCMD_ARG_TGT_ARCH')\n        return TARGET_TO_PLAT.get(target) or get_host_platform()\n    return get_host_platform()\n\n\nif sys.platform == 'darwin':\n    _syscfg_macosx_ver = None  # cache the version pulled from sysconfig\nMACOSX_VERSION_VAR = 'MACOSX_DEPLOYMENT_TARGET'\n\n\ndef _clear_cached_macosx_ver():\n    \"\"\"For testing only. Do not call.\"\"\"\n    global _syscfg_macosx_ver\n    _syscfg_macosx_ver = None\n\n\ndef get_macosx_target_ver_from_syscfg():\n    \"\"\"Get the version of macOS latched in the Python interpreter configuration.\n    Returns the version as a string or None if can't obtain one. Cached.\"\"\"\n    global _syscfg_macosx_ver\n    if _syscfg_macosx_ver is None:\n        from distutils import sysconfig\n\n        ver = sysconfig.get_config_var(MACOSX_VERSION_VAR) or ''\n        if ver:\n            _syscfg_macosx_ver = ver\n    return _syscfg_macosx_ver\n\n\ndef get_macosx_target_ver():\n    \"\"\"Return the version of macOS for which we are building.\n\n    The target version defaults to the version in sysconfig latched at time\n    the Python interpreter was built, unless overridden by an environment\n    variable. If neither source has a value, then None is returned\"\"\"\n\n    syscfg_ver = get_macosx_target_ver_from_syscfg()\n    env_ver = os.environ.get(MACOSX_VERSION_VAR)\n\n    if env_ver:\n        # Validate overridden version against sysconfig version, if have both.\n        # Ensure that the deployment target of the build process is not less\n        # than 10.3 if the interpreter was built for 10.3 or later.  This\n        # ensures extension modules are built with correct compatibility\n        # values, specifically LDSHARED which can use\n        # '-undefined dynamic_lookup' which only works on >= 10.3.\n        if (\n            syscfg_ver\n            and split_version(syscfg_ver) >= [10, 3]\n            and split_version(env_ver) < [10, 3]\n        ):\n            my_msg = (\n                '$' + MACOSX_VERSION_VAR + ' mismatch: '\n                f'now \"{env_ver}\" but \"{syscfg_ver}\" during configure; '\n                'must use 10.3 or later'\n            )\n            raise DistutilsPlatformError(my_msg)\n        return env_ver\n    return syscfg_ver\n\n\ndef split_version(s):\n    \"\"\"Convert a dot-separated string into a list of numbers for comparisons\"\"\"\n    return [int(n) for n in s.split('.')]\n\n\n@pass_none\ndef convert_path(pathname: str | os.PathLike) -> str:\n    r\"\"\"\n    Allow for pathlib.Path inputs, coax to a native path string.\n\n    If None is passed, will just pass it through as\n    Setuptools relies on this behavior.\n\n    >>> convert_path(None) is None\n    True\n\n    Removes empty paths.\n\n    >>> convert_path('foo/./bar').replace('\\\\', '/')\n    'foo/bar'\n    \"\"\"\n    return os.fspath(pathlib.PurePath(pathname))\n\n\ndef change_root(new_root, pathname):\n    \"\"\"Return 'pathname' with 'new_root' prepended.  If 'pathname' is\n    relative, this is equivalent to \"os.path.join(new_root,pathname)\".\n    Otherwise, it requires making 'pathname' relative and then joining the\n    two, which is tricky on DOS/Windows and Mac OS.\n    \"\"\"\n    if os.name == 'posix':\n        if not os.path.isabs(pathname):\n            return os.path.join(new_root, pathname)\n        else:\n            return os.path.join(new_root, pathname[1:])\n\n    elif os.name == 'nt':\n        (drive, path) = os.path.splitdrive(pathname)\n        if path[0] == os.sep:\n            path = path[1:]\n        return os.path.join(new_root, path)\n\n    raise DistutilsPlatformError(f\"nothing known about platform '{os.name}'\")\n\n\n@functools.lru_cache\ndef check_environ():\n    \"\"\"Ensure that 'os.environ' has all the environment variables we\n    guarantee that users can use in config files, command-line options,\n    etc.  Currently this includes:\n      HOME - user's home directory (Unix only)\n      PLAT - description of the current platform, including hardware\n             and OS (see 'get_platform()')\n    \"\"\"\n    if os.name == 'posix' and 'HOME' not in os.environ:\n        try:\n            import pwd\n\n            os.environ['HOME'] = pwd.getpwuid(os.getuid())[5]\n        except (ImportError, KeyError):\n            # bpo-10496: if the current user identifier doesn't exist in the\n            # password database, do nothing\n            pass\n\n    if 'PLAT' not in os.environ:\n        os.environ['PLAT'] = get_platform()\n\n\ndef subst_vars(s, local_vars):\n    \"\"\"\n    Perform variable substitution on 'string'.\n    Variables are indicated by format-style braces (\"{var}\").\n    Variable is substituted by the value found in the 'local_vars'\n    dictionary or in 'os.environ' if it's not in 'local_vars'.\n    'os.environ' is first checked/augmented to guarantee that it contains\n    certain values: see 'check_environ()'.  Raise ValueError for any\n    variables not found in either 'local_vars' or 'os.environ'.\n    \"\"\"\n    check_environ()\n    lookup = dict(os.environ)\n    lookup.update((name, str(value)) for name, value in local_vars.items())\n    try:\n        return _subst_compat(s).format_map(lookup)\n    except KeyError as var:\n        raise ValueError(f\"invalid variable {var}\")\n\n\ndef _subst_compat(s):\n    \"\"\"\n    Replace shell/Perl-style variable substitution with\n    format-style. For compatibility.\n    \"\"\"\n\n    def _subst(match):\n        return f'{{{match.group(1)}}}'\n\n    repl = re.sub(r'\\$([a-zA-Z_][a-zA-Z_0-9]*)', _subst, s)\n    if repl != s:\n        import warnings\n\n        warnings.warn(\n            \"shell/Perl-style substitutions are deprecated\",\n            DeprecationWarning,\n        )\n    return repl\n\n\ndef grok_environment_error(exc, prefix=\"error: \"):\n    # Function kept for backward compatibility.\n    # Used to try clever things with EnvironmentErrors,\n    # but nowadays str(exception) produces good messages.\n    return prefix + str(exc)\n\n\n# Needed by 'split_quoted()'\n_wordchars_re = _squote_re = _dquote_re = None\n\n\ndef _init_regex():\n    global _wordchars_re, _squote_re, _dquote_re\n    _wordchars_re = re.compile(rf'[^\\\\\\'\\\"{string.whitespace} ]*')\n    _squote_re = re.compile(r\"'(?:[^'\\\\]|\\\\.)*'\")\n    _dquote_re = re.compile(r'\"(?:[^\"\\\\]|\\\\.)*\"')\n\n\ndef split_quoted(s):\n    \"\"\"Split a string up according to Unix shell-like rules for quotes and\n    backslashes.  In short: words are delimited by spaces, as long as those\n    spaces are not escaped by a backslash, or inside a quoted string.\n    Single and double quotes are equivalent, and the quote characters can\n    be backslash-escaped.  The backslash is stripped from any two-character\n    escape sequence, leaving only the escaped character.  The quote\n    characters are stripped from any quoted string.  Returns a list of\n    words.\n    \"\"\"\n\n    # This is a nice algorithm for splitting up a single string, since it\n    # doesn't require character-by-character examination.  It was a little\n    # bit of a brain-bender to get it working right, though...\n    if _wordchars_re is None:\n        _init_regex()\n\n    s = s.strip()\n    words = []\n    pos = 0\n\n    while s:\n        m = _wordchars_re.match(s, pos)\n        end = m.end()\n        if end == len(s):\n            words.append(s[:end])\n            break\n\n        if s[end] in string.whitespace:\n            # unescaped, unquoted whitespace: now\n            # we definitely have a word delimiter\n            words.append(s[:end])\n            s = s[end:].lstrip()\n            pos = 0\n\n        elif s[end] == '\\\\':\n            # preserve whatever is being escaped;\n            # will become part of the current word\n            s = s[:end] + s[end + 1 :]\n            pos = end + 1\n\n        else:\n            if s[end] == \"'\":  # slurp singly-quoted string\n                m = _squote_re.match(s, end)\n            elif s[end] == '\"':  # slurp doubly-quoted string\n                m = _dquote_re.match(s, end)\n            else:\n                raise RuntimeError(f\"this can't happen (bad char '{s[end]}')\")\n\n            if m is None:\n                raise ValueError(f\"bad string (mismatched {s[end]} quotes?)\")\n\n            (beg, end) = m.span()\n            s = s[:beg] + s[beg + 1 : end - 1] + s[end:]\n            pos = m.end() - 2\n\n        if pos >= len(s):\n            words.append(s)\n            break\n\n    return words\n\n\n# split_quoted ()\n\n\ndef execute(func, args, msg=None, verbose=False, dry_run=False):\n    \"\"\"Perform some action that affects the outside world (eg.  by\n    writing to the filesystem).  Such actions are special because they\n    are disabled by the 'dry_run' flag.  This method takes care of all\n    that bureaucracy for you; all you have to do is supply the\n    function to call and an argument tuple for it (to embody the\n    \"external action\" being performed), and an optional message to\n    print.\n    \"\"\"\n    if msg is None:\n        msg = f\"{func.__name__}{args!r}\"\n        if msg[-2:] == ',)':  # correct for singleton tuple\n            msg = msg[0:-2] + ')'\n\n    log.info(msg)\n    if not dry_run:\n        func(*args)\n\n\ndef strtobool(val):\n    \"\"\"Convert a string representation of truth to true (1) or false (0).\n\n    True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values\n    are 'n', 'no', 'f', 'false', 'off', and '0'.  Raises ValueError if\n    'val' is anything else.\n    \"\"\"\n    val = val.lower()\n    if val in ('y', 'yes', 't', 'true', 'on', '1'):\n        return 1\n    elif val in ('n', 'no', 'f', 'false', 'off', '0'):\n        return 0\n    else:\n        raise ValueError(f\"invalid truth value {val!r}\")\n\n\ndef byte_compile(  # noqa: C901\n    py_files,\n    optimize=0,\n    force=False,\n    prefix=None,\n    base_dir=None,\n    verbose=True,\n    dry_run=False,\n    direct=None,\n):\n    \"\"\"Byte-compile a collection of Python source files to .pyc\n    files in a __pycache__ subdirectory.  'py_files' is a list\n    of files to compile; any files that don't end in \".py\" are silently\n    skipped.  'optimize' must be one of the following:\n      0 - don't optimize\n      1 - normal optimization (like \"python -O\")\n      2 - extra optimization (like \"python -OO\")\n    If 'force' is true, all files are recompiled regardless of\n    timestamps.\n\n    The source filename encoded in each bytecode file defaults to the\n    filenames listed in 'py_files'; you can modify these with 'prefix' and\n    'basedir'.  'prefix' is a string that will be stripped off of each\n    source filename, and 'base_dir' is a directory name that will be\n    prepended (after 'prefix' is stripped).  You can supply either or both\n    (or neither) of 'prefix' and 'base_dir', as you wish.\n\n    If 'dry_run' is true, doesn't actually do anything that would\n    affect the filesystem.\n\n    Byte-compilation is either done directly in this interpreter process\n    with the standard py_compile module, or indirectly by writing a\n    temporary script and executing it.  Normally, you should let\n    'byte_compile()' figure out to use direct compilation or not (see\n    the source for details).  The 'direct' flag is used by the script\n    generated in indirect mode; unless you know what you're doing, leave\n    it set to None.\n    \"\"\"\n\n    # nothing is done if sys.dont_write_bytecode is True\n    if sys.dont_write_bytecode:\n        raise DistutilsByteCompileError('byte-compiling is disabled.')\n\n    # First, if the caller didn't force us into direct or indirect mode,\n    # figure out which mode we should be in.  We take a conservative\n    # approach: choose direct mode *only* if the current interpreter is\n    # in debug mode and optimize is 0.  If we're not in debug mode (-O\n    # or -OO), we don't know which level of optimization this\n    # interpreter is running with, so we can't do direct\n    # byte-compilation and be certain that it's the right thing.  Thus,\n    # always compile indirectly if the current interpreter is in either\n    # optimize mode, or if either optimization level was requested by\n    # the caller.\n    if direct is None:\n        direct = __debug__ and optimize == 0\n\n    # \"Indirect\" byte-compilation: write a temporary script and then\n    # run it with the appropriate flags.\n    if not direct:\n        (script_fd, script_name) = tempfile.mkstemp(\".py\")\n        log.info(\"writing byte-compilation script '%s'\", script_name)\n        if not dry_run:\n            script = os.fdopen(script_fd, \"w\", encoding='utf-8')\n\n            with script:\n                script.write(\n                    \"\"\"\\\nfrom distutils.util import byte_compile\nfiles = [\n\"\"\"\n                )\n\n                # XXX would be nice to write absolute filenames, just for\n                # safety's sake (script should be more robust in the face of\n                # chdir'ing before running it).  But this requires abspath'ing\n                # 'prefix' as well, and that breaks the hack in build_lib's\n                # 'byte_compile()' method that carefully tacks on a trailing\n                # slash (os.sep really) to make sure the prefix here is \"just\n                # right\".  This whole prefix business is rather delicate -- the\n                # problem is that it's really a directory, but I'm treating it\n                # as a dumb string, so trailing slashes and so forth matter.\n\n                script.write(\",\\n\".join(map(repr, py_files)) + \"]\\n\")\n                script.write(\n                    f\"\"\"\nbyte_compile(files, optimize={optimize!r}, force={force!r},\n             prefix={prefix!r}, base_dir={base_dir!r},\n             verbose={verbose!r}, dry_run=False,\n             direct=True)\n\"\"\"\n                )\n\n        cmd = [sys.executable]\n        cmd.extend(subprocess._optim_args_from_interpreter_flags())\n        cmd.append(script_name)\n        spawn(cmd, dry_run=dry_run)\n        execute(os.remove, (script_name,), f\"removing {script_name}\", dry_run=dry_run)\n\n    # \"Direct\" byte-compilation: use the py_compile module to compile\n    # right here, right now.  Note that the script generated in indirect\n    # mode simply calls 'byte_compile()' in direct mode, a weird sort of\n    # cross-process recursion.  Hey, it works!\n    else:\n        from py_compile import compile\n\n        for file in py_files:\n            if file[-3:] != \".py\":\n                # This lets us be lazy and not filter filenames in\n                # the \"install_lib\" command.\n                continue\n\n            # Terminology from the py_compile module:\n            #   cfile - byte-compiled file\n            #   dfile - purported source filename (same as 'file' by default)\n            if optimize >= 0:\n                opt = '' if optimize == 0 else optimize\n                cfile = importlib.util.cache_from_source(file, optimization=opt)\n            else:\n                cfile = importlib.util.cache_from_source(file)\n            dfile = file\n            if prefix:\n                if file[: len(prefix)] != prefix:\n                    raise ValueError(\n                        f\"invalid prefix: filename {file!r} doesn't start with {prefix!r}\"\n                    )\n                dfile = dfile[len(prefix) :]\n            if base_dir:\n                dfile = os.path.join(base_dir, dfile)\n\n            cfile_base = os.path.basename(cfile)\n            if direct:\n                if force or newer(file, cfile):\n                    log.info(\"byte-compiling %s to %s\", file, cfile_base)\n                    if not dry_run:\n                        compile(file, cfile, dfile)\n                else:\n                    log.debug(\"skipping byte-compilation of %s to %s\", file, cfile_base)\n\n\ndef rfc822_escape(header):\n    \"\"\"Return a version of the string escaped for inclusion in an\n    RFC-822 header, by ensuring there are 8 spaces space after each newline.\n    \"\"\"\n    indent = 8 * \" \"\n    lines = header.splitlines(keepends=True)\n\n    # Emulate the behaviour of `str.split`\n    # (the terminal line break in `splitlines` does not result in an extra line):\n    ends_in_newline = lines and lines[-1].splitlines()[0] != lines[-1]\n    suffix = indent if ends_in_newline else \"\"\n\n    return indent.join(lines) + suffix\n\n\ndef is_mingw():\n    \"\"\"Returns True if the current platform is mingw.\n\n    Python compiled with Mingw-w64 has sys.platform == 'win32' and\n    get_platform() starts with 'mingw'.\n    \"\"\"\n    return sys.platform == 'win32' and get_platform().startswith('mingw')\n\n\ndef is_freethreaded():\n    \"\"\"Return True if the Python interpreter is built with free threading support.\"\"\"\n    return bool(sysconfig.get_config_var('Py_GIL_DISABLED'))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/version.py","size":12619,"sha1":"0d4de3f82a02e9872a4da5ae65c3e1b740dceccc","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"#\n# distutils/version.py\n#\n# Implements multiple version numbering conventions for the\n# Python Module Distribution Utilities.\n#\n# $Id$\n#\n\n\"\"\"Provides classes to represent module version numbers (one class for\neach style of version numbering).  There are currently two such classes\nimplemented: StrictVersion and LooseVersion.\n\nEvery version number class implements the following interface:\n  * the 'parse' method takes a string and parses it to some internal\n    representation; if the string is an invalid version number,\n    'parse' raises a ValueError exception\n  * the class constructor takes an optional string argument which,\n    if supplied, is passed to 'parse'\n  * __str__ reconstructs the string that was passed to 'parse' (or\n    an equivalent string -- ie. one that will generate an equivalent\n    version number instance)\n  * __repr__ generates Python code to recreate the version number instance\n  * _cmp compares the current instance with either another instance\n    of the same class or a string (which will be parsed to an instance\n    of the same class, thus must follow the same rules)\n\"\"\"\n\nimport contextlib\nimport re\nimport warnings\n\n\n@contextlib.contextmanager\ndef suppress_known_deprecation():\n    with warnings.catch_warnings(record=True) as ctx:\n        warnings.filterwarnings(\n            action='default',\n            category=DeprecationWarning,\n            message=\"distutils Version classes are deprecated.\",\n        )\n        yield ctx\n\n\nclass Version:\n    \"\"\"Abstract base class for version numbering classes.  Just provides\n    constructor (__init__) and reproducer (__repr__), because those\n    seem to be the same for all version numbering classes; and route\n    rich comparisons to _cmp.\n    \"\"\"\n\n    def __init__(self, vstring=None):\n        if vstring:\n            self.parse(vstring)\n        warnings.warn(\n            \"distutils Version classes are deprecated. Use packaging.version instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__} ('{self}')\"\n\n    def __eq__(self, other):\n        c = self._cmp(other)\n        if c is NotImplemented:\n            return c\n        return c == 0\n\n    def __lt__(self, other):\n        c = self._cmp(other)\n        if c is NotImplemented:\n            return c\n        return c < 0\n\n    def __le__(self, other):\n        c = self._cmp(other)\n        if c is NotImplemented:\n            return c\n        return c <= 0\n\n    def __gt__(self, other):\n        c = self._cmp(other)\n        if c is NotImplemented:\n            return c\n        return c > 0\n\n    def __ge__(self, other):\n        c = self._cmp(other)\n        if c is NotImplemented:\n            return c\n        return c >= 0\n\n\n# Interface for version-number classes -- must be implemented\n# by the following classes (the concrete ones -- Version should\n# be treated as an abstract class).\n#    __init__ (string) - create and take same action as 'parse'\n#                        (string parameter is optional)\n#    parse (string)    - convert a string representation to whatever\n#                        internal representation is appropriate for\n#                        this style of version numbering\n#    __str__ (self)    - convert back to a string; should be very similar\n#                        (if not identical to) the string supplied to parse\n#    __repr__ (self)   - generate Python code to recreate\n#                        the instance\n#    _cmp (self, other) - compare two version numbers ('other' may\n#                        be an unparsed version string, or another\n#                        instance of your version class)\n\n\nclass StrictVersion(Version):\n    \"\"\"Version numbering for anal retentives and software idealists.\n    Implements the standard interface for version number classes as\n    described above.  A version number consists of two or three\n    dot-separated numeric components, with an optional \"pre-release\" tag\n    on the end.  The pre-release tag consists of the letter 'a' or 'b'\n    followed by a number.  If the numeric components of two version\n    numbers are equal, then one with a pre-release tag will always\n    be deemed earlier (lesser) than one without.\n\n    The following are valid version numbers (shown in the order that\n    would be obtained by sorting according to the supplied cmp function):\n\n        0.4       0.4.0  (these two are equivalent)\n        0.4.1\n        0.5a1\n        0.5b3\n        0.5\n        0.9.6\n        1.0\n        1.0.4a3\n        1.0.4b1\n        1.0.4\n\n    The following are examples of invalid version numbers:\n\n        1\n        2.7.2.2\n        1.3.a4\n        1.3pl1\n        1.3c4\n\n    The rationale for this version numbering system will be explained\n    in the distutils documentation.\n    \"\"\"\n\n    version_re = re.compile(\n        r'^(\\d+) \\. (\\d+) (\\. (\\d+))? ([ab](\\d+))?$', re.VERBOSE | re.ASCII\n    )\n\n    def parse(self, vstring):\n        match = self.version_re.match(vstring)\n        if not match:\n            raise ValueError(f\"invalid version number '{vstring}'\")\n\n        (major, minor, patch, prerelease, prerelease_num) = match.group(1, 2, 4, 5, 6)\n\n        if patch:\n            self.version = tuple(map(int, [major, minor, patch]))\n        else:\n            self.version = tuple(map(int, [major, minor])) + (0,)\n\n        if prerelease:\n            self.prerelease = (prerelease[0], int(prerelease_num))\n        else:\n            self.prerelease = None\n\n    def __str__(self):\n        if self.version[2] == 0:\n            vstring = '.'.join(map(str, self.version[0:2]))\n        else:\n            vstring = '.'.join(map(str, self.version))\n\n        if self.prerelease:\n            vstring = vstring + self.prerelease[0] + str(self.prerelease[1])\n\n        return vstring\n\n    def _cmp(self, other):\n        if isinstance(other, str):\n            with suppress_known_deprecation():\n                other = StrictVersion(other)\n        elif not isinstance(other, StrictVersion):\n            return NotImplemented\n\n        if self.version == other.version:\n            # versions match; pre-release drives the comparison\n            return self._cmp_prerelease(other)\n\n        return -1 if self.version < other.version else 1\n\n    def _cmp_prerelease(self, other):\n        \"\"\"\n        case 1: self has prerelease, other doesn't; other is greater\n        case 2: self doesn't have prerelease, other does: self is greater\n        case 3: both or neither have prerelease: compare them!\n        \"\"\"\n        if self.prerelease and not other.prerelease:\n            return -1\n        elif not self.prerelease and other.prerelease:\n            return 1\n\n        if self.prerelease == other.prerelease:\n            return 0\n        elif self.prerelease < other.prerelease:\n            return -1\n        else:\n            return 1\n\n\n# end class StrictVersion\n\n\n# The rules according to Greg Stein:\n# 1) a version number has 1 or more numbers separated by a period or by\n#    sequences of letters. If only periods, then these are compared\n#    left-to-right to determine an ordering.\n# 2) sequences of letters are part of the tuple for comparison and are\n#    compared lexicographically\n# 3) recognize the numeric components may have leading zeroes\n#\n# The LooseVersion class below implements these rules: a version number\n# string is split up into a tuple of integer and string components, and\n# comparison is a simple tuple comparison.  This means that version\n# numbers behave in a predictable and obvious way, but a way that might\n# not necessarily be how people *want* version numbers to behave.  There\n# wouldn't be a problem if people could stick to purely numeric version\n# numbers: just split on period and compare the numbers as tuples.\n# However, people insist on putting letters into their version numbers;\n# the most common purpose seems to be:\n#   - indicating a \"pre-release\" version\n#     ('alpha', 'beta', 'a', 'b', 'pre', 'p')\n#   - indicating a post-release patch ('p', 'pl', 'patch')\n# but of course this can't cover all version number schemes, and there's\n# no way to know what a programmer means without asking him.\n#\n# The problem is what to do with letters (and other non-numeric\n# characters) in a version number.  The current implementation does the\n# obvious and predictable thing: keep them as strings and compare\n# lexically within a tuple comparison.  This has the desired effect if\n# an appended letter sequence implies something \"post-release\":\n# eg. \"0.99\" < \"0.99pl14\" < \"1.0\", and \"5.001\" < \"5.001m\" < \"5.002\".\n#\n# However, if letters in a version number imply a pre-release version,\n# the \"obvious\" thing isn't correct.  Eg. you would expect that\n# \"1.5.1\" < \"1.5.2a2\" < \"1.5.2\", but under the tuple/lexical comparison\n# implemented here, this just isn't so.\n#\n# Two possible solutions come to mind.  The first is to tie the\n# comparison algorithm to a particular set of semantic rules, as has\n# been done in the StrictVersion class above.  This works great as long\n# as everyone can go along with bondage and discipline.  Hopefully a\n# (large) subset of Python module programmers will agree that the\n# particular flavour of bondage and discipline provided by StrictVersion\n# provides enough benefit to be worth using, and will submit their\n# version numbering scheme to its domination.  The free-thinking\n# anarchists in the lot will never give in, though, and something needs\n# to be done to accommodate them.\n#\n# Perhaps a \"moderately strict\" version class could be implemented that\n# lets almost anything slide (syntactically), and makes some heuristic\n# assumptions about non-digits in version number strings.  This could\n# sink into special-case-hell, though; if I was as talented and\n# idiosyncratic as Larry Wall, I'd go ahead and implement a class that\n# somehow knows that \"1.2.1\" < \"1.2.2a2\" < \"1.2.2\" < \"1.2.2pl3\", and is\n# just as happy dealing with things like \"2g6\" and \"1.13++\".  I don't\n# think I'm smart enough to do it right though.\n#\n# In any case, I've coded the test suite for this module (see\n# ../test/test_version.py) specifically to fail on things like comparing\n# \"1.2a2\" and \"1.2\".  That's not because the *code* is doing anything\n# wrong, it's because the simple, obvious design doesn't match my\n# complicated, hairy expectations for real-world version numbers.  It\n# would be a snap to fix the test suite to say, \"Yep, LooseVersion does\n# the Right Thing\" (ie. the code matches the conception).  But I'd rather\n# have a conception that matches common notions about version numbers.\n\n\nclass LooseVersion(Version):\n    \"\"\"Version numbering for anarchists and software realists.\n    Implements the standard interface for version number classes as\n    described above.  A version number consists of a series of numbers,\n    separated by either periods or strings of letters.  When comparing\n    version numbers, the numeric components will be compared\n    numerically, and the alphabetic components lexically.  The following\n    are all valid version numbers, in no particular order:\n\n        1.5.1\n        1.5.2b2\n        161\n        3.10a\n        8.02\n        3.4j\n        1996.07.12\n        3.2.pl0\n        3.1.1.6\n        2g6\n        11g\n        0.960923\n        2.2beta29\n        1.13++\n        5.5.kw\n        2.0b1pl0\n\n    In fact, there is no such thing as an invalid version number under\n    this scheme; the rules for comparison are simple and predictable,\n    but may not always give the results you want (for some definition\n    of \"want\").\n    \"\"\"\n\n    component_re = re.compile(r'(\\d+ | [a-z]+ | \\.)', re.VERBOSE)\n\n    def parse(self, vstring):\n        # I've given up on thinking I can reconstruct the version string\n        # from the parsed tuple -- so I just store the string here for\n        # use by __str__\n        self.vstring = vstring\n        components = [x for x in self.component_re.split(vstring) if x and x != '.']\n        for i, obj in enumerate(components):\n            try:\n                components[i] = int(obj)\n            except ValueError:\n                pass\n\n        self.version = components\n\n    def __str__(self):\n        return self.vstring\n\n    def __repr__(self):\n        return f\"LooseVersion ('{self}')\"\n\n    def _cmp(self, other):\n        if isinstance(other, str):\n            other = LooseVersion(other)\n        elif not isinstance(other, LooseVersion):\n            return NotImplemented\n\n        if self.version == other.version:\n            return 0\n        if self.version < other.version:\n            return -1\n        if self.version > other.version:\n            return 1\n\n\n# end class LooseVersion\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/versionpredicate.py","size":5205,"sha1":"27c966a4186b57d7c0523c14c7635572e6d08944","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Module for parsing and testing package version predicate strings.\"\"\"\n\nimport operator\nimport re\n\nfrom . import version\n\nre_validPackage = re.compile(r\"(?i)^\\s*([a-z_]\\w*(?:\\.[a-z_]\\w*)*)(.*)\", re.ASCII)\n# (package) (rest)\n\nre_paren = re.compile(r\"^\\s*\\((.*)\\)\\s*$\")  # (list) inside of parentheses\nre_splitComparison = re.compile(r\"^\\s*(<=|>=|<|>|!=|==)\\s*([^\\s,]+)\\s*$\")\n# (comp) (version)\n\n\ndef splitUp(pred):\n    \"\"\"Parse a single version comparison.\n\n    Return (comparison string, StrictVersion)\n    \"\"\"\n    res = re_splitComparison.match(pred)\n    if not res:\n        raise ValueError(f\"bad package restriction syntax: {pred!r}\")\n    comp, verStr = res.groups()\n    with version.suppress_known_deprecation():\n        other = version.StrictVersion(verStr)\n    return (comp, other)\n\n\ncompmap = {\n    \"<\": operator.lt,\n    \"<=\": operator.le,\n    \"==\": operator.eq,\n    \">\": operator.gt,\n    \">=\": operator.ge,\n    \"!=\": operator.ne,\n}\n\n\nclass VersionPredicate:\n    \"\"\"Parse and test package version predicates.\n\n    >>> v = VersionPredicate('pyepat.abc (>1.0, <3333.3a1, !=1555.1b3)')\n\n    The `name` attribute provides the full dotted name that is given::\n\n    >>> v.name\n    'pyepat.abc'\n\n    The str() of a `VersionPredicate` provides a normalized\n    human-readable version of the expression::\n\n    >>> print(v)\n    pyepat.abc (> 1.0, < 3333.3a1, != 1555.1b3)\n\n    The `satisfied_by()` method can be used to determine with a given\n    version number is included in the set described by the version\n    restrictions::\n\n    >>> v.satisfied_by('1.1')\n    True\n    >>> v.satisfied_by('1.4')\n    True\n    >>> v.satisfied_by('1.0')\n    False\n    >>> v.satisfied_by('4444.4')\n    False\n    >>> v.satisfied_by('1555.1b3')\n    False\n\n    `VersionPredicate` is flexible in accepting extra whitespace::\n\n    >>> v = VersionPredicate(' pat( ==  0.1  )  ')\n    >>> v.name\n    'pat'\n    >>> v.satisfied_by('0.1')\n    True\n    >>> v.satisfied_by('0.2')\n    False\n\n    If any version numbers passed in do not conform to the\n    restrictions of `StrictVersion`, a `ValueError` is raised::\n\n    >>> v = VersionPredicate('p1.p2.p3.p4(>=1.0, <=1.3a1, !=1.2zb3)')\n    Traceback (most recent call last):\n      ...\n    ValueError: invalid version number '1.2zb3'\n\n    It the module or package name given does not conform to what's\n    allowed as a legal module or package name, `ValueError` is\n    raised::\n\n    >>> v = VersionPredicate('foo-bar')\n    Traceback (most recent call last):\n      ...\n    ValueError: expected parenthesized list: '-bar'\n\n    >>> v = VersionPredicate('foo bar (12.21)')\n    Traceback (most recent call last):\n      ...\n    ValueError: expected parenthesized list: 'bar (12.21)'\n\n    \"\"\"\n\n    def __init__(self, versionPredicateStr):\n        \"\"\"Parse a version predicate string.\"\"\"\n        # Fields:\n        #    name:  package name\n        #    pred:  list of (comparison string, StrictVersion)\n\n        versionPredicateStr = versionPredicateStr.strip()\n        if not versionPredicateStr:\n            raise ValueError(\"empty package restriction\")\n        match = re_validPackage.match(versionPredicateStr)\n        if not match:\n            raise ValueError(f\"bad package name in {versionPredicateStr!r}\")\n        self.name, paren = match.groups()\n        paren = paren.strip()\n        if paren:\n            match = re_paren.match(paren)\n            if not match:\n                raise ValueError(f\"expected parenthesized list: {paren!r}\")\n            str = match.groups()[0]\n            self.pred = [splitUp(aPred) for aPred in str.split(\",\")]\n            if not self.pred:\n                raise ValueError(f\"empty parenthesized list in {versionPredicateStr!r}\")\n        else:\n            self.pred = []\n\n    def __str__(self):\n        if self.pred:\n            seq = [cond + \" \" + str(ver) for cond, ver in self.pred]\n            return self.name + \" (\" + \", \".join(seq) + \")\"\n        else:\n            return self.name\n\n    def satisfied_by(self, version):\n        \"\"\"True if version is compatible with all the predicates in self.\n        The parameter version must be acceptable to the StrictVersion\n        constructor.  It may be either a string or StrictVersion.\n        \"\"\"\n        for cond, ver in self.pred:\n            if not compmap[cond](version, ver):\n                return False\n        return True\n\n\n_provision_rx = None\n\n\ndef split_provision(value):\n    \"\"\"Return the name and optional version number of a provision.\n\n    The version number, if given, will be returned as a `StrictVersion`\n    instance, otherwise it will be `None`.\n\n    >>> split_provision('mypkg')\n    ('mypkg', None)\n    >>> split_provision(' mypkg( 1.2 ) ')\n    ('mypkg', StrictVersion ('1.2'))\n    \"\"\"\n    global _provision_rx\n    if _provision_rx is None:\n        _provision_rx = re.compile(\n            r\"([a-zA-Z_]\\w*(?:\\.[a-zA-Z_]\\w*)*)(?:\\s*\\(\\s*([^)\\s]+)\\s*\\))?$\", re.ASCII\n        )\n    value = value.strip()\n    m = _provision_rx.match(value)\n    if not m:\n        raise ValueError(f\"illegal provides specification: {value!r}\")\n    ver = m.group(2) or None\n    if ver:\n        with version.suppress_known_deprecation():\n            ver = version.StrictVersion(ver)\n    return m.group(1), ver\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_distutils/zosccompiler.py","size":6589,"sha1":"766b728ef7d71c1ea8e8078794ef3d3089fb1f91","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"distutils.zosccompiler\n\nContains the selection of the c & c++ compilers on z/OS. There are several\ndifferent c compilers on z/OS, all of them are optional, so the correct\none needs to be chosen based on the users input. This is compatible with\nthe following compilers:\n\nIBM C/C++ For Open Enterprise Languages on z/OS 2.0\nIBM Open XL C/C++ 1.1 for z/OS\nIBM XL C/C++ V2.4.1 for z/OS 2.4 and 2.5\nIBM z/OS XL C/C++\n\"\"\"\n\nimport os\n\nfrom . import sysconfig\nfrom .errors import CompileError, DistutilsExecError\nfrom .unixccompiler import UnixCCompiler\n\n_cc_args = {\n    'ibm-openxl': [\n        '-m64',\n        '-fvisibility=default',\n        '-fzos-le-char-mode=ascii',\n        '-fno-short-enums',\n    ],\n    'ibm-xlclang': [\n        '-q64',\n        '-qexportall',\n        '-qascii',\n        '-qstrict',\n        '-qnocsect',\n        '-Wa,asa,goff',\n        '-Wa,xplink',\n        '-qgonumber',\n        '-qenum=int',\n        '-Wc,DLL',\n    ],\n    'ibm-xlc': [\n        '-q64',\n        '-qexportall',\n        '-qascii',\n        '-qstrict',\n        '-qnocsect',\n        '-Wa,asa,goff',\n        '-Wa,xplink',\n        '-qgonumber',\n        '-qenum=int',\n        '-Wc,DLL',\n        '-qlanglvl=extc99',\n    ],\n}\n\n_cxx_args = {\n    'ibm-openxl': [\n        '-m64',\n        '-fvisibility=default',\n        '-fzos-le-char-mode=ascii',\n        '-fno-short-enums',\n    ],\n    'ibm-xlclang': [\n        '-q64',\n        '-qexportall',\n        '-qascii',\n        '-qstrict',\n        '-qnocsect',\n        '-Wa,asa,goff',\n        '-Wa,xplink',\n        '-qgonumber',\n        '-qenum=int',\n        '-Wc,DLL',\n    ],\n    'ibm-xlc': [\n        '-q64',\n        '-qexportall',\n        '-qascii',\n        '-qstrict',\n        '-qnocsect',\n        '-Wa,asa,goff',\n        '-Wa,xplink',\n        '-qgonumber',\n        '-qenum=int',\n        '-Wc,DLL',\n        '-qlanglvl=extended0x',\n    ],\n}\n\n_asm_args = {\n    'ibm-openxl': ['-fasm', '-fno-integrated-as', '-Wa,--ASA', '-Wa,--GOFF'],\n    'ibm-xlclang': [],\n    'ibm-xlc': [],\n}\n\n_ld_args = {\n    'ibm-openxl': [],\n    'ibm-xlclang': ['-Wl,dll', '-q64'],\n    'ibm-xlc': ['-Wl,dll', '-q64'],\n}\n\n\n# Python on z/OS is built with no compiler specific options in it's CFLAGS.\n# But each compiler requires it's own specific options to build successfully,\n# though some of the options are common between them\nclass zOSCCompiler(UnixCCompiler):\n    src_extensions = ['.c', '.C', '.cc', '.cxx', '.cpp', '.m', '.s']\n    _cpp_extensions = ['.cc', '.cpp', '.cxx', '.C']\n    _asm_extensions = ['.s']\n\n    def _get_zos_compiler_name(self):\n        zos_compiler_names = [\n            os.path.basename(binary)\n            for envvar in ('CC', 'CXX', 'LDSHARED')\n            if (binary := os.environ.get(envvar, None))\n        ]\n        if len(zos_compiler_names) == 0:\n            return 'ibm-openxl'\n\n        zos_compilers = {}\n        for compiler in (\n            'ibm-clang',\n            'ibm-clang64',\n            'ibm-clang++',\n            'ibm-clang++64',\n            'clang',\n            'clang++',\n            'clang-14',\n        ):\n            zos_compilers[compiler] = 'ibm-openxl'\n\n        for compiler in ('xlclang', 'xlclang++', 'njsc', 'njsc++'):\n            zos_compilers[compiler] = 'ibm-xlclang'\n\n        for compiler in ('xlc', 'xlC', 'xlc++'):\n            zos_compilers[compiler] = 'ibm-xlc'\n\n        return zos_compilers.get(zos_compiler_names[0], 'ibm-openxl')\n\n    def __init__(self, verbose=False, dry_run=False, force=False):\n        super().__init__(verbose, dry_run, force)\n        self.zos_compiler = self._get_zos_compiler_name()\n        sysconfig.customize_compiler(self)\n\n    def _compile(self, obj, src, ext, cc_args, extra_postargs, pp_opts):\n        local_args = []\n        if ext in self._cpp_extensions:\n            compiler = self.compiler_cxx\n            local_args.extend(_cxx_args[self.zos_compiler])\n        elif ext in self._asm_extensions:\n            compiler = self.compiler_so\n            local_args.extend(_cc_args[self.zos_compiler])\n            local_args.extend(_asm_args[self.zos_compiler])\n        else:\n            compiler = self.compiler_so\n            local_args.extend(_cc_args[self.zos_compiler])\n        local_args.extend(cc_args)\n\n        try:\n            self.spawn(compiler + local_args + [src, '-o', obj] + extra_postargs)\n        except DistutilsExecError as msg:\n            raise CompileError(msg)\n\n    def runtime_library_dir_option(self, dir):\n        return '-L' + dir\n\n    def link(\n        self,\n        target_desc,\n        objects,\n        output_filename,\n        output_dir=None,\n        libraries=None,\n        library_dirs=None,\n        runtime_library_dirs=None,\n        export_symbols=None,\n        debug=False,\n        extra_preargs=None,\n        extra_postargs=None,\n        build_temp=None,\n        target_lang=None,\n    ):\n        # For a built module to use functions from cpython, it needs to use Pythons\n        # side deck file. The side deck is located beside the libpython3.xx.so\n        ldversion = sysconfig.get_config_var('LDVERSION')\n        if sysconfig.python_build:\n            side_deck_path = os.path.join(\n                sysconfig.get_config_var('abs_builddir'),\n                f'libpython{ldversion}.x',\n            )\n        else:\n            side_deck_path = os.path.join(\n                sysconfig.get_config_var('installed_base'),\n                sysconfig.get_config_var('platlibdir'),\n                f'libpython{ldversion}.x',\n            )\n\n        if os.path.exists(side_deck_path):\n            if extra_postargs:\n                extra_postargs.append(side_deck_path)\n            else:\n                extra_postargs = [side_deck_path]\n\n        # Check and replace libraries included side deck files\n        if runtime_library_dirs:\n            for dir in runtime_library_dirs:\n                for library in libraries[:]:\n                    library_side_deck = os.path.join(dir, f'{library}.x')\n                    if os.path.exists(library_side_deck):\n                        libraries.remove(library)\n                        extra_postargs.append(library_side_deck)\n                        break\n\n        # Any required ld args for the given compiler\n        extra_postargs.extend(_ld_args[self.zos_compiler])\n\n        super().link(\n            target_desc,\n            objects,\n            output_filename,\n            output_dir,\n            libraries,\n            library_dirs,\n            runtime_library_dirs,\n            export_symbols,\n            debug,\n            extra_preargs,\n            extra_postargs,\n            build_temp,\n            target_lang,\n        )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_entry_points.py","size":2310,"sha1":"7545dd812fd1024c57f54a2b13a78b9f092972be","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import functools\nimport itertools\nimport operator\n\nfrom jaraco.functools import pass_none\nfrom jaraco.text import yield_lines\nfrom more_itertools import consume\n\nfrom ._importlib import metadata\nfrom ._itertools import ensure_unique\nfrom .errors import OptionError\n\n\ndef ensure_valid(ep):\n    \"\"\"\n    Exercise one of the dynamic properties to trigger\n    the pattern match.\n    \"\"\"\n    try:\n        ep.extras\n    except (AttributeError, AssertionError) as ex:\n        # Why both? See https://github.com/python/importlib_metadata/issues/488\n        msg = (\n            f\"Problems to parse {ep}.\\nPlease ensure entry-point follows the spec: \"\n            \"https://packaging.python.org/en/latest/specifications/entry-points/\"\n        )\n        raise OptionError(msg) from ex\n\n\ndef load_group(value, group):\n    \"\"\"\n    Given a value of an entry point or series of entry points,\n    return each as an EntryPoint.\n    \"\"\"\n    # normalize to a single sequence of lines\n    lines = yield_lines(value)\n    text = f'[{group}]\\n' + '\\n'.join(lines)\n    return metadata.EntryPoints._from_text(text)\n\n\ndef by_group_and_name(ep):\n    return ep.group, ep.name\n\n\ndef validate(eps: metadata.EntryPoints):\n    \"\"\"\n    Ensure entry points are unique by group and name and validate each.\n    \"\"\"\n    consume(map(ensure_valid, ensure_unique(eps, key=by_group_and_name)))\n    return eps\n\n\n@functools.singledispatch\ndef load(eps):\n    \"\"\"\n    Given a Distribution.entry_points, produce EntryPoints.\n    \"\"\"\n    groups = itertools.chain.from_iterable(\n        load_group(value, group) for group, value in eps.items()\n    )\n    return validate(metadata.EntryPoints(groups))\n\n\n@load.register(str)\ndef _(eps):\n    r\"\"\"\n    >>> ep, = load('[console_scripts]\\nfoo=bar')\n    >>> ep.group\n    'console_scripts'\n    >>> ep.name\n    'foo'\n    >>> ep.value\n    'bar'\n    \"\"\"\n    return validate(metadata.EntryPoints(metadata.EntryPoints._from_text(eps)))\n\n\nload.register(type(None), lambda x: x)\n\n\n@pass_none\ndef render(eps: metadata.EntryPoints):\n    by_group = operator.attrgetter('group')\n    groups = itertools.groupby(sorted(eps, key=by_group), by_group)\n\n    return '\\n'.join(f'[{group}]\\n{render_items(items)}\\n' for group, items in groups)\n\n\ndef render_items(eps):\n    return '\\n'.join(f'{ep.name} = {ep.value}' for ep in sorted(eps))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_imp.py","size":2435,"sha1":"74a6023fde80113d37bdf31bef2d8396e5c5dd88","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nRe-implementation of find_module and get_frozen_object\nfrom the deprecated imp module.\n\"\"\"\n\nimport importlib.machinery\nimport importlib.util\nimport os\nimport tokenize\nfrom importlib.util import module_from_spec\n\nPY_SOURCE = 1\nPY_COMPILED = 2\nC_EXTENSION = 3\nC_BUILTIN = 6\nPY_FROZEN = 7\n\n\ndef find_spec(module, paths):\n    finder = (\n        importlib.machinery.PathFinder().find_spec\n        if isinstance(paths, list)\n        else importlib.util.find_spec\n    )\n    return finder(module, paths)\n\n\ndef find_module(module, paths=None):\n    \"\"\"Just like 'imp.find_module()', but with package support\"\"\"\n    spec = find_spec(module, paths)\n    if spec is None:\n        raise ImportError(f\"Can't find {module}\")\n    if not spec.has_location and hasattr(spec, 'submodule_search_locations'):\n        spec = importlib.util.spec_from_loader('__init__.py', spec.loader)\n\n    kind = -1\n    file = None\n    static = isinstance(spec.loader, type)\n    if (\n        spec.origin == 'frozen'\n        or static\n        and issubclass(spec.loader, importlib.machinery.FrozenImporter)\n    ):\n        kind = PY_FROZEN\n        path = None  # imp compabilty\n        suffix = mode = ''  # imp compatibility\n    elif (\n        spec.origin == 'built-in'\n        or static\n        and issubclass(spec.loader, importlib.machinery.BuiltinImporter)\n    ):\n        kind = C_BUILTIN\n        path = None  # imp compabilty\n        suffix = mode = ''  # imp compatibility\n    elif spec.has_location:\n        path = spec.origin\n        suffix = os.path.splitext(path)[1]\n        mode = 'r' if suffix in importlib.machinery.SOURCE_SUFFIXES else 'rb'\n\n        if suffix in importlib.machinery.SOURCE_SUFFIXES:\n            kind = PY_SOURCE\n            file = tokenize.open(path)\n        elif suffix in importlib.machinery.BYTECODE_SUFFIXES:\n            kind = PY_COMPILED\n            file = open(path, 'rb')\n        elif suffix in importlib.machinery.EXTENSION_SUFFIXES:\n            kind = C_EXTENSION\n\n    else:\n        path = None\n        suffix = mode = ''\n\n    return file, path, (suffix, mode, kind)\n\n\ndef get_frozen_object(module, paths=None):\n    spec = find_spec(module, paths)\n    if not spec:\n        raise ImportError(f\"Can't find {module}\")\n    return spec.loader.get_code(module)\n\n\ndef get_module(module, paths, info):\n    spec = find_spec(module, paths)\n    if not spec:\n        raise ImportError(f\"Can't find {module}\")\n    return module_from_spec(spec)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_importlib.py","size":223,"sha1":"8c50de9d5c9fd5afdcc2ef5797ca1c09237f069e","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\n\nif sys.version_info < (3, 10):\n    import importlib_metadata as metadata  # pragma: no cover\nelse:\n    import importlib.metadata as metadata  # noqa: F401\n\n\nimport importlib.resources as resources  # noqa: F401\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_itertools.py","size":657,"sha1":"e652b52906b0d64f10a48d836ee9f53ee9d76cbd","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from more_itertools import consume  # noqa: F401\n\n\n# copied from jaraco.itertools 6.1\ndef ensure_unique(iterable, key=lambda x: x):\n    \"\"\"\n    Wrap an iterable to raise a ValueError if non-unique values are encountered.\n\n    >>> list(ensure_unique('abc'))\n    ['a', 'b', 'c']\n    >>> consume(ensure_unique('abca'))\n    Traceback (most recent call last):\n    ...\n    ValueError: Duplicate element 'a' encountered.\n    \"\"\"\n    seen = set()\n    seen_add = seen.add\n    for element in iterable:\n        k = key(element)\n        if k in seen:\n            raise ValueError(f\"Duplicate element {element!r} encountered.\")\n        seen_add(k)\n        yield element\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_normalization.py","size":4536,"sha1":"0eabe3a7c3a85b819c417eba2b54d447633646a5","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nHelpers for normalization as expected in wheel/sdist/module file names\nand core metadata\n\"\"\"\n\nimport re\n\nimport packaging\n\n# https://packaging.python.org/en/latest/specifications/core-metadata/#name\n_VALID_NAME = re.compile(r\"^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$\", re.I)\n_UNSAFE_NAME_CHARS = re.compile(r\"[^A-Z0-9._-]+\", re.I)\n_NON_ALPHANUMERIC = re.compile(r\"[^A-Z0-9]+\", re.I)\n_PEP440_FALLBACK = re.compile(r\"^v?(?P<safe>(?:[0-9]+!)?[0-9]+(?:\\.[0-9]+)*)\", re.I)\n\n\ndef safe_identifier(name: str) -> str:\n    \"\"\"Make a string safe to be used as Python identifier.\n    >>> safe_identifier(\"12abc\")\n    '_12abc'\n    >>> safe_identifier(\"__editable__.myns.pkg-78.9.3_local\")\n    '__editable___myns_pkg_78_9_3_local'\n    \"\"\"\n    safe = re.sub(r'\\W|^(?=\\d)', '_', name)\n    assert safe.isidentifier()\n    return safe\n\n\ndef safe_name(component: str) -> str:\n    \"\"\"Escape a component used as a project name according to Core Metadata.\n    >>> safe_name(\"hello world\")\n    'hello-world'\n    >>> safe_name(\"hello?world\")\n    'hello-world'\n    >>> safe_name(\"hello_world\")\n    'hello_world'\n    \"\"\"\n    # See pkg_resources.safe_name\n    return _UNSAFE_NAME_CHARS.sub(\"-\", component)\n\n\ndef safe_version(version: str) -> str:\n    \"\"\"Convert an arbitrary string into a valid version string.\n    Can still raise an ``InvalidVersion`` exception.\n    To avoid exceptions use ``best_effort_version``.\n    >>> safe_version(\"1988 12 25\")\n    '1988.12.25'\n    >>> safe_version(\"v0.2.1\")\n    '0.2.1'\n    >>> safe_version(\"v0.2?beta\")\n    '0.2b0'\n    >>> safe_version(\"v0.2 beta\")\n    '0.2b0'\n    >>> safe_version(\"ubuntu lts\")\n    Traceback (most recent call last):\n    ...\n    packaging.version.InvalidVersion: Invalid version: 'ubuntu.lts'\n    \"\"\"\n    v = version.replace(' ', '.')\n    try:\n        return str(packaging.version.Version(v))\n    except packaging.version.InvalidVersion:\n        attempt = _UNSAFE_NAME_CHARS.sub(\"-\", v)\n        return str(packaging.version.Version(attempt))\n\n\ndef best_effort_version(version: str) -> str:\n    \"\"\"Convert an arbitrary string into a version-like string.\n    Fallback when ``safe_version`` is not safe enough.\n    >>> best_effort_version(\"v0.2 beta\")\n    '0.2b0'\n    >>> best_effort_version(\"ubuntu lts\")\n    '0.dev0+sanitized.ubuntu.lts'\n    >>> best_effort_version(\"0.23ubuntu1\")\n    '0.23.dev0+sanitized.ubuntu1'\n    >>> best_effort_version(\"0.23-\")\n    '0.23.dev0+sanitized'\n    >>> best_effort_version(\"0.-_\")\n    '0.dev0+sanitized'\n    >>> best_effort_version(\"42.+?1\")\n    '42.dev0+sanitized.1'\n    \"\"\"\n    # See pkg_resources._forgiving_version\n    try:\n        return safe_version(version)\n    except packaging.version.InvalidVersion:\n        v = version.replace(' ', '.')\n        match = _PEP440_FALLBACK.search(v)\n        if match:\n            safe = match[\"safe\"]\n            rest = v[len(safe) :]\n        else:\n            safe = \"0\"\n            rest = version\n        safe_rest = _NON_ALPHANUMERIC.sub(\".\", rest).strip(\".\")\n        local = f\"sanitized.{safe_rest}\".strip(\".\")\n        return safe_version(f\"{safe}.dev0+{local}\")\n\n\ndef safe_extra(extra: str) -> str:\n    \"\"\"Normalize extra name according to PEP 685\n    >>> safe_extra(\"_FrIeNdLy-._.-bArD\")\n    'friendly-bard'\n    >>> safe_extra(\"FrIeNdLy-._.-bArD__._-\")\n    'friendly-bard'\n    \"\"\"\n    return _NON_ALPHANUMERIC.sub(\"-\", extra).strip(\"-\").lower()\n\n\ndef filename_component(value: str) -> str:\n    \"\"\"Normalize each component of a filename (e.g. distribution/version part of wheel)\n    Note: ``value`` needs to be already normalized.\n    >>> filename_component(\"my-pkg\")\n    'my_pkg'\n    \"\"\"\n    return value.replace(\"-\", \"_\").strip(\"_\")\n\n\ndef filename_component_broken(value: str) -> str:\n    \"\"\"\n    Produce the incorrect filename component for compatibility.\n\n    See pypa/setuptools#4167 for detailed analysis.\n\n    TODO: replace this with filename_component after pip 24 is\n    nearly-ubiquitous.\n\n    >>> filename_component_broken('foo_bar-baz')\n    'foo-bar-baz'\n    \"\"\"\n    return value.replace('_', '-')\n\n\ndef safer_name(value: str) -> str:\n    \"\"\"Like ``safe_name`` but can be used as filename component for wheel\"\"\"\n    # See bdist_wheel.safer_name\n    return filename_component(safe_name(value))\n\n\ndef safer_best_effort_version(value: str) -> str:\n    \"\"\"Like ``best_effort_version`` but can be used as filename component for wheel\"\"\"\n    # See bdist_wheel.safer_verion\n    # TODO: Replace with only safe_version in the future (no need for best effort)\n    return filename_component(best_effort_version(value))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_path.py","size":2685,"sha1":"4f85828131a12cee3e55b621209d432adfe136b9","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport contextlib\nimport os\nimport sys\nfrom typing import TYPE_CHECKING, TypeVar, Union\n\nfrom more_itertools import unique_everseen\n\nif TYPE_CHECKING:\n    from typing_extensions import TypeAlias\n\nStrPath: TypeAlias = Union[str, os.PathLike[str]]  #  Same as _typeshed.StrPath\nStrPathT = TypeVar(\"StrPathT\", bound=Union[str, os.PathLike[str]])\n\n\ndef ensure_directory(path):\n    \"\"\"Ensure that the parent directory of `path` exists\"\"\"\n    dirname = os.path.dirname(path)\n    os.makedirs(dirname, exist_ok=True)\n\n\ndef same_path(p1: StrPath, p2: StrPath) -> bool:\n    \"\"\"Differs from os.path.samefile because it does not require paths to exist.\n    Purely string based (no comparison between i-nodes).\n    >>> same_path(\"a/b\", \"./a/b\")\n    True\n    >>> same_path(\"a/b\", \"a/./b\")\n    True\n    >>> same_path(\"a/b\", \"././a/b\")\n    True\n    >>> same_path(\"a/b\", \"./a/b/c/..\")\n    True\n    >>> same_path(\"a/b\", \"../a/b/c\")\n    False\n    >>> same_path(\"a\", \"a/b\")\n    False\n    \"\"\"\n    return normpath(p1) == normpath(p2)\n\n\ndef normpath(filename: StrPath) -> str:\n    \"\"\"Normalize a file/dir name for comparison purposes.\"\"\"\n    # See pkg_resources.normalize_path for notes about cygwin\n    file = os.path.abspath(filename) if sys.platform == 'cygwin' else filename\n    return os.path.normcase(os.path.realpath(os.path.normpath(file)))\n\n\n@contextlib.contextmanager\ndef paths_on_pythonpath(paths):\n    \"\"\"\n    Add the indicated paths to the head of the PYTHONPATH environment\n    variable so that subprocesses will also see the packages at\n    these paths.\n\n    Do this in a context that restores the value on exit.\n\n    >>> getfixture('monkeypatch').setenv('PYTHONPATH', 'anything')\n    >>> with paths_on_pythonpath(['foo', 'bar']):\n    ...     assert 'foo' in os.environ['PYTHONPATH']\n    ...     assert 'anything' in os.environ['PYTHONPATH']\n    >>> os.environ['PYTHONPATH']\n    'anything'\n\n    >>> getfixture('monkeypatch').delenv('PYTHONPATH')\n    >>> with paths_on_pythonpath(['foo', 'bar']):\n    ...     assert 'foo' in os.environ['PYTHONPATH']\n    >>> os.environ.get('PYTHONPATH')\n    \"\"\"\n    nothing = object()\n    orig_pythonpath = os.environ.get('PYTHONPATH', nothing)\n    current_pythonpath = os.environ.get('PYTHONPATH', '')\n    try:\n        prefix = os.pathsep.join(unique_everseen(paths))\n        to_join = filter(None, [prefix, current_pythonpath])\n        new_path = os.pathsep.join(to_join)\n        if new_path:\n            os.environ['PYTHONPATH'] = new_path\n        yield\n    finally:\n        if orig_pythonpath is nothing:\n            os.environ.pop('PYTHONPATH', None)\n        else:\n            os.environ['PYTHONPATH'] = orig_pythonpath\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_reqs.py","size":1438,"sha1":"b24a9e2fff8267b7aef2ea78339a4d9defdc99f2","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nfrom collections.abc import Iterable, Iterator\nfrom functools import lru_cache\nfrom typing import TYPE_CHECKING, Callable, TypeVar, Union, overload\n\nimport jaraco.text as text\nfrom packaging.requirements import Requirement\n\nif TYPE_CHECKING:\n    from typing_extensions import TypeAlias\n\n_T = TypeVar(\"_T\")\n_StrOrIter: TypeAlias = Union[str, Iterable[str]]\n\n\nparse_req: Callable[[str], Requirement] = lru_cache()(Requirement)\n# Setuptools parses the same requirement many times\n# (e.g. first for validation than for normalisation),\n# so it might be worth to cache.\n\n\ndef parse_strings(strs: _StrOrIter) -> Iterator[str]:\n    \"\"\"\n    Yield requirement strings for each specification in `strs`.\n\n    `strs` must be a string, or a (possibly-nested) iterable thereof.\n    \"\"\"\n    return text.join_continuation(map(text.drop_comment, text.yield_lines(strs)))\n\n\n# These overloads are only needed because of a mypy false-positive, pyright gets it right\n# https://github.com/python/mypy/issues/3737\n@overload\ndef parse(strs: _StrOrIter) -> Iterator[Requirement]: ...\n@overload\ndef parse(strs: _StrOrIter, parser: Callable[[str], _T]) -> Iterator[_T]: ...\ndef parse(strs: _StrOrIter, parser: Callable[[str], _T] = parse_req) -> Iterator[_T]:  # type: ignore[assignment]\n    \"\"\"\n    Replacement for ``pkg_resources.parse_requirements`` that uses ``packaging``.\n    \"\"\"\n    return map(parser, parse_strings(strs))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_shutil.py","size":1496,"sha1":"9e6c67435f9f9ff944fb9f07e26ea77637d7a594","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Convenience layer on top of stdlib's shutil and os\"\"\"\n\nimport os\nimport stat\nfrom typing import Callable, TypeVar\n\nfrom .compat import py311\n\nfrom distutils import log\n\ntry:\n    from os import chmod  # pyright: ignore[reportAssignmentType]\n    # Losing type-safety w/ pyright, but that's ok\nexcept ImportError:  # pragma: no cover\n    # Jython compatibility\n    def chmod(*args: object, **kwargs: object) -> None:  # type: ignore[misc] # Mypy reuses the imported definition anyway\n        pass\n\n\n_T = TypeVar(\"_T\")\n\n\ndef attempt_chmod_verbose(path, mode):\n    log.debug(\"changing mode of %s to %o\", path, mode)\n    try:\n        chmod(path, mode)\n    except OSError as e:  # pragma: no cover\n        log.debug(\"chmod failed: %s\", e)\n\n\n# Must match shutil._OnExcCallback\ndef _auto_chmod(\n    func: Callable[..., _T], arg: str, exc: BaseException\n) -> _T:  # pragma: no cover\n    \"\"\"shutils onexc callback to automatically call chmod for certain functions.\"\"\"\n    # Only retry for scenarios known to have an issue\n    if func in [os.unlink, os.remove] and os.name == 'nt':\n        attempt_chmod_verbose(arg, stat.S_IWRITE)\n        return func(arg)\n    raise exc\n\n\ndef rmtree(path, ignore_errors=False, onexc=_auto_chmod):\n    \"\"\"\n    Similar to ``shutil.rmtree`` but automatically executes ``chmod``\n    for well know Windows failure scenarios.\n    \"\"\"\n    return py311.shutil_rmtree(path, ignore_errors, onexc)\n\n\ndef rmdir(path, **opts):\n    if os.path.isdir(path):\n        rmtree(path, **opts)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_static.py","size":4855,"sha1":"d672854a788948f3f2fcfd1e82fc99ab06eb7c7f","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from functools import wraps\nfrom typing import TypeVar\n\nimport packaging.specifiers\n\nfrom .warnings import SetuptoolsDeprecationWarning\n\n\nclass Static:\n    \"\"\"\n    Wrapper for built-in object types that are allow setuptools to identify\n    static core metadata (in opposition to ``Dynamic``, as defined :pep:`643`).\n\n    The trick is to mark values with :class:`Static` when they come from\n    ``pyproject.toml`` or ``setup.cfg``, so if any plugin overwrite the value\n    with a built-in, setuptools will be able to recognise the change.\n\n    We inherit from built-in classes, so that we don't need to change the existing\n    code base to deal with the new types.\n    We also should strive for immutability objects to avoid changes after the\n    initial parsing.\n    \"\"\"\n\n    _mutated_: bool = False  # TODO: Remove after deprecation warning is solved\n\n\ndef _prevent_modification(target: type, method: str, copying: str) -> None:\n    \"\"\"\n    Because setuptools is very flexible we cannot fully prevent\n    plugins and user customisations from modifying static values that were\n    parsed from config files.\n    But we can attempt to block \"in-place\" mutations and identify when they\n    were done.\n    \"\"\"\n    fn = getattr(target, method, None)\n    if fn is None:\n        return\n\n    @wraps(fn)\n    def _replacement(self: Static, *args, **kwargs):\n        # TODO: After deprecation period raise NotImplementedError instead of warning\n        #       which obviated the existence and checks of the `_mutated_` attribute.\n        self._mutated_ = True\n        SetuptoolsDeprecationWarning.emit(\n            \"Direct modification of value will be disallowed\",\n            f\"\"\"\n            In an effort to implement PEP 643, direct/in-place changes of static values\n            that come from configuration files are deprecated.\n            If you need to modify this value, please first create a copy with {copying}\n            and make sure conform to all relevant standards when overriding setuptools\n            functionality (https://packaging.python.org/en/latest/specifications/).\n            \"\"\",\n            due_date=(2025, 10, 10),  # Initially introduced in 2024-09-06\n        )\n        return fn(self, *args, **kwargs)\n\n    _replacement.__doc__ = \"\"  # otherwise doctest may fail.\n    setattr(target, method, _replacement)\n\n\nclass Str(str, Static):\n    pass\n\n\nclass Tuple(tuple, Static):\n    pass\n\n\nclass List(list, Static):\n    \"\"\"\n    :meta private:\n    >>> x = List([1, 2, 3])\n    >>> is_static(x)\n    True\n    >>> x += [0]  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    SetuptoolsDeprecationWarning: Direct modification ...\n    >>> is_static(x)  # no longer static after modification\n    False\n    >>> y = list(x)\n    >>> y.clear()\n    >>> y\n    []\n    >>> y == x\n    False\n    >>> is_static(List(y))\n    True\n    \"\"\"\n\n\n# Make `List` immutable-ish\n# (certain places of setuptools/distutils issue a warn if we use tuple instead of list)\nfor _method in (\n    '__delitem__',\n    '__iadd__',\n    '__setitem__',\n    'append',\n    'clear',\n    'extend',\n    'insert',\n    'remove',\n    'reverse',\n    'pop',\n):\n    _prevent_modification(List, _method, \"`list(value)`\")\n\n\nclass Dict(dict, Static):\n    \"\"\"\n    :meta private:\n    >>> x = Dict({'a': 1, 'b': 2})\n    >>> is_static(x)\n    True\n    >>> x['c'] = 0  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    SetuptoolsDeprecationWarning: Direct modification ...\n    >>> x._mutated_\n    True\n    >>> is_static(x)  # no longer static after modification\n    False\n    >>> y = dict(x)\n    >>> y.popitem()\n    ('b', 2)\n    >>> y == x\n    False\n    >>> is_static(Dict(y))\n    True\n    \"\"\"\n\n\n# Make `Dict` immutable-ish (we cannot inherit from types.MappingProxyType):\nfor _method in (\n    '__delitem__',\n    '__ior__',\n    '__setitem__',\n    'clear',\n    'pop',\n    'popitem',\n    'setdefault',\n    'update',\n):\n    _prevent_modification(Dict, _method, \"`dict(value)`\")\n\n\nclass SpecifierSet(packaging.specifiers.SpecifierSet, Static):\n    \"\"\"Not exactly a built-in type but useful for ``requires-python``\"\"\"\n\n\nT = TypeVar(\"T\")\n\n\ndef noop(value: T) -> T:\n    \"\"\"\n    >>> noop(42)\n    42\n    \"\"\"\n    return value\n\n\n_CONVERSIONS = {str: Str, tuple: Tuple, list: List, dict: Dict}\n\n\ndef attempt_conversion(value: T) -> T:\n    \"\"\"\n    >>> is_static(attempt_conversion(\"hello\"))\n    True\n    >>> is_static(object())\n    False\n    \"\"\"\n    return _CONVERSIONS.get(type(value), noop)(value)  # type: ignore[call-overload]\n\n\ndef is_static(value: object) -> bool:\n    \"\"\"\n    >>> is_static(a := Dict({'a': 1}))\n    True\n    >>> is_static(dict(a))\n    False\n    >>> is_static(b := List([1, 2, 3]))\n    True\n    >>> is_static(list(b))\n    False\n    \"\"\"\n    return isinstance(value, Static) and not value._mutated_\n\n\nEMPTY_LIST = List()\nEMPTY_DICT = Dict()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/autocommand/__init__.py","size":1037,"sha1":"344892855332594d3b5352eb75332364b075aa2d","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# Copyright 2014-2016 Nathan West\n#\n# This file is part of autocommand.\n#\n# autocommand is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# autocommand is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with autocommand.  If not, see <http://www.gnu.org/licenses/>.\n\n# flake8 flags all these imports as unused, hence the NOQAs everywhere.\n\nfrom .automain import automain  # NOQA\nfrom .autoparse import autoparse, smart_open  # NOQA\nfrom .autocommand import autocommand  # NOQA\n\ntry:\n    from .autoasync import autoasync  # NOQA\nexcept ImportError:  # pragma: no cover\n    pass\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/autocommand/autoasync.py","size":5680,"sha1":"594fa5aa4fb0bcc2c3635127a2763f1b6d556c23","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# Copyright 2014-2015 Nathan West\n#\n# This file is part of autocommand.\n#\n# autocommand is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# autocommand is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with autocommand.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom asyncio import get_event_loop, iscoroutine\nfrom functools import wraps\nfrom inspect import signature\n\n\nasync def _run_forever_coro(coro, args, kwargs, loop):\n    '''\n    This helper function launches an async main function that was tagged with\n    forever=True. There are two possibilities:\n\n    - The function is a normal function, which handles initializing the event\n      loop, which is then run forever\n    - The function is a coroutine, which needs to be scheduled in the event\n      loop, which is then run forever\n      - There is also the possibility that the function is a normal function\n        wrapping a coroutine function\n\n    The function is therefore called unconditionally and scheduled in the event\n    loop if the return value is a coroutine object.\n\n    The reason this is a separate function is to make absolutely sure that all\n    the objects created are garbage collected after all is said and done; we\n    do this to ensure that any exceptions raised in the tasks are collected\n    ASAP.\n    '''\n\n    # Personal note: I consider this an antipattern, as it relies on the use of\n    # unowned resources. The setup function dumps some stuff into the event\n    # loop where it just whirls in the ether without a well defined owner or\n    # lifetime. For this reason, there's a good chance I'll remove the\n    # forever=True feature from autoasync at some point in the future.\n    thing = coro(*args, **kwargs)\n    if iscoroutine(thing):\n        await thing\n\n\ndef autoasync(coro=None, *, loop=None, forever=False, pass_loop=False):\n    '''\n    Convert an asyncio coroutine into a function which, when called, is\n    evaluted in an event loop, and the return value returned. This is intented\n    to make it easy to write entry points into asyncio coroutines, which\n    otherwise need to be explictly evaluted with an event loop's\n    run_until_complete.\n\n    If `loop` is given, it is used as the event loop to run the coro in. If it\n    is None (the default), the loop is retreived using asyncio.get_event_loop.\n    This call is defered until the decorated function is called, so that\n    callers can install custom event loops or event loop policies after\n    @autoasync is applied.\n\n    If `forever` is True, the loop is run forever after the decorated coroutine\n    is finished. Use this for servers created with asyncio.start_server and the\n    like.\n\n    If `pass_loop` is True, the event loop object is passed into the coroutine\n    as the `loop` kwarg when the wrapper function is called. In this case, the\n    wrapper function's __signature__ is updated to remove this parameter, so\n    that autoparse can still be used on it without generating a parameter for\n    `loop`.\n\n    This coroutine can be called with ( @autoasync(...) ) or without\n    ( @autoasync ) arguments.\n\n    Examples:\n\n    @autoasync\n    def get_file(host, port):\n        reader, writer = yield from asyncio.open_connection(host, port)\n        data = reader.read()\n        sys.stdout.write(data.decode())\n\n    get_file(host, port)\n\n    @autoasync(forever=True, pass_loop=True)\n    def server(host, port, loop):\n        yield_from loop.create_server(Proto, host, port)\n\n    server('localhost', 8899)\n\n    '''\n    if coro is None:\n        return lambda c: autoasync(\n            c, loop=loop,\n            forever=forever,\n            pass_loop=pass_loop)\n\n    # The old and new signatures are required to correctly bind the loop\n    # parameter in 100% of cases, even if it's a positional parameter.\n    # NOTE: A future release will probably require the loop parameter to be\n    # a kwonly parameter.\n    if pass_loop:\n        old_sig = signature(coro)\n        new_sig = old_sig.replace(parameters=(\n            param for name, param in old_sig.parameters.items()\n            if name != \"loop\"))\n\n    @wraps(coro)\n    def autoasync_wrapper(*args, **kwargs):\n        # Defer the call to get_event_loop so that, if a custom policy is\n        # installed after the autoasync decorator, it is respected at call time\n        local_loop = get_event_loop() if loop is None else loop\n\n        # Inject the 'loop' argument. We have to use this signature binding to\n        # ensure it's injected in the correct place (positional, keyword, etc)\n        if pass_loop:\n            bound_args = old_sig.bind_partial()\n            bound_args.arguments.update(\n                loop=local_loop,\n                **new_sig.bind(*args, **kwargs).arguments)\n            args, kwargs = bound_args.args, bound_args.kwargs\n\n        if forever:\n            local_loop.create_task(_run_forever_coro(\n                coro, args, kwargs, local_loop\n            ))\n            local_loop.run_forever()\n        else:\n            return local_loop.run_until_complete(coro(*args, **kwargs))\n\n    # Attach the updated signature. This allows 'pass_loop' to be used with\n    # autoparse\n    if pass_loop:\n        autoasync_wrapper.__signature__ = new_sig\n\n    return autoasync_wrapper\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/autocommand/autocommand.py","size":2505,"sha1":"ef0027a7ef11fe16dc87122333a1ea904776d2de","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# Copyright 2014-2015 Nathan West\n#\n# This file is part of autocommand.\n#\n# autocommand is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# autocommand is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with autocommand.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom .autoparse import autoparse\nfrom .automain import automain\ntry:\n    from .autoasync import autoasync\nexcept ImportError:  # pragma: no cover\n    pass\n\n\ndef autocommand(\n        module, *,\n        description=None,\n        epilog=None,\n        add_nos=False,\n        parser=None,\n        loop=None,\n        forever=False,\n        pass_loop=False):\n\n    if callable(module):\n        raise TypeError('autocommand requires a module name argument')\n\n    def autocommand_decorator(func):\n        # Step 1: if requested, run it all in an asyncio event loop. autoasync\n        # patches the __signature__ of the decorated function, so that in the\n        # event that pass_loop is True, the `loop` parameter of the original\n        # function will *not* be interpreted as a command-line argument by\n        # autoparse\n        if loop is not None or forever or pass_loop:\n            func = autoasync(\n                func,\n                loop=None if loop is True else loop,\n                pass_loop=pass_loop,\n                forever=forever)\n\n        # Step 2: create parser. We do this second so that the arguments are\n        # parsed and passed *before* entering the asyncio event loop, if it\n        # exists. This simplifies the stack trace and ensures errors are\n        # reported earlier. It also ensures that errors raised during parsing &\n        # passing are still raised if `forever` is True.\n        func = autoparse(\n            func,\n            description=description,\n            epilog=epilog,\n            add_nos=add_nos,\n            parser=parser)\n\n        # Step 3: call the function automatically if __name__ == '__main__' (or\n        # if True was provided)\n        func = automain(module)(func)\n\n        return func\n\n    return autocommand_decorator\n"}]}