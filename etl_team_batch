import os
import sys
import json
import time
import argparse
import sqlite3
from typing import List, Dict, Optional

import requests

# Usa il tuo KnowledgeManager (Chroma + HFEmbedder)
try:
    from knowledge_manager import KnowledgeManager
except Exception:
    KnowledgeManager = None  # consente --no-chroma

USER_AGENT = os.environ.get("USER_AGENT", "FantacalcioETL/1.0 (replit)")
WIKIDATA_SEARCH = "https://www.wikidata.org/w/api.php"
SPARQL_ENDPOINT = "https://query.wikidata.org/sparql"

DB_PATH = os.environ.get("ETL_DB", "./fantacalcio.db")


def wbsearchentities(name: str, lang: str = "it", type_hint: Optional[str] = None) -> Optional[Dict]:
    """
    Cerca entità su Wikidata (preferisci club calcistici). Ritorna {id, label} o None.
    type_hint può essere 'item' (default).
    """
    params = {
        "action": "wbsearchentities",
        "search": name,
        "language": lang,
        "uselang": lang,
        "format": "json",
        "limit": 10,
        "type": type_hint or "item",
    }
    r = requests.get(WIKIDATA_SEARCH, params=params, headers={"User-Agent": USER_AGENT}, timeout=10)
    r.raise_for_status()
    data = r.json()
    res = data.get("search", [])
    if not res:
        return None

    # semplice ranking: preferisci descrizioni che contengono 'football club' o 'società'
    def score(item):
        desc = (item.get("description") or "").lower()
        s = 0
        if "football" in desc or "calcio" in desc or "club" in desc or "società" in desc:
            s += 10
        if "club" in desc and "football" in desc:
            s += 5
        return s

    res.sort(key=score, reverse=True)
    top = res[0]
    return {"id": top.get("id"), "label": top.get("label")}


def sparql_select(query: str) -> List[Dict]:
    headers = {
        "User-Agent": USER_AGENT,
        "Accept": "application/sparql-results+json",
    }
    r = requests.get(SPARQL_ENDPOINT, params={"query": query, "format": "json"}, headers=headers, timeout=25)
    r.raise_for_status()
    data = r.json()
    return data.get("results", {}).get("bindings", [])


def fetch_current_roster(club_qid: str, lang: str = "it") -> List[Dict]:
    """
    Rosa attuale: membri con P54 senza end time (qualifier P582).
    Prende anche il sitelink Wikipedia e (se disponibile) il ruolo.
    """
    query = f"""
    SELECT ?player ?playerLabel ?playerEN ?wpPage ?positionLabel WHERE {{
      BIND(wd:{club_qid} AS ?club)
      ?player p:P54 ?st .
      ?st ps:P54 ?club .
      FILTER NOT EXISTS {{ ?st pq:P582 ?end . }}  # senza end time => attuale

      OPTIONAL {{
        ?player wdt:P413 ?position .
        SERVICE wikibase:label {{ bd:serviceParam wikibase:language "{lang},en". }}
      }}

      OPTIONAL {{
        ?wpPage schema:about ?player ;
                schema:isPartOf <https://{lang}.wikipedia.org/> .
      }}

      SERVICE wikibase:label {{
        bd:serviceParam wikibase:language "{lang},en" .
        ?player rdfs:label ?playerLabel .
      }}
    }}
    """
    rows = sparql_select(query)
    out = []
    for b in rows:
        def val(x): return b.get(x, {}).get("value")
        out.append({
            "player_qid": val("player").split("/")[-1] if val("player") else None,
            "player_label": val("playerLabel") or val("playerEN"),
            "wiki_page": val("wpPage"),
            "position": val("positionLabel"),
        })
    # dedup (a volte posizioni multiple)
    seen = set()
    unique = []
    for r in out:
        key = r.get("player_qid") or r.get("player_label")
        if key and key not in seen:
            seen.add(key)
            unique.append(r)
    return unique


# ------------------ SQLite schema ------------------
SCHEMA_SQL = """
CREATE TABLE IF NOT EXISTS clubs (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  wikidata_id TEXT,
  country TEXT
);

CREATE TABLE IF NOT EXISTS players (
  id TEXT PRIMARY KEY,
  full_name TEXT NOT NULL,
  wikidata_id TEXT,
  position TEXT
);

CREATE TABLE IF NOT EXISTS memberships (
  player_id TEXT NOT NULL,
  club_id TEXT NOT NULL,
  start_date TEXT,
  end_date TEXT,
  source_url TEXT,
  source_date TEXT,
  PRIMARY KEY (player_id, club_id, start_date),
  FOREIGN KEY (player_id) REFERENCES players(id),
  FOREIGN KEY (club_id) REFERENCES clubs(id)
);
"""


def ensure_db(conn: sqlite3.Connection):
    conn.executescript(SCHEMA_SQL)
    conn.commit()


def upsert_club(conn: sqlite3.Connection, club_id: str, name: str, wikidata_id: Optional[str]):
    conn.execute(
        "INSERT INTO clubs(id, name, wikidata_id) VALUES(?,?,?) "
        "ON CONFLICT(id) DO UPDATE SET name=excluded.name, wikidata_id=excluded.wikidata_id",
        (club_id, name, wikidata_id)
    )
    conn.commit()


def upsert_player(conn: sqlite3.Connection, pid: str, full_name: str, wikidata_id: Optional[str], position: Optional[str]):
    conn.execute(
        "INSERT INTO players(id, full_name, wikidata_id, position) VALUES(?,?,?,?) "
        "ON CONFLICT(id) DO UPDATE SET full_name=excluded.full_name, wikidata_id=excluded.wikidata_id, position=excluded.position",
        (pid, full_name, wikidata_id, position)
    )


def upsert_membership(conn: sqlite3.Connection, pid: str, cid: str, start_date: Optional[str], source_url: Optional[str], source_date: Optional[str]):
    conn.execute(
        "INSERT OR REPLACE INTO memberships(player_id, club_id, start_date, end_date, source_url, source_date) VALUES(?,?,?,?,?,?)",
        (pid, cid, start_date or "0000-00-00", None, source_url, source_date)
    )


def normalize_id(label: str) -> str:
    return label.lower().replace(" ", "_").replace("'", "").replace(".", "").replace("-", "_")


def ingest_team(team_name: str, season: str, valid_to: str, lang: str = "it", no_chroma: bool = False) -> Dict:
    # 1) risolvi club
    club = wbsearchentities(team_name, lang=lang, type_hint="item")
    if not club:
        raise RuntimeError(f"Club non trovato su Wikidata: {team_name}")

    club_qid = club["id"]             # es. Q17564
    club_label = club["label"] or team_name
    club_row_id = f"club_{normalize_id(club_label)}"

    # 2) roster attuale
    roster = fetch_current_roster(club_qid, lang=lang)

    # 3) scrivi su SQLite
    conn = sqlite3.connect(DB_PATH)
    ensure_db(conn)
    upsert_club(conn, club_row_id, club_label, club_qid)

    now = time.strftime("%Y-%m-%d")
    for r in roster:
        name = r.get("player_label") or "Giocatore"
        pid = f"pl_{normalize_id(name)}"
        upsert_player(conn, pid, name, r.get("player_qid"), r.get("position"))
        upsert_membership(conn, pid, club_row_id, start_date=now, source_url=r.get("wiki_page"), source_date=now)
    conn.commit()

    # 4) indicizza in Chroma (facoltativo)
    added_docs = 0
    if not no_chroma and KnowledgeManager is not None:
        km = KnowledgeManager()
        items = []
        for r in roster:
            name = r.get("player_label") or "Giocatore"
            pid = f"pl_{normalize_id(name)}"
            text = f"{name} è un calciatore del {club_label}."
            md = {
                "type": "player_info",
                "player": name,
                "player_id": pid,
                "team": club_label,
                "position": r.get("position"),
                "title": f"Profilo {name}",
                "source": r.get("wiki_page") or f"https://www.wikidata.org/wiki/{r.get('player_qid')}" if r.get("player_qid") else "internal://wikidata",
                "date": now,
                "valid_to": valid_to,
                "season": season,
            }
            items.append({"id": pid, "text": text, "metadata": md})

        stats = km.add_many(items)
        added_docs = stats.get("added", 0)

    return {
        "club_qid": club_qid,
        "club": club_label,
        "players": len(roster),
        "db_path": DB_PATH,
        "chroma_indexed": added_docs,
    }


def main():
    ap = argparse.ArgumentParser(description="ETL rosa squadra: Wikidata -> SQLite + Chroma")
    ap.add_argument("--team", required=True, help="Nome squadra (es. 'Atalanta', 'Milan', 'Juventus')")
    ap.add_argument("--season", default=os.environ.get("SEASON_DEFAULT", "2025-26"), help="Stagione da inserire nei metadati (es. 2025-26)")
    ap.add_argument("--valid-to", default="2099-01-01", help="Data di validità per il documento (YYYY-MM-DD)")
    ap.add_argument("--lang", default="it", help="Lingua preferita (default: it)")
    ap.add_argument("--no-chroma", action="store_true", help="Non indicizzare in Chroma (solo DB locale)")
    args = ap.parse_args()

    try:
        out = ingest_team(args.team, args.season, args.valid_to, lang=args.lang, no_chroma=args.no_chroma)
        print(json.dumps(out, ensure_ascii=False, indent=2))
    except Exception as e:
        print(f"[ETL] Errore: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()