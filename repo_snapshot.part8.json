{"generated_at":"2025-08-17T20:04:18.057896Z","root":"/home/runner/workspace","git":{"head":"7b7135163eb4227ef98e4c2d7b4ab78ea306bd73","branch":"main","status":" M corrections.db\n?? app_changes.json\n?? export_changes.py\n"},"filters":{"git_range":null,"since":null,"include_ext":[".cfg",".css",".env",".htm",".html",".ini",".jinja",".jinja2",".js",".json",".md",".py",".toml",".ts",".yaml",".yml"],"exclude_dirs":[".git",".ipynb_checkpoints",".mypy_cache",".pytest_cache",".pythonlibs",".venv","__pycache__","cache","chroma_db","data/exports","node_modules","venv"],"exclude_globs":["*.bmp","*.db","*.feather","*.gif","*.gz","*.ico","*.jpeg","*.jpg","*.jsonl","*.lock","*.log","*.parquet","*.png","*.sqlite","*.sqlite3","*.tar","*.webp","*.zip"],"max_file_bytes":400000},"summary":{"file_count":876,"total_bytes":9265289},"files":[{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/autocommand/automain.py","size":2076,"sha1":"753c1e1006fcfbc4d6f9a062e597fb01f700c19a","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# Copyright 2014-2015 Nathan West\n#\n# This file is part of autocommand.\n#\n# autocommand is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# autocommand is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with autocommand.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nfrom .errors import AutocommandError\n\n\nclass AutomainRequiresModuleError(AutocommandError, TypeError):\n    pass\n\n\ndef automain(module, *, args=(), kwargs=None):\n    '''\n    This decorator automatically invokes a function if the module is being run\n    as the \"__main__\" module. Optionally, provide args or kwargs with which to\n    call the function. If `module` is \"__main__\", the function is called, and\n    the program is `sys.exit`ed with the return value. You can also pass `True`\n    to cause the function to be called unconditionally. If the function is not\n    called, it is returned unchanged by the decorator.\n\n    Usage:\n\n    @automain(__name__)  # Pass __name__ to check __name__==\"__main__\"\n    def main():\n        ...\n\n    If __name__ is \"__main__\" here, the main function is called, and then\n    sys.exit called with the return value.\n    '''\n\n    # Check that @automain(...) was called, rather than @automain\n    if callable(module):\n        raise AutomainRequiresModuleError(module)\n\n    if module == '__main__' or module is True:\n        if kwargs is None:\n            kwargs = {}\n\n        # Use a function definition instead of a lambda for a neater traceback\n        def automain_decorator(main):\n            sys.exit(main(*args, **kwargs))\n\n        return automain_decorator\n    else:\n        return lambda main: main\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/autocommand/autoparse.py","size":11642,"sha1":"4138bd027a934dece22e6f16d1485c2be9ba7b62","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# Copyright 2014-2015 Nathan West\n#\n# This file is part of autocommand.\n#\n# autocommand is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# autocommand is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with autocommand.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nfrom re import compile as compile_regex\nfrom inspect import signature, getdoc, Parameter\nfrom argparse import ArgumentParser\nfrom contextlib import contextmanager\nfrom functools import wraps\nfrom io import IOBase\nfrom autocommand.errors import AutocommandError\n\n\n_empty = Parameter.empty\n\n\nclass AnnotationError(AutocommandError):\n    '''Annotation error: annotation must be a string, type, or tuple of both'''\n\n\nclass PositionalArgError(AutocommandError):\n    '''\n    Postional Arg Error: autocommand can't handle postional-only parameters\n    '''\n\n\nclass KWArgError(AutocommandError):\n    '''kwarg Error: autocommand can't handle a **kwargs parameter'''\n\n\nclass DocstringError(AutocommandError):\n    '''Docstring error'''\n\n\nclass TooManySplitsError(DocstringError):\n    '''\n    The docstring had too many ---- section splits. Currently we only support\n    using up to a single split, to split the docstring into description and\n    epilog parts.\n    '''\n\n\ndef _get_type_description(annotation):\n    '''\n    Given an annotation, return the (type, description) for the parameter.\n    If you provide an annotation that is somehow both a string and a callable,\n    the behavior is undefined.\n    '''\n    if annotation is _empty:\n        return None, None\n    elif callable(annotation):\n        return annotation, None\n    elif isinstance(annotation, str):\n        return None, annotation\n    elif isinstance(annotation, tuple):\n        try:\n            arg1, arg2 = annotation\n        except ValueError as e:\n            raise AnnotationError(annotation) from e\n        else:\n            if callable(arg1) and isinstance(arg2, str):\n                return arg1, arg2\n            elif isinstance(arg1, str) and callable(arg2):\n                return arg2, arg1\n\n    raise AnnotationError(annotation)\n\n\ndef _add_arguments(param, parser, used_char_args, add_nos):\n    '''\n    Add the argument(s) to an ArgumentParser (using add_argument) for a given\n    parameter. used_char_args is the set of -short options currently already in\n    use, and is updated (if necessary) by this function. If add_nos is True,\n    this will also add an inverse switch for all boolean options. For\n    instance, for the boolean parameter \"verbose\", this will create --verbose\n    and --no-verbose.\n    '''\n\n    # Impl note: This function is kept separate from make_parser because it's\n    # already very long and I wanted to separate out as much as possible into\n    # its own call scope, to prevent even the possibility of suble mutation\n    # bugs.\n    if param.kind is param.POSITIONAL_ONLY:\n        raise PositionalArgError(param)\n    elif param.kind is param.VAR_KEYWORD:\n        raise KWArgError(param)\n\n    # These are the kwargs for the add_argument function.\n    arg_spec = {}\n    is_option = False\n\n    # Get the type and default from the annotation.\n    arg_type, description = _get_type_description(param.annotation)\n\n    # Get the default value\n    default = param.default\n\n    # If there is no explicit type, and the default is present and not None,\n    # infer the type from the default.\n    if arg_type is None and default not in {_empty, None}:\n        arg_type = type(default)\n\n    # Add default. The presence of a default means this is an option, not an\n    # argument.\n    if default is not _empty:\n        arg_spec['default'] = default\n        is_option = True\n\n    # Add the type\n    if arg_type is not None:\n        # Special case for bool: make it just a --switch\n        if arg_type is bool:\n            if not default or default is _empty:\n                arg_spec['action'] = 'store_true'\n            else:\n                arg_spec['action'] = 'store_false'\n\n            # Switches are always options\n            is_option = True\n\n        # Special case for file types: make it a string type, for filename\n        elif isinstance(default, IOBase):\n            arg_spec['type'] = str\n\n        # TODO: special case for list type.\n        #   - How to specificy type of list members?\n        #       - param: [int]\n        #       - param: int =[]\n        #   - action='append' vs nargs='*'\n\n        else:\n            arg_spec['type'] = arg_type\n\n    # nargs: if the signature includes *args, collect them as trailing CLI\n    # arguments in a list. *args can't have a default value, so it can never be\n    # an option.\n    if param.kind is param.VAR_POSITIONAL:\n        # TODO: consider depluralizing metavar/name here.\n        arg_spec['nargs'] = '*'\n\n    # Add description.\n    if description is not None:\n        arg_spec['help'] = description\n\n    # Get the --flags\n    flags = []\n    name = param.name\n\n    if is_option:\n        # Add the first letter as a -short option.\n        for letter in name[0], name[0].swapcase():\n            if letter not in used_char_args:\n                used_char_args.add(letter)\n                flags.append('-{}'.format(letter))\n                break\n\n        # If the parameter is a --long option, or is a -short option that\n        # somehow failed to get a flag, add it.\n        if len(name) > 1 or not flags:\n            flags.append('--{}'.format(name))\n\n        arg_spec['dest'] = name\n    else:\n        flags.append(name)\n\n    parser.add_argument(*flags, **arg_spec)\n\n    # Create the --no- version for boolean switches\n    if add_nos and arg_type is bool:\n        parser.add_argument(\n            '--no-{}'.format(name),\n            action='store_const',\n            dest=name,\n            const=default if default is not _empty else False)\n\n\ndef make_parser(func_sig, description, epilog, add_nos):\n    '''\n    Given the signature of a function, create an ArgumentParser\n    '''\n    parser = ArgumentParser(description=description, epilog=epilog)\n\n    used_char_args = {'h'}\n\n    # Arange the params so that single-character arguments are first. This\n    # esnures they don't have to get --long versions. sorted is stable, so the\n    # parameters will otherwise still be in relative order.\n    params = sorted(\n        func_sig.parameters.values(),\n        key=lambda param: len(param.name) > 1)\n\n    for param in params:\n        _add_arguments(param, parser, used_char_args, add_nos)\n\n    return parser\n\n\n_DOCSTRING_SPLIT = compile_regex(r'\\n\\s*-{4,}\\s*\\n')\n\n\ndef parse_docstring(docstring):\n    '''\n    Given a docstring, parse it into a description and epilog part\n    '''\n    if docstring is None:\n        return '', ''\n\n    parts = _DOCSTRING_SPLIT.split(docstring)\n\n    if len(parts) == 1:\n        return docstring, ''\n    elif len(parts) == 2:\n        return parts[0], parts[1]\n    else:\n        raise TooManySplitsError()\n\n\ndef autoparse(\n        func=None, *,\n        description=None,\n        epilog=None,\n        add_nos=False,\n        parser=None):\n    '''\n    This decorator converts a function that takes normal arguments into a\n    function which takes a single optional argument, argv, parses it using an\n    argparse.ArgumentParser, and calls the underlying function with the parsed\n    arguments. If it is not given, sys.argv[1:] is used. This is so that the\n    function can be used as a setuptools entry point, as well as a normal main\n    function. sys.argv[1:] is not evaluated until the function is called, to\n    allow injecting different arguments for testing.\n\n    It uses the argument signature of the function to create an\n    ArgumentParser. Parameters without defaults become positional parameters,\n    while parameters *with* defaults become --options. Use annotations to set\n    the type of the parameter.\n\n    The `desctiption` and `epilog` parameters corrospond to the same respective\n    argparse parameters. If no description is given, it defaults to the\n    decorated functions's docstring, if present.\n\n    If add_nos is True, every boolean option (that is, every parameter with a\n    default of True/False or a type of bool) will have a --no- version created\n    as well, which inverts the option. For instance, the --verbose option will\n    have a --no-verbose counterpart. These are not mutually exclusive-\n    whichever one appears last in the argument list will have precedence.\n\n    If a parser is given, it is used instead of one generated from the function\n    signature. In this case, no parser is created; instead, the given parser is\n    used to parse the argv argument. The parser's results' argument names must\n    match up with the parameter names of the decorated function.\n\n    The decorated function is attached to the result as the `func` attribute,\n    and the parser is attached as the `parser` attribute.\n    '''\n\n    # If @autoparse(...) is used instead of @autoparse\n    if func is None:\n        return lambda f: autoparse(\n            f, description=description,\n            epilog=epilog,\n            add_nos=add_nos,\n            parser=parser)\n\n    func_sig = signature(func)\n\n    docstr_description, docstr_epilog = parse_docstring(getdoc(func))\n\n    if parser is None:\n        parser = make_parser(\n            func_sig,\n            description or docstr_description,\n            epilog or docstr_epilog,\n            add_nos)\n\n    @wraps(func)\n    def autoparse_wrapper(argv=None):\n        if argv is None:\n            argv = sys.argv[1:]\n\n        # Get empty argument binding, to fill with parsed arguments. This\n        # object does all the heavy lifting of turning named arguments into\n        # into correctly bound *args and **kwargs.\n        parsed_args = func_sig.bind_partial()\n        parsed_args.arguments.update(vars(parser.parse_args(argv)))\n\n        return func(*parsed_args.args, **parsed_args.kwargs)\n\n    # TODO: attach an updated __signature__ to autoparse_wrapper, just in case.\n\n    # Attach the wrapped function and parser, and return the wrapper.\n    autoparse_wrapper.func = func\n    autoparse_wrapper.parser = parser\n    return autoparse_wrapper\n\n\n@contextmanager\ndef smart_open(filename_or_file, *args, **kwargs):\n    '''\n    This context manager allows you to open a filename, if you want to default\n    some already-existing file object, like sys.stdout, which shouldn't be\n    closed at the end of the context. If the filename argument is a str, bytes,\n    or int, the file object is created via a call to open with the given *args\n    and **kwargs, sent to the context, and closed at the end of the context,\n    just like \"with open(filename) as f:\". If it isn't one of the openable\n    types, the object simply sent to the context unchanged, and left unclosed\n    at the end of the context. Example:\n\n        def work_with_file(name=sys.stdout):\n            with smart_open(name) as f:\n                # Works correctly if name is a str filename or sys.stdout\n                print(\"Some stuff\", file=f)\n                # If it was a filename, f is closed at the end here.\n    '''\n    if isinstance(filename_or_file, (str, bytes, int)):\n        with open(filename_or_file, *args, **kwargs) as file:\n            yield file\n    else:\n        yield filename_or_file\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/autocommand/errors.py","size":886,"sha1":"4429b4bc839cefeca67a9671beb88a0974af7a2a","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# Copyright 2014-2016 Nathan West\n#\n# This file is part of autocommand.\n#\n# autocommand is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Lesser General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# autocommand is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with autocommand.  If not, see <http://www.gnu.org/licenses/>.\n\n\nclass AutocommandError(Exception):\n    '''Base class for autocommand exceptions'''\n    pass\n\n# Individual modules will define errors specific to that module.\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/backports/__init__.py","size":81,"sha1":"0b9c483b7399d4dfa8a400e86d0b447e5bcd5d19","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"__path__ = __import__('pkgutil').extend_path(__path__, __name__)  # type: ignore\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/backports/tarfile/__init__.py","size":108491,"sha1":"41bf201d004966bfef38ff822732d9aa8c7f7b31","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"#-------------------------------------------------------------------\n# tarfile.py\n#-------------------------------------------------------------------\n# Copyright (C) 2002 Lars Gustaebel <lars@gustaebel.de>\n# All rights reserved.\n#\n# Permission  is  hereby granted,  free  of charge,  to  any person\n# obtaining a  copy of  this software  and associated documentation\n# files  (the  \"Software\"),  to   deal  in  the  Software   without\n# restriction,  including  without limitation  the  rights to  use,\n# copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies  of  the  Software,  and to  permit  persons  to  whom the\n# Software  is  furnished  to  do  so,  subject  to  the  following\n# conditions:\n#\n# The above copyright  notice and this  permission notice shall  be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS  IS\", WITHOUT WARRANTY OF ANY  KIND,\n# EXPRESS OR IMPLIED, INCLUDING  BUT NOT LIMITED TO  THE WARRANTIES\n# OF  MERCHANTABILITY,  FITNESS   FOR  A  PARTICULAR   PURPOSE  AND\n# NONINFRINGEMENT.  IN  NO  EVENT SHALL  THE  AUTHORS  OR COPYRIGHT\n# HOLDERS  BE LIABLE  FOR ANY  CLAIM, DAMAGES  OR OTHER  LIABILITY,\n# WHETHER  IN AN  ACTION OF  CONTRACT, TORT  OR OTHERWISE,  ARISING\n# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n# OTHER DEALINGS IN THE SOFTWARE.\n#\n\"\"\"Read from and write to tar format archives.\n\"\"\"\n\nversion     = \"0.9.0\"\n__author__  = \"Lars Gust\\u00e4bel (lars@gustaebel.de)\"\n__credits__ = \"Gustavo Niemeyer, Niels Gust\\u00e4bel, Richard Townsend.\"\n\n#---------\n# Imports\n#---------\nfrom builtins import open as bltn_open\nimport sys\nimport os\nimport io\nimport shutil\nimport stat\nimport time\nimport struct\nimport copy\nimport re\n\nfrom .compat.py38 import removesuffix\n\ntry:\n    import pwd\nexcept ImportError:\n    pwd = None\ntry:\n    import grp\nexcept ImportError:\n    grp = None\n\n# os.symlink on Windows prior to 6.0 raises NotImplementedError\n# OSError (winerror=1314) will be raised if the caller does not hold the\n# SeCreateSymbolicLinkPrivilege privilege\nsymlink_exception = (AttributeError, NotImplementedError, OSError)\n\n# from tarfile import *\n__all__ = [\"TarFile\", \"TarInfo\", \"is_tarfile\", \"TarError\", \"ReadError\",\n           \"CompressionError\", \"StreamError\", \"ExtractError\", \"HeaderError\",\n           \"ENCODING\", \"USTAR_FORMAT\", \"GNU_FORMAT\", \"PAX_FORMAT\",\n           \"DEFAULT_FORMAT\", \"open\",\"fully_trusted_filter\", \"data_filter\",\n           \"tar_filter\", \"FilterError\", \"AbsoluteLinkError\",\n           \"OutsideDestinationError\", \"SpecialFileError\", \"AbsolutePathError\",\n           \"LinkOutsideDestinationError\"]\n\n\n#---------------------------------------------------------\n# tar constants\n#---------------------------------------------------------\nNUL = b\"\\0\"                     # the null character\nBLOCKSIZE = 512                 # length of processing blocks\nRECORDSIZE = BLOCKSIZE * 20     # length of records\nGNU_MAGIC = b\"ustar  \\0\"        # magic gnu tar string\nPOSIX_MAGIC = b\"ustar\\x0000\"    # magic posix tar string\n\nLENGTH_NAME = 100               # maximum length of a filename\nLENGTH_LINK = 100               # maximum length of a linkname\nLENGTH_PREFIX = 155             # maximum length of the prefix field\n\nREGTYPE = b\"0\"                  # regular file\nAREGTYPE = b\"\\0\"                # regular file\nLNKTYPE = b\"1\"                  # link (inside tarfile)\nSYMTYPE = b\"2\"                  # symbolic link\nCHRTYPE = b\"3\"                  # character special device\nBLKTYPE = b\"4\"                  # block special device\nDIRTYPE = b\"5\"                  # directory\nFIFOTYPE = b\"6\"                 # fifo special device\nCONTTYPE = b\"7\"                 # contiguous file\n\nGNUTYPE_LONGNAME = b\"L\"         # GNU tar longname\nGNUTYPE_LONGLINK = b\"K\"         # GNU tar longlink\nGNUTYPE_SPARSE = b\"S\"           # GNU tar sparse file\n\nXHDTYPE = b\"x\"                  # POSIX.1-2001 extended header\nXGLTYPE = b\"g\"                  # POSIX.1-2001 global header\nSOLARIS_XHDTYPE = b\"X\"          # Solaris extended header\n\nUSTAR_FORMAT = 0                # POSIX.1-1988 (ustar) format\nGNU_FORMAT = 1                  # GNU tar format\nPAX_FORMAT = 2                  # POSIX.1-2001 (pax) format\nDEFAULT_FORMAT = PAX_FORMAT\n\n#---------------------------------------------------------\n# tarfile constants\n#---------------------------------------------------------\n# File types that tarfile supports:\nSUPPORTED_TYPES = (REGTYPE, AREGTYPE, LNKTYPE,\n                   SYMTYPE, DIRTYPE, FIFOTYPE,\n                   CONTTYPE, CHRTYPE, BLKTYPE,\n                   GNUTYPE_LONGNAME, GNUTYPE_LONGLINK,\n                   GNUTYPE_SPARSE)\n\n# File types that will be treated as a regular file.\nREGULAR_TYPES = (REGTYPE, AREGTYPE,\n                 CONTTYPE, GNUTYPE_SPARSE)\n\n# File types that are part of the GNU tar format.\nGNU_TYPES = (GNUTYPE_LONGNAME, GNUTYPE_LONGLINK,\n             GNUTYPE_SPARSE)\n\n# Fields from a pax header that override a TarInfo attribute.\nPAX_FIELDS = (\"path\", \"linkpath\", \"size\", \"mtime\",\n              \"uid\", \"gid\", \"uname\", \"gname\")\n\n# Fields from a pax header that are affected by hdrcharset.\nPAX_NAME_FIELDS = {\"path\", \"linkpath\", \"uname\", \"gname\"}\n\n# Fields in a pax header that are numbers, all other fields\n# are treated as strings.\nPAX_NUMBER_FIELDS = {\n    \"atime\": float,\n    \"ctime\": float,\n    \"mtime\": float,\n    \"uid\": int,\n    \"gid\": int,\n    \"size\": int\n}\n\n#---------------------------------------------------------\n# initialization\n#---------------------------------------------------------\nif os.name == \"nt\":\n    ENCODING = \"utf-8\"\nelse:\n    ENCODING = sys.getfilesystemencoding()\n\n#---------------------------------------------------------\n# Some useful functions\n#---------------------------------------------------------\n\ndef stn(s, length, encoding, errors):\n    \"\"\"Convert a string to a null-terminated bytes object.\n    \"\"\"\n    if s is None:\n        raise ValueError(\"metadata cannot contain None\")\n    s = s.encode(encoding, errors)\n    return s[:length] + (length - len(s)) * NUL\n\ndef nts(s, encoding, errors):\n    \"\"\"Convert a null-terminated bytes object to a string.\n    \"\"\"\n    p = s.find(b\"\\0\")\n    if p != -1:\n        s = s[:p]\n    return s.decode(encoding, errors)\n\ndef nti(s):\n    \"\"\"Convert a number field to a python number.\n    \"\"\"\n    # There are two possible encodings for a number field, see\n    # itn() below.\n    if s[0] in (0o200, 0o377):\n        n = 0\n        for i in range(len(s) - 1):\n            n <<= 8\n            n += s[i + 1]\n        if s[0] == 0o377:\n            n = -(256 ** (len(s) - 1) - n)\n    else:\n        try:\n            s = nts(s, \"ascii\", \"strict\")\n            n = int(s.strip() or \"0\", 8)\n        except ValueError:\n            raise InvalidHeaderError(\"invalid header\")\n    return n\n\ndef itn(n, digits=8, format=DEFAULT_FORMAT):\n    \"\"\"Convert a python number to a number field.\n    \"\"\"\n    # POSIX 1003.1-1988 requires numbers to be encoded as a string of\n    # octal digits followed by a null-byte, this allows values up to\n    # (8**(digits-1))-1. GNU tar allows storing numbers greater than\n    # that if necessary. A leading 0o200 or 0o377 byte indicate this\n    # particular encoding, the following digits-1 bytes are a big-endian\n    # base-256 representation. This allows values up to (256**(digits-1))-1.\n    # A 0o200 byte indicates a positive number, a 0o377 byte a negative\n    # number.\n    original_n = n\n    n = int(n)\n    if 0 <= n < 8 ** (digits - 1):\n        s = bytes(\"%0*o\" % (digits - 1, n), \"ascii\") + NUL\n    elif format == GNU_FORMAT and -256 ** (digits - 1) <= n < 256 ** (digits - 1):\n        if n >= 0:\n            s = bytearray([0o200])\n        else:\n            s = bytearray([0o377])\n            n = 256 ** digits + n\n\n        for i in range(digits - 1):\n            s.insert(1, n & 0o377)\n            n >>= 8\n    else:\n        raise ValueError(\"overflow in number field\")\n\n    return s\n\ndef calc_chksums(buf):\n    \"\"\"Calculate the checksum for a member's header by summing up all\n       characters except for the chksum field which is treated as if\n       it was filled with spaces. According to the GNU tar sources,\n       some tars (Sun and NeXT) calculate chksum with signed char,\n       which will be different if there are chars in the buffer with\n       the high bit set. So we calculate two checksums, unsigned and\n       signed.\n    \"\"\"\n    unsigned_chksum = 256 + sum(struct.unpack_from(\"148B8x356B\", buf))\n    signed_chksum = 256 + sum(struct.unpack_from(\"148b8x356b\", buf))\n    return unsigned_chksum, signed_chksum\n\ndef copyfileobj(src, dst, length=None, exception=OSError, bufsize=None):\n    \"\"\"Copy length bytes from fileobj src to fileobj dst.\n       If length is None, copy the entire content.\n    \"\"\"\n    bufsize = bufsize or 16 * 1024\n    if length == 0:\n        return\n    if length is None:\n        shutil.copyfileobj(src, dst, bufsize)\n        return\n\n    blocks, remainder = divmod(length, bufsize)\n    for b in range(blocks):\n        buf = src.read(bufsize)\n        if len(buf) < bufsize:\n            raise exception(\"unexpected end of data\")\n        dst.write(buf)\n\n    if remainder != 0:\n        buf = src.read(remainder)\n        if len(buf) < remainder:\n            raise exception(\"unexpected end of data\")\n        dst.write(buf)\n    return\n\ndef _safe_print(s):\n    encoding = getattr(sys.stdout, 'encoding', None)\n    if encoding is not None:\n        s = s.encode(encoding, 'backslashreplace').decode(encoding)\n    print(s, end=' ')\n\n\nclass TarError(Exception):\n    \"\"\"Base exception.\"\"\"\n    pass\nclass ExtractError(TarError):\n    \"\"\"General exception for extract errors.\"\"\"\n    pass\nclass ReadError(TarError):\n    \"\"\"Exception for unreadable tar archives.\"\"\"\n    pass\nclass CompressionError(TarError):\n    \"\"\"Exception for unavailable compression methods.\"\"\"\n    pass\nclass StreamError(TarError):\n    \"\"\"Exception for unsupported operations on stream-like TarFiles.\"\"\"\n    pass\nclass HeaderError(TarError):\n    \"\"\"Base exception for header errors.\"\"\"\n    pass\nclass EmptyHeaderError(HeaderError):\n    \"\"\"Exception for empty headers.\"\"\"\n    pass\nclass TruncatedHeaderError(HeaderError):\n    \"\"\"Exception for truncated headers.\"\"\"\n    pass\nclass EOFHeaderError(HeaderError):\n    \"\"\"Exception for end of file headers.\"\"\"\n    pass\nclass InvalidHeaderError(HeaderError):\n    \"\"\"Exception for invalid headers.\"\"\"\n    pass\nclass SubsequentHeaderError(HeaderError):\n    \"\"\"Exception for missing and invalid extended headers.\"\"\"\n    pass\n\n#---------------------------\n# internal stream interface\n#---------------------------\nclass _LowLevelFile:\n    \"\"\"Low-level file object. Supports reading and writing.\n       It is used instead of a regular file object for streaming\n       access.\n    \"\"\"\n\n    def __init__(self, name, mode):\n        mode = {\n            \"r\": os.O_RDONLY,\n            \"w\": os.O_WRONLY | os.O_CREAT | os.O_TRUNC,\n        }[mode]\n        if hasattr(os, \"O_BINARY\"):\n            mode |= os.O_BINARY\n        self.fd = os.open(name, mode, 0o666)\n\n    def close(self):\n        os.close(self.fd)\n\n    def read(self, size):\n        return os.read(self.fd, size)\n\n    def write(self, s):\n        os.write(self.fd, s)\n\nclass _Stream:\n    \"\"\"Class that serves as an adapter between TarFile and\n       a stream-like object.  The stream-like object only\n       needs to have a read() or write() method that works with bytes,\n       and the method is accessed blockwise.\n       Use of gzip or bzip2 compression is possible.\n       A stream-like object could be for example: sys.stdin.buffer,\n       sys.stdout.buffer, a socket, a tape device etc.\n\n       _Stream is intended to be used only internally.\n    \"\"\"\n\n    def __init__(self, name, mode, comptype, fileobj, bufsize,\n                 compresslevel):\n        \"\"\"Construct a _Stream object.\n        \"\"\"\n        self._extfileobj = True\n        if fileobj is None:\n            fileobj = _LowLevelFile(name, mode)\n            self._extfileobj = False\n\n        if comptype == '*':\n            # Enable transparent compression detection for the\n            # stream interface\n            fileobj = _StreamProxy(fileobj)\n            comptype = fileobj.getcomptype()\n\n        self.name     = name or \"\"\n        self.mode     = mode\n        self.comptype = comptype\n        self.fileobj  = fileobj\n        self.bufsize  = bufsize\n        self.buf      = b\"\"\n        self.pos      = 0\n        self.closed   = False\n\n        try:\n            if comptype == \"gz\":\n                try:\n                    import zlib\n                except ImportError:\n                    raise CompressionError(\"zlib module is not available\") from None\n                self.zlib = zlib\n                self.crc = zlib.crc32(b\"\")\n                if mode == \"r\":\n                    self.exception = zlib.error\n                    self._init_read_gz()\n                else:\n                    self._init_write_gz(compresslevel)\n\n            elif comptype == \"bz2\":\n                try:\n                    import bz2\n                except ImportError:\n                    raise CompressionError(\"bz2 module is not available\") from None\n                if mode == \"r\":\n                    self.dbuf = b\"\"\n                    self.cmp = bz2.BZ2Decompressor()\n                    self.exception = OSError\n                else:\n                    self.cmp = bz2.BZ2Compressor(compresslevel)\n\n            elif comptype == \"xz\":\n                try:\n                    import lzma\n                except ImportError:\n                    raise CompressionError(\"lzma module is not available\") from None\n                if mode == \"r\":\n                    self.dbuf = b\"\"\n                    self.cmp = lzma.LZMADecompressor()\n                    self.exception = lzma.LZMAError\n                else:\n                    self.cmp = lzma.LZMACompressor()\n\n            elif comptype != \"tar\":\n                raise CompressionError(\"unknown compression type %r\" % comptype)\n\n        except:\n            if not self._extfileobj:\n                self.fileobj.close()\n            self.closed = True\n            raise\n\n    def __del__(self):\n        if hasattr(self, \"closed\") and not self.closed:\n            self.close()\n\n    def _init_write_gz(self, compresslevel):\n        \"\"\"Initialize for writing with gzip compression.\n        \"\"\"\n        self.cmp = self.zlib.compressobj(compresslevel,\n                                         self.zlib.DEFLATED,\n                                         -self.zlib.MAX_WBITS,\n                                         self.zlib.DEF_MEM_LEVEL,\n                                         0)\n        timestamp = struct.pack(\"<L\", int(time.time()))\n        self.__write(b\"\\037\\213\\010\\010\" + timestamp + b\"\\002\\377\")\n        if self.name.endswith(\".gz\"):\n            self.name = self.name[:-3]\n        # Honor \"directory components removed\" from RFC1952\n        self.name = os.path.basename(self.name)\n        # RFC1952 says we must use ISO-8859-1 for the FNAME field.\n        self.__write(self.name.encode(\"iso-8859-1\", \"replace\") + NUL)\n\n    def write(self, s):\n        \"\"\"Write string s to the stream.\n        \"\"\"\n        if self.comptype == \"gz\":\n            self.crc = self.zlib.crc32(s, self.crc)\n        self.pos += len(s)\n        if self.comptype != \"tar\":\n            s = self.cmp.compress(s)\n        self.__write(s)\n\n    def __write(self, s):\n        \"\"\"Write string s to the stream if a whole new block\n           is ready to be written.\n        \"\"\"\n        self.buf += s\n        while len(self.buf) > self.bufsize:\n            self.fileobj.write(self.buf[:self.bufsize])\n            self.buf = self.buf[self.bufsize:]\n\n    def close(self):\n        \"\"\"Close the _Stream object. No operation should be\n           done on it afterwards.\n        \"\"\"\n        if self.closed:\n            return\n\n        self.closed = True\n        try:\n            if self.mode == \"w\" and self.comptype != \"tar\":\n                self.buf += self.cmp.flush()\n\n            if self.mode == \"w\" and self.buf:\n                self.fileobj.write(self.buf)\n                self.buf = b\"\"\n                if self.comptype == \"gz\":\n                    self.fileobj.write(struct.pack(\"<L\", self.crc))\n                    self.fileobj.write(struct.pack(\"<L\", self.pos & 0xffffFFFF))\n        finally:\n            if not self._extfileobj:\n                self.fileobj.close()\n\n    def _init_read_gz(self):\n        \"\"\"Initialize for reading a gzip compressed fileobj.\n        \"\"\"\n        self.cmp = self.zlib.decompressobj(-self.zlib.MAX_WBITS)\n        self.dbuf = b\"\"\n\n        # taken from gzip.GzipFile with some alterations\n        if self.__read(2) != b\"\\037\\213\":\n            raise ReadError(\"not a gzip file\")\n        if self.__read(1) != b\"\\010\":\n            raise CompressionError(\"unsupported compression method\")\n\n        flag = ord(self.__read(1))\n        self.__read(6)\n\n        if flag & 4:\n            xlen = ord(self.__read(1)) + 256 * ord(self.__read(1))\n            self.read(xlen)\n        if flag & 8:\n            while True:\n                s = self.__read(1)\n                if not s or s == NUL:\n                    break\n        if flag & 16:\n            while True:\n                s = self.__read(1)\n                if not s or s == NUL:\n                    break\n        if flag & 2:\n            self.__read(2)\n\n    def tell(self):\n        \"\"\"Return the stream's file pointer position.\n        \"\"\"\n        return self.pos\n\n    def seek(self, pos=0):\n        \"\"\"Set the stream's file pointer to pos. Negative seeking\n           is forbidden.\n        \"\"\"\n        if pos - self.pos >= 0:\n            blocks, remainder = divmod(pos - self.pos, self.bufsize)\n            for i in range(blocks):\n                self.read(self.bufsize)\n            self.read(remainder)\n        else:\n            raise StreamError(\"seeking backwards is not allowed\")\n        return self.pos\n\n    def read(self, size):\n        \"\"\"Return the next size number of bytes from the stream.\"\"\"\n        assert size is not None\n        buf = self._read(size)\n        self.pos += len(buf)\n        return buf\n\n    def _read(self, size):\n        \"\"\"Return size bytes from the stream.\n        \"\"\"\n        if self.comptype == \"tar\":\n            return self.__read(size)\n\n        c = len(self.dbuf)\n        t = [self.dbuf]\n        while c < size:\n            # Skip underlying buffer to avoid unaligned double buffering.\n            if self.buf:\n                buf = self.buf\n                self.buf = b\"\"\n            else:\n                buf = self.fileobj.read(self.bufsize)\n                if not buf:\n                    break\n            try:\n                buf = self.cmp.decompress(buf)\n            except self.exception as e:\n                raise ReadError(\"invalid compressed data\") from e\n            t.append(buf)\n            c += len(buf)\n        t = b\"\".join(t)\n        self.dbuf = t[size:]\n        return t[:size]\n\n    def __read(self, size):\n        \"\"\"Return size bytes from stream. If internal buffer is empty,\n           read another block from the stream.\n        \"\"\"\n        c = len(self.buf)\n        t = [self.buf]\n        while c < size:\n            buf = self.fileobj.read(self.bufsize)\n            if not buf:\n                break\n            t.append(buf)\n            c += len(buf)\n        t = b\"\".join(t)\n        self.buf = t[size:]\n        return t[:size]\n# class _Stream\n\nclass _StreamProxy(object):\n    \"\"\"Small proxy class that enables transparent compression\n       detection for the Stream interface (mode 'r|*').\n    \"\"\"\n\n    def __init__(self, fileobj):\n        self.fileobj = fileobj\n        self.buf = self.fileobj.read(BLOCKSIZE)\n\n    def read(self, size):\n        self.read = self.fileobj.read\n        return self.buf\n\n    def getcomptype(self):\n        if self.buf.startswith(b\"\\x1f\\x8b\\x08\"):\n            return \"gz\"\n        elif self.buf[0:3] == b\"BZh\" and self.buf[4:10] == b\"1AY&SY\":\n            return \"bz2\"\n        elif self.buf.startswith((b\"\\x5d\\x00\\x00\\x80\", b\"\\xfd7zXZ\")):\n            return \"xz\"\n        else:\n            return \"tar\"\n\n    def close(self):\n        self.fileobj.close()\n# class StreamProxy\n\n#------------------------\n# Extraction file object\n#------------------------\nclass _FileInFile(object):\n    \"\"\"A thin wrapper around an existing file object that\n       provides a part of its data as an individual file\n       object.\n    \"\"\"\n\n    def __init__(self, fileobj, offset, size, name, blockinfo=None):\n        self.fileobj = fileobj\n        self.offset = offset\n        self.size = size\n        self.position = 0\n        self.name = name\n        self.closed = False\n\n        if blockinfo is None:\n            blockinfo = [(0, size)]\n\n        # Construct a map with data and zero blocks.\n        self.map_index = 0\n        self.map = []\n        lastpos = 0\n        realpos = self.offset\n        for offset, size in blockinfo:\n            if offset > lastpos:\n                self.map.append((False, lastpos, offset, None))\n            self.map.append((True, offset, offset + size, realpos))\n            realpos += size\n            lastpos = offset + size\n        if lastpos < self.size:\n            self.map.append((False, lastpos, self.size, None))\n\n    def flush(self):\n        pass\n\n    @property\n    def mode(self):\n        return 'rb'\n\n    def readable(self):\n        return True\n\n    def writable(self):\n        return False\n\n    def seekable(self):\n        return self.fileobj.seekable()\n\n    def tell(self):\n        \"\"\"Return the current file position.\n        \"\"\"\n        return self.position\n\n    def seek(self, position, whence=io.SEEK_SET):\n        \"\"\"Seek to a position in the file.\n        \"\"\"\n        if whence == io.SEEK_SET:\n            self.position = min(max(position, 0), self.size)\n        elif whence == io.SEEK_CUR:\n            if position < 0:\n                self.position = max(self.position + position, 0)\n            else:\n                self.position = min(self.position + position, self.size)\n        elif whence == io.SEEK_END:\n            self.position = max(min(self.size + position, self.size), 0)\n        else:\n            raise ValueError(\"Invalid argument\")\n        return self.position\n\n    def read(self, size=None):\n        \"\"\"Read data from the file.\n        \"\"\"\n        if size is None:\n            size = self.size - self.position\n        else:\n            size = min(size, self.size - self.position)\n\n        buf = b\"\"\n        while size > 0:\n            while True:\n                data, start, stop, offset = self.map[self.map_index]\n                if start <= self.position < stop:\n                    break\n                else:\n                    self.map_index += 1\n                    if self.map_index == len(self.map):\n                        self.map_index = 0\n            length = min(size, stop - self.position)\n            if data:\n                self.fileobj.seek(offset + (self.position - start))\n                b = self.fileobj.read(length)\n                if len(b) != length:\n                    raise ReadError(\"unexpected end of data\")\n                buf += b\n            else:\n                buf += NUL * length\n            size -= length\n            self.position += length\n        return buf\n\n    def readinto(self, b):\n        buf = self.read(len(b))\n        b[:len(buf)] = buf\n        return len(buf)\n\n    def close(self):\n        self.closed = True\n#class _FileInFile\n\nclass ExFileObject(io.BufferedReader):\n\n    def __init__(self, tarfile, tarinfo):\n        fileobj = _FileInFile(tarfile.fileobj, tarinfo.offset_data,\n                tarinfo.size, tarinfo.name, tarinfo.sparse)\n        super().__init__(fileobj)\n#class ExFileObject\n\n\n#-----------------------------\n# extraction filters (PEP 706)\n#-----------------------------\n\nclass FilterError(TarError):\n    pass\n\nclass AbsolutePathError(FilterError):\n    def __init__(self, tarinfo):\n        self.tarinfo = tarinfo\n        super().__init__(f'member {tarinfo.name!r} has an absolute path')\n\nclass OutsideDestinationError(FilterError):\n    def __init__(self, tarinfo, path):\n        self.tarinfo = tarinfo\n        self._path = path\n        super().__init__(f'{tarinfo.name!r} would be extracted to {path!r}, '\n                         + 'which is outside the destination')\n\nclass SpecialFileError(FilterError):\n    def __init__(self, tarinfo):\n        self.tarinfo = tarinfo\n        super().__init__(f'{tarinfo.name!r} is a special file')\n\nclass AbsoluteLinkError(FilterError):\n    def __init__(self, tarinfo):\n        self.tarinfo = tarinfo\n        super().__init__(f'{tarinfo.name!r} is a link to an absolute path')\n\nclass LinkOutsideDestinationError(FilterError):\n    def __init__(self, tarinfo, path):\n        self.tarinfo = tarinfo\n        self._path = path\n        super().__init__(f'{tarinfo.name!r} would link to {path!r}, '\n                         + 'which is outside the destination')\n\ndef _get_filtered_attrs(member, dest_path, for_data=True):\n    new_attrs = {}\n    name = member.name\n    dest_path = os.path.realpath(dest_path)\n    # Strip leading / (tar's directory separator) from filenames.\n    # Include os.sep (target OS directory separator) as well.\n    if name.startswith(('/', os.sep)):\n        name = new_attrs['name'] = member.path.lstrip('/' + os.sep)\n    if os.path.isabs(name):\n        # Path is absolute even after stripping.\n        # For example, 'C:/foo' on Windows.\n        raise AbsolutePathError(member)\n    # Ensure we stay in the destination\n    target_path = os.path.realpath(os.path.join(dest_path, name))\n    if os.path.commonpath([target_path, dest_path]) != dest_path:\n        raise OutsideDestinationError(member, target_path)\n    # Limit permissions (no high bits, and go-w)\n    mode = member.mode\n    if mode is not None:\n        # Strip high bits & group/other write bits\n        mode = mode & 0o755\n        if for_data:\n            # For data, handle permissions & file types\n            if member.isreg() or member.islnk():\n                if not mode & 0o100:\n                    # Clear executable bits if not executable by user\n                    mode &= ~0o111\n                # Ensure owner can read & write\n                mode |= 0o600\n            elif member.isdir() or member.issym():\n                # Ignore mode for directories & symlinks\n                mode = None\n            else:\n                # Reject special files\n                raise SpecialFileError(member)\n        if mode != member.mode:\n            new_attrs['mode'] = mode\n    if for_data:\n        # Ignore ownership for 'data'\n        if member.uid is not None:\n            new_attrs['uid'] = None\n        if member.gid is not None:\n            new_attrs['gid'] = None\n        if member.uname is not None:\n            new_attrs['uname'] = None\n        if member.gname is not None:\n            new_attrs['gname'] = None\n        # Check link destination for 'data'\n        if member.islnk() or member.issym():\n            if os.path.isabs(member.linkname):\n                raise AbsoluteLinkError(member)\n            if member.issym():\n                target_path = os.path.join(dest_path,\n                                           os.path.dirname(name),\n                                           member.linkname)\n            else:\n                target_path = os.path.join(dest_path,\n                                           member.linkname)\n            target_path = os.path.realpath(target_path)\n            if os.path.commonpath([target_path, dest_path]) != dest_path:\n                raise LinkOutsideDestinationError(member, target_path)\n    return new_attrs\n\ndef fully_trusted_filter(member, dest_path):\n    return member\n\ndef tar_filter(member, dest_path):\n    new_attrs = _get_filtered_attrs(member, dest_path, False)\n    if new_attrs:\n        return member.replace(**new_attrs, deep=False)\n    return member\n\ndef data_filter(member, dest_path):\n    new_attrs = _get_filtered_attrs(member, dest_path, True)\n    if new_attrs:\n        return member.replace(**new_attrs, deep=False)\n    return member\n\n_NAMED_FILTERS = {\n    \"fully_trusted\": fully_trusted_filter,\n    \"tar\": tar_filter,\n    \"data\": data_filter,\n}\n\n#------------------\n# Exported Classes\n#------------------\n\n# Sentinel for replace() defaults, meaning \"don't change the attribute\"\n_KEEP = object()\n\nclass TarInfo(object):\n    \"\"\"Informational class which holds the details about an\n       archive member given by a tar header block.\n       TarInfo objects are returned by TarFile.getmember(),\n       TarFile.getmembers() and TarFile.gettarinfo() and are\n       usually created internally.\n    \"\"\"\n\n    __slots__ = dict(\n        name = 'Name of the archive member.',\n        mode = 'Permission bits.',\n        uid = 'User ID of the user who originally stored this member.',\n        gid = 'Group ID of the user who originally stored this member.',\n        size = 'Size in bytes.',\n        mtime = 'Time of last modification.',\n        chksum = 'Header checksum.',\n        type = ('File type. type is usually one of these constants: '\n                'REGTYPE, AREGTYPE, LNKTYPE, SYMTYPE, DIRTYPE, FIFOTYPE, '\n                'CONTTYPE, CHRTYPE, BLKTYPE, GNUTYPE_SPARSE.'),\n        linkname = ('Name of the target file name, which is only present '\n                    'in TarInfo objects of type LNKTYPE and SYMTYPE.'),\n        uname = 'User name.',\n        gname = 'Group name.',\n        devmajor = 'Device major number.',\n        devminor = 'Device minor number.',\n        offset = 'The tar header starts here.',\n        offset_data = \"The file's data starts here.\",\n        pax_headers = ('A dictionary containing key-value pairs of an '\n                       'associated pax extended header.'),\n        sparse = 'Sparse member information.',\n        _tarfile = None,\n        _sparse_structs = None,\n        _link_target = None,\n        )\n\n    def __init__(self, name=\"\"):\n        \"\"\"Construct a TarInfo object. name is the optional name\n           of the member.\n        \"\"\"\n        self.name = name        # member name\n        self.mode = 0o644       # file permissions\n        self.uid = 0            # user id\n        self.gid = 0            # group id\n        self.size = 0           # file size\n        self.mtime = 0          # modification time\n        self.chksum = 0         # header checksum\n        self.type = REGTYPE     # member type\n        self.linkname = \"\"      # link name\n        self.uname = \"\"         # user name\n        self.gname = \"\"         # group name\n        self.devmajor = 0       # device major number\n        self.devminor = 0       # device minor number\n\n        self.offset = 0         # the tar header starts here\n        self.offset_data = 0    # the file's data starts here\n\n        self.sparse = None      # sparse member information\n        self.pax_headers = {}   # pax header information\n\n    @property\n    def tarfile(self):\n        import warnings\n        warnings.warn(\n            'The undocumented \"tarfile\" attribute of TarInfo objects '\n            + 'is deprecated and will be removed in Python 3.16',\n            DeprecationWarning, stacklevel=2)\n        return self._tarfile\n\n    @tarfile.setter\n    def tarfile(self, tarfile):\n        import warnings\n        warnings.warn(\n            'The undocumented \"tarfile\" attribute of TarInfo objects '\n            + 'is deprecated and will be removed in Python 3.16',\n            DeprecationWarning, stacklevel=2)\n        self._tarfile = tarfile\n\n    @property\n    def path(self):\n        'In pax headers, \"name\" is called \"path\".'\n        return self.name\n\n    @path.setter\n    def path(self, name):\n        self.name = name\n\n    @property\n    def linkpath(self):\n        'In pax headers, \"linkname\" is called \"linkpath\".'\n        return self.linkname\n\n    @linkpath.setter\n    def linkpath(self, linkname):\n        self.linkname = linkname\n\n    def __repr__(self):\n        return \"<%s %r at %#x>\" % (self.__class__.__name__,self.name,id(self))\n\n    def replace(self, *,\n                name=_KEEP, mtime=_KEEP, mode=_KEEP, linkname=_KEEP,\n                uid=_KEEP, gid=_KEEP, uname=_KEEP, gname=_KEEP,\n                deep=True, _KEEP=_KEEP):\n        \"\"\"Return a deep copy of self with the given attributes replaced.\n        \"\"\"\n        if deep:\n            result = copy.deepcopy(self)\n        else:\n            result = copy.copy(self)\n        if name is not _KEEP:\n            result.name = name\n        if mtime is not _KEEP:\n            result.mtime = mtime\n        if mode is not _KEEP:\n            result.mode = mode\n        if linkname is not _KEEP:\n            result.linkname = linkname\n        if uid is not _KEEP:\n            result.uid = uid\n        if gid is not _KEEP:\n            result.gid = gid\n        if uname is not _KEEP:\n            result.uname = uname\n        if gname is not _KEEP:\n            result.gname = gname\n        return result\n\n    def get_info(self):\n        \"\"\"Return the TarInfo's attributes as a dictionary.\n        \"\"\"\n        if self.mode is None:\n            mode = None\n        else:\n            mode = self.mode & 0o7777\n        info = {\n            \"name\":     self.name,\n            \"mode\":     mode,\n            \"uid\":      self.uid,\n            \"gid\":      self.gid,\n            \"size\":     self.size,\n            \"mtime\":    self.mtime,\n            \"chksum\":   self.chksum,\n            \"type\":     self.type,\n            \"linkname\": self.linkname,\n            \"uname\":    self.uname,\n            \"gname\":    self.gname,\n            \"devmajor\": self.devmajor,\n            \"devminor\": self.devminor\n        }\n\n        if info[\"type\"] == DIRTYPE and not info[\"name\"].endswith(\"/\"):\n            info[\"name\"] += \"/\"\n\n        return info\n\n    def tobuf(self, format=DEFAULT_FORMAT, encoding=ENCODING, errors=\"surrogateescape\"):\n        \"\"\"Return a tar header as a string of 512 byte blocks.\n        \"\"\"\n        info = self.get_info()\n        for name, value in info.items():\n            if value is None:\n                raise ValueError(\"%s may not be None\" % name)\n\n        if format == USTAR_FORMAT:\n            return self.create_ustar_header(info, encoding, errors)\n        elif format == GNU_FORMAT:\n            return self.create_gnu_header(info, encoding, errors)\n        elif format == PAX_FORMAT:\n            return self.create_pax_header(info, encoding)\n        else:\n            raise ValueError(\"invalid format\")\n\n    def create_ustar_header(self, info, encoding, errors):\n        \"\"\"Return the object as a ustar header block.\n        \"\"\"\n        info[\"magic\"] = POSIX_MAGIC\n\n        if len(info[\"linkname\"].encode(encoding, errors)) > LENGTH_LINK:\n            raise ValueError(\"linkname is too long\")\n\n        if len(info[\"name\"].encode(encoding, errors)) > LENGTH_NAME:\n            info[\"prefix\"], info[\"name\"] = self._posix_split_name(info[\"name\"], encoding, errors)\n\n        return self._create_header(info, USTAR_FORMAT, encoding, errors)\n\n    def create_gnu_header(self, info, encoding, errors):\n        \"\"\"Return the object as a GNU header block sequence.\n        \"\"\"\n        info[\"magic\"] = GNU_MAGIC\n\n        buf = b\"\"\n        if len(info[\"linkname\"].encode(encoding, errors)) > LENGTH_LINK:\n            buf += self._create_gnu_long_header(info[\"linkname\"], GNUTYPE_LONGLINK, encoding, errors)\n\n        if len(info[\"name\"].encode(encoding, errors)) > LENGTH_NAME:\n            buf += self._create_gnu_long_header(info[\"name\"], GNUTYPE_LONGNAME, encoding, errors)\n\n        return buf + self._create_header(info, GNU_FORMAT, encoding, errors)\n\n    def create_pax_header(self, info, encoding):\n        \"\"\"Return the object as a ustar header block. If it cannot be\n           represented this way, prepend a pax extended header sequence\n           with supplement information.\n        \"\"\"\n        info[\"magic\"] = POSIX_MAGIC\n        pax_headers = self.pax_headers.copy()\n\n        # Test string fields for values that exceed the field length or cannot\n        # be represented in ASCII encoding.\n        for name, hname, length in (\n                (\"name\", \"path\", LENGTH_NAME), (\"linkname\", \"linkpath\", LENGTH_LINK),\n                (\"uname\", \"uname\", 32), (\"gname\", \"gname\", 32)):\n\n            if hname in pax_headers:\n                # The pax header has priority.\n                continue\n\n            # Try to encode the string as ASCII.\n            try:\n                info[name].encode(\"ascii\", \"strict\")\n            except UnicodeEncodeError:\n                pax_headers[hname] = info[name]\n                continue\n\n            if len(info[name]) > length:\n                pax_headers[hname] = info[name]\n\n        # Test number fields for values that exceed the field limit or values\n        # that like to be stored as float.\n        for name, digits in ((\"uid\", 8), (\"gid\", 8), (\"size\", 12), (\"mtime\", 12)):\n            needs_pax = False\n\n            val = info[name]\n            val_is_float = isinstance(val, float)\n            val_int = round(val) if val_is_float else val\n            if not 0 <= val_int < 8 ** (digits - 1):\n                # Avoid overflow.\n                info[name] = 0\n                needs_pax = True\n            elif val_is_float:\n                # Put rounded value in ustar header, and full\n                # precision value in pax header.\n                info[name] = val_int\n                needs_pax = True\n\n            # The existing pax header has priority.\n            if needs_pax and name not in pax_headers:\n                pax_headers[name] = str(val)\n\n        # Create a pax extended header if necessary.\n        if pax_headers:\n            buf = self._create_pax_generic_header(pax_headers, XHDTYPE, encoding)\n        else:\n            buf = b\"\"\n\n        return buf + self._create_header(info, USTAR_FORMAT, \"ascii\", \"replace\")\n\n    @classmethod\n    def create_pax_global_header(cls, pax_headers):\n        \"\"\"Return the object as a pax global header block sequence.\n        \"\"\"\n        return cls._create_pax_generic_header(pax_headers, XGLTYPE, \"utf-8\")\n\n    def _posix_split_name(self, name, encoding, errors):\n        \"\"\"Split a name longer than 100 chars into a prefix\n           and a name part.\n        \"\"\"\n        components = name.split(\"/\")\n        for i in range(1, len(components)):\n            prefix = \"/\".join(components[:i])\n            name = \"/\".join(components[i:])\n            if len(prefix.encode(encoding, errors)) <= LENGTH_PREFIX and \\\n                    len(name.encode(encoding, errors)) <= LENGTH_NAME:\n                break\n        else:\n            raise ValueError(\"name is too long\")\n\n        return prefix, name\n\n    @staticmethod\n    def _create_header(info, format, encoding, errors):\n        \"\"\"Return a header block. info is a dictionary with file\n           information, format must be one of the *_FORMAT constants.\n        \"\"\"\n        has_device_fields = info.get(\"type\") in (CHRTYPE, BLKTYPE)\n        if has_device_fields:\n            devmajor = itn(info.get(\"devmajor\", 0), 8, format)\n            devminor = itn(info.get(\"devminor\", 0), 8, format)\n        else:\n            devmajor = stn(\"\", 8, encoding, errors)\n            devminor = stn(\"\", 8, encoding, errors)\n\n        # None values in metadata should cause ValueError.\n        # itn()/stn() do this for all fields except type.\n        filetype = info.get(\"type\", REGTYPE)\n        if filetype is None:\n            raise ValueError(\"TarInfo.type must not be None\")\n\n        parts = [\n            stn(info.get(\"name\", \"\"), 100, encoding, errors),\n            itn(info.get(\"mode\", 0) & 0o7777, 8, format),\n            itn(info.get(\"uid\", 0), 8, format),\n            itn(info.get(\"gid\", 0), 8, format),\n            itn(info.get(\"size\", 0), 12, format),\n            itn(info.get(\"mtime\", 0), 12, format),\n            b\"        \", # checksum field\n            filetype,\n            stn(info.get(\"linkname\", \"\"), 100, encoding, errors),\n            info.get(\"magic\", POSIX_MAGIC),\n            stn(info.get(\"uname\", \"\"), 32, encoding, errors),\n            stn(info.get(\"gname\", \"\"), 32, encoding, errors),\n            devmajor,\n            devminor,\n            stn(info.get(\"prefix\", \"\"), 155, encoding, errors)\n        ]\n\n        buf = struct.pack(\"%ds\" % BLOCKSIZE, b\"\".join(parts))\n        chksum = calc_chksums(buf[-BLOCKSIZE:])[0]\n        buf = buf[:-364] + bytes(\"%06o\\0\" % chksum, \"ascii\") + buf[-357:]\n        return buf\n\n    @staticmethod\n    def _create_payload(payload):\n        \"\"\"Return the string payload filled with zero bytes\n           up to the next 512 byte border.\n        \"\"\"\n        blocks, remainder = divmod(len(payload), BLOCKSIZE)\n        if remainder > 0:\n            payload += (BLOCKSIZE - remainder) * NUL\n        return payload\n\n    @classmethod\n    def _create_gnu_long_header(cls, name, type, encoding, errors):\n        \"\"\"Return a GNUTYPE_LONGNAME or GNUTYPE_LONGLINK sequence\n           for name.\n        \"\"\"\n        name = name.encode(encoding, errors) + NUL\n\n        info = {}\n        info[\"name\"] = \"././@LongLink\"\n        info[\"type\"] = type\n        info[\"size\"] = len(name)\n        info[\"magic\"] = GNU_MAGIC\n\n        # create extended header + name blocks.\n        return cls._create_header(info, USTAR_FORMAT, encoding, errors) + \\\n                cls._create_payload(name)\n\n    @classmethod\n    def _create_pax_generic_header(cls, pax_headers, type, encoding):\n        \"\"\"Return a POSIX.1-2008 extended or global header sequence\n           that contains a list of keyword, value pairs. The values\n           must be strings.\n        \"\"\"\n        # Check if one of the fields contains surrogate characters and thereby\n        # forces hdrcharset=BINARY, see _proc_pax() for more information.\n        binary = False\n        for keyword, value in pax_headers.items():\n            try:\n                value.encode(\"utf-8\", \"strict\")\n            except UnicodeEncodeError:\n                binary = True\n                break\n\n        records = b\"\"\n        if binary:\n            # Put the hdrcharset field at the beginning of the header.\n            records += b\"21 hdrcharset=BINARY\\n\"\n\n        for keyword, value in pax_headers.items():\n            keyword = keyword.encode(\"utf-8\")\n            if binary:\n                # Try to restore the original byte representation of 'value'.\n                # Needless to say, that the encoding must match the string.\n                value = value.encode(encoding, \"surrogateescape\")\n            else:\n                value = value.encode(\"utf-8\")\n\n            l = len(keyword) + len(value) + 3   # ' ' + '=' + '\\n'\n            n = p = 0\n            while True:\n                n = l + len(str(p))\n                if n == p:\n                    break\n                p = n\n            records += bytes(str(p), \"ascii\") + b\" \" + keyword + b\"=\" + value + b\"\\n\"\n\n        # We use a hardcoded \"././@PaxHeader\" name like star does\n        # instead of the one that POSIX recommends.\n        info = {}\n        info[\"name\"] = \"././@PaxHeader\"\n        info[\"type\"] = type\n        info[\"size\"] = len(records)\n        info[\"magic\"] = POSIX_MAGIC\n\n        # Create pax header + record blocks.\n        return cls._create_header(info, USTAR_FORMAT, \"ascii\", \"replace\") + \\\n                cls._create_payload(records)\n\n    @classmethod\n    def frombuf(cls, buf, encoding, errors):\n        \"\"\"Construct a TarInfo object from a 512 byte bytes object.\n        \"\"\"\n        if len(buf) == 0:\n            raise EmptyHeaderError(\"empty header\")\n        if len(buf) != BLOCKSIZE:\n            raise TruncatedHeaderError(\"truncated header\")\n        if buf.count(NUL) == BLOCKSIZE:\n            raise EOFHeaderError(\"end of file header\")\n\n        chksum = nti(buf[148:156])\n        if chksum not in calc_chksums(buf):\n            raise InvalidHeaderError(\"bad checksum\")\n\n        obj = cls()\n        obj.name = nts(buf[0:100], encoding, errors)\n        obj.mode = nti(buf[100:108])\n        obj.uid = nti(buf[108:116])\n        obj.gid = nti(buf[116:124])\n        obj.size = nti(buf[124:136])\n        obj.mtime = nti(buf[136:148])\n        obj.chksum = chksum\n        obj.type = buf[156:157]\n        obj.linkname = nts(buf[157:257], encoding, errors)\n        obj.uname = nts(buf[265:297], encoding, errors)\n        obj.gname = nts(buf[297:329], encoding, errors)\n        obj.devmajor = nti(buf[329:337])\n        obj.devminor = nti(buf[337:345])\n        prefix = nts(buf[345:500], encoding, errors)\n\n        # Old V7 tar format represents a directory as a regular\n        # file with a trailing slash.\n        if obj.type == AREGTYPE and obj.name.endswith(\"/\"):\n            obj.type = DIRTYPE\n\n        # The old GNU sparse format occupies some of the unused\n        # space in the buffer for up to 4 sparse structures.\n        # Save them for later processing in _proc_sparse().\n        if obj.type == GNUTYPE_SPARSE:\n            pos = 386\n            structs = []\n            for i in range(4):\n                try:\n                    offset = nti(buf[pos:pos + 12])\n                    numbytes = nti(buf[pos + 12:pos + 24])\n                except ValueError:\n                    break\n                structs.append((offset, numbytes))\n                pos += 24\n            isextended = bool(buf[482])\n            origsize = nti(buf[483:495])\n            obj._sparse_structs = (structs, isextended, origsize)\n\n        # Remove redundant slashes from directories.\n        if obj.isdir():\n            obj.name = obj.name.rstrip(\"/\")\n\n        # Reconstruct a ustar longname.\n        if prefix and obj.type not in GNU_TYPES:\n            obj.name = prefix + \"/\" + obj.name\n        return obj\n\n    @classmethod\n    def fromtarfile(cls, tarfile):\n        \"\"\"Return the next TarInfo object from TarFile object\n           tarfile.\n        \"\"\"\n        buf = tarfile.fileobj.read(BLOCKSIZE)\n        obj = cls.frombuf(buf, tarfile.encoding, tarfile.errors)\n        obj.offset = tarfile.fileobj.tell() - BLOCKSIZE\n        return obj._proc_member(tarfile)\n\n    #--------------------------------------------------------------------------\n    # The following are methods that are called depending on the type of a\n    # member. The entry point is _proc_member() which can be overridden in a\n    # subclass to add custom _proc_*() methods. A _proc_*() method MUST\n    # implement the following\n    # operations:\n    # 1. Set self.offset_data to the position where the data blocks begin,\n    #    if there is data that follows.\n    # 2. Set tarfile.offset to the position where the next member's header will\n    #    begin.\n    # 3. Return self or another valid TarInfo object.\n    def _proc_member(self, tarfile):\n        \"\"\"Choose the right processing method depending on\n           the type and call it.\n        \"\"\"\n        if self.type in (GNUTYPE_LONGNAME, GNUTYPE_LONGLINK):\n            return self._proc_gnulong(tarfile)\n        elif self.type == GNUTYPE_SPARSE:\n            return self._proc_sparse(tarfile)\n        elif self.type in (XHDTYPE, XGLTYPE, SOLARIS_XHDTYPE):\n            return self._proc_pax(tarfile)\n        else:\n            return self._proc_builtin(tarfile)\n\n    def _proc_builtin(self, tarfile):\n        \"\"\"Process a builtin type or an unknown type which\n           will be treated as a regular file.\n        \"\"\"\n        self.offset_data = tarfile.fileobj.tell()\n        offset = self.offset_data\n        if self.isreg() or self.type not in SUPPORTED_TYPES:\n            # Skip the following data blocks.\n            offset += self._block(self.size)\n        tarfile.offset = offset\n\n        # Patch the TarInfo object with saved global\n        # header information.\n        self._apply_pax_info(tarfile.pax_headers, tarfile.encoding, tarfile.errors)\n\n        # Remove redundant slashes from directories. This is to be consistent\n        # with frombuf().\n        if self.isdir():\n            self.name = self.name.rstrip(\"/\")\n\n        return self\n\n    def _proc_gnulong(self, tarfile):\n        \"\"\"Process the blocks that hold a GNU longname\n           or longlink member.\n        \"\"\"\n        buf = tarfile.fileobj.read(self._block(self.size))\n\n        # Fetch the next header and process it.\n        try:\n            next = self.fromtarfile(tarfile)\n        except HeaderError as e:\n            raise SubsequentHeaderError(str(e)) from None\n\n        # Patch the TarInfo object from the next header with\n        # the longname information.\n        next.offset = self.offset\n        if self.type == GNUTYPE_LONGNAME:\n            next.name = nts(buf, tarfile.encoding, tarfile.errors)\n        elif self.type == GNUTYPE_LONGLINK:\n            next.linkname = nts(buf, tarfile.encoding, tarfile.errors)\n\n        # Remove redundant slashes from directories. This is to be consistent\n        # with frombuf().\n        if next.isdir():\n            next.name = removesuffix(next.name, \"/\")\n\n        return next\n\n    def _proc_sparse(self, tarfile):\n        \"\"\"Process a GNU sparse header plus extra headers.\n        \"\"\"\n        # We already collected some sparse structures in frombuf().\n        structs, isextended, origsize = self._sparse_structs\n        del self._sparse_structs\n\n        # Collect sparse structures from extended header blocks.\n        while isextended:\n            buf = tarfile.fileobj.read(BLOCKSIZE)\n            pos = 0\n            for i in range(21):\n                try:\n                    offset = nti(buf[pos:pos + 12])\n                    numbytes = nti(buf[pos + 12:pos + 24])\n                except ValueError:\n                    break\n                if offset and numbytes:\n                    structs.append((offset, numbytes))\n                pos += 24\n            isextended = bool(buf[504])\n        self.sparse = structs\n\n        self.offset_data = tarfile.fileobj.tell()\n        tarfile.offset = self.offset_data + self._block(self.size)\n        self.size = origsize\n        return self\n\n    def _proc_pax(self, tarfile):\n        \"\"\"Process an extended or global header as described in\n           POSIX.1-2008.\n        \"\"\"\n        # Read the header information.\n        buf = tarfile.fileobj.read(self._block(self.size))\n\n        # A pax header stores supplemental information for either\n        # the following file (extended) or all following files\n        # (global).\n        if self.type == XGLTYPE:\n            pax_headers = tarfile.pax_headers\n        else:\n            pax_headers = tarfile.pax_headers.copy()\n\n        # Check if the pax header contains a hdrcharset field. This tells us\n        # the encoding of the path, linkpath, uname and gname fields. Normally,\n        # these fields are UTF-8 encoded but since POSIX.1-2008 tar\n        # implementations are allowed to store them as raw binary strings if\n        # the translation to UTF-8 fails.\n        match = re.search(br\"\\d+ hdrcharset=([^\\n]+)\\n\", buf)\n        if match is not None:\n            pax_headers[\"hdrcharset\"] = match.group(1).decode(\"utf-8\")\n\n        # For the time being, we don't care about anything other than \"BINARY\".\n        # The only other value that is currently allowed by the standard is\n        # \"ISO-IR 10646 2000 UTF-8\" in other words UTF-8.\n        hdrcharset = pax_headers.get(\"hdrcharset\")\n        if hdrcharset == \"BINARY\":\n            encoding = tarfile.encoding\n        else:\n            encoding = \"utf-8\"\n\n        # Parse pax header information. A record looks like that:\n        # \"%d %s=%s\\n\" % (length, keyword, value). length is the size\n        # of the complete record including the length field itself and\n        # the newline. keyword and value are both UTF-8 encoded strings.\n        regex = re.compile(br\"(\\d+) ([^=]+)=\")\n        pos = 0\n        while match := regex.match(buf, pos):\n            length, keyword = match.groups()\n            length = int(length)\n            if length == 0:\n                raise InvalidHeaderError(\"invalid header\")\n            value = buf[match.end(2) + 1:match.start(1) + length - 1]\n\n            # Normally, we could just use \"utf-8\" as the encoding and \"strict\"\n            # as the error handler, but we better not take the risk. For\n            # example, GNU tar <= 1.23 is known to store filenames it cannot\n            # translate to UTF-8 as raw strings (unfortunately without a\n            # hdrcharset=BINARY header).\n            # We first try the strict standard encoding, and if that fails we\n            # fall back on the user's encoding and error handler.\n            keyword = self._decode_pax_field(keyword, \"utf-8\", \"utf-8\",\n                    tarfile.errors)\n            if keyword in PAX_NAME_FIELDS:\n                value = self._decode_pax_field(value, encoding, tarfile.encoding,\n                        tarfile.errors)\n            else:\n                value = self._decode_pax_field(value, \"utf-8\", \"utf-8\",\n                        tarfile.errors)\n\n            pax_headers[keyword] = value\n            pos += length\n\n        # Fetch the next header.\n        try:\n            next = self.fromtarfile(tarfile)\n        except HeaderError as e:\n            raise SubsequentHeaderError(str(e)) from None\n\n        # Process GNU sparse information.\n        if \"GNU.sparse.map\" in pax_headers:\n            # GNU extended sparse format version 0.1.\n            self._proc_gnusparse_01(next, pax_headers)\n\n        elif \"GNU.sparse.size\" in pax_headers:\n            # GNU extended sparse format version 0.0.\n            self._proc_gnusparse_00(next, pax_headers, buf)\n\n        elif pax_headers.get(\"GNU.sparse.major\") == \"1\" and pax_headers.get(\"GNU.sparse.minor\") == \"0\":\n            # GNU extended sparse format version 1.0.\n            self._proc_gnusparse_10(next, pax_headers, tarfile)\n\n        if self.type in (XHDTYPE, SOLARIS_XHDTYPE):\n            # Patch the TarInfo object with the extended header info.\n            next._apply_pax_info(pax_headers, tarfile.encoding, tarfile.errors)\n            next.offset = self.offset\n\n            if \"size\" in pax_headers:\n                # If the extended header replaces the size field,\n                # we need to recalculate the offset where the next\n                # header starts.\n                offset = next.offset_data\n                if next.isreg() or next.type not in SUPPORTED_TYPES:\n                    offset += next._block(next.size)\n                tarfile.offset = offset\n\n        return next\n\n    def _proc_gnusparse_00(self, next, pax_headers, buf):\n        \"\"\"Process a GNU tar extended sparse header, version 0.0.\n        \"\"\"\n        offsets = []\n        for match in re.finditer(br\"\\d+ GNU.sparse.offset=(\\d+)\\n\", buf):\n            offsets.append(int(match.group(1)))\n        numbytes = []\n        for match in re.finditer(br\"\\d+ GNU.sparse.numbytes=(\\d+)\\n\", buf):\n            numbytes.append(int(match.group(1)))\n        next.sparse = list(zip(offsets, numbytes))\n\n    def _proc_gnusparse_01(self, next, pax_headers):\n        \"\"\"Process a GNU tar extended sparse header, version 0.1.\n        \"\"\"\n        sparse = [int(x) for x in pax_headers[\"GNU.sparse.map\"].split(\",\")]\n        next.sparse = list(zip(sparse[::2], sparse[1::2]))\n\n    def _proc_gnusparse_10(self, next, pax_headers, tarfile):\n        \"\"\"Process a GNU tar extended sparse header, version 1.0.\n        \"\"\"\n        fields = None\n        sparse = []\n        buf = tarfile.fileobj.read(BLOCKSIZE)\n        fields, buf = buf.split(b\"\\n\", 1)\n        fields = int(fields)\n        while len(sparse) < fields * 2:\n            if b\"\\n\" not in buf:\n                buf += tarfile.fileobj.read(BLOCKSIZE)\n            number, buf = buf.split(b\"\\n\", 1)\n            sparse.append(int(number))\n        next.offset_data = tarfile.fileobj.tell()\n        next.sparse = list(zip(sparse[::2], sparse[1::2]))\n\n    def _apply_pax_info(self, pax_headers, encoding, errors):\n        \"\"\"Replace fields with supplemental information from a previous\n           pax extended or global header.\n        \"\"\"\n        for keyword, value in pax_headers.items():\n            if keyword == \"GNU.sparse.name\":\n                setattr(self, \"path\", value)\n            elif keyword == \"GNU.sparse.size\":\n                setattr(self, \"size\", int(value))\n            elif keyword == \"GNU.sparse.realsize\":\n                setattr(self, \"size\", int(value))\n            elif keyword in PAX_FIELDS:\n                if keyword in PAX_NUMBER_FIELDS:\n                    try:\n                        value = PAX_NUMBER_FIELDS[keyword](value)\n                    except ValueError:\n                        value = 0\n                if keyword == \"path\":\n                    value = value.rstrip(\"/\")\n                setattr(self, keyword, value)\n\n        self.pax_headers = pax_headers.copy()\n\n    def _decode_pax_field(self, value, encoding, fallback_encoding, fallback_errors):\n        \"\"\"Decode a single field from a pax record.\n        \"\"\"\n        try:\n            return value.decode(encoding, \"strict\")\n        except UnicodeDecodeError:\n            return value.decode(fallback_encoding, fallback_errors)\n\n    def _block(self, count):\n        \"\"\"Round up a byte count by BLOCKSIZE and return it,\n           e.g. _block(834) => 1024.\n        \"\"\"\n        blocks, remainder = divmod(count, BLOCKSIZE)\n        if remainder:\n            blocks += 1\n        return blocks * BLOCKSIZE\n\n    def isreg(self):\n        'Return True if the Tarinfo object is a regular file.'\n        return self.type in REGULAR_TYPES\n\n    def isfile(self):\n        'Return True if the Tarinfo object is a regular file.'\n        return self.isreg()\n\n    def isdir(self):\n        'Return True if it is a directory.'\n        return self.type == DIRTYPE\n\n    def issym(self):\n        'Return True if it is a symbolic link.'\n        return self.type == SYMTYPE\n\n    def islnk(self):\n        'Return True if it is a hard link.'\n        return self.type == LNKTYPE\n\n    def ischr(self):\n        'Return True if it is a character device.'\n        return self.type == CHRTYPE\n\n    def isblk(self):\n        'Return True if it is a block device.'\n        return self.type == BLKTYPE\n\n    def isfifo(self):\n        'Return True if it is a FIFO.'\n        return self.type == FIFOTYPE\n\n    def issparse(self):\n        return self.sparse is not None\n\n    def isdev(self):\n        'Return True if it is one of character device, block device or FIFO.'\n        return self.type in (CHRTYPE, BLKTYPE, FIFOTYPE)\n# class TarInfo\n\nclass TarFile(object):\n    \"\"\"The TarFile Class provides an interface to tar archives.\n    \"\"\"\n\n    debug = 0                   # May be set from 0 (no msgs) to 3 (all msgs)\n\n    dereference = False         # If true, add content of linked file to the\n                                # tar file, else the link.\n\n    ignore_zeros = False        # If true, skips empty or invalid blocks and\n                                # continues processing.\n\n    errorlevel = 1              # If 0, fatal errors only appear in debug\n                                # messages (if debug >= 0). If > 0, errors\n                                # are passed to the caller as exceptions.\n\n    format = DEFAULT_FORMAT     # The format to use when creating an archive.\n\n    encoding = ENCODING         # Encoding for 8-bit character strings.\n\n    errors = None               # Error handler for unicode conversion.\n\n    tarinfo = TarInfo           # The default TarInfo class to use.\n\n    fileobject = ExFileObject   # The file-object for extractfile().\n\n    extraction_filter = None    # The default filter for extraction.\n\n    def __init__(self, name=None, mode=\"r\", fileobj=None, format=None,\n            tarinfo=None, dereference=None, ignore_zeros=None, encoding=None,\n            errors=\"surrogateescape\", pax_headers=None, debug=None,\n            errorlevel=None, copybufsize=None, stream=False):\n        \"\"\"Open an (uncompressed) tar archive 'name'. 'mode' is either 'r' to\n           read from an existing archive, 'a' to append data to an existing\n           file or 'w' to create a new file overwriting an existing one. 'mode'\n           defaults to 'r'.\n           If 'fileobj' is given, it is used for reading or writing data. If it\n           can be determined, 'mode' is overridden by 'fileobj's mode.\n           'fileobj' is not closed, when TarFile is closed.\n        \"\"\"\n        modes = {\"r\": \"rb\", \"a\": \"r+b\", \"w\": \"wb\", \"x\": \"xb\"}\n        if mode not in modes:\n            raise ValueError(\"mode must be 'r', 'a', 'w' or 'x'\")\n        self.mode = mode\n        self._mode = modes[mode]\n\n        if not fileobj:\n            if self.mode == \"a\" and not os.path.exists(name):\n                # Create nonexistent files in append mode.\n                self.mode = \"w\"\n                self._mode = \"wb\"\n            fileobj = bltn_open(name, self._mode)\n            self._extfileobj = False\n        else:\n            if (name is None and hasattr(fileobj, \"name\") and\n                isinstance(fileobj.name, (str, bytes))):\n                name = fileobj.name\n            if hasattr(fileobj, \"mode\"):\n                self._mode = fileobj.mode\n            self._extfileobj = True\n        self.name = os.path.abspath(name) if name else None\n        self.fileobj = fileobj\n\n        self.stream = stream\n\n        # Init attributes.\n        if format is not None:\n            self.format = format\n        if tarinfo is not None:\n            self.tarinfo = tarinfo\n        if dereference is not None:\n            self.dereference = dereference\n        if ignore_zeros is not None:\n            self.ignore_zeros = ignore_zeros\n        if encoding is not None:\n            self.encoding = encoding\n        self.errors = errors\n\n        if pax_headers is not None and self.format == PAX_FORMAT:\n            self.pax_headers = pax_headers\n        else:\n            self.pax_headers = {}\n\n        if debug is not None:\n            self.debug = debug\n        if errorlevel is not None:\n            self.errorlevel = errorlevel\n\n        # Init datastructures.\n        self.copybufsize = copybufsize\n        self.closed = False\n        self.members = []       # list of members as TarInfo objects\n        self._loaded = False    # flag if all members have been read\n        self.offset = self.fileobj.tell()\n                                # current position in the archive file\n        self.inodes = {}        # dictionary caching the inodes of\n                                # archive members already added\n\n        try:\n            if self.mode == \"r\":\n                self.firstmember = None\n                self.firstmember = self.next()\n\n            if self.mode == \"a\":\n                # Move to the end of the archive,\n                # before the first empty block.\n                while True:\n                    self.fileobj.seek(self.offset)\n                    try:\n                        tarinfo = self.tarinfo.fromtarfile(self)\n                        self.members.append(tarinfo)\n                    except EOFHeaderError:\n                        self.fileobj.seek(self.offset)\n                        break\n                    except HeaderError as e:\n                        raise ReadError(str(e)) from None\n\n            if self.mode in (\"a\", \"w\", \"x\"):\n                self._loaded = True\n\n                if self.pax_headers:\n                    buf = self.tarinfo.create_pax_global_header(self.pax_headers.copy())\n                    self.fileobj.write(buf)\n                    self.offset += len(buf)\n        except:\n            if not self._extfileobj:\n                self.fileobj.close()\n            self.closed = True\n            raise\n\n    #--------------------------------------------------------------------------\n    # Below are the classmethods which act as alternate constructors to the\n    # TarFile class. The open() method is the only one that is needed for\n    # public use; it is the \"super\"-constructor and is able to select an\n    # adequate \"sub\"-constructor for a particular compression using the mapping\n    # from OPEN_METH.\n    #\n    # This concept allows one to subclass TarFile without losing the comfort of\n    # the super-constructor. A sub-constructor is registered and made available\n    # by adding it to the mapping in OPEN_METH.\n\n    @classmethod\n    def open(cls, name=None, mode=\"r\", fileobj=None, bufsize=RECORDSIZE, **kwargs):\n        r\"\"\"Open a tar archive for reading, writing or appending. Return\n           an appropriate TarFile class.\n\n           mode:\n           'r' or 'r:\\*' open for reading with transparent compression\n           'r:'         open for reading exclusively uncompressed\n           'r:gz'       open for reading with gzip compression\n           'r:bz2'      open for reading with bzip2 compression\n           'r:xz'       open for reading with lzma compression\n           'a' or 'a:'  open for appending, creating the file if necessary\n           'w' or 'w:'  open for writing without compression\n           'w:gz'       open for writing with gzip compression\n           'w:bz2'      open for writing with bzip2 compression\n           'w:xz'       open for writing with lzma compression\n\n           'x' or 'x:'  create a tarfile exclusively without compression, raise\n                        an exception if the file is already created\n           'x:gz'       create a gzip compressed tarfile, raise an exception\n                        if the file is already created\n           'x:bz2'      create a bzip2 compressed tarfile, raise an exception\n                        if the file is already created\n           'x:xz'       create an lzma compressed tarfile, raise an exception\n                        if the file is already created\n\n           'r|\\*'        open a stream of tar blocks with transparent compression\n           'r|'         open an uncompressed stream of tar blocks for reading\n           'r|gz'       open a gzip compressed stream of tar blocks\n           'r|bz2'      open a bzip2 compressed stream of tar blocks\n           'r|xz'       open an lzma compressed stream of tar blocks\n           'w|'         open an uncompressed stream for writing\n           'w|gz'       open a gzip compressed stream for writing\n           'w|bz2'      open a bzip2 compressed stream for writing\n           'w|xz'       open an lzma compressed stream for writing\n        \"\"\"\n\n        if not name and not fileobj:\n            raise ValueError(\"nothing to open\")\n\n        if mode in (\"r\", \"r:*\"):\n            # Find out which *open() is appropriate for opening the file.\n            def not_compressed(comptype):\n                return cls.OPEN_METH[comptype] == 'taropen'\n            error_msgs = []\n            for comptype in sorted(cls.OPEN_METH, key=not_compressed):\n                func = getattr(cls, cls.OPEN_METH[comptype])\n                if fileobj is not None:\n                    saved_pos = fileobj.tell()\n                try:\n                    return func(name, \"r\", fileobj, **kwargs)\n                except (ReadError, CompressionError) as e:\n                    error_msgs.append(f'- method {comptype}: {e!r}')\n                    if fileobj is not None:\n                        fileobj.seek(saved_pos)\n                    continue\n            error_msgs_summary = '\\n'.join(error_msgs)\n            raise ReadError(f\"file could not be opened successfully:\\n{error_msgs_summary}\")\n\n        elif \":\" in mode:\n            filemode, comptype = mode.split(\":\", 1)\n            filemode = filemode or \"r\"\n            comptype = comptype or \"tar\"\n\n            # Select the *open() function according to\n            # given compression.\n            if comptype in cls.OPEN_METH:\n                func = getattr(cls, cls.OPEN_METH[comptype])\n            else:\n                raise CompressionError(\"unknown compression type %r\" % comptype)\n            return func(name, filemode, fileobj, **kwargs)\n\n        elif \"|\" in mode:\n            filemode, comptype = mode.split(\"|\", 1)\n            filemode = filemode or \"r\"\n            comptype = comptype or \"tar\"\n\n            if filemode not in (\"r\", \"w\"):\n                raise ValueError(\"mode must be 'r' or 'w'\")\n\n            compresslevel = kwargs.pop(\"compresslevel\", 9)\n            stream = _Stream(name, filemode, comptype, fileobj, bufsize,\n                             compresslevel)\n            try:\n                t = cls(name, filemode, stream, **kwargs)\n            except:\n                stream.close()\n                raise\n            t._extfileobj = False\n            return t\n\n        elif mode in (\"a\", \"w\", \"x\"):\n            return cls.taropen(name, mode, fileobj, **kwargs)\n\n        raise ValueError(\"undiscernible mode\")\n\n    @classmethod\n    def taropen(cls, name, mode=\"r\", fileobj=None, **kwargs):\n        \"\"\"Open uncompressed tar archive name for reading or writing.\n        \"\"\"\n        if mode not in (\"r\", \"a\", \"w\", \"x\"):\n            raise ValueError(\"mode must be 'r', 'a', 'w' or 'x'\")\n        return cls(name, mode, fileobj, **kwargs)\n\n    @classmethod\n    def gzopen(cls, name, mode=\"r\", fileobj=None, compresslevel=9, **kwargs):\n        \"\"\"Open gzip compressed tar archive name for reading or writing.\n           Appending is not allowed.\n        \"\"\"\n        if mode not in (\"r\", \"w\", \"x\"):\n            raise ValueError(\"mode must be 'r', 'w' or 'x'\")\n\n        try:\n            from gzip import GzipFile\n        except ImportError:\n            raise CompressionError(\"gzip module is not available\") from None\n\n        try:\n            fileobj = GzipFile(name, mode + \"b\", compresslevel, fileobj)\n        except OSError as e:\n            if fileobj is not None and mode == 'r':\n                raise ReadError(\"not a gzip file\") from e\n            raise\n\n        try:\n            t = cls.taropen(name, mode, fileobj, **kwargs)\n        except OSError as e:\n            fileobj.close()\n            if mode == 'r':\n                raise ReadError(\"not a gzip file\") from e\n            raise\n        except:\n            fileobj.close()\n            raise\n        t._extfileobj = False\n        return t\n\n    @classmethod\n    def bz2open(cls, name, mode=\"r\", fileobj=None, compresslevel=9, **kwargs):\n        \"\"\"Open bzip2 compressed tar archive name for reading or writing.\n           Appending is not allowed.\n        \"\"\"\n        if mode not in (\"r\", \"w\", \"x\"):\n            raise ValueError(\"mode must be 'r', 'w' or 'x'\")\n\n        try:\n            from bz2 import BZ2File\n        except ImportError:\n            raise CompressionError(\"bz2 module is not available\") from None\n\n        fileobj = BZ2File(fileobj or name, mode, compresslevel=compresslevel)\n\n        try:\n            t = cls.taropen(name, mode, fileobj, **kwargs)\n        except (OSError, EOFError) as e:\n            fileobj.close()\n            if mode == 'r':\n                raise ReadError(\"not a bzip2 file\") from e\n            raise\n        except:\n            fileobj.close()\n            raise\n        t._extfileobj = False\n        return t\n\n    @classmethod\n    def xzopen(cls, name, mode=\"r\", fileobj=None, preset=None, **kwargs):\n        \"\"\"Open lzma compressed tar archive name for reading or writing.\n           Appending is not allowed.\n        \"\"\"\n        if mode not in (\"r\", \"w\", \"x\"):\n            raise ValueError(\"mode must be 'r', 'w' or 'x'\")\n\n        try:\n            from lzma import LZMAFile, LZMAError\n        except ImportError:\n            raise CompressionError(\"lzma module is not available\") from None\n\n        fileobj = LZMAFile(fileobj or name, mode, preset=preset)\n\n        try:\n            t = cls.taropen(name, mode, fileobj, **kwargs)\n        except (LZMAError, EOFError) as e:\n            fileobj.close()\n            if mode == 'r':\n                raise ReadError(\"not an lzma file\") from e\n            raise\n        except:\n            fileobj.close()\n            raise\n        t._extfileobj = False\n        return t\n\n    # All *open() methods are registered here.\n    OPEN_METH = {\n        \"tar\": \"taropen\",   # uncompressed tar\n        \"gz\":  \"gzopen\",    # gzip compressed tar\n        \"bz2\": \"bz2open\",   # bzip2 compressed tar\n        \"xz\":  \"xzopen\"     # lzma compressed tar\n    }\n\n    #--------------------------------------------------------------------------\n    # The public methods which TarFile provides:\n\n    def close(self):\n        \"\"\"Close the TarFile. In write-mode, two finishing zero blocks are\n           appended to the archive.\n        \"\"\"\n        if self.closed:\n            return\n\n        self.closed = True\n        try:\n            if self.mode in (\"a\", \"w\", \"x\"):\n                self.fileobj.write(NUL * (BLOCKSIZE * 2))\n                self.offset += (BLOCKSIZE * 2)\n                # fill up the end with zero-blocks\n                # (like option -b20 for tar does)\n                blocks, remainder = divmod(self.offset, RECORDSIZE)\n                if remainder > 0:\n                    self.fileobj.write(NUL * (RECORDSIZE - remainder))\n        finally:\n            if not self._extfileobj:\n                self.fileobj.close()\n\n    def getmember(self, name):\n        \"\"\"Return a TarInfo object for member 'name'. If 'name' can not be\n           found in the archive, KeyError is raised. If a member occurs more\n           than once in the archive, its last occurrence is assumed to be the\n           most up-to-date version.\n        \"\"\"\n        tarinfo = self._getmember(name.rstrip('/'))\n        if tarinfo is None:\n            raise KeyError(\"filename %r not found\" % name)\n        return tarinfo\n\n    def getmembers(self):\n        \"\"\"Return the members of the archive as a list of TarInfo objects. The\n           list has the same order as the members in the archive.\n        \"\"\"\n        self._check()\n        if not self._loaded:    # if we want to obtain a list of\n            self._load()        # all members, we first have to\n                                # scan the whole archive.\n        return self.members\n\n    def getnames(self):\n        \"\"\"Return the members of the archive as a list of their names. It has\n           the same order as the list returned by getmembers().\n        \"\"\"\n        return [tarinfo.name for tarinfo in self.getmembers()]\n\n    def gettarinfo(self, name=None, arcname=None, fileobj=None):\n        \"\"\"Create a TarInfo object from the result of os.stat or equivalent\n           on an existing file. The file is either named by 'name', or\n           specified as a file object 'fileobj' with a file descriptor. If\n           given, 'arcname' specifies an alternative name for the file in the\n           archive, otherwise, the name is taken from the 'name' attribute of\n           'fileobj', or the 'name' argument. The name should be a text\n           string.\n        \"\"\"\n        self._check(\"awx\")\n\n        # When fileobj is given, replace name by\n        # fileobj's real name.\n        if fileobj is not None:\n            name = fileobj.name\n\n        # Building the name of the member in the archive.\n        # Backward slashes are converted to forward slashes,\n        # Absolute paths are turned to relative paths.\n        if arcname is None:\n            arcname = name\n        drv, arcname = os.path.splitdrive(arcname)\n        arcname = arcname.replace(os.sep, \"/\")\n        arcname = arcname.lstrip(\"/\")\n\n        # Now, fill the TarInfo object with\n        # information specific for the file.\n        tarinfo = self.tarinfo()\n        tarinfo._tarfile = self  # To be removed in 3.16.\n\n        # Use os.stat or os.lstat, depending on if symlinks shall be resolved.\n        if fileobj is None:\n            if not self.dereference:\n                statres = os.lstat(name)\n            else:\n                statres = os.stat(name)\n        else:\n            statres = os.fstat(fileobj.fileno())\n        linkname = \"\"\n\n        stmd = statres.st_mode\n        if stat.S_ISREG(stmd):\n            inode = (statres.st_ino, statres.st_dev)\n            if not self.dereference and statres.st_nlink > 1 and \\\n                    inode in self.inodes and arcname != self.inodes[inode]:\n                # Is it a hardlink to an already\n                # archived file?\n                type = LNKTYPE\n                linkname = self.inodes[inode]\n            else:\n                # The inode is added only if its valid.\n                # For win32 it is always 0.\n                type = REGTYPE\n                if inode[0]:\n                    self.inodes[inode] = arcname\n        elif stat.S_ISDIR(stmd):\n            type = DIRTYPE\n        elif stat.S_ISFIFO(stmd):\n            type = FIFOTYPE\n        elif stat.S_ISLNK(stmd):\n            type = SYMTYPE\n            linkname = os.readlink(name)\n        elif stat.S_ISCHR(stmd):\n            type = CHRTYPE\n        elif stat.S_ISBLK(stmd):\n            type = BLKTYPE\n        else:\n            return None\n\n        # Fill the TarInfo object with all\n        # information we can get.\n        tarinfo.name = arcname\n        tarinfo.mode = stmd\n        tarinfo.uid = statres.st_uid\n        tarinfo.gid = statres.st_gid\n        if type == REGTYPE:\n            tarinfo.size = statres.st_size\n        else:\n            tarinfo.size = 0\n        tarinfo.mtime = statres.st_mtime\n        tarinfo.type = type\n        tarinfo.linkname = linkname\n        if pwd:\n            try:\n                tarinfo.uname = pwd.getpwuid(tarinfo.uid)[0]\n            except KeyError:\n                pass\n        if grp:\n            try:\n                tarinfo.gname = grp.getgrgid(tarinfo.gid)[0]\n            except KeyError:\n                pass\n\n        if type in (CHRTYPE, BLKTYPE):\n            if hasattr(os, \"major\") and hasattr(os, \"minor\"):\n                tarinfo.devmajor = os.major(statres.st_rdev)\n                tarinfo.devminor = os.minor(statres.st_rdev)\n        return tarinfo\n\n    def list(self, verbose=True, *, members=None):\n        \"\"\"Print a table of contents to sys.stdout. If 'verbose' is False, only\n           the names of the members are printed. If it is True, an 'ls -l'-like\n           output is produced. 'members' is optional and must be a subset of the\n           list returned by getmembers().\n        \"\"\"\n        # Convert tarinfo type to stat type.\n        type2mode = {REGTYPE: stat.S_IFREG, SYMTYPE: stat.S_IFLNK,\n                     FIFOTYPE: stat.S_IFIFO, CHRTYPE: stat.S_IFCHR,\n                     DIRTYPE: stat.S_IFDIR, BLKTYPE: stat.S_IFBLK}\n        self._check()\n\n        if members is None:\n            members = self\n        for tarinfo in members:\n            if verbose:\n                if tarinfo.mode is None:\n                    _safe_print(\"??????????\")\n                else:\n                    modetype = type2mode.get(tarinfo.type, 0)\n                    _safe_print(stat.filemode(modetype | tarinfo.mode))\n                _safe_print(\"%s/%s\" % (tarinfo.uname or tarinfo.uid,\n                                       tarinfo.gname or tarinfo.gid))\n                if tarinfo.ischr() or tarinfo.isblk():\n                    _safe_print(\"%10s\" %\n                            (\"%d,%d\" % (tarinfo.devmajor, tarinfo.devminor)))\n                else:\n                    _safe_print(\"%10d\" % tarinfo.size)\n                if tarinfo.mtime is None:\n                    _safe_print(\"????-??-?? ??:??:??\")\n                else:\n                    _safe_print(\"%d-%02d-%02d %02d:%02d:%02d\" \\\n                                % time.localtime(tarinfo.mtime)[:6])\n\n            _safe_print(tarinfo.name + (\"/\" if tarinfo.isdir() else \"\"))\n\n            if verbose:\n                if tarinfo.issym():\n                    _safe_print(\"-> \" + tarinfo.linkname)\n                if tarinfo.islnk():\n                    _safe_print(\"link to \" + tarinfo.linkname)\n            print()\n\n    def add(self, name, arcname=None, recursive=True, *, filter=None):\n        \"\"\"Add the file 'name' to the archive. 'name' may be any type of file\n           (directory, fifo, symbolic link, etc.). If given, 'arcname'\n           specifies an alternative name for the file in the archive.\n           Directories are added recursively by default. This can be avoided by\n           setting 'recursive' to False. 'filter' is a function\n           that expects a TarInfo object argument and returns the changed\n           TarInfo object, if it returns None the TarInfo object will be\n           excluded from the archive.\n        \"\"\"\n        self._check(\"awx\")\n\n        if arcname is None:\n            arcname = name\n\n        # Skip if somebody tries to archive the archive...\n        if self.name is not None and os.path.abspath(name) == self.name:\n            self._dbg(2, \"tarfile: Skipped %r\" % name)\n            return\n\n        self._dbg(1, name)\n\n        # Create a TarInfo object from the file.\n        tarinfo = self.gettarinfo(name, arcname)\n\n        if tarinfo is None:\n            self._dbg(1, \"tarfile: Unsupported type %r\" % name)\n            return\n\n        # Change or exclude the TarInfo object.\n        if filter is not None:\n            tarinfo = filter(tarinfo)\n            if tarinfo is None:\n                self._dbg(2, \"tarfile: Excluded %r\" % name)\n                return\n\n        # Append the tar header and data to the archive.\n        if tarinfo.isreg():\n            with bltn_open(name, \"rb\") as f:\n                self.addfile(tarinfo, f)\n\n        elif tarinfo.isdir():\n            self.addfile(tarinfo)\n            if recursive:\n                for f in sorted(os.listdir(name)):\n                    self.add(os.path.join(name, f), os.path.join(arcname, f),\n                            recursive, filter=filter)\n\n        else:\n            self.addfile(tarinfo)\n\n    def addfile(self, tarinfo, fileobj=None):\n        \"\"\"Add the TarInfo object 'tarinfo' to the archive. If 'tarinfo' represents\n           a non zero-size regular file, the 'fileobj' argument should be a binary file,\n           and tarinfo.size bytes are read from it and added to the archive.\n           You can create TarInfo objects directly, or by using gettarinfo().\n        \"\"\"\n        self._check(\"awx\")\n\n        if fileobj is None and tarinfo.isreg() and tarinfo.size != 0:\n            raise ValueError(\"fileobj not provided for non zero-size regular file\")\n\n        tarinfo = copy.copy(tarinfo)\n\n        buf = tarinfo.tobuf(self.format, self.encoding, self.errors)\n        self.fileobj.write(buf)\n        self.offset += len(buf)\n        bufsize=self.copybufsize\n        # If there's data to follow, append it.\n        if fileobj is not None:\n            copyfileobj(fileobj, self.fileobj, tarinfo.size, bufsize=bufsize)\n            blocks, remainder = divmod(tarinfo.size, BLOCKSIZE)\n            if remainder > 0:\n                self.fileobj.write(NUL * (BLOCKSIZE - remainder))\n                blocks += 1\n            self.offset += blocks * BLOCKSIZE\n\n        self.members.append(tarinfo)\n\n    def _get_filter_function(self, filter):\n        if filter is None:\n            filter = self.extraction_filter\n            if filter is None:\n                import warnings\n                warnings.warn(\n                    'Python 3.14 will, by default, filter extracted tar '\n                    + 'archives and reject files or modify their metadata. '\n                    + 'Use the filter argument to control this behavior.',\n                    DeprecationWarning, stacklevel=3)\n                return fully_trusted_filter\n            if isinstance(filter, str):\n                raise TypeError(\n                    'String names are not supported for '\n                    + 'TarFile.extraction_filter. Use a function such as '\n                    + 'tarfile.data_filter directly.')\n            return filter\n        if callable(filter):\n            return filter\n        try:\n            return _NAMED_FILTERS[filter]\n        except KeyError:\n            raise ValueError(f\"filter {filter!r} not found\") from None\n\n    def extractall(self, path=\".\", members=None, *, numeric_owner=False,\n                   filter=None):\n        \"\"\"Extract all members from the archive to the current working\n           directory and set owner, modification time and permissions on\n           directories afterwards. 'path' specifies a different directory\n           to extract to. 'members' is optional and must be a subset of the\n           list returned by getmembers(). If 'numeric_owner' is True, only\n           the numbers for user/group names are used and not the names.\n\n           The 'filter' function will be called on each member just\n           before extraction.\n           It can return a changed TarInfo or None to skip the member.\n           String names of common filters are accepted.\n        \"\"\"\n        directories = []\n\n        filter_function = self._get_filter_function(filter)\n        if members is None:\n            members = self\n\n        for member in members:\n            tarinfo = self._get_extract_tarinfo(member, filter_function, path)\n            if tarinfo is None:\n                continue\n            if tarinfo.isdir():\n                # For directories, delay setting attributes until later,\n                # since permissions can interfere with extraction and\n                # extracting contents can reset mtime.\n                directories.append(tarinfo)\n            self._extract_one(tarinfo, path, set_attrs=not tarinfo.isdir(),\n                              numeric_owner=numeric_owner)\n\n        # Reverse sort directories.\n        directories.sort(key=lambda a: a.name, reverse=True)\n\n        # Set correct owner, mtime and filemode on directories.\n        for tarinfo in directories:\n            dirpath = os.path.join(path, tarinfo.name)\n            try:\n                self.chown(tarinfo, dirpath, numeric_owner=numeric_owner)\n                self.utime(tarinfo, dirpath)\n                self.chmod(tarinfo, dirpath)\n            except ExtractError as e:\n                self._handle_nonfatal_error(e)\n\n    def extract(self, member, path=\"\", set_attrs=True, *, numeric_owner=False,\n                filter=None):\n        \"\"\"Extract a member from the archive to the current working directory,\n           using its full name. Its file information is extracted as accurately\n           as possible. 'member' may be a filename or a TarInfo object. You can\n           specify a different directory using 'path'. File attributes (owner,\n           mtime, mode) are set unless 'set_attrs' is False. If 'numeric_owner'\n           is True, only the numbers for user/group names are used and not\n           the names.\n\n           The 'filter' function will be called before extraction.\n           It can return a changed TarInfo or None to skip the member.\n           String names of common filters are accepted.\n        \"\"\"\n        filter_function = self._get_filter_function(filter)\n        tarinfo = self._get_extract_tarinfo(member, filter_function, path)\n        if tarinfo is not None:\n            self._extract_one(tarinfo, path, set_attrs, numeric_owner)\n\n    def _get_extract_tarinfo(self, member, filter_function, path):\n        \"\"\"Get filtered TarInfo (or None) from member, which might be a str\"\"\"\n        if isinstance(member, str):\n            tarinfo = self.getmember(member)\n        else:\n            tarinfo = member\n\n        unfiltered = tarinfo\n        try:\n            tarinfo = filter_function(tarinfo, path)\n        except (OSError, FilterError) as e:\n            self._handle_fatal_error(e)\n        except ExtractError as e:\n            self._handle_nonfatal_error(e)\n        if tarinfo is None:\n            self._dbg(2, \"tarfile: Excluded %r\" % unfiltered.name)\n            return None\n        # Prepare the link target for makelink().\n        if tarinfo.islnk():\n            tarinfo = copy.copy(tarinfo)\n            tarinfo._link_target = os.path.join(path, tarinfo.linkname)\n        return tarinfo\n\n    def _extract_one(self, tarinfo, path, set_attrs, numeric_owner):\n        \"\"\"Extract from filtered tarinfo to disk\"\"\"\n        self._check(\"r\")\n\n        try:\n            self._extract_member(tarinfo, os.path.join(path, tarinfo.name),\n                                 set_attrs=set_attrs,\n                                 numeric_owner=numeric_owner)\n        except OSError as e:\n            self._handle_fatal_error(e)\n        except ExtractError as e:\n            self._handle_nonfatal_error(e)\n\n    def _handle_nonfatal_error(self, e):\n        \"\"\"Handle non-fatal error (ExtractError) according to errorlevel\"\"\"\n        if self.errorlevel > 1:\n            raise\n        else:\n            self._dbg(1, \"tarfile: %s\" % e)\n\n    def _handle_fatal_error(self, e):\n        \"\"\"Handle \"fatal\" error according to self.errorlevel\"\"\"\n        if self.errorlevel > 0:\n            raise\n        elif isinstance(e, OSError):\n            if e.filename is None:\n                self._dbg(1, \"tarfile: %s\" % e.strerror)\n            else:\n                self._dbg(1, \"tarfile: %s %r\" % (e.strerror, e.filename))\n        else:\n            self._dbg(1, \"tarfile: %s %s\" % (type(e).__name__, e))\n\n    def extractfile(self, member):\n        \"\"\"Extract a member from the archive as a file object. 'member' may be\n           a filename or a TarInfo object. If 'member' is a regular file or\n           a link, an io.BufferedReader object is returned. For all other\n           existing members, None is returned. If 'member' does not appear\n           in the archive, KeyError is raised.\n        \"\"\"\n        self._check(\"r\")\n\n        if isinstance(member, str):\n            tarinfo = self.getmember(member)\n        else:\n            tarinfo = member\n\n        if tarinfo.isreg() or tarinfo.type not in SUPPORTED_TYPES:\n            # Members with unknown types are treated as regular files.\n            return self.fileobject(self, tarinfo)\n\n        elif tarinfo.islnk() or tarinfo.issym():\n            if isinstance(self.fileobj, _Stream):\n                # A small but ugly workaround for the case that someone tries\n                # to extract a (sym)link as a file-object from a non-seekable\n                # stream of tar blocks.\n                raise StreamError(\"cannot extract (sym)link as file object\")\n            else:\n                # A (sym)link's file object is its target's file object.\n                return self.extractfile(self._find_link_target(tarinfo))\n        else:\n            # If there's no data associated with the member (directory, chrdev,\n            # blkdev, etc.), return None instead of a file object.\n            return None\n\n    def _extract_member(self, tarinfo, targetpath, set_attrs=True,\n                        numeric_owner=False):\n        \"\"\"Extract the TarInfo object tarinfo to a physical\n           file called targetpath.\n        \"\"\"\n        # Fetch the TarInfo object for the given name\n        # and build the destination pathname, replacing\n        # forward slashes to platform specific separators.\n        targetpath = targetpath.rstrip(\"/\")\n        targetpath = targetpath.replace(\"/\", os.sep)\n\n        # Create all upper directories.\n        upperdirs = os.path.dirname(targetpath)\n        if upperdirs and not os.path.exists(upperdirs):\n            # Create directories that are not part of the archive with\n            # default permissions.\n            os.makedirs(upperdirs, exist_ok=True)\n\n        if tarinfo.islnk() or tarinfo.issym():\n            self._dbg(1, \"%s -> %s\" % (tarinfo.name, tarinfo.linkname))\n        else:\n            self._dbg(1, tarinfo.name)\n\n        if tarinfo.isreg():\n            self.makefile(tarinfo, targetpath)\n        elif tarinfo.isdir():\n            self.makedir(tarinfo, targetpath)\n        elif tarinfo.isfifo():\n            self.makefifo(tarinfo, targetpath)\n        elif tarinfo.ischr() or tarinfo.isblk():\n            self.makedev(tarinfo, targetpath)\n        elif tarinfo.islnk() or tarinfo.issym():\n            self.makelink(tarinfo, targetpath)\n        elif tarinfo.type not in SUPPORTED_TYPES:\n            self.makeunknown(tarinfo, targetpath)\n        else:\n            self.makefile(tarinfo, targetpath)\n\n        if set_attrs:\n            self.chown(tarinfo, targetpath, numeric_owner)\n            if not tarinfo.issym():\n                self.chmod(tarinfo, targetpath)\n                self.utime(tarinfo, targetpath)\n\n    #--------------------------------------------------------------------------\n    # Below are the different file methods. They are called via\n    # _extract_member() when extract() is called. They can be replaced in a\n    # subclass to implement other functionality.\n\n    def makedir(self, tarinfo, targetpath):\n        \"\"\"Make a directory called targetpath.\n        \"\"\"\n        try:\n            if tarinfo.mode is None:\n                # Use the system's default mode\n                os.mkdir(targetpath)\n            else:\n                # Use a safe mode for the directory, the real mode is set\n                # later in _extract_member().\n                os.mkdir(targetpath, 0o700)\n        except FileExistsError:\n            if not os.path.isdir(targetpath):\n                raise\n\n    def makefile(self, tarinfo, targetpath):\n        \"\"\"Make a file called targetpath.\n        \"\"\"\n        source = self.fileobj\n        source.seek(tarinfo.offset_data)\n        bufsize = self.copybufsize\n        with bltn_open(targetpath, \"wb\") as target:\n            if tarinfo.sparse is not None:\n                for offset, size in tarinfo.sparse:\n                    target.seek(offset)\n                    copyfileobj(source, target, size, ReadError, bufsize)\n                target.seek(tarinfo.size)\n                target.truncate()\n            else:\n                copyfileobj(source, target, tarinfo.size, ReadError, bufsize)\n\n    def makeunknown(self, tarinfo, targetpath):\n        \"\"\"Make a file from a TarInfo object with an unknown type\n           at targetpath.\n        \"\"\"\n        self.makefile(tarinfo, targetpath)\n        self._dbg(1, \"tarfile: Unknown file type %r, \" \\\n                     \"extracted as regular file.\" % tarinfo.type)\n\n    def makefifo(self, tarinfo, targetpath):\n        \"\"\"Make a fifo called targetpath.\n        \"\"\"\n        if hasattr(os, \"mkfifo\"):\n            os.mkfifo(targetpath)\n        else:\n            raise ExtractError(\"fifo not supported by system\")\n\n    def makedev(self, tarinfo, targetpath):\n        \"\"\"Make a character or block device called targetpath.\n        \"\"\"\n        if not hasattr(os, \"mknod\") or not hasattr(os, \"makedev\"):\n            raise ExtractError(\"special devices not supported by system\")\n\n        mode = tarinfo.mode\n        if mode is None:\n            # Use mknod's default\n            mode = 0o600\n        if tarinfo.isblk():\n            mode |= stat.S_IFBLK\n        else:\n            mode |= stat.S_IFCHR\n\n        os.mknod(targetpath, mode,\n                 os.makedev(tarinfo.devmajor, tarinfo.devminor))\n\n    def makelink(self, tarinfo, targetpath):\n        \"\"\"Make a (symbolic) link called targetpath. If it cannot be created\n          (platform limitation), we try to make a copy of the referenced file\n          instead of a link.\n        \"\"\"\n        try:\n            # For systems that support symbolic and hard links.\n            if tarinfo.issym():\n                if os.path.lexists(targetpath):\n                    # Avoid FileExistsError on following os.symlink.\n                    os.unlink(targetpath)\n                os.symlink(tarinfo.linkname, targetpath)\n            else:\n                if os.path.exists(tarinfo._link_target):\n                    os.link(tarinfo._link_target, targetpath)\n                else:\n                    self._extract_member(self._find_link_target(tarinfo),\n                                         targetpath)\n        except symlink_exception:\n            try:\n                self._extract_member(self._find_link_target(tarinfo),\n                                     targetpath)\n            except KeyError:\n                raise ExtractError(\"unable to resolve link inside archive\") from None\n\n    def chown(self, tarinfo, targetpath, numeric_owner):\n        \"\"\"Set owner of targetpath according to tarinfo. If numeric_owner\n           is True, use .gid/.uid instead of .gname/.uname. If numeric_owner\n           is False, fall back to .gid/.uid when the search based on name\n           fails.\n        \"\"\"\n        if hasattr(os, \"geteuid\") and os.geteuid() == 0:\n            # We have to be root to do so.\n            g = tarinfo.gid\n            u = tarinfo.uid\n            if not numeric_owner:\n                try:\n                    if grp and tarinfo.gname:\n                        g = grp.getgrnam(tarinfo.gname)[2]\n                except KeyError:\n                    pass\n                try:\n                    if pwd and tarinfo.uname:\n                        u = pwd.getpwnam(tarinfo.uname)[2]\n                except KeyError:\n                    pass\n            if g is None:\n                g = -1\n            if u is None:\n                u = -1\n            try:\n                if tarinfo.issym() and hasattr(os, \"lchown\"):\n                    os.lchown(targetpath, u, g)\n                else:\n                    os.chown(targetpath, u, g)\n            except (OSError, OverflowError) as e:\n                # OverflowError can be raised if an ID doesn't fit in 'id_t'\n                raise ExtractError(\"could not change owner\") from e\n\n    def chmod(self, tarinfo, targetpath):\n        \"\"\"Set file permissions of targetpath according to tarinfo.\n        \"\"\"\n        if tarinfo.mode is None:\n            return\n        try:\n            os.chmod(targetpath, tarinfo.mode)\n        except OSError as e:\n            raise ExtractError(\"could not change mode\") from e\n\n    def utime(self, tarinfo, targetpath):\n        \"\"\"Set modification time of targetpath according to tarinfo.\n        \"\"\"\n        mtime = tarinfo.mtime\n        if mtime is None:\n            return\n        if not hasattr(os, 'utime'):\n            return\n        try:\n            os.utime(targetpath, (mtime, mtime))\n        except OSError as e:\n            raise ExtractError(\"could not change modification time\") from e\n\n    #--------------------------------------------------------------------------\n    def next(self):\n        \"\"\"Return the next member of the archive as a TarInfo object, when\n           TarFile is opened for reading. Return None if there is no more\n           available.\n        \"\"\"\n        self._check(\"ra\")\n        if self.firstmember is not None:\n            m = self.firstmember\n            self.firstmember = None\n            return m\n\n        # Advance the file pointer.\n        if self.offset != self.fileobj.tell():\n            if self.offset == 0:\n                return None\n            self.fileobj.seek(self.offset - 1)\n            if not self.fileobj.read(1):\n                raise ReadError(\"unexpected end of data\")\n\n        # Read the next block.\n        tarinfo = None\n        while True:\n            try:\n                tarinfo = self.tarinfo.fromtarfile(self)\n            except EOFHeaderError as e:\n                if self.ignore_zeros:\n                    self._dbg(2, \"0x%X: %s\" % (self.offset, e))\n                    self.offset += BLOCKSIZE\n                    continue\n            except InvalidHeaderError as e:\n                if self.ignore_zeros:\n                    self._dbg(2, \"0x%X: %s\" % (self.offset, e))\n                    self.offset += BLOCKSIZE\n                    continue\n                elif self.offset == 0:\n                    raise ReadError(str(e)) from None\n            except EmptyHeaderError:\n                if self.offset == 0:\n                    raise ReadError(\"empty file\") from None\n            except TruncatedHeaderError as e:\n                if self.offset == 0:\n                    raise ReadError(str(e)) from None\n            except SubsequentHeaderError as e:\n                raise ReadError(str(e)) from None\n            except Exception as e:\n                try:\n                    import zlib\n                    if isinstance(e, zlib.error):\n                        raise ReadError(f'zlib error: {e}') from None\n                    else:\n                        raise e\n                except ImportError:\n                    raise e\n            break\n\n        if tarinfo is not None:\n            # if streaming the file we do not want to cache the tarinfo\n            if not self.stream:\n                self.members.append(tarinfo)\n        else:\n            self._loaded = True\n\n        return tarinfo\n\n    #--------------------------------------------------------------------------\n    # Little helper methods:\n\n    def _getmember(self, name, tarinfo=None, normalize=False):\n        \"\"\"Find an archive member by name from bottom to top.\n           If tarinfo is given, it is used as the starting point.\n        \"\"\"\n        # Ensure that all members have been loaded.\n        members = self.getmembers()\n\n        # Limit the member search list up to tarinfo.\n        skipping = False\n        if tarinfo is not None:\n            try:\n                index = members.index(tarinfo)\n            except ValueError:\n                # The given starting point might be a (modified) copy.\n                # We'll later skip members until we find an equivalent.\n                skipping = True\n            else:\n                # Happy fast path\n                members = members[:index]\n\n        if normalize:\n            name = os.path.normpath(name)\n\n        for member in reversed(members):\n            if skipping:\n                if tarinfo.offset == member.offset:\n                    skipping = False\n                continue\n            if normalize:\n                member_name = os.path.normpath(member.name)\n            else:\n                member_name = member.name\n\n            if name == member_name:\n                return member\n\n        if skipping:\n            # Starting point was not found\n            raise ValueError(tarinfo)\n\n    def _load(self):\n        \"\"\"Read through the entire archive file and look for readable\n           members. This should not run if the file is set to stream.\n        \"\"\"\n        if not self.stream:\n            while self.next() is not None:\n                pass\n            self._loaded = True\n\n    def _check(self, mode=None):\n        \"\"\"Check if TarFile is still open, and if the operation's mode\n           corresponds to TarFile's mode.\n        \"\"\"\n        if self.closed:\n            raise OSError(\"%s is closed\" % self.__class__.__name__)\n        if mode is not None and self.mode not in mode:\n            raise OSError(\"bad operation for mode %r\" % self.mode)\n\n    def _find_link_target(self, tarinfo):\n        \"\"\"Find the target member of a symlink or hardlink member in the\n           archive.\n        \"\"\"\n        if tarinfo.issym():\n            # Always search the entire archive.\n            linkname = \"/\".join(filter(None, (os.path.dirname(tarinfo.name), tarinfo.linkname)))\n            limit = None\n        else:\n            # Search the archive before the link, because a hard link is\n            # just a reference to an already archived file.\n            linkname = tarinfo.linkname\n            limit = tarinfo\n\n        member = self._getmember(linkname, tarinfo=limit, normalize=True)\n        if member is None:\n            raise KeyError(\"linkname %r not found\" % linkname)\n        return member\n\n    def __iter__(self):\n        \"\"\"Provide an iterator object.\n        \"\"\"\n        if self._loaded:\n            yield from self.members\n            return\n\n        # Yield items using TarFile's next() method.\n        # When all members have been read, set TarFile as _loaded.\n        index = 0\n        # Fix for SF #1100429: Under rare circumstances it can\n        # happen that getmembers() is called during iteration,\n        # which will have already exhausted the next() method.\n        if self.firstmember is not None:\n            tarinfo = self.next()\n            index += 1\n            yield tarinfo\n\n        while True:\n            if index < len(self.members):\n                tarinfo = self.members[index]\n            elif not self._loaded:\n                tarinfo = self.next()\n                if not tarinfo:\n                    self._loaded = True\n                    return\n            else:\n                return\n            index += 1\n            yield tarinfo\n\n    def _dbg(self, level, msg):\n        \"\"\"Write debugging output to sys.stderr.\n        \"\"\"\n        if level <= self.debug:\n            print(msg, file=sys.stderr)\n\n    def __enter__(self):\n        self._check()\n        return self\n\n    def __exit__(self, type, value, traceback):\n        if type is None:\n            self.close()\n        else:\n            # An exception occurred. We must not call close() because\n            # it would try to write end-of-archive blocks and padding.\n            if not self._extfileobj:\n                self.fileobj.close()\n            self.closed = True\n\n#--------------------\n# exported functions\n#--------------------\n\ndef is_tarfile(name):\n    \"\"\"Return True if name points to a tar archive that we\n       are able to handle, else return False.\n\n       'name' should be a string, file, or file-like object.\n    \"\"\"\n    try:\n        if hasattr(name, \"read\"):\n            pos = name.tell()\n            t = open(fileobj=name)\n            name.seek(pos)\n        else:\n            t = open(name)\n        t.close()\n        return True\n    except TarError:\n        return False\n\nopen = TarFile.open\n\n\ndef main():\n    import argparse\n\n    description = 'A simple command-line interface for tarfile module.'\n    parser = argparse.ArgumentParser(description=description)\n    parser.add_argument('-v', '--verbose', action='store_true', default=False,\n                        help='Verbose output')\n    parser.add_argument('--filter', metavar='<filtername>',\n                        choices=_NAMED_FILTERS,\n                        help='Filter for extraction')\n\n    group = parser.add_mutually_exclusive_group(required=True)\n    group.add_argument('-l', '--list', metavar='<tarfile>',\n                       help='Show listing of a tarfile')\n    group.add_argument('-e', '--extract', nargs='+',\n                       metavar=('<tarfile>', '<output_dir>'),\n                       help='Extract tarfile into target dir')\n    group.add_argument('-c', '--create', nargs='+',\n                       metavar=('<name>', '<file>'),\n                       help='Create tarfile from sources')\n    group.add_argument('-t', '--test', metavar='<tarfile>',\n                       help='Test if a tarfile is valid')\n\n    args = parser.parse_args()\n\n    if args.filter and args.extract is None:\n        parser.exit(1, '--filter is only valid for extraction\\n')\n\n    if args.test is not None:\n        src = args.test\n        if is_tarfile(src):\n            with open(src, 'r') as tar:\n                tar.getmembers()\n                print(tar.getmembers(), file=sys.stderr)\n            if args.verbose:\n                print('{!r} is a tar archive.'.format(src))\n        else:\n            parser.exit(1, '{!r} is not a tar archive.\\n'.format(src))\n\n    elif args.list is not None:\n        src = args.list\n        if is_tarfile(src):\n            with TarFile.open(src, 'r:*') as tf:\n                tf.list(verbose=args.verbose)\n        else:\n            parser.exit(1, '{!r} is not a tar archive.\\n'.format(src))\n\n    elif args.extract is not None:\n        if len(args.extract) == 1:\n            src = args.extract[0]\n            curdir = os.curdir\n        elif len(args.extract) == 2:\n            src, curdir = args.extract\n        else:\n            parser.exit(1, parser.format_help())\n\n        if is_tarfile(src):\n            with TarFile.open(src, 'r:*') as tf:\n                tf.extractall(path=curdir, filter=args.filter)\n            if args.verbose:\n                if curdir == '.':\n                    msg = '{!r} file is extracted.'.format(src)\n                else:\n                    msg = ('{!r} file is extracted '\n                           'into {!r} directory.').format(src, curdir)\n                print(msg)\n        else:\n            parser.exit(1, '{!r} is not a tar archive.\\n'.format(src))\n\n    elif args.create is not None:\n        tar_name = args.create.pop(0)\n        _, ext = os.path.splitext(tar_name)\n        compressions = {\n            # gz\n            '.gz': 'gz',\n            '.tgz': 'gz',\n            # xz\n            '.xz': 'xz',\n            '.txz': 'xz',\n            # bz2\n            '.bz2': 'bz2',\n            '.tbz': 'bz2',\n            '.tbz2': 'bz2',\n            '.tb2': 'bz2',\n        }\n        tar_mode = 'w:' + compressions[ext] if ext in compressions else 'w'\n        tar_files = args.create\n\n        with TarFile.open(tar_name, tar_mode) as tf:\n            for file_name in tar_files:\n                tf.add(file_name)\n\n        if args.verbose:\n            print('{!r} file created.'.format(tar_name))\n\nif __name__ == '__main__':\n    main()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/backports/tarfile/__main__.py","size":59,"sha1":"418f3ff76d92563aa1f70c982ccc90d6a51fd2c0","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from . import main\n\n\nif __name__ == '__main__':\n    main()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/backports/tarfile/compat/__init__.py","size":0,"sha1":"da39a3ee5e6b4b0d3255bfef95601890afd80709","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":""},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/backports/tarfile/compat/py38.py","size":568,"sha1":"4a89e2371c6cfc8bae1985cb217cb8b716a22e11","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\n\n\nif sys.version_info < (3, 9):\n\n    def removesuffix(self, suffix):\n        # suffix='' should not call self[:-0].\n        if suffix and self.endswith(suffix):\n            return self[: -len(suffix)]\n        else:\n            return self[:]\n\n    def removeprefix(self, prefix):\n        if self.startswith(prefix):\n            return self[len(prefix) :]\n        else:\n            return self[:]\nelse:\n\n    def removesuffix(self, suffix):\n        return self.removesuffix(suffix)\n\n    def removeprefix(self, prefix):\n        return self.removeprefix(prefix)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/importlib_metadata/__init__.py","size":33798,"sha1":"723568d30237c5084aca42147608d93e9e4ea444","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport os\nimport re\nimport abc\nimport sys\nimport json\nimport zipp\nimport email\nimport types\nimport inspect\nimport pathlib\nimport operator\nimport textwrap\nimport functools\nimport itertools\nimport posixpath\nimport collections\n\nfrom . import _meta\nfrom .compat import py39, py311\nfrom ._collections import FreezableDefaultDict, Pair\nfrom ._compat import (\n    NullFinder,\n    install,\n)\nfrom ._functools import method_cache, pass_none\nfrom ._itertools import always_iterable, unique_everseen\nfrom ._meta import PackageMetadata, SimplePath\n\nfrom contextlib import suppress\nfrom importlib import import_module\nfrom importlib.abc import MetaPathFinder\nfrom itertools import starmap\nfrom typing import Any, Iterable, List, Mapping, Match, Optional, Set, cast\n\n__all__ = [\n    'Distribution',\n    'DistributionFinder',\n    'PackageMetadata',\n    'PackageNotFoundError',\n    'distribution',\n    'distributions',\n    'entry_points',\n    'files',\n    'metadata',\n    'packages_distributions',\n    'requires',\n    'version',\n]\n\n\nclass PackageNotFoundError(ModuleNotFoundError):\n    \"\"\"The package was not found.\"\"\"\n\n    def __str__(self) -> str:\n        return f\"No package metadata was found for {self.name}\"\n\n    @property\n    def name(self) -> str:  # type: ignore[override]\n        (name,) = self.args\n        return name\n\n\nclass Sectioned:\n    \"\"\"\n    A simple entry point config parser for performance\n\n    >>> for item in Sectioned.read(Sectioned._sample):\n    ...     print(item)\n    Pair(name='sec1', value='# comments ignored')\n    Pair(name='sec1', value='a = 1')\n    Pair(name='sec1', value='b = 2')\n    Pair(name='sec2', value='a = 2')\n\n    >>> res = Sectioned.section_pairs(Sectioned._sample)\n    >>> item = next(res)\n    >>> item.name\n    'sec1'\n    >>> item.value\n    Pair(name='a', value='1')\n    >>> item = next(res)\n    >>> item.value\n    Pair(name='b', value='2')\n    >>> item = next(res)\n    >>> item.name\n    'sec2'\n    >>> item.value\n    Pair(name='a', value='2')\n    >>> list(res)\n    []\n    \"\"\"\n\n    _sample = textwrap.dedent(\n        \"\"\"\n        [sec1]\n        # comments ignored\n        a = 1\n        b = 2\n\n        [sec2]\n        a = 2\n        \"\"\"\n    ).lstrip()\n\n    @classmethod\n    def section_pairs(cls, text):\n        return (\n            section._replace(value=Pair.parse(section.value))\n            for section in cls.read(text, filter_=cls.valid)\n            if section.name is not None\n        )\n\n    @staticmethod\n    def read(text, filter_=None):\n        lines = filter(filter_, map(str.strip, text.splitlines()))\n        name = None\n        for value in lines:\n            section_match = value.startswith('[') and value.endswith(']')\n            if section_match:\n                name = value.strip('[]')\n                continue\n            yield Pair(name, value)\n\n    @staticmethod\n    def valid(line: str):\n        return line and not line.startswith('#')\n\n\nclass EntryPoint:\n    \"\"\"An entry point as defined by Python packaging conventions.\n\n    See `the packaging docs on entry points\n    <https://packaging.python.org/specifications/entry-points/>`_\n    for more information.\n\n    >>> ep = EntryPoint(\n    ...     name=None, group=None, value='package.module:attr [extra1, extra2]')\n    >>> ep.module\n    'package.module'\n    >>> ep.attr\n    'attr'\n    >>> ep.extras\n    ['extra1', 'extra2']\n    \"\"\"\n\n    pattern = re.compile(\n        r'(?P<module>[\\w.]+)\\s*'\n        r'(:\\s*(?P<attr>[\\w.]+)\\s*)?'\n        r'((?P<extras>\\[.*\\])\\s*)?$'\n    )\n    \"\"\"\n    A regular expression describing the syntax for an entry point,\n    which might look like:\n\n        - module\n        - package.module\n        - package.module:attribute\n        - package.module:object.attribute\n        - package.module:attr [extra1, extra2]\n\n    Other combinations are possible as well.\n\n    The expression is lenient about whitespace around the ':',\n    following the attr, and following any extras.\n    \"\"\"\n\n    name: str\n    value: str\n    group: str\n\n    dist: Optional[Distribution] = None\n\n    def __init__(self, name: str, value: str, group: str) -> None:\n        vars(self).update(name=name, value=value, group=group)\n\n    def load(self) -> Any:\n        \"\"\"Load the entry point from its definition. If only a module\n        is indicated by the value, return that module. Otherwise,\n        return the named object.\n        \"\"\"\n        match = cast(Match, self.pattern.match(self.value))\n        module = import_module(match.group('module'))\n        attrs = filter(None, (match.group('attr') or '').split('.'))\n        return functools.reduce(getattr, attrs, module)\n\n    @property\n    def module(self) -> str:\n        match = self.pattern.match(self.value)\n        assert match is not None\n        return match.group('module')\n\n    @property\n    def attr(self) -> str:\n        match = self.pattern.match(self.value)\n        assert match is not None\n        return match.group('attr')\n\n    @property\n    def extras(self) -> List[str]:\n        match = self.pattern.match(self.value)\n        assert match is not None\n        return re.findall(r'\\w+', match.group('extras') or '')\n\n    def _for(self, dist):\n        vars(self).update(dist=dist)\n        return self\n\n    def matches(self, **params):\n        \"\"\"\n        EntryPoint matches the given parameters.\n\n        >>> ep = EntryPoint(group='foo', name='bar', value='bing:bong [extra1, extra2]')\n        >>> ep.matches(group='foo')\n        True\n        >>> ep.matches(name='bar', value='bing:bong [extra1, extra2]')\n        True\n        >>> ep.matches(group='foo', name='other')\n        False\n        >>> ep.matches()\n        True\n        >>> ep.matches(extras=['extra1', 'extra2'])\n        True\n        >>> ep.matches(module='bing')\n        True\n        >>> ep.matches(attr='bong')\n        True\n        \"\"\"\n        attrs = (getattr(self, param) for param in params)\n        return all(map(operator.eq, params.values(), attrs))\n\n    def _key(self):\n        return self.name, self.value, self.group\n\n    def __lt__(self, other):\n        return self._key() < other._key()\n\n    def __eq__(self, other):\n        return self._key() == other._key()\n\n    def __setattr__(self, name, value):\n        raise AttributeError(\"EntryPoint objects are immutable.\")\n\n    def __repr__(self):\n        return (\n            f'EntryPoint(name={self.name!r}, value={self.value!r}, '\n            f'group={self.group!r})'\n        )\n\n    def __hash__(self) -> int:\n        return hash(self._key())\n\n\nclass EntryPoints(tuple):\n    \"\"\"\n    An immutable collection of selectable EntryPoint objects.\n    \"\"\"\n\n    __slots__ = ()\n\n    def __getitem__(self, name: str) -> EntryPoint:  # type: ignore[override]\n        \"\"\"\n        Get the EntryPoint in self matching name.\n        \"\"\"\n        try:\n            return next(iter(self.select(name=name)))\n        except StopIteration:\n            raise KeyError(name)\n\n    def __repr__(self):\n        \"\"\"\n        Repr with classname and tuple constructor to\n        signal that we deviate from regular tuple behavior.\n        \"\"\"\n        return '%s(%r)' % (self.__class__.__name__, tuple(self))\n\n    def select(self, **params) -> EntryPoints:\n        \"\"\"\n        Select entry points from self that match the\n        given parameters (typically group and/or name).\n        \"\"\"\n        return EntryPoints(ep for ep in self if py39.ep_matches(ep, **params))\n\n    @property\n    def names(self) -> Set[str]:\n        \"\"\"\n        Return the set of all names of all entry points.\n        \"\"\"\n        return {ep.name for ep in self}\n\n    @property\n    def groups(self) -> Set[str]:\n        \"\"\"\n        Return the set of all groups of all entry points.\n        \"\"\"\n        return {ep.group for ep in self}\n\n    @classmethod\n    def _from_text_for(cls, text, dist):\n        return cls(ep._for(dist) for ep in cls._from_text(text))\n\n    @staticmethod\n    def _from_text(text):\n        return (\n            EntryPoint(name=item.value.name, value=item.value.value, group=item.name)\n            for item in Sectioned.section_pairs(text or '')\n        )\n\n\nclass PackagePath(pathlib.PurePosixPath):\n    \"\"\"A reference to a path in a package\"\"\"\n\n    hash: Optional[FileHash]\n    size: int\n    dist: Distribution\n\n    def read_text(self, encoding: str = 'utf-8') -> str:  # type: ignore[override]\n        return self.locate().read_text(encoding=encoding)\n\n    def read_binary(self) -> bytes:\n        return self.locate().read_bytes()\n\n    def locate(self) -> SimplePath:\n        \"\"\"Return a path-like object for this path\"\"\"\n        return self.dist.locate_file(self)\n\n\nclass FileHash:\n    def __init__(self, spec: str) -> None:\n        self.mode, _, self.value = spec.partition('=')\n\n    def __repr__(self) -> str:\n        return f'<FileHash mode: {self.mode} value: {self.value}>'\n\n\nclass Distribution(metaclass=abc.ABCMeta):\n    \"\"\"\n    An abstract Python distribution package.\n\n    Custom providers may derive from this class and define\n    the abstract methods to provide a concrete implementation\n    for their environment. Some providers may opt to override\n    the default implementation of some properties to bypass\n    the file-reading mechanism.\n    \"\"\"\n\n    @abc.abstractmethod\n    def read_text(self, filename) -> Optional[str]:\n        \"\"\"Attempt to load metadata file given by the name.\n\n        Python distribution metadata is organized by blobs of text\n        typically represented as \"files\" in the metadata directory\n        (e.g. package-1.0.dist-info). These files include things\n        like:\n\n        - METADATA: The distribution metadata including fields\n          like Name and Version and Description.\n        - entry_points.txt: A series of entry points as defined in\n          `the entry points spec <https://packaging.python.org/en/latest/specifications/entry-points/#file-format>`_.\n        - RECORD: A record of files according to\n          `this recording spec <https://packaging.python.org/en/latest/specifications/recording-installed-packages/#the-record-file>`_.\n\n        A package may provide any set of files, including those\n        not listed here or none at all.\n\n        :param filename: The name of the file in the distribution info.\n        :return: The text if found, otherwise None.\n        \"\"\"\n\n    @abc.abstractmethod\n    def locate_file(self, path: str | os.PathLike[str]) -> SimplePath:\n        \"\"\"\n        Given a path to a file in this distribution, return a SimplePath\n        to it.\n        \"\"\"\n\n    @classmethod\n    def from_name(cls, name: str) -> Distribution:\n        \"\"\"Return the Distribution for the given package name.\n\n        :param name: The name of the distribution package to search for.\n        :return: The Distribution instance (or subclass thereof) for the named\n            package, if found.\n        :raises PackageNotFoundError: When the named package's distribution\n            metadata cannot be found.\n        :raises ValueError: When an invalid value is supplied for name.\n        \"\"\"\n        if not name:\n            raise ValueError(\"A distribution name is required.\")\n        try:\n            return next(iter(cls.discover(name=name)))\n        except StopIteration:\n            raise PackageNotFoundError(name)\n\n    @classmethod\n    def discover(\n        cls, *, context: Optional[DistributionFinder.Context] = None, **kwargs\n    ) -> Iterable[Distribution]:\n        \"\"\"Return an iterable of Distribution objects for all packages.\n\n        Pass a ``context`` or pass keyword arguments for constructing\n        a context.\n\n        :context: A ``DistributionFinder.Context`` object.\n        :return: Iterable of Distribution objects for packages matching\n          the context.\n        \"\"\"\n        if context and kwargs:\n            raise ValueError(\"cannot accept context and kwargs\")\n        context = context or DistributionFinder.Context(**kwargs)\n        return itertools.chain.from_iterable(\n            resolver(context) for resolver in cls._discover_resolvers()\n        )\n\n    @staticmethod\n    def at(path: str | os.PathLike[str]) -> Distribution:\n        \"\"\"Return a Distribution for the indicated metadata path.\n\n        :param path: a string or path-like object\n        :return: a concrete Distribution instance for the path\n        \"\"\"\n        return PathDistribution(pathlib.Path(path))\n\n    @staticmethod\n    def _discover_resolvers():\n        \"\"\"Search the meta_path for resolvers (MetadataPathFinders).\"\"\"\n        declared = (\n            getattr(finder, 'find_distributions', None) for finder in sys.meta_path\n        )\n        return filter(None, declared)\n\n    @property\n    def metadata(self) -> _meta.PackageMetadata:\n        \"\"\"Return the parsed metadata for this Distribution.\n\n        The returned object will have keys that name the various bits of\n        metadata per the\n        `Core metadata specifications <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\n\n        Custom providers may provide the METADATA file or override this\n        property.\n        \"\"\"\n        # deferred for performance (python/cpython#109829)\n        from . import _adapters\n\n        opt_text = (\n            self.read_text('METADATA')\n            or self.read_text('PKG-INFO')\n            # This last clause is here to support old egg-info files.  Its\n            # effect is to just end up using the PathDistribution's self._path\n            # (which points to the egg-info file) attribute unchanged.\n            or self.read_text('')\n        )\n        text = cast(str, opt_text)\n        return _adapters.Message(email.message_from_string(text))\n\n    @property\n    def name(self) -> str:\n        \"\"\"Return the 'Name' metadata for the distribution package.\"\"\"\n        return self.metadata['Name']\n\n    @property\n    def _normalized_name(self):\n        \"\"\"Return a normalized version of the name.\"\"\"\n        return Prepared.normalize(self.name)\n\n    @property\n    def version(self) -> str:\n        \"\"\"Return the 'Version' metadata for the distribution package.\"\"\"\n        return self.metadata['Version']\n\n    @property\n    def entry_points(self) -> EntryPoints:\n        \"\"\"\n        Return EntryPoints for this distribution.\n\n        Custom providers may provide the ``entry_points.txt`` file\n        or override this property.\n        \"\"\"\n        return EntryPoints._from_text_for(self.read_text('entry_points.txt'), self)\n\n    @property\n    def files(self) -> Optional[List[PackagePath]]:\n        \"\"\"Files in this distribution.\n\n        :return: List of PackagePath for this distribution or None\n\n        Result is `None` if the metadata file that enumerates files\n        (i.e. RECORD for dist-info, or installed-files.txt or\n        SOURCES.txt for egg-info) is missing.\n        Result may be empty if the metadata exists but is empty.\n\n        Custom providers are recommended to provide a \"RECORD\" file (in\n        ``read_text``) or override this property to allow for callers to be\n        able to resolve filenames provided by the package.\n        \"\"\"\n\n        def make_file(name, hash=None, size_str=None):\n            result = PackagePath(name)\n            result.hash = FileHash(hash) if hash else None\n            result.size = int(size_str) if size_str else None\n            result.dist = self\n            return result\n\n        @pass_none\n        def make_files(lines):\n            # Delay csv import, since Distribution.files is not as widely used\n            # as other parts of importlib.metadata\n            import csv\n\n            return starmap(make_file, csv.reader(lines))\n\n        @pass_none\n        def skip_missing_files(package_paths):\n            return list(filter(lambda path: path.locate().exists(), package_paths))\n\n        return skip_missing_files(\n            make_files(\n                self._read_files_distinfo()\n                or self._read_files_egginfo_installed()\n                or self._read_files_egginfo_sources()\n            )\n        )\n\n    def _read_files_distinfo(self):\n        \"\"\"\n        Read the lines of RECORD.\n        \"\"\"\n        text = self.read_text('RECORD')\n        return text and text.splitlines()\n\n    def _read_files_egginfo_installed(self):\n        \"\"\"\n        Read installed-files.txt and return lines in a similar\n        CSV-parsable format as RECORD: each file must be placed\n        relative to the site-packages directory and must also be\n        quoted (since file names can contain literal commas).\n\n        This file is written when the package is installed by pip,\n        but it might not be written for other installation methods.\n        Assume the file is accurate if it exists.\n        \"\"\"\n        text = self.read_text('installed-files.txt')\n        # Prepend the .egg-info/ subdir to the lines in this file.\n        # But this subdir is only available from PathDistribution's\n        # self._path.\n        subdir = getattr(self, '_path', None)\n        if not text or not subdir:\n            return\n\n        paths = (\n            py311.relative_fix((subdir / name).resolve())\n            .relative_to(self.locate_file('').resolve(), walk_up=True)\n            .as_posix()\n            for name in text.splitlines()\n        )\n        return map('\"{}\"'.format, paths)\n\n    def _read_files_egginfo_sources(self):\n        \"\"\"\n        Read SOURCES.txt and return lines in a similar CSV-parsable\n        format as RECORD: each file name must be quoted (since it\n        might contain literal commas).\n\n        Note that SOURCES.txt is not a reliable source for what\n        files are installed by a package. This file is generated\n        for a source archive, and the files that are present\n        there (e.g. setup.py) may not correctly reflect the files\n        that are present after the package has been installed.\n        \"\"\"\n        text = self.read_text('SOURCES.txt')\n        return text and map('\"{}\"'.format, text.splitlines())\n\n    @property\n    def requires(self) -> Optional[List[str]]:\n        \"\"\"Generated requirements specified for this Distribution\"\"\"\n        reqs = self._read_dist_info_reqs() or self._read_egg_info_reqs()\n        return reqs and list(reqs)\n\n    def _read_dist_info_reqs(self):\n        return self.metadata.get_all('Requires-Dist')\n\n    def _read_egg_info_reqs(self):\n        source = self.read_text('requires.txt')\n        return pass_none(self._deps_from_requires_text)(source)\n\n    @classmethod\n    def _deps_from_requires_text(cls, source):\n        return cls._convert_egg_info_reqs_to_simple_reqs(Sectioned.read(source))\n\n    @staticmethod\n    def _convert_egg_info_reqs_to_simple_reqs(sections):\n        \"\"\"\n        Historically, setuptools would solicit and store 'extra'\n        requirements, including those with environment markers,\n        in separate sections. More modern tools expect each\n        dependency to be defined separately, with any relevant\n        extras and environment markers attached directly to that\n        requirement. This method converts the former to the\n        latter. See _test_deps_from_requires_text for an example.\n        \"\"\"\n\n        def make_condition(name):\n            return name and f'extra == \"{name}\"'\n\n        def quoted_marker(section):\n            section = section or ''\n            extra, sep, markers = section.partition(':')\n            if extra and markers:\n                markers = f'({markers})'\n            conditions = list(filter(None, [markers, make_condition(extra)]))\n            return '; ' + ' and '.join(conditions) if conditions else ''\n\n        def url_req_space(req):\n            \"\"\"\n            PEP 508 requires a space between the url_spec and the quoted_marker.\n            Ref python/importlib_metadata#357.\n            \"\"\"\n            # '@' is uniquely indicative of a url_req.\n            return ' ' * ('@' in req)\n\n        for section in sections:\n            space = url_req_space(section.value)\n            yield section.value + space + quoted_marker(section.name)\n\n    @property\n    def origin(self):\n        return self._load_json('direct_url.json')\n\n    def _load_json(self, filename):\n        return pass_none(json.loads)(\n            self.read_text(filename),\n            object_hook=lambda data: types.SimpleNamespace(**data),\n        )\n\n\nclass DistributionFinder(MetaPathFinder):\n    \"\"\"\n    A MetaPathFinder capable of discovering installed distributions.\n\n    Custom providers should implement this interface in order to\n    supply metadata.\n    \"\"\"\n\n    class Context:\n        \"\"\"\n        Keyword arguments presented by the caller to\n        ``distributions()`` or ``Distribution.discover()``\n        to narrow the scope of a search for distributions\n        in all DistributionFinders.\n\n        Each DistributionFinder may expect any parameters\n        and should attempt to honor the canonical\n        parameters defined below when appropriate.\n\n        This mechanism gives a custom provider a means to\n        solicit additional details from the caller beyond\n        \"name\" and \"path\" when searching distributions.\n        For example, imagine a provider that exposes suites\n        of packages in either a \"public\" or \"private\" ``realm``.\n        A caller may wish to query only for distributions in\n        a particular realm and could call\n        ``distributions(realm=\"private\")`` to signal to the\n        custom provider to only include distributions from that\n        realm.\n        \"\"\"\n\n        name = None\n        \"\"\"\n        Specific name for which a distribution finder should match.\n        A name of ``None`` matches all distributions.\n        \"\"\"\n\n        def __init__(self, **kwargs):\n            vars(self).update(kwargs)\n\n        @property\n        def path(self) -> List[str]:\n            \"\"\"\n            The sequence of directory path that a distribution finder\n            should search.\n\n            Typically refers to Python installed package paths such as\n            \"site-packages\" directories and defaults to ``sys.path``.\n            \"\"\"\n            return vars(self).get('path', sys.path)\n\n    @abc.abstractmethod\n    def find_distributions(self, context=Context()) -> Iterable[Distribution]:\n        \"\"\"\n        Find distributions.\n\n        Return an iterable of all Distribution instances capable of\n        loading the metadata for packages matching the ``context``,\n        a DistributionFinder.Context instance.\n        \"\"\"\n\n\nclass FastPath:\n    \"\"\"\n    Micro-optimized class for searching a root for children.\n\n    Root is a path on the file system that may contain metadata\n    directories either as natural directories or within a zip file.\n\n    >>> FastPath('').children()\n    ['...']\n\n    FastPath objects are cached and recycled for any given root.\n\n    >>> FastPath('foobar') is FastPath('foobar')\n    True\n    \"\"\"\n\n    @functools.lru_cache()  # type: ignore\n    def __new__(cls, root):\n        return super().__new__(cls)\n\n    def __init__(self, root):\n        self.root = root\n\n    def joinpath(self, child):\n        return pathlib.Path(self.root, child)\n\n    def children(self):\n        with suppress(Exception):\n            return os.listdir(self.root or '.')\n        with suppress(Exception):\n            return self.zip_children()\n        return []\n\n    def zip_children(self):\n        zip_path = zipp.Path(self.root)\n        names = zip_path.root.namelist()\n        self.joinpath = zip_path.joinpath\n\n        return dict.fromkeys(child.split(posixpath.sep, 1)[0] for child in names)\n\n    def search(self, name):\n        return self.lookup(self.mtime).search(name)\n\n    @property\n    def mtime(self):\n        with suppress(OSError):\n            return os.stat(self.root).st_mtime\n        self.lookup.cache_clear()\n\n    @method_cache\n    def lookup(self, mtime):\n        return Lookup(self)\n\n\nclass Lookup:\n    \"\"\"\n    A micro-optimized class for searching a (fast) path for metadata.\n    \"\"\"\n\n    def __init__(self, path: FastPath):\n        \"\"\"\n        Calculate all of the children representing metadata.\n\n        From the children in the path, calculate early all of the\n        children that appear to represent metadata (infos) or legacy\n        metadata (eggs).\n        \"\"\"\n\n        base = os.path.basename(path.root).lower()\n        base_is_egg = base.endswith(\".egg\")\n        self.infos = FreezableDefaultDict(list)\n        self.eggs = FreezableDefaultDict(list)\n\n        for child in path.children():\n            low = child.lower()\n            if low.endswith((\".dist-info\", \".egg-info\")):\n                # rpartition is faster than splitext and suitable for this purpose.\n                name = low.rpartition(\".\")[0].partition(\"-\")[0]\n                normalized = Prepared.normalize(name)\n                self.infos[normalized].append(path.joinpath(child))\n            elif base_is_egg and low == \"egg-info\":\n                name = base.rpartition(\".\")[0].partition(\"-\")[0]\n                legacy_normalized = Prepared.legacy_normalize(name)\n                self.eggs[legacy_normalized].append(path.joinpath(child))\n\n        self.infos.freeze()\n        self.eggs.freeze()\n\n    def search(self, prepared: Prepared):\n        \"\"\"\n        Yield all infos and eggs matching the Prepared query.\n        \"\"\"\n        infos = (\n            self.infos[prepared.normalized]\n            if prepared\n            else itertools.chain.from_iterable(self.infos.values())\n        )\n        eggs = (\n            self.eggs[prepared.legacy_normalized]\n            if prepared\n            else itertools.chain.from_iterable(self.eggs.values())\n        )\n        return itertools.chain(infos, eggs)\n\n\nclass Prepared:\n    \"\"\"\n    A prepared search query for metadata on a possibly-named package.\n\n    Pre-calculates the normalization to prevent repeated operations.\n\n    >>> none = Prepared(None)\n    >>> none.normalized\n    >>> none.legacy_normalized\n    >>> bool(none)\n    False\n    >>> sample = Prepared('Sample__Pkg-name.foo')\n    >>> sample.normalized\n    'sample_pkg_name_foo'\n    >>> sample.legacy_normalized\n    'sample__pkg_name.foo'\n    >>> bool(sample)\n    True\n    \"\"\"\n\n    normalized = None\n    legacy_normalized = None\n\n    def __init__(self, name: Optional[str]):\n        self.name = name\n        if name is None:\n            return\n        self.normalized = self.normalize(name)\n        self.legacy_normalized = self.legacy_normalize(name)\n\n    @staticmethod\n    def normalize(name):\n        \"\"\"\n        PEP 503 normalization plus dashes as underscores.\n        \"\"\"\n        return re.sub(r\"[-_.]+\", \"-\", name).lower().replace('-', '_')\n\n    @staticmethod\n    def legacy_normalize(name):\n        \"\"\"\n        Normalize the package name as found in the convention in\n        older packaging tools versions and specs.\n        \"\"\"\n        return name.lower().replace('-', '_')\n\n    def __bool__(self):\n        return bool(self.name)\n\n\n@install\nclass MetadataPathFinder(NullFinder, DistributionFinder):\n    \"\"\"A degenerate finder for distribution packages on the file system.\n\n    This finder supplies only a find_distributions() method for versions\n    of Python that do not have a PathFinder find_distributions().\n    \"\"\"\n\n    @classmethod\n    def find_distributions(\n        cls, context=DistributionFinder.Context()\n    ) -> Iterable[PathDistribution]:\n        \"\"\"\n        Find distributions.\n\n        Return an iterable of all Distribution instances capable of\n        loading the metadata for packages matching ``context.name``\n        (or all names if ``None`` indicated) along the paths in the list\n        of directories ``context.path``.\n        \"\"\"\n        found = cls._search_paths(context.name, context.path)\n        return map(PathDistribution, found)\n\n    @classmethod\n    def _search_paths(cls, name, paths):\n        \"\"\"Find metadata directories in paths heuristically.\"\"\"\n        prepared = Prepared(name)\n        return itertools.chain.from_iterable(\n            path.search(prepared) for path in map(FastPath, paths)\n        )\n\n    @classmethod\n    def invalidate_caches(cls) -> None:\n        FastPath.__new__.cache_clear()\n\n\nclass PathDistribution(Distribution):\n    def __init__(self, path: SimplePath) -> None:\n        \"\"\"Construct a distribution.\n\n        :param path: SimplePath indicating the metadata directory.\n        \"\"\"\n        self._path = path\n\n    def read_text(self, filename: str | os.PathLike[str]) -> Optional[str]:\n        with suppress(\n            FileNotFoundError,\n            IsADirectoryError,\n            KeyError,\n            NotADirectoryError,\n            PermissionError,\n        ):\n            return self._path.joinpath(filename).read_text(encoding='utf-8')\n\n        return None\n\n    read_text.__doc__ = Distribution.read_text.__doc__\n\n    def locate_file(self, path: str | os.PathLike[str]) -> SimplePath:\n        return self._path.parent / path\n\n    @property\n    def _normalized_name(self):\n        \"\"\"\n        Performance optimization: where possible, resolve the\n        normalized name from the file system path.\n        \"\"\"\n        stem = os.path.basename(str(self._path))\n        return (\n            pass_none(Prepared.normalize)(self._name_from_stem(stem))\n            or super()._normalized_name\n        )\n\n    @staticmethod\n    def _name_from_stem(stem):\n        \"\"\"\n        >>> PathDistribution._name_from_stem('foo-3.0.egg-info')\n        'foo'\n        >>> PathDistribution._name_from_stem('CherryPy-3.0.dist-info')\n        'CherryPy'\n        >>> PathDistribution._name_from_stem('face.egg-info')\n        'face'\n        >>> PathDistribution._name_from_stem('foo.bar')\n        \"\"\"\n        filename, ext = os.path.splitext(stem)\n        if ext not in ('.dist-info', '.egg-info'):\n            return\n        name, sep, rest = filename.partition('-')\n        return name\n\n\ndef distribution(distribution_name: str) -> Distribution:\n    \"\"\"Get the ``Distribution`` instance for the named package.\n\n    :param distribution_name: The name of the distribution package as a string.\n    :return: A ``Distribution`` instance (or subclass thereof).\n    \"\"\"\n    return Distribution.from_name(distribution_name)\n\n\ndef distributions(**kwargs) -> Iterable[Distribution]:\n    \"\"\"Get all ``Distribution`` instances in the current environment.\n\n    :return: An iterable of ``Distribution`` instances.\n    \"\"\"\n    return Distribution.discover(**kwargs)\n\n\ndef metadata(distribution_name: str) -> _meta.PackageMetadata:\n    \"\"\"Get the metadata for the named package.\n\n    :param distribution_name: The name of the distribution package to query.\n    :return: A PackageMetadata containing the parsed metadata.\n    \"\"\"\n    return Distribution.from_name(distribution_name).metadata\n\n\ndef version(distribution_name: str) -> str:\n    \"\"\"Get the version string for the named package.\n\n    :param distribution_name: The name of the distribution package to query.\n    :return: The version string for the package as defined in the package's\n        \"Version\" metadata key.\n    \"\"\"\n    return distribution(distribution_name).version\n\n\n_unique = functools.partial(\n    unique_everseen,\n    key=py39.normalized_name,\n)\n\"\"\"\nWrapper for ``distributions`` to return unique distributions by name.\n\"\"\"\n\n\ndef entry_points(**params) -> EntryPoints:\n    \"\"\"Return EntryPoint objects for all installed packages.\n\n    Pass selection parameters (group or name) to filter the\n    result to entry points matching those properties (see\n    EntryPoints.select()).\n\n    :return: EntryPoints for all installed packages.\n    \"\"\"\n    eps = itertools.chain.from_iterable(\n        dist.entry_points for dist in _unique(distributions())\n    )\n    return EntryPoints(eps).select(**params)\n\n\ndef files(distribution_name: str) -> Optional[List[PackagePath]]:\n    \"\"\"Return a list of files for the named package.\n\n    :param distribution_name: The name of the distribution package to query.\n    :return: List of files composing the distribution.\n    \"\"\"\n    return distribution(distribution_name).files\n\n\ndef requires(distribution_name: str) -> Optional[List[str]]:\n    \"\"\"\n    Return a list of requirements for the named package.\n\n    :return: An iterable of requirements, suitable for\n        packaging.requirement.Requirement.\n    \"\"\"\n    return distribution(distribution_name).requires\n\n\ndef packages_distributions() -> Mapping[str, List[str]]:\n    \"\"\"\n    Return a mapping of top-level packages to their\n    distributions.\n\n    >>> import collections.abc\n    >>> pkgs = packages_distributions()\n    >>> all(isinstance(dist, collections.abc.Sequence) for dist in pkgs.values())\n    True\n    \"\"\"\n    pkg_to_dist = collections.defaultdict(list)\n    for dist in distributions():\n        for pkg in _top_level_declared(dist) or _top_level_inferred(dist):\n            pkg_to_dist[pkg].append(dist.metadata['Name'])\n    return dict(pkg_to_dist)\n\n\ndef _top_level_declared(dist):\n    return (dist.read_text('top_level.txt') or '').split()\n\n\ndef _topmost(name: PackagePath) -> Optional[str]:\n    \"\"\"\n    Return the top-most parent as long as there is a parent.\n    \"\"\"\n    top, *rest = name.parts\n    return top if rest else None\n\n\ndef _get_toplevel_name(name: PackagePath) -> str:\n    \"\"\"\n    Infer a possibly importable module name from a name presumed on\n    sys.path.\n\n    >>> _get_toplevel_name(PackagePath('foo.py'))\n    'foo'\n    >>> _get_toplevel_name(PackagePath('foo'))\n    'foo'\n    >>> _get_toplevel_name(PackagePath('foo.pyc'))\n    'foo'\n    >>> _get_toplevel_name(PackagePath('foo/__init__.py'))\n    'foo'\n    >>> _get_toplevel_name(PackagePath('foo.pth'))\n    'foo.pth'\n    >>> _get_toplevel_name(PackagePath('foo.dist-info'))\n    'foo.dist-info'\n    \"\"\"\n    return _topmost(name) or (\n        # python/typeshed#10328\n        inspect.getmodulename(name)  # type: ignore\n        or str(name)\n    )\n\n\ndef _top_level_inferred(dist):\n    opt_names = set(map(_get_toplevel_name, always_iterable(dist.files)))\n\n    def importable_name(name):\n        return '.' not in name\n\n    return filter(importable_name, opt_names)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/importlib_metadata/_adapters.py","size":2317,"sha1":"5af210ac3ad8ea1b2cdbef30e7152211ea3c6497","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import re\nimport textwrap\nimport email.message\n\nfrom ._text import FoldedCase\n\n\nclass Message(email.message.Message):\n    multiple_use_keys = set(\n        map(\n            FoldedCase,\n            [\n                'Classifier',\n                'Obsoletes-Dist',\n                'Platform',\n                'Project-URL',\n                'Provides-Dist',\n                'Provides-Extra',\n                'Requires-Dist',\n                'Requires-External',\n                'Supported-Platform',\n                'Dynamic',\n            ],\n        )\n    )\n    \"\"\"\n    Keys that may be indicated multiple times per PEP 566.\n    \"\"\"\n\n    def __new__(cls, orig: email.message.Message):\n        res = super().__new__(cls)\n        vars(res).update(vars(orig))\n        return res\n\n    def __init__(self, *args, **kwargs):\n        self._headers = self._repair_headers()\n\n    # suppress spurious error from mypy\n    def __iter__(self):\n        return super().__iter__()\n\n    def __getitem__(self, item):\n        \"\"\"\n        Override parent behavior to typical dict behavior.\n\n        ``email.message.Message`` will emit None values for missing\n        keys. Typical mappings, including this ``Message``, will raise\n        a key error for missing keys.\n\n        Ref python/importlib_metadata#371.\n        \"\"\"\n        res = super().__getitem__(item)\n        if res is None:\n            raise KeyError(item)\n        return res\n\n    def _repair_headers(self):\n        def redent(value):\n            \"Correct for RFC822 indentation\"\n            if not value or '\\n' not in value:\n                return value\n            return textwrap.dedent(' ' * 8 + value)\n\n        headers = [(key, redent(value)) for key, value in vars(self)['_headers']]\n        if self._payload:\n            headers.append(('Description', self.get_payload()))\n        return headers\n\n    @property\n    def json(self):\n        \"\"\"\n        Convert PackageMetadata to a JSON-compatible format\n        per PEP 0566.\n        \"\"\"\n\n        def transform(key):\n            value = self.get_all(key) if key in self.multiple_use_keys else self[key]\n            if key == 'Keywords':\n                value = re.split(r'\\s+', value)\n            tk = key.lower().replace('-', '_')\n            return tk, value\n\n        return dict(map(transform, map(FoldedCase, self)))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/importlib_metadata/_collections.py","size":743,"sha1":"4e07a9ef47d40ddd33eb1d29c8277823ad97a01b","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import collections\n\n\n# from jaraco.collections 3.3\nclass FreezableDefaultDict(collections.defaultdict):\n    \"\"\"\n    Often it is desirable to prevent the mutation of\n    a default dict after its initial construction, such\n    as to prevent mutation during iteration.\n\n    >>> dd = FreezableDefaultDict(list)\n    >>> dd[0].append('1')\n    >>> dd.freeze()\n    >>> dd[1]\n    []\n    >>> len(dd)\n    1\n    \"\"\"\n\n    def __missing__(self, key):\n        return getattr(self, '_frozen', super().__missing__)(key)\n\n    def freeze(self):\n        self._frozen = lambda key: self.default_factory()\n\n\nclass Pair(collections.namedtuple('Pair', 'name value')):\n    @classmethod\n    def parse(cls, text):\n        return cls(*map(str.strip, text.split(\"=\", 1)))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/importlib_metadata/_compat.py","size":1314,"sha1":"e97fb31d48e8848820559c72fe8404097381b90f","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\nimport platform\n\n\n__all__ = ['install', 'NullFinder']\n\n\ndef install(cls):\n    \"\"\"\n    Class decorator for installation on sys.meta_path.\n\n    Adds the backport DistributionFinder to sys.meta_path and\n    attempts to disable the finder functionality of the stdlib\n    DistributionFinder.\n    \"\"\"\n    sys.meta_path.append(cls())\n    disable_stdlib_finder()\n    return cls\n\n\ndef disable_stdlib_finder():\n    \"\"\"\n    Give the backport primacy for discovering path-based distributions\n    by monkey-patching the stdlib O_O.\n\n    See #91 for more background for rationale on this sketchy\n    behavior.\n    \"\"\"\n\n    def matches(finder):\n        return getattr(\n            finder, '__module__', None\n        ) == '_frozen_importlib_external' and hasattr(finder, 'find_distributions')\n\n    for finder in filter(matches, sys.meta_path):  # pragma: nocover\n        del finder.find_distributions\n\n\nclass NullFinder:\n    \"\"\"\n    A \"Finder\" (aka \"MetaPathFinder\") that never finds any modules,\n    but may find distributions.\n    \"\"\"\n\n    @staticmethod\n    def find_spec(*args, **kwargs):\n        return None\n\n\ndef pypy_partial(val):\n    \"\"\"\n    Adjust for variable stacklevel on partial under PyPy.\n\n    Workaround for #327.\n    \"\"\"\n    is_pypy = platform.python_implementation() == 'PyPy'\n    return val + is_pypy\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/importlib_metadata/_functools.py","size":2895,"sha1":"69d5ecd15436ac8a0774dd5c4388f32425a9e128","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import types\nimport functools\n\n\n# from jaraco.functools 3.3\ndef method_cache(method, cache_wrapper=None):\n    \"\"\"\n    Wrap lru_cache to support storing the cache data in the object instances.\n\n    Abstracts the common paradigm where the method explicitly saves an\n    underscore-prefixed protected property on first call and returns that\n    subsequently.\n\n    >>> class MyClass:\n    ...     calls = 0\n    ...\n    ...     @method_cache\n    ...     def method(self, value):\n    ...         self.calls += 1\n    ...         return value\n\n    >>> a = MyClass()\n    >>> a.method(3)\n    3\n    >>> for x in range(75):\n    ...     res = a.method(x)\n    >>> a.calls\n    75\n\n    Note that the apparent behavior will be exactly like that of lru_cache\n    except that the cache is stored on each instance, so values in one\n    instance will not flush values from another, and when an instance is\n    deleted, so are the cached values for that instance.\n\n    >>> b = MyClass()\n    >>> for x in range(35):\n    ...     res = b.method(x)\n    >>> b.calls\n    35\n    >>> a.method(0)\n    0\n    >>> a.calls\n    75\n\n    Note that if method had been decorated with ``functools.lru_cache()``,\n    a.calls would have been 76 (due to the cached value of 0 having been\n    flushed by the 'b' instance).\n\n    Clear the cache with ``.cache_clear()``\n\n    >>> a.method.cache_clear()\n\n    Same for a method that hasn't yet been called.\n\n    >>> c = MyClass()\n    >>> c.method.cache_clear()\n\n    Another cache wrapper may be supplied:\n\n    >>> cache = functools.lru_cache(maxsize=2)\n    >>> MyClass.method2 = method_cache(lambda self: 3, cache_wrapper=cache)\n    >>> a = MyClass()\n    >>> a.method2()\n    3\n\n    Caution - do not subsequently wrap the method with another decorator, such\n    as ``@property``, which changes the semantics of the function.\n\n    See also\n    http://code.activestate.com/recipes/577452-a-memoize-decorator-for-instance-methods/\n    for another implementation and additional justification.\n    \"\"\"\n    cache_wrapper = cache_wrapper or functools.lru_cache()\n\n    def wrapper(self, *args, **kwargs):\n        # it's the first call, replace the method with a cached, bound method\n        bound_method = types.MethodType(method, self)\n        cached_method = cache_wrapper(bound_method)\n        setattr(self, method.__name__, cached_method)\n        return cached_method(*args, **kwargs)\n\n    # Support cache clear even before cache has been created.\n    wrapper.cache_clear = lambda: None\n\n    return wrapper\n\n\n# From jaraco.functools 3.3\ndef pass_none(func):\n    \"\"\"\n    Wrap func so it's not called if its first param is None\n\n    >>> print_text = pass_none(print)\n    >>> print_text('text')\n    text\n    >>> print_text(None)\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(param, *args, **kwargs):\n        if param is not None:\n            return func(param, *args, **kwargs)\n\n    return wrapper\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/importlib_metadata/_itertools.py","size":2068,"sha1":"40b1034a8bbb3f59720230c6d05c239977b37a11","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from itertools import filterfalse\n\n\ndef unique_everseen(iterable, key=None):\n    \"List unique elements, preserving order. Remember all elements ever seen.\"\n    # unique_everseen('AAAABBBCCDAABBB') --> A B C D\n    # unique_everseen('ABBCcAD', str.lower) --> A B C D\n    seen = set()\n    seen_add = seen.add\n    if key is None:\n        for element in filterfalse(seen.__contains__, iterable):\n            seen_add(element)\n            yield element\n    else:\n        for element in iterable:\n            k = key(element)\n            if k not in seen:\n                seen_add(k)\n                yield element\n\n\n# copied from more_itertools 8.8\ndef always_iterable(obj, base_type=(str, bytes)):\n    \"\"\"If *obj* is iterable, return an iterator over its items::\n\n        >>> obj = (1, 2, 3)\n        >>> list(always_iterable(obj))\n        [1, 2, 3]\n\n    If *obj* is not iterable, return a one-item iterable containing *obj*::\n\n        >>> obj = 1\n        >>> list(always_iterable(obj))\n        [1]\n\n    If *obj* is ``None``, return an empty iterable:\n\n        >>> obj = None\n        >>> list(always_iterable(None))\n        []\n\n    By default, binary and text strings are not considered iterable::\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj))\n        ['foo']\n\n    If *base_type* is set, objects for which ``isinstance(obj, base_type)``\n    returns ``True`` won't be considered iterable.\n\n        >>> obj = {'a': 1}\n        >>> list(always_iterable(obj))  # Iterate over the dict's keys\n        ['a']\n        >>> list(always_iterable(obj, base_type=dict))  # Treat dicts as a unit\n        [{'a': 1}]\n\n    Set *base_type* to ``None`` to avoid any special handling and treat objects\n    Python considers iterable as iterable:\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj, base_type=None))\n        ['f', 'o', 'o']\n    \"\"\"\n    if obj is None:\n        return iter(())\n\n    if (base_type is not None) and isinstance(obj, base_type):\n        return iter((obj,))\n\n    try:\n        return iter(obj)\n    except TypeError:\n        return iter((obj,))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/importlib_metadata/_meta.py","size":1801,"sha1":"d4ae900cf941e43dd6b4e591a4f756f70d5b3506","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport os\nfrom typing import Protocol\nfrom typing import Any, Dict, Iterator, List, Optional, TypeVar, Union, overload\n\n\n_T = TypeVar(\"_T\")\n\n\nclass PackageMetadata(Protocol):\n    def __len__(self) -> int: ...  # pragma: no cover\n\n    def __contains__(self, item: str) -> bool: ...  # pragma: no cover\n\n    def __getitem__(self, key: str) -> str: ...  # pragma: no cover\n\n    def __iter__(self) -> Iterator[str]: ...  # pragma: no cover\n\n    @overload\n    def get(\n        self, name: str, failobj: None = None\n    ) -> Optional[str]: ...  # pragma: no cover\n\n    @overload\n    def get(self, name: str, failobj: _T) -> Union[str, _T]: ...  # pragma: no cover\n\n    # overload per python/importlib_metadata#435\n    @overload\n    def get_all(\n        self, name: str, failobj: None = None\n    ) -> Optional[List[Any]]: ...  # pragma: no cover\n\n    @overload\n    def get_all(self, name: str, failobj: _T) -> Union[List[Any], _T]:\n        \"\"\"\n        Return all values associated with a possibly multi-valued key.\n        \"\"\"\n\n    @property\n    def json(self) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        A JSON-compatible form of the metadata.\n        \"\"\"\n\n\nclass SimplePath(Protocol):\n    \"\"\"\n    A minimal subset of pathlib.Path required by Distribution.\n    \"\"\"\n\n    def joinpath(\n        self, other: Union[str, os.PathLike[str]]\n    ) -> SimplePath: ...  # pragma: no cover\n\n    def __truediv__(\n        self, other: Union[str, os.PathLike[str]]\n    ) -> SimplePath: ...  # pragma: no cover\n\n    @property\n    def parent(self) -> SimplePath: ...  # pragma: no cover\n\n    def read_text(self, encoding=None) -> str: ...  # pragma: no cover\n\n    def read_bytes(self) -> bytes: ...  # pragma: no cover\n\n    def exists(self) -> bool: ...  # pragma: no cover\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/importlib_metadata/_text.py","size":2166,"sha1":"5706a824d57d684b2985ee3a05a77ac152f55ebc","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import re\n\nfrom ._functools import method_cache\n\n\n# from jaraco.text 3.5\nclass FoldedCase(str):\n    \"\"\"\n    A case insensitive string class; behaves just like str\n    except compares equal when the only variation is case.\n\n    >>> s = FoldedCase('hello world')\n\n    >>> s == 'Hello World'\n    True\n\n    >>> 'Hello World' == s\n    True\n\n    >>> s != 'Hello World'\n    False\n\n    >>> s.index('O')\n    4\n\n    >>> s.split('O')\n    ['hell', ' w', 'rld']\n\n    >>> sorted(map(FoldedCase, ['GAMMA', 'alpha', 'Beta']))\n    ['alpha', 'Beta', 'GAMMA']\n\n    Sequence membership is straightforward.\n\n    >>> \"Hello World\" in [s]\n    True\n    >>> s in [\"Hello World\"]\n    True\n\n    You may test for set inclusion, but candidate and elements\n    must both be folded.\n\n    >>> FoldedCase(\"Hello World\") in {s}\n    True\n    >>> s in {FoldedCase(\"Hello World\")}\n    True\n\n    String inclusion works as long as the FoldedCase object\n    is on the right.\n\n    >>> \"hello\" in FoldedCase(\"Hello World\")\n    True\n\n    But not if the FoldedCase object is on the left:\n\n    >>> FoldedCase('hello') in 'Hello World'\n    False\n\n    In that case, use in_:\n\n    >>> FoldedCase('hello').in_('Hello World')\n    True\n\n    >>> FoldedCase('hello') > FoldedCase('Hello')\n    False\n    \"\"\"\n\n    def __lt__(self, other):\n        return self.lower() < other.lower()\n\n    def __gt__(self, other):\n        return self.lower() > other.lower()\n\n    def __eq__(self, other):\n        return self.lower() == other.lower()\n\n    def __ne__(self, other):\n        return self.lower() != other.lower()\n\n    def __hash__(self):\n        return hash(self.lower())\n\n    def __contains__(self, other):\n        return super().lower().__contains__(other.lower())\n\n    def in_(self, other):\n        \"Does self appear in other?\"\n        return self in FoldedCase(other)\n\n    # cache lower since it's likely to be called frequently.\n    @method_cache\n    def lower(self):\n        return super().lower()\n\n    def index(self, sub):\n        return self.lower().index(sub.lower())\n\n    def split(self, splitter=' ', maxsplit=0):\n        pattern = re.compile(re.escape(splitter), re.I)\n        return pattern.split(self, maxsplit)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/importlib_metadata/compat/__init__.py","size":0,"sha1":"da39a3ee5e6b4b0d3255bfef95601890afd80709","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":""},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/importlib_metadata/compat/py311.py","size":608,"sha1":"e39e7c4aa80d89bb0ce892c720e9fd1293d6356b","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import os\nimport pathlib\nimport sys\nimport types\n\n\ndef wrap(path):  # pragma: no cover\n    \"\"\"\n    Workaround for https://github.com/python/cpython/issues/84538\n    to add backward compatibility for walk_up=True.\n    An example affected package is dask-labextension, which uses\n    jupyter-packaging to install JupyterLab javascript files outside\n    of site-packages.\n    \"\"\"\n\n    def relative_to(root, *, walk_up=False):\n        return pathlib.Path(os.path.relpath(path, root))\n\n    return types.SimpleNamespace(relative_to=relative_to)\n\n\nrelative_fix = wrap if sys.version_info < (3, 12) else lambda x: x\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/importlib_metadata/compat/py39.py","size":1102,"sha1":"b8dd03b88b7f92cd220d595db9e98288e5221674","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nCompatibility layer with Python 3.8/3.9\n\"\"\"\n\nfrom typing import TYPE_CHECKING, Any, Optional\n\nif TYPE_CHECKING:  # pragma: no cover\n    # Prevent circular imports on runtime.\n    from .. import Distribution, EntryPoint\nelse:\n    Distribution = EntryPoint = Any\n\n\ndef normalized_name(dist: Distribution) -> Optional[str]:\n    \"\"\"\n    Honor name normalization for distributions that don't provide ``_normalized_name``.\n    \"\"\"\n    try:\n        return dist._normalized_name\n    except AttributeError:\n        from .. import Prepared  # -> delay to prevent circular imports.\n\n        return Prepared.normalize(getattr(dist, \"name\", None) or dist.metadata['Name'])\n\n\ndef ep_matches(ep: EntryPoint, **params) -> bool:\n    \"\"\"\n    Workaround for ``EntryPoint`` objects without the ``matches`` method.\n    \"\"\"\n    try:\n        return ep.matches(**params)\n    except AttributeError:\n        from .. import EntryPoint  # -> delay to prevent circular imports.\n\n        # Reconstruct the EntryPoint object to make sure it is compatible.\n        return EntryPoint(ep.name, ep.value, ep.group).matches(**params)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/importlib_metadata/diagnose.py","size":379,"sha1":"c2100959070616fb6e5e753e423870f337971506","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\n\nfrom . import Distribution\n\n\ndef inspect(path):\n    print(\"Inspecting\", path)\n    dists = list(Distribution.discover(path=[path]))\n    if not dists:\n        return\n    print(\"Found\", len(dists), \"packages:\", end=' ')\n    print(', '.join(dist.name for dist in dists))\n\n\ndef run():\n    for path in sys.path:\n        inspect(path)\n\n\nif __name__ == '__main__':\n    run()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/inflect/__init__.py","size":103796,"sha1":"5801d14964c392466422b0bfee3ddaf356511c29","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\ninflect: english language inflection\n - correctly generate plurals, ordinals, indefinite articles\n - convert numbers to words\n\nCopyright (C) 2010 Paul Dyson\n\nBased upon the Perl module\n`Lingua::EN::Inflect <https://metacpan.org/pod/Lingua::EN::Inflect>`_.\n\nmethods:\n    classical inflect\n    plural plural_noun plural_verb plural_adj singular_noun no num a an\n    compare compare_nouns compare_verbs compare_adjs\n    present_participle\n    ordinal\n    number_to_words\n    join\n    defnoun defverb defadj defa defan\n\nINFLECTIONS:\n    classical inflect\n    plural plural_noun plural_verb plural_adj singular_noun compare\n    no num a an present_participle\n\nPLURALS:\n    classical inflect\n    plural plural_noun plural_verb plural_adj singular_noun no num\n    compare compare_nouns compare_verbs compare_adjs\n\nCOMPARISONS:\n    classical\n    compare compare_nouns compare_verbs compare_adjs\n\nARTICLES:\n    classical inflect num a an\n\nNUMERICAL:\n    ordinal number_to_words\n\nUSER_DEFINED:\n    defnoun defverb defadj defa defan\n\nExceptions:\n UnknownClassicalModeError\n BadNumValueError\n BadChunkingOptionError\n NumOutOfRangeError\n BadUserDefinedPatternError\n BadRcFileError\n BadGenderError\n\n\"\"\"\n\nfrom __future__ import annotations\n\nimport ast\nimport collections\nimport contextlib\nimport functools\nimport itertools\nimport re\nfrom numbers import Number\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    Dict,\n    Iterable,\n    List,\n    Literal,\n    Match,\n    Optional,\n    Sequence,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom more_itertools import windowed_complete\nfrom typeguard import typechecked\n\nfrom .compat.py38 import Annotated\n\n\nclass UnknownClassicalModeError(Exception):\n    pass\n\n\nclass BadNumValueError(Exception):\n    pass\n\n\nclass BadChunkingOptionError(Exception):\n    pass\n\n\nclass NumOutOfRangeError(Exception):\n    pass\n\n\nclass BadUserDefinedPatternError(Exception):\n    pass\n\n\nclass BadRcFileError(Exception):\n    pass\n\n\nclass BadGenderError(Exception):\n    pass\n\n\ndef enclose(s: str) -> str:\n    return f\"(?:{s})\"\n\n\ndef joinstem(cutpoint: Optional[int] = 0, words: Optional[Iterable[str]] = None) -> str:\n    \"\"\"\n    Join stem of each word in words into a string for regex.\n\n    Each word is truncated at cutpoint.\n\n    Cutpoint is usually negative indicating the number of letters to remove\n    from the end of each word.\n\n    >>> joinstem(-2, [\"ephemeris\", \"iris\", \".*itis\"])\n    '(?:ephemer|ir|.*it)'\n\n    >>> joinstem(None, [\"ephemeris\"])\n    '(?:ephemeris)'\n\n    >>> joinstem(5, None)\n    '(?:)'\n    \"\"\"\n    return enclose(\"|\".join(w[:cutpoint] for w in words or []))\n\n\ndef bysize(words: Iterable[str]) -> Dict[int, set]:\n    \"\"\"\n    From a list of words, return a dict of sets sorted by word length.\n\n    >>> words = ['ant', 'cat', 'dog', 'pig', 'frog', 'goat', 'horse', 'elephant']\n    >>> ret = bysize(words)\n    >>> sorted(ret[3])\n    ['ant', 'cat', 'dog', 'pig']\n    >>> ret[5]\n    {'horse'}\n    \"\"\"\n    res: Dict[int, set] = collections.defaultdict(set)\n    for w in words:\n        res[len(w)].add(w)\n    return res\n\n\ndef make_pl_si_lists(\n    lst: Iterable[str],\n    plending: str,\n    siendingsize: Optional[int],\n    dojoinstem: bool = True,\n):\n    \"\"\"\n    given a list of singular words: lst\n\n    an ending to append to make the plural: plending\n\n    the number of characters to remove from the singular\n    before appending plending: siendingsize\n\n    a flag whether to create a joinstem: dojoinstem\n\n    return:\n    a list of pluralised words: si_list (called si because this is what you need to\n    look for to make the singular)\n\n    the pluralised words as a dict of sets sorted by word length: si_bysize\n    the singular words as a dict of sets sorted by word length: pl_bysize\n    if dojoinstem is True: a regular expression that matches any of the stems: stem\n    \"\"\"\n    if siendingsize is not None:\n        siendingsize = -siendingsize\n    si_list = [w[:siendingsize] + plending for w in lst]\n    pl_bysize = bysize(lst)\n    si_bysize = bysize(si_list)\n    if dojoinstem:\n        stem = joinstem(siendingsize, lst)\n        return si_list, si_bysize, pl_bysize, stem\n    else:\n        return si_list, si_bysize, pl_bysize\n\n\n# 1. PLURALS\n\npl_sb_irregular_s = {\n    \"corpus\": \"corpuses|corpora\",\n    \"opus\": \"opuses|opera\",\n    \"genus\": \"genera\",\n    \"mythos\": \"mythoi\",\n    \"penis\": \"penises|penes\",\n    \"testis\": \"testes\",\n    \"atlas\": \"atlases|atlantes\",\n    \"yes\": \"yeses\",\n}\n\npl_sb_irregular = {\n    \"child\": \"children\",\n    \"chili\": \"chilis|chilies\",\n    \"brother\": \"brothers|brethren\",\n    \"infinity\": \"infinities|infinity\",\n    \"loaf\": \"loaves\",\n    \"lore\": \"lores|lore\",\n    \"hoof\": \"hoofs|hooves\",\n    \"beef\": \"beefs|beeves\",\n    \"thief\": \"thiefs|thieves\",\n    \"money\": \"monies\",\n    \"mongoose\": \"mongooses\",\n    \"ox\": \"oxen\",\n    \"cow\": \"cows|kine\",\n    \"graffito\": \"graffiti\",\n    \"octopus\": \"octopuses|octopodes\",\n    \"genie\": \"genies|genii\",\n    \"ganglion\": \"ganglions|ganglia\",\n    \"trilby\": \"trilbys\",\n    \"turf\": \"turfs|turves\",\n    \"numen\": \"numina\",\n    \"atman\": \"atmas\",\n    \"occiput\": \"occiputs|occipita\",\n    \"sabretooth\": \"sabretooths\",\n    \"sabertooth\": \"sabertooths\",\n    \"lowlife\": \"lowlifes\",\n    \"flatfoot\": \"flatfoots\",\n    \"tenderfoot\": \"tenderfoots\",\n    \"romany\": \"romanies\",\n    \"jerry\": \"jerries\",\n    \"mary\": \"maries\",\n    \"talouse\": \"talouses\",\n    \"rom\": \"roma\",\n    \"carmen\": \"carmina\",\n}\n\npl_sb_irregular.update(pl_sb_irregular_s)\n# pl_sb_irregular_keys = enclose('|'.join(pl_sb_irregular.keys()))\n\npl_sb_irregular_caps = {\n    \"Romany\": \"Romanies\",\n    \"Jerry\": \"Jerrys\",\n    \"Mary\": \"Marys\",\n    \"Rom\": \"Roma\",\n}\n\npl_sb_irregular_compound = {\"prima donna\": \"prima donnas|prime donne\"}\n\nsi_sb_irregular = {v: k for (k, v) in pl_sb_irregular.items()}\nfor k in list(si_sb_irregular):\n    if \"|\" in k:\n        k1, k2 = k.split(\"|\")\n        si_sb_irregular[k1] = si_sb_irregular[k2] = si_sb_irregular[k]\n        del si_sb_irregular[k]\nsi_sb_irregular_caps = {v: k for (k, v) in pl_sb_irregular_caps.items()}\nsi_sb_irregular_compound = {v: k for (k, v) in pl_sb_irregular_compound.items()}\nfor k in list(si_sb_irregular_compound):\n    if \"|\" in k:\n        k1, k2 = k.split(\"|\")\n        si_sb_irregular_compound[k1] = si_sb_irregular_compound[k2] = (\n            si_sb_irregular_compound[k]\n        )\n        del si_sb_irregular_compound[k]\n\n# si_sb_irregular_keys = enclose('|'.join(si_sb_irregular.keys()))\n\n# Z's that don't double\n\npl_sb_z_zes_list = (\"quartz\", \"topaz\")\npl_sb_z_zes_bysize = bysize(pl_sb_z_zes_list)\n\npl_sb_ze_zes_list = (\"snooze\",)\npl_sb_ze_zes_bysize = bysize(pl_sb_ze_zes_list)\n\n\n# CLASSICAL \"..is\" -> \"..ides\"\n\npl_sb_C_is_ides_complete = [\n    # GENERAL WORDS...\n    \"ephemeris\",\n    \"iris\",\n    \"clitoris\",\n    \"chrysalis\",\n    \"epididymis\",\n]\n\npl_sb_C_is_ides_endings = [\n    # INFLAMATIONS...\n    \"itis\"\n]\n\npl_sb_C_is_ides = joinstem(\n    -2, pl_sb_C_is_ides_complete + [f\".*{w}\" for w in pl_sb_C_is_ides_endings]\n)\n\npl_sb_C_is_ides_list = pl_sb_C_is_ides_complete + pl_sb_C_is_ides_endings\n\n(\n    si_sb_C_is_ides_list,\n    si_sb_C_is_ides_bysize,\n    pl_sb_C_is_ides_bysize,\n) = make_pl_si_lists(pl_sb_C_is_ides_list, \"ides\", 2, dojoinstem=False)\n\n\n# CLASSICAL \"..a\" -> \"..ata\"\n\npl_sb_C_a_ata_list = (\n    \"anathema\",\n    \"bema\",\n    \"carcinoma\",\n    \"charisma\",\n    \"diploma\",\n    \"dogma\",\n    \"drama\",\n    \"edema\",\n    \"enema\",\n    \"enigma\",\n    \"lemma\",\n    \"lymphoma\",\n    \"magma\",\n    \"melisma\",\n    \"miasma\",\n    \"oedema\",\n    \"sarcoma\",\n    \"schema\",\n    \"soma\",\n    \"stigma\",\n    \"stoma\",\n    \"trauma\",\n    \"gumma\",\n    \"pragma\",\n)\n\n(\n    si_sb_C_a_ata_list,\n    si_sb_C_a_ata_bysize,\n    pl_sb_C_a_ata_bysize,\n    pl_sb_C_a_ata,\n) = make_pl_si_lists(pl_sb_C_a_ata_list, \"ata\", 1)\n\n# UNCONDITIONAL \"..a\" -> \"..ae\"\n\npl_sb_U_a_ae_list = (\n    \"alumna\",\n    \"alga\",\n    \"vertebra\",\n    \"persona\",\n    \"vita\",\n)\n(\n    si_sb_U_a_ae_list,\n    si_sb_U_a_ae_bysize,\n    pl_sb_U_a_ae_bysize,\n    pl_sb_U_a_ae,\n) = make_pl_si_lists(pl_sb_U_a_ae_list, \"e\", None)\n\n# CLASSICAL \"..a\" -> \"..ae\"\n\npl_sb_C_a_ae_list = (\n    \"amoeba\",\n    \"antenna\",\n    \"formula\",\n    \"hyperbola\",\n    \"medusa\",\n    \"nebula\",\n    \"parabola\",\n    \"abscissa\",\n    \"hydra\",\n    \"nova\",\n    \"lacuna\",\n    \"aurora\",\n    \"umbra\",\n    \"flora\",\n    \"fauna\",\n)\n(\n    si_sb_C_a_ae_list,\n    si_sb_C_a_ae_bysize,\n    pl_sb_C_a_ae_bysize,\n    pl_sb_C_a_ae,\n) = make_pl_si_lists(pl_sb_C_a_ae_list, \"e\", None)\n\n\n# CLASSICAL \"..en\" -> \"..ina\"\n\npl_sb_C_en_ina_list = (\"stamen\", \"foramen\", \"lumen\")\n\n(\n    si_sb_C_en_ina_list,\n    si_sb_C_en_ina_bysize,\n    pl_sb_C_en_ina_bysize,\n    pl_sb_C_en_ina,\n) = make_pl_si_lists(pl_sb_C_en_ina_list, \"ina\", 2)\n\n\n# UNCONDITIONAL \"..um\" -> \"..a\"\n\npl_sb_U_um_a_list = (\n    \"bacterium\",\n    \"agendum\",\n    \"desideratum\",\n    \"erratum\",\n    \"stratum\",\n    \"datum\",\n    \"ovum\",\n    \"extremum\",\n    \"candelabrum\",\n)\n(\n    si_sb_U_um_a_list,\n    si_sb_U_um_a_bysize,\n    pl_sb_U_um_a_bysize,\n    pl_sb_U_um_a,\n) = make_pl_si_lists(pl_sb_U_um_a_list, \"a\", 2)\n\n# CLASSICAL \"..um\" -> \"..a\"\n\npl_sb_C_um_a_list = (\n    \"maximum\",\n    \"minimum\",\n    \"momentum\",\n    \"optimum\",\n    \"quantum\",\n    \"cranium\",\n    \"curriculum\",\n    \"dictum\",\n    \"phylum\",\n    \"aquarium\",\n    \"compendium\",\n    \"emporium\",\n    \"encomium\",\n    \"gymnasium\",\n    \"honorarium\",\n    \"interregnum\",\n    \"lustrum\",\n    \"memorandum\",\n    \"millennium\",\n    \"rostrum\",\n    \"spectrum\",\n    \"speculum\",\n    \"stadium\",\n    \"trapezium\",\n    \"ultimatum\",\n    \"medium\",\n    \"vacuum\",\n    \"velum\",\n    \"consortium\",\n    \"arboretum\",\n)\n\n(\n    si_sb_C_um_a_list,\n    si_sb_C_um_a_bysize,\n    pl_sb_C_um_a_bysize,\n    pl_sb_C_um_a,\n) = make_pl_si_lists(pl_sb_C_um_a_list, \"a\", 2)\n\n\n# UNCONDITIONAL \"..us\" -> \"i\"\n\npl_sb_U_us_i_list = (\n    \"alumnus\",\n    \"alveolus\",\n    \"bacillus\",\n    \"bronchus\",\n    \"locus\",\n    \"nucleus\",\n    \"stimulus\",\n    \"meniscus\",\n    \"sarcophagus\",\n)\n(\n    si_sb_U_us_i_list,\n    si_sb_U_us_i_bysize,\n    pl_sb_U_us_i_bysize,\n    pl_sb_U_us_i,\n) = make_pl_si_lists(pl_sb_U_us_i_list, \"i\", 2)\n\n# CLASSICAL \"..us\" -> \"..i\"\n\npl_sb_C_us_i_list = (\n    \"focus\",\n    \"radius\",\n    \"genius\",\n    \"incubus\",\n    \"succubus\",\n    \"nimbus\",\n    \"fungus\",\n    \"nucleolus\",\n    \"stylus\",\n    \"torus\",\n    \"umbilicus\",\n    \"uterus\",\n    \"hippopotamus\",\n    \"cactus\",\n)\n\n(\n    si_sb_C_us_i_list,\n    si_sb_C_us_i_bysize,\n    pl_sb_C_us_i_bysize,\n    pl_sb_C_us_i,\n) = make_pl_si_lists(pl_sb_C_us_i_list, \"i\", 2)\n\n\n# CLASSICAL \"..us\" -> \"..us\"  (ASSIMILATED 4TH DECLENSION LATIN NOUNS)\n\npl_sb_C_us_us = (\n    \"status\",\n    \"apparatus\",\n    \"prospectus\",\n    \"sinus\",\n    \"hiatus\",\n    \"impetus\",\n    \"plexus\",\n)\npl_sb_C_us_us_bysize = bysize(pl_sb_C_us_us)\n\n# UNCONDITIONAL \"..on\" -> \"a\"\n\npl_sb_U_on_a_list = (\n    \"criterion\",\n    \"perihelion\",\n    \"aphelion\",\n    \"phenomenon\",\n    \"prolegomenon\",\n    \"noumenon\",\n    \"organon\",\n    \"asyndeton\",\n    \"hyperbaton\",\n)\n(\n    si_sb_U_on_a_list,\n    si_sb_U_on_a_bysize,\n    pl_sb_U_on_a_bysize,\n    pl_sb_U_on_a,\n) = make_pl_si_lists(pl_sb_U_on_a_list, \"a\", 2)\n\n# CLASSICAL \"..on\" -> \"..a\"\n\npl_sb_C_on_a_list = (\"oxymoron\",)\n\n(\n    si_sb_C_on_a_list,\n    si_sb_C_on_a_bysize,\n    pl_sb_C_on_a_bysize,\n    pl_sb_C_on_a,\n) = make_pl_si_lists(pl_sb_C_on_a_list, \"a\", 2)\n\n\n# CLASSICAL \"..o\" -> \"..i\"  (BUT NORMALLY -> \"..os\")\n\npl_sb_C_o_i = [\n    \"solo\",\n    \"soprano\",\n    \"basso\",\n    \"alto\",\n    \"contralto\",\n    \"tempo\",\n    \"piano\",\n    \"virtuoso\",\n]  # list not tuple so can concat for pl_sb_U_o_os\n\npl_sb_C_o_i_bysize = bysize(pl_sb_C_o_i)\nsi_sb_C_o_i_bysize = bysize([f\"{w[:-1]}i\" for w in pl_sb_C_o_i])\n\npl_sb_C_o_i_stems = joinstem(-1, pl_sb_C_o_i)\n\n# ALWAYS \"..o\" -> \"..os\"\n\npl_sb_U_o_os_complete = {\"ado\", \"ISO\", \"NATO\", \"NCO\", \"NGO\", \"oto\"}\nsi_sb_U_o_os_complete = {f\"{w}s\" for w in pl_sb_U_o_os_complete}\n\n\npl_sb_U_o_os_endings = [\n    \"aficionado\",\n    \"aggro\",\n    \"albino\",\n    \"allegro\",\n    \"ammo\",\n    \"Antananarivo\",\n    \"archipelago\",\n    \"armadillo\",\n    \"auto\",\n    \"avocado\",\n    \"Bamako\",\n    \"Barquisimeto\",\n    \"bimbo\",\n    \"bingo\",\n    \"Biro\",\n    \"bolero\",\n    \"Bolzano\",\n    \"bongo\",\n    \"Boto\",\n    \"burro\",\n    \"Cairo\",\n    \"canto\",\n    \"cappuccino\",\n    \"casino\",\n    \"cello\",\n    \"Chicago\",\n    \"Chimango\",\n    \"cilantro\",\n    \"cochito\",\n    \"coco\",\n    \"Colombo\",\n    \"Colorado\",\n    \"commando\",\n    \"concertino\",\n    \"contango\",\n    \"credo\",\n    \"crescendo\",\n    \"cyano\",\n    \"demo\",\n    \"ditto\",\n    \"Draco\",\n    \"dynamo\",\n    \"embryo\",\n    \"Esperanto\",\n    \"espresso\",\n    \"euro\",\n    \"falsetto\",\n    \"Faro\",\n    \"fiasco\",\n    \"Filipino\",\n    \"flamenco\",\n    \"furioso\",\n    \"generalissimo\",\n    \"Gestapo\",\n    \"ghetto\",\n    \"gigolo\",\n    \"gizmo\",\n    \"Greensboro\",\n    \"gringo\",\n    \"Guaiabero\",\n    \"guano\",\n    \"gumbo\",\n    \"gyro\",\n    \"hairdo\",\n    \"hippo\",\n    \"Idaho\",\n    \"impetigo\",\n    \"inferno\",\n    \"info\",\n    \"intermezzo\",\n    \"intertrigo\",\n    \"Iquico\",\n    \"jumbo\",\n    \"junto\",\n    \"Kakapo\",\n    \"kilo\",\n    \"Kinkimavo\",\n    \"Kokako\",\n    \"Kosovo\",\n    \"Lesotho\",\n    \"libero\",\n    \"libido\",\n    \"libretto\",\n    \"lido\",\n    \"Lilo\",\n    \"limbo\",\n    \"limo\",\n    \"lineno\",\n    \"lingo\",\n    \"lino\",\n    \"livedo\",\n    \"loco\",\n    \"logo\",\n    \"lumbago\",\n    \"macho\",\n    \"macro\",\n    \"mafioso\",\n    \"magneto\",\n    \"magnifico\",\n    \"Majuro\",\n    \"Malabo\",\n    \"manifesto\",\n    \"Maputo\",\n    \"Maracaibo\",\n    \"medico\",\n    \"memo\",\n    \"metro\",\n    \"Mexico\",\n    \"micro\",\n    \"Milano\",\n    \"Monaco\",\n    \"mono\",\n    \"Montenegro\",\n    \"Morocco\",\n    \"Muqdisho\",\n    \"myo\",\n    \"neutrino\",\n    \"Ningbo\",\n    \"octavo\",\n    \"oregano\",\n    \"Orinoco\",\n    \"Orlando\",\n    \"Oslo\",\n    \"panto\",\n    \"Paramaribo\",\n    \"Pardusco\",\n    \"pedalo\",\n    \"photo\",\n    \"pimento\",\n    \"pinto\",\n    \"pleco\",\n    \"Pluto\",\n    \"pogo\",\n    \"polo\",\n    \"poncho\",\n    \"Porto-Novo\",\n    \"Porto\",\n    \"pro\",\n    \"psycho\",\n    \"pueblo\",\n    \"quarto\",\n    \"Quito\",\n    \"repo\",\n    \"rhino\",\n    \"risotto\",\n    \"rococo\",\n    \"rondo\",\n    \"Sacramento\",\n    \"saddo\",\n    \"sago\",\n    \"salvo\",\n    \"Santiago\",\n    \"Sapporo\",\n    \"Sarajevo\",\n    \"scherzando\",\n    \"scherzo\",\n    \"silo\",\n    \"sirocco\",\n    \"sombrero\",\n    \"staccato\",\n    \"sterno\",\n    \"stucco\",\n    \"stylo\",\n    \"sumo\",\n    \"Taiko\",\n    \"techno\",\n    \"terrazzo\",\n    \"testudo\",\n    \"timpano\",\n    \"tiro\",\n    \"tobacco\",\n    \"Togo\",\n    \"Tokyo\",\n    \"torero\",\n    \"Torino\",\n    \"Toronto\",\n    \"torso\",\n    \"tremolo\",\n    \"typo\",\n    \"tyro\",\n    \"ufo\",\n    \"UNESCO\",\n    \"vaquero\",\n    \"vermicello\",\n    \"verso\",\n    \"vibrato\",\n    \"violoncello\",\n    \"Virgo\",\n    \"weirdo\",\n    \"WHO\",\n    \"WTO\",\n    \"Yamoussoukro\",\n    \"yo-yo\",\n    \"zero\",\n    \"Zibo\",\n] + pl_sb_C_o_i\n\npl_sb_U_o_os_bysize = bysize(pl_sb_U_o_os_endings)\nsi_sb_U_o_os_bysize = bysize([f\"{w}s\" for w in pl_sb_U_o_os_endings])\n\n\n# UNCONDITIONAL \"..ch\" -> \"..chs\"\n\npl_sb_U_ch_chs_list = (\"czech\", \"eunuch\", \"stomach\")\n\n(\n    si_sb_U_ch_chs_list,\n    si_sb_U_ch_chs_bysize,\n    pl_sb_U_ch_chs_bysize,\n    pl_sb_U_ch_chs,\n) = make_pl_si_lists(pl_sb_U_ch_chs_list, \"s\", None)\n\n\n# UNCONDITIONAL \"..[ei]x\" -> \"..ices\"\n\npl_sb_U_ex_ices_list = (\"codex\", \"murex\", \"silex\")\n(\n    si_sb_U_ex_ices_list,\n    si_sb_U_ex_ices_bysize,\n    pl_sb_U_ex_ices_bysize,\n    pl_sb_U_ex_ices,\n) = make_pl_si_lists(pl_sb_U_ex_ices_list, \"ices\", 2)\n\npl_sb_U_ix_ices_list = (\"radix\", \"helix\")\n(\n    si_sb_U_ix_ices_list,\n    si_sb_U_ix_ices_bysize,\n    pl_sb_U_ix_ices_bysize,\n    pl_sb_U_ix_ices,\n) = make_pl_si_lists(pl_sb_U_ix_ices_list, \"ices\", 2)\n\n# CLASSICAL \"..[ei]x\" -> \"..ices\"\n\npl_sb_C_ex_ices_list = (\n    \"vortex\",\n    \"vertex\",\n    \"cortex\",\n    \"latex\",\n    \"pontifex\",\n    \"apex\",\n    \"index\",\n    \"simplex\",\n)\n\n(\n    si_sb_C_ex_ices_list,\n    si_sb_C_ex_ices_bysize,\n    pl_sb_C_ex_ices_bysize,\n    pl_sb_C_ex_ices,\n) = make_pl_si_lists(pl_sb_C_ex_ices_list, \"ices\", 2)\n\n\npl_sb_C_ix_ices_list = (\"appendix\",)\n\n(\n    si_sb_C_ix_ices_list,\n    si_sb_C_ix_ices_bysize,\n    pl_sb_C_ix_ices_bysize,\n    pl_sb_C_ix_ices,\n) = make_pl_si_lists(pl_sb_C_ix_ices_list, \"ices\", 2)\n\n\n# ARABIC: \"..\" -> \"..i\"\n\npl_sb_C_i_list = (\"afrit\", \"afreet\", \"efreet\")\n\n(si_sb_C_i_list, si_sb_C_i_bysize, pl_sb_C_i_bysize, pl_sb_C_i) = make_pl_si_lists(\n    pl_sb_C_i_list, \"i\", None\n)\n\n\n# HEBREW: \"..\" -> \"..im\"\n\npl_sb_C_im_list = (\"goy\", \"seraph\", \"cherub\")\n\n(si_sb_C_im_list, si_sb_C_im_bysize, pl_sb_C_im_bysize, pl_sb_C_im) = make_pl_si_lists(\n    pl_sb_C_im_list, \"im\", None\n)\n\n\n# UNCONDITIONAL \"..man\" -> \"..mans\"\n\npl_sb_U_man_mans_list = \"\"\"\n    ataman caiman cayman ceriman\n    desman dolman farman harman hetman\n    human leman ottoman shaman talisman\n\"\"\".split()\npl_sb_U_man_mans_caps_list = \"\"\"\n    Alabaman Bahaman Burman German\n    Hiroshiman Liman Nakayaman Norman Oklahoman\n    Panaman Roman Selman Sonaman Tacoman Yakiman\n    Yokohaman Yuman\n\"\"\".split()\n\n(\n    si_sb_U_man_mans_list,\n    si_sb_U_man_mans_bysize,\n    pl_sb_U_man_mans_bysize,\n) = make_pl_si_lists(pl_sb_U_man_mans_list, \"s\", None, dojoinstem=False)\n(\n    si_sb_U_man_mans_caps_list,\n    si_sb_U_man_mans_caps_bysize,\n    pl_sb_U_man_mans_caps_bysize,\n) = make_pl_si_lists(pl_sb_U_man_mans_caps_list, \"s\", None, dojoinstem=False)\n\n# UNCONDITIONAL \"..louse\" -> \"..lice\"\npl_sb_U_louse_lice_list = (\"booklouse\", \"grapelouse\", \"louse\", \"woodlouse\")\n\n(\n    si_sb_U_louse_lice_list,\n    si_sb_U_louse_lice_bysize,\n    pl_sb_U_louse_lice_bysize,\n) = make_pl_si_lists(pl_sb_U_louse_lice_list, \"lice\", 5, dojoinstem=False)\n\npl_sb_uninflected_s_complete = [\n    # PAIRS OR GROUPS SUBSUMED TO A SINGULAR...\n    \"breeches\",\n    \"britches\",\n    \"pajamas\",\n    \"pyjamas\",\n    \"clippers\",\n    \"gallows\",\n    \"hijinks\",\n    \"headquarters\",\n    \"pliers\",\n    \"scissors\",\n    \"testes\",\n    \"herpes\",\n    \"pincers\",\n    \"shears\",\n    \"proceedings\",\n    \"trousers\",\n    # UNASSIMILATED LATIN 4th DECLENSION\n    \"cantus\",\n    \"coitus\",\n    \"nexus\",\n    # RECENT IMPORTS...\n    \"contretemps\",\n    \"corps\",\n    \"debris\",\n    \"siemens\",\n    # DISEASES\n    \"mumps\",\n    # MISCELLANEOUS OTHERS...\n    \"diabetes\",\n    \"jackanapes\",\n    \"series\",\n    \"species\",\n    \"subspecies\",\n    \"rabies\",\n    \"chassis\",\n    \"innings\",\n    \"news\",\n    \"mews\",\n    \"haggis\",\n]\n\npl_sb_uninflected_s_endings = [\n    # RECENT IMPORTS...\n    \"ois\",\n    # DISEASES\n    \"measles\",\n]\n\npl_sb_uninflected_s = pl_sb_uninflected_s_complete + [\n    f\".*{w}\" for w in pl_sb_uninflected_s_endings\n]\n\npl_sb_uninflected_herd = (\n    # DON'T INFLECT IN CLASSICAL MODE, OTHERWISE NORMAL INFLECTION\n    \"wildebeest\",\n    \"swine\",\n    \"eland\",\n    \"bison\",\n    \"buffalo\",\n    \"cattle\",\n    \"elk\",\n    \"rhinoceros\",\n    \"zucchini\",\n    \"caribou\",\n    \"dace\",\n    \"grouse\",\n    \"guinea fowl\",\n    \"guinea-fowl\",\n    \"haddock\",\n    \"hake\",\n    \"halibut\",\n    \"herring\",\n    \"mackerel\",\n    \"pickerel\",\n    \"pike\",\n    \"roe\",\n    \"seed\",\n    \"shad\",\n    \"snipe\",\n    \"teal\",\n    \"turbot\",\n    \"water fowl\",\n    \"water-fowl\",\n)\n\npl_sb_uninflected_complete = [\n    # SOME FISH AND HERD ANIMALS\n    \"tuna\",\n    \"salmon\",\n    \"mackerel\",\n    \"trout\",\n    \"bream\",\n    \"sea-bass\",\n    \"sea bass\",\n    \"carp\",\n    \"cod\",\n    \"flounder\",\n    \"whiting\",\n    \"moose\",\n    # OTHER ODDITIES\n    \"graffiti\",\n    \"djinn\",\n    \"samuri\",\n    \"offspring\",\n    \"pence\",\n    \"quid\",\n    \"hertz\",\n] + pl_sb_uninflected_s_complete\n# SOME WORDS ENDING IN ...s (OFTEN PAIRS TAKEN AS A WHOLE)\n\npl_sb_uninflected_caps = [\n    # ALL NATIONALS ENDING IN -ese\n    \"Portuguese\",\n    \"Amoyese\",\n    \"Borghese\",\n    \"Congoese\",\n    \"Faroese\",\n    \"Foochowese\",\n    \"Genevese\",\n    \"Genoese\",\n    \"Gilbertese\",\n    \"Hottentotese\",\n    \"Kiplingese\",\n    \"Kongoese\",\n    \"Lucchese\",\n    \"Maltese\",\n    \"Nankingese\",\n    \"Niasese\",\n    \"Pekingese\",\n    \"Piedmontese\",\n    \"Pistoiese\",\n    \"Sarawakese\",\n    \"Shavese\",\n    \"Vermontese\",\n    \"Wenchowese\",\n    \"Yengeese\",\n]\n\n\npl_sb_uninflected_endings = [\n    # UNCOUNTABLE NOUNS\n    \"butter\",\n    \"cash\",\n    \"furniture\",\n    \"information\",\n    # SOME FISH AND HERD ANIMALS\n    \"fish\",\n    \"deer\",\n    \"sheep\",\n    # ALL NATIONALS ENDING IN -ese\n    \"nese\",\n    \"rese\",\n    \"lese\",\n    \"mese\",\n    # DISEASES\n    \"pox\",\n    # OTHER ODDITIES\n    \"craft\",\n] + pl_sb_uninflected_s_endings\n# SOME WORDS ENDING IN ...s (OFTEN PAIRS TAKEN AS A WHOLE)\n\n\npl_sb_uninflected_bysize = bysize(pl_sb_uninflected_endings)\n\n\n# SINGULAR WORDS ENDING IN ...s (ALL INFLECT WITH ...es)\n\npl_sb_singular_s_complete = [\n    \"acropolis\",\n    \"aegis\",\n    \"alias\",\n    \"asbestos\",\n    \"bathos\",\n    \"bias\",\n    \"bronchitis\",\n    \"bursitis\",\n    \"caddis\",\n    \"cannabis\",\n    \"canvas\",\n    \"chaos\",\n    \"cosmos\",\n    \"dais\",\n    \"digitalis\",\n    \"epidermis\",\n    \"ethos\",\n    \"eyas\",\n    \"gas\",\n    \"glottis\",\n    \"hubris\",\n    \"ibis\",\n    \"lens\",\n    \"mantis\",\n    \"marquis\",\n    \"metropolis\",\n    \"pathos\",\n    \"pelvis\",\n    \"polis\",\n    \"rhinoceros\",\n    \"sassafras\",\n    \"trellis\",\n] + pl_sb_C_is_ides_complete\n\n\npl_sb_singular_s_endings = [\"ss\", \"us\"] + pl_sb_C_is_ides_endings\n\npl_sb_singular_s_bysize = bysize(pl_sb_singular_s_endings)\n\nsi_sb_singular_s_complete = [f\"{w}es\" for w in pl_sb_singular_s_complete]\nsi_sb_singular_s_endings = [f\"{w}es\" for w in pl_sb_singular_s_endings]\nsi_sb_singular_s_bysize = bysize(si_sb_singular_s_endings)\n\npl_sb_singular_s_es = [\"[A-Z].*es\"]\n\npl_sb_singular_s = enclose(\n    \"|\".join(\n        pl_sb_singular_s_complete\n        + [f\".*{w}\" for w in pl_sb_singular_s_endings]\n        + pl_sb_singular_s_es\n    )\n)\n\n\n# PLURALS ENDING IN uses -> use\n\n\nsi_sb_ois_oi_case = (\"Bolshois\", \"Hanois\")\n\nsi_sb_uses_use_case = (\"Betelgeuses\", \"Duses\", \"Meuses\", \"Syracuses\", \"Toulouses\")\n\nsi_sb_uses_use = (\n    \"abuses\",\n    \"applauses\",\n    \"blouses\",\n    \"carouses\",\n    \"causes\",\n    \"chartreuses\",\n    \"clauses\",\n    \"contuses\",\n    \"douses\",\n    \"excuses\",\n    \"fuses\",\n    \"grouses\",\n    \"hypotenuses\",\n    \"masseuses\",\n    \"menopauses\",\n    \"misuses\",\n    \"muses\",\n    \"overuses\",\n    \"pauses\",\n    \"peruses\",\n    \"profuses\",\n    \"recluses\",\n    \"reuses\",\n    \"ruses\",\n    \"souses\",\n    \"spouses\",\n    \"suffuses\",\n    \"transfuses\",\n    \"uses\",\n)\n\nsi_sb_ies_ie_case = (\n    \"Addies\",\n    \"Aggies\",\n    \"Allies\",\n    \"Amies\",\n    \"Angies\",\n    \"Annies\",\n    \"Annmaries\",\n    \"Archies\",\n    \"Arties\",\n    \"Aussies\",\n    \"Barbies\",\n    \"Barries\",\n    \"Basies\",\n    \"Bennies\",\n    \"Bernies\",\n    \"Berties\",\n    \"Bessies\",\n    \"Betties\",\n    \"Billies\",\n    \"Blondies\",\n    \"Bobbies\",\n    \"Bonnies\",\n    \"Bowies\",\n    \"Brandies\",\n    \"Bries\",\n    \"Brownies\",\n    \"Callies\",\n    \"Carnegies\",\n    \"Carries\",\n    \"Cassies\",\n    \"Charlies\",\n    \"Cheries\",\n    \"Christies\",\n    \"Connies\",\n    \"Curies\",\n    \"Dannies\",\n    \"Debbies\",\n    \"Dixies\",\n    \"Dollies\",\n    \"Donnies\",\n    \"Drambuies\",\n    \"Eddies\",\n    \"Effies\",\n    \"Ellies\",\n    \"Elsies\",\n    \"Eries\",\n    \"Ernies\",\n    \"Essies\",\n    \"Eugenies\",\n    \"Fannies\",\n    \"Flossies\",\n    \"Frankies\",\n    \"Freddies\",\n    \"Gillespies\",\n    \"Goldies\",\n    \"Gracies\",\n    \"Guthries\",\n    \"Hallies\",\n    \"Hatties\",\n    \"Hetties\",\n    \"Hollies\",\n    \"Jackies\",\n    \"Jamies\",\n    \"Janies\",\n    \"Jannies\",\n    \"Jeanies\",\n    \"Jeannies\",\n    \"Jennies\",\n    \"Jessies\",\n    \"Jimmies\",\n    \"Jodies\",\n    \"Johnies\",\n    \"Johnnies\",\n    \"Josies\",\n    \"Julies\",\n    \"Kalgoorlies\",\n    \"Kathies\",\n    \"Katies\",\n    \"Kellies\",\n    \"Kewpies\",\n    \"Kristies\",\n    \"Laramies\",\n    \"Lassies\",\n    \"Lauries\",\n    \"Leslies\",\n    \"Lessies\",\n    \"Lillies\",\n    \"Lizzies\",\n    \"Lonnies\",\n    \"Lories\",\n    \"Lorries\",\n    \"Lotties\",\n    \"Louies\",\n    \"Mackenzies\",\n    \"Maggies\",\n    \"Maisies\",\n    \"Mamies\",\n    \"Marcies\",\n    \"Margies\",\n    \"Maries\",\n    \"Marjories\",\n    \"Matties\",\n    \"McKenzies\",\n    \"Melanies\",\n    \"Mickies\",\n    \"Millies\",\n    \"Minnies\",\n    \"Mollies\",\n    \"Mounties\",\n    \"Nannies\",\n    \"Natalies\",\n    \"Nellies\",\n    \"Netties\",\n    \"Ollies\",\n    \"Ozzies\",\n    \"Pearlies\",\n    \"Pottawatomies\",\n    \"Reggies\",\n    \"Richies\",\n    \"Rickies\",\n    \"Robbies\",\n    \"Ronnies\",\n    \"Rosalies\",\n    \"Rosemaries\",\n    \"Rosies\",\n    \"Roxies\",\n    \"Rushdies\",\n    \"Ruthies\",\n    \"Sadies\",\n    \"Sallies\",\n    \"Sammies\",\n    \"Scotties\",\n    \"Selassies\",\n    \"Sherries\",\n    \"Sophies\",\n    \"Stacies\",\n    \"Stefanies\",\n    \"Stephanies\",\n    \"Stevies\",\n    \"Susies\",\n    \"Sylvies\",\n    \"Tammies\",\n    \"Terries\",\n    \"Tessies\",\n    \"Tommies\",\n    \"Tracies\",\n    \"Trekkies\",\n    \"Valaries\",\n    \"Valeries\",\n    \"Valkyries\",\n    \"Vickies\",\n    \"Virgies\",\n    \"Willies\",\n    \"Winnies\",\n    \"Wylies\",\n    \"Yorkies\",\n)\n\nsi_sb_ies_ie = (\n    \"aeries\",\n    \"baggies\",\n    \"belies\",\n    \"biggies\",\n    \"birdies\",\n    \"bogies\",\n    \"bonnies\",\n    \"boogies\",\n    \"bookies\",\n    \"bourgeoisies\",\n    \"brownies\",\n    \"budgies\",\n    \"caddies\",\n    \"calories\",\n    \"camaraderies\",\n    \"cockamamies\",\n    \"collies\",\n    \"cookies\",\n    \"coolies\",\n    \"cooties\",\n    \"coteries\",\n    \"crappies\",\n    \"curies\",\n    \"cutesies\",\n    \"dogies\",\n    \"eyries\",\n    \"floozies\",\n    \"footsies\",\n    \"freebies\",\n    \"genies\",\n    \"goalies\",\n    \"groupies\",\n    \"hies\",\n    \"jalousies\",\n    \"junkies\",\n    \"kiddies\",\n    \"laddies\",\n    \"lassies\",\n    \"lies\",\n    \"lingeries\",\n    \"magpies\",\n    \"menageries\",\n    \"mommies\",\n    \"movies\",\n    \"neckties\",\n    \"newbies\",\n    \"nighties\",\n    \"oldies\",\n    \"organdies\",\n    \"overlies\",\n    \"pies\",\n    \"pinkies\",\n    \"pixies\",\n    \"potpies\",\n    \"prairies\",\n    \"quickies\",\n    \"reveries\",\n    \"rookies\",\n    \"rotisseries\",\n    \"softies\",\n    \"sorties\",\n    \"species\",\n    \"stymies\",\n    \"sweeties\",\n    \"ties\",\n    \"underlies\",\n    \"unties\",\n    \"veggies\",\n    \"vies\",\n    \"yuppies\",\n    \"zombies\",\n)\n\n\nsi_sb_oes_oe_case = (\n    \"Chloes\",\n    \"Crusoes\",\n    \"Defoes\",\n    \"Faeroes\",\n    \"Ivanhoes\",\n    \"Joes\",\n    \"McEnroes\",\n    \"Moes\",\n    \"Monroes\",\n    \"Noes\",\n    \"Poes\",\n    \"Roscoes\",\n    \"Tahoes\",\n    \"Tippecanoes\",\n    \"Zoes\",\n)\n\nsi_sb_oes_oe = (\n    \"aloes\",\n    \"backhoes\",\n    \"canoes\",\n    \"does\",\n    \"floes\",\n    \"foes\",\n    \"hoes\",\n    \"mistletoes\",\n    \"oboes\",\n    \"pekoes\",\n    \"roes\",\n    \"sloes\",\n    \"throes\",\n    \"tiptoes\",\n    \"toes\",\n    \"woes\",\n)\n\nsi_sb_z_zes = (\"quartzes\", \"topazes\")\n\nsi_sb_zzes_zz = (\"buzzes\", \"fizzes\", \"frizzes\", \"razzes\")\n\nsi_sb_ches_che_case = (\n    \"Andromaches\",\n    \"Apaches\",\n    \"Blanches\",\n    \"Comanches\",\n    \"Nietzsches\",\n    \"Porsches\",\n    \"Roches\",\n)\n\nsi_sb_ches_che = (\n    \"aches\",\n    \"avalanches\",\n    \"backaches\",\n    \"bellyaches\",\n    \"caches\",\n    \"cloches\",\n    \"creches\",\n    \"douches\",\n    \"earaches\",\n    \"fiches\",\n    \"headaches\",\n    \"heartaches\",\n    \"microfiches\",\n    \"niches\",\n    \"pastiches\",\n    \"psyches\",\n    \"quiches\",\n    \"stomachaches\",\n    \"toothaches\",\n    \"tranches\",\n)\n\nsi_sb_xes_xe = (\"annexes\", \"axes\", \"deluxes\", \"pickaxes\")\n\nsi_sb_sses_sse_case = (\"Hesses\", \"Jesses\", \"Larousses\", \"Matisses\")\nsi_sb_sses_sse = (\n    \"bouillabaisses\",\n    \"crevasses\",\n    \"demitasses\",\n    \"impasses\",\n    \"mousses\",\n    \"posses\",\n)\n\nsi_sb_ves_ve_case = (\n    # *[nwl]ives -> [nwl]live\n    \"Clives\",\n    \"Palmolives\",\n)\nsi_sb_ves_ve = (\n    # *[^d]eaves -> eave\n    \"interweaves\",\n    \"weaves\",\n    # *[nwl]ives -> [nwl]live\n    \"olives\",\n    # *[eoa]lves -> [eoa]lve\n    \"bivalves\",\n    \"dissolves\",\n    \"resolves\",\n    \"salves\",\n    \"twelves\",\n    \"valves\",\n)\n\n\nplverb_special_s = enclose(\n    \"|\".join(\n        [pl_sb_singular_s]\n        + pl_sb_uninflected_s\n        + list(pl_sb_irregular_s)\n        + [\"(.*[csx])is\", \"(.*)ceps\", \"[A-Z].*s\"]\n    )\n)\n\n_pl_sb_postfix_adj_defn = (\n    (\"general\", enclose(r\"(?!major|lieutenant|brigadier|adjutant|.*star)\\S+\")),\n    (\"martial\", enclose(\"court\")),\n    (\"force\", enclose(\"pound\")),\n)\n\npl_sb_postfix_adj: Iterable[str] = (\n    enclose(val + f\"(?=(?:-|\\\\s+){key})\") for key, val in _pl_sb_postfix_adj_defn\n)\n\npl_sb_postfix_adj_stems = f\"({'|'.join(pl_sb_postfix_adj)})(.*)\"\n\n\n# PLURAL WORDS ENDING IS es GO TO SINGULAR is\n\nsi_sb_es_is = (\n    \"amanuenses\",\n    \"amniocenteses\",\n    \"analyses\",\n    \"antitheses\",\n    \"apotheoses\",\n    \"arterioscleroses\",\n    \"atheroscleroses\",\n    \"axes\",\n    # 'bases', # bases -> basis\n    \"catalyses\",\n    \"catharses\",\n    \"chasses\",\n    \"cirrhoses\",\n    \"cocces\",\n    \"crises\",\n    \"diagnoses\",\n    \"dialyses\",\n    \"diereses\",\n    \"electrolyses\",\n    \"emphases\",\n    \"exegeses\",\n    \"geneses\",\n    \"halitoses\",\n    \"hydrolyses\",\n    \"hypnoses\",\n    \"hypotheses\",\n    \"hystereses\",\n    \"metamorphoses\",\n    \"metastases\",\n    \"misdiagnoses\",\n    \"mitoses\",\n    \"mononucleoses\",\n    \"narcoses\",\n    \"necroses\",\n    \"nemeses\",\n    \"neuroses\",\n    \"oases\",\n    \"osmoses\",\n    \"osteoporoses\",\n    \"paralyses\",\n    \"parentheses\",\n    \"parthenogeneses\",\n    \"periphrases\",\n    \"photosyntheses\",\n    \"probosces\",\n    \"prognoses\",\n    \"prophylaxes\",\n    \"prostheses\",\n    \"preces\",\n    \"psoriases\",\n    \"psychoanalyses\",\n    \"psychokineses\",\n    \"psychoses\",\n    \"scleroses\",\n    \"scolioses\",\n    \"sepses\",\n    \"silicoses\",\n    \"symbioses\",\n    \"synopses\",\n    \"syntheses\",\n    \"taxes\",\n    \"telekineses\",\n    \"theses\",\n    \"thromboses\",\n    \"tuberculoses\",\n    \"urinalyses\",\n)\n\npl_prep_list = \"\"\"\n    about above across after among around at athwart before behind\n    below beneath beside besides between betwixt beyond but by\n    during except for from in into near of off on onto out over\n    since till to under until unto upon with\"\"\".split()\n\npl_prep_list_da = pl_prep_list + [\"de\", \"du\", \"da\"]\n\npl_prep_bysize = bysize(pl_prep_list_da)\n\npl_prep = enclose(\"|\".join(pl_prep_list_da))\n\npl_sb_prep_dual_compound = rf\"(.*?)((?:-|\\s+)(?:{pl_prep})(?:-|\\s+))a(?:-|\\s+)(.*)\"\n\n\nsingular_pronoun_genders = {\n    \"neuter\",\n    \"feminine\",\n    \"masculine\",\n    \"gender-neutral\",\n    \"feminine or masculine\",\n    \"masculine or feminine\",\n}\n\npl_pron_nom = {\n    # NOMINATIVE    REFLEXIVE\n    \"i\": \"we\",\n    \"myself\": \"ourselves\",\n    \"you\": \"you\",\n    \"yourself\": \"yourselves\",\n    \"she\": \"they\",\n    \"herself\": \"themselves\",\n    \"he\": \"they\",\n    \"himself\": \"themselves\",\n    \"it\": \"they\",\n    \"itself\": \"themselves\",\n    \"they\": \"they\",\n    \"themself\": \"themselves\",\n    #   POSSESSIVE\n    \"mine\": \"ours\",\n    \"yours\": \"yours\",\n    \"hers\": \"theirs\",\n    \"his\": \"theirs\",\n    \"its\": \"theirs\",\n    \"theirs\": \"theirs\",\n}\n\nsi_pron: Dict[str, Dict[str, Union[str, Dict[str, str]]]] = {\n    \"nom\": {v: k for (k, v) in pl_pron_nom.items()}\n}\nsi_pron[\"nom\"][\"we\"] = \"I\"\n\n\npl_pron_acc = {\n    # ACCUSATIVE    REFLEXIVE\n    \"me\": \"us\",\n    \"myself\": \"ourselves\",\n    \"you\": \"you\",\n    \"yourself\": \"yourselves\",\n    \"her\": \"them\",\n    \"herself\": \"themselves\",\n    \"him\": \"them\",\n    \"himself\": \"themselves\",\n    \"it\": \"them\",\n    \"itself\": \"themselves\",\n    \"them\": \"them\",\n    \"themself\": \"themselves\",\n}\n\npl_pron_acc_keys = enclose(\"|\".join(pl_pron_acc))\npl_pron_acc_keys_bysize = bysize(pl_pron_acc)\n\nsi_pron[\"acc\"] = {v: k for (k, v) in pl_pron_acc.items()}\n\nfor _thecase, _plur, _gend, _sing in (\n    (\"nom\", \"they\", \"neuter\", \"it\"),\n    (\"nom\", \"they\", \"feminine\", \"she\"),\n    (\"nom\", \"they\", \"masculine\", \"he\"),\n    (\"nom\", \"they\", \"gender-neutral\", \"they\"),\n    (\"nom\", \"they\", \"feminine or masculine\", \"she or he\"),\n    (\"nom\", \"they\", \"masculine or feminine\", \"he or she\"),\n    (\"nom\", \"themselves\", \"neuter\", \"itself\"),\n    (\"nom\", \"themselves\", \"feminine\", \"herself\"),\n    (\"nom\", \"themselves\", \"masculine\", \"himself\"),\n    (\"nom\", \"themselves\", \"gender-neutral\", \"themself\"),\n    (\"nom\", \"themselves\", \"feminine or masculine\", \"herself or himself\"),\n    (\"nom\", \"themselves\", \"masculine or feminine\", \"himself or herself\"),\n    (\"nom\", \"theirs\", \"neuter\", \"its\"),\n    (\"nom\", \"theirs\", \"feminine\", \"hers\"),\n    (\"nom\", \"theirs\", \"masculine\", \"his\"),\n    (\"nom\", \"theirs\", \"gender-neutral\", \"theirs\"),\n    (\"nom\", \"theirs\", \"feminine or masculine\", \"hers or his\"),\n    (\"nom\", \"theirs\", \"masculine or feminine\", \"his or hers\"),\n    (\"acc\", \"them\", \"neuter\", \"it\"),\n    (\"acc\", \"them\", \"feminine\", \"her\"),\n    (\"acc\", \"them\", \"masculine\", \"him\"),\n    (\"acc\", \"them\", \"gender-neutral\", \"them\"),\n    (\"acc\", \"them\", \"feminine or masculine\", \"her or him\"),\n    (\"acc\", \"them\", \"masculine or feminine\", \"him or her\"),\n    (\"acc\", \"themselves\", \"neuter\", \"itself\"),\n    (\"acc\", \"themselves\", \"feminine\", \"herself\"),\n    (\"acc\", \"themselves\", \"masculine\", \"himself\"),\n    (\"acc\", \"themselves\", \"gender-neutral\", \"themself\"),\n    (\"acc\", \"themselves\", \"feminine or masculine\", \"herself or himself\"),\n    (\"acc\", \"themselves\", \"masculine or feminine\", \"himself or herself\"),\n):\n    try:\n        si_pron[_thecase][_plur][_gend] = _sing  # type: ignore\n    except TypeError:\n        si_pron[_thecase][_plur] = {}\n        si_pron[_thecase][_plur][_gend] = _sing  # type: ignore\n\n\nsi_pron_acc_keys = enclose(\"|\".join(si_pron[\"acc\"]))\nsi_pron_acc_keys_bysize = bysize(si_pron[\"acc\"])\n\n\ndef get_si_pron(thecase, word, gender) -> str:\n    try:\n        sing = si_pron[thecase][word]\n    except KeyError:\n        raise  # not a pronoun\n    try:\n        return sing[gender]  # has several types due to gender\n    except TypeError:\n        return cast(str, sing)  # answer independent of gender\n\n\n# These dictionaries group verbs by first, second and third person\n# conjugations.\n\nplverb_irregular_pres = {\n    \"am\": \"are\",\n    \"are\": \"are\",\n    \"is\": \"are\",\n    \"was\": \"were\",\n    \"were\": \"were\",\n    \"have\": \"have\",\n    \"has\": \"have\",\n    \"do\": \"do\",\n    \"does\": \"do\",\n}\n\nplverb_ambiguous_pres = {\n    \"act\": \"act\",\n    \"acts\": \"act\",\n    \"blame\": \"blame\",\n    \"blames\": \"blame\",\n    \"can\": \"can\",\n    \"must\": \"must\",\n    \"fly\": \"fly\",\n    \"flies\": \"fly\",\n    \"copy\": \"copy\",\n    \"copies\": \"copy\",\n    \"drink\": \"drink\",\n    \"drinks\": \"drink\",\n    \"fight\": \"fight\",\n    \"fights\": \"fight\",\n    \"fire\": \"fire\",\n    \"fires\": \"fire\",\n    \"like\": \"like\",\n    \"likes\": \"like\",\n    \"look\": \"look\",\n    \"looks\": \"look\",\n    \"make\": \"make\",\n    \"makes\": \"make\",\n    \"reach\": \"reach\",\n    \"reaches\": \"reach\",\n    \"run\": \"run\",\n    \"runs\": \"run\",\n    \"sink\": \"sink\",\n    \"sinks\": \"sink\",\n    \"sleep\": \"sleep\",\n    \"sleeps\": \"sleep\",\n    \"view\": \"view\",\n    \"views\": \"view\",\n}\n\nplverb_ambiguous_pres_keys = re.compile(\n    rf\"^({enclose('|'.join(plverb_ambiguous_pres))})((\\s.*)?)$\", re.IGNORECASE\n)\n\n\nplverb_irregular_non_pres = (\n    \"did\",\n    \"had\",\n    \"ate\",\n    \"made\",\n    \"put\",\n    \"spent\",\n    \"fought\",\n    \"sank\",\n    \"gave\",\n    \"sought\",\n    \"shall\",\n    \"could\",\n    \"ought\",\n    \"should\",\n)\n\nplverb_ambiguous_non_pres = re.compile(\n    r\"^((?:thought|saw|bent|will|might|cut))((\\s.*)?)$\", re.IGNORECASE\n)\n\n# \"..oes\" -> \"..oe\" (the rest are \"..oes\" -> \"o\")\n\npl_v_oes_oe = (\"canoes\", \"floes\", \"oboes\", \"roes\", \"throes\", \"woes\")\npl_v_oes_oe_endings_size4 = (\"hoes\", \"toes\")\npl_v_oes_oe_endings_size5 = (\"shoes\",)\n\n\npl_count_zero = (\"0\", \"no\", \"zero\", \"nil\")\n\n\npl_count_one = (\"1\", \"a\", \"an\", \"one\", \"each\", \"every\", \"this\", \"that\")\n\npl_adj_special = {\"a\": \"some\", \"an\": \"some\", \"this\": \"these\", \"that\": \"those\"}\n\npl_adj_special_keys = re.compile(\n    rf\"^({enclose('|'.join(pl_adj_special))})$\", re.IGNORECASE\n)\n\npl_adj_poss = {\n    \"my\": \"our\",\n    \"your\": \"your\",\n    \"its\": \"their\",\n    \"her\": \"their\",\n    \"his\": \"their\",\n    \"their\": \"their\",\n}\n\npl_adj_poss_keys = re.compile(rf\"^({enclose('|'.join(pl_adj_poss))})$\", re.IGNORECASE)\n\n\n# 2. INDEFINITE ARTICLES\n\n# THIS PATTERN MATCHES STRINGS OF CAPITALS STARTING WITH A \"VOWEL-SOUND\"\n# CONSONANT FOLLOWED BY ANOTHER CONSONANT, AND WHICH ARE NOT LIKELY\n# TO BE REAL WORDS (OH, ALL RIGHT THEN, IT'S JUST MAGIC!)\n\nA_abbrev = re.compile(\n    r\"\"\"\n^(?! FJO | [HLMNS]Y.  | RY[EO] | SQU\n  | ( F[LR]? | [HL] | MN? | N | RH? | S[CHKLMNPTVW]? | X(YL)?) [AEIOU])\n[FHLMNRSX][A-Z]\n\"\"\",\n    re.VERBOSE,\n)\n\n# THIS PATTERN CODES THE BEGINNINGS OF ALL ENGLISH WORDS BEGINING WITH A\n# 'y' FOLLOWED BY A CONSONANT. ANY OTHER Y-CONSONANT PREFIX THEREFORE\n# IMPLIES AN ABBREVIATION.\n\nA_y_cons = re.compile(r\"^(y(b[lor]|cl[ea]|fere|gg|p[ios]|rou|tt))\", re.IGNORECASE)\n\n# EXCEPTIONS TO EXCEPTIONS\n\nA_explicit_a = re.compile(r\"^((?:unabomber|unanimous|US))\", re.IGNORECASE)\n\nA_explicit_an = re.compile(\n    r\"^((?:euler|hour(?!i)|heir|honest|hono[ur]|mpeg))\", re.IGNORECASE\n)\n\nA_ordinal_an = re.compile(r\"^([aefhilmnorsx]-?th)\", re.IGNORECASE)\n\nA_ordinal_a = re.compile(r\"^([bcdgjkpqtuvwyz]-?th)\", re.IGNORECASE)\n\n\n# NUMERICAL INFLECTIONS\n\nnth = {\n    0: \"th\",\n    1: \"st\",\n    2: \"nd\",\n    3: \"rd\",\n    4: \"th\",\n    5: \"th\",\n    6: \"th\",\n    7: \"th\",\n    8: \"th\",\n    9: \"th\",\n    11: \"th\",\n    12: \"th\",\n    13: \"th\",\n}\nnth_suff = set(nth.values())\n\nordinal = dict(\n    ty=\"tieth\",\n    one=\"first\",\n    two=\"second\",\n    three=\"third\",\n    five=\"fifth\",\n    eight=\"eighth\",\n    nine=\"ninth\",\n    twelve=\"twelfth\",\n)\n\nordinal_suff = re.compile(rf\"({'|'.join(ordinal)})\\Z\")\n\n\n# NUMBERS\n\nunit = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\nteen = [\n    \"ten\",\n    \"eleven\",\n    \"twelve\",\n    \"thirteen\",\n    \"fourteen\",\n    \"fifteen\",\n    \"sixteen\",\n    \"seventeen\",\n    \"eighteen\",\n    \"nineteen\",\n]\nten = [\n    \"\",\n    \"\",\n    \"twenty\",\n    \"thirty\",\n    \"forty\",\n    \"fifty\",\n    \"sixty\",\n    \"seventy\",\n    \"eighty\",\n    \"ninety\",\n]\nmill = [\n    \" \",\n    \" thousand\",\n    \" million\",\n    \" billion\",\n    \" trillion\",\n    \" quadrillion\",\n    \" quintillion\",\n    \" sextillion\",\n    \" septillion\",\n    \" octillion\",\n    \" nonillion\",\n    \" decillion\",\n]\n\n\n# SUPPORT CLASSICAL PLURALIZATIONS\n\ndef_classical = dict(\n    all=False, zero=False, herd=False, names=True, persons=False, ancient=False\n)\n\nall_classical = {k: True for k in def_classical}\nno_classical = {k: False for k in def_classical}\n\n\n# Maps strings to built-in constant types\nstring_to_constant = {\"True\": True, \"False\": False, \"None\": None}\n\n\n# Pre-compiled regular expression objects\nDOLLAR_DIGITS = re.compile(r\"\\$(\\d+)\")\nFUNCTION_CALL = re.compile(r\"((\\w+)\\([^)]*\\)*)\", re.IGNORECASE)\nPARTITION_WORD = re.compile(r\"\\A(\\s*)(.+?)(\\s*)\\Z\")\nPL_SB_POSTFIX_ADJ_STEMS_RE = re.compile(\n    rf\"^(?:{pl_sb_postfix_adj_stems})$\", re.IGNORECASE\n)\nPL_SB_PREP_DUAL_COMPOUND_RE = re.compile(\n    rf\"^(?:{pl_sb_prep_dual_compound})$\", re.IGNORECASE\n)\nDENOMINATOR = re.compile(r\"(?P<denominator>.+)( (per|a) .+)\")\nPLVERB_SPECIAL_S_RE = re.compile(rf\"^({plverb_special_s})$\")\nWHITESPACE = re.compile(r\"\\s\")\nENDS_WITH_S = re.compile(r\"^(.*[^s])s$\", re.IGNORECASE)\nENDS_WITH_APOSTROPHE_S = re.compile(r\"^(.*)'s?$\")\nINDEFINITE_ARTICLE_TEST = re.compile(r\"\\A(\\s*)(?:an?\\s+)?(.+?)(\\s*)\\Z\", re.IGNORECASE)\nSPECIAL_AN = re.compile(r\"^[aefhilmnorsx]$\", re.IGNORECASE)\nSPECIAL_A = re.compile(r\"^[bcdgjkpqtuvwyz]$\", re.IGNORECASE)\nSPECIAL_ABBREV_AN = re.compile(r\"^[aefhilmnorsx][.-]\", re.IGNORECASE)\nSPECIAL_ABBREV_A = re.compile(r\"^[a-z][.-]\", re.IGNORECASE)\nCONSONANTS = re.compile(r\"^[^aeiouy]\", re.IGNORECASE)\nARTICLE_SPECIAL_EU = re.compile(r\"^e[uw]\", re.IGNORECASE)\nARTICLE_SPECIAL_ONCE = re.compile(r\"^onc?e\\b\", re.IGNORECASE)\nARTICLE_SPECIAL_ONETIME = re.compile(r\"^onetime\\b\", re.IGNORECASE)\nARTICLE_SPECIAL_UNIT = re.compile(r\"^uni([^nmd]|mo)\", re.IGNORECASE)\nARTICLE_SPECIAL_UBA = re.compile(r\"^u[bcfghjkqrst][aeiou]\", re.IGNORECASE)\nARTICLE_SPECIAL_UKR = re.compile(r\"^ukr\", re.IGNORECASE)\nSPECIAL_CAPITALS = re.compile(r\"^U[NK][AIEO]?\")\nVOWELS = re.compile(r\"^[aeiou]\", re.IGNORECASE)\n\nDIGIT_GROUP = re.compile(r\"(\\d)\")\nTWO_DIGITS = re.compile(r\"(\\d)(\\d)\")\nTHREE_DIGITS = re.compile(r\"(\\d)(\\d)(\\d)\")\nTHREE_DIGITS_WORD = re.compile(r\"(\\d)(\\d)(\\d)(?=\\D*\\Z)\")\nTWO_DIGITS_WORD = re.compile(r\"(\\d)(\\d)(?=\\D*\\Z)\")\nONE_DIGIT_WORD = re.compile(r\"(\\d)(?=\\D*\\Z)\")\n\nFOUR_DIGIT_COMMA = re.compile(r\"(\\d)(\\d{3}(?:,|\\Z))\")\nNON_DIGIT = re.compile(r\"\\D\")\nWHITESPACES_COMMA = re.compile(r\"\\s+,\")\nCOMMA_WORD = re.compile(r\", (\\S+)\\s+\\Z\")\nWHITESPACES = re.compile(r\"\\s+\")\n\n\nPRESENT_PARTICIPLE_REPLACEMENTS = (\n    (re.compile(r\"ie$\"), r\"y\"),\n    (\n        re.compile(r\"ue$\"),\n        r\"u\",\n    ),  # TODO: isn't ue$ -> u encompassed in the following rule?\n    (re.compile(r\"([auy])e$\"), r\"\\g<1>\"),\n    (re.compile(r\"ski$\"), r\"ski\"),\n    (re.compile(r\"[^b]i$\"), r\"\"),\n    (re.compile(r\"^(are|were)$\"), r\"be\"),\n    (re.compile(r\"^(had)$\"), r\"hav\"),\n    (re.compile(r\"^(hoe)$\"), r\"\\g<1>\"),\n    (re.compile(r\"([^e])e$\"), r\"\\g<1>\"),\n    (re.compile(r\"er$\"), r\"er\"),\n    (re.compile(r\"([^aeiou][aeiouy]([bdgmnprst]))$\"), r\"\\g<1>\\g<2>\"),\n)\n\nDIGIT = re.compile(r\"\\d\")\n\n\nclass Words(str):\n    lowered: str\n    split_: List[str]\n    first: str\n    last: str\n\n    def __init__(self, orig) -> None:\n        self.lowered = self.lower()\n        self.split_ = self.split()\n        self.first = self.split_[0]\n        self.last = self.split_[-1]\n\n\nFalsish = Any  # ideally, falsish would only validate on bool(value) is False\n\n\n_STATIC_TYPE_CHECKING = TYPE_CHECKING\n# ^-- Workaround for typeguard AST manipulation:\n#     https://github.com/agronholm/typeguard/issues/353#issuecomment-1556306554\n\nif _STATIC_TYPE_CHECKING:  # pragma: no cover\n    Word = Annotated[str, \"String with at least 1 character\"]\nelse:\n\n    class _WordMeta(type):  # Too dynamic to be supported by mypy...\n        def __instancecheck__(self, instance: Any) -> bool:\n            return isinstance(instance, str) and len(instance) >= 1\n\n    class Word(metaclass=_WordMeta):  # type: ignore[no-redef]\n        \"\"\"String with at least 1 character\"\"\"\n\n\nclass engine:\n    def __init__(self) -> None:\n        self.classical_dict = def_classical.copy()\n        self.persistent_count: Optional[int] = None\n        self.mill_count = 0\n        self.pl_sb_user_defined: List[Optional[Word]] = []\n        self.pl_v_user_defined: List[Optional[Word]] = []\n        self.pl_adj_user_defined: List[Optional[Word]] = []\n        self.si_sb_user_defined: List[Optional[Word]] = []\n        self.A_a_user_defined: List[Optional[Word]] = []\n        self.thegender = \"neuter\"\n        self.__number_args: Optional[Dict[str, str]] = None\n\n    @property\n    def _number_args(self):\n        return cast(Dict[str, str], self.__number_args)\n\n    @_number_args.setter\n    def _number_args(self, val):\n        self.__number_args = val\n\n    @typechecked\n    def defnoun(self, singular: Optional[Word], plural: Optional[Word]) -> int:\n        \"\"\"\n        Set the noun plural of singular to plural.\n\n        \"\"\"\n        self.checkpat(singular)\n        self.checkpatplural(plural)\n        self.pl_sb_user_defined.extend((singular, plural))\n        self.si_sb_user_defined.extend((plural, singular))\n        return 1\n\n    @typechecked\n    def defverb(\n        self,\n        s1: Optional[Word],\n        p1: Optional[Word],\n        s2: Optional[Word],\n        p2: Optional[Word],\n        s3: Optional[Word],\n        p3: Optional[Word],\n    ) -> int:\n        \"\"\"\n        Set the verb plurals for s1, s2 and s3 to p1, p2 and p3 respectively.\n\n        Where 1, 2 and 3 represent the 1st, 2nd and 3rd person forms of the verb.\n\n        \"\"\"\n        self.checkpat(s1)\n        self.checkpat(s2)\n        self.checkpat(s3)\n        self.checkpatplural(p1)\n        self.checkpatplural(p2)\n        self.checkpatplural(p3)\n        self.pl_v_user_defined.extend((s1, p1, s2, p2, s3, p3))\n        return 1\n\n    @typechecked\n    def defadj(self, singular: Optional[Word], plural: Optional[Word]) -> int:\n        \"\"\"\n        Set the adjective plural of singular to plural.\n\n        \"\"\"\n        self.checkpat(singular)\n        self.checkpatplural(plural)\n        self.pl_adj_user_defined.extend((singular, plural))\n        return 1\n\n    @typechecked\n    def defa(self, pattern: Optional[Word]) -> int:\n        \"\"\"\n        Define the indefinite article as 'a' for words matching pattern.\n\n        \"\"\"\n        self.checkpat(pattern)\n        self.A_a_user_defined.extend((pattern, \"a\"))\n        return 1\n\n    @typechecked\n    def defan(self, pattern: Optional[Word]) -> int:\n        \"\"\"\n        Define the indefinite article as 'an' for words matching pattern.\n\n        \"\"\"\n        self.checkpat(pattern)\n        self.A_a_user_defined.extend((pattern, \"an\"))\n        return 1\n\n    def checkpat(self, pattern: Optional[Word]) -> None:\n        \"\"\"\n        check for errors in a regex pattern\n        \"\"\"\n        if pattern is None:\n            return\n        try:\n            re.match(pattern, \"\")\n        except re.error as err:\n            raise BadUserDefinedPatternError(pattern) from err\n\n    def checkpatplural(self, pattern: Optional[Word]) -> None:\n        \"\"\"\n        check for errors in a regex replace pattern\n        \"\"\"\n        return\n\n    @typechecked\n    def ud_match(self, word: Word, wordlist: Sequence[Optional[Word]]) -> Optional[str]:\n        for i in range(len(wordlist) - 2, -2, -2):  # backwards through even elements\n            mo = re.search(rf\"^{wordlist[i]}$\", word, re.IGNORECASE)\n            if mo:\n                if wordlist[i + 1] is None:\n                    return None\n                pl = DOLLAR_DIGITS.sub(\n                    r\"\\\\1\", cast(Word, wordlist[i + 1])\n                )  # change $n to \\n for expand\n                return mo.expand(pl)\n        return None\n\n    def classical(self, **kwargs) -> None:\n        \"\"\"\n        turn classical mode on and off for various categories\n\n        turn on all classical modes:\n        classical()\n        classical(all=True)\n\n        turn on or off specific claassical modes:\n        e.g.\n        classical(herd=True)\n        classical(names=False)\n\n        By default all classical modes are off except names.\n\n        unknown value in args or key in kwargs raises\n        exception: UnknownClasicalModeError\n\n        \"\"\"\n        if not kwargs:\n            self.classical_dict = all_classical.copy()\n            return\n        if \"all\" in kwargs:\n            if kwargs[\"all\"]:\n                self.classical_dict = all_classical.copy()\n            else:\n                self.classical_dict = no_classical.copy()\n\n        for k, v in kwargs.items():\n            if k in def_classical:\n                self.classical_dict[k] = v\n            else:\n                raise UnknownClassicalModeError\n\n    def num(\n        self, count: Optional[int] = None, show: Optional[int] = None\n    ) -> str:  # (;$count,$show)\n        \"\"\"\n        Set the number to be used in other method calls.\n\n        Returns count.\n\n        Set show to False to return '' instead.\n\n        \"\"\"\n        if count is not None:\n            try:\n                self.persistent_count = int(count)\n            except ValueError as err:\n                raise BadNumValueError from err\n            if (show is None) or show:\n                return str(count)\n        else:\n            self.persistent_count = None\n        return \"\"\n\n    def gender(self, gender: str) -> None:\n        \"\"\"\n        set the gender for the singular of plural pronouns\n\n        can be one of:\n        'neuter'                ('they' -> 'it')\n        'feminine'              ('they' -> 'she')\n        'masculine'             ('they' -> 'he')\n        'gender-neutral'        ('they' -> 'they')\n        'feminine or masculine' ('they' -> 'she or he')\n        'masculine or feminine' ('they' -> 'he or she')\n        \"\"\"\n        if gender in singular_pronoun_genders:\n            self.thegender = gender\n        else:\n            raise BadGenderError\n\n    def _get_value_from_ast(self, obj):\n        \"\"\"\n        Return the value of the ast object.\n        \"\"\"\n        if isinstance(obj, ast.Num):\n            return obj.n\n        elif isinstance(obj, ast.Str):\n            return obj.s\n        elif isinstance(obj, ast.List):\n            return [self._get_value_from_ast(e) for e in obj.elts]\n        elif isinstance(obj, ast.Tuple):\n            return tuple([self._get_value_from_ast(e) for e in obj.elts])\n\n        # None, True and False are NameConstants in Py3.4 and above.\n        elif isinstance(obj, ast.NameConstant):\n            return obj.value\n\n        # Probably passed a variable name.\n        # Or passed a single word without wrapping it in quotes as an argument\n        # ex: p.inflect(\"I plural(see)\") instead of p.inflect(\"I plural('see')\")\n        raise NameError(f\"name '{obj.id}' is not defined\")\n\n    def _string_to_substitute(\n        self, mo: Match, methods_dict: Dict[str, Callable]\n    ) -> str:\n        \"\"\"\n        Return the string to be substituted for the match.\n        \"\"\"\n        matched_text, f_name = mo.groups()\n        # matched_text is the complete match string. e.g. plural_noun(cat)\n        # f_name is the function name. e.g. plural_noun\n\n        # Return matched_text if function name is not in methods_dict\n        if f_name not in methods_dict:\n            return matched_text\n\n        # Parse the matched text\n        a_tree = ast.parse(matched_text)\n\n        # get the args and kwargs from ast objects\n        args_list = [\n            self._get_value_from_ast(a)\n            for a in a_tree.body[0].value.args  # type: ignore[attr-defined]\n        ]\n        kwargs_list = {\n            kw.arg: self._get_value_from_ast(kw.value)\n            for kw in a_tree.body[0].value.keywords  # type: ignore[attr-defined]\n        }\n\n        # Call the corresponding function\n        return methods_dict[f_name](*args_list, **kwargs_list)\n\n    # 0. PERFORM GENERAL INFLECTIONS IN A STRING\n\n    @typechecked\n    def inflect(self, text: Word) -> str:\n        \"\"\"\n        Perform inflections in a string.\n\n        e.g. inflect('The plural of cat is plural(cat)') returns\n        'The plural of cat is cats'\n\n        can use plural, plural_noun, plural_verb, plural_adj,\n        singular_noun, a, an, no, ordinal, number_to_words,\n        and prespart\n\n        \"\"\"\n        save_persistent_count = self.persistent_count\n\n        # Dictionary of allowed methods\n        methods_dict: Dict[str, Callable] = {\n            \"plural\": self.plural,\n            \"plural_adj\": self.plural_adj,\n            \"plural_noun\": self.plural_noun,\n            \"plural_verb\": self.plural_verb,\n            \"singular_noun\": self.singular_noun,\n            \"a\": self.a,\n            \"an\": self.a,\n            \"no\": self.no,\n            \"ordinal\": self.ordinal,\n            \"number_to_words\": self.number_to_words,\n            \"present_participle\": self.present_participle,\n            \"num\": self.num,\n        }\n\n        # Regular expression to find Python's function call syntax\n        output = FUNCTION_CALL.sub(\n            lambda mo: self._string_to_substitute(mo, methods_dict), text\n        )\n        self.persistent_count = save_persistent_count\n        return output\n\n    # ## PLURAL SUBROUTINES\n\n    def postprocess(self, orig: str, inflected) -> str:\n        inflected = str(inflected)\n        if \"|\" in inflected:\n            word_options = inflected.split(\"|\")\n            # When two parts of a noun need to be pluralized\n            if len(word_options[0].split(\" \")) == len(word_options[1].split(\" \")):\n                result = inflected.split(\"|\")[self.classical_dict[\"all\"]].split(\" \")\n            # When only the last part of the noun needs to be pluralized\n            else:\n                result = inflected.split(\" \")\n                for index, word in enumerate(result):\n                    if \"|\" in word:\n                        result[index] = word.split(\"|\")[self.classical_dict[\"all\"]]\n        else:\n            result = inflected.split(\" \")\n\n        # Try to fix word wise capitalization\n        for index, word in enumerate(orig.split(\" \")):\n            if word == \"I\":\n                # Is this the only word for exceptions like this\n                # Where the original is fully capitalized\n                # without 'meaning' capitalization?\n                # Also this fails to handle a capitalizaion in context\n                continue\n            if word.capitalize() == word:\n                result[index] = result[index].capitalize()\n            if word == word.upper():\n                result[index] = result[index].upper()\n        return \" \".join(result)\n\n    def partition_word(self, text: str) -> Tuple[str, str, str]:\n        mo = PARTITION_WORD.search(text)\n        if mo:\n            return mo.group(1), mo.group(2), mo.group(3)\n        else:\n            return \"\", \"\", \"\"\n\n    @typechecked\n    def plural(self, text: Word, count: Optional[Union[str, int, Any]] = None) -> str:\n        \"\"\"\n        Return the plural of text.\n\n        If count supplied, then return text if count is one of:\n            1, a, an, one, each, every, this, that\n\n        otherwise return the plural.\n\n        Whitespace at the start and end is preserved.\n\n        \"\"\"\n        pre, word, post = self.partition_word(text)\n        if not word:\n            return text\n        plural = self.postprocess(\n            word,\n            self._pl_special_adjective(word, count)\n            or self._pl_special_verb(word, count)\n            or self._plnoun(word, count),\n        )\n        return f\"{pre}{plural}{post}\"\n\n    @typechecked\n    def plural_noun(\n        self, text: Word, count: Optional[Union[str, int, Any]] = None\n    ) -> str:\n        \"\"\"\n        Return the plural of text, where text is a noun.\n\n        If count supplied, then return text if count is one of:\n            1, a, an, one, each, every, this, that\n\n        otherwise return the plural.\n\n        Whitespace at the start and end is preserved.\n\n        \"\"\"\n        pre, word, post = self.partition_word(text)\n        if not word:\n            return text\n        plural = self.postprocess(word, self._plnoun(word, count))\n        return f\"{pre}{plural}{post}\"\n\n    @typechecked\n    def plural_verb(\n        self, text: Word, count: Optional[Union[str, int, Any]] = None\n    ) -> str:\n        \"\"\"\n        Return the plural of text, where text is a verb.\n\n        If count supplied, then return text if count is one of:\n            1, a, an, one, each, every, this, that\n\n        otherwise return the plural.\n\n        Whitespace at the start and end is preserved.\n\n        \"\"\"\n        pre, word, post = self.partition_word(text)\n        if not word:\n            return text\n        plural = self.postprocess(\n            word,\n            self._pl_special_verb(word, count) or self._pl_general_verb(word, count),\n        )\n        return f\"{pre}{plural}{post}\"\n\n    @typechecked\n    def plural_adj(\n        self, text: Word, count: Optional[Union[str, int, Any]] = None\n    ) -> str:\n        \"\"\"\n        Return the plural of text, where text is an adjective.\n\n        If count supplied, then return text if count is one of:\n            1, a, an, one, each, every, this, that\n\n        otherwise return the plural.\n\n        Whitespace at the start and end is preserved.\n\n        \"\"\"\n        pre, word, post = self.partition_word(text)\n        if not word:\n            return text\n        plural = self.postprocess(word, self._pl_special_adjective(word, count) or word)\n        return f\"{pre}{plural}{post}\"\n\n    @typechecked\n    def compare(self, word1: Word, word2: Word) -> Union[str, bool]:\n        \"\"\"\n        compare word1 and word2 for equality regardless of plurality\n\n        return values:\n        eq - the strings are equal\n        p:s - word1 is the plural of word2\n        s:p - word2 is the plural of word1\n        p:p - word1 and word2 are two different plural forms of the one word\n        False - otherwise\n\n        >>> compare = engine().compare\n        >>> compare(\"egg\", \"eggs\")\n        's:p'\n        >>> compare('egg', 'egg')\n        'eq'\n\n        Words should not be empty.\n\n        >>> compare('egg', '')\n        Traceback (most recent call last):\n        ...\n        typeguard.TypeCheckError:...is not an instance of inflect.Word\n        \"\"\"\n        norms = self.plural_noun, self.plural_verb, self.plural_adj\n        results = (self._plequal(word1, word2, norm) for norm in norms)\n        return next(filter(None, results), False)\n\n    @typechecked\n    def compare_nouns(self, word1: Word, word2: Word) -> Union[str, bool]:\n        \"\"\"\n        compare word1 and word2 for equality regardless of plurality\n        word1 and word2 are to be treated as nouns\n\n        return values:\n        eq - the strings are equal\n        p:s - word1 is the plural of word2\n        s:p - word2 is the plural of word1\n        p:p - word1 and word2 are two different plural forms of the one word\n        False - otherwise\n\n        \"\"\"\n        return self._plequal(word1, word2, self.plural_noun)\n\n    @typechecked\n    def compare_verbs(self, word1: Word, word2: Word) -> Union[str, bool]:\n        \"\"\"\n        compare word1 and word2 for equality regardless of plurality\n        word1 and word2 are to be treated as verbs\n\n        return values:\n        eq - the strings are equal\n        p:s - word1 is the plural of word2\n        s:p - word2 is the plural of word1\n        p:p - word1 and word2 are two different plural forms of the one word\n        False - otherwise\n\n        \"\"\"\n        return self._plequal(word1, word2, self.plural_verb)\n\n    @typechecked\n    def compare_adjs(self, word1: Word, word2: Word) -> Union[str, bool]:\n        \"\"\"\n        compare word1 and word2 for equality regardless of plurality\n        word1 and word2 are to be treated as adjectives\n\n        return values:\n        eq - the strings are equal\n        p:s - word1 is the plural of word2\n        s:p - word2 is the plural of word1\n        p:p - word1 and word2 are two different plural forms of the one word\n        False - otherwise\n\n        \"\"\"\n        return self._plequal(word1, word2, self.plural_adj)\n\n    @typechecked\n    def singular_noun(\n        self,\n        text: Word,\n        count: Optional[Union[int, str, Any]] = None,\n        gender: Optional[str] = None,\n    ) -> Union[str, Literal[False]]:\n        \"\"\"\n        Return the singular of text, where text is a plural noun.\n\n        If count supplied, then return the singular if count is one of:\n            1, a, an, one, each, every, this, that or if count is None\n\n        otherwise return text unchanged.\n\n        Whitespace at the start and end is preserved.\n\n        >>> p = engine()\n        >>> p.singular_noun('horses')\n        'horse'\n        >>> p.singular_noun('knights')\n        'knight'\n\n        Returns False when a singular noun is passed.\n\n        >>> p.singular_noun('horse')\n        False\n        >>> p.singular_noun('knight')\n        False\n        >>> p.singular_noun('soldier')\n        False\n\n        \"\"\"\n        pre, word, post = self.partition_word(text)\n        if not word:\n            return text\n        sing = self._sinoun(word, count=count, gender=gender)\n        if sing is not False:\n            plural = self.postprocess(word, sing)\n            return f\"{pre}{plural}{post}\"\n        return False\n\n    def _plequal(self, word1: str, word2: str, pl) -> Union[str, bool]:  # noqa: C901\n        classval = self.classical_dict.copy()\n        self.classical_dict = all_classical.copy()\n        if word1 == word2:\n            return \"eq\"\n        if word1 == pl(word2):\n            return \"p:s\"\n        if pl(word1) == word2:\n            return \"s:p\"\n        self.classical_dict = no_classical.copy()\n        if word1 == pl(word2):\n            return \"p:s\"\n        if pl(word1) == word2:\n            return \"s:p\"\n        self.classical_dict = classval.copy()\n\n        if pl == self.plural or pl == self.plural_noun:\n            if self._pl_check_plurals_N(word1, word2):\n                return \"p:p\"\n            if self._pl_check_plurals_N(word2, word1):\n                return \"p:p\"\n        if pl == self.plural or pl == self.plural_adj:\n            if self._pl_check_plurals_adj(word1, word2):\n                return \"p:p\"\n        return False\n\n    def _pl_reg_plurals(self, pair: str, stems: str, end1: str, end2: str) -> bool:\n        pattern = rf\"({stems})({end1}\\|\\1{end2}|{end2}\\|\\1{end1})\"\n        return bool(re.search(pattern, pair))\n\n    def _pl_check_plurals_N(self, word1: str, word2: str) -> bool:\n        stem_endings = (\n            (pl_sb_C_a_ata, \"as\", \"ata\"),\n            (pl_sb_C_is_ides, \"is\", \"ides\"),\n            (pl_sb_C_a_ae, \"s\", \"e\"),\n            (pl_sb_C_en_ina, \"ens\", \"ina\"),\n            (pl_sb_C_um_a, \"ums\", \"a\"),\n            (pl_sb_C_us_i, \"uses\", \"i\"),\n            (pl_sb_C_on_a, \"ons\", \"a\"),\n            (pl_sb_C_o_i_stems, \"os\", \"i\"),\n            (pl_sb_C_ex_ices, \"exes\", \"ices\"),\n            (pl_sb_C_ix_ices, \"ixes\", \"ices\"),\n            (pl_sb_C_i, \"s\", \"i\"),\n            (pl_sb_C_im, \"s\", \"im\"),\n            (\".*eau\", \"s\", \"x\"),\n            (\".*ieu\", \"s\", \"x\"),\n            (\".*tri\", \"xes\", \"ces\"),\n            (\".{2,}[yia]n\", \"xes\", \"ges\"),\n        )\n\n        words = map(Words, (word1, word2))\n        pair = \"|\".join(word.last for word in words)\n\n        return (\n            pair in pl_sb_irregular_s.values()\n            or pair in pl_sb_irregular.values()\n            or pair in pl_sb_irregular_caps.values()\n            or any(\n                self._pl_reg_plurals(pair, stems, end1, end2)\n                for stems, end1, end2 in stem_endings\n            )\n        )\n\n    def _pl_check_plurals_adj(self, word1: str, word2: str) -> bool:\n        word1a = word1[: word1.rfind(\"'\")] if word1.endswith((\"'s\", \"'\")) else \"\"\n        word2a = word2[: word2.rfind(\"'\")] if word2.endswith((\"'s\", \"'\")) else \"\"\n\n        return (\n            bool(word1a)\n            and bool(word2a)\n            and (\n                self._pl_check_plurals_N(word1a, word2a)\n                or self._pl_check_plurals_N(word2a, word1a)\n            )\n        )\n\n    def get_count(self, count: Optional[Union[str, int]] = None) -> Union[str, int]:\n        if count is None and self.persistent_count is not None:\n            count = self.persistent_count\n\n        if count is not None:\n            count = (\n                1\n                if (\n                    (str(count) in pl_count_one)\n                    or (\n                        self.classical_dict[\"zero\"]\n                        and str(count).lower() in pl_count_zero\n                    )\n                )\n                else 2\n            )\n        else:\n            count = \"\"\n        return count\n\n    # @profile\n    def _plnoun(  # noqa: C901\n        self, word: str, count: Optional[Union[str, int]] = None\n    ) -> str:\n        count = self.get_count(count)\n\n        # DEFAULT TO PLURAL\n\n        if count == 1:\n            return word\n\n        # HANDLE USER-DEFINED NOUNS\n\n        value = self.ud_match(word, self.pl_sb_user_defined)\n        if value is not None:\n            return value\n\n        # HANDLE EMPTY WORD, SINGULAR COUNT AND UNINFLECTED PLURALS\n\n        if word == \"\":\n            return word\n\n        word = Words(word)\n\n        if word.last.lower() in pl_sb_uninflected_complete:\n            if len(word.split_) >= 3:\n                return self._handle_long_compounds(word, count=2) or word\n            return word\n\n        if word in pl_sb_uninflected_caps:\n            return word\n\n        for k, v in pl_sb_uninflected_bysize.items():\n            if word.lowered[-k:] in v:\n                return word\n\n        if self.classical_dict[\"herd\"] and word.last.lower() in pl_sb_uninflected_herd:\n            return word\n\n        # HANDLE COMPOUNDS (\"Governor General\", \"mother-in-law\", \"aide-de-camp\", ETC.)\n\n        mo = PL_SB_POSTFIX_ADJ_STEMS_RE.search(word)\n        if mo and mo.group(2) != \"\":\n            return f\"{self._plnoun(mo.group(1), 2)}{mo.group(2)}\"\n\n        if \" a \" in word.lowered or \"-a-\" in word.lowered:\n            mo = PL_SB_PREP_DUAL_COMPOUND_RE.search(word)\n            if mo and mo.group(2) != \"\" and mo.group(3) != \"\":\n                return (\n                    f\"{self._plnoun(mo.group(1), 2)}\"\n                    f\"{mo.group(2)}\"\n                    f\"{self._plnoun(mo.group(3))}\"\n                )\n\n        if len(word.split_) >= 3:\n            handled_words = self._handle_long_compounds(word, count=2)\n            if handled_words is not None:\n                return handled_words\n\n        # only pluralize denominators in units\n        mo = DENOMINATOR.search(word.lowered)\n        if mo:\n            index = len(mo.group(\"denominator\"))\n            return f\"{self._plnoun(word[:index])}{word[index:]}\"\n\n        # handle units given in degrees (only accept if\n        # there is no more than one word following)\n        # degree Celsius => degrees Celsius but degree\n        # fahrenheit hour => degree fahrenheit hours\n        if len(word.split_) >= 2 and word.split_[-2] == \"degree\":\n            return \" \".join([self._plnoun(word.first)] + word.split_[1:])\n\n        with contextlib.suppress(ValueError):\n            return self._handle_prepositional_phrase(\n                word.lowered,\n                functools.partial(self._plnoun, count=2),\n                '-',\n            )\n\n        # HANDLE PRONOUNS\n\n        for k, v in pl_pron_acc_keys_bysize.items():\n            if word.lowered[-k:] in v:  # ends with accusative pronoun\n                for pk, pv in pl_prep_bysize.items():\n                    if word.lowered[:pk] in pv:  # starts with a prep\n                        if word.lowered.split() == [\n                            word.lowered[:pk],\n                            word.lowered[-k:],\n                        ]:\n                            # only whitespace in between\n                            return word.lowered[:-k] + pl_pron_acc[word.lowered[-k:]]\n\n        try:\n            return pl_pron_nom[word.lowered]\n        except KeyError:\n            pass\n\n        try:\n            return pl_pron_acc[word.lowered]\n        except KeyError:\n            pass\n\n        # HANDLE ISOLATED IRREGULAR PLURALS\n\n        if word.last in pl_sb_irregular_caps:\n            llen = len(word.last)\n            return f\"{word[:-llen]}{pl_sb_irregular_caps[word.last]}\"\n\n        lowered_last = word.last.lower()\n        if lowered_last in pl_sb_irregular:\n            llen = len(lowered_last)\n            return f\"{word[:-llen]}{pl_sb_irregular[lowered_last]}\"\n\n        dash_split = word.lowered.split('-')\n        if (\" \".join(dash_split[-2:])).lower() in pl_sb_irregular_compound:\n            llen = len(\n                \" \".join(dash_split[-2:])\n            )  # TODO: what if 2 spaces between these words?\n            return (\n                f\"{word[:-llen]}\"\n                f\"{pl_sb_irregular_compound[(' '.join(dash_split[-2:])).lower()]}\"\n            )\n\n        if word.lowered[-3:] == \"quy\":\n            return f\"{word[:-1]}ies\"\n\n        if word.lowered[-6:] == \"person\":\n            if self.classical_dict[\"persons\"]:\n                return f\"{word}s\"\n            else:\n                return f\"{word[:-4]}ople\"\n\n        # HANDLE FAMILIES OF IRREGULAR PLURALS\n\n        if word.lowered[-3:] == \"man\":\n            for k, v in pl_sb_U_man_mans_bysize.items():\n                if word.lowered[-k:] in v:\n                    return f\"{word}s\"\n            for k, v in pl_sb_U_man_mans_caps_bysize.items():\n                if word[-k:] in v:\n                    return f\"{word}s\"\n            return f\"{word[:-3]}men\"\n        if word.lowered[-5:] == \"mouse\":\n            return f\"{word[:-5]}mice\"\n        if word.lowered[-5:] == \"louse\":\n            v = pl_sb_U_louse_lice_bysize.get(len(word))\n            if v and word.lowered in v:\n                return f\"{word[:-5]}lice\"\n            return f\"{word}s\"\n        if word.lowered[-5:] == \"goose\":\n            return f\"{word[:-5]}geese\"\n        if word.lowered[-5:] == \"tooth\":\n            return f\"{word[:-5]}teeth\"\n        if word.lowered[-4:] == \"foot\":\n            return f\"{word[:-4]}feet\"\n        if word.lowered[-4:] == \"taco\":\n            return f\"{word[:-5]}tacos\"\n\n        if word.lowered == \"die\":\n            return \"dice\"\n\n        # HANDLE UNASSIMILATED IMPORTS\n\n        if word.lowered[-4:] == \"ceps\":\n            return word\n        if word.lowered[-4:] == \"zoon\":\n            return f\"{word[:-2]}a\"\n        if word.lowered[-3:] in (\"cis\", \"sis\", \"xis\"):\n            return f\"{word[:-2]}es\"\n\n        for lastlet, d, numend, post in (\n            (\"h\", pl_sb_U_ch_chs_bysize, None, \"s\"),\n            (\"x\", pl_sb_U_ex_ices_bysize, -2, \"ices\"),\n            (\"x\", pl_sb_U_ix_ices_bysize, -2, \"ices\"),\n            (\"m\", pl_sb_U_um_a_bysize, -2, \"a\"),\n            (\"s\", pl_sb_U_us_i_bysize, -2, \"i\"),\n            (\"n\", pl_sb_U_on_a_bysize, -2, \"a\"),\n            (\"a\", pl_sb_U_a_ae_bysize, None, \"e\"),\n        ):\n            if word.lowered[-1] == lastlet:  # this test to add speed\n                for k, v in d.items():\n                    if word.lowered[-k:] in v:\n                        return word[:numend] + post\n\n        # HANDLE INCOMPLETELY ASSIMILATED IMPORTS\n\n        if self.classical_dict[\"ancient\"]:\n            if word.lowered[-4:] == \"trix\":\n                return f\"{word[:-1]}ces\"\n            if word.lowered[-3:] in (\"eau\", \"ieu\"):\n                return f\"{word}x\"\n            if word.lowered[-3:] in (\"ynx\", \"inx\", \"anx\") and len(word) > 4:\n                return f\"{word[:-1]}ges\"\n\n            for lastlet, d, numend, post in (\n                (\"n\", pl_sb_C_en_ina_bysize, -2, \"ina\"),\n                (\"x\", pl_sb_C_ex_ices_bysize, -2, \"ices\"),\n                (\"x\", pl_sb_C_ix_ices_bysize, -2, \"ices\"),\n                (\"m\", pl_sb_C_um_a_bysize, -2, \"a\"),\n                (\"s\", pl_sb_C_us_i_bysize, -2, \"i\"),\n                (\"s\", pl_sb_C_us_us_bysize, None, \"\"),\n                (\"a\", pl_sb_C_a_ae_bysize, None, \"e\"),\n                (\"a\", pl_sb_C_a_ata_bysize, None, \"ta\"),\n                (\"s\", pl_sb_C_is_ides_bysize, -1, \"des\"),\n                (\"o\", pl_sb_C_o_i_bysize, -1, \"i\"),\n                (\"n\", pl_sb_C_on_a_bysize, -2, \"a\"),\n            ):\n                if word.lowered[-1] == lastlet:  # this test to add speed\n                    for k, v in d.items():\n                        if word.lowered[-k:] in v:\n                            return word[:numend] + post\n\n            for d, numend, post in (\n                (pl_sb_C_i_bysize, None, \"i\"),\n                (pl_sb_C_im_bysize, None, \"im\"),\n            ):\n                for k, v in d.items():\n                    if word.lowered[-k:] in v:\n                        return word[:numend] + post\n\n        # HANDLE SINGULAR NOUNS ENDING IN ...s OR OTHER SILIBANTS\n\n        if lowered_last in pl_sb_singular_s_complete:\n            return f\"{word}es\"\n\n        for k, v in pl_sb_singular_s_bysize.items():\n            if word.lowered[-k:] in v:\n                return f\"{word}es\"\n\n        if word.lowered[-2:] == \"es\" and word[0] == word[0].upper():\n            return f\"{word}es\"\n\n        if word.lowered[-1] == \"z\":\n            for k, v in pl_sb_z_zes_bysize.items():\n                if word.lowered[-k:] in v:\n                    return f\"{word}es\"\n\n            if word.lowered[-2:-1] != \"z\":\n                return f\"{word}zes\"\n\n        if word.lowered[-2:] == \"ze\":\n            for k, v in pl_sb_ze_zes_bysize.items():\n                if word.lowered[-k:] in v:\n                    return f\"{word}s\"\n\n        if word.lowered[-2:] in (\"ch\", \"sh\", \"zz\", \"ss\") or word.lowered[-1] == \"x\":\n            return f\"{word}es\"\n\n        # HANDLE ...f -> ...ves\n\n        if word.lowered[-3:] in (\"elf\", \"alf\", \"olf\"):\n            return f\"{word[:-1]}ves\"\n        if word.lowered[-3:] == \"eaf\" and word.lowered[-4:-3] != \"d\":\n            return f\"{word[:-1]}ves\"\n        if word.lowered[-4:] in (\"nife\", \"life\", \"wife\"):\n            return f\"{word[:-2]}ves\"\n        if word.lowered[-3:] == \"arf\":\n            return f\"{word[:-1]}ves\"\n\n        # HANDLE ...y\n\n        if word.lowered[-1] == \"y\":\n            if word.lowered[-2:-1] in \"aeiou\" or len(word) == 1:\n                return f\"{word}s\"\n\n            if self.classical_dict[\"names\"]:\n                if word.lowered[-1] == \"y\" and word[0] == word[0].upper():\n                    return f\"{word}s\"\n\n            return f\"{word[:-1]}ies\"\n\n        # HANDLE ...o\n\n        if lowered_last in pl_sb_U_o_os_complete:\n            return f\"{word}s\"\n\n        for k, v in pl_sb_U_o_os_bysize.items():\n            if word.lowered[-k:] in v:\n                return f\"{word}s\"\n\n        if word.lowered[-2:] in (\"ao\", \"eo\", \"io\", \"oo\", \"uo\"):\n            return f\"{word}s\"\n\n        if word.lowered[-1] == \"o\":\n            return f\"{word}es\"\n\n        # OTHERWISE JUST ADD ...s\n\n        return f\"{word}s\"\n\n    @classmethod\n    def _handle_prepositional_phrase(cls, phrase, transform, sep):\n        \"\"\"\n        Given a word or phrase possibly separated by sep, parse out\n        the prepositional phrase and apply the transform to the word\n        preceding the prepositional phrase.\n\n        Raise ValueError if the pivot is not found or if at least two\n        separators are not found.\n\n        >>> engine._handle_prepositional_phrase(\"man-of-war\", str.upper, '-')\n        'MAN-of-war'\n        >>> engine._handle_prepositional_phrase(\"man of war\", str.upper, ' ')\n        'MAN of war'\n        \"\"\"\n        parts = phrase.split(sep)\n        if len(parts) < 3:\n            raise ValueError(\"Cannot handle words with fewer than two separators\")\n\n        pivot = cls._find_pivot(parts, pl_prep_list_da)\n\n        transformed = transform(parts[pivot - 1]) or parts[pivot - 1]\n        return \" \".join(\n            parts[: pivot - 1] + [sep.join([transformed, parts[pivot], ''])]\n        ) + \" \".join(parts[(pivot + 1) :])\n\n    def _handle_long_compounds(self, word: Words, count: int) -> Union[str, None]:\n        \"\"\"\n        Handles the plural and singular for compound `Words` that\n        have three or more words, based on the given count.\n\n        >>> engine()._handle_long_compounds(Words(\"pair of scissors\"), 2)\n        'pairs of scissors'\n        >>> engine()._handle_long_compounds(Words(\"men beyond hills\"), 1)\n        'man beyond hills'\n        \"\"\"\n        inflection = self._sinoun if count == 1 else self._plnoun\n        solutions = (  # type: ignore\n            \" \".join(\n                itertools.chain(\n                    leader,\n                    [inflection(cand, count), prep],  # type: ignore\n                    trailer,\n                )\n            )\n            for leader, (cand, prep), trailer in windowed_complete(word.split_, 2)\n            if prep in pl_prep_list_da  # type: ignore\n        )\n        return next(solutions, None)\n\n    @staticmethod\n    def _find_pivot(words, candidates):\n        pivots = (\n            index for index in range(1, len(words) - 1) if words[index] in candidates\n        )\n        try:\n            return next(pivots)\n        except StopIteration:\n            raise ValueError(\"No pivot found\") from None\n\n    def _pl_special_verb(  # noqa: C901\n        self, word: str, count: Optional[Union[str, int]] = None\n    ) -> Union[str, bool]:\n        if self.classical_dict[\"zero\"] and str(count).lower() in pl_count_zero:\n            return False\n        count = self.get_count(count)\n\n        if count == 1:\n            return word\n\n        # HANDLE USER-DEFINED VERBS\n\n        value = self.ud_match(word, self.pl_v_user_defined)\n        if value is not None:\n            return value\n\n        # HANDLE IRREGULAR PRESENT TENSE (SIMPLE AND COMPOUND)\n\n        try:\n            words = Words(word)\n        except IndexError:\n            return False  # word is ''\n\n        if words.first in plverb_irregular_pres:\n            return f\"{plverb_irregular_pres[words.first]}{words[len(words.first) :]}\"\n\n        # HANDLE IRREGULAR FUTURE, PRETERITE AND PERFECT TENSES\n\n        if words.first in plverb_irregular_non_pres:\n            return word\n\n        # HANDLE PRESENT NEGATIONS (SIMPLE AND COMPOUND)\n\n        if words.first.endswith(\"n't\") and words.first[:-3] in plverb_irregular_pres:\n            return (\n                f\"{plverb_irregular_pres[words.first[:-3]]}n't\"\n                f\"{words[len(words.first) :]}\"\n            )\n\n        if words.first.endswith(\"n't\"):\n            return word\n\n        # HANDLE SPECIAL CASES\n\n        mo = PLVERB_SPECIAL_S_RE.search(word)\n        if mo:\n            return False\n        if WHITESPACE.search(word):\n            return False\n\n        if words.lowered == \"quizzes\":\n            return \"quiz\"\n\n        # HANDLE STANDARD 3RD PERSON (CHOP THE ...(e)s OFF SINGLE WORDS)\n\n        if (\n            words.lowered[-4:] in (\"ches\", \"shes\", \"zzes\", \"sses\")\n            or words.lowered[-3:] == \"xes\"\n        ):\n            return words[:-2]\n\n        if words.lowered[-3:] == \"ies\" and len(words) > 3:\n            return words.lowered[:-3] + \"y\"\n\n        if (\n            words.last.lower() in pl_v_oes_oe\n            or words.lowered[-4:] in pl_v_oes_oe_endings_size4\n            or words.lowered[-5:] in pl_v_oes_oe_endings_size5\n        ):\n            return words[:-1]\n\n        if words.lowered.endswith(\"oes\") and len(words) > 3:\n            return words.lowered[:-2]\n\n        mo = ENDS_WITH_S.search(words)\n        if mo:\n            return mo.group(1)\n\n        # OTHERWISE, A REGULAR VERB (HANDLE ELSEWHERE)\n\n        return False\n\n    def _pl_general_verb(\n        self, word: str, count: Optional[Union[str, int]] = None\n    ) -> str:\n        count = self.get_count(count)\n\n        if count == 1:\n            return word\n\n        # HANDLE AMBIGUOUS PRESENT TENSES  (SIMPLE AND COMPOUND)\n\n        mo = plverb_ambiguous_pres_keys.search(word)\n        if mo:\n            return f\"{plverb_ambiguous_pres[mo.group(1).lower()]}{mo.group(2)}\"\n\n        # HANDLE AMBIGUOUS PRETERITE AND PERFECT TENSES\n\n        mo = plverb_ambiguous_non_pres.search(word)\n        if mo:\n            return word\n\n        # OTHERWISE, 1st OR 2ND PERSON IS UNINFLECTED\n\n        return word\n\n    def _pl_special_adjective(\n        self, word: str, count: Optional[Union[str, int]] = None\n    ) -> Union[str, bool]:\n        count = self.get_count(count)\n\n        if count == 1:\n            return word\n\n        # HANDLE USER-DEFINED ADJECTIVES\n\n        value = self.ud_match(word, self.pl_adj_user_defined)\n        if value is not None:\n            return value\n\n        # HANDLE KNOWN CASES\n\n        mo = pl_adj_special_keys.search(word)\n        if mo:\n            return pl_adj_special[mo.group(1).lower()]\n\n        # HANDLE POSSESSIVES\n\n        mo = pl_adj_poss_keys.search(word)\n        if mo:\n            return pl_adj_poss[mo.group(1).lower()]\n\n        mo = ENDS_WITH_APOSTROPHE_S.search(word)\n        if mo:\n            pl = self.plural_noun(mo.group(1))\n            trailing_s = \"\" if pl[-1] == \"s\" else \"s\"\n            return f\"{pl}'{trailing_s}\"\n\n        # OTHERWISE, NO IDEA\n\n        return False\n\n    # @profile\n    def _sinoun(  # noqa: C901\n        self,\n        word: str,\n        count: Optional[Union[str, int]] = None,\n        gender: Optional[str] = None,\n    ) -> Union[str, bool]:\n        count = self.get_count(count)\n\n        # DEFAULT TO PLURAL\n\n        if count == 2:\n            return word\n\n        # SET THE GENDER\n\n        try:\n            if gender is None:\n                gender = self.thegender\n            elif gender not in singular_pronoun_genders:\n                raise BadGenderError\n        except (TypeError, IndexError) as err:\n            raise BadGenderError from err\n\n        # HANDLE USER-DEFINED NOUNS\n\n        value = self.ud_match(word, self.si_sb_user_defined)\n        if value is not None:\n            return value\n\n        # HANDLE EMPTY WORD, SINGULAR COUNT AND UNINFLECTED PLURALS\n\n        if word == \"\":\n            return word\n\n        if word in si_sb_ois_oi_case:\n            return word[:-1]\n\n        words = Words(word)\n\n        if words.last.lower() in pl_sb_uninflected_complete:\n            if len(words.split_) >= 3:\n                return self._handle_long_compounds(words, count=1) or word\n            return word\n\n        if word in pl_sb_uninflected_caps:\n            return word\n\n        for k, v in pl_sb_uninflected_bysize.items():\n            if words.lowered[-k:] in v:\n                return word\n\n        if self.classical_dict[\"herd\"] and words.last.lower() in pl_sb_uninflected_herd:\n            return word\n\n        if words.last.lower() in pl_sb_C_us_us:\n            return word if self.classical_dict[\"ancient\"] else False\n\n        # HANDLE COMPOUNDS (\"Governor General\", \"mother-in-law\", \"aide-de-camp\", ETC.)\n\n        mo = PL_SB_POSTFIX_ADJ_STEMS_RE.search(word)\n        if mo and mo.group(2) != \"\":\n            return f\"{self._sinoun(mo.group(1), 1, gender=gender)}{mo.group(2)}\"\n\n        with contextlib.suppress(ValueError):\n            return self._handle_prepositional_phrase(\n                words.lowered,\n                functools.partial(self._sinoun, count=1, gender=gender),\n                ' ',\n            )\n\n        with contextlib.suppress(ValueError):\n            return self._handle_prepositional_phrase(\n                words.lowered,\n                functools.partial(self._sinoun, count=1, gender=gender),\n                '-',\n            )\n\n        # HANDLE PRONOUNS\n\n        for k, v in si_pron_acc_keys_bysize.items():\n            if words.lowered[-k:] in v:  # ends with accusative pronoun\n                for pk, pv in pl_prep_bysize.items():\n                    if words.lowered[:pk] in pv:  # starts with a prep\n                        if words.lowered.split() == [\n                            words.lowered[:pk],\n                            words.lowered[-k:],\n                        ]:\n                            # only whitespace in between\n                            return words.lowered[:-k] + get_si_pron(\n                                \"acc\", words.lowered[-k:], gender\n                            )\n\n        try:\n            return get_si_pron(\"nom\", words.lowered, gender)\n        except KeyError:\n            pass\n\n        try:\n            return get_si_pron(\"acc\", words.lowered, gender)\n        except KeyError:\n            pass\n\n        # HANDLE ISOLATED IRREGULAR PLURALS\n\n        if words.last in si_sb_irregular_caps:\n            llen = len(words.last)\n            return f\"{word[:-llen]}{si_sb_irregular_caps[words.last]}\"\n\n        if words.last.lower() in si_sb_irregular:\n            llen = len(words.last.lower())\n            return f\"{word[:-llen]}{si_sb_irregular[words.last.lower()]}\"\n\n        dash_split = words.lowered.split(\"-\")\n        if (\" \".join(dash_split[-2:])).lower() in si_sb_irregular_compound:\n            llen = len(\n                \" \".join(dash_split[-2:])\n            )  # TODO: what if 2 spaces between these words?\n            return \"{}{}\".format(\n                word[:-llen],\n                si_sb_irregular_compound[(\" \".join(dash_split[-2:])).lower()],\n            )\n\n        if words.lowered[-5:] == \"quies\":\n            return word[:-3] + \"y\"\n\n        if words.lowered[-7:] == \"persons\":\n            return word[:-1]\n        if words.lowered[-6:] == \"people\":\n            return word[:-4] + \"rson\"\n\n        # HANDLE FAMILIES OF IRREGULAR PLURALS\n\n        if words.lowered[-4:] == \"mans\":\n            for k, v in si_sb_U_man_mans_bysize.items():\n                if words.lowered[-k:] in v:\n                    return word[:-1]\n            for k, v in si_sb_U_man_mans_caps_bysize.items():\n                if word[-k:] in v:\n                    return word[:-1]\n        if words.lowered[-3:] == \"men\":\n            return word[:-3] + \"man\"\n        if words.lowered[-4:] == \"mice\":\n            return word[:-4] + \"mouse\"\n        if words.lowered[-4:] == \"lice\":\n            v = si_sb_U_louse_lice_bysize.get(len(word))\n            if v and words.lowered in v:\n                return word[:-4] + \"louse\"\n        if words.lowered[-5:] == \"geese\":\n            return word[:-5] + \"goose\"\n        if words.lowered[-5:] == \"teeth\":\n            return word[:-5] + \"tooth\"\n        if words.lowered[-4:] == \"feet\":\n            return word[:-4] + \"foot\"\n\n        if words.lowered == \"dice\":\n            return \"die\"\n\n        # HANDLE UNASSIMILATED IMPORTS\n\n        if words.lowered[-4:] == \"ceps\":\n            return word\n        if words.lowered[-3:] == \"zoa\":\n            return word[:-1] + \"on\"\n\n        for lastlet, d, unass_numend, post in (\n            (\"s\", si_sb_U_ch_chs_bysize, -1, \"\"),\n            (\"s\", si_sb_U_ex_ices_bysize, -4, \"ex\"),\n            (\"s\", si_sb_U_ix_ices_bysize, -4, \"ix\"),\n            (\"a\", si_sb_U_um_a_bysize, -1, \"um\"),\n            (\"i\", si_sb_U_us_i_bysize, -1, \"us\"),\n            (\"a\", si_sb_U_on_a_bysize, -1, \"on\"),\n            (\"e\", si_sb_U_a_ae_bysize, -1, \"\"),\n        ):\n            if words.lowered[-1] == lastlet:  # this test to add speed\n                for k, v in d.items():\n                    if words.lowered[-k:] in v:\n                        return word[:unass_numend] + post\n\n        # HANDLE INCOMPLETELY ASSIMILATED IMPORTS\n\n        if self.classical_dict[\"ancient\"]:\n            if words.lowered[-6:] == \"trices\":\n                return word[:-3] + \"x\"\n            if words.lowered[-4:] in (\"eaux\", \"ieux\"):\n                return word[:-1]\n            if words.lowered[-5:] in (\"ynges\", \"inges\", \"anges\") and len(word) > 6:\n                return word[:-3] + \"x\"\n\n            for lastlet, d, class_numend, post in (\n                (\"a\", si_sb_C_en_ina_bysize, -3, \"en\"),\n                (\"s\", si_sb_C_ex_ices_bysize, -4, \"ex\"),\n                (\"s\", si_sb_C_ix_ices_bysize, -4, \"ix\"),\n                (\"a\", si_sb_C_um_a_bysize, -1, \"um\"),\n                (\"i\", si_sb_C_us_i_bysize, -1, \"us\"),\n                (\"s\", pl_sb_C_us_us_bysize, None, \"\"),\n                (\"e\", si_sb_C_a_ae_bysize, -1, \"\"),\n                (\"a\", si_sb_C_a_ata_bysize, -2, \"\"),\n                (\"s\", si_sb_C_is_ides_bysize, -3, \"s\"),\n                (\"i\", si_sb_C_o_i_bysize, -1, \"o\"),\n                (\"a\", si_sb_C_on_a_bysize, -1, \"on\"),\n                (\"m\", si_sb_C_im_bysize, -2, \"\"),\n                (\"i\", si_sb_C_i_bysize, -1, \"\"),\n            ):\n                if words.lowered[-1] == lastlet:  # this test to add speed\n                    for k, v in d.items():\n                        if words.lowered[-k:] in v:\n                            return word[:class_numend] + post\n\n        # HANDLE PLURLS ENDING IN uses -> use\n\n        if (\n            words.lowered[-6:] == \"houses\"\n            or word in si_sb_uses_use_case\n            or words.last.lower() in si_sb_uses_use\n        ):\n            return word[:-1]\n\n        # HANDLE PLURLS ENDING IN ies -> ie\n\n        if word in si_sb_ies_ie_case or words.last.lower() in si_sb_ies_ie:\n            return word[:-1]\n\n        # HANDLE PLURLS ENDING IN oes -> oe\n\n        if (\n            words.lowered[-5:] == \"shoes\"\n            or word in si_sb_oes_oe_case\n            or words.last.lower() in si_sb_oes_oe\n        ):\n            return word[:-1]\n\n        # HANDLE SINGULAR NOUNS ENDING IN ...s OR OTHER SILIBANTS\n\n        if word in si_sb_sses_sse_case or words.last.lower() in si_sb_sses_sse:\n            return word[:-1]\n\n        if words.last.lower() in si_sb_singular_s_complete:\n            return word[:-2]\n\n        for k, v in si_sb_singular_s_bysize.items():\n            if words.lowered[-k:] in v:\n                return word[:-2]\n\n        if words.lowered[-4:] == \"eses\" and word[0] == word[0].upper():\n            return word[:-2]\n\n        if words.last.lower() in si_sb_z_zes:\n            return word[:-2]\n\n        if words.last.lower() in si_sb_zzes_zz:\n            return word[:-2]\n\n        if words.lowered[-4:] == \"zzes\":\n            return word[:-3]\n\n        if word in si_sb_ches_che_case or words.last.lower() in si_sb_ches_che:\n            return word[:-1]\n\n        if words.lowered[-4:] in (\"ches\", \"shes\"):\n            return word[:-2]\n\n        if words.last.lower() in si_sb_xes_xe:\n            return word[:-1]\n\n        if words.lowered[-3:] == \"xes\":\n            return word[:-2]\n\n        # HANDLE ...f -> ...ves\n\n        if word in si_sb_ves_ve_case or words.last.lower() in si_sb_ves_ve:\n            return word[:-1]\n\n        if words.lowered[-3:] == \"ves\":\n            if words.lowered[-5:-3] in (\"el\", \"al\", \"ol\"):\n                return word[:-3] + \"f\"\n            if words.lowered[-5:-3] == \"ea\" and word[-6:-5] != \"d\":\n                return word[:-3] + \"f\"\n            if words.lowered[-5:-3] in (\"ni\", \"li\", \"wi\"):\n                return word[:-3] + \"fe\"\n            if words.lowered[-5:-3] == \"ar\":\n                return word[:-3] + \"f\"\n\n        # HANDLE ...y\n\n        if words.lowered[-2:] == \"ys\":\n            if len(words.lowered) > 2 and words.lowered[-3] in \"aeiou\":\n                return word[:-1]\n\n            if self.classical_dict[\"names\"]:\n                if words.lowered[-2:] == \"ys\" and word[0] == word[0].upper():\n                    return word[:-1]\n\n        if words.lowered[-3:] == \"ies\":\n            return word[:-3] + \"y\"\n\n        # HANDLE ...o\n\n        if words.lowered[-2:] == \"os\":\n            if words.last.lower() in si_sb_U_o_os_complete:\n                return word[:-1]\n\n            for k, v in si_sb_U_o_os_bysize.items():\n                if words.lowered[-k:] in v:\n                    return word[:-1]\n\n            if words.lowered[-3:] in (\"aos\", \"eos\", \"ios\", \"oos\", \"uos\"):\n                return word[:-1]\n\n        if words.lowered[-3:] == \"oes\":\n            return word[:-2]\n\n        # UNASSIMILATED IMPORTS FINAL RULE\n\n        if word in si_sb_es_is:\n            return word[:-2] + \"is\"\n\n        # OTHERWISE JUST REMOVE ...s\n\n        if words.lowered[-1] == \"s\":\n            return word[:-1]\n\n        # COULD NOT FIND SINGULAR\n\n        return False\n\n    # ADJECTIVES\n\n    @typechecked\n    def a(self, text: Word, count: Optional[Union[int, str, Any]] = 1) -> str:\n        \"\"\"\n        Return the appropriate indefinite article followed by text.\n\n        The indefinite article is either 'a' or 'an'.\n\n        If count is not one, then return count followed by text\n        instead of 'a' or 'an'.\n\n        Whitespace at the start and end is preserved.\n\n        \"\"\"\n        mo = INDEFINITE_ARTICLE_TEST.search(text)\n        if mo:\n            word = mo.group(2)\n            if not word:\n                return text\n            pre = mo.group(1)\n            post = mo.group(3)\n            result = self._indef_article(word, count)\n            return f\"{pre}{result}{post}\"\n        return \"\"\n\n    an = a\n\n    _indef_article_cases = (\n        # HANDLE ORDINAL FORMS\n        (A_ordinal_a, \"a\"),\n        (A_ordinal_an, \"an\"),\n        # HANDLE SPECIAL CASES\n        (A_explicit_an, \"an\"),\n        (SPECIAL_AN, \"an\"),\n        (SPECIAL_A, \"a\"),\n        # HANDLE ABBREVIATIONS\n        (A_abbrev, \"an\"),\n        (SPECIAL_ABBREV_AN, \"an\"),\n        (SPECIAL_ABBREV_A, \"a\"),\n        # HANDLE CONSONANTS\n        (CONSONANTS, \"a\"),\n        # HANDLE SPECIAL VOWEL-FORMS\n        (ARTICLE_SPECIAL_EU, \"a\"),\n        (ARTICLE_SPECIAL_ONCE, \"a\"),\n        (ARTICLE_SPECIAL_ONETIME, \"a\"),\n        (ARTICLE_SPECIAL_UNIT, \"a\"),\n        (ARTICLE_SPECIAL_UBA, \"a\"),\n        (ARTICLE_SPECIAL_UKR, \"a\"),\n        (A_explicit_a, \"a\"),\n        # HANDLE SPECIAL CAPITALS\n        (SPECIAL_CAPITALS, \"a\"),\n        # HANDLE VOWELS\n        (VOWELS, \"an\"),\n        # HANDLE y...\n        # (BEFORE CERTAIN CONSONANTS IMPLIES (UNNATURALIZED) \"i..\" SOUND)\n        (A_y_cons, \"an\"),\n    )\n\n    def _indef_article(self, word: str, count: Union[int, str, Any]) -> str:\n        mycount = self.get_count(count)\n\n        if mycount != 1:\n            return f\"{count} {word}\"\n\n        # HANDLE USER-DEFINED VARIANTS\n\n        value = self.ud_match(word, self.A_a_user_defined)\n        if value is not None:\n            return f\"{value} {word}\"\n\n        matches = (\n            f'{article} {word}'\n            for regexen, article in self._indef_article_cases\n            if regexen.search(word)\n        )\n\n        # OTHERWISE, GUESS \"a\"\n        fallback = f'a {word}'\n        return next(matches, fallback)\n\n    # 2. TRANSLATE ZERO-QUANTIFIED $word TO \"no plural($word)\"\n\n    @typechecked\n    def no(self, text: Word, count: Optional[Union[int, str]] = None) -> str:\n        \"\"\"\n        If count is 0, no, zero or nil, return 'no' followed by the plural\n        of text.\n\n        If count is one of:\n            1, a, an, one, each, every, this, that\n            return count followed by text.\n\n        Otherwise return count follow by the plural of text.\n\n        In the return value count is always followed by a space.\n\n        Whitespace at the start and end is preserved.\n\n        \"\"\"\n        if count is None and self.persistent_count is not None:\n            count = self.persistent_count\n\n        if count is None:\n            count = 0\n        mo = PARTITION_WORD.search(text)\n        if mo:\n            pre = mo.group(1)\n            word = mo.group(2)\n            post = mo.group(3)\n        else:\n            pre = \"\"\n            word = \"\"\n            post = \"\"\n\n        if str(count).lower() in pl_count_zero:\n            count = 'no'\n        return f\"{pre}{count} {self.plural(word, count)}{post}\"\n\n    # PARTICIPLES\n\n    @typechecked\n    def present_participle(self, word: Word) -> str:\n        \"\"\"\n        Return the present participle for word.\n\n        word is the 3rd person singular verb.\n\n        \"\"\"\n        plv = self.plural_verb(word, 2)\n        ans = plv\n\n        for regexen, repl in PRESENT_PARTICIPLE_REPLACEMENTS:\n            ans, num = regexen.subn(repl, plv)\n            if num:\n                return f\"{ans}ing\"\n        return f\"{ans}ing\"\n\n    # NUMERICAL INFLECTIONS\n\n    @typechecked\n    def ordinal(self, num: Union[Number, Word]) -> str:\n        \"\"\"\n        Return the ordinal of num.\n\n        >>> ordinal = engine().ordinal\n        >>> ordinal(1)\n        '1st'\n        >>> ordinal('one')\n        'first'\n        \"\"\"\n        if DIGIT.match(str(num)):\n            if isinstance(num, (float, int)) and int(num) == num:\n                n = int(num)\n            else:\n                if \".\" in str(num):\n                    try:\n                        # numbers after decimal,\n                        # so only need last one for ordinal\n                        n = int(str(num)[-1])\n\n                    except ValueError:  # ends with '.', so need to use whole string\n                        n = int(str(num)[:-1])\n                else:\n                    n = int(num)  # type: ignore\n            try:\n                post = nth[n % 100]\n            except KeyError:\n                post = nth[n % 10]\n            return f\"{num}{post}\"\n        else:\n            return self._sub_ord(num)\n\n    def millfn(self, ind: int = 0) -> str:\n        if ind > len(mill) - 1:\n            raise NumOutOfRangeError\n        return mill[ind]\n\n    def unitfn(self, units: int, mindex: int = 0) -> str:\n        return f\"{unit[units]}{self.millfn(mindex)}\"\n\n    def tenfn(self, tens, units, mindex=0) -> str:\n        if tens != 1:\n            tens_part = ten[tens]\n            if tens and units:\n                hyphen = \"-\"\n            else:\n                hyphen = \"\"\n            unit_part = unit[units]\n            mill_part = self.millfn(mindex)\n            return f\"{tens_part}{hyphen}{unit_part}{mill_part}\"\n        return f\"{teen[units]}{mill[mindex]}\"\n\n    def hundfn(self, hundreds: int, tens: int, units: int, mindex: int) -> str:\n        if hundreds:\n            andword = f\" {self._number_args['andword']} \" if tens or units else \"\"\n            # use unit not unitfn as simpler\n            return (\n                f\"{unit[hundreds]} hundred{andword}\"\n                f\"{self.tenfn(tens, units)}{self.millfn(mindex)}, \"\n            )\n        if tens or units:\n            return f\"{self.tenfn(tens, units)}{self.millfn(mindex)}, \"\n        return \"\"\n\n    def group1sub(self, mo: Match) -> str:\n        units = int(mo.group(1))\n        if units == 1:\n            return f\" {self._number_args['one']}, \"\n        elif units:\n            return f\"{unit[units]}, \"\n        else:\n            return f\" {self._number_args['zero']}, \"\n\n    def group1bsub(self, mo: Match) -> str:\n        units = int(mo.group(1))\n        if units:\n            return f\"{unit[units]}, \"\n        else:\n            return f\" {self._number_args['zero']}, \"\n\n    def group2sub(self, mo: Match) -> str:\n        tens = int(mo.group(1))\n        units = int(mo.group(2))\n        if tens:\n            return f\"{self.tenfn(tens, units)}, \"\n        if units:\n            return f\" {self._number_args['zero']} {unit[units]}, \"\n        return f\" {self._number_args['zero']} {self._number_args['zero']}, \"\n\n    def group3sub(self, mo: Match) -> str:\n        hundreds = int(mo.group(1))\n        tens = int(mo.group(2))\n        units = int(mo.group(3))\n        if hundreds == 1:\n            hunword = f\" {self._number_args['one']}\"\n        elif hundreds:\n            hunword = str(unit[hundreds])\n        else:\n            hunword = f\" {self._number_args['zero']}\"\n        if tens:\n            tenword = self.tenfn(tens, units)\n        elif units:\n            tenword = f\" {self._number_args['zero']} {unit[units]}\"\n        else:\n            tenword = f\" {self._number_args['zero']} {self._number_args['zero']}\"\n        return f\"{hunword} {tenword}, \"\n\n    def hundsub(self, mo: Match) -> str:\n        ret = self.hundfn(\n            int(mo.group(1)), int(mo.group(2)), int(mo.group(3)), self.mill_count\n        )\n        self.mill_count += 1\n        return ret\n\n    def tensub(self, mo: Match) -> str:\n        return f\"{self.tenfn(int(mo.group(1)), int(mo.group(2)), self.mill_count)}, \"\n\n    def unitsub(self, mo: Match) -> str:\n        return f\"{self.unitfn(int(mo.group(1)), self.mill_count)}, \"\n\n    def enword(self, num: str, group: int) -> str:\n        # import pdb\n        # pdb.set_trace()\n\n        if group == 1:\n            num = DIGIT_GROUP.sub(self.group1sub, num)\n        elif group == 2:\n            num = TWO_DIGITS.sub(self.group2sub, num)\n            num = DIGIT_GROUP.sub(self.group1bsub, num, 1)\n        elif group == 3:\n            num = THREE_DIGITS.sub(self.group3sub, num)\n            num = TWO_DIGITS.sub(self.group2sub, num, 1)\n            num = DIGIT_GROUP.sub(self.group1sub, num, 1)\n        elif int(num) == 0:\n            num = self._number_args[\"zero\"]\n        elif int(num) == 1:\n            num = self._number_args[\"one\"]\n        else:\n            num = num.lstrip().lstrip(\"0\")\n            self.mill_count = 0\n            # surely there's a better way to do the next bit\n            mo = THREE_DIGITS_WORD.search(num)\n            while mo:\n                num = THREE_DIGITS_WORD.sub(self.hundsub, num, 1)\n                mo = THREE_DIGITS_WORD.search(num)\n            num = TWO_DIGITS_WORD.sub(self.tensub, num, 1)\n            num = ONE_DIGIT_WORD.sub(self.unitsub, num, 1)\n        return num\n\n    @staticmethod\n    def _sub_ord(val):\n        new = ordinal_suff.sub(lambda match: ordinal[match.group(1)], val)\n        return new + \"th\" * (new == val)\n\n    @classmethod\n    def _chunk_num(cls, num, decimal, group):\n        if decimal:\n            max_split = -1 if group != 0 else 1\n            chunks = num.split(\".\", max_split)\n        else:\n            chunks = [num]\n        return cls._remove_last_blank(chunks)\n\n    @staticmethod\n    def _remove_last_blank(chunks):\n        \"\"\"\n        Remove the last item from chunks if it's a blank string.\n\n        Return the resultant chunks and whether the last item was removed.\n        \"\"\"\n        removed = chunks[-1] == \"\"\n        result = chunks[:-1] if removed else chunks\n        return result, removed\n\n    @staticmethod\n    def _get_sign(num):\n        return {'+': 'plus', '-': 'minus'}.get(num.lstrip()[0], '')\n\n    @typechecked\n    def number_to_words(  # noqa: C901\n        self,\n        num: Union[Number, Word],\n        wantlist: bool = False,\n        group: int = 0,\n        comma: Union[Falsish, str] = \",\",\n        andword: str = \"and\",\n        zero: str = \"zero\",\n        one: str = \"one\",\n        decimal: Union[Falsish, str] = \"point\",\n        threshold: Optional[int] = None,\n    ) -> Union[str, List[str]]:\n        \"\"\"\n        Return a number in words.\n\n        group = 1, 2 or 3 to group numbers before turning into words\n        comma: define comma\n\n        andword:\n            word for 'and'. Can be set to ''.\n            e.g. \"one hundred and one\" vs \"one hundred one\"\n\n        zero: word for '0'\n        one: word for '1'\n        decimal: word for decimal point\n        threshold: numbers above threshold not turned into words\n\n        parameters not remembered from last call. Departure from Perl version.\n        \"\"\"\n        self._number_args = {\"andword\": andword, \"zero\": zero, \"one\": one}\n        num = str(num)\n\n        # Handle \"stylistic\" conversions (up to a given threshold)...\n        if threshold is not None and float(num) > threshold:\n            spnum = num.split(\".\", 1)\n            while comma:\n                (spnum[0], n) = FOUR_DIGIT_COMMA.subn(r\"\\1,\\2\", spnum[0])\n                if n == 0:\n                    break\n            try:\n                return f\"{spnum[0]}.{spnum[1]}\"\n            except IndexError:\n                return str(spnum[0])\n\n        if group < 0 or group > 3:\n            raise BadChunkingOptionError\n\n        sign = self._get_sign(num)\n\n        if num in nth_suff:\n            num = zero\n\n        myord = num[-2:] in nth_suff\n        if myord:\n            num = num[:-2]\n\n        chunks, finalpoint = self._chunk_num(num, decimal, group)\n\n        loopstart = chunks[0] == \"\"\n        first: bool | None = not loopstart\n\n        def _handle_chunk(chunk):\n            nonlocal first\n\n            # remove all non numeric \\D\n            chunk = NON_DIGIT.sub(\"\", chunk)\n            if chunk == \"\":\n                chunk = \"0\"\n\n            if group == 0 and not first:\n                chunk = self.enword(chunk, 1)\n            else:\n                chunk = self.enword(chunk, group)\n\n            if chunk[-2:] == \", \":\n                chunk = chunk[:-2]\n            chunk = WHITESPACES_COMMA.sub(\",\", chunk)\n\n            if group == 0 and first:\n                chunk = COMMA_WORD.sub(f\" {andword} \\\\1\", chunk)\n            chunk = WHITESPACES.sub(\" \", chunk)\n            # chunk = re.sub(r\"(\\A\\s|\\s\\Z)\", self.blankfn, chunk)\n            chunk = chunk.strip()\n            if first:\n                first = None\n            return chunk\n\n        chunks[loopstart:] = map(_handle_chunk, chunks[loopstart:])\n\n        numchunks = []\n        if first != 0:\n            numchunks = chunks[0].split(f\"{comma} \")\n\n        if myord and numchunks:\n            numchunks[-1] = self._sub_ord(numchunks[-1])\n\n        for chunk in chunks[1:]:\n            numchunks.append(decimal)\n            numchunks.extend(chunk.split(f\"{comma} \"))\n\n        if finalpoint:\n            numchunks.append(decimal)\n\n        if wantlist:\n            return [sign] * bool(sign) + numchunks\n\n        signout = f\"{sign} \" if sign else \"\"\n        valout = (\n            ', '.join(numchunks)\n            if group\n            else ''.join(self._render(numchunks, decimal, comma))\n        )\n        return signout + valout\n\n    @staticmethod\n    def _render(chunks, decimal, comma):\n        first_item = chunks.pop(0)\n        yield first_item\n        first = decimal is None or not first_item.endswith(decimal)\n        for nc in chunks:\n            if nc == decimal:\n                first = False\n            elif first:\n                yield comma\n            yield f\" {nc}\"\n\n    @typechecked\n    def join(\n        self,\n        words: Optional[Sequence[Word]],\n        sep: Optional[str] = None,\n        sep_spaced: bool = True,\n        final_sep: Optional[str] = None,\n        conj: str = \"and\",\n        conj_spaced: bool = True,\n    ) -> str:\n        \"\"\"\n        Join words into a list.\n\n        e.g. join(['ant', 'bee', 'fly']) returns 'ant, bee, and fly'\n\n        options:\n        conj: replacement for 'and'\n        sep: separator. default ',', unless ',' is in the list then ';'\n        final_sep: final separator. default ',', unless ',' is in the list then ';'\n        conj_spaced: boolean. Should conj have spaces around it\n\n        \"\"\"\n        if not words:\n            return \"\"\n        if len(words) == 1:\n            return words[0]\n\n        if conj_spaced:\n            if conj == \"\":\n                conj = \" \"\n            else:\n                conj = f\" {conj} \"\n\n        if len(words) == 2:\n            return f\"{words[0]}{conj}{words[1]}\"\n\n        if sep is None:\n            if \",\" in \"\".join(words):\n                sep = \";\"\n            else:\n                sep = \",\"\n        if final_sep is None:\n            final_sep = sep\n\n        final_sep = f\"{final_sep}{conj}\"\n\n        if sep_spaced:\n            sep += \" \"\n\n        return f\"{sep.join(words[0:-1])}{final_sep}{words[-1]}\"\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/inflect/compat/__init__.py","size":0,"sha1":"da39a3ee5e6b4b0d3255bfef95601890afd80709","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":""},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/inflect/compat/py38.py","size":160,"sha1":"dc9eaae43de8f7f7c510b46cf0a2291d8ddae4ca","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\n\n\nif sys.version_info > (3, 9):\n    from typing import Annotated\nelse:  # pragma: no cover\n    from typing_extensions import Annotated  # noqa: F401\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/jaraco/collections/__init__.py","size":26640,"sha1":"b855df5c922381a5c4d80d7e5b39f256f47ad52d","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport collections.abc\nimport copy\nimport functools\nimport itertools\nimport operator\nimport random\nimport re\nfrom collections.abc import Container, Iterable, Mapping\nfrom typing import TYPE_CHECKING, Any, Callable, Dict, TypeVar, Union, overload\n\nimport jaraco.text\n\nif TYPE_CHECKING:\n    from _operator import _SupportsComparison\n\n    from _typeshed import SupportsKeysAndGetItem\n    from typing_extensions import Self\n\n    _RangeMapKT = TypeVar('_RangeMapKT', bound=_SupportsComparison)\nelse:\n    # _SupportsComparison doesn't exist at runtime,\n    # but _RangeMapKT is used in RangeMap's superclass' type parameters\n    _RangeMapKT = TypeVar('_RangeMapKT')\n\n_T = TypeVar('_T')\n_VT = TypeVar('_VT')\n\n_Matchable = Union[Callable, Container, Iterable, re.Pattern]\n\n\ndef _dispatch(obj: _Matchable) -> Callable:\n    # can't rely on singledispatch for Union[Container, Iterable]\n    # due to ambiguity\n    # (https://peps.python.org/pep-0443/#abstract-base-classes).\n    if isinstance(obj, re.Pattern):\n        return obj.fullmatch\n    # mypy issue: https://github.com/python/mypy/issues/11071\n    if not isinstance(obj, Callable):  # type: ignore[arg-type]\n        if not isinstance(obj, Container):\n            obj = set(obj)  # type: ignore[arg-type]\n        obj = obj.__contains__\n    return obj  # type: ignore[return-value]\n\n\nclass Projection(collections.abc.Mapping):\n    \"\"\"\n    Project a set of keys over a mapping\n\n    >>> sample = {'a': 1, 'b': 2, 'c': 3}\n    >>> prj = Projection(['a', 'c', 'd'], sample)\n    >>> dict(prj)\n    {'a': 1, 'c': 3}\n\n    Projection also accepts an iterable or callable or pattern.\n\n    >>> iter_prj = Projection(iter('acd'), sample)\n    >>> call_prj = Projection(lambda k: ord(k) in (97, 99, 100), sample)\n    >>> pat_prj = Projection(re.compile(r'[acd]'), sample)\n    >>> prj == iter_prj == call_prj == pat_prj\n    True\n\n    Keys should only appear if they were specified and exist in the space.\n    Order is retained.\n\n    >>> list(prj)\n    ['a', 'c']\n\n    Attempting to access a key not in the projection\n    results in a KeyError.\n\n    >>> prj['b']\n    Traceback (most recent call last):\n    ...\n    KeyError: 'b'\n\n    Use the projection to update another dict.\n\n    >>> target = {'a': 2, 'b': 2}\n    >>> target.update(prj)\n    >>> target\n    {'a': 1, 'b': 2, 'c': 3}\n\n    Projection keeps a reference to the original dict, so\n    modifying the original dict may modify the Projection.\n\n    >>> del sample['a']\n    >>> dict(prj)\n    {'c': 3}\n    \"\"\"\n\n    def __init__(self, keys: _Matchable, space: Mapping):\n        self._match = _dispatch(keys)\n        self._space = space\n\n    def __getitem__(self, key):\n        if not self._match(key):\n            raise KeyError(key)\n        return self._space[key]\n\n    def _keys_resolved(self):\n        return filter(self._match, self._space)\n\n    def __iter__(self):\n        return self._keys_resolved()\n\n    def __len__(self):\n        return len(tuple(self._keys_resolved()))\n\n\nclass Mask(Projection):\n    \"\"\"\n    The inverse of a :class:`Projection`, masking out keys.\n\n    >>> sample = {'a': 1, 'b': 2, 'c': 3}\n    >>> msk = Mask(['a', 'c', 'd'], sample)\n    >>> dict(msk)\n    {'b': 2}\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # self._match = compose(operator.not_, self._match)\n        self._match = lambda key, orig=self._match: not orig(key)\n\n\ndef dict_map(function, dictionary):\n    \"\"\"\n    Return a new dict with function applied to values of dictionary.\n\n    >>> dict_map(lambda x: x+1, dict(a=1, b=2))\n    {'a': 2, 'b': 3}\n    \"\"\"\n    return dict((key, function(value)) for key, value in dictionary.items())\n\n\nclass RangeMap(Dict[_RangeMapKT, _VT]):\n    \"\"\"\n    A dictionary-like object that uses the keys as bounds for a range.\n    Inclusion of the value for that range is determined by the\n    key_match_comparator, which defaults to less-than-or-equal.\n    A value is returned for a key if it is the first key that matches in\n    the sorted list of keys.\n\n    One may supply keyword parameters to be passed to the sort function used\n    to sort keys (i.e. key, reverse) as sort_params.\n\n    Create a map that maps 1-3 -> 'a', 4-6 -> 'b'\n\n    >>> r = RangeMap({3: 'a', 6: 'b'})  # boy, that was easy\n    >>> r[1], r[2], r[3], r[4], r[5], r[6]\n    ('a', 'a', 'a', 'b', 'b', 'b')\n\n    Even float values should work so long as the comparison operator\n    supports it.\n\n    >>> r[4.5]\n    'b'\n\n    Notice that the way rangemap is defined, it must be open-ended\n    on one side.\n\n    >>> r[0]\n    'a'\n    >>> r[-1]\n    'a'\n\n    One can close the open-end of the RangeMap by using undefined_value\n\n    >>> r = RangeMap({0: RangeMap.undefined_value, 3: 'a', 6: 'b'})\n    >>> r[0]\n    Traceback (most recent call last):\n    ...\n    KeyError: 0\n\n    One can get the first or last elements in the range by using RangeMap.Item\n\n    >>> last_item = RangeMap.Item(-1)\n    >>> r[last_item]\n    'b'\n\n    .last_item is a shortcut for Item(-1)\n\n    >>> r[RangeMap.last_item]\n    'b'\n\n    Sometimes it's useful to find the bounds for a RangeMap\n\n    >>> r.bounds()\n    (0, 6)\n\n    RangeMap supports .get(key, default)\n\n    >>> r.get(0, 'not found')\n    'not found'\n\n    >>> r.get(7, 'not found')\n    'not found'\n\n    One often wishes to define the ranges by their left-most values,\n    which requires use of sort params and a key_match_comparator.\n\n    >>> r = RangeMap({1: 'a', 4: 'b'},\n    ...     sort_params=dict(reverse=True),\n    ...     key_match_comparator=operator.ge)\n    >>> r[1], r[2], r[3], r[4], r[5], r[6]\n    ('a', 'a', 'a', 'b', 'b', 'b')\n\n    That wasn't nearly as easy as before, so an alternate constructor\n    is provided:\n\n    >>> r = RangeMap.left({1: 'a', 4: 'b', 7: RangeMap.undefined_value})\n    >>> r[1], r[2], r[3], r[4], r[5], r[6]\n    ('a', 'a', 'a', 'b', 'b', 'b')\n\n    \"\"\"\n\n    def __init__(\n        self,\n        source: (\n            SupportsKeysAndGetItem[_RangeMapKT, _VT] | Iterable[tuple[_RangeMapKT, _VT]]\n        ),\n        sort_params: Mapping[str, Any] = {},\n        key_match_comparator: Callable[[_RangeMapKT, _RangeMapKT], bool] = operator.le,\n    ):\n        dict.__init__(self, source)\n        self.sort_params = sort_params\n        self.match = key_match_comparator\n\n    @classmethod\n    def left(\n        cls,\n        source: (\n            SupportsKeysAndGetItem[_RangeMapKT, _VT] | Iterable[tuple[_RangeMapKT, _VT]]\n        ),\n    ) -> Self:\n        return cls(\n            source, sort_params=dict(reverse=True), key_match_comparator=operator.ge\n        )\n\n    def __getitem__(self, item: _RangeMapKT) -> _VT:\n        sorted_keys = sorted(self.keys(), **self.sort_params)\n        if isinstance(item, RangeMap.Item):\n            result = self.__getitem__(sorted_keys[item])\n        else:\n            key = self._find_first_match_(sorted_keys, item)\n            result = dict.__getitem__(self, key)\n            if result is RangeMap.undefined_value:\n                raise KeyError(key)\n        return result\n\n    @overload  # type: ignore[override] # Signature simplified over dict and Mapping\n    def get(self, key: _RangeMapKT, default: _T) -> _VT | _T: ...\n    @overload\n    def get(self, key: _RangeMapKT, default: None = None) -> _VT | None: ...\n    def get(self, key: _RangeMapKT, default: _T | None = None) -> _VT | _T | None:\n        \"\"\"\n        Return the value for key if key is in the dictionary, else default.\n        If default is not given, it defaults to None, so that this method\n        never raises a KeyError.\n        \"\"\"\n        try:\n            return self[key]\n        except KeyError:\n            return default\n\n    def _find_first_match_(\n        self, keys: Iterable[_RangeMapKT], item: _RangeMapKT\n    ) -> _RangeMapKT:\n        is_match = functools.partial(self.match, item)\n        matches = filter(is_match, keys)\n        try:\n            return next(matches)\n        except StopIteration:\n            raise KeyError(item) from None\n\n    def bounds(self) -> tuple[_RangeMapKT, _RangeMapKT]:\n        sorted_keys = sorted(self.keys(), **self.sort_params)\n        return (sorted_keys[RangeMap.first_item], sorted_keys[RangeMap.last_item])\n\n    # some special values for the RangeMap\n    undefined_value = type('RangeValueUndefined', (), {})()\n\n    class Item(int):\n        \"\"\"RangeMap Item\"\"\"\n\n    first_item = Item(0)\n    last_item = Item(-1)\n\n\ndef __identity(x):\n    return x\n\n\ndef sorted_items(d, key=__identity, reverse=False):\n    \"\"\"\n    Return the items of the dictionary sorted by the keys.\n\n    >>> sample = dict(foo=20, bar=42, baz=10)\n    >>> tuple(sorted_items(sample))\n    (('bar', 42), ('baz', 10), ('foo', 20))\n\n    >>> reverse_string = lambda s: ''.join(reversed(s))\n    >>> tuple(sorted_items(sample, key=reverse_string))\n    (('foo', 20), ('bar', 42), ('baz', 10))\n\n    >>> tuple(sorted_items(sample, reverse=True))\n    (('foo', 20), ('baz', 10), ('bar', 42))\n    \"\"\"\n\n    # wrap the key func so it operates on the first element of each item\n    def pairkey_key(item):\n        return key(item[0])\n\n    return sorted(d.items(), key=pairkey_key, reverse=reverse)\n\n\nclass KeyTransformingDict(dict):\n    \"\"\"\n    A dict subclass that transforms the keys before they're used.\n    Subclasses may override the default transform_key to customize behavior.\n    \"\"\"\n\n    @staticmethod\n    def transform_key(key):  # pragma: nocover\n        return key\n\n    def __init__(self, *args, **kargs):\n        super().__init__()\n        # build a dictionary using the default constructs\n        d = dict(*args, **kargs)\n        # build this dictionary using transformed keys.\n        for item in d.items():\n            self.__setitem__(*item)\n\n    def __setitem__(self, key, val):\n        key = self.transform_key(key)\n        super().__setitem__(key, val)\n\n    def __getitem__(self, key):\n        key = self.transform_key(key)\n        return super().__getitem__(key)\n\n    def __contains__(self, key):\n        key = self.transform_key(key)\n        return super().__contains__(key)\n\n    def __delitem__(self, key):\n        key = self.transform_key(key)\n        return super().__delitem__(key)\n\n    def get(self, key, *args, **kwargs):\n        key = self.transform_key(key)\n        return super().get(key, *args, **kwargs)\n\n    def setdefault(self, key, *args, **kwargs):\n        key = self.transform_key(key)\n        return super().setdefault(key, *args, **kwargs)\n\n    def pop(self, key, *args, **kwargs):\n        key = self.transform_key(key)\n        return super().pop(key, *args, **kwargs)\n\n    def matching_key_for(self, key):\n        \"\"\"\n        Given a key, return the actual key stored in self that matches.\n        Raise KeyError if the key isn't found.\n        \"\"\"\n        try:\n            return next(e_key for e_key in self.keys() if e_key == key)\n        except StopIteration as err:\n            raise KeyError(key) from err\n\n\nclass FoldedCaseKeyedDict(KeyTransformingDict):\n    \"\"\"\n    A case-insensitive dictionary (keys are compared as insensitive\n    if they are strings).\n\n    >>> d = FoldedCaseKeyedDict()\n    >>> d['heLlo'] = 'world'\n    >>> list(d.keys()) == ['heLlo']\n    True\n    >>> list(d.values()) == ['world']\n    True\n    >>> d['hello'] == 'world'\n    True\n    >>> 'hello' in d\n    True\n    >>> 'HELLO' in d\n    True\n    >>> print(repr(FoldedCaseKeyedDict({'heLlo': 'world'})))\n    {'heLlo': 'world'}\n    >>> d = FoldedCaseKeyedDict({'heLlo': 'world'})\n    >>> print(d['hello'])\n    world\n    >>> print(d['Hello'])\n    world\n    >>> list(d.keys())\n    ['heLlo']\n    >>> d = FoldedCaseKeyedDict({'heLlo': 'world', 'Hello': 'world'})\n    >>> list(d.values())\n    ['world']\n    >>> key, = d.keys()\n    >>> key in ['heLlo', 'Hello']\n    True\n    >>> del d['HELLO']\n    >>> d\n    {}\n\n    get should work\n\n    >>> d['Sumthin'] = 'else'\n    >>> d.get('SUMTHIN')\n    'else'\n    >>> d.get('OTHER', 'thing')\n    'thing'\n    >>> del d['sumthin']\n\n    setdefault should also work\n\n    >>> d['This'] = 'that'\n    >>> print(d.setdefault('this', 'other'))\n    that\n    >>> len(d)\n    1\n    >>> print(d['this'])\n    that\n    >>> print(d.setdefault('That', 'other'))\n    other\n    >>> print(d['THAT'])\n    other\n\n    Make it pop!\n\n    >>> print(d.pop('THAT'))\n    other\n\n    To retrieve the key in its originally-supplied form, use matching_key_for\n\n    >>> print(d.matching_key_for('this'))\n    This\n\n    >>> d.matching_key_for('missing')\n    Traceback (most recent call last):\n    ...\n    KeyError: 'missing'\n    \"\"\"\n\n    @staticmethod\n    def transform_key(key):\n        return jaraco.text.FoldedCase(key)\n\n\nclass DictAdapter:\n    \"\"\"\n    Provide a getitem interface for attributes of an object.\n\n    Let's say you want to get at the string.lowercase property in a formatted\n    string. It's easy with DictAdapter.\n\n    >>> import string\n    >>> print(\"lowercase is %(ascii_lowercase)s\" % DictAdapter(string))\n    lowercase is abcdefghijklmnopqrstuvwxyz\n    \"\"\"\n\n    def __init__(self, wrapped_ob):\n        self.object = wrapped_ob\n\n    def __getitem__(self, name):\n        return getattr(self.object, name)\n\n\nclass ItemsAsAttributes:\n    \"\"\"\n    Mix-in class to enable a mapping object to provide items as\n    attributes.\n\n    >>> C = type('C', (dict, ItemsAsAttributes), dict())\n    >>> i = C()\n    >>> i['foo'] = 'bar'\n    >>> i.foo\n    'bar'\n\n    Natural attribute access takes precedence\n\n    >>> i.foo = 'henry'\n    >>> i.foo\n    'henry'\n\n    But as you might expect, the mapping functionality is preserved.\n\n    >>> i['foo']\n    'bar'\n\n    A normal attribute error should be raised if an attribute is\n    requested that doesn't exist.\n\n    >>> i.missing\n    Traceback (most recent call last):\n    ...\n    AttributeError: 'C' object has no attribute 'missing'\n\n    It also works on dicts that customize __getitem__\n\n    >>> missing_func = lambda self, key: 'missing item'\n    >>> C = type(\n    ...     'C',\n    ...     (dict, ItemsAsAttributes),\n    ...     dict(__missing__ = missing_func),\n    ... )\n    >>> i = C()\n    >>> i.missing\n    'missing item'\n    >>> i.foo\n    'missing item'\n    \"\"\"\n\n    def __getattr__(self, key):\n        try:\n            return getattr(super(), key)\n        except AttributeError as e:\n            # attempt to get the value from the mapping (return self[key])\n            #  but be careful not to lose the original exception context.\n            noval = object()\n\n            def _safe_getitem(cont, key, missing_result):\n                try:\n                    return cont[key]\n                except KeyError:\n                    return missing_result\n\n            result = _safe_getitem(self, key, noval)\n            if result is not noval:\n                return result\n            # raise the original exception, but use the original class\n            #  name, not 'super'.\n            (message,) = e.args\n            message = message.replace('super', self.__class__.__name__, 1)\n            e.args = (message,)\n            raise\n\n\ndef invert_map(map):\n    \"\"\"\n    Given a dictionary, return another dictionary with keys and values\n    switched. If any of the values resolve to the same key, raises\n    a ValueError.\n\n    >>> numbers = dict(a=1, b=2, c=3)\n    >>> letters = invert_map(numbers)\n    >>> letters[1]\n    'a'\n    >>> numbers['d'] = 3\n    >>> invert_map(numbers)\n    Traceback (most recent call last):\n    ...\n    ValueError: Key conflict in inverted mapping\n    \"\"\"\n    res = dict((v, k) for k, v in map.items())\n    if not len(res) == len(map):\n        raise ValueError('Key conflict in inverted mapping')\n    return res\n\n\nclass IdentityOverrideMap(dict):\n    \"\"\"\n    A dictionary that by default maps each key to itself, but otherwise\n    acts like a normal dictionary.\n\n    >>> d = IdentityOverrideMap()\n    >>> d[42]\n    42\n    >>> d['speed'] = 'speedo'\n    >>> print(d['speed'])\n    speedo\n    \"\"\"\n\n    def __missing__(self, key):\n        return key\n\n\nclass DictStack(list, collections.abc.MutableMapping):\n    \"\"\"\n    A stack of dictionaries that behaves as a view on those dictionaries,\n    giving preference to the last.\n\n    >>> stack = DictStack([dict(a=1, c=2), dict(b=2, a=2)])\n    >>> stack['a']\n    2\n    >>> stack['b']\n    2\n    >>> stack['c']\n    2\n    >>> len(stack)\n    3\n    >>> stack.push(dict(a=3))\n    >>> stack['a']\n    3\n    >>> stack['a'] = 4\n    >>> set(stack.keys()) == set(['a', 'b', 'c'])\n    True\n    >>> set(stack.items()) == set([('a', 4), ('b', 2), ('c', 2)])\n    True\n    >>> dict(**stack) == dict(stack) == dict(a=4, c=2, b=2)\n    True\n    >>> d = stack.pop()\n    >>> stack['a']\n    2\n    >>> d = stack.pop()\n    >>> stack['a']\n    1\n    >>> stack.get('b', None)\n    >>> 'c' in stack\n    True\n    >>> del stack['c']\n    >>> dict(stack)\n    {'a': 1}\n    \"\"\"\n\n    def __iter__(self):\n        dicts = list.__iter__(self)\n        return iter(set(itertools.chain.from_iterable(c.keys() for c in dicts)))\n\n    def __getitem__(self, key):\n        for scope in reversed(tuple(list.__iter__(self))):\n            if key in scope:\n                return scope[key]\n        raise KeyError(key)\n\n    push = list.append\n\n    def __contains__(self, other):\n        return collections.abc.Mapping.__contains__(self, other)\n\n    def __len__(self):\n        return len(list(iter(self)))\n\n    def __setitem__(self, key, item):\n        last = list.__getitem__(self, -1)\n        return last.__setitem__(key, item)\n\n    def __delitem__(self, key):\n        last = list.__getitem__(self, -1)\n        return last.__delitem__(key)\n\n    # workaround for mypy confusion\n    def pop(self, *args, **kwargs):\n        return list.pop(self, *args, **kwargs)\n\n\nclass BijectiveMap(dict):\n    \"\"\"\n    A Bijective Map (two-way mapping).\n\n    Implemented as a simple dictionary of 2x the size, mapping values back\n    to keys.\n\n    Note, this implementation may be incomplete. If there's not a test for\n    your use case below, it's likely to fail, so please test and send pull\n    requests or patches for additional functionality needed.\n\n\n    >>> m = BijectiveMap()\n    >>> m['a'] = 'b'\n    >>> m == {'a': 'b', 'b': 'a'}\n    True\n    >>> print(m['b'])\n    a\n\n    >>> m['c'] = 'd'\n    >>> len(m)\n    2\n\n    Some weird things happen if you map an item to itself or overwrite a\n    single key of a pair, so it's disallowed.\n\n    >>> m['e'] = 'e'\n    Traceback (most recent call last):\n    ValueError: Key cannot map to itself\n\n    >>> m['d'] = 'e'\n    Traceback (most recent call last):\n    ValueError: Key/Value pairs may not overlap\n\n    >>> m['e'] = 'd'\n    Traceback (most recent call last):\n    ValueError: Key/Value pairs may not overlap\n\n    >>> print(m.pop('d'))\n    c\n\n    >>> 'c' in m\n    False\n\n    >>> m = BijectiveMap(dict(a='b'))\n    >>> len(m)\n    1\n    >>> print(m['b'])\n    a\n\n    >>> m = BijectiveMap()\n    >>> m.update(a='b')\n    >>> m['b']\n    'a'\n\n    >>> del m['b']\n    >>> len(m)\n    0\n    >>> 'a' in m\n    False\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__()\n        self.update(*args, **kwargs)\n\n    def __setitem__(self, item, value):\n        if item == value:\n            raise ValueError(\"Key cannot map to itself\")\n        overlap = (\n            item in self\n            and self[item] != value\n            or value in self\n            and self[value] != item\n        )\n        if overlap:\n            raise ValueError(\"Key/Value pairs may not overlap\")\n        super().__setitem__(item, value)\n        super().__setitem__(value, item)\n\n    def __delitem__(self, item):\n        self.pop(item)\n\n    def __len__(self):\n        return super().__len__() // 2\n\n    def pop(self, key, *args, **kwargs):\n        mirror = self[key]\n        super().__delitem__(mirror)\n        return super().pop(key, *args, **kwargs)\n\n    def update(self, *args, **kwargs):\n        # build a dictionary using the default constructs\n        d = dict(*args, **kwargs)\n        # build this dictionary using transformed keys.\n        for item in d.items():\n            self.__setitem__(*item)\n\n\nclass FrozenDict(collections.abc.Mapping, collections.abc.Hashable):\n    \"\"\"\n    An immutable mapping.\n\n    >>> a = FrozenDict(a=1, b=2)\n    >>> b = FrozenDict(a=1, b=2)\n    >>> a == b\n    True\n\n    >>> a == dict(a=1, b=2)\n    True\n    >>> dict(a=1, b=2) == a\n    True\n    >>> 'a' in a\n    True\n    >>> type(hash(a)) is type(0)\n    True\n    >>> set(iter(a)) == {'a', 'b'}\n    True\n    >>> len(a)\n    2\n    >>> a['a'] == a.get('a') == 1\n    True\n\n    >>> a['c'] = 3\n    Traceback (most recent call last):\n    ...\n    TypeError: 'FrozenDict' object does not support item assignment\n\n    >>> a.update(y=3)\n    Traceback (most recent call last):\n    ...\n    AttributeError: 'FrozenDict' object has no attribute 'update'\n\n    Copies should compare equal\n\n    >>> copy.copy(a) == a\n    True\n\n    Copies should be the same type\n\n    >>> isinstance(copy.copy(a), FrozenDict)\n    True\n\n    FrozenDict supplies .copy(), even though\n    collections.abc.Mapping doesn't demand it.\n\n    >>> a.copy() == a\n    True\n    >>> a.copy() is not a\n    True\n    \"\"\"\n\n    __slots__ = ['__data']\n\n    def __new__(cls, *args, **kwargs):\n        self = super().__new__(cls)\n        self.__data = dict(*args, **kwargs)\n        return self\n\n    # Container\n    def __contains__(self, key):\n        return key in self.__data\n\n    # Hashable\n    def __hash__(self):\n        return hash(tuple(sorted(self.__data.items())))\n\n    # Mapping\n    def __iter__(self):\n        return iter(self.__data)\n\n    def __len__(self):\n        return len(self.__data)\n\n    def __getitem__(self, key):\n        return self.__data[key]\n\n    # override get for efficiency provided by dict\n    def get(self, *args, **kwargs):\n        return self.__data.get(*args, **kwargs)\n\n    # override eq to recognize underlying implementation\n    def __eq__(self, other):\n        if isinstance(other, FrozenDict):\n            other = other.__data\n        return self.__data.__eq__(other)\n\n    def copy(self):\n        \"Return a shallow copy of self\"\n        return copy.copy(self)\n\n\nclass Enumeration(ItemsAsAttributes, BijectiveMap):\n    \"\"\"\n    A convenient way to provide enumerated values\n\n    >>> e = Enumeration('a b c')\n    >>> e['a']\n    0\n\n    >>> e.a\n    0\n\n    >>> e[1]\n    'b'\n\n    >>> set(e.names) == set('abc')\n    True\n\n    >>> set(e.codes) == set(range(3))\n    True\n\n    >>> e.get('d') is None\n    True\n\n    Codes need not start with 0\n\n    >>> e = Enumeration('a b c', range(1, 4))\n    >>> e['a']\n    1\n\n    >>> e[3]\n    'c'\n    \"\"\"\n\n    def __init__(self, names, codes=None):\n        if isinstance(names, str):\n            names = names.split()\n        if codes is None:\n            codes = itertools.count()\n        super().__init__(zip(names, codes))\n\n    @property\n    def names(self):\n        return (key for key in self if isinstance(key, str))\n\n    @property\n    def codes(self):\n        return (self[name] for name in self.names)\n\n\nclass Everything:\n    \"\"\"\n    A collection \"containing\" every possible thing.\n\n    >>> 'foo' in Everything()\n    True\n\n    >>> import random\n    >>> random.randint(1, 999) in Everything()\n    True\n\n    >>> random.choice([None, 'foo', 42, ('a', 'b', 'c')]) in Everything()\n    True\n    \"\"\"\n\n    def __contains__(self, other):\n        return True\n\n\nclass InstrumentedDict(collections.UserDict):\n    \"\"\"\n    Instrument an existing dictionary with additional\n    functionality, but always reference and mutate\n    the original dictionary.\n\n    >>> orig = {'a': 1, 'b': 2}\n    >>> inst = InstrumentedDict(orig)\n    >>> inst['a']\n    1\n    >>> inst['c'] = 3\n    >>> orig['c']\n    3\n    >>> inst.keys() == orig.keys()\n    True\n    \"\"\"\n\n    def __init__(self, data):\n        super().__init__()\n        self.data = data\n\n\nclass Least:\n    \"\"\"\n    A value that is always lesser than any other\n\n    >>> least = Least()\n    >>> 3 < least\n    False\n    >>> 3 > least\n    True\n    >>> least < 3\n    True\n    >>> least <= 3\n    True\n    >>> least > 3\n    False\n    >>> 'x' > least\n    True\n    >>> None > least\n    True\n    \"\"\"\n\n    def __le__(self, other):\n        return True\n\n    __lt__ = __le__\n\n    def __ge__(self, other):\n        return False\n\n    __gt__ = __ge__\n\n\nclass Greatest:\n    \"\"\"\n    A value that is always greater than any other\n\n    >>> greatest = Greatest()\n    >>> 3 < greatest\n    True\n    >>> 3 > greatest\n    False\n    >>> greatest < 3\n    False\n    >>> greatest > 3\n    True\n    >>> greatest >= 3\n    True\n    >>> 'x' > greatest\n    False\n    >>> None > greatest\n    False\n    \"\"\"\n\n    def __ge__(self, other):\n        return True\n\n    __gt__ = __ge__\n\n    def __le__(self, other):\n        return False\n\n    __lt__ = __le__\n\n\ndef pop_all(items):\n    \"\"\"\n    Clear items in place and return a copy of items.\n\n    >>> items = [1, 2, 3]\n    >>> popped = pop_all(items)\n    >>> popped is items\n    False\n    >>> popped\n    [1, 2, 3]\n    >>> items\n    []\n    \"\"\"\n    result, items[:] = items[:], []\n    return result\n\n\nclass FreezableDefaultDict(collections.defaultdict):\n    \"\"\"\n    Often it is desirable to prevent the mutation of\n    a default dict after its initial construction, such\n    as to prevent mutation during iteration.\n\n    >>> dd = FreezableDefaultDict(list)\n    >>> dd[0].append('1')\n    >>> dd.freeze()\n    >>> dd[1]\n    []\n    >>> len(dd)\n    1\n    \"\"\"\n\n    def __missing__(self, key):\n        return getattr(self, '_frozen', super().__missing__)(key)\n\n    def freeze(self):\n        self._frozen = lambda key: self.default_factory()\n\n\nclass Accumulator:\n    def __init__(self, initial=0):\n        self.val = initial\n\n    def __call__(self, val):\n        self.val += val\n        return self.val\n\n\nclass WeightedLookup(RangeMap):\n    \"\"\"\n    Given parameters suitable for a dict representing keys\n    and a weighted proportion, return a RangeMap representing\n    spans of values proportial to the weights:\n\n    >>> even = WeightedLookup(a=1, b=1)\n\n    [0, 1) -> a\n    [1, 2) -> b\n\n    >>> lk = WeightedLookup(a=1, b=2)\n\n    [0, 1) -> a\n    [1, 3) -> b\n\n    >>> lk[.5]\n    'a'\n    >>> lk[1.5]\n    'b'\n\n    Adds ``.random()`` to select a random weighted value:\n\n    >>> lk.random() in ['a', 'b']\n    True\n\n    >>> choices = [lk.random() for x in range(1000)]\n\n    Statistically speaking, choices should be .5 a:b\n    >>> ratio = choices.count('a') / choices.count('b')\n    >>> .4 < ratio < .6\n    True\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        raw = dict(*args, **kwargs)\n\n        # allocate keys by weight\n        indexes = map(Accumulator(), raw.values())\n        super().__init__(zip(indexes, raw.keys()), key_match_comparator=operator.lt)\n\n    def random(self):\n        lower, upper = self.bounds()\n        selector = random.random() * upper\n        return self[selector]\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/jaraco/context.py","size":9552,"sha1":"55c7bd380158bae11b727da0bb3a49a12a6d2439","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport contextlib\nimport functools\nimport operator\nimport os\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\nimport urllib.request\nimport warnings\nfrom typing import Iterator\n\n\nif sys.version_info < (3, 12):\n    from backports import tarfile\nelse:\n    import tarfile\n\n\n@contextlib.contextmanager\ndef pushd(dir: str | os.PathLike) -> Iterator[str | os.PathLike]:\n    \"\"\"\n    >>> tmp_path = getfixture('tmp_path')\n    >>> with pushd(tmp_path):\n    ...     assert os.getcwd() == os.fspath(tmp_path)\n    >>> assert os.getcwd() != os.fspath(tmp_path)\n    \"\"\"\n\n    orig = os.getcwd()\n    os.chdir(dir)\n    try:\n        yield dir\n    finally:\n        os.chdir(orig)\n\n\n@contextlib.contextmanager\ndef tarball(\n    url, target_dir: str | os.PathLike | None = None\n) -> Iterator[str | os.PathLike]:\n    \"\"\"\n    Get a tarball, extract it, yield, then clean up.\n\n    >>> import urllib.request\n    >>> url = getfixture('tarfile_served')\n    >>> target = getfixture('tmp_path') / 'out'\n    >>> tb = tarball(url, target_dir=target)\n    >>> import pathlib\n    >>> with tb as extracted:\n    ...     contents = pathlib.Path(extracted, 'contents.txt').read_text(encoding='utf-8')\n    >>> assert not os.path.exists(extracted)\n    \"\"\"\n    if target_dir is None:\n        target_dir = os.path.basename(url).replace('.tar.gz', '').replace('.tgz', '')\n    # In the tar command, use --strip-components=1 to strip the first path and\n    #  then\n    #  use -C to cause the files to be extracted to {target_dir}. This ensures\n    #  that we always know where the files were extracted.\n    os.mkdir(target_dir)\n    try:\n        req = urllib.request.urlopen(url)\n        with tarfile.open(fileobj=req, mode='r|*') as tf:\n            tf.extractall(path=target_dir, filter=strip_first_component)\n        yield target_dir\n    finally:\n        shutil.rmtree(target_dir)\n\n\ndef strip_first_component(\n    member: tarfile.TarInfo,\n    path,\n) -> tarfile.TarInfo:\n    _, member.name = member.name.split('/', 1)\n    return member\n\n\ndef _compose(*cmgrs):\n    \"\"\"\n    Compose any number of dependent context managers into a single one.\n\n    The last, innermost context manager may take arbitrary arguments, but\n    each successive context manager should accept the result from the\n    previous as a single parameter.\n\n    Like :func:`jaraco.functools.compose`, behavior works from right to\n    left, so the context manager should be indicated from outermost to\n    innermost.\n\n    Example, to create a context manager to change to a temporary\n    directory:\n\n    >>> temp_dir_as_cwd = _compose(pushd, temp_dir)\n    >>> with temp_dir_as_cwd() as dir:\n    ...     assert os.path.samefile(os.getcwd(), dir)\n    \"\"\"\n\n    def compose_two(inner, outer):\n        def composed(*args, **kwargs):\n            with inner(*args, **kwargs) as saved, outer(saved) as res:\n                yield res\n\n        return contextlib.contextmanager(composed)\n\n    return functools.reduce(compose_two, reversed(cmgrs))\n\n\ntarball_cwd = _compose(pushd, tarball)\n\n\n@contextlib.contextmanager\ndef tarball_context(*args, **kwargs):\n    warnings.warn(\n        \"tarball_context is deprecated. Use tarball or tarball_cwd instead.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    pushd_ctx = kwargs.pop('pushd', pushd)\n    with tarball(*args, **kwargs) as tball, pushd_ctx(tball) as dir:\n        yield dir\n\n\ndef infer_compression(url):\n    \"\"\"\n    Given a URL or filename, infer the compression code for tar.\n\n    >>> infer_compression('http://foo/bar.tar.gz')\n    'z'\n    >>> infer_compression('http://foo/bar.tgz')\n    'z'\n    >>> infer_compression('file.bz')\n    'j'\n    >>> infer_compression('file.xz')\n    'J'\n    \"\"\"\n    warnings.warn(\n        \"infer_compression is deprecated with no replacement\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    # cheat and just assume it's the last two characters\n    compression_indicator = url[-2:]\n    mapping = dict(gz='z', bz='j', xz='J')\n    # Assume 'z' (gzip) if no match\n    return mapping.get(compression_indicator, 'z')\n\n\n@contextlib.contextmanager\ndef temp_dir(remover=shutil.rmtree):\n    \"\"\"\n    Create a temporary directory context. Pass a custom remover\n    to override the removal behavior.\n\n    >>> import pathlib\n    >>> with temp_dir() as the_dir:\n    ...     assert os.path.isdir(the_dir)\n    ...     _ = pathlib.Path(the_dir).joinpath('somefile').write_text('contents', encoding='utf-8')\n    >>> assert not os.path.exists(the_dir)\n    \"\"\"\n    temp_dir = tempfile.mkdtemp()\n    try:\n        yield temp_dir\n    finally:\n        remover(temp_dir)\n\n\n@contextlib.contextmanager\ndef repo_context(url, branch=None, quiet=True, dest_ctx=temp_dir):\n    \"\"\"\n    Check out the repo indicated by url.\n\n    If dest_ctx is supplied, it should be a context manager\n    to yield the target directory for the check out.\n    \"\"\"\n    exe = 'git' if 'git' in url else 'hg'\n    with dest_ctx() as repo_dir:\n        cmd = [exe, 'clone', url, repo_dir]\n        if branch:\n            cmd.extend(['--branch', branch])\n        devnull = open(os.path.devnull, 'w')\n        stdout = devnull if quiet else None\n        subprocess.check_call(cmd, stdout=stdout)\n        yield repo_dir\n\n\ndef null():\n    \"\"\"\n    A null context suitable to stand in for a meaningful context.\n\n    >>> with null() as value:\n    ...     assert value is None\n\n    This context is most useful when dealing with two or more code\n    branches but only some need a context. Wrap the others in a null\n    context to provide symmetry across all options.\n    \"\"\"\n    warnings.warn(\n        \"null is deprecated. Use contextlib.nullcontext\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return contextlib.nullcontext()\n\n\nclass ExceptionTrap:\n    \"\"\"\n    A context manager that will catch certain exceptions and provide an\n    indication they occurred.\n\n    >>> with ExceptionTrap() as trap:\n    ...     raise Exception()\n    >>> bool(trap)\n    True\n\n    >>> with ExceptionTrap() as trap:\n    ...     pass\n    >>> bool(trap)\n    False\n\n    >>> with ExceptionTrap(ValueError) as trap:\n    ...     raise ValueError(\"1 + 1 is not 3\")\n    >>> bool(trap)\n    True\n    >>> trap.value\n    ValueError('1 + 1 is not 3')\n    >>> trap.tb\n    <traceback object at ...>\n\n    >>> with ExceptionTrap(ValueError) as trap:\n    ...     raise Exception()\n    Traceback (most recent call last):\n    ...\n    Exception\n\n    >>> bool(trap)\n    False\n    \"\"\"\n\n    exc_info = None, None, None\n\n    def __init__(self, exceptions=(Exception,)):\n        self.exceptions = exceptions\n\n    def __enter__(self):\n        return self\n\n    @property\n    def type(self):\n        return self.exc_info[0]\n\n    @property\n    def value(self):\n        return self.exc_info[1]\n\n    @property\n    def tb(self):\n        return self.exc_info[2]\n\n    def __exit__(self, *exc_info):\n        type = exc_info[0]\n        matches = type and issubclass(type, self.exceptions)\n        if matches:\n            self.exc_info = exc_info\n        return matches\n\n    def __bool__(self):\n        return bool(self.type)\n\n    def raises(self, func, *, _test=bool):\n        \"\"\"\n        Wrap func and replace the result with the truth\n        value of the trap (True if an exception occurred).\n\n        First, give the decorator an alias to support Python 3.8\n        Syntax.\n\n        >>> raises = ExceptionTrap(ValueError).raises\n\n        Now decorate a function that always fails.\n\n        >>> @raises\n        ... def fail():\n        ...     raise ValueError('failed')\n        >>> fail()\n        True\n        \"\"\"\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with ExceptionTrap(self.exceptions) as trap:\n                func(*args, **kwargs)\n            return _test(trap)\n\n        return wrapper\n\n    def passes(self, func):\n        \"\"\"\n        Wrap func and replace the result with the truth\n        value of the trap (True if no exception).\n\n        First, give the decorator an alias to support Python 3.8\n        Syntax.\n\n        >>> passes = ExceptionTrap(ValueError).passes\n\n        Now decorate a function that always fails.\n\n        >>> @passes\n        ... def fail():\n        ...     raise ValueError('failed')\n\n        >>> fail()\n        False\n        \"\"\"\n        return self.raises(func, _test=operator.not_)\n\n\nclass suppress(contextlib.suppress, contextlib.ContextDecorator):\n    \"\"\"\n    A version of contextlib.suppress with decorator support.\n\n    >>> @suppress(KeyError)\n    ... def key_error():\n    ...     {}['']\n    >>> key_error()\n    \"\"\"\n\n\nclass on_interrupt(contextlib.ContextDecorator):\n    \"\"\"\n    Replace a KeyboardInterrupt with SystemExit(1)\n\n    >>> def do_interrupt():\n    ...     raise KeyboardInterrupt()\n    >>> on_interrupt('error')(do_interrupt)()\n    Traceback (most recent call last):\n    ...\n    SystemExit: 1\n    >>> on_interrupt('error', code=255)(do_interrupt)()\n    Traceback (most recent call last):\n    ...\n    SystemExit: 255\n    >>> on_interrupt('suppress')(do_interrupt)()\n    >>> with __import__('pytest').raises(KeyboardInterrupt):\n    ...     on_interrupt('ignore')(do_interrupt)()\n    \"\"\"\n\n    def __init__(self, action='error', /, code=1):\n        self.action = action\n        self.code = code\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exctype, excinst, exctb):\n        if exctype is not KeyboardInterrupt or self.action == 'ignore':\n            return\n        elif self.action == 'error':\n            raise SystemExit(self.code) from excinst\n        return self.action == 'suppress'\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/jaraco/functools/__init__.py","size":16642,"sha1":"c44861f47c804886cc329f6f2ff3f6b78b1afe16","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import collections.abc\nimport functools\nimport inspect\nimport itertools\nimport operator\nimport time\nimport types\nimport warnings\n\nimport more_itertools\n\n\ndef compose(*funcs):\n    \"\"\"\n    Compose any number of unary functions into a single unary function.\n\n    >>> import textwrap\n    >>> expected = str.strip(textwrap.dedent(compose.__doc__))\n    >>> strip_and_dedent = compose(str.strip, textwrap.dedent)\n    >>> strip_and_dedent(compose.__doc__) == expected\n    True\n\n    Compose also allows the innermost function to take arbitrary arguments.\n\n    >>> round_three = lambda x: round(x, ndigits=3)\n    >>> f = compose(round_three, int.__truediv__)\n    >>> [f(3*x, x+1) for x in range(1,10)]\n    [1.5, 2.0, 2.25, 2.4, 2.5, 2.571, 2.625, 2.667, 2.7]\n    \"\"\"\n\n    def compose_two(f1, f2):\n        return lambda *args, **kwargs: f1(f2(*args, **kwargs))\n\n    return functools.reduce(compose_two, funcs)\n\n\ndef once(func):\n    \"\"\"\n    Decorate func so it's only ever called the first time.\n\n    This decorator can ensure that an expensive or non-idempotent function\n    will not be expensive on subsequent calls and is idempotent.\n\n    >>> add_three = once(lambda a: a+3)\n    >>> add_three(3)\n    6\n    >>> add_three(9)\n    6\n    >>> add_three('12')\n    6\n\n    To reset the stored value, simply clear the property ``saved_result``.\n\n    >>> del add_three.saved_result\n    >>> add_three(9)\n    12\n    >>> add_three(8)\n    12\n\n    Or invoke 'reset()' on it.\n\n    >>> add_three.reset()\n    >>> add_three(-3)\n    0\n    >>> add_three(0)\n    0\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        if not hasattr(wrapper, 'saved_result'):\n            wrapper.saved_result = func(*args, **kwargs)\n        return wrapper.saved_result\n\n    wrapper.reset = lambda: vars(wrapper).__delitem__('saved_result')\n    return wrapper\n\n\ndef method_cache(method, cache_wrapper=functools.lru_cache()):\n    \"\"\"\n    Wrap lru_cache to support storing the cache data in the object instances.\n\n    Abstracts the common paradigm where the method explicitly saves an\n    underscore-prefixed protected property on first call and returns that\n    subsequently.\n\n    >>> class MyClass:\n    ...     calls = 0\n    ...\n    ...     @method_cache\n    ...     def method(self, value):\n    ...         self.calls += 1\n    ...         return value\n\n    >>> a = MyClass()\n    >>> a.method(3)\n    3\n    >>> for x in range(75):\n    ...     res = a.method(x)\n    >>> a.calls\n    75\n\n    Note that the apparent behavior will be exactly like that of lru_cache\n    except that the cache is stored on each instance, so values in one\n    instance will not flush values from another, and when an instance is\n    deleted, so are the cached values for that instance.\n\n    >>> b = MyClass()\n    >>> for x in range(35):\n    ...     res = b.method(x)\n    >>> b.calls\n    35\n    >>> a.method(0)\n    0\n    >>> a.calls\n    75\n\n    Note that if method had been decorated with ``functools.lru_cache()``,\n    a.calls would have been 76 (due to the cached value of 0 having been\n    flushed by the 'b' instance).\n\n    Clear the cache with ``.cache_clear()``\n\n    >>> a.method.cache_clear()\n\n    Same for a method that hasn't yet been called.\n\n    >>> c = MyClass()\n    >>> c.method.cache_clear()\n\n    Another cache wrapper may be supplied:\n\n    >>> cache = functools.lru_cache(maxsize=2)\n    >>> MyClass.method2 = method_cache(lambda self: 3, cache_wrapper=cache)\n    >>> a = MyClass()\n    >>> a.method2()\n    3\n\n    Caution - do not subsequently wrap the method with another decorator, such\n    as ``@property``, which changes the semantics of the function.\n\n    See also\n    http://code.activestate.com/recipes/577452-a-memoize-decorator-for-instance-methods/\n    for another implementation and additional justification.\n    \"\"\"\n\n    def wrapper(self, *args, **kwargs):\n        # it's the first call, replace the method with a cached, bound method\n        bound_method = types.MethodType(method, self)\n        cached_method = cache_wrapper(bound_method)\n        setattr(self, method.__name__, cached_method)\n        return cached_method(*args, **kwargs)\n\n    # Support cache clear even before cache has been created.\n    wrapper.cache_clear = lambda: None\n\n    return _special_method_cache(method, cache_wrapper) or wrapper\n\n\ndef _special_method_cache(method, cache_wrapper):\n    \"\"\"\n    Because Python treats special methods differently, it's not\n    possible to use instance attributes to implement the cached\n    methods.\n\n    Instead, install the wrapper method under a different name\n    and return a simple proxy to that wrapper.\n\n    https://github.com/jaraco/jaraco.functools/issues/5\n    \"\"\"\n    name = method.__name__\n    special_names = '__getattr__', '__getitem__'\n\n    if name not in special_names:\n        return None\n\n    wrapper_name = '__cached' + name\n\n    def proxy(self, /, *args, **kwargs):\n        if wrapper_name not in vars(self):\n            bound = types.MethodType(method, self)\n            cache = cache_wrapper(bound)\n            setattr(self, wrapper_name, cache)\n        else:\n            cache = getattr(self, wrapper_name)\n        return cache(*args, **kwargs)\n\n    return proxy\n\n\ndef apply(transform):\n    \"\"\"\n    Decorate a function with a transform function that is\n    invoked on results returned from the decorated function.\n\n    >>> @apply(reversed)\n    ... def get_numbers(start):\n    ...     \"doc for get_numbers\"\n    ...     return range(start, start+3)\n    >>> list(get_numbers(4))\n    [6, 5, 4]\n    >>> get_numbers.__doc__\n    'doc for get_numbers'\n    \"\"\"\n\n    def wrap(func):\n        return functools.wraps(func)(compose(transform, func))\n\n    return wrap\n\n\ndef result_invoke(action):\n    r\"\"\"\n    Decorate a function with an action function that is\n    invoked on the results returned from the decorated\n    function (for its side effect), then return the original\n    result.\n\n    >>> @result_invoke(print)\n    ... def add_two(a, b):\n    ...     return a + b\n    >>> x = add_two(2, 3)\n    5\n    >>> x\n    5\n    \"\"\"\n\n    def wrap(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            result = func(*args, **kwargs)\n            action(result)\n            return result\n\n        return wrapper\n\n    return wrap\n\n\ndef invoke(f, /, *args, **kwargs):\n    \"\"\"\n    Call a function for its side effect after initialization.\n\n    The benefit of using the decorator instead of simply invoking a function\n    after defining it is that it makes explicit the author's intent for the\n    function to be called immediately. Whereas if one simply calls the\n    function immediately, it's less obvious if that was intentional or\n    incidental. It also avoids repeating the name - the two actions, defining\n    the function and calling it immediately are modeled separately, but linked\n    by the decorator construct.\n\n    The benefit of having a function construct (opposed to just invoking some\n    behavior inline) is to serve as a scope in which the behavior occurs. It\n    avoids polluting the global namespace with local variables, provides an\n    anchor on which to attach documentation (docstring), keeps the behavior\n    logically separated (instead of conceptually separated or not separated at\n    all), and provides potential to re-use the behavior for testing or other\n    purposes.\n\n    This function is named as a pithy way to communicate, \"call this function\n    primarily for its side effect\", or \"while defining this function, also\n    take it aside and call it\". It exists because there's no Python construct\n    for \"define and call\" (nor should there be, as decorators serve this need\n    just fine). The behavior happens immediately and synchronously.\n\n    >>> @invoke\n    ... def func(): print(\"called\")\n    called\n    >>> func()\n    called\n\n    Use functools.partial to pass parameters to the initial call\n\n    >>> @functools.partial(invoke, name='bingo')\n    ... def func(name): print('called with', name)\n    called with bingo\n    \"\"\"\n    f(*args, **kwargs)\n    return f\n\n\nclass Throttler:\n    \"\"\"Rate-limit a function (or other callable).\"\"\"\n\n    def __init__(self, func, max_rate=float('Inf')):\n        if isinstance(func, Throttler):\n            func = func.func\n        self.func = func\n        self.max_rate = max_rate\n        self.reset()\n\n    def reset(self):\n        self.last_called = 0\n\n    def __call__(self, *args, **kwargs):\n        self._wait()\n        return self.func(*args, **kwargs)\n\n    def _wait(self):\n        \"\"\"Ensure at least 1/max_rate seconds from last call.\"\"\"\n        elapsed = time.time() - self.last_called\n        must_wait = 1 / self.max_rate - elapsed\n        time.sleep(max(0, must_wait))\n        self.last_called = time.time()\n\n    def __get__(self, obj, owner=None):\n        return first_invoke(self._wait, functools.partial(self.func, obj))\n\n\ndef first_invoke(func1, func2):\n    \"\"\"\n    Return a function that when invoked will invoke func1 without\n    any parameters (for its side effect) and then invoke func2\n    with whatever parameters were passed, returning its result.\n    \"\"\"\n\n    def wrapper(*args, **kwargs):\n        func1()\n        return func2(*args, **kwargs)\n\n    return wrapper\n\n\nmethod_caller = first_invoke(\n    lambda: warnings.warn(\n        '`jaraco.functools.method_caller` is deprecated, '\n        'use `operator.methodcaller` instead',\n        DeprecationWarning,\n        stacklevel=3,\n    ),\n    operator.methodcaller,\n)\n\n\ndef retry_call(func, cleanup=lambda: None, retries=0, trap=()):\n    \"\"\"\n    Given a callable func, trap the indicated exceptions\n    for up to 'retries' times, invoking cleanup on the\n    exception. On the final attempt, allow any exceptions\n    to propagate.\n    \"\"\"\n    attempts = itertools.count() if retries == float('inf') else range(retries)\n    for _ in attempts:\n        try:\n            return func()\n        except trap:\n            cleanup()\n\n    return func()\n\n\ndef retry(*r_args, **r_kwargs):\n    \"\"\"\n    Decorator wrapper for retry_call. Accepts arguments to retry_call\n    except func and then returns a decorator for the decorated function.\n\n    Ex:\n\n    >>> @retry(retries=3)\n    ... def my_func(a, b):\n    ...     \"this is my funk\"\n    ...     print(a, b)\n    >>> my_func.__doc__\n    'this is my funk'\n    \"\"\"\n\n    def decorate(func):\n        @functools.wraps(func)\n        def wrapper(*f_args, **f_kwargs):\n            bound = functools.partial(func, *f_args, **f_kwargs)\n            return retry_call(bound, *r_args, **r_kwargs)\n\n        return wrapper\n\n    return decorate\n\n\ndef print_yielded(func):\n    \"\"\"\n    Convert a generator into a function that prints all yielded elements.\n\n    >>> @print_yielded\n    ... def x():\n    ...     yield 3; yield None\n    >>> x()\n    3\n    None\n    \"\"\"\n    print_all = functools.partial(map, print)\n    print_results = compose(more_itertools.consume, print_all, func)\n    return functools.wraps(func)(print_results)\n\n\ndef pass_none(func):\n    \"\"\"\n    Wrap func so it's not called if its first param is None.\n\n    >>> print_text = pass_none(print)\n    >>> print_text('text')\n    text\n    >>> print_text(None)\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(param, /, *args, **kwargs):\n        if param is not None:\n            return func(param, *args, **kwargs)\n        return None\n\n    return wrapper\n\n\ndef assign_params(func, namespace):\n    \"\"\"\n    Assign parameters from namespace where func solicits.\n\n    >>> def func(x, y=3):\n    ...     print(x, y)\n    >>> assigned = assign_params(func, dict(x=2, z=4))\n    >>> assigned()\n    2 3\n\n    The usual errors are raised if a function doesn't receive\n    its required parameters:\n\n    >>> assigned = assign_params(func, dict(y=3, z=4))\n    >>> assigned()\n    Traceback (most recent call last):\n    TypeError: func() ...argument...\n\n    It even works on methods:\n\n    >>> class Handler:\n    ...     def meth(self, arg):\n    ...         print(arg)\n    >>> assign_params(Handler().meth, dict(arg='crystal', foo='clear'))()\n    crystal\n    \"\"\"\n    sig = inspect.signature(func)\n    params = sig.parameters.keys()\n    call_ns = {k: namespace[k] for k in params if k in namespace}\n    return functools.partial(func, **call_ns)\n\n\ndef save_method_args(method):\n    \"\"\"\n    Wrap a method such that when it is called, the args and kwargs are\n    saved on the method.\n\n    >>> class MyClass:\n    ...     @save_method_args\n    ...     def method(self, a, b):\n    ...         print(a, b)\n    >>> my_ob = MyClass()\n    >>> my_ob.method(1, 2)\n    1 2\n    >>> my_ob._saved_method.args\n    (1, 2)\n    >>> my_ob._saved_method.kwargs\n    {}\n    >>> my_ob.method(a=3, b='foo')\n    3 foo\n    >>> my_ob._saved_method.args\n    ()\n    >>> my_ob._saved_method.kwargs == dict(a=3, b='foo')\n    True\n\n    The arguments are stored on the instance, allowing for\n    different instance to save different args.\n\n    >>> your_ob = MyClass()\n    >>> your_ob.method({str('x'): 3}, b=[4])\n    {'x': 3} [4]\n    >>> your_ob._saved_method.args\n    ({'x': 3},)\n    >>> my_ob._saved_method.args\n    ()\n    \"\"\"\n    args_and_kwargs = collections.namedtuple('args_and_kwargs', 'args kwargs')\n\n    @functools.wraps(method)\n    def wrapper(self, /, *args, **kwargs):\n        attr_name = '_saved_' + method.__name__\n        attr = args_and_kwargs(args, kwargs)\n        setattr(self, attr_name, attr)\n        return method(self, *args, **kwargs)\n\n    return wrapper\n\n\ndef except_(*exceptions, replace=None, use=None):\n    \"\"\"\n    Replace the indicated exceptions, if raised, with the indicated\n    literal replacement or evaluated expression (if present).\n\n    >>> safe_int = except_(ValueError)(int)\n    >>> safe_int('five')\n    >>> safe_int('5')\n    5\n\n    Specify a literal replacement with ``replace``.\n\n    >>> safe_int_r = except_(ValueError, replace=0)(int)\n    >>> safe_int_r('five')\n    0\n\n    Provide an expression to ``use`` to pass through particular parameters.\n\n    >>> safe_int_pt = except_(ValueError, use='args[0]')(int)\n    >>> safe_int_pt('five')\n    'five'\n\n    \"\"\"\n\n    def decorate(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                return func(*args, **kwargs)\n            except exceptions:\n                try:\n                    return eval(use)\n                except TypeError:\n                    return replace\n\n        return wrapper\n\n    return decorate\n\n\ndef identity(x):\n    \"\"\"\n    Return the argument.\n\n    >>> o = object()\n    >>> identity(o) is o\n    True\n    \"\"\"\n    return x\n\n\ndef bypass_when(check, *, _op=identity):\n    \"\"\"\n    Decorate a function to return its parameter when ``check``.\n\n    >>> bypassed = []  # False\n\n    >>> @bypass_when(bypassed)\n    ... def double(x):\n    ...     return x * 2\n    >>> double(2)\n    4\n    >>> bypassed[:] = [object()]  # True\n    >>> double(2)\n    2\n    \"\"\"\n\n    def decorate(func):\n        @functools.wraps(func)\n        def wrapper(param, /):\n            return param if _op(check) else func(param)\n\n        return wrapper\n\n    return decorate\n\n\ndef bypass_unless(check):\n    \"\"\"\n    Decorate a function to return its parameter unless ``check``.\n\n    >>> enabled = [object()]  # True\n\n    >>> @bypass_unless(enabled)\n    ... def double(x):\n    ...     return x * 2\n    >>> double(2)\n    4\n    >>> del enabled[:]  # False\n    >>> double(2)\n    2\n    \"\"\"\n    return bypass_when(check, _op=operator.not_)\n\n\n@functools.singledispatch\ndef _splat_inner(args, func):\n    \"\"\"Splat args to func.\"\"\"\n    return func(*args)\n\n\n@_splat_inner.register\ndef _(args: collections.abc.Mapping, func):\n    \"\"\"Splat kargs to func as kwargs.\"\"\"\n    return func(**args)\n\n\ndef splat(func):\n    \"\"\"\n    Wrap func to expect its parameters to be passed positionally in a tuple.\n\n    Has a similar effect to that of ``itertools.starmap`` over\n    simple ``map``.\n\n    >>> pairs = [(-1, 1), (0, 2)]\n    >>> more_itertools.consume(itertools.starmap(print, pairs))\n    -1 1\n    0 2\n    >>> more_itertools.consume(map(splat(print), pairs))\n    -1 1\n    0 2\n\n    The approach generalizes to other iterators that don't have a \"star\"\n    equivalent, such as a \"starfilter\".\n\n    >>> list(filter(splat(operator.add), pairs))\n    [(0, 2)]\n\n    Splat also accepts a mapping argument.\n\n    >>> def is_nice(msg, code):\n    ...     return \"smile\" in msg or code == 0\n    >>> msgs = [\n    ...     dict(msg='smile!', code=20),\n    ...     dict(msg='error :(', code=1),\n    ...     dict(msg='unknown', code=0),\n    ... ]\n    >>> for msg in filter(splat(is_nice), msgs):\n    ...     print(msg)\n    {'msg': 'smile!', 'code': 20}\n    {'msg': 'unknown', 'code': 0}\n    \"\"\"\n    return functools.wraps(func)(functools.partial(_splat_inner, func=func))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/jaraco/text/__init__.py","size":16250,"sha1":"fe6f776668febb0965e43e5afba2d1f57bf140f3","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import re\nimport itertools\nimport textwrap\nimport functools\n\ntry:\n    from importlib.resources import files  # type: ignore\nexcept ImportError:  # pragma: nocover\n    from importlib_resources import files  # type: ignore\n\nfrom jaraco.functools import compose, method_cache\nfrom jaraco.context import ExceptionTrap\n\n\ndef substitution(old, new):\n    \"\"\"\n    Return a function that will perform a substitution on a string\n    \"\"\"\n    return lambda s: s.replace(old, new)\n\n\ndef multi_substitution(*substitutions):\n    \"\"\"\n    Take a sequence of pairs specifying substitutions, and create\n    a function that performs those substitutions.\n\n    >>> multi_substitution(('foo', 'bar'), ('bar', 'baz'))('foo')\n    'baz'\n    \"\"\"\n    substitutions = itertools.starmap(substitution, substitutions)\n    # compose function applies last function first, so reverse the\n    #  substitutions to get the expected order.\n    substitutions = reversed(tuple(substitutions))\n    return compose(*substitutions)\n\n\nclass FoldedCase(str):\n    \"\"\"\n    A case insensitive string class; behaves just like str\n    except compares equal when the only variation is case.\n\n    >>> s = FoldedCase('hello world')\n\n    >>> s == 'Hello World'\n    True\n\n    >>> 'Hello World' == s\n    True\n\n    >>> s != 'Hello World'\n    False\n\n    >>> s.index('O')\n    4\n\n    >>> s.split('O')\n    ['hell', ' w', 'rld']\n\n    >>> sorted(map(FoldedCase, ['GAMMA', 'alpha', 'Beta']))\n    ['alpha', 'Beta', 'GAMMA']\n\n    Sequence membership is straightforward.\n\n    >>> \"Hello World\" in [s]\n    True\n    >>> s in [\"Hello World\"]\n    True\n\n    Allows testing for set inclusion, but candidate and elements\n    must both be folded.\n\n    >>> FoldedCase(\"Hello World\") in {s}\n    True\n    >>> s in {FoldedCase(\"Hello World\")}\n    True\n\n    String inclusion works as long as the FoldedCase object\n    is on the right.\n\n    >>> \"hello\" in FoldedCase(\"Hello World\")\n    True\n\n    But not if the FoldedCase object is on the left:\n\n    >>> FoldedCase('hello') in 'Hello World'\n    False\n\n    In that case, use ``in_``:\n\n    >>> FoldedCase('hello').in_('Hello World')\n    True\n\n    >>> FoldedCase('hello') > FoldedCase('Hello')\n    False\n\n    >>> FoldedCase('') == FoldedCase('ss')\n    True\n    \"\"\"\n\n    def __lt__(self, other):\n        return self.casefold() < other.casefold()\n\n    def __gt__(self, other):\n        return self.casefold() > other.casefold()\n\n    def __eq__(self, other):\n        return self.casefold() == other.casefold()\n\n    def __ne__(self, other):\n        return self.casefold() != other.casefold()\n\n    def __hash__(self):\n        return hash(self.casefold())\n\n    def __contains__(self, other):\n        return super().casefold().__contains__(other.casefold())\n\n    def in_(self, other):\n        \"Does self appear in other?\"\n        return self in FoldedCase(other)\n\n    # cache casefold since it's likely to be called frequently.\n    @method_cache\n    def casefold(self):\n        return super().casefold()\n\n    def index(self, sub):\n        return self.casefold().index(sub.casefold())\n\n    def split(self, splitter=' ', maxsplit=0):\n        pattern = re.compile(re.escape(splitter), re.I)\n        return pattern.split(self, maxsplit)\n\n\n# Python 3.8 compatibility\n_unicode_trap = ExceptionTrap(UnicodeDecodeError)\n\n\n@_unicode_trap.passes\ndef is_decodable(value):\n    r\"\"\"\n    Return True if the supplied value is decodable (using the default\n    encoding).\n\n    >>> is_decodable(b'\\xff')\n    False\n    >>> is_decodable(b'\\x32')\n    True\n    \"\"\"\n    value.decode()\n\n\ndef is_binary(value):\n    r\"\"\"\n    Return True if the value appears to be binary (that is, it's a byte\n    string and isn't decodable).\n\n    >>> is_binary(b'\\xff')\n    True\n    >>> is_binary('\\xff')\n    False\n    \"\"\"\n    return isinstance(value, bytes) and not is_decodable(value)\n\n\ndef trim(s):\n    r\"\"\"\n    Trim something like a docstring to remove the whitespace that\n    is common due to indentation and formatting.\n\n    >>> trim(\"\\n\\tfoo = bar\\n\\t\\tbar = baz\\n\")\n    'foo = bar\\n\\tbar = baz'\n    \"\"\"\n    return textwrap.dedent(s).strip()\n\n\ndef wrap(s):\n    \"\"\"\n    Wrap lines of text, retaining existing newlines as\n    paragraph markers.\n\n    >>> print(wrap(lorem_ipsum))\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do\n    eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad\n    minim veniam, quis nostrud exercitation ullamco laboris nisi ut\n    aliquip ex ea commodo consequat. Duis aute irure dolor in\n    reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla\n    pariatur. Excepteur sint occaecat cupidatat non proident, sunt in\n    culpa qui officia deserunt mollit anim id est laborum.\n    <BLANKLINE>\n    Curabitur pretium tincidunt lacus. Nulla gravida orci a odio. Nullam\n    varius, turpis et commodo pharetra, est eros bibendum elit, nec luctus\n    magna felis sollicitudin mauris. Integer in mauris eu nibh euismod\n    gravida. Duis ac tellus et risus vulputate vehicula. Donec lobortis\n    risus a elit. Etiam tempor. Ut ullamcorper, ligula eu tempor congue,\n    eros est euismod turpis, id tincidunt sapien risus a quam. Maecenas\n    fermentum consequat mi. Donec fermentum. Pellentesque malesuada nulla\n    a mi. Duis sapien sem, aliquet nec, commodo eget, consequat quis,\n    neque. Aliquam faucibus, elit ut dictum aliquet, felis nisl adipiscing\n    sapien, sed malesuada diam lacus eget erat. Cras mollis scelerisque\n    nunc. Nullam arcu. Aliquam consequat. Curabitur augue lorem, dapibus\n    quis, laoreet et, pretium ac, nisi. Aenean magna nisl, mollis quis,\n    molestie eu, feugiat in, orci. In hac habitasse platea dictumst.\n    \"\"\"\n    paragraphs = s.splitlines()\n    wrapped = ('\\n'.join(textwrap.wrap(para)) for para in paragraphs)\n    return '\\n\\n'.join(wrapped)\n\n\ndef unwrap(s):\n    r\"\"\"\n    Given a multi-line string, return an unwrapped version.\n\n    >>> wrapped = wrap(lorem_ipsum)\n    >>> wrapped.count('\\n')\n    20\n    >>> unwrapped = unwrap(wrapped)\n    >>> unwrapped.count('\\n')\n    1\n    >>> print(unwrapped)\n    Lorem ipsum dolor sit amet, consectetur adipiscing ...\n    Curabitur pretium tincidunt lacus. Nulla gravida orci ...\n\n    \"\"\"\n    paragraphs = re.split(r'\\n\\n+', s)\n    cleaned = (para.replace('\\n', ' ') for para in paragraphs)\n    return '\\n'.join(cleaned)\n\n\nlorem_ipsum: str = (\n    files(__name__).joinpath('Lorem ipsum.txt').read_text(encoding='utf-8')\n)\n\n\nclass Splitter:\n    \"\"\"object that will split a string with the given arguments for each call\n\n    >>> s = Splitter(',')\n    >>> s('hello, world, this is your, master calling')\n    ['hello', ' world', ' this is your', ' master calling']\n    \"\"\"\n\n    def __init__(self, *args):\n        self.args = args\n\n    def __call__(self, s):\n        return s.split(*self.args)\n\n\ndef indent(string, prefix=' ' * 4):\n    \"\"\"\n    >>> indent('foo')\n    '    foo'\n    \"\"\"\n    return prefix + string\n\n\nclass WordSet(tuple):\n    \"\"\"\n    Given an identifier, return the words that identifier represents,\n    whether in camel case, underscore-separated, etc.\n\n    >>> WordSet.parse(\"camelCase\")\n    ('camel', 'Case')\n\n    >>> WordSet.parse(\"under_sep\")\n    ('under', 'sep')\n\n    Acronyms should be retained\n\n    >>> WordSet.parse(\"firstSNL\")\n    ('first', 'SNL')\n\n    >>> WordSet.parse(\"you_and_I\")\n    ('you', 'and', 'I')\n\n    >>> WordSet.parse(\"A simple test\")\n    ('A', 'simple', 'test')\n\n    Multiple caps should not interfere with the first cap of another word.\n\n    >>> WordSet.parse(\"myABCClass\")\n    ('my', 'ABC', 'Class')\n\n    The result is a WordSet, providing access to other forms.\n\n    >>> WordSet.parse(\"myABCClass\").underscore_separated()\n    'my_ABC_Class'\n\n    >>> WordSet.parse('a-command').camel_case()\n    'ACommand'\n\n    >>> WordSet.parse('someIdentifier').lowered().space_separated()\n    'some identifier'\n\n    Slices of the result should return another WordSet.\n\n    >>> WordSet.parse('taken-out-of-context')[1:].underscore_separated()\n    'out_of_context'\n\n    >>> WordSet.from_class_name(WordSet()).lowered().space_separated()\n    'word set'\n\n    >>> example = WordSet.parse('figured it out')\n    >>> example.headless_camel_case()\n    'figuredItOut'\n    >>> example.dash_separated()\n    'figured-it-out'\n\n    \"\"\"\n\n    _pattern = re.compile('([A-Z]?[a-z]+)|([A-Z]+(?![a-z]))')\n\n    def capitalized(self):\n        return WordSet(word.capitalize() for word in self)\n\n    def lowered(self):\n        return WordSet(word.lower() for word in self)\n\n    def camel_case(self):\n        return ''.join(self.capitalized())\n\n    def headless_camel_case(self):\n        words = iter(self)\n        first = next(words).lower()\n        new_words = itertools.chain((first,), WordSet(words).camel_case())\n        return ''.join(new_words)\n\n    def underscore_separated(self):\n        return '_'.join(self)\n\n    def dash_separated(self):\n        return '-'.join(self)\n\n    def space_separated(self):\n        return ' '.join(self)\n\n    def trim_right(self, item):\n        \"\"\"\n        Remove the item from the end of the set.\n\n        >>> WordSet.parse('foo bar').trim_right('foo')\n        ('foo', 'bar')\n        >>> WordSet.parse('foo bar').trim_right('bar')\n        ('foo',)\n        >>> WordSet.parse('').trim_right('bar')\n        ()\n        \"\"\"\n        return self[:-1] if self and self[-1] == item else self\n\n    def trim_left(self, item):\n        \"\"\"\n        Remove the item from the beginning of the set.\n\n        >>> WordSet.parse('foo bar').trim_left('foo')\n        ('bar',)\n        >>> WordSet.parse('foo bar').trim_left('bar')\n        ('foo', 'bar')\n        >>> WordSet.parse('').trim_left('bar')\n        ()\n        \"\"\"\n        return self[1:] if self and self[0] == item else self\n\n    def trim(self, item):\n        \"\"\"\n        >>> WordSet.parse('foo bar').trim('foo')\n        ('bar',)\n        \"\"\"\n        return self.trim_left(item).trim_right(item)\n\n    def __getitem__(self, item):\n        result = super().__getitem__(item)\n        if isinstance(item, slice):\n            result = WordSet(result)\n        return result\n\n    @classmethod\n    def parse(cls, identifier):\n        matches = cls._pattern.finditer(identifier)\n        return WordSet(match.group(0) for match in matches)\n\n    @classmethod\n    def from_class_name(cls, subject):\n        return cls.parse(subject.__class__.__name__)\n\n\n# for backward compatibility\nwords = WordSet.parse\n\n\ndef simple_html_strip(s):\n    r\"\"\"\n    Remove HTML from the string `s`.\n\n    >>> str(simple_html_strip(''))\n    ''\n\n    >>> print(simple_html_strip('A <bold>stormy</bold> day in paradise'))\n    A stormy day in paradise\n\n    >>> print(simple_html_strip('Somebody <!-- do not --> tell the truth.'))\n    Somebody  tell the truth.\n\n    >>> print(simple_html_strip('What about<br/>\\nmultiple lines?'))\n    What about\n    multiple lines?\n    \"\"\"\n    html_stripper = re.compile('(<!--.*?-->)|(<[^>]*>)|([^<]+)', re.DOTALL)\n    texts = (match.group(3) or '' for match in html_stripper.finditer(s))\n    return ''.join(texts)\n\n\nclass SeparatedValues(str):\n    \"\"\"\n    A string separated by a separator. Overrides __iter__ for getting\n    the values.\n\n    >>> list(SeparatedValues('a,b,c'))\n    ['a', 'b', 'c']\n\n    Whitespace is stripped and empty values are discarded.\n\n    >>> list(SeparatedValues(' a,   b   , c,  '))\n    ['a', 'b', 'c']\n    \"\"\"\n\n    separator = ','\n\n    def __iter__(self):\n        parts = self.split(self.separator)\n        return filter(None, (part.strip() for part in parts))\n\n\nclass Stripper:\n    r\"\"\"\n    Given a series of lines, find the common prefix and strip it from them.\n\n    >>> lines = [\n    ...     'abcdefg\\n',\n    ...     'abc\\n',\n    ...     'abcde\\n',\n    ... ]\n    >>> res = Stripper.strip_prefix(lines)\n    >>> res.prefix\n    'abc'\n    >>> list(res.lines)\n    ['defg\\n', '\\n', 'de\\n']\n\n    If no prefix is common, nothing should be stripped.\n\n    >>> lines = [\n    ...     'abcd\\n',\n    ...     '1234\\n',\n    ... ]\n    >>> res = Stripper.strip_prefix(lines)\n    >>> res.prefix = ''\n    >>> list(res.lines)\n    ['abcd\\n', '1234\\n']\n    \"\"\"\n\n    def __init__(self, prefix, lines):\n        self.prefix = prefix\n        self.lines = map(self, lines)\n\n    @classmethod\n    def strip_prefix(cls, lines):\n        prefix_lines, lines = itertools.tee(lines)\n        prefix = functools.reduce(cls.common_prefix, prefix_lines)\n        return cls(prefix, lines)\n\n    def __call__(self, line):\n        if not self.prefix:\n            return line\n        null, prefix, rest = line.partition(self.prefix)\n        return rest\n\n    @staticmethod\n    def common_prefix(s1, s2):\n        \"\"\"\n        Return the common prefix of two lines.\n        \"\"\"\n        index = min(len(s1), len(s2))\n        while s1[:index] != s2[:index]:\n            index -= 1\n        return s1[:index]\n\n\ndef remove_prefix(text, prefix):\n    \"\"\"\n    Remove the prefix from the text if it exists.\n\n    >>> remove_prefix('underwhelming performance', 'underwhelming ')\n    'performance'\n\n    >>> remove_prefix('something special', 'sample')\n    'something special'\n    \"\"\"\n    null, prefix, rest = text.rpartition(prefix)\n    return rest\n\n\ndef remove_suffix(text, suffix):\n    \"\"\"\n    Remove the suffix from the text if it exists.\n\n    >>> remove_suffix('name.git', '.git')\n    'name'\n\n    >>> remove_suffix('something special', 'sample')\n    'something special'\n    \"\"\"\n    rest, suffix, null = text.partition(suffix)\n    return rest\n\n\ndef normalize_newlines(text):\n    r\"\"\"\n    Replace alternate newlines with the canonical newline.\n\n    >>> normalize_newlines('Lorem Ipsum\\u2029')\n    'Lorem Ipsum\\n'\n    >>> normalize_newlines('Lorem Ipsum\\r\\n')\n    'Lorem Ipsum\\n'\n    >>> normalize_newlines('Lorem Ipsum\\x85')\n    'Lorem Ipsum\\n'\n    \"\"\"\n    newlines = ['\\r\\n', '\\r', '\\n', '\\u0085', '\\u2028', '\\u2029']\n    pattern = '|'.join(newlines)\n    return re.sub(pattern, '\\n', text)\n\n\ndef _nonblank(str):\n    return str and not str.startswith('#')\n\n\n@functools.singledispatch\ndef yield_lines(iterable):\n    r\"\"\"\n    Yield valid lines of a string or iterable.\n\n    >>> list(yield_lines(''))\n    []\n    >>> list(yield_lines(['foo', 'bar']))\n    ['foo', 'bar']\n    >>> list(yield_lines('foo\\nbar'))\n    ['foo', 'bar']\n    >>> list(yield_lines('\\nfoo\\n#bar\\nbaz #comment'))\n    ['foo', 'baz #comment']\n    >>> list(yield_lines(['foo\\nbar', 'baz', 'bing\\n\\n\\n']))\n    ['foo', 'bar', 'baz', 'bing']\n    \"\"\"\n    return itertools.chain.from_iterable(map(yield_lines, iterable))\n\n\n@yield_lines.register(str)\ndef _(text):\n    return filter(_nonblank, map(str.strip, text.splitlines()))\n\n\ndef drop_comment(line):\n    \"\"\"\n    Drop comments.\n\n    >>> drop_comment('foo # bar')\n    'foo'\n\n    A hash without a space may be in a URL.\n\n    >>> drop_comment('http://example.com/foo#bar')\n    'http://example.com/foo#bar'\n    \"\"\"\n    return line.partition(' #')[0]\n\n\ndef join_continuation(lines):\n    r\"\"\"\n    Join lines continued by a trailing backslash.\n\n    >>> list(join_continuation(['foo \\\\', 'bar', 'baz']))\n    ['foobar', 'baz']\n    >>> list(join_continuation(['foo \\\\', 'bar', 'baz']))\n    ['foobar', 'baz']\n    >>> list(join_continuation(['foo \\\\', 'bar \\\\', 'baz']))\n    ['foobarbaz']\n\n    Not sure why, but...\n    The character preceding the backslash is also elided.\n\n    >>> list(join_continuation(['goo\\\\', 'dly']))\n    ['godly']\n\n    A terrible idea, but...\n    If no line is available to continue, suppress the lines.\n\n    >>> list(join_continuation(['foo', 'bar\\\\', 'baz\\\\']))\n    ['foo']\n    \"\"\"\n    lines = iter(lines)\n    for item in lines:\n        while item.endswith('\\\\'):\n            try:\n                item = item[:-2].strip() + next(lines)\n            except StopIteration:\n                return\n        yield item\n\n\ndef read_newlines(filename, limit=1024):\n    r\"\"\"\n    >>> tmp_path = getfixture('tmp_path')\n    >>> filename = tmp_path / 'out.txt'\n    >>> _ = filename.write_text('foo\\n', newline='', encoding='utf-8')\n    >>> read_newlines(filename)\n    '\\n'\n    >>> _ = filename.write_text('foo\\r\\n', newline='', encoding='utf-8')\n    >>> read_newlines(filename)\n    '\\r\\n'\n    >>> _ = filename.write_text('foo\\r\\nbar\\nbing\\r', newline='', encoding='utf-8')\n    >>> read_newlines(filename)\n    ('\\r', '\\n', '\\r\\n')\n    \"\"\"\n    with open(filename, encoding='utf-8') as fp:\n        fp.read(limit)\n    return fp.newlines\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/jaraco/text/layouts.py","size":643,"sha1":"017d1501b7887f350bb6da58fba5590e0d8ae99b","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"qwerty = \"-=qwertyuiop[]asdfghjkl;'zxcvbnm,./_+QWERTYUIOP{}ASDFGHJKL:\\\"ZXCVBNM<>?\"\ndvorak = \"[]',.pyfgcrl/=aoeuidhtns-;qjkxbmwvz{}\\\"<>PYFGCRL?+AOEUIDHTNS_:QJKXBMWVZ\"\n\n\nto_dvorak = str.maketrans(qwerty, dvorak)\nto_qwerty = str.maketrans(dvorak, qwerty)\n\n\ndef translate(input, translation):\n    \"\"\"\n    >>> translate('dvorak', to_dvorak)\n    'ekrpat'\n    >>> translate('qwerty', to_qwerty)\n    'x,dokt'\n    \"\"\"\n    return input.translate(translation)\n\n\ndef _translate_stream(stream, translation):\n    \"\"\"\n    >>> import io\n    >>> _translate_stream(io.StringIO('foo'), to_dvorak)\n    urr\n    \"\"\"\n    print(translate(stream.read(), translation))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/jaraco/text/show-newlines.py","size":904,"sha1":"8ee2b59255fe83b8eb94de244f3bec591bcc16e2","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import autocommand\nimport inflect\n\nfrom more_itertools import always_iterable\n\nimport jaraco.text\n\n\ndef report_newlines(filename):\n    r\"\"\"\n    Report the newlines in the indicated file.\n\n    >>> tmp_path = getfixture('tmp_path')\n    >>> filename = tmp_path / 'out.txt'\n    >>> _ = filename.write_text('foo\\nbar\\n', newline='', encoding='utf-8')\n    >>> report_newlines(filename)\n    newline is '\\n'\n    >>> filename = tmp_path / 'out.txt'\n    >>> _ = filename.write_text('foo\\nbar\\r\\n', newline='', encoding='utf-8')\n    >>> report_newlines(filename)\n    newlines are ('\\n', '\\r\\n')\n    \"\"\"\n    newlines = jaraco.text.read_newlines(filename)\n    count = len(tuple(always_iterable(newlines)))\n    engine = inflect.engine()\n    print(\n        engine.plural_noun(\"newline\", count),\n        engine.plural_verb(\"is\", count),\n        repr(newlines),\n    )\n\n\nautocommand.autocommand(__name__)(report_newlines)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/jaraco/text/strip-prefix.py","size":412,"sha1":"16d37fe91e6e6174ecc5ebf06d10063687980ee8","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\n\nimport autocommand\n\nfrom jaraco.text import Stripper\n\n\ndef strip_prefix():\n    r\"\"\"\n    Strip any common prefix from stdin.\n\n    >>> import io, pytest\n    >>> getfixture('monkeypatch').setattr('sys.stdin', io.StringIO('abcdef\\nabc123'))\n    >>> strip_prefix()\n    def\n    123\n    \"\"\"\n    sys.stdout.writelines(Stripper.strip_prefix(sys.stdin).lines)\n\n\nautocommand.autocommand(__name__)(strip_prefix)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/jaraco/text/to-dvorak.py","size":119,"sha1":"c29e2e76d2ac2aaeff06ff460d248651fc89ae81","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\n\nfrom . import layouts\n\n\n__name__ == '__main__' and layouts._translate_stream(sys.stdin, layouts.to_dvorak)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/jaraco/text/to-qwerty.py","size":119,"sha1":"1433a62a1f45f4db80fa92860f044745082a88da","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\n\nfrom . import layouts\n\n\n__name__ == '__main__' and layouts._translate_stream(sys.stdin, layouts.to_qwerty)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/more_itertools/__init__.py","size":149,"sha1":"aa90bc3f286e3d6b492546e95d2a80a84704982d","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"More routines for operating on iterables, beyond itertools\"\"\"\n\nfrom .more import *  # noqa\nfrom .recipes import *  # noqa\n\n__version__ = '10.3.0'\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/more_itertools/more.py","size":148370,"sha1":"417ebe791a3b03d30c67994a6e71b6f618bb7fb1","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import math\nimport warnings\n\nfrom collections import Counter, defaultdict, deque, abc\nfrom collections.abc import Sequence\nfrom functools import cached_property, partial, reduce, wraps\nfrom heapq import heapify, heapreplace, heappop\nfrom itertools import (\n    chain,\n    combinations,\n    compress,\n    count,\n    cycle,\n    dropwhile,\n    groupby,\n    islice,\n    repeat,\n    starmap,\n    takewhile,\n    tee,\n    zip_longest,\n    product,\n)\nfrom math import comb, e, exp, factorial, floor, fsum, log, perm, tau\nfrom queue import Empty, Queue\nfrom random import random, randrange, uniform\nfrom operator import itemgetter, mul, sub, gt, lt, ge, le\nfrom sys import hexversion, maxsize\nfrom time import monotonic\n\nfrom .recipes import (\n    _marker,\n    _zip_equal,\n    UnequalIterablesError,\n    consume,\n    flatten,\n    pairwise,\n    powerset,\n    take,\n    unique_everseen,\n    all_equal,\n    batched,\n)\n\n__all__ = [\n    'AbortThread',\n    'SequenceView',\n    'UnequalIterablesError',\n    'adjacent',\n    'all_unique',\n    'always_iterable',\n    'always_reversible',\n    'bucket',\n    'callback_iter',\n    'chunked',\n    'chunked_even',\n    'circular_shifts',\n    'collapse',\n    'combination_index',\n    'combination_with_replacement_index',\n    'consecutive_groups',\n    'constrained_batches',\n    'consumer',\n    'count_cycle',\n    'countable',\n    'dft',\n    'difference',\n    'distinct_combinations',\n    'distinct_permutations',\n    'distribute',\n    'divide',\n    'doublestarmap',\n    'duplicates_everseen',\n    'duplicates_justseen',\n    'classify_unique',\n    'exactly_n',\n    'filter_except',\n    'filter_map',\n    'first',\n    'gray_product',\n    'groupby_transform',\n    'ichunked',\n    'iequals',\n    'idft',\n    'ilen',\n    'interleave',\n    'interleave_evenly',\n    'interleave_longest',\n    'intersperse',\n    'is_sorted',\n    'islice_extended',\n    'iterate',\n    'iter_suppress',\n    'join_mappings',\n    'last',\n    'locate',\n    'longest_common_prefix',\n    'lstrip',\n    'make_decorator',\n    'map_except',\n    'map_if',\n    'map_reduce',\n    'mark_ends',\n    'minmax',\n    'nth_or_last',\n    'nth_permutation',\n    'nth_product',\n    'nth_combination_with_replacement',\n    'numeric_range',\n    'one',\n    'only',\n    'outer_product',\n    'padded',\n    'partial_product',\n    'partitions',\n    'peekable',\n    'permutation_index',\n    'powerset_of_sets',\n    'product_index',\n    'raise_',\n    'repeat_each',\n    'repeat_last',\n    'replace',\n    'rlocate',\n    'rstrip',\n    'run_length',\n    'sample',\n    'seekable',\n    'set_partitions',\n    'side_effect',\n    'sliced',\n    'sort_together',\n    'split_after',\n    'split_at',\n    'split_before',\n    'split_into',\n    'split_when',\n    'spy',\n    'stagger',\n    'strip',\n    'strictly_n',\n    'substrings',\n    'substrings_indexes',\n    'takewhile_inclusive',\n    'time_limited',\n    'unique_in_window',\n    'unique_to_each',\n    'unzip',\n    'value_chain',\n    'windowed',\n    'windowed_complete',\n    'with_iter',\n    'zip_broadcast',\n    'zip_equal',\n    'zip_offset',\n]\n\n# math.sumprod is available for Python 3.12+\n_fsumprod = getattr(math, 'sumprod', lambda x, y: fsum(map(mul, x, y)))\n\n\ndef chunked(iterable, n, strict=False):\n    \"\"\"Break *iterable* into lists of length *n*:\n\n        >>> list(chunked([1, 2, 3, 4, 5, 6], 3))\n        [[1, 2, 3], [4, 5, 6]]\n\n    By the default, the last yielded list will have fewer than *n* elements\n    if the length of *iterable* is not divisible by *n*:\n\n        >>> list(chunked([1, 2, 3, 4, 5, 6, 7, 8], 3))\n        [[1, 2, 3], [4, 5, 6], [7, 8]]\n\n    To use a fill-in value instead, see the :func:`grouper` recipe.\n\n    If the length of *iterable* is not divisible by *n* and *strict* is\n    ``True``, then ``ValueError`` will be raised before the last\n    list is yielded.\n\n    \"\"\"\n    iterator = iter(partial(take, n, iter(iterable)), [])\n    if strict:\n        if n is None:\n            raise ValueError('n must not be None when using strict mode.')\n\n        def ret():\n            for chunk in iterator:\n                if len(chunk) != n:\n                    raise ValueError('iterable is not divisible by n.')\n                yield chunk\n\n        return iter(ret())\n    else:\n        return iterator\n\n\ndef first(iterable, default=_marker):\n    \"\"\"Return the first item of *iterable*, or *default* if *iterable* is\n    empty.\n\n        >>> first([0, 1, 2, 3])\n        0\n        >>> first([], 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n\n    :func:`first` is useful when you have a generator of expensive-to-retrieve\n    values and want any arbitrary one. It is marginally shorter than\n    ``next(iter(iterable), default)``.\n\n    \"\"\"\n    for item in iterable:\n        return item\n    if default is _marker:\n        raise ValueError(\n            'first() was called on an empty iterable, and no '\n            'default value was provided.'\n        )\n    return default\n\n\ndef last(iterable, default=_marker):\n    \"\"\"Return the last item of *iterable*, or *default* if *iterable* is\n    empty.\n\n        >>> last([0, 1, 2, 3])\n        3\n        >>> last([], 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n    \"\"\"\n    try:\n        if isinstance(iterable, Sequence):\n            return iterable[-1]\n        # Work around https://bugs.python.org/issue38525\n        elif hasattr(iterable, '__reversed__') and (hexversion != 0x030800F0):\n            return next(reversed(iterable))\n        else:\n            return deque(iterable, maxlen=1)[-1]\n    except (IndexError, TypeError, StopIteration):\n        if default is _marker:\n            raise ValueError(\n                'last() was called on an empty iterable, and no default was '\n                'provided.'\n            )\n        return default\n\n\ndef nth_or_last(iterable, n, default=_marker):\n    \"\"\"Return the nth or the last item of *iterable*,\n    or *default* if *iterable* is empty.\n\n        >>> nth_or_last([0, 1, 2, 3], 2)\n        2\n        >>> nth_or_last([0, 1], 2)\n        1\n        >>> nth_or_last([], 0, 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n    \"\"\"\n    return last(islice(iterable, n + 1), default=default)\n\n\nclass peekable:\n    \"\"\"Wrap an iterator to allow lookahead and prepending elements.\n\n    Call :meth:`peek` on the result to get the value that will be returned\n    by :func:`next`. This won't advance the iterator:\n\n        >>> p = peekable(['a', 'b'])\n        >>> p.peek()\n        'a'\n        >>> next(p)\n        'a'\n\n    Pass :meth:`peek` a default value to return that instead of raising\n    ``StopIteration`` when the iterator is exhausted.\n\n        >>> p = peekable([])\n        >>> p.peek('hi')\n        'hi'\n\n    peekables also offer a :meth:`prepend` method, which \"inserts\" items\n    at the head of the iterable:\n\n        >>> p = peekable([1, 2, 3])\n        >>> p.prepend(10, 11, 12)\n        >>> next(p)\n        10\n        >>> p.peek()\n        11\n        >>> list(p)\n        [11, 12, 1, 2, 3]\n\n    peekables can be indexed. Index 0 is the item that will be returned by\n    :func:`next`, index 1 is the item after that, and so on:\n    The values up to the given index will be cached.\n\n        >>> p = peekable(['a', 'b', 'c', 'd'])\n        >>> p[0]\n        'a'\n        >>> p[1]\n        'b'\n        >>> next(p)\n        'a'\n\n    Negative indexes are supported, but be aware that they will cache the\n    remaining items in the source iterator, which may require significant\n    storage.\n\n    To check whether a peekable is exhausted, check its truth value:\n\n        >>> p = peekable(['a', 'b'])\n        >>> if p:  # peekable has items\n        ...     list(p)\n        ['a', 'b']\n        >>> if not p:  # peekable is exhausted\n        ...     list(p)\n        []\n\n    \"\"\"\n\n    def __init__(self, iterable):\n        self._it = iter(iterable)\n        self._cache = deque()\n\n    def __iter__(self):\n        return self\n\n    def __bool__(self):\n        try:\n            self.peek()\n        except StopIteration:\n            return False\n        return True\n\n    def peek(self, default=_marker):\n        \"\"\"Return the item that will be next returned from ``next()``.\n\n        Return ``default`` if there are no items left. If ``default`` is not\n        provided, raise ``StopIteration``.\n\n        \"\"\"\n        if not self._cache:\n            try:\n                self._cache.append(next(self._it))\n            except StopIteration:\n                if default is _marker:\n                    raise\n                return default\n        return self._cache[0]\n\n    def prepend(self, *items):\n        \"\"\"Stack up items to be the next ones returned from ``next()`` or\n        ``self.peek()``. The items will be returned in\n        first in, first out order::\n\n            >>> p = peekable([1, 2, 3])\n            >>> p.prepend(10, 11, 12)\n            >>> next(p)\n            10\n            >>> list(p)\n            [11, 12, 1, 2, 3]\n\n        It is possible, by prepending items, to \"resurrect\" a peekable that\n        previously raised ``StopIteration``.\n\n            >>> p = peekable([])\n            >>> next(p)\n            Traceback (most recent call last):\n              ...\n            StopIteration\n            >>> p.prepend(1)\n            >>> next(p)\n            1\n            >>> next(p)\n            Traceback (most recent call last):\n              ...\n            StopIteration\n\n        \"\"\"\n        self._cache.extendleft(reversed(items))\n\n    def __next__(self):\n        if self._cache:\n            return self._cache.popleft()\n\n        return next(self._it)\n\n    def _get_slice(self, index):\n        # Normalize the slice's arguments\n        step = 1 if (index.step is None) else index.step\n        if step > 0:\n            start = 0 if (index.start is None) else index.start\n            stop = maxsize if (index.stop is None) else index.stop\n        elif step < 0:\n            start = -1 if (index.start is None) else index.start\n            stop = (-maxsize - 1) if (index.stop is None) else index.stop\n        else:\n            raise ValueError('slice step cannot be zero')\n\n        # If either the start or stop index is negative, we'll need to cache\n        # the rest of the iterable in order to slice from the right side.\n        if (start < 0) or (stop < 0):\n            self._cache.extend(self._it)\n        # Otherwise we'll need to find the rightmost index and cache to that\n        # point.\n        else:\n            n = min(max(start, stop) + 1, maxsize)\n            cache_len = len(self._cache)\n            if n >= cache_len:\n                self._cache.extend(islice(self._it, n - cache_len))\n\n        return list(self._cache)[index]\n\n    def __getitem__(self, index):\n        if isinstance(index, slice):\n            return self._get_slice(index)\n\n        cache_len = len(self._cache)\n        if index < 0:\n            self._cache.extend(self._it)\n        elif index >= cache_len:\n            self._cache.extend(islice(self._it, index + 1 - cache_len))\n\n        return self._cache[index]\n\n\ndef consumer(func):\n    \"\"\"Decorator that automatically advances a PEP-342-style \"reverse iterator\"\n    to its first yield point so you don't have to call ``next()`` on it\n    manually.\n\n        >>> @consumer\n        ... def tally():\n        ...     i = 0\n        ...     while True:\n        ...         print('Thing number %s is %s.' % (i, (yield)))\n        ...         i += 1\n        ...\n        >>> t = tally()\n        >>> t.send('red')\n        Thing number 0 is red.\n        >>> t.send('fish')\n        Thing number 1 is fish.\n\n    Without the decorator, you would have to call ``next(t)`` before\n    ``t.send()`` could be used.\n\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        gen = func(*args, **kwargs)\n        next(gen)\n        return gen\n\n    return wrapper\n\n\ndef ilen(iterable):\n    \"\"\"Return the number of items in *iterable*.\n\n        >>> ilen(x for x in range(1000000) if x % 3 == 0)\n        333334\n\n    This consumes the iterable, so handle with care.\n\n    \"\"\"\n    # This approach was selected because benchmarks showed it's likely the\n    # fastest of the known implementations at the time of writing.\n    # See GitHub tracker: #236, #230.\n    counter = count()\n    deque(zip(iterable, counter), maxlen=0)\n    return next(counter)\n\n\ndef iterate(func, start):\n    \"\"\"Return ``start``, ``func(start)``, ``func(func(start))``, ...\n\n    >>> from itertools import islice\n    >>> list(islice(iterate(lambda x: 2*x, 1), 10))\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\n\n    \"\"\"\n    while True:\n        yield start\n        try:\n            start = func(start)\n        except StopIteration:\n            break\n\n\ndef with_iter(context_manager):\n    \"\"\"Wrap an iterable in a ``with`` statement, so it closes once exhausted.\n\n    For example, this will close the file when the iterator is exhausted::\n\n        upper_lines = (line.upper() for line in with_iter(open('foo')))\n\n    Any context manager which returns an iterable is a candidate for\n    ``with_iter``.\n\n    \"\"\"\n    with context_manager as iterable:\n        yield from iterable\n\n\ndef one(iterable, too_short=None, too_long=None):\n    \"\"\"Return the first item from *iterable*, which is expected to contain only\n    that item. Raise an exception if *iterable* is empty or has more than one\n    item.\n\n    :func:`one` is useful for ensuring that an iterable contains only one item.\n    For example, it can be used to retrieve the result of a database query\n    that is expected to return a single row.\n\n    If *iterable* is empty, ``ValueError`` will be raised. You may specify a\n    different exception with the *too_short* keyword:\n\n        >>> it = []\n        >>> one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: too many items in iterable (expected 1)'\n        >>> too_short = IndexError('too few items')\n        >>> one(it, too_short=too_short)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        IndexError: too few items\n\n    Similarly, if *iterable* contains more than one item, ``ValueError`` will\n    be raised. You may specify a different exception with the *too_long*\n    keyword:\n\n        >>> it = ['too', 'many']\n        >>> one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: Expected exactly one item in iterable, but got 'too',\n        'many', and perhaps more.\n        >>> too_long = RuntimeError\n        >>> one(it, too_long=too_long)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        RuntimeError\n\n    Note that :func:`one` attempts to advance *iterable* twice to ensure there\n    is only one item. See :func:`spy` or :func:`peekable` to check iterable\n    contents less destructively.\n\n    \"\"\"\n    it = iter(iterable)\n\n    try:\n        first_value = next(it)\n    except StopIteration as exc:\n        raise (\n            too_short or ValueError('too few items in iterable (expected 1)')\n        ) from exc\n\n    try:\n        second_value = next(it)\n    except StopIteration:\n        pass\n    else:\n        msg = (\n            'Expected exactly one item in iterable, but got {!r}, {!r}, '\n            'and perhaps more.'.format(first_value, second_value)\n        )\n        raise too_long or ValueError(msg)\n\n    return first_value\n\n\ndef raise_(exception, *args):\n    raise exception(*args)\n\n\ndef strictly_n(iterable, n, too_short=None, too_long=None):\n    \"\"\"Validate that *iterable* has exactly *n* items and return them if\n    it does. If it has fewer than *n* items, call function *too_short*\n    with those items. If it has more than *n* items, call function\n    *too_long* with the first ``n + 1`` items.\n\n        >>> iterable = ['a', 'b', 'c', 'd']\n        >>> n = 4\n        >>> list(strictly_n(iterable, n))\n        ['a', 'b', 'c', 'd']\n\n    Note that the returned iterable must be consumed in order for the check to\n    be made.\n\n    By default, *too_short* and *too_long* are functions that raise\n    ``ValueError``.\n\n        >>> list(strictly_n('ab', 3))  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: too few items in iterable (got 2)\n\n        >>> list(strictly_n('abc', 2))  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: too many items in iterable (got at least 3)\n\n    You can instead supply functions that do something else.\n    *too_short* will be called with the number of items in *iterable*.\n    *too_long* will be called with `n + 1`.\n\n        >>> def too_short(item_count):\n        ...     raise RuntimeError\n        >>> it = strictly_n('abcd', 6, too_short=too_short)\n        >>> list(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        RuntimeError\n\n        >>> def too_long(item_count):\n        ...     print('The boss is going to hear about this')\n        >>> it = strictly_n('abcdef', 4, too_long=too_long)\n        >>> list(it)\n        The boss is going to hear about this\n        ['a', 'b', 'c', 'd']\n\n    \"\"\"\n    if too_short is None:\n        too_short = lambda item_count: raise_(\n            ValueError,\n            'Too few items in iterable (got {})'.format(item_count),\n        )\n\n    if too_long is None:\n        too_long = lambda item_count: raise_(\n            ValueError,\n            'Too many items in iterable (got at least {})'.format(item_count),\n        )\n\n    it = iter(iterable)\n    for i in range(n):\n        try:\n            item = next(it)\n        except StopIteration:\n            too_short(i)\n            return\n        else:\n            yield item\n\n    try:\n        next(it)\n    except StopIteration:\n        pass\n    else:\n        too_long(n + 1)\n\n\ndef distinct_permutations(iterable, r=None):\n    \"\"\"Yield successive distinct permutations of the elements in *iterable*.\n\n        >>> sorted(distinct_permutations([1, 0, 1]))\n        [(0, 1, 1), (1, 0, 1), (1, 1, 0)]\n\n    Equivalent to ``set(permutations(iterable))``, except duplicates are not\n    generated and thrown away. For larger input sequences this is much more\n    efficient.\n\n    Duplicate permutations arise when there are duplicated elements in the\n    input iterable. The number of items returned is\n    `n! / (x_1! * x_2! * ... * x_n!)`, where `n` is the total number of\n    items input, and each `x_i` is the count of a distinct item in the input\n    sequence.\n\n    If *r* is given, only the *r*-length permutations are yielded.\n\n        >>> sorted(distinct_permutations([1, 0, 1], r=2))\n        [(0, 1), (1, 0), (1, 1)]\n        >>> sorted(distinct_permutations(range(3), r=2))\n        [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]\n\n    \"\"\"\n\n    # Algorithm: https://w.wiki/Qai\n    def _full(A):\n        while True:\n            # Yield the permutation we have\n            yield tuple(A)\n\n            # Find the largest index i such that A[i] < A[i + 1]\n            for i in range(size - 2, -1, -1):\n                if A[i] < A[i + 1]:\n                    break\n            #  If no such index exists, this permutation is the last one\n            else:\n                return\n\n            # Find the largest index j greater than j such that A[i] < A[j]\n            for j in range(size - 1, i, -1):\n                if A[i] < A[j]:\n                    break\n\n            # Swap the value of A[i] with that of A[j], then reverse the\n            # sequence from A[i + 1] to form the new permutation\n            A[i], A[j] = A[j], A[i]\n            A[i + 1 :] = A[: i - size : -1]  # A[i + 1:][::-1]\n\n    # Algorithm: modified from the above\n    def _partial(A, r):\n        # Split A into the first r items and the last r items\n        head, tail = A[:r], A[r:]\n        right_head_indexes = range(r - 1, -1, -1)\n        left_tail_indexes = range(len(tail))\n\n        while True:\n            # Yield the permutation we have\n            yield tuple(head)\n\n            # Starting from the right, find the first index of the head with\n            # value smaller than the maximum value of the tail - call it i.\n            pivot = tail[-1]\n            for i in right_head_indexes:\n                if head[i] < pivot:\n                    break\n                pivot = head[i]\n            else:\n                return\n\n            # Starting from the left, find the first value of the tail\n            # with a value greater than head[i] and swap.\n            for j in left_tail_indexes:\n                if tail[j] > head[i]:\n                    head[i], tail[j] = tail[j], head[i]\n                    break\n            # If we didn't find one, start from the right and find the first\n            # index of the head with a value greater than head[i] and swap.\n            else:\n                for j in right_head_indexes:\n                    if head[j] > head[i]:\n                        head[i], head[j] = head[j], head[i]\n                        break\n\n            # Reverse head[i + 1:] and swap it with tail[:r - (i + 1)]\n            tail += head[: i - r : -1]  # head[i + 1:][::-1]\n            i += 1\n            head[i:], tail[:] = tail[: r - i], tail[r - i :]\n\n    items = sorted(iterable)\n\n    size = len(items)\n    if r is None:\n        r = size\n\n    if 0 < r <= size:\n        return _full(items) if (r == size) else _partial(items, r)\n\n    return iter(() if r else ((),))\n\n\ndef intersperse(e, iterable, n=1):\n    \"\"\"Intersperse filler element *e* among the items in *iterable*, leaving\n    *n* items between each filler element.\n\n        >>> list(intersperse('!', [1, 2, 3, 4, 5]))\n        [1, '!', 2, '!', 3, '!', 4, '!', 5]\n\n        >>> list(intersperse(None, [1, 2, 3, 4, 5], n=2))\n        [1, 2, None, 3, 4, None, 5]\n\n    \"\"\"\n    if n == 0:\n        raise ValueError('n must be > 0')\n    elif n == 1:\n        # interleave(repeat(e), iterable) -> e, x_0, e, x_1, e, x_2...\n        # islice(..., 1, None) -> x_0, e, x_1, e, x_2...\n        return islice(interleave(repeat(e), iterable), 1, None)\n    else:\n        # interleave(filler, chunks) -> [e], [x_0, x_1], [e], [x_2, x_3]...\n        # islice(..., 1, None) -> [x_0, x_1], [e], [x_2, x_3]...\n        # flatten(...) -> x_0, x_1, e, x_2, x_3...\n        filler = repeat([e])\n        chunks = chunked(iterable, n)\n        return flatten(islice(interleave(filler, chunks), 1, None))\n\n\ndef unique_to_each(*iterables):\n    \"\"\"Return the elements from each of the input iterables that aren't in the\n    other input iterables.\n\n    For example, suppose you have a set of packages, each with a set of\n    dependencies::\n\n        {'pkg_1': {'A', 'B'}, 'pkg_2': {'B', 'C'}, 'pkg_3': {'B', 'D'}}\n\n    If you remove one package, which dependencies can also be removed?\n\n    If ``pkg_1`` is removed, then ``A`` is no longer necessary - it is not\n    associated with ``pkg_2`` or ``pkg_3``. Similarly, ``C`` is only needed for\n    ``pkg_2``, and ``D`` is only needed for ``pkg_3``::\n\n        >>> unique_to_each({'A', 'B'}, {'B', 'C'}, {'B', 'D'})\n        [['A'], ['C'], ['D']]\n\n    If there are duplicates in one input iterable that aren't in the others\n    they will be duplicated in the output. Input order is preserved::\n\n        >>> unique_to_each(\"mississippi\", \"missouri\")\n        [['p', 'p'], ['o', 'u', 'r']]\n\n    It is assumed that the elements of each iterable are hashable.\n\n    \"\"\"\n    pool = [list(it) for it in iterables]\n    counts = Counter(chain.from_iterable(map(set, pool)))\n    uniques = {element for element in counts if counts[element] == 1}\n    return [list(filter(uniques.__contains__, it)) for it in pool]\n\n\ndef windowed(seq, n, fillvalue=None, step=1):\n    \"\"\"Return a sliding window of width *n* over the given iterable.\n\n        >>> all_windows = windowed([1, 2, 3, 4, 5], 3)\n        >>> list(all_windows)\n        [(1, 2, 3), (2, 3, 4), (3, 4, 5)]\n\n    When the window is larger than the iterable, *fillvalue* is used in place\n    of missing values:\n\n        >>> list(windowed([1, 2, 3], 4))\n        [(1, 2, 3, None)]\n\n    Each window will advance in increments of *step*:\n\n        >>> list(windowed([1, 2, 3, 4, 5, 6], 3, fillvalue='!', step=2))\n        [(1, 2, 3), (3, 4, 5), (5, 6, '!')]\n\n    To slide into the iterable's items, use :func:`chain` to add filler items\n    to the left:\n\n        >>> iterable = [1, 2, 3, 4]\n        >>> n = 3\n        >>> padding = [None] * (n - 1)\n        >>> list(windowed(chain(padding, iterable), 3))\n        [(None, None, 1), (None, 1, 2), (1, 2, 3), (2, 3, 4)]\n    \"\"\"\n    if n < 0:\n        raise ValueError('n must be >= 0')\n    if n == 0:\n        yield ()\n        return\n    if step < 1:\n        raise ValueError('step must be >= 1')\n\n    iterable = iter(seq)\n\n    # Generate first window\n    window = deque(islice(iterable, n), maxlen=n)\n\n    # Deal with the first window not being full\n    if not window:\n        return\n    if len(window) < n:\n        yield tuple(window) + ((fillvalue,) * (n - len(window)))\n        return\n    yield tuple(window)\n\n    # Create the filler for the next windows. The padding ensures\n    # we have just enough elements to fill the last window.\n    padding = (fillvalue,) * (n - 1 if step >= n else step - 1)\n    filler = map(window.append, chain(iterable, padding))\n\n    # Generate the rest of the windows\n    for _ in islice(filler, step - 1, None, step):\n        yield tuple(window)\n\n\ndef substrings(iterable):\n    \"\"\"Yield all of the substrings of *iterable*.\n\n        >>> [''.join(s) for s in substrings('more')]\n        ['m', 'o', 'r', 'e', 'mo', 'or', 're', 'mor', 'ore', 'more']\n\n    Note that non-string iterables can also be subdivided.\n\n        >>> list(substrings([0, 1, 2]))\n        [(0,), (1,), (2,), (0, 1), (1, 2), (0, 1, 2)]\n\n    \"\"\"\n    # The length-1 substrings\n    seq = []\n    for item in iter(iterable):\n        seq.append(item)\n        yield (item,)\n    seq = tuple(seq)\n    item_count = len(seq)\n\n    # And the rest\n    for n in range(2, item_count + 1):\n        for i in range(item_count - n + 1):\n            yield seq[i : i + n]\n\n\ndef substrings_indexes(seq, reverse=False):\n    \"\"\"Yield all substrings and their positions in *seq*\n\n    The items yielded will be a tuple of the form ``(substr, i, j)``, where\n    ``substr == seq[i:j]``.\n\n    This function only works for iterables that support slicing, such as\n    ``str`` objects.\n\n    >>> for item in substrings_indexes('more'):\n    ...    print(item)\n    ('m', 0, 1)\n    ('o', 1, 2)\n    ('r', 2, 3)\n    ('e', 3, 4)\n    ('mo', 0, 2)\n    ('or', 1, 3)\n    ('re', 2, 4)\n    ('mor', 0, 3)\n    ('ore', 1, 4)\n    ('more', 0, 4)\n\n    Set *reverse* to ``True`` to yield the same items in the opposite order.\n\n\n    \"\"\"\n    r = range(1, len(seq) + 1)\n    if reverse:\n        r = reversed(r)\n    return (\n        (seq[i : i + L], i, i + L) for L in r for i in range(len(seq) - L + 1)\n    )\n\n\nclass bucket:\n    \"\"\"Wrap *iterable* and return an object that buckets the iterable into\n    child iterables based on a *key* function.\n\n        >>> iterable = ['a1', 'b1', 'c1', 'a2', 'b2', 'c2', 'b3']\n        >>> s = bucket(iterable, key=lambda x: x[0])  # Bucket by 1st character\n        >>> sorted(list(s))  # Get the keys\n        ['a', 'b', 'c']\n        >>> a_iterable = s['a']\n        >>> next(a_iterable)\n        'a1'\n        >>> next(a_iterable)\n        'a2'\n        >>> list(s['b'])\n        ['b1', 'b2', 'b3']\n\n    The original iterable will be advanced and its items will be cached until\n    they are used by the child iterables. This may require significant storage.\n\n    By default, attempting to select a bucket to which no items belong  will\n    exhaust the iterable and cache all values.\n    If you specify a *validator* function, selected buckets will instead be\n    checked against it.\n\n        >>> from itertools import count\n        >>> it = count(1, 2)  # Infinite sequence of odd numbers\n        >>> key = lambda x: x % 10  # Bucket by last digit\n        >>> validator = lambda x: x in {1, 3, 5, 7, 9}  # Odd digits only\n        >>> s = bucket(it, key=key, validator=validator)\n        >>> 2 in s\n        False\n        >>> list(s[2])\n        []\n\n    \"\"\"\n\n    def __init__(self, iterable, key, validator=None):\n        self._it = iter(iterable)\n        self._key = key\n        self._cache = defaultdict(deque)\n        self._validator = validator or (lambda x: True)\n\n    def __contains__(self, value):\n        if not self._validator(value):\n            return False\n\n        try:\n            item = next(self[value])\n        except StopIteration:\n            return False\n        else:\n            self._cache[value].appendleft(item)\n\n        return True\n\n    def _get_values(self, value):\n        \"\"\"\n        Helper to yield items from the parent iterator that match *value*.\n        Items that don't match are stored in the local cache as they\n        are encountered.\n        \"\"\"\n        while True:\n            # If we've cached some items that match the target value, emit\n            # the first one and evict it from the cache.\n            if self._cache[value]:\n                yield self._cache[value].popleft()\n            # Otherwise we need to advance the parent iterator to search for\n            # a matching item, caching the rest.\n            else:\n                while True:\n                    try:\n                        item = next(self._it)\n                    except StopIteration:\n                        return\n                    item_value = self._key(item)\n                    if item_value == value:\n                        yield item\n                        break\n                    elif self._validator(item_value):\n                        self._cache[item_value].append(item)\n\n    def __iter__(self):\n        for item in self._it:\n            item_value = self._key(item)\n            if self._validator(item_value):\n                self._cache[item_value].append(item)\n\n        yield from self._cache.keys()\n\n    def __getitem__(self, value):\n        if not self._validator(value):\n            return iter(())\n\n        return self._get_values(value)\n\n\ndef spy(iterable, n=1):\n    \"\"\"Return a 2-tuple with a list containing the first *n* elements of\n    *iterable*, and an iterator with the same items as *iterable*.\n    This allows you to \"look ahead\" at the items in the iterable without\n    advancing it.\n\n    There is one item in the list by default:\n\n        >>> iterable = 'abcdefg'\n        >>> head, iterable = spy(iterable)\n        >>> head\n        ['a']\n        >>> list(iterable)\n        ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n\n    You may use unpacking to retrieve items instead of lists:\n\n        >>> (head,), iterable = spy('abcdefg')\n        >>> head\n        'a'\n        >>> (first, second), iterable = spy('abcdefg', 2)\n        >>> first\n        'a'\n        >>> second\n        'b'\n\n    The number of items requested can be larger than the number of items in\n    the iterable:\n\n        >>> iterable = [1, 2, 3, 4, 5]\n        >>> head, iterable = spy(iterable, 10)\n        >>> head\n        [1, 2, 3, 4, 5]\n        >>> list(iterable)\n        [1, 2, 3, 4, 5]\n\n    \"\"\"\n    it = iter(iterable)\n    head = take(n, it)\n\n    return head.copy(), chain(head, it)\n\n\ndef interleave(*iterables):\n    \"\"\"Return a new iterable yielding from each iterable in turn,\n    until the shortest is exhausted.\n\n        >>> list(interleave([1, 2, 3], [4, 5], [6, 7, 8]))\n        [1, 4, 6, 2, 5, 7]\n\n    For a version that doesn't terminate after the shortest iterable is\n    exhausted, see :func:`interleave_longest`.\n\n    \"\"\"\n    return chain.from_iterable(zip(*iterables))\n\n\ndef interleave_longest(*iterables):\n    \"\"\"Return a new iterable yielding from each iterable in turn,\n    skipping any that are exhausted.\n\n        >>> list(interleave_longest([1, 2, 3], [4, 5], [6, 7, 8]))\n        [1, 4, 6, 2, 5, 7, 3, 8]\n\n    This function produces the same output as :func:`roundrobin`, but may\n    perform better for some inputs (in particular when the number of iterables\n    is large).\n\n    \"\"\"\n    i = chain.from_iterable(zip_longest(*iterables, fillvalue=_marker))\n    return (x for x in i if x is not _marker)\n\n\ndef interleave_evenly(iterables, lengths=None):\n    \"\"\"\n    Interleave multiple iterables so that their elements are evenly distributed\n    throughout the output sequence.\n\n    >>> iterables = [1, 2, 3, 4, 5], ['a', 'b']\n    >>> list(interleave_evenly(iterables))\n    [1, 2, 'a', 3, 4, 'b', 5]\n\n    >>> iterables = [[1, 2, 3], [4, 5], [6, 7, 8]]\n    >>> list(interleave_evenly(iterables))\n    [1, 6, 4, 2, 7, 3, 8, 5]\n\n    This function requires iterables of known length. Iterables without\n    ``__len__()`` can be used by manually specifying lengths with *lengths*:\n\n    >>> from itertools import combinations, repeat\n    >>> iterables = [combinations(range(4), 2), ['a', 'b', 'c']]\n    >>> lengths = [4 * (4 - 1) // 2, 3]\n    >>> list(interleave_evenly(iterables, lengths=lengths))\n    [(0, 1), (0, 2), 'a', (0, 3), (1, 2), 'b', (1, 3), (2, 3), 'c']\n\n    Based on Bresenham's algorithm.\n    \"\"\"\n    if lengths is None:\n        try:\n            lengths = [len(it) for it in iterables]\n        except TypeError:\n            raise ValueError(\n                'Iterable lengths could not be determined automatically. '\n                'Specify them with the lengths keyword.'\n            )\n    elif len(iterables) != len(lengths):\n        raise ValueError('Mismatching number of iterables and lengths.')\n\n    dims = len(lengths)\n\n    # sort iterables by length, descending\n    lengths_permute = sorted(\n        range(dims), key=lambda i: lengths[i], reverse=True\n    )\n    lengths_desc = [lengths[i] for i in lengths_permute]\n    iters_desc = [iter(iterables[i]) for i in lengths_permute]\n\n    # the longest iterable is the primary one (Bresenham: the longest\n    # distance along an axis)\n    delta_primary, deltas_secondary = lengths_desc[0], lengths_desc[1:]\n    iter_primary, iters_secondary = iters_desc[0], iters_desc[1:]\n    errors = [delta_primary // dims] * len(deltas_secondary)\n\n    to_yield = sum(lengths)\n    while to_yield:\n        yield next(iter_primary)\n        to_yield -= 1\n        # update errors for each secondary iterable\n        errors = [e - delta for e, delta in zip(errors, deltas_secondary)]\n\n        # those iterables for which the error is negative are yielded\n        # (\"diagonal step\" in Bresenham)\n        for i, e_ in enumerate(errors):\n            if e_ < 0:\n                yield next(iters_secondary[i])\n                to_yield -= 1\n                errors[i] += delta_primary\n\n\ndef collapse(iterable, base_type=None, levels=None):\n    \"\"\"Flatten an iterable with multiple levels of nesting (e.g., a list of\n    lists of tuples) into non-iterable types.\n\n        >>> iterable = [(1, 2), ([3, 4], [[5], [6]])]\n        >>> list(collapse(iterable))\n        [1, 2, 3, 4, 5, 6]\n\n    Binary and text strings are not considered iterable and\n    will not be collapsed.\n\n    To avoid collapsing other types, specify *base_type*:\n\n        >>> iterable = ['ab', ('cd', 'ef'), ['gh', 'ij']]\n        >>> list(collapse(iterable, base_type=tuple))\n        ['ab', ('cd', 'ef'), 'gh', 'ij']\n\n    Specify *levels* to stop flattening after a certain level:\n\n    >>> iterable = [('a', ['b']), ('c', ['d'])]\n    >>> list(collapse(iterable))  # Fully flattened\n    ['a', 'b', 'c', 'd']\n    >>> list(collapse(iterable, levels=1))  # Only one level flattened\n    ['a', ['b'], 'c', ['d']]\n\n    \"\"\"\n    stack = deque()\n    # Add our first node group, treat the iterable as a single node\n    stack.appendleft((0, repeat(iterable, 1)))\n\n    while stack:\n        node_group = stack.popleft()\n        level, nodes = node_group\n\n        # Check if beyond max level\n        if levels is not None and level > levels:\n            yield from nodes\n            continue\n\n        for node in nodes:\n            # Check if done iterating\n            if isinstance(node, (str, bytes)) or (\n                (base_type is not None) and isinstance(node, base_type)\n            ):\n                yield node\n            # Otherwise try to create child nodes\n            else:\n                try:\n                    tree = iter(node)\n                except TypeError:\n                    yield node\n                else:\n                    # Save our current location\n                    stack.appendleft(node_group)\n                    # Append the new child node\n                    stack.appendleft((level + 1, tree))\n                    # Break to process child node\n                    break\n\n\ndef side_effect(func, iterable, chunk_size=None, before=None, after=None):\n    \"\"\"Invoke *func* on each item in *iterable* (or on each *chunk_size* group\n    of items) before yielding the item.\n\n    `func` must be a function that takes a single argument. Its return value\n    will be discarded.\n\n    *before* and *after* are optional functions that take no arguments. They\n    will be executed before iteration starts and after it ends, respectively.\n\n    `side_effect` can be used for logging, updating progress bars, or anything\n    that is not functionally \"pure.\"\n\n    Emitting a status message:\n\n        >>> from more_itertools import consume\n        >>> func = lambda item: print('Received {}'.format(item))\n        >>> consume(side_effect(func, range(2)))\n        Received 0\n        Received 1\n\n    Operating on chunks of items:\n\n        >>> pair_sums = []\n        >>> func = lambda chunk: pair_sums.append(sum(chunk))\n        >>> list(side_effect(func, [0, 1, 2, 3, 4, 5], 2))\n        [0, 1, 2, 3, 4, 5]\n        >>> list(pair_sums)\n        [1, 5, 9]\n\n    Writing to a file-like object:\n\n        >>> from io import StringIO\n        >>> from more_itertools import consume\n        >>> f = StringIO()\n        >>> func = lambda x: print(x, file=f)\n        >>> before = lambda: print(u'HEADER', file=f)\n        >>> after = f.close\n        >>> it = [u'a', u'b', u'c']\n        >>> consume(side_effect(func, it, before=before, after=after))\n        >>> f.closed\n        True\n\n    \"\"\"\n    try:\n        if before is not None:\n            before()\n\n        if chunk_size is None:\n            for item in iterable:\n                func(item)\n                yield item\n        else:\n            for chunk in chunked(iterable, chunk_size):\n                func(chunk)\n                yield from chunk\n    finally:\n        if after is not None:\n            after()\n\n\ndef sliced(seq, n, strict=False):\n    \"\"\"Yield slices of length *n* from the sequence *seq*.\n\n    >>> list(sliced((1, 2, 3, 4, 5, 6), 3))\n    [(1, 2, 3), (4, 5, 6)]\n\n    By the default, the last yielded slice will have fewer than *n* elements\n    if the length of *seq* is not divisible by *n*:\n\n    >>> list(sliced((1, 2, 3, 4, 5, 6, 7, 8), 3))\n    [(1, 2, 3), (4, 5, 6), (7, 8)]\n\n    If the length of *seq* is not divisible by *n* and *strict* is\n    ``True``, then ``ValueError`` will be raised before the last\n    slice is yielded.\n\n    This function will only work for iterables that support slicing.\n    For non-sliceable iterables, see :func:`chunked`.\n\n    \"\"\"\n    iterator = takewhile(len, (seq[i : i + n] for i in count(0, n)))\n    if strict:\n\n        def ret():\n            for _slice in iterator:\n                if len(_slice) != n:\n                    raise ValueError(\"seq is not divisible by n.\")\n                yield _slice\n\n        return iter(ret())\n    else:\n        return iterator\n\n\ndef split_at(iterable, pred, maxsplit=-1, keep_separator=False):\n    \"\"\"Yield lists of items from *iterable*, where each list is delimited by\n    an item where callable *pred* returns ``True``.\n\n        >>> list(split_at('abcdcba', lambda x: x == 'b'))\n        [['a'], ['c', 'd', 'c'], ['a']]\n\n        >>> list(split_at(range(10), lambda n: n % 2 == 1))\n        [[0], [2], [4], [6], [8], []]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_at(range(10), lambda n: n % 2 == 1, maxsplit=2))\n        [[0], [2], [4, 5, 6, 7, 8, 9]]\n\n    By default, the delimiting items are not included in the output.\n    To include them, set *keep_separator* to ``True``.\n\n        >>> list(split_at('abcdcba', lambda x: x == 'b', keep_separator=True))\n        [['a'], ['b'], ['c', 'd', 'c'], ['b'], ['a']]\n\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    buf = []\n    it = iter(iterable)\n    for item in it:\n        if pred(item):\n            yield buf\n            if keep_separator:\n                yield [item]\n            if maxsplit == 1:\n                yield list(it)\n                return\n            buf = []\n            maxsplit -= 1\n        else:\n            buf.append(item)\n    yield buf\n\n\ndef split_before(iterable, pred, maxsplit=-1):\n    \"\"\"Yield lists of items from *iterable*, where each list ends just before\n    an item for which callable *pred* returns ``True``:\n\n        >>> list(split_before('OneTwo', lambda s: s.isupper()))\n        [['O', 'n', 'e'], ['T', 'w', 'o']]\n\n        >>> list(split_before(range(10), lambda n: n % 3 == 0))\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_before(range(10), lambda n: n % 3 == 0, maxsplit=2))\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8, 9]]\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    buf = []\n    it = iter(iterable)\n    for item in it:\n        if pred(item) and buf:\n            yield buf\n            if maxsplit == 1:\n                yield [item] + list(it)\n                return\n            buf = []\n            maxsplit -= 1\n        buf.append(item)\n    if buf:\n        yield buf\n\n\ndef split_after(iterable, pred, maxsplit=-1):\n    \"\"\"Yield lists of items from *iterable*, where each list ends with an\n    item where callable *pred* returns ``True``:\n\n        >>> list(split_after('one1two2', lambda s: s.isdigit()))\n        [['o', 'n', 'e', '1'], ['t', 'w', 'o', '2']]\n\n        >>> list(split_after(range(10), lambda n: n % 3 == 0))\n        [[0], [1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_after(range(10), lambda n: n % 3 == 0, maxsplit=2))\n        [[0], [1, 2, 3], [4, 5, 6, 7, 8, 9]]\n\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    buf = []\n    it = iter(iterable)\n    for item in it:\n        buf.append(item)\n        if pred(item) and buf:\n            yield buf\n            if maxsplit == 1:\n                buf = list(it)\n                if buf:\n                    yield buf\n                return\n            buf = []\n            maxsplit -= 1\n    if buf:\n        yield buf\n\n\ndef split_when(iterable, pred, maxsplit=-1):\n    \"\"\"Split *iterable* into pieces based on the output of *pred*.\n    *pred* should be a function that takes successive pairs of items and\n    returns ``True`` if the iterable should be split in between them.\n\n    For example, to find runs of increasing numbers, split the iterable when\n    element ``i`` is larger than element ``i + 1``:\n\n        >>> list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2], lambda x, y: x > y))\n        [[1, 2, 3, 3], [2, 5], [2, 4], [2]]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2],\n        ...                 lambda x, y: x > y, maxsplit=2))\n        [[1, 2, 3, 3], [2, 5], [2, 4, 2]]\n\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    it = iter(iterable)\n    try:\n        cur_item = next(it)\n    except StopIteration:\n        return\n\n    buf = [cur_item]\n    for next_item in it:\n        if pred(cur_item, next_item):\n            yield buf\n            if maxsplit == 1:\n                yield [next_item] + list(it)\n                return\n            buf = []\n            maxsplit -= 1\n\n        buf.append(next_item)\n        cur_item = next_item\n\n    yield buf\n\n\ndef split_into(iterable, sizes):\n    \"\"\"Yield a list of sequential items from *iterable* of length 'n' for each\n    integer 'n' in *sizes*.\n\n        >>> list(split_into([1,2,3,4,5,6], [1,2,3]))\n        [[1], [2, 3], [4, 5, 6]]\n\n    If the sum of *sizes* is smaller than the length of *iterable*, then the\n    remaining items of *iterable* will not be returned.\n\n        >>> list(split_into([1,2,3,4,5,6], [2,3]))\n        [[1, 2], [3, 4, 5]]\n\n    If the sum of *sizes* is larger than the length of *iterable*, fewer items\n    will be returned in the iteration that overruns *iterable* and further\n    lists will be empty:\n\n        >>> list(split_into([1,2,3,4], [1,2,3,4]))\n        [[1], [2, 3], [4], []]\n\n    When a ``None`` object is encountered in *sizes*, the returned list will\n    contain items up to the end of *iterable* the same way that itertools.slice\n    does:\n\n        >>> list(split_into([1,2,3,4,5,6,7,8,9,0], [2,3,None]))\n        [[1, 2], [3, 4, 5], [6, 7, 8, 9, 0]]\n\n    :func:`split_into` can be useful for grouping a series of items where the\n    sizes of the groups are not uniform. An example would be where in a row\n    from a table, multiple columns represent elements of the same feature\n    (e.g. a point represented by x,y,z) but, the format is not the same for\n    all columns.\n    \"\"\"\n    # convert the iterable argument into an iterator so its contents can\n    # be consumed by islice in case it is a generator\n    it = iter(iterable)\n\n    for size in sizes:\n        if size is None:\n            yield list(it)\n            return\n        else:\n            yield list(islice(it, size))\n\n\ndef padded(iterable, fillvalue=None, n=None, next_multiple=False):\n    \"\"\"Yield the elements from *iterable*, followed by *fillvalue*, such that\n    at least *n* items are emitted.\n\n        >>> list(padded([1, 2, 3], '?', 5))\n        [1, 2, 3, '?', '?']\n\n    If *next_multiple* is ``True``, *fillvalue* will be emitted until the\n    number of items emitted is a multiple of *n*:\n\n        >>> list(padded([1, 2, 3, 4], n=3, next_multiple=True))\n        [1, 2, 3, 4, None, None]\n\n    If *n* is ``None``, *fillvalue* will be emitted indefinitely.\n\n    To create an *iterable* of exactly size *n*, you can truncate with\n    :func:`islice`.\n\n        >>> list(islice(padded([1, 2, 3], '?'), 5))\n        [1, 2, 3, '?', '?']\n        >>> list(islice(padded([1, 2, 3, 4, 5, 6, 7, 8], '?'), 5))\n        [1, 2, 3, 4, 5]\n\n    \"\"\"\n    iterable = iter(iterable)\n    iterable_with_repeat = chain(iterable, repeat(fillvalue))\n\n    if n is None:\n        return iterable_with_repeat\n    elif n < 1:\n        raise ValueError('n must be at least 1')\n    elif next_multiple:\n\n        def slice_generator():\n            for first in iterable:\n                yield (first,)\n                yield islice(iterable_with_repeat, n - 1)\n\n        # While elements exist produce slices of size n\n        return chain.from_iterable(slice_generator())\n    else:\n        # Ensure the first batch is at least size n then iterate\n        return chain(islice(iterable_with_repeat, n), iterable)\n\n\ndef repeat_each(iterable, n=2):\n    \"\"\"Repeat each element in *iterable* *n* times.\n\n    >>> list(repeat_each('ABC', 3))\n    ['A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'C']\n    \"\"\"\n    return chain.from_iterable(map(repeat, iterable, repeat(n)))\n\n\ndef repeat_last(iterable, default=None):\n    \"\"\"After the *iterable* is exhausted, keep yielding its last element.\n\n        >>> list(islice(repeat_last(range(3)), 5))\n        [0, 1, 2, 2, 2]\n\n    If the iterable is empty, yield *default* forever::\n\n        >>> list(islice(repeat_last(range(0), 42), 5))\n        [42, 42, 42, 42, 42]\n\n    \"\"\"\n    item = _marker\n    for item in iterable:\n        yield item\n    final = default if item is _marker else item\n    yield from repeat(final)\n\n\ndef distribute(n, iterable):\n    \"\"\"Distribute the items from *iterable* among *n* smaller iterables.\n\n        >>> group_1, group_2 = distribute(2, [1, 2, 3, 4, 5, 6])\n        >>> list(group_1)\n        [1, 3, 5]\n        >>> list(group_2)\n        [2, 4, 6]\n\n    If the length of *iterable* is not evenly divisible by *n*, then the\n    length of the returned iterables will not be identical:\n\n        >>> children = distribute(3, [1, 2, 3, 4, 5, 6, 7])\n        >>> [list(c) for c in children]\n        [[1, 4, 7], [2, 5], [3, 6]]\n\n    If the length of *iterable* is smaller than *n*, then the last returned\n    iterables will be empty:\n\n        >>> children = distribute(5, [1, 2, 3])\n        >>> [list(c) for c in children]\n        [[1], [2], [3], [], []]\n\n    This function uses :func:`itertools.tee` and may require significant\n    storage.\n\n    If you need the order items in the smaller iterables to match the\n    original iterable, see :func:`divide`.\n\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be at least 1')\n\n    children = tee(iterable, n)\n    return [islice(it, index, None, n) for index, it in enumerate(children)]\n\n\ndef stagger(iterable, offsets=(-1, 0, 1), longest=False, fillvalue=None):\n    \"\"\"Yield tuples whose elements are offset from *iterable*.\n    The amount by which the `i`-th item in each tuple is offset is given by\n    the `i`-th item in *offsets*.\n\n        >>> list(stagger([0, 1, 2, 3]))\n        [(None, 0, 1), (0, 1, 2), (1, 2, 3)]\n        >>> list(stagger(range(8), offsets=(0, 2, 4)))\n        [(0, 2, 4), (1, 3, 5), (2, 4, 6), (3, 5, 7)]\n\n    By default, the sequence will end when the final element of a tuple is the\n    last item in the iterable. To continue until the first element of a tuple\n    is the last item in the iterable, set *longest* to ``True``::\n\n        >>> list(stagger([0, 1, 2, 3], longest=True))\n        [(None, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, None), (3, None, None)]\n\n    By default, ``None`` will be used to replace offsets beyond the end of the\n    sequence. Specify *fillvalue* to use some other value.\n\n    \"\"\"\n    children = tee(iterable, len(offsets))\n\n    return zip_offset(\n        *children, offsets=offsets, longest=longest, fillvalue=fillvalue\n    )\n\n\ndef zip_equal(*iterables):\n    \"\"\"``zip`` the input *iterables* together, but raise\n    ``UnequalIterablesError`` if they aren't all the same length.\n\n        >>> it_1 = range(3)\n        >>> it_2 = iter('abc')\n        >>> list(zip_equal(it_1, it_2))\n        [(0, 'a'), (1, 'b'), (2, 'c')]\n\n        >>> it_1 = range(3)\n        >>> it_2 = iter('abcd')\n        >>> list(zip_equal(it_1, it_2)) # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        more_itertools.more.UnequalIterablesError: Iterables have different\n        lengths\n\n    \"\"\"\n    if hexversion >= 0x30A00A6:\n        warnings.warn(\n            (\n                'zip_equal will be removed in a future version of '\n                'more-itertools. Use the builtin zip function with '\n                'strict=True instead.'\n            ),\n            DeprecationWarning,\n        )\n\n    return _zip_equal(*iterables)\n\n\ndef zip_offset(*iterables, offsets, longest=False, fillvalue=None):\n    \"\"\"``zip`` the input *iterables* together, but offset the `i`-th iterable\n    by the `i`-th item in *offsets*.\n\n        >>> list(zip_offset('0123', 'abcdef', offsets=(0, 1)))\n        [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e')]\n\n    This can be used as a lightweight alternative to SciPy or pandas to analyze\n    data sets in which some series have a lead or lag relationship.\n\n    By default, the sequence will end when the shortest iterable is exhausted.\n    To continue until the longest iterable is exhausted, set *longest* to\n    ``True``.\n\n        >>> list(zip_offset('0123', 'abcdef', offsets=(0, 1), longest=True))\n        [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e'), (None, 'f')]\n\n    By default, ``None`` will be used to replace offsets beyond the end of the\n    sequence. Specify *fillvalue* to use some other value.\n\n    \"\"\"\n    if len(iterables) != len(offsets):\n        raise ValueError(\"Number of iterables and offsets didn't match\")\n\n    staggered = []\n    for it, n in zip(iterables, offsets):\n        if n < 0:\n            staggered.append(chain(repeat(fillvalue, -n), it))\n        elif n > 0:\n            staggered.append(islice(it, n, None))\n        else:\n            staggered.append(it)\n\n    if longest:\n        return zip_longest(*staggered, fillvalue=fillvalue)\n\n    return zip(*staggered)\n\n\ndef sort_together(iterables, key_list=(0,), key=None, reverse=False):\n    \"\"\"Return the input iterables sorted together, with *key_list* as the\n    priority for sorting. All iterables are trimmed to the length of the\n    shortest one.\n\n    This can be used like the sorting function in a spreadsheet. If each\n    iterable represents a column of data, the key list determines which\n    columns are used for sorting.\n\n    By default, all iterables are sorted using the ``0``-th iterable::\n\n        >>> iterables = [(4, 3, 2, 1), ('a', 'b', 'c', 'd')]\n        >>> sort_together(iterables)\n        [(1, 2, 3, 4), ('d', 'c', 'b', 'a')]\n\n    Set a different key list to sort according to another iterable.\n    Specifying multiple keys dictates how ties are broken::\n\n        >>> iterables = [(3, 1, 2), (0, 1, 0), ('c', 'b', 'a')]\n        >>> sort_together(iterables, key_list=(1, 2))\n        [(2, 3, 1), (0, 0, 1), ('a', 'c', 'b')]\n\n    To sort by a function of the elements of the iterable, pass a *key*\n    function. Its arguments are the elements of the iterables corresponding to\n    the key list::\n\n        >>> names = ('a', 'b', 'c')\n        >>> lengths = (1, 2, 3)\n        >>> widths = (5, 2, 1)\n        >>> def area(length, width):\n        ...     return length * width\n        >>> sort_together([names, lengths, widths], key_list=(1, 2), key=area)\n        [('c', 'b', 'a'), (3, 2, 1), (1, 2, 5)]\n\n    Set *reverse* to ``True`` to sort in descending order.\n\n        >>> sort_together([(1, 2, 3), ('c', 'b', 'a')], reverse=True)\n        [(3, 2, 1), ('a', 'b', 'c')]\n\n    \"\"\"\n    if key is None:\n        # if there is no key function, the key argument to sorted is an\n        # itemgetter\n        key_argument = itemgetter(*key_list)\n    else:\n        # if there is a key function, call it with the items at the offsets\n        # specified by the key function as arguments\n        key_list = list(key_list)\n        if len(key_list) == 1:\n            # if key_list contains a single item, pass the item at that offset\n            # as the only argument to the key function\n            key_offset = key_list[0]\n            key_argument = lambda zipped_items: key(zipped_items[key_offset])\n        else:\n            # if key_list contains multiple items, use itemgetter to return a\n            # tuple of items, which we pass as *args to the key function\n            get_key_items = itemgetter(*key_list)\n            key_argument = lambda zipped_items: key(\n                *get_key_items(zipped_items)\n            )\n\n    return list(\n        zip(*sorted(zip(*iterables), key=key_argument, reverse=reverse))\n    )\n\n\ndef unzip(iterable):\n    \"\"\"The inverse of :func:`zip`, this function disaggregates the elements\n    of the zipped *iterable*.\n\n    The ``i``-th iterable contains the ``i``-th element from each element\n    of the zipped iterable. The first element is used to determine the\n    length of the remaining elements.\n\n        >>> iterable = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n        >>> letters, numbers = unzip(iterable)\n        >>> list(letters)\n        ['a', 'b', 'c', 'd']\n        >>> list(numbers)\n        [1, 2, 3, 4]\n\n    This is similar to using ``zip(*iterable)``, but it avoids reading\n    *iterable* into memory. Note, however, that this function uses\n    :func:`itertools.tee` and thus may require significant storage.\n\n    \"\"\"\n    head, iterable = spy(iter(iterable))\n    if not head:\n        # empty iterable, e.g. zip([], [], [])\n        return ()\n    # spy returns a one-length iterable as head\n    head = head[0]\n    iterables = tee(iterable, len(head))\n\n    def itemgetter(i):\n        def getter(obj):\n            try:\n                return obj[i]\n            except IndexError:\n                # basically if we have an iterable like\n                # iter([(1, 2, 3), (4, 5), (6,)])\n                # the second unzipped iterable would fail at the third tuple\n                # since it would try to access tup[1]\n                # same with the third unzipped iterable and the second tuple\n                # to support these \"improperly zipped\" iterables,\n                # we create a custom itemgetter\n                # which just stops the unzipped iterables\n                # at first length mismatch\n                raise StopIteration\n\n        return getter\n\n    return tuple(map(itemgetter(i), it) for i, it in enumerate(iterables))\n\n\ndef divide(n, iterable):\n    \"\"\"Divide the elements from *iterable* into *n* parts, maintaining\n    order.\n\n        >>> group_1, group_2 = divide(2, [1, 2, 3, 4, 5, 6])\n        >>> list(group_1)\n        [1, 2, 3]\n        >>> list(group_2)\n        [4, 5, 6]\n\n    If the length of *iterable* is not evenly divisible by *n*, then the\n    length of the returned iterables will not be identical:\n\n        >>> children = divide(3, [1, 2, 3, 4, 5, 6, 7])\n        >>> [list(c) for c in children]\n        [[1, 2, 3], [4, 5], [6, 7]]\n\n    If the length of the iterable is smaller than n, then the last returned\n    iterables will be empty:\n\n        >>> children = divide(5, [1, 2, 3])\n        >>> [list(c) for c in children]\n        [[1], [2], [3], [], []]\n\n    This function will exhaust the iterable before returning.\n    If order is not important, see :func:`distribute`, which does not first\n    pull the iterable into memory.\n\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be at least 1')\n\n    try:\n        iterable[:0]\n    except TypeError:\n        seq = tuple(iterable)\n    else:\n        seq = iterable\n\n    q, r = divmod(len(seq), n)\n\n    ret = []\n    stop = 0\n    for i in range(1, n + 1):\n        start = stop\n        stop += q + 1 if i <= r else q\n        ret.append(iter(seq[start:stop]))\n\n    return ret\n\n\ndef always_iterable(obj, base_type=(str, bytes)):\n    \"\"\"If *obj* is iterable, return an iterator over its items::\n\n        >>> obj = (1, 2, 3)\n        >>> list(always_iterable(obj))\n        [1, 2, 3]\n\n    If *obj* is not iterable, return a one-item iterable containing *obj*::\n\n        >>> obj = 1\n        >>> list(always_iterable(obj))\n        [1]\n\n    If *obj* is ``None``, return an empty iterable:\n\n        >>> obj = None\n        >>> list(always_iterable(None))\n        []\n\n    By default, binary and text strings are not considered iterable::\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj))\n        ['foo']\n\n    If *base_type* is set, objects for which ``isinstance(obj, base_type)``\n    returns ``True`` won't be considered iterable.\n\n        >>> obj = {'a': 1}\n        >>> list(always_iterable(obj))  # Iterate over the dict's keys\n        ['a']\n        >>> list(always_iterable(obj, base_type=dict))  # Treat dicts as a unit\n        [{'a': 1}]\n\n    Set *base_type* to ``None`` to avoid any special handling and treat objects\n    Python considers iterable as iterable:\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj, base_type=None))\n        ['f', 'o', 'o']\n    \"\"\"\n    if obj is None:\n        return iter(())\n\n    if (base_type is not None) and isinstance(obj, base_type):\n        return iter((obj,))\n\n    try:\n        return iter(obj)\n    except TypeError:\n        return iter((obj,))\n\n\ndef adjacent(predicate, iterable, distance=1):\n    \"\"\"Return an iterable over `(bool, item)` tuples where the `item` is\n    drawn from *iterable* and the `bool` indicates whether\n    that item satisfies the *predicate* or is adjacent to an item that does.\n\n    For example, to find whether items are adjacent to a ``3``::\n\n        >>> list(adjacent(lambda x: x == 3, range(6)))\n        [(False, 0), (False, 1), (True, 2), (True, 3), (True, 4), (False, 5)]\n\n    Set *distance* to change what counts as adjacent. For example, to find\n    whether items are two places away from a ``3``:\n\n        >>> list(adjacent(lambda x: x == 3, range(6), distance=2))\n        [(False, 0), (True, 1), (True, 2), (True, 3), (True, 4), (True, 5)]\n\n    This is useful for contextualizing the results of a search function.\n    For example, a code comparison tool might want to identify lines that\n    have changed, but also surrounding lines to give the viewer of the diff\n    context.\n\n    The predicate function will only be called once for each item in the\n    iterable.\n\n    See also :func:`groupby_transform`, which can be used with this function\n    to group ranges of items with the same `bool` value.\n\n    \"\"\"\n    # Allow distance=0 mainly for testing that it reproduces results with map()\n    if distance < 0:\n        raise ValueError('distance must be at least 0')\n\n    i1, i2 = tee(iterable)\n    padding = [False] * distance\n    selected = chain(padding, map(predicate, i1), padding)\n    adjacent_to_selected = map(any, windowed(selected, 2 * distance + 1))\n    return zip(adjacent_to_selected, i2)\n\n\ndef groupby_transform(iterable, keyfunc=None, valuefunc=None, reducefunc=None):\n    \"\"\"An extension of :func:`itertools.groupby` that can apply transformations\n    to the grouped data.\n\n    * *keyfunc* is a function computing a key value for each item in *iterable*\n    * *valuefunc* is a function that transforms the individual items from\n      *iterable* after grouping\n    * *reducefunc* is a function that transforms each group of items\n\n    >>> iterable = 'aAAbBBcCC'\n    >>> keyfunc = lambda k: k.upper()\n    >>> valuefunc = lambda v: v.lower()\n    >>> reducefunc = lambda g: ''.join(g)\n    >>> list(groupby_transform(iterable, keyfunc, valuefunc, reducefunc))\n    [('A', 'aaa'), ('B', 'bbb'), ('C', 'ccc')]\n\n    Each optional argument defaults to an identity function if not specified.\n\n    :func:`groupby_transform` is useful when grouping elements of an iterable\n    using a separate iterable as the key. To do this, :func:`zip` the iterables\n    and pass a *keyfunc* that extracts the first element and a *valuefunc*\n    that extracts the second element::\n\n        >>> from operator import itemgetter\n        >>> keys = [0, 0, 1, 1, 1, 2, 2, 2, 3]\n        >>> values = 'abcdefghi'\n        >>> iterable = zip(keys, values)\n        >>> grouper = groupby_transform(iterable, itemgetter(0), itemgetter(1))\n        >>> [(k, ''.join(g)) for k, g in grouper]\n        [(0, 'ab'), (1, 'cde'), (2, 'fgh'), (3, 'i')]\n\n    Note that the order of items in the iterable is significant.\n    Only adjacent items are grouped together, so if you don't want any\n    duplicate groups, you should sort the iterable by the key function.\n\n    \"\"\"\n    ret = groupby(iterable, keyfunc)\n    if valuefunc:\n        ret = ((k, map(valuefunc, g)) for k, g in ret)\n    if reducefunc:\n        ret = ((k, reducefunc(g)) for k, g in ret)\n\n    return ret\n\n\nclass numeric_range(abc.Sequence, abc.Hashable):\n    \"\"\"An extension of the built-in ``range()`` function whose arguments can\n    be any orderable numeric type.\n\n    With only *stop* specified, *start* defaults to ``0`` and *step*\n    defaults to ``1``. The output items will match the type of *stop*:\n\n        >>> list(numeric_range(3.5))\n        [0.0, 1.0, 2.0, 3.0]\n\n    With only *start* and *stop* specified, *step* defaults to ``1``. The\n    output items will match the type of *start*:\n\n        >>> from decimal import Decimal\n        >>> start = Decimal('2.1')\n        >>> stop = Decimal('5.1')\n        >>> list(numeric_range(start, stop))\n        [Decimal('2.1'), Decimal('3.1'), Decimal('4.1')]\n\n    With *start*, *stop*, and *step*  specified the output items will match\n    the type of ``start + step``:\n\n        >>> from fractions import Fraction\n        >>> start = Fraction(1, 2)  # Start at 1/2\n        >>> stop = Fraction(5, 2)  # End at 5/2\n        >>> step = Fraction(1, 2)  # Count by 1/2\n        >>> list(numeric_range(start, stop, step))\n        [Fraction(1, 2), Fraction(1, 1), Fraction(3, 2), Fraction(2, 1)]\n\n    If *step* is zero, ``ValueError`` is raised. Negative steps are supported:\n\n        >>> list(numeric_range(3, -1, -1.0))\n        [3.0, 2.0, 1.0, 0.0]\n\n    Be aware of the limitations of floating point numbers; the representation\n    of the yielded numbers may be surprising.\n\n    ``datetime.datetime`` objects can be used for *start* and *stop*, if *step*\n    is a ``datetime.timedelta`` object:\n\n        >>> import datetime\n        >>> start = datetime.datetime(2019, 1, 1)\n        >>> stop = datetime.datetime(2019, 1, 3)\n        >>> step = datetime.timedelta(days=1)\n        >>> items = iter(numeric_range(start, stop, step))\n        >>> next(items)\n        datetime.datetime(2019, 1, 1, 0, 0)\n        >>> next(items)\n        datetime.datetime(2019, 1, 2, 0, 0)\n\n    \"\"\"\n\n    _EMPTY_HASH = hash(range(0, 0))\n\n    def __init__(self, *args):\n        argc = len(args)\n        if argc == 1:\n            (self._stop,) = args\n            self._start = type(self._stop)(0)\n            self._step = type(self._stop - self._start)(1)\n        elif argc == 2:\n            self._start, self._stop = args\n            self._step = type(self._stop - self._start)(1)\n        elif argc == 3:\n            self._start, self._stop, self._step = args\n        elif argc == 0:\n            raise TypeError(\n                'numeric_range expected at least '\n                '1 argument, got {}'.format(argc)\n            )\n        else:\n            raise TypeError(\n                'numeric_range expected at most '\n                '3 arguments, got {}'.format(argc)\n            )\n\n        self._zero = type(self._step)(0)\n        if self._step == self._zero:\n            raise ValueError('numeric_range() arg 3 must not be zero')\n        self._growing = self._step > self._zero\n\n    def __bool__(self):\n        if self._growing:\n            return self._start < self._stop\n        else:\n            return self._start > self._stop\n\n    def __contains__(self, elem):\n        if self._growing:\n            if self._start <= elem < self._stop:\n                return (elem - self._start) % self._step == self._zero\n        else:\n            if self._start >= elem > self._stop:\n                return (self._start - elem) % (-self._step) == self._zero\n\n        return False\n\n    def __eq__(self, other):\n        if isinstance(other, numeric_range):\n            empty_self = not bool(self)\n            empty_other = not bool(other)\n            if empty_self or empty_other:\n                return empty_self and empty_other  # True if both empty\n            else:\n                return (\n                    self._start == other._start\n                    and self._step == other._step\n                    and self._get_by_index(-1) == other._get_by_index(-1)\n                )\n        else:\n            return False\n\n    def __getitem__(self, key):\n        if isinstance(key, int):\n            return self._get_by_index(key)\n        elif isinstance(key, slice):\n            step = self._step if key.step is None else key.step * self._step\n\n            if key.start is None or key.start <= -self._len:\n                start = self._start\n            elif key.start >= self._len:\n                start = self._stop\n            else:  # -self._len < key.start < self._len\n                start = self._get_by_index(key.start)\n\n            if key.stop is None or key.stop >= self._len:\n                stop = self._stop\n            elif key.stop <= -self._len:\n                stop = self._start\n            else:  # -self._len < key.stop < self._len\n                stop = self._get_by_index(key.stop)\n\n            return numeric_range(start, stop, step)\n        else:\n            raise TypeError(\n                'numeric range indices must be '\n                'integers or slices, not {}'.format(type(key).__name__)\n            )\n\n    def __hash__(self):\n        if self:\n            return hash((self._start, self._get_by_index(-1), self._step))\n        else:\n            return self._EMPTY_HASH\n\n    def __iter__(self):\n        values = (self._start + (n * self._step) for n in count())\n        if self._growing:\n            return takewhile(partial(gt, self._stop), values)\n        else:\n            return takewhile(partial(lt, self._stop), values)\n\n    def __len__(self):\n        return self._len\n\n    @cached_property\n    def _len(self):\n        if self._growing:\n            start = self._start\n            stop = self._stop\n            step = self._step\n        else:\n            start = self._stop\n            stop = self._start\n            step = -self._step\n        distance = stop - start\n        if distance <= self._zero:\n            return 0\n        else:  # distance > 0 and step > 0: regular euclidean division\n            q, r = divmod(distance, step)\n            return int(q) + int(r != self._zero)\n\n    def __reduce__(self):\n        return numeric_range, (self._start, self._stop, self._step)\n\n    def __repr__(self):\n        if self._step == 1:\n            return \"numeric_range({}, {})\".format(\n                repr(self._start), repr(self._stop)\n            )\n        else:\n            return \"numeric_range({}, {}, {})\".format(\n                repr(self._start), repr(self._stop), repr(self._step)\n            )\n\n    def __reversed__(self):\n        return iter(\n            numeric_range(\n                self._get_by_index(-1), self._start - self._step, -self._step\n            )\n        )\n\n    def count(self, value):\n        return int(value in self)\n\n    def index(self, value):\n        if self._growing:\n            if self._start <= value < self._stop:\n                q, r = divmod(value - self._start, self._step)\n                if r == self._zero:\n                    return int(q)\n        else:\n            if self._start >= value > self._stop:\n                q, r = divmod(self._start - value, -self._step)\n                if r == self._zero:\n                    return int(q)\n\n        raise ValueError(\"{} is not in numeric range\".format(value))\n\n    def _get_by_index(self, i):\n        if i < 0:\n            i += self._len\n        if i < 0 or i >= self._len:\n            raise IndexError(\"numeric range object index out of range\")\n        return self._start + i * self._step\n\n\ndef count_cycle(iterable, n=None):\n    \"\"\"Cycle through the items from *iterable* up to *n* times, yielding\n    the number of completed cycles along with each item. If *n* is omitted the\n    process repeats indefinitely.\n\n    >>> list(count_cycle('AB', 3))\n    [(0, 'A'), (0, 'B'), (1, 'A'), (1, 'B'), (2, 'A'), (2, 'B')]\n\n    \"\"\"\n    iterable = tuple(iterable)\n    if not iterable:\n        return iter(())\n    counter = count() if n is None else range(n)\n    return ((i, item) for i in counter for item in iterable)\n\n\ndef mark_ends(iterable):\n    \"\"\"Yield 3-tuples of the form ``(is_first, is_last, item)``.\n\n    >>> list(mark_ends('ABC'))\n    [(True, False, 'A'), (False, False, 'B'), (False, True, 'C')]\n\n    Use this when looping over an iterable to take special action on its first\n    and/or last items:\n\n    >>> iterable = ['Header', 100, 200, 'Footer']\n    >>> total = 0\n    >>> for is_first, is_last, item in mark_ends(iterable):\n    ...     if is_first:\n    ...         continue  # Skip the header\n    ...     if is_last:\n    ...         continue  # Skip the footer\n    ...     total += item\n    >>> print(total)\n    300\n    \"\"\"\n    it = iter(iterable)\n\n    try:\n        b = next(it)\n    except StopIteration:\n        return\n\n    try:\n        for i in count():\n            a = b\n            b = next(it)\n            yield i == 0, False, a\n\n    except StopIteration:\n        yield i == 0, True, a\n\n\ndef locate(iterable, pred=bool, window_size=None):\n    \"\"\"Yield the index of each item in *iterable* for which *pred* returns\n    ``True``.\n\n    *pred* defaults to :func:`bool`, which will select truthy items:\n\n        >>> list(locate([0, 1, 1, 0, 1, 0, 0]))\n        [1, 2, 4]\n\n    Set *pred* to a custom function to, e.g., find the indexes for a particular\n    item.\n\n        >>> list(locate(['a', 'b', 'c', 'b'], lambda x: x == 'b'))\n        [1, 3]\n\n    If *window_size* is given, then the *pred* function will be called with\n    that many items. This enables searching for sub-sequences:\n\n        >>> iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]\n        >>> pred = lambda *args: args == (1, 2, 3)\n        >>> list(locate(iterable, pred=pred, window_size=3))\n        [1, 5, 9]\n\n    Use with :func:`seekable` to find indexes and then retrieve the associated\n    items:\n\n        >>> from itertools import count\n        >>> from more_itertools import seekable\n        >>> source = (3 * n + 1 if (n % 2) else n // 2 for n in count())\n        >>> it = seekable(source)\n        >>> pred = lambda x: x > 100\n        >>> indexes = locate(it, pred=pred)\n        >>> i = next(indexes)\n        >>> it.seek(i)\n        >>> next(it)\n        106\n\n    \"\"\"\n    if window_size is None:\n        return compress(count(), map(pred, iterable))\n\n    if window_size < 1:\n        raise ValueError('window size must be at least 1')\n\n    it = windowed(iterable, window_size, fillvalue=_marker)\n    return compress(count(), starmap(pred, it))\n\n\ndef longest_common_prefix(iterables):\n    \"\"\"Yield elements of the longest common prefix amongst given *iterables*.\n\n    >>> ''.join(longest_common_prefix(['abcd', 'abc', 'abf']))\n    'ab'\n\n    \"\"\"\n    return (c[0] for c in takewhile(all_equal, zip(*iterables)))\n\n\ndef lstrip(iterable, pred):\n    \"\"\"Yield the items from *iterable*, but strip any from the beginning\n    for which *pred* returns ``True``.\n\n    For example, to remove a set of items from the start of an iterable:\n\n        >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n        >>> pred = lambda x: x in {None, False, ''}\n        >>> list(lstrip(iterable, pred))\n        [1, 2, None, 3, False, None]\n\n    This function is analogous to to :func:`str.lstrip`, and is essentially\n    an wrapper for :func:`itertools.dropwhile`.\n\n    \"\"\"\n    return dropwhile(pred, iterable)\n\n\ndef rstrip(iterable, pred):\n    \"\"\"Yield the items from *iterable*, but strip any from the end\n    for which *pred* returns ``True``.\n\n    For example, to remove a set of items from the end of an iterable:\n\n        >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n        >>> pred = lambda x: x in {None, False, ''}\n        >>> list(rstrip(iterable, pred))\n        [None, False, None, 1, 2, None, 3]\n\n    This function is analogous to :func:`str.rstrip`.\n\n    \"\"\"\n    cache = []\n    cache_append = cache.append\n    cache_clear = cache.clear\n    for x in iterable:\n        if pred(x):\n            cache_append(x)\n        else:\n            yield from cache\n            cache_clear()\n            yield x\n\n\ndef strip(iterable, pred):\n    \"\"\"Yield the items from *iterable*, but strip any from the\n    beginning and end for which *pred* returns ``True``.\n\n    For example, to remove a set of items from both ends of an iterable:\n\n        >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n        >>> pred = lambda x: x in {None, False, ''}\n        >>> list(strip(iterable, pred))\n        [1, 2, None, 3]\n\n    This function is analogous to :func:`str.strip`.\n\n    \"\"\"\n    return rstrip(lstrip(iterable, pred), pred)\n\n\nclass islice_extended:\n    \"\"\"An extension of :func:`itertools.islice` that supports negative values\n    for *stop*, *start*, and *step*.\n\n        >>> iterable = iter('abcdefgh')\n        >>> list(islice_extended(iterable, -4, -1))\n        ['e', 'f', 'g']\n\n    Slices with negative values require some caching of *iterable*, but this\n    function takes care to minimize the amount of memory required.\n\n    For example, you can use a negative step with an infinite iterator:\n\n        >>> from itertools import count\n        >>> list(islice_extended(count(), 110, 99, -2))\n        [110, 108, 106, 104, 102, 100]\n\n    You can also use slice notation directly:\n\n        >>> iterable = map(str, count())\n        >>> it = islice_extended(iterable)[10:20:2]\n        >>> list(it)\n        ['10', '12', '14', '16', '18']\n\n    \"\"\"\n\n    def __init__(self, iterable, *args):\n        it = iter(iterable)\n        if args:\n            self._iterable = _islice_helper(it, slice(*args))\n        else:\n            self._iterable = it\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        return next(self._iterable)\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            return islice_extended(_islice_helper(self._iterable, key))\n\n        raise TypeError('islice_extended.__getitem__ argument must be a slice')\n\n\ndef _islice_helper(it, s):\n    start = s.start\n    stop = s.stop\n    if s.step == 0:\n        raise ValueError('step argument must be a non-zero integer or None.')\n    step = s.step or 1\n\n    if step > 0:\n        start = 0 if (start is None) else start\n\n        if start < 0:\n            # Consume all but the last -start items\n            cache = deque(enumerate(it, 1), maxlen=-start)\n            len_iter = cache[-1][0] if cache else 0\n\n            # Adjust start to be positive\n            i = max(len_iter + start, 0)\n\n            # Adjust stop to be positive\n            if stop is None:\n                j = len_iter\n            elif stop >= 0:\n                j = min(stop, len_iter)\n            else:\n                j = max(len_iter + stop, 0)\n\n            # Slice the cache\n            n = j - i\n            if n <= 0:\n                return\n\n            for index, item in islice(cache, 0, n, step):\n                yield item\n        elif (stop is not None) and (stop < 0):\n            # Advance to the start position\n            next(islice(it, start, start), None)\n\n            # When stop is negative, we have to carry -stop items while\n            # iterating\n            cache = deque(islice(it, -stop), maxlen=-stop)\n\n            for index, item in enumerate(it):\n                cached_item = cache.popleft()\n                if index % step == 0:\n                    yield cached_item\n                cache.append(item)\n        else:\n            # When both start and stop are positive we have the normal case\n            yield from islice(it, start, stop, step)\n    else:\n        start = -1 if (start is None) else start\n\n        if (stop is not None) and (stop < 0):\n            # Consume all but the last items\n            n = -stop - 1\n            cache = deque(enumerate(it, 1), maxlen=n)\n            len_iter = cache[-1][0] if cache else 0\n\n            # If start and stop are both negative they are comparable and\n            # we can just slice. Otherwise we can adjust start to be negative\n            # and then slice.\n            if start < 0:\n                i, j = start, stop\n            else:\n                i, j = min(start - len_iter, -1), None\n\n            for index, item in list(cache)[i:j:step]:\n                yield item\n        else:\n            # Advance to the stop position\n            if stop is not None:\n                m = stop + 1\n                next(islice(it, m, m), None)\n\n            # stop is positive, so if start is negative they are not comparable\n            # and we need the rest of the items.\n            if start < 0:\n                i = start\n                n = None\n            # stop is None and start is positive, so we just need items up to\n            # the start index.\n            elif stop is None:\n                i = None\n                n = start + 1\n            # Both stop and start are positive, so they are comparable.\n            else:\n                i = None\n                n = start - stop\n                if n <= 0:\n                    return\n\n            cache = list(islice(it, n))\n\n            yield from cache[i::step]\n\n\ndef always_reversible(iterable):\n    \"\"\"An extension of :func:`reversed` that supports all iterables, not\n    just those which implement the ``Reversible`` or ``Sequence`` protocols.\n\n        >>> print(*always_reversible(x for x in range(3)))\n        2 1 0\n\n    If the iterable is already reversible, this function returns the\n    result of :func:`reversed()`. If the iterable is not reversible,\n    this function will cache the remaining items in the iterable and\n    yield them in reverse order, which may require significant storage.\n    \"\"\"\n    try:\n        return reversed(iterable)\n    except TypeError:\n        return reversed(list(iterable))\n\n\ndef consecutive_groups(iterable, ordering=lambda x: x):\n    \"\"\"Yield groups of consecutive items using :func:`itertools.groupby`.\n    The *ordering* function determines whether two items are adjacent by\n    returning their position.\n\n    By default, the ordering function is the identity function. This is\n    suitable for finding runs of numbers:\n\n        >>> iterable = [1, 10, 11, 12, 20, 30, 31, 32, 33, 40]\n        >>> for group in consecutive_groups(iterable):\n        ...     print(list(group))\n        [1]\n        [10, 11, 12]\n        [20]\n        [30, 31, 32, 33]\n        [40]\n\n    For finding runs of adjacent letters, try using the :meth:`index` method\n    of a string of letters:\n\n        >>> from string import ascii_lowercase\n        >>> iterable = 'abcdfgilmnop'\n        >>> ordering = ascii_lowercase.index\n        >>> for group in consecutive_groups(iterable, ordering):\n        ...     print(list(group))\n        ['a', 'b', 'c', 'd']\n        ['f', 'g']\n        ['i']\n        ['l', 'm', 'n', 'o', 'p']\n\n    Each group of consecutive items is an iterator that shares it source with\n    *iterable*. When an an output group is advanced, the previous group is\n    no longer available unless its elements are copied (e.g., into a ``list``).\n\n        >>> iterable = [1, 2, 11, 12, 21, 22]\n        >>> saved_groups = []\n        >>> for group in consecutive_groups(iterable):\n        ...     saved_groups.append(list(group))  # Copy group elements\n        >>> saved_groups\n        [[1, 2], [11, 12], [21, 22]]\n\n    \"\"\"\n    for k, g in groupby(\n        enumerate(iterable), key=lambda x: x[0] - ordering(x[1])\n    ):\n        yield map(itemgetter(1), g)\n\n\ndef difference(iterable, func=sub, *, initial=None):\n    \"\"\"This function is the inverse of :func:`itertools.accumulate`. By default\n    it will compute the first difference of *iterable* using\n    :func:`operator.sub`:\n\n        >>> from itertools import accumulate\n        >>> iterable = accumulate([0, 1, 2, 3, 4])  # produces 0, 1, 3, 6, 10\n        >>> list(difference(iterable))\n        [0, 1, 2, 3, 4]\n\n    *func* defaults to :func:`operator.sub`, but other functions can be\n    specified. They will be applied as follows::\n\n        A, B, C, D, ... --> A, func(B, A), func(C, B), func(D, C), ...\n\n    For example, to do progressive division:\n\n        >>> iterable = [1, 2, 6, 24, 120]\n        >>> func = lambda x, y: x // y\n        >>> list(difference(iterable, func))\n        [1, 2, 3, 4, 5]\n\n    If the *initial* keyword is set, the first element will be skipped when\n    computing successive differences.\n\n        >>> it = [10, 11, 13, 16]  # from accumulate([1, 2, 3], initial=10)\n        >>> list(difference(it, initial=10))\n        [1, 2, 3]\n\n    \"\"\"\n    a, b = tee(iterable)\n    try:\n        first = [next(b)]\n    except StopIteration:\n        return iter([])\n\n    if initial is not None:\n        first = []\n\n    return chain(first, map(func, b, a))\n\n\nclass SequenceView(Sequence):\n    \"\"\"Return a read-only view of the sequence object *target*.\n\n    :class:`SequenceView` objects are analogous to Python's built-in\n    \"dictionary view\" types. They provide a dynamic view of a sequence's items,\n    meaning that when the sequence updates, so does the view.\n\n        >>> seq = ['0', '1', '2']\n        >>> view = SequenceView(seq)\n        >>> view\n        SequenceView(['0', '1', '2'])\n        >>> seq.append('3')\n        >>> view\n        SequenceView(['0', '1', '2', '3'])\n\n    Sequence views support indexing, slicing, and length queries. They act\n    like the underlying sequence, except they don't allow assignment:\n\n        >>> view[1]\n        '1'\n        >>> view[1:-1]\n        ['1', '2']\n        >>> len(view)\n        4\n\n    Sequence views are useful as an alternative to copying, as they don't\n    require (much) extra storage.\n\n    \"\"\"\n\n    def __init__(self, target):\n        if not isinstance(target, Sequence):\n            raise TypeError\n        self._target = target\n\n    def __getitem__(self, index):\n        return self._target[index]\n\n    def __len__(self):\n        return len(self._target)\n\n    def __repr__(self):\n        return '{}({})'.format(self.__class__.__name__, repr(self._target))\n\n\nclass seekable:\n    \"\"\"Wrap an iterator to allow for seeking backward and forward. This\n    progressively caches the items in the source iterable so they can be\n    re-visited.\n\n    Call :meth:`seek` with an index to seek to that position in the source\n    iterable.\n\n    To \"reset\" an iterator, seek to ``0``:\n\n        >>> from itertools import count\n        >>> it = seekable((str(n) for n in count()))\n        >>> next(it), next(it), next(it)\n        ('0', '1', '2')\n        >>> it.seek(0)\n        >>> next(it), next(it), next(it)\n        ('0', '1', '2')\n        >>> next(it)\n        '3'\n\n    You can also seek forward:\n\n        >>> it = seekable((str(n) for n in range(20)))\n        >>> it.seek(10)\n        >>> next(it)\n        '10'\n        >>> it.relative_seek(-2)  # Seeking relative to the current position\n        >>> next(it)\n        '9'\n        >>> it.seek(20)  # Seeking past the end of the source isn't a problem\n        >>> list(it)\n        []\n        >>> it.seek(0)  # Resetting works even after hitting the end\n        >>> next(it), next(it), next(it)\n        ('0', '1', '2')\n\n    Call :meth:`peek` to look ahead one item without advancing the iterator:\n\n        >>> it = seekable('1234')\n        >>> it.peek()\n        '1'\n        >>> list(it)\n        ['1', '2', '3', '4']\n        >>> it.peek(default='empty')\n        'empty'\n\n    Before the iterator is at its end, calling :func:`bool` on it will return\n    ``True``. After it will return ``False``:\n\n        >>> it = seekable('5678')\n        >>> bool(it)\n        True\n        >>> list(it)\n        ['5', '6', '7', '8']\n        >>> bool(it)\n        False\n\n    You may view the contents of the cache with the :meth:`elements` method.\n    That returns a :class:`SequenceView`, a view that updates automatically:\n\n        >>> it = seekable((str(n) for n in range(10)))\n        >>> next(it), next(it), next(it)\n        ('0', '1', '2')\n        >>> elements = it.elements()\n        >>> elements\n        SequenceView(['0', '1', '2'])\n        >>> next(it)\n        '3'\n        >>> elements\n        SequenceView(['0', '1', '2', '3'])\n\n    By default, the cache grows as the source iterable progresses, so beware of\n    wrapping very large or infinite iterables. Supply *maxlen* to limit the\n    size of the cache (this of course limits how far back you can seek).\n\n        >>> from itertools import count\n        >>> it = seekable((str(n) for n in count()), maxlen=2)\n        >>> next(it), next(it), next(it), next(it)\n        ('0', '1', '2', '3')\n        >>> list(it.elements())\n        ['2', '3']\n        >>> it.seek(0)\n        >>> next(it), next(it), next(it), next(it)\n        ('2', '3', '4', '5')\n        >>> next(it)\n        '6'\n\n    \"\"\"\n\n    def __init__(self, iterable, maxlen=None):\n        self._source = iter(iterable)\n        if maxlen is None:\n            self._cache = []\n        else:\n            self._cache = deque([], maxlen)\n        self._index = None\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self._index is not None:\n            try:\n                item = self._cache[self._index]\n            except IndexError:\n                self._index = None\n            else:\n                self._index += 1\n                return item\n\n        item = next(self._source)\n        self._cache.append(item)\n        return item\n\n    def __bool__(self):\n        try:\n            self.peek()\n        except StopIteration:\n            return False\n        return True\n\n    def peek(self, default=_marker):\n        try:\n            peeked = next(self)\n        except StopIteration:\n            if default is _marker:\n                raise\n            return default\n        if self._index is None:\n            self._index = len(self._cache)\n        self._index -= 1\n        return peeked\n\n    def elements(self):\n        return SequenceView(self._cache)\n\n    def seek(self, index):\n        self._index = index\n        remainder = index - len(self._cache)\n        if remainder > 0:\n            consume(self, remainder)\n\n    def relative_seek(self, count):\n        index = len(self._cache)\n        self.seek(max(index + count, 0))\n\n\nclass run_length:\n    \"\"\"\n    :func:`run_length.encode` compresses an iterable with run-length encoding.\n    It yields groups of repeated items with the count of how many times they\n    were repeated:\n\n        >>> uncompressed = 'abbcccdddd'\n        >>> list(run_length.encode(uncompressed))\n        [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n\n    :func:`run_length.decode` decompresses an iterable that was previously\n    compressed with run-length encoding. It yields the items of the\n    decompressed iterable:\n\n        >>> compressed = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n        >>> list(run_length.decode(compressed))\n        ['a', 'b', 'b', 'c', 'c', 'c', 'd', 'd', 'd', 'd']\n\n    \"\"\"\n\n    @staticmethod\n    def encode(iterable):\n        return ((k, ilen(g)) for k, g in groupby(iterable))\n\n    @staticmethod\n    def decode(iterable):\n        return chain.from_iterable(repeat(k, n) for k, n in iterable)\n\n\ndef exactly_n(iterable, n, predicate=bool):\n    \"\"\"Return ``True`` if exactly ``n`` items in the iterable are ``True``\n    according to the *predicate* function.\n\n        >>> exactly_n([True, True, False], 2)\n        True\n        >>> exactly_n([True, True, False], 1)\n        False\n        >>> exactly_n([0, 1, 2, 3, 4, 5], 3, lambda x: x < 3)\n        True\n\n    The iterable will be advanced until ``n + 1`` truthy items are encountered,\n    so avoid calling it on infinite iterables.\n\n    \"\"\"\n    return len(take(n + 1, filter(predicate, iterable))) == n\n\n\ndef circular_shifts(iterable):\n    \"\"\"Return a list of circular shifts of *iterable*.\n\n    >>> circular_shifts(range(4))\n    [(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)]\n    \"\"\"\n    lst = list(iterable)\n    return take(len(lst), windowed(cycle(lst), len(lst)))\n\n\ndef make_decorator(wrapping_func, result_index=0):\n    \"\"\"Return a decorator version of *wrapping_func*, which is a function that\n    modifies an iterable. *result_index* is the position in that function's\n    signature where the iterable goes.\n\n    This lets you use itertools on the \"production end,\" i.e. at function\n    definition. This can augment what the function returns without changing the\n    function's code.\n\n    For example, to produce a decorator version of :func:`chunked`:\n\n        >>> from more_itertools import chunked\n        >>> chunker = make_decorator(chunked, result_index=0)\n        >>> @chunker(3)\n        ... def iter_range(n):\n        ...     return iter(range(n))\n        ...\n        >>> list(iter_range(9))\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n\n    To only allow truthy items to be returned:\n\n        >>> truth_serum = make_decorator(filter, result_index=1)\n        >>> @truth_serum(bool)\n        ... def boolean_test():\n        ...     return [0, 1, '', ' ', False, True]\n        ...\n        >>> list(boolean_test())\n        [1, ' ', True]\n\n    The :func:`peekable` and :func:`seekable` wrappers make for practical\n    decorators:\n\n        >>> from more_itertools import peekable\n        >>> peekable_function = make_decorator(peekable)\n        >>> @peekable_function()\n        ... def str_range(*args):\n        ...     return (str(x) for x in range(*args))\n        ...\n        >>> it = str_range(1, 20, 2)\n        >>> next(it), next(it), next(it)\n        ('1', '3', '5')\n        >>> it.peek()\n        '7'\n        >>> next(it)\n        '7'\n\n    \"\"\"\n\n    # See https://sites.google.com/site/bbayles/index/decorator_factory for\n    # notes on how this works.\n    def decorator(*wrapping_args, **wrapping_kwargs):\n        def outer_wrapper(f):\n            def inner_wrapper(*args, **kwargs):\n                result = f(*args, **kwargs)\n                wrapping_args_ = list(wrapping_args)\n                wrapping_args_.insert(result_index, result)\n                return wrapping_func(*wrapping_args_, **wrapping_kwargs)\n\n            return inner_wrapper\n\n        return outer_wrapper\n\n    return decorator\n\n\ndef map_reduce(iterable, keyfunc, valuefunc=None, reducefunc=None):\n    \"\"\"Return a dictionary that maps the items in *iterable* to categories\n    defined by *keyfunc*, transforms them with *valuefunc*, and\n    then summarizes them by category with *reducefunc*.\n\n    *valuefunc* defaults to the identity function if it is unspecified.\n    If *reducefunc* is unspecified, no summarization takes place:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> result = map_reduce('abbccc', keyfunc)\n        >>> sorted(result.items())\n        [('A', ['a']), ('B', ['b', 'b']), ('C', ['c', 'c', 'c'])]\n\n    Specifying *valuefunc* transforms the categorized items:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> valuefunc = lambda x: 1\n        >>> result = map_reduce('abbccc', keyfunc, valuefunc)\n        >>> sorted(result.items())\n        [('A', [1]), ('B', [1, 1]), ('C', [1, 1, 1])]\n\n    Specifying *reducefunc* summarizes the categorized items:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> valuefunc = lambda x: 1\n        >>> reducefunc = sum\n        >>> result = map_reduce('abbccc', keyfunc, valuefunc, reducefunc)\n        >>> sorted(result.items())\n        [('A', 1), ('B', 2), ('C', 3)]\n\n    You may want to filter the input iterable before applying the map/reduce\n    procedure:\n\n        >>> all_items = range(30)\n        >>> items = [x for x in all_items if 10 <= x <= 20]  # Filter\n        >>> keyfunc = lambda x: x % 2  # Evens map to 0; odds to 1\n        >>> categories = map_reduce(items, keyfunc=keyfunc)\n        >>> sorted(categories.items())\n        [(0, [10, 12, 14, 16, 18, 20]), (1, [11, 13, 15, 17, 19])]\n        >>> summaries = map_reduce(items, keyfunc=keyfunc, reducefunc=sum)\n        >>> sorted(summaries.items())\n        [(0, 90), (1, 75)]\n\n    Note that all items in the iterable are gathered into a list before the\n    summarization step, which may require significant storage.\n\n    The returned object is a :obj:`collections.defaultdict` with the\n    ``default_factory`` set to ``None``, such that it behaves like a normal\n    dictionary.\n\n    \"\"\"\n    valuefunc = (lambda x: x) if (valuefunc is None) else valuefunc\n\n    ret = defaultdict(list)\n    for item in iterable:\n        key = keyfunc(item)\n        value = valuefunc(item)\n        ret[key].append(value)\n\n    if reducefunc is not None:\n        for key, value_list in ret.items():\n            ret[key] = reducefunc(value_list)\n\n    ret.default_factory = None\n    return ret\n\n\ndef rlocate(iterable, pred=bool, window_size=None):\n    \"\"\"Yield the index of each item in *iterable* for which *pred* returns\n    ``True``, starting from the right and moving left.\n\n    *pred* defaults to :func:`bool`, which will select truthy items:\n\n        >>> list(rlocate([0, 1, 1, 0, 1, 0, 0]))  # Truthy at 1, 2, and 4\n        [4, 2, 1]\n\n    Set *pred* to a custom function to, e.g., find the indexes for a particular\n    item:\n\n        >>> iterable = iter('abcb')\n        >>> pred = lambda x: x == 'b'\n        >>> list(rlocate(iterable, pred))\n        [3, 1]\n\n    If *window_size* is given, then the *pred* function will be called with\n    that many items. This enables searching for sub-sequences:\n\n        >>> iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]\n        >>> pred = lambda *args: args == (1, 2, 3)\n        >>> list(rlocate(iterable, pred=pred, window_size=3))\n        [9, 5, 1]\n\n    Beware, this function won't return anything for infinite iterables.\n    If *iterable* is reversible, ``rlocate`` will reverse it and search from\n    the right. Otherwise, it will search from the left and return the results\n    in reverse order.\n\n    See :func:`locate` to for other example applications.\n\n    \"\"\"\n    if window_size is None:\n        try:\n            len_iter = len(iterable)\n            return (len_iter - i - 1 for i in locate(reversed(iterable), pred))\n        except TypeError:\n            pass\n\n    return reversed(list(locate(iterable, pred, window_size)))\n\n\ndef replace(iterable, pred, substitutes, count=None, window_size=1):\n    \"\"\"Yield the items from *iterable*, replacing the items for which *pred*\n    returns ``True`` with the items from the iterable *substitutes*.\n\n        >>> iterable = [1, 1, 0, 1, 1, 0, 1, 1]\n        >>> pred = lambda x: x == 0\n        >>> substitutes = (2, 3)\n        >>> list(replace(iterable, pred, substitutes))\n        [1, 1, 2, 3, 1, 1, 2, 3, 1, 1]\n\n    If *count* is given, the number of replacements will be limited:\n\n        >>> iterable = [1, 1, 0, 1, 1, 0, 1, 1, 0]\n        >>> pred = lambda x: x == 0\n        >>> substitutes = [None]\n        >>> list(replace(iterable, pred, substitutes, count=2))\n        [1, 1, None, 1, 1, None, 1, 1, 0]\n\n    Use *window_size* to control the number of items passed as arguments to\n    *pred*. This allows for locating and replacing subsequences.\n\n        >>> iterable = [0, 1, 2, 5, 0, 1, 2, 5]\n        >>> window_size = 3\n        >>> pred = lambda *args: args == (0, 1, 2)  # 3 items passed to pred\n        >>> substitutes = [3, 4] # Splice in these items\n        >>> list(replace(iterable, pred, substitutes, window_size=window_size))\n        [3, 4, 5, 3, 4, 5]\n\n    \"\"\"\n    if window_size < 1:\n        raise ValueError('window_size must be at least 1')\n\n    # Save the substitutes iterable, since it's used more than once\n    substitutes = tuple(substitutes)\n\n    # Add padding such that the number of windows matches the length of the\n    # iterable\n    it = chain(iterable, [_marker] * (window_size - 1))\n    windows = windowed(it, window_size)\n\n    n = 0\n    for w in windows:\n        # If the current window matches our predicate (and we haven't hit\n        # our maximum number of replacements), splice in the substitutes\n        # and then consume the following windows that overlap with this one.\n        # For example, if the iterable is (0, 1, 2, 3, 4...)\n        # and the window size is 2, we have (0, 1), (1, 2), (2, 3)...\n        # If the predicate matches on (0, 1), we need to zap (0, 1) and (1, 2)\n        if pred(*w):\n            if (count is None) or (n < count):\n                n += 1\n                yield from substitutes\n                consume(windows, window_size - 1)\n                continue\n\n        # If there was no match (or we've reached the replacement limit),\n        # yield the first item from the window.\n        if w and (w[0] is not _marker):\n            yield w[0]\n\n\ndef partitions(iterable):\n    \"\"\"Yield all possible order-preserving partitions of *iterable*.\n\n    >>> iterable = 'abc'\n    >>> for part in partitions(iterable):\n    ...     print([''.join(p) for p in part])\n    ['abc']\n    ['a', 'bc']\n    ['ab', 'c']\n    ['a', 'b', 'c']\n\n    This is unrelated to :func:`partition`.\n\n    \"\"\"\n    sequence = list(iterable)\n    n = len(sequence)\n    for i in powerset(range(1, n)):\n        yield [sequence[i:j] for i, j in zip((0,) + i, i + (n,))]\n\n\ndef set_partitions(iterable, k=None):\n    \"\"\"\n    Yield the set partitions of *iterable* into *k* parts. Set partitions are\n    not order-preserving.\n\n    >>> iterable = 'abc'\n    >>> for part in set_partitions(iterable, 2):\n    ...     print([''.join(p) for p in part])\n    ['a', 'bc']\n    ['ab', 'c']\n    ['b', 'ac']\n\n\n    If *k* is not given, every set partition is generated.\n\n    >>> iterable = 'abc'\n    >>> for part in set_partitions(iterable):\n    ...     print([''.join(p) for p in part])\n    ['abc']\n    ['a', 'bc']\n    ['ab', 'c']\n    ['b', 'ac']\n    ['a', 'b', 'c']\n\n    \"\"\"\n    L = list(iterable)\n    n = len(L)\n    if k is not None:\n        if k < 1:\n            raise ValueError(\n                \"Can't partition in a negative or zero number of groups\"\n            )\n        elif k > n:\n            return\n\n    def set_partitions_helper(L, k):\n        n = len(L)\n        if k == 1:\n            yield [L]\n        elif n == k:\n            yield [[s] for s in L]\n        else:\n            e, *M = L\n            for p in set_partitions_helper(M, k - 1):\n                yield [[e], *p]\n            for p in set_partitions_helper(M, k):\n                for i in range(len(p)):\n                    yield p[:i] + [[e] + p[i]] + p[i + 1 :]\n\n    if k is None:\n        for k in range(1, n + 1):\n            yield from set_partitions_helper(L, k)\n    else:\n        yield from set_partitions_helper(L, k)\n\n\nclass time_limited:\n    \"\"\"\n    Yield items from *iterable* until *limit_seconds* have passed.\n    If the time limit expires before all items have been yielded, the\n    ``timed_out`` parameter will be set to ``True``.\n\n    >>> from time import sleep\n    >>> def generator():\n    ...     yield 1\n    ...     yield 2\n    ...     sleep(0.2)\n    ...     yield 3\n    >>> iterable = time_limited(0.1, generator())\n    >>> list(iterable)\n    [1, 2]\n    >>> iterable.timed_out\n    True\n\n    Note that the time is checked before each item is yielded, and iteration\n    stops if  the time elapsed is greater than *limit_seconds*. If your time\n    limit is 1 second, but it takes 2 seconds to generate the first item from\n    the iterable, the function will run for 2 seconds and not yield anything.\n    As a special case, when *limit_seconds* is zero, the iterator never\n    returns anything.\n\n    \"\"\"\n\n    def __init__(self, limit_seconds, iterable):\n        if limit_seconds < 0:\n            raise ValueError('limit_seconds must be positive')\n        self.limit_seconds = limit_seconds\n        self._iterable = iter(iterable)\n        self._start_time = monotonic()\n        self.timed_out = False\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.limit_seconds == 0:\n            self.timed_out = True\n            raise StopIteration\n        item = next(self._iterable)\n        if monotonic() - self._start_time > self.limit_seconds:\n            self.timed_out = True\n            raise StopIteration\n\n        return item\n\n\ndef only(iterable, default=None, too_long=None):\n    \"\"\"If *iterable* has only one item, return it.\n    If it has zero items, return *default*.\n    If it has more than one item, raise the exception given by *too_long*,\n    which is ``ValueError`` by default.\n\n    >>> only([], default='missing')\n    'missing'\n    >>> only([1])\n    1\n    >>> only([1, 2])  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    ValueError: Expected exactly one item in iterable, but got 1, 2,\n     and perhaps more.'\n    >>> only([1, 2], too_long=TypeError)  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    TypeError\n\n    Note that :func:`only` attempts to advance *iterable* twice to ensure there\n    is only one item.  See :func:`spy` or :func:`peekable` to check\n    iterable contents less destructively.\n    \"\"\"\n    it = iter(iterable)\n    first_value = next(it, default)\n\n    try:\n        second_value = next(it)\n    except StopIteration:\n        pass\n    else:\n        msg = (\n            'Expected exactly one item in iterable, but got {!r}, {!r}, '\n            'and perhaps more.'.format(first_value, second_value)\n        )\n        raise too_long or ValueError(msg)\n\n    return first_value\n\n\ndef _ichunk(iterable, n):\n    cache = deque()\n    chunk = islice(iterable, n)\n\n    def generator():\n        while True:\n            if cache:\n                yield cache.popleft()\n            else:\n                try:\n                    item = next(chunk)\n                except StopIteration:\n                    return\n                else:\n                    yield item\n\n    def materialize_next(n=1):\n        # if n not specified materialize everything\n        if n is None:\n            cache.extend(chunk)\n            return len(cache)\n\n        to_cache = n - len(cache)\n\n        # materialize up to n\n        if to_cache > 0:\n            cache.extend(islice(chunk, to_cache))\n\n        # return number materialized up to n\n        return min(n, len(cache))\n\n    return (generator(), materialize_next)\n\n\ndef ichunked(iterable, n):\n    \"\"\"Break *iterable* into sub-iterables with *n* elements each.\n    :func:`ichunked` is like :func:`chunked`, but it yields iterables\n    instead of lists.\n\n    If the sub-iterables are read in order, the elements of *iterable*\n    won't be stored in memory.\n    If they are read out of order, :func:`itertools.tee` is used to cache\n    elements as necessary.\n\n    >>> from itertools import count\n    >>> all_chunks = ichunked(count(), 4)\n    >>> c_1, c_2, c_3 = next(all_chunks), next(all_chunks), next(all_chunks)\n    >>> list(c_2)  # c_1's elements have been cached; c_3's haven't been\n    [4, 5, 6, 7]\n    >>> list(c_1)\n    [0, 1, 2, 3]\n    >>> list(c_3)\n    [8, 9, 10, 11]\n\n    \"\"\"\n    iterable = iter(iterable)\n    while True:\n        # Create new chunk\n        chunk, materialize_next = _ichunk(iterable, n)\n\n        # Check to see whether we're at the end of the source iterable\n        if not materialize_next():\n            return\n\n        yield chunk\n\n        # Fill previous chunk's cache\n        materialize_next(None)\n\n\ndef iequals(*iterables):\n    \"\"\"Return ``True`` if all given *iterables* are equal to each other,\n    which means that they contain the same elements in the same order.\n\n    The function is useful for comparing iterables of different data types\n    or iterables that do not support equality checks.\n\n    >>> iequals(\"abc\", ['a', 'b', 'c'], ('a', 'b', 'c'), iter(\"abc\"))\n    True\n\n    >>> iequals(\"abc\", \"acb\")\n    False\n\n    Not to be confused with :func:`all_equal`, which checks whether all\n    elements of iterable are equal to each other.\n\n    \"\"\"\n    return all(map(all_equal, zip_longest(*iterables, fillvalue=object())))\n\n\ndef distinct_combinations(iterable, r):\n    \"\"\"Yield the distinct combinations of *r* items taken from *iterable*.\n\n        >>> list(distinct_combinations([0, 0, 1], 2))\n        [(0, 0), (0, 1)]\n\n    Equivalent to ``set(combinations(iterable))``, except duplicates are not\n    generated and thrown away. For larger input sequences this is much more\n    efficient.\n\n    \"\"\"\n    if r < 0:\n        raise ValueError('r must be non-negative')\n    elif r == 0:\n        yield ()\n        return\n    pool = tuple(iterable)\n    generators = [unique_everseen(enumerate(pool), key=itemgetter(1))]\n    current_combo = [None] * r\n    level = 0\n    while generators:\n        try:\n            cur_idx, p = next(generators[-1])\n        except StopIteration:\n            generators.pop()\n            level -= 1\n            continue\n        current_combo[level] = p\n        if level + 1 == r:\n            yield tuple(current_combo)\n        else:\n            generators.append(\n                unique_everseen(\n                    enumerate(pool[cur_idx + 1 :], cur_idx + 1),\n                    key=itemgetter(1),\n                )\n            )\n            level += 1\n\n\ndef filter_except(validator, iterable, *exceptions):\n    \"\"\"Yield the items from *iterable* for which the *validator* function does\n    not raise one of the specified *exceptions*.\n\n    *validator* is called for each item in *iterable*.\n    It should be a function that accepts one argument and raises an exception\n    if that item is not valid.\n\n    >>> iterable = ['1', '2', 'three', '4', None]\n    >>> list(filter_except(int, iterable, ValueError, TypeError))\n    ['1', '2', '4']\n\n    If an exception other than one given by *exceptions* is raised by\n    *validator*, it is raised like normal.\n    \"\"\"\n    for item in iterable:\n        try:\n            validator(item)\n        except exceptions:\n            pass\n        else:\n            yield item\n\n\ndef map_except(function, iterable, *exceptions):\n    \"\"\"Transform each item from *iterable* with *function* and yield the\n    result, unless *function* raises one of the specified *exceptions*.\n\n    *function* is called to transform each item in *iterable*.\n    It should accept one argument.\n\n    >>> iterable = ['1', '2', 'three', '4', None]\n    >>> list(map_except(int, iterable, ValueError, TypeError))\n    [1, 2, 4]\n\n    If an exception other than one given by *exceptions* is raised by\n    *function*, it is raised like normal.\n    \"\"\"\n    for item in iterable:\n        try:\n            yield function(item)\n        except exceptions:\n            pass\n\n\ndef map_if(iterable, pred, func, func_else=lambda x: x):\n    \"\"\"Evaluate each item from *iterable* using *pred*. If the result is\n    equivalent to ``True``, transform the item with *func* and yield it.\n    Otherwise, transform the item with *func_else* and yield it.\n\n    *pred*, *func*, and *func_else* should each be functions that accept\n    one argument. By default, *func_else* is the identity function.\n\n    >>> from math import sqrt\n    >>> iterable = list(range(-5, 5))\n    >>> iterable\n    [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\n    >>> list(map_if(iterable, lambda x: x > 3, lambda x: 'toobig'))\n    [-5, -4, -3, -2, -1, 0, 1, 2, 3, 'toobig']\n    >>> list(map_if(iterable, lambda x: x >= 0,\n    ... lambda x: f'{sqrt(x):.2f}', lambda x: None))\n    [None, None, None, None, None, '0.00', '1.00', '1.41', '1.73', '2.00']\n    \"\"\"\n    for item in iterable:\n        yield func(item) if pred(item) else func_else(item)\n\n\ndef _sample_unweighted(iterable, k):\n    # Implementation of \"Algorithm L\" from the 1994 paper by Kim-Hung Li:\n    # \"Reservoir-Sampling Algorithms of Time Complexity O(n(1+log(N/n)))\".\n\n    # Fill up the reservoir (collection of samples) with the first `k` samples\n    reservoir = take(k, iterable)\n\n    # Generate random number that's the largest in a sample of k U(0,1) numbers\n    # Largest order statistic: https://en.wikipedia.org/wiki/Order_statistic\n    W = exp(log(random()) / k)\n\n    # The number of elements to skip before changing the reservoir is a random\n    # number with a geometric distribution. Sample it using random() and logs.\n    next_index = k + floor(log(random()) / log(1 - W))\n\n    for index, element in enumerate(iterable, k):\n        if index == next_index:\n            reservoir[randrange(k)] = element\n            # The new W is the largest in a sample of k U(0, `old_W`) numbers\n            W *= exp(log(random()) / k)\n            next_index += floor(log(random()) / log(1 - W)) + 1\n\n    return reservoir\n\n\ndef _sample_weighted(iterable, k, weights):\n    # Implementation of \"A-ExpJ\" from the 2006 paper by Efraimidis et al. :\n    # \"Weighted random sampling with a reservoir\".\n\n    # Log-transform for numerical stability for weights that are small/large\n    weight_keys = (log(random()) / weight for weight in weights)\n\n    # Fill up the reservoir (collection of samples) with the first `k`\n    # weight-keys and elements, then heapify the list.\n    reservoir = take(k, zip(weight_keys, iterable))\n    heapify(reservoir)\n\n    # The number of jumps before changing the reservoir is a random variable\n    # with an exponential distribution. Sample it using random() and logs.\n    smallest_weight_key, _ = reservoir[0]\n    weights_to_skip = log(random()) / smallest_weight_key\n\n    for weight, element in zip(weights, iterable):\n        if weight >= weights_to_skip:\n            # The notation here is consistent with the paper, but we store\n            # the weight-keys in log-space for better numerical stability.\n            smallest_weight_key, _ = reservoir[0]\n            t_w = exp(weight * smallest_weight_key)\n            r_2 = uniform(t_w, 1)  # generate U(t_w, 1)\n            weight_key = log(r_2) / weight\n            heapreplace(reservoir, (weight_key, element))\n            smallest_weight_key, _ = reservoir[0]\n            weights_to_skip = log(random()) / smallest_weight_key\n        else:\n            weights_to_skip -= weight\n\n    # Equivalent to [element for weight_key, element in sorted(reservoir)]\n    return [heappop(reservoir)[1] for _ in range(k)]\n\n\ndef sample(iterable, k, weights=None):\n    \"\"\"Return a *k*-length list of elements chosen (without replacement)\n    from the *iterable*. Like :func:`random.sample`, but works on iterables\n    of unknown length.\n\n    >>> iterable = range(100)\n    >>> sample(iterable, 5)  # doctest: +SKIP\n    [81, 60, 96, 16, 4]\n\n    An iterable with *weights* may also be given:\n\n    >>> iterable = range(100)\n    >>> weights = (i * i + 1 for i in range(100))\n    >>> sampled = sample(iterable, 5, weights=weights)  # doctest: +SKIP\n    [79, 67, 74, 66, 78]\n\n    The algorithm can also be used to generate weighted random permutations.\n    The relative weight of each item determines the probability that it\n    appears late in the permutation.\n\n    >>> data = \"abcdefgh\"\n    >>> weights = range(1, len(data) + 1)\n    >>> sample(data, k=len(data), weights=weights)  # doctest: +SKIP\n    ['c', 'a', 'b', 'e', 'g', 'd', 'h', 'f']\n    \"\"\"\n    if k == 0:\n        return []\n\n    iterable = iter(iterable)\n    if weights is None:\n        return _sample_unweighted(iterable, k)\n    else:\n        weights = iter(weights)\n        return _sample_weighted(iterable, k, weights)\n\n\ndef is_sorted(iterable, key=None, reverse=False, strict=False):\n    \"\"\"Returns ``True`` if the items of iterable are in sorted order, and\n    ``False`` otherwise. *key* and *reverse* have the same meaning that they do\n    in the built-in :func:`sorted` function.\n\n    >>> is_sorted(['1', '2', '3', '4', '5'], key=int)\n    True\n    >>> is_sorted([5, 4, 3, 1, 2], reverse=True)\n    False\n\n    If *strict*, tests for strict sorting, that is, returns ``False`` if equal\n    elements are found:\n\n    >>> is_sorted([1, 2, 2])\n    True\n    >>> is_sorted([1, 2, 2], strict=True)\n    False\n\n    The function returns ``False`` after encountering the first out-of-order\n    item. If there are no out-of-order items, the iterable is exhausted.\n    \"\"\"\n\n    compare = (le if reverse else ge) if strict else (lt if reverse else gt)\n    it = iterable if key is None else map(key, iterable)\n    return not any(starmap(compare, pairwise(it)))\n\n\nclass AbortThread(BaseException):\n    pass\n\n\nclass callback_iter:\n    \"\"\"Convert a function that uses callbacks to an iterator.\n\n    Let *func* be a function that takes a `callback` keyword argument.\n    For example:\n\n    >>> def func(callback=None):\n    ...     for i, c in [(1, 'a'), (2, 'b'), (3, 'c')]:\n    ...         if callback:\n    ...             callback(i, c)\n    ...     return 4\n\n\n    Use ``with callback_iter(func)`` to get an iterator over the parameters\n    that are delivered to the callback.\n\n    >>> with callback_iter(func) as it:\n    ...     for args, kwargs in it:\n    ...         print(args)\n    (1, 'a')\n    (2, 'b')\n    (3, 'c')\n\n    The function will be called in a background thread. The ``done`` property\n    indicates whether it has completed execution.\n\n    >>> it.done\n    True\n\n    If it completes successfully, its return value will be available\n    in the ``result`` property.\n\n    >>> it.result\n    4\n\n    Notes:\n\n    * If the function uses some keyword argument besides ``callback``, supply\n      *callback_kwd*.\n    * If it finished executing, but raised an exception, accessing the\n      ``result`` property will raise the same exception.\n    * If it hasn't finished executing, accessing the ``result``\n      property from within the ``with`` block will raise ``RuntimeError``.\n    * If it hasn't finished executing, accessing the ``result`` property from\n      outside the ``with`` block will raise a\n      ``more_itertools.AbortThread`` exception.\n    * Provide *wait_seconds* to adjust how frequently the it is polled for\n      output.\n\n    \"\"\"\n\n    def __init__(self, func, callback_kwd='callback', wait_seconds=0.1):\n        self._func = func\n        self._callback_kwd = callback_kwd\n        self._aborted = False\n        self._future = None\n        self._wait_seconds = wait_seconds\n        # Lazily import concurrent.future\n        self._executor = __import__(\n            'concurrent.futures'\n        ).futures.ThreadPoolExecutor(max_workers=1)\n        self._iterator = self._reader()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self._aborted = True\n        self._executor.shutdown()\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        return next(self._iterator)\n\n    @property\n    def done(self):\n        if self._future is None:\n            return False\n        return self._future.done()\n\n    @property\n    def result(self):\n        if not self.done:\n            raise RuntimeError('Function has not yet completed')\n\n        return self._future.result()\n\n    def _reader(self):\n        q = Queue()\n\n        def callback(*args, **kwargs):\n            if self._aborted:\n                raise AbortThread('canceled by user')\n\n            q.put((args, kwargs))\n\n        self._future = self._executor.submit(\n            self._func, **{self._callback_kwd: callback}\n        )\n\n        while True:\n            try:\n                item = q.get(timeout=self._wait_seconds)\n            except Empty:\n                pass\n            else:\n                q.task_done()\n                yield item\n\n            if self._future.done():\n                break\n\n        remaining = []\n        while True:\n            try:\n                item = q.get_nowait()\n            except Empty:\n                break\n            else:\n                q.task_done()\n                remaining.append(item)\n        q.join()\n        yield from remaining\n\n\ndef windowed_complete(iterable, n):\n    \"\"\"\n    Yield ``(beginning, middle, end)`` tuples, where:\n\n    * Each ``middle`` has *n* items from *iterable*\n    * Each ``beginning`` has the items before the ones in ``middle``\n    * Each ``end`` has the items after the ones in ``middle``\n\n    >>> iterable = range(7)\n    >>> n = 3\n    >>> for beginning, middle, end in windowed_complete(iterable, n):\n    ...     print(beginning, middle, end)\n    () (0, 1, 2) (3, 4, 5, 6)\n    (0,) (1, 2, 3) (4, 5, 6)\n    (0, 1) (2, 3, 4) (5, 6)\n    (0, 1, 2) (3, 4, 5) (6,)\n    (0, 1, 2, 3) (4, 5, 6) ()\n\n    Note that *n* must be at least 0 and most equal to the length of\n    *iterable*.\n\n    This function will exhaust the iterable and may require significant\n    storage.\n    \"\"\"\n    if n < 0:\n        raise ValueError('n must be >= 0')\n\n    seq = tuple(iterable)\n    size = len(seq)\n\n    if n > size:\n        raise ValueError('n must be <= len(seq)')\n\n    for i in range(size - n + 1):\n        beginning = seq[:i]\n        middle = seq[i : i + n]\n        end = seq[i + n :]\n        yield beginning, middle, end\n\n\ndef all_unique(iterable, key=None):\n    \"\"\"\n    Returns ``True`` if all the elements of *iterable* are unique (no two\n    elements are equal).\n\n        >>> all_unique('ABCB')\n        False\n\n    If a *key* function is specified, it will be used to make comparisons.\n\n        >>> all_unique('ABCb')\n        True\n        >>> all_unique('ABCb', str.lower)\n        False\n\n    The function returns as soon as the first non-unique element is\n    encountered. Iterables with a mix of hashable and unhashable items can\n    be used, but the function will be slower for unhashable items.\n    \"\"\"\n    seenset = set()\n    seenset_add = seenset.add\n    seenlist = []\n    seenlist_add = seenlist.append\n    for element in map(key, iterable) if key else iterable:\n        try:\n            if element in seenset:\n                return False\n            seenset_add(element)\n        except TypeError:\n            if element in seenlist:\n                return False\n            seenlist_add(element)\n    return True\n\n\ndef nth_product(index, *args):\n    \"\"\"Equivalent to ``list(product(*args))[index]``.\n\n    The products of *args* can be ordered lexicographically.\n    :func:`nth_product` computes the product at sort position *index* without\n    computing the previous products.\n\n        >>> nth_product(8, range(2), range(2), range(2), range(2))\n        (1, 0, 0, 0)\n\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pools = list(map(tuple, reversed(args)))\n    ns = list(map(len, pools))\n\n    c = reduce(mul, ns)\n\n    if index < 0:\n        index += c\n\n    if not 0 <= index < c:\n        raise IndexError\n\n    result = []\n    for pool, n in zip(pools, ns):\n        result.append(pool[index % n])\n        index //= n\n\n    return tuple(reversed(result))\n\n\ndef nth_permutation(iterable, r, index):\n    \"\"\"Equivalent to ``list(permutations(iterable, r))[index]```\n\n    The subsequences of *iterable* that are of length *r* where order is\n    important can be ordered lexicographically. :func:`nth_permutation`\n    computes the subsequence at sort position *index* directly, without\n    computing the previous subsequences.\n\n        >>> nth_permutation('ghijk', 2, 5)\n        ('h', 'i')\n\n    ``ValueError`` will be raised If *r* is negative or greater than the length\n    of *iterable*.\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pool = list(iterable)\n    n = len(pool)\n\n    if r is None or r == n:\n        r, c = n, factorial(n)\n    elif not 0 <= r < n:\n        raise ValueError\n    else:\n        c = perm(n, r)\n    assert c > 0  # factortial(n)>0, and r<n so perm(n,r) is never zero\n\n    if index < 0:\n        index += c\n\n    if not 0 <= index < c:\n        raise IndexError\n\n    result = [0] * r\n    q = index * factorial(n) // c if r < n else index\n    for d in range(1, n + 1):\n        q, i = divmod(q, d)\n        if 0 <= n - d < r:\n            result[n - d] = i\n        if q == 0:\n            break\n\n    return tuple(map(pool.pop, result))\n\n\ndef nth_combination_with_replacement(iterable, r, index):\n    \"\"\"Equivalent to\n    ``list(combinations_with_replacement(iterable, r))[index]``.\n\n\n    The subsequences with repetition of *iterable* that are of length *r* can\n    be ordered lexicographically. :func:`nth_combination_with_replacement`\n    computes the subsequence at sort position *index* directly, without\n    computing the previous subsequences with replacement.\n\n        >>> nth_combination_with_replacement(range(5), 3, 5)\n        (0, 1, 1)\n\n    ``ValueError`` will be raised If *r* is negative or greater than the length\n    of *iterable*.\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    if (r < 0) or (r > n):\n        raise ValueError\n\n    c = comb(n + r - 1, r)\n\n    if index < 0:\n        index += c\n\n    if (index < 0) or (index >= c):\n        raise IndexError\n\n    result = []\n    i = 0\n    while r:\n        r -= 1\n        while n >= 0:\n            num_combs = comb(n + r - 1, r)\n            if index < num_combs:\n                break\n            n -= 1\n            i += 1\n            index -= num_combs\n        result.append(pool[i])\n\n    return tuple(result)\n\n\ndef value_chain(*args):\n    \"\"\"Yield all arguments passed to the function in the same order in which\n    they were passed. If an argument itself is iterable then iterate over its\n    values.\n\n        >>> list(value_chain(1, 2, 3, [4, 5, 6]))\n        [1, 2, 3, 4, 5, 6]\n\n    Binary and text strings are not considered iterable and are emitted\n    as-is:\n\n        >>> list(value_chain('12', '34', ['56', '78']))\n        ['12', '34', '56', '78']\n\n    Pre- or postpend a single element to an iterable:\n\n        >>> list(value_chain(1, [2, 3, 4, 5, 6]))\n        [1, 2, 3, 4, 5, 6]\n        >>> list(value_chain([1, 2, 3, 4, 5], 6))\n        [1, 2, 3, 4, 5, 6]\n\n    Multiple levels of nesting are not flattened.\n\n    \"\"\"\n    for value in args:\n        if isinstance(value, (str, bytes)):\n            yield value\n            continue\n        try:\n            yield from value\n        except TypeError:\n            yield value\n\n\ndef product_index(element, *args):\n    \"\"\"Equivalent to ``list(product(*args)).index(element)``\n\n    The products of *args* can be ordered lexicographically.\n    :func:`product_index` computes the first index of *element* without\n    computing the previous products.\n\n        >>> product_index([8, 2], range(10), range(5))\n        42\n\n    ``ValueError`` will be raised if the given *element* isn't in the product\n    of *args*.\n    \"\"\"\n    index = 0\n\n    for x, pool in zip_longest(element, args, fillvalue=_marker):\n        if x is _marker or pool is _marker:\n            raise ValueError('element is not a product of args')\n\n        pool = tuple(pool)\n        index = index * len(pool) + pool.index(x)\n\n    return index\n\n\ndef combination_index(element, iterable):\n    \"\"\"Equivalent to ``list(combinations(iterable, r)).index(element)``\n\n    The subsequences of *iterable* that are of length *r* can be ordered\n    lexicographically. :func:`combination_index` computes the index of the\n    first *element*, without computing the previous combinations.\n\n        >>> combination_index('adf', 'abcdefg')\n        10\n\n    ``ValueError`` will be raised if the given *element* isn't one of the\n    combinations of *iterable*.\n    \"\"\"\n    element = enumerate(element)\n    k, y = next(element, (None, None))\n    if k is None:\n        return 0\n\n    indexes = []\n    pool = enumerate(iterable)\n    for n, x in pool:\n        if x == y:\n            indexes.append(n)\n            tmp, y = next(element, (None, None))\n            if tmp is None:\n                break\n            else:\n                k = tmp\n    else:\n        raise ValueError('element is not a combination of iterable')\n\n    n, _ = last(pool, default=(n, None))\n\n    # Python versions below 3.8 don't have math.comb\n    index = 1\n    for i, j in enumerate(reversed(indexes), start=1):\n        j = n - j\n        if i <= j:\n            index += comb(j, i)\n\n    return comb(n + 1, k + 1) - index\n\n\ndef combination_with_replacement_index(element, iterable):\n    \"\"\"Equivalent to\n    ``list(combinations_with_replacement(iterable, r)).index(element)``\n\n    The subsequences with repetition of *iterable* that are of length *r* can\n    be ordered lexicographically. :func:`combination_with_replacement_index`\n    computes the index of the first *element*, without computing the previous\n    combinations with replacement.\n\n        >>> combination_with_replacement_index('adf', 'abcdefg')\n        20\n\n    ``ValueError`` will be raised if the given *element* isn't one of the\n    combinations with replacement of *iterable*.\n    \"\"\"\n    element = tuple(element)\n    l = len(element)\n    element = enumerate(element)\n\n    k, y = next(element, (None, None))\n    if k is None:\n        return 0\n\n    indexes = []\n    pool = tuple(iterable)\n    for n, x in enumerate(pool):\n        while x == y:\n            indexes.append(n)\n            tmp, y = next(element, (None, None))\n            if tmp is None:\n                break\n            else:\n                k = tmp\n        if y is None:\n            break\n    else:\n        raise ValueError(\n            'element is not a combination with replacement of iterable'\n        )\n\n    n = len(pool)\n    occupations = [0] * n\n    for p in indexes:\n        occupations[p] += 1\n\n    index = 0\n    cumulative_sum = 0\n    for k in range(1, n):\n        cumulative_sum += occupations[k - 1]\n        j = l + n - 1 - k - cumulative_sum\n        i = n - k\n        if i <= j:\n            index += comb(j, i)\n\n    return index\n\n\ndef permutation_index(element, iterable):\n    \"\"\"Equivalent to ``list(permutations(iterable, r)).index(element)```\n\n    The subsequences of *iterable* that are of length *r* where order is\n    important can be ordered lexicographically. :func:`permutation_index`\n    computes the index of the first *element* directly, without computing\n    the previous permutations.\n\n        >>> permutation_index([1, 3, 2], range(5))\n        19\n\n    ``ValueError`` will be raised if the given *element* isn't one of the\n    permutations of *iterable*.\n    \"\"\"\n    index = 0\n    pool = list(iterable)\n    for i, x in zip(range(len(pool), -1, -1), element):\n        r = pool.index(x)\n        index = index * i + r\n        del pool[r]\n\n    return index\n\n\nclass countable:\n    \"\"\"Wrap *iterable* and keep a count of how many items have been consumed.\n\n    The ``items_seen`` attribute starts at ``0`` and increments as the iterable\n    is consumed:\n\n        >>> iterable = map(str, range(10))\n        >>> it = countable(iterable)\n        >>> it.items_seen\n        0\n        >>> next(it), next(it)\n        ('0', '1')\n        >>> list(it)\n        ['2', '3', '4', '5', '6', '7', '8', '9']\n        >>> it.items_seen\n        10\n    \"\"\"\n\n    def __init__(self, iterable):\n        self._it = iter(iterable)\n        self.items_seen = 0\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        item = next(self._it)\n        self.items_seen += 1\n\n        return item\n\n\ndef chunked_even(iterable, n):\n    \"\"\"Break *iterable* into lists of approximately length *n*.\n    Items are distributed such the lengths of the lists differ by at most\n    1 item.\n\n    >>> iterable = [1, 2, 3, 4, 5, 6, 7]\n    >>> n = 3\n    >>> list(chunked_even(iterable, n))  # List lengths: 3, 2, 2\n    [[1, 2, 3], [4, 5], [6, 7]]\n    >>> list(chunked(iterable, n))  # List lengths: 3, 3, 1\n    [[1, 2, 3], [4, 5, 6], [7]]\n\n    \"\"\"\n    iterable = iter(iterable)\n\n    # Initialize a buffer to process the chunks while keeping\n    # some back to fill any underfilled chunks\n    min_buffer = (n - 1) * (n - 2)\n    buffer = list(islice(iterable, min_buffer))\n\n    # Append items until we have a completed chunk\n    for _ in islice(map(buffer.append, iterable), n, None, n):\n        yield buffer[:n]\n        del buffer[:n]\n\n    # Check if any chunks need addition processing\n    if not buffer:\n        return\n    length = len(buffer)\n\n    # Chunks are either size `full_size <= n` or `partial_size = full_size - 1`\n    q, r = divmod(length, n)\n    num_lists = q + (1 if r > 0 else 0)\n    q, r = divmod(length, num_lists)\n    full_size = q + (1 if r > 0 else 0)\n    partial_size = full_size - 1\n    num_full = length - partial_size * num_lists\n\n    # Yield chunks of full size\n    partial_start_idx = num_full * full_size\n    if full_size > 0:\n        for i in range(0, partial_start_idx, full_size):\n            yield buffer[i : i + full_size]\n\n    # Yield chunks of partial size\n    if partial_size > 0:\n        for i in range(partial_start_idx, length, partial_size):\n            yield buffer[i : i + partial_size]\n\n\ndef zip_broadcast(*objects, scalar_types=(str, bytes), strict=False):\n    \"\"\"A version of :func:`zip` that \"broadcasts\" any scalar\n    (i.e., non-iterable) items into output tuples.\n\n    >>> iterable_1 = [1, 2, 3]\n    >>> iterable_2 = ['a', 'b', 'c']\n    >>> scalar = '_'\n    >>> list(zip_broadcast(iterable_1, iterable_2, scalar))\n    [(1, 'a', '_'), (2, 'b', '_'), (3, 'c', '_')]\n\n    The *scalar_types* keyword argument determines what types are considered\n    scalar. It is set to ``(str, bytes)`` by default. Set it to ``None`` to\n    treat strings and byte strings as iterable:\n\n    >>> list(zip_broadcast('abc', 0, 'xyz', scalar_types=None))\n    [('a', 0, 'x'), ('b', 0, 'y'), ('c', 0, 'z')]\n\n    If the *strict* keyword argument is ``True``, then\n    ``UnequalIterablesError`` will be raised if any of the iterables have\n    different lengths.\n    \"\"\"\n\n    def is_scalar(obj):\n        if scalar_types and isinstance(obj, scalar_types):\n            return True\n        try:\n            iter(obj)\n        except TypeError:\n            return True\n        else:\n            return False\n\n    size = len(objects)\n    if not size:\n        return\n\n    new_item = [None] * size\n    iterables, iterable_positions = [], []\n    for i, obj in enumerate(objects):\n        if is_scalar(obj):\n            new_item[i] = obj\n        else:\n            iterables.append(iter(obj))\n            iterable_positions.append(i)\n\n    if not iterables:\n        yield tuple(objects)\n        return\n\n    zipper = _zip_equal if strict else zip\n    for item in zipper(*iterables):\n        for i, new_item[i] in zip(iterable_positions, item):\n            pass\n        yield tuple(new_item)\n\n\ndef unique_in_window(iterable, n, key=None):\n    \"\"\"Yield the items from *iterable* that haven't been seen recently.\n    *n* is the size of the lookback window.\n\n        >>> iterable = [0, 1, 0, 2, 3, 0]\n        >>> n = 3\n        >>> list(unique_in_window(iterable, n))\n        [0, 1, 2, 3, 0]\n\n    The *key* function, if provided, will be used to determine uniqueness:\n\n        >>> list(unique_in_window('abAcda', 3, key=lambda x: x.lower()))\n        ['a', 'b', 'c', 'd', 'a']\n\n    The items in *iterable* must be hashable.\n\n    \"\"\"\n    if n <= 0:\n        raise ValueError('n must be greater than 0')\n\n    window = deque(maxlen=n)\n    counts = defaultdict(int)\n    use_key = key is not None\n\n    for item in iterable:\n        if len(window) == n:\n            to_discard = window[0]\n            if counts[to_discard] == 1:\n                del counts[to_discard]\n            else:\n                counts[to_discard] -= 1\n\n        k = key(item) if use_key else item\n        if k not in counts:\n            yield item\n        counts[k] += 1\n        window.append(k)\n\n\ndef duplicates_everseen(iterable, key=None):\n    \"\"\"Yield duplicate elements after their first appearance.\n\n    >>> list(duplicates_everseen('mississippi'))\n    ['s', 'i', 's', 's', 'i', 'p', 'i']\n    >>> list(duplicates_everseen('AaaBbbCccAaa', str.lower))\n    ['a', 'a', 'b', 'b', 'c', 'c', 'A', 'a', 'a']\n\n    This function is analogous to :func:`unique_everseen` and is subject to\n    the same performance considerations.\n\n    \"\"\"\n    seen_set = set()\n    seen_list = []\n    use_key = key is not None\n\n    for element in iterable:\n        k = key(element) if use_key else element\n        try:\n            if k not in seen_set:\n                seen_set.add(k)\n            else:\n                yield element\n        except TypeError:\n            if k not in seen_list:\n                seen_list.append(k)\n            else:\n                yield element\n\n\ndef duplicates_justseen(iterable, key=None):\n    \"\"\"Yields serially-duplicate elements after their first appearance.\n\n    >>> list(duplicates_justseen('mississippi'))\n    ['s', 's', 'p']\n    >>> list(duplicates_justseen('AaaBbbCccAaa', str.lower))\n    ['a', 'a', 'b', 'b', 'c', 'c', 'a', 'a']\n\n    This function is analogous to :func:`unique_justseen`.\n\n    \"\"\"\n    return flatten(g for _, g in groupby(iterable, key) for _ in g)\n\n\ndef classify_unique(iterable, key=None):\n    \"\"\"Classify each element in terms of its uniqueness.\n\n    For each element in the input iterable, return a 3-tuple consisting of:\n\n    1. The element itself\n    2. ``False`` if the element is equal to the one preceding it in the input,\n       ``True`` otherwise (i.e. the equivalent of :func:`unique_justseen`)\n    3. ``False`` if this element has been seen anywhere in the input before,\n       ``True`` otherwise (i.e. the equivalent of :func:`unique_everseen`)\n\n    >>> list(classify_unique('otto'))    # doctest: +NORMALIZE_WHITESPACE\n    [('o', True,  True),\n     ('t', True,  True),\n     ('t', False, False),\n     ('o', True,  False)]\n\n    This function is analogous to :func:`unique_everseen` and is subject to\n    the same performance considerations.\n\n    \"\"\"\n    seen_set = set()\n    seen_list = []\n    use_key = key is not None\n    previous = None\n\n    for i, element in enumerate(iterable):\n        k = key(element) if use_key else element\n        is_unique_justseen = not i or previous != k\n        previous = k\n        is_unique_everseen = False\n        try:\n            if k not in seen_set:\n                seen_set.add(k)\n                is_unique_everseen = True\n        except TypeError:\n            if k not in seen_list:\n                seen_list.append(k)\n                is_unique_everseen = True\n        yield element, is_unique_justseen, is_unique_everseen\n\n\ndef minmax(iterable_or_value, *others, key=None, default=_marker):\n    \"\"\"Returns both the smallest and largest items in an iterable\n    or the largest of two or more arguments.\n\n        >>> minmax([3, 1, 5])\n        (1, 5)\n\n        >>> minmax(4, 2, 6)\n        (2, 6)\n\n    If a *key* function is provided, it will be used to transform the input\n    items for comparison.\n\n        >>> minmax([5, 30], key=str)  # '30' sorts before '5'\n        (30, 5)\n\n    If a *default* value is provided, it will be returned if there are no\n    input items.\n\n        >>> minmax([], default=(0, 0))\n        (0, 0)\n\n    Otherwise ``ValueError`` is raised.\n\n    This function is based on the\n    `recipe <http://code.activestate.com/recipes/577916/>`__ by\n    Raymond Hettinger and takes care to minimize the number of comparisons\n    performed.\n    \"\"\"\n    iterable = (iterable_or_value, *others) if others else iterable_or_value\n\n    it = iter(iterable)\n\n    try:\n        lo = hi = next(it)\n    except StopIteration as exc:\n        if default is _marker:\n            raise ValueError(\n                '`minmax()` argument is an empty iterable. '\n                'Provide a `default` value to suppress this error.'\n            ) from exc\n        return default\n\n    # Different branches depending on the presence of key. This saves a lot\n    # of unimportant copies which would slow the \"key=None\" branch\n    # significantly down.\n    if key is None:\n        for x, y in zip_longest(it, it, fillvalue=lo):\n            if y < x:\n                x, y = y, x\n            if x < lo:\n                lo = x\n            if hi < y:\n                hi = y\n\n    else:\n        lo_key = hi_key = key(lo)\n\n        for x, y in zip_longest(it, it, fillvalue=lo):\n            x_key, y_key = key(x), key(y)\n\n            if y_key < x_key:\n                x, y, x_key, y_key = y, x, y_key, x_key\n            if x_key < lo_key:\n                lo, lo_key = x, x_key\n            if hi_key < y_key:\n                hi, hi_key = y, y_key\n\n    return lo, hi\n\n\ndef constrained_batches(\n    iterable, max_size, max_count=None, get_len=len, strict=True\n):\n    \"\"\"Yield batches of items from *iterable* with a combined size limited by\n    *max_size*.\n\n    >>> iterable = [b'12345', b'123', b'12345678', b'1', b'1', b'12', b'1']\n    >>> list(constrained_batches(iterable, 10))\n    [(b'12345', b'123'), (b'12345678', b'1', b'1'), (b'12', b'1')]\n\n    If a *max_count* is supplied, the number of items per batch is also\n    limited:\n\n    >>> iterable = [b'12345', b'123', b'12345678', b'1', b'1', b'12', b'1']\n    >>> list(constrained_batches(iterable, 10, max_count = 2))\n    [(b'12345', b'123'), (b'12345678', b'1'), (b'1', b'12'), (b'1',)]\n\n    If a *get_len* function is supplied, use that instead of :func:`len` to\n    determine item size.\n\n    If *strict* is ``True``, raise ``ValueError`` if any single item is bigger\n    than *max_size*. Otherwise, allow single items to exceed *max_size*.\n    \"\"\"\n    if max_size <= 0:\n        raise ValueError('maximum size must be greater than zero')\n\n    batch = []\n    batch_size = 0\n    batch_count = 0\n    for item in iterable:\n        item_len = get_len(item)\n        if strict and item_len > max_size:\n            raise ValueError('item size exceeds maximum size')\n\n        reached_count = batch_count == max_count\n        reached_size = item_len + batch_size > max_size\n        if batch_count and (reached_size or reached_count):\n            yield tuple(batch)\n            batch.clear()\n            batch_size = 0\n            batch_count = 0\n\n        batch.append(item)\n        batch_size += item_len\n        batch_count += 1\n\n    if batch:\n        yield tuple(batch)\n\n\ndef gray_product(*iterables):\n    \"\"\"Like :func:`itertools.product`, but return tuples in an order such\n    that only one element in the generated tuple changes from one iteration\n    to the next.\n\n        >>> list(gray_product('AB','CD'))\n        [('A', 'C'), ('B', 'C'), ('B', 'D'), ('A', 'D')]\n\n    This function consumes all of the input iterables before producing output.\n    If any of the input iterables have fewer than two items, ``ValueError``\n    is raised.\n\n    For information on the algorithm, see\n    `this section <https://www-cs-faculty.stanford.edu/~knuth/fasc2a.ps.gz>`__\n    of Donald Knuth's *The Art of Computer Programming*.\n    \"\"\"\n    all_iterables = tuple(tuple(x) for x in iterables)\n    iterable_count = len(all_iterables)\n    for iterable in all_iterables:\n        if len(iterable) < 2:\n            raise ValueError(\"each iterable must have two or more items\")\n\n    # This is based on \"Algorithm H\" from section 7.2.1.1, page 20.\n    # a holds the indexes of the source iterables for the n-tuple to be yielded\n    # f is the array of \"focus pointers\"\n    # o is the array of \"directions\"\n    a = [0] * iterable_count\n    f = list(range(iterable_count + 1))\n    o = [1] * iterable_count\n    while True:\n        yield tuple(all_iterables[i][a[i]] for i in range(iterable_count))\n        j = f[0]\n        f[0] = 0\n        if j == iterable_count:\n            break\n        a[j] = a[j] + o[j]\n        if a[j] == 0 or a[j] == len(all_iterables[j]) - 1:\n            o[j] = -o[j]\n            f[j] = f[j + 1]\n            f[j + 1] = j + 1\n\n\ndef partial_product(*iterables):\n    \"\"\"Yields tuples containing one item from each iterator, with subsequent\n    tuples changing a single item at a time by advancing each iterator until it\n    is exhausted. This sequence guarantees every value in each iterable is\n    output at least once without generating all possible combinations.\n\n    This may be useful, for example, when testing an expensive function.\n\n        >>> list(partial_product('AB', 'C', 'DEF'))\n        [('A', 'C', 'D'), ('B', 'C', 'D'), ('B', 'C', 'E'), ('B', 'C', 'F')]\n    \"\"\"\n\n    iterators = list(map(iter, iterables))\n\n    try:\n        prod = [next(it) for it in iterators]\n    except StopIteration:\n        return\n    yield tuple(prod)\n\n    for i, it in enumerate(iterators):\n        for prod[i] in it:\n            yield tuple(prod)\n\n\ndef takewhile_inclusive(predicate, iterable):\n    \"\"\"A variant of :func:`takewhile` that yields one additional element.\n\n        >>> list(takewhile_inclusive(lambda x: x < 5, [1, 4, 6, 4, 1]))\n        [1, 4, 6]\n\n    :func:`takewhile` would return ``[1, 4]``.\n    \"\"\"\n    for x in iterable:\n        yield x\n        if not predicate(x):\n            break\n\n\ndef outer_product(func, xs, ys, *args, **kwargs):\n    \"\"\"A generalized outer product that applies a binary function to all\n    pairs of items. Returns a 2D matrix with ``len(xs)`` rows and ``len(ys)``\n    columns.\n    Also accepts ``*args`` and ``**kwargs`` that are passed to ``func``.\n\n    Multiplication table:\n\n    >>> list(outer_product(mul, range(1, 4), range(1, 6)))\n    [(1, 2, 3, 4, 5), (2, 4, 6, 8, 10), (3, 6, 9, 12, 15)]\n\n    Cross tabulation:\n\n    >>> xs = ['A', 'B', 'A', 'A', 'B', 'B', 'A', 'A', 'B', 'B']\n    >>> ys = ['X', 'X', 'X', 'Y', 'Z', 'Z', 'Y', 'Y', 'Z', 'Z']\n    >>> rows = list(zip(xs, ys))\n    >>> count_rows = lambda x, y: rows.count((x, y))\n    >>> list(outer_product(count_rows, sorted(set(xs)), sorted(set(ys))))\n    [(2, 3, 0), (1, 0, 4)]\n\n    Usage with ``*args`` and ``**kwargs``:\n\n    >>> animals = ['cat', 'wolf', 'mouse']\n    >>> list(outer_product(min, animals, animals, key=len))\n    [('cat', 'cat', 'cat'), ('cat', 'wolf', 'wolf'), ('cat', 'wolf', 'mouse')]\n    \"\"\"\n    ys = tuple(ys)\n    return batched(\n        starmap(lambda x, y: func(x, y, *args, **kwargs), product(xs, ys)),\n        n=len(ys),\n    )\n\n\ndef iter_suppress(iterable, *exceptions):\n    \"\"\"Yield each of the items from *iterable*. If the iteration raises one of\n    the specified *exceptions*, that exception will be suppressed and iteration\n    will stop.\n\n    >>> from itertools import chain\n    >>> def breaks_at_five(x):\n    ...     while True:\n    ...         if x >= 5:\n    ...             raise RuntimeError\n    ...         yield x\n    ...         x += 1\n    >>> it_1 = iter_suppress(breaks_at_five(1), RuntimeError)\n    >>> it_2 = iter_suppress(breaks_at_five(2), RuntimeError)\n    >>> list(chain(it_1, it_2))\n    [1, 2, 3, 4, 2, 3, 4]\n    \"\"\"\n    try:\n        yield from iterable\n    except exceptions:\n        return\n\n\ndef filter_map(func, iterable):\n    \"\"\"Apply *func* to every element of *iterable*, yielding only those which\n    are not ``None``.\n\n    >>> elems = ['1', 'a', '2', 'b', '3']\n    >>> list(filter_map(lambda s: int(s) if s.isnumeric() else None, elems))\n    [1, 2, 3]\n    \"\"\"\n    for x in iterable:\n        y = func(x)\n        if y is not None:\n            yield y\n\n\ndef powerset_of_sets(iterable):\n    \"\"\"Yields all possible subsets of the iterable.\n\n        >>> list(powerset_of_sets([1, 2, 3]))  # doctest: +SKIP\n        [set(), {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}]\n        >>> list(powerset_of_sets([1, 1, 0]))  # doctest: +SKIP\n        [set(), {1}, {0}, {0, 1}]\n\n    :func:`powerset_of_sets` takes care to minimize the number\n    of hash operations performed.\n    \"\"\"\n    sets = tuple(map(set, dict.fromkeys(map(frozenset, zip(iterable)))))\n    for r in range(len(sets) + 1):\n        yield from starmap(set().union, combinations(sets, r))\n\n\ndef join_mappings(**field_to_map):\n    \"\"\"\n    Joins multiple mappings together using their common keys.\n\n    >>> user_scores = {'elliot': 50, 'claris': 60}\n    >>> user_times = {'elliot': 30, 'claris': 40}\n    >>> join_mappings(score=user_scores, time=user_times)\n    {'elliot': {'score': 50, 'time': 30}, 'claris': {'score': 60, 'time': 40}}\n    \"\"\"\n    ret = defaultdict(dict)\n\n    for field_name, mapping in field_to_map.items():\n        for key, value in mapping.items():\n            ret[key][field_name] = value\n\n    return dict(ret)\n\n\ndef _complex_sumprod(v1, v2):\n    \"\"\"High precision sumprod() for complex numbers.\n    Used by :func:`dft` and :func:`idft`.\n    \"\"\"\n\n    r1 = chain((p.real for p in v1), (-p.imag for p in v1))\n    r2 = chain((q.real for q in v2), (q.imag for q in v2))\n    i1 = chain((p.real for p in v1), (p.imag for p in v1))\n    i2 = chain((q.imag for q in v2), (q.real for q in v2))\n    return complex(_fsumprod(r1, r2), _fsumprod(i1, i2))\n\n\ndef dft(xarr):\n    \"\"\"Discrete Fourier Tranform. *xarr* is a sequence of complex numbers.\n    Yields the components of the corresponding transformed output vector.\n\n    >>> import cmath\n    >>> xarr = [1, 2-1j, -1j, -1+2j]\n    >>> Xarr = [2, -2-2j, -2j, 4+4j]\n    >>> all(map(cmath.isclose, dft(xarr), Xarr))\n    True\n\n    See :func:`idft` for the inverse Discrete Fourier Transform.\n    \"\"\"\n    N = len(xarr)\n    roots_of_unity = [e ** (n / N * tau * -1j) for n in range(N)]\n    for k in range(N):\n        coeffs = [roots_of_unity[k * n % N] for n in range(N)]\n        yield _complex_sumprod(xarr, coeffs)\n\n\ndef idft(Xarr):\n    \"\"\"Inverse Discrete Fourier Tranform. *Xarr* is a sequence of\n    complex numbers. Yields the components of the corresponding\n    inverse-transformed output vector.\n\n    >>> import cmath\n    >>> xarr = [1, 2-1j, -1j, -1+2j]\n    >>> Xarr = [2, -2-2j, -2j, 4+4j]\n    >>> all(map(cmath.isclose, idft(Xarr), xarr))\n    True\n\n    See :func:`dft` for the Discrete Fourier Transform.\n    \"\"\"\n    N = len(Xarr)\n    roots_of_unity = [e ** (n / N * tau * 1j) for n in range(N)]\n    for k in range(N):\n        coeffs = [roots_of_unity[k * n % N] for n in range(N)]\n        yield _complex_sumprod(Xarr, coeffs) / N\n\n\ndef doublestarmap(func, iterable):\n    \"\"\"Apply *func* to every item of *iterable* by dictionary unpacking\n    the item into *func*.\n\n    The difference between :func:`itertools.starmap` and :func:`doublestarmap`\n    parallels the distinction between ``func(*a)`` and ``func(**a)``.\n\n    >>> iterable = [{'a': 1, 'b': 2}, {'a': 40, 'b': 60}]\n    >>> list(doublestarmap(lambda a, b: a + b, iterable))\n    [3, 100]\n\n    ``TypeError`` will be raised if *func*'s signature doesn't match the\n    mapping contained in *iterable* or if *iterable* does not contain mappings.\n    \"\"\"\n    for item in iterable:\n        yield func(**item)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/more_itertools/recipes.py","size":28591,"sha1":"4a54d1832b8e2923925f0ac0e1085f53e8c40df7","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Imported from the recipes section of the itertools documentation.\n\nAll functions taken from the recipes section of the itertools library docs\n[1]_.\nSome backward-compatible usability improvements have been made.\n\n.. [1] http://docs.python.org/library/itertools.html#recipes\n\n\"\"\"\n\nimport math\nimport operator\n\nfrom collections import deque\nfrom collections.abc import Sized\nfrom functools import partial, reduce\nfrom itertools import (\n    chain,\n    combinations,\n    compress,\n    count,\n    cycle,\n    groupby,\n    islice,\n    product,\n    repeat,\n    starmap,\n    tee,\n    zip_longest,\n)\nfrom random import randrange, sample, choice\nfrom sys import hexversion\n\n__all__ = [\n    'all_equal',\n    'batched',\n    'before_and_after',\n    'consume',\n    'convolve',\n    'dotproduct',\n    'first_true',\n    'factor',\n    'flatten',\n    'grouper',\n    'iter_except',\n    'iter_index',\n    'matmul',\n    'ncycles',\n    'nth',\n    'nth_combination',\n    'padnone',\n    'pad_none',\n    'pairwise',\n    'partition',\n    'polynomial_eval',\n    'polynomial_from_roots',\n    'polynomial_derivative',\n    'powerset',\n    'prepend',\n    'quantify',\n    'reshape',\n    'random_combination_with_replacement',\n    'random_combination',\n    'random_permutation',\n    'random_product',\n    'repeatfunc',\n    'roundrobin',\n    'sieve',\n    'sliding_window',\n    'subslices',\n    'sum_of_squares',\n    'tabulate',\n    'tail',\n    'take',\n    'totient',\n    'transpose',\n    'triplewise',\n    'unique',\n    'unique_everseen',\n    'unique_justseen',\n]\n\n_marker = object()\n\n\n# zip with strict is available for Python 3.10+\ntry:\n    zip(strict=True)\nexcept TypeError:\n    _zip_strict = zip\nelse:\n    _zip_strict = partial(zip, strict=True)\n\n# math.sumprod is available for Python 3.12+\n_sumprod = getattr(math, 'sumprod', lambda x, y: dotproduct(x, y))\n\n\ndef take(n, iterable):\n    \"\"\"Return first *n* items of the iterable as a list.\n\n        >>> take(3, range(10))\n        [0, 1, 2]\n\n    If there are fewer than *n* items in the iterable, all of them are\n    returned.\n\n        >>> take(10, range(3))\n        [0, 1, 2]\n\n    \"\"\"\n    return list(islice(iterable, n))\n\n\ndef tabulate(function, start=0):\n    \"\"\"Return an iterator over the results of ``func(start)``,\n    ``func(start + 1)``, ``func(start + 2)``...\n\n    *func* should be a function that accepts one integer argument.\n\n    If *start* is not specified it defaults to 0. It will be incremented each\n    time the iterator is advanced.\n\n        >>> square = lambda x: x ** 2\n        >>> iterator = tabulate(square, -3)\n        >>> take(4, iterator)\n        [9, 4, 1, 0]\n\n    \"\"\"\n    return map(function, count(start))\n\n\ndef tail(n, iterable):\n    \"\"\"Return an iterator over the last *n* items of *iterable*.\n\n    >>> t = tail(3, 'ABCDEFG')\n    >>> list(t)\n    ['E', 'F', 'G']\n\n    \"\"\"\n    # If the given iterable has a length, then we can use islice to get its\n    # final elements. Note that if the iterable is not actually Iterable,\n    # either islice or deque will throw a TypeError. This is why we don't\n    # check if it is Iterable.\n    if isinstance(iterable, Sized):\n        yield from islice(iterable, max(0, len(iterable) - n), None)\n    else:\n        yield from iter(deque(iterable, maxlen=n))\n\n\ndef consume(iterator, n=None):\n    \"\"\"Advance *iterable* by *n* steps. If *n* is ``None``, consume it\n    entirely.\n\n    Efficiently exhausts an iterator without returning values. Defaults to\n    consuming the whole iterator, but an optional second argument may be\n    provided to limit consumption.\n\n        >>> i = (x for x in range(10))\n        >>> next(i)\n        0\n        >>> consume(i, 3)\n        >>> next(i)\n        4\n        >>> consume(i)\n        >>> next(i)\n        Traceback (most recent call last):\n          File \"<stdin>\", line 1, in <module>\n        StopIteration\n\n    If the iterator has fewer items remaining than the provided limit, the\n    whole iterator will be consumed.\n\n        >>> i = (x for x in range(3))\n        >>> consume(i, 5)\n        >>> next(i)\n        Traceback (most recent call last):\n          File \"<stdin>\", line 1, in <module>\n        StopIteration\n\n    \"\"\"\n    # Use functions that consume iterators at C speed.\n    if n is None:\n        # feed the entire iterator into a zero-length deque\n        deque(iterator, maxlen=0)\n    else:\n        # advance to the empty slice starting at position n\n        next(islice(iterator, n, n), None)\n\n\ndef nth(iterable, n, default=None):\n    \"\"\"Returns the nth item or a default value.\n\n    >>> l = range(10)\n    >>> nth(l, 3)\n    3\n    >>> nth(l, 20, \"zebra\")\n    'zebra'\n\n    \"\"\"\n    return next(islice(iterable, n, None), default)\n\n\ndef all_equal(iterable, key=None):\n    \"\"\"\n    Returns ``True`` if all the elements are equal to each other.\n\n        >>> all_equal('aaaa')\n        True\n        >>> all_equal('aaab')\n        False\n\n    A function that accepts a single argument and returns a transformed version\n    of each input item can be specified with *key*:\n\n        >>> all_equal('AaaA', key=str.casefold)\n        True\n        >>> all_equal([1, 2, 3], key=lambda x: x < 10)\n        True\n\n    \"\"\"\n    return len(list(islice(groupby(iterable, key), 2))) <= 1\n\n\ndef quantify(iterable, pred=bool):\n    \"\"\"Return the how many times the predicate is true.\n\n    >>> quantify([True, False, True])\n    2\n\n    \"\"\"\n    return sum(map(pred, iterable))\n\n\ndef pad_none(iterable):\n    \"\"\"Returns the sequence of elements and then returns ``None`` indefinitely.\n\n        >>> take(5, pad_none(range(3)))\n        [0, 1, 2, None, None]\n\n    Useful for emulating the behavior of the built-in :func:`map` function.\n\n    See also :func:`padded`.\n\n    \"\"\"\n    return chain(iterable, repeat(None))\n\n\npadnone = pad_none\n\n\ndef ncycles(iterable, n):\n    \"\"\"Returns the sequence elements *n* times\n\n    >>> list(ncycles([\"a\", \"b\"], 3))\n    ['a', 'b', 'a', 'b', 'a', 'b']\n\n    \"\"\"\n    return chain.from_iterable(repeat(tuple(iterable), n))\n\n\ndef dotproduct(vec1, vec2):\n    \"\"\"Returns the dot product of the two iterables.\n\n    >>> dotproduct([10, 10], [20, 20])\n    400\n\n    \"\"\"\n    return sum(map(operator.mul, vec1, vec2))\n\n\ndef flatten(listOfLists):\n    \"\"\"Return an iterator flattening one level of nesting in a list of lists.\n\n        >>> list(flatten([[0, 1], [2, 3]]))\n        [0, 1, 2, 3]\n\n    See also :func:`collapse`, which can flatten multiple levels of nesting.\n\n    \"\"\"\n    return chain.from_iterable(listOfLists)\n\n\ndef repeatfunc(func, times=None, *args):\n    \"\"\"Call *func* with *args* repeatedly, returning an iterable over the\n    results.\n\n    If *times* is specified, the iterable will terminate after that many\n    repetitions:\n\n        >>> from operator import add\n        >>> times = 4\n        >>> args = 3, 5\n        >>> list(repeatfunc(add, times, *args))\n        [8, 8, 8, 8]\n\n    If *times* is ``None`` the iterable will not terminate:\n\n        >>> from random import randrange\n        >>> times = None\n        >>> args = 1, 11\n        >>> take(6, repeatfunc(randrange, times, *args))  # doctest:+SKIP\n        [2, 4, 8, 1, 8, 4]\n\n    \"\"\"\n    if times is None:\n        return starmap(func, repeat(args))\n    return starmap(func, repeat(args, times))\n\n\ndef _pairwise(iterable):\n    \"\"\"Returns an iterator of paired items, overlapping, from the original\n\n    >>> take(4, pairwise(count()))\n    [(0, 1), (1, 2), (2, 3), (3, 4)]\n\n    On Python 3.10 and above, this is an alias for :func:`itertools.pairwise`.\n\n    \"\"\"\n    a, b = tee(iterable)\n    next(b, None)\n    return zip(a, b)\n\n\ntry:\n    from itertools import pairwise as itertools_pairwise\nexcept ImportError:\n    pairwise = _pairwise\nelse:\n\n    def pairwise(iterable):\n        return itertools_pairwise(iterable)\n\n    pairwise.__doc__ = _pairwise.__doc__\n\n\nclass UnequalIterablesError(ValueError):\n    def __init__(self, details=None):\n        msg = 'Iterables have different lengths'\n        if details is not None:\n            msg += (': index 0 has length {}; index {} has length {}').format(\n                *details\n            )\n\n        super().__init__(msg)\n\n\ndef _zip_equal_generator(iterables):\n    for combo in zip_longest(*iterables, fillvalue=_marker):\n        for val in combo:\n            if val is _marker:\n                raise UnequalIterablesError()\n        yield combo\n\n\ndef _zip_equal(*iterables):\n    # Check whether the iterables are all the same size.\n    try:\n        first_size = len(iterables[0])\n        for i, it in enumerate(iterables[1:], 1):\n            size = len(it)\n            if size != first_size:\n                raise UnequalIterablesError(details=(first_size, i, size))\n        # All sizes are equal, we can use the built-in zip.\n        return zip(*iterables)\n    # If any one of the iterables didn't have a length, start reading\n    # them until one runs out.\n    except TypeError:\n        return _zip_equal_generator(iterables)\n\n\ndef grouper(iterable, n, incomplete='fill', fillvalue=None):\n    \"\"\"Group elements from *iterable* into fixed-length groups of length *n*.\n\n    >>> list(grouper('ABCDEF', 3))\n    [('A', 'B', 'C'), ('D', 'E', 'F')]\n\n    The keyword arguments *incomplete* and *fillvalue* control what happens for\n    iterables whose length is not a multiple of *n*.\n\n    When *incomplete* is `'fill'`, the last group will contain instances of\n    *fillvalue*.\n\n    >>> list(grouper('ABCDEFG', 3, incomplete='fill', fillvalue='x'))\n    [('A', 'B', 'C'), ('D', 'E', 'F'), ('G', 'x', 'x')]\n\n    When *incomplete* is `'ignore'`, the last group will not be emitted.\n\n    >>> list(grouper('ABCDEFG', 3, incomplete='ignore', fillvalue='x'))\n    [('A', 'B', 'C'), ('D', 'E', 'F')]\n\n    When *incomplete* is `'strict'`, a subclass of `ValueError` will be raised.\n\n    >>> it = grouper('ABCDEFG', 3, incomplete='strict')\n    >>> list(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    UnequalIterablesError\n\n    \"\"\"\n    args = [iter(iterable)] * n\n    if incomplete == 'fill':\n        return zip_longest(*args, fillvalue=fillvalue)\n    if incomplete == 'strict':\n        return _zip_equal(*args)\n    if incomplete == 'ignore':\n        return zip(*args)\n    else:\n        raise ValueError('Expected fill, strict, or ignore')\n\n\ndef roundrobin(*iterables):\n    \"\"\"Yields an item from each iterable, alternating between them.\n\n        >>> list(roundrobin('ABC', 'D', 'EF'))\n        ['A', 'D', 'E', 'B', 'F', 'C']\n\n    This function produces the same output as :func:`interleave_longest`, but\n    may perform better for some inputs (in particular when the number of\n    iterables is small).\n\n    \"\"\"\n    # Algorithm credited to George Sakkis\n    iterators = map(iter, iterables)\n    for num_active in range(len(iterables), 0, -1):\n        iterators = cycle(islice(iterators, num_active))\n        yield from map(next, iterators)\n\n\ndef partition(pred, iterable):\n    \"\"\"\n    Returns a 2-tuple of iterables derived from the input iterable.\n    The first yields the items that have ``pred(item) == False``.\n    The second yields the items that have ``pred(item) == True``.\n\n        >>> is_odd = lambda x: x % 2 != 0\n        >>> iterable = range(10)\n        >>> even_items, odd_items = partition(is_odd, iterable)\n        >>> list(even_items), list(odd_items)\n        ([0, 2, 4, 6, 8], [1, 3, 5, 7, 9])\n\n    If *pred* is None, :func:`bool` is used.\n\n        >>> iterable = [0, 1, False, True, '', ' ']\n        >>> false_items, true_items = partition(None, iterable)\n        >>> list(false_items), list(true_items)\n        ([0, False, ''], [1, True, ' '])\n\n    \"\"\"\n    if pred is None:\n        pred = bool\n\n    t1, t2, p = tee(iterable, 3)\n    p1, p2 = tee(map(pred, p))\n    return (compress(t1, map(operator.not_, p1)), compress(t2, p2))\n\n\ndef powerset(iterable):\n    \"\"\"Yields all possible subsets of the iterable.\n\n        >>> list(powerset([1, 2, 3]))\n        [(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]\n\n    :func:`powerset` will operate on iterables that aren't :class:`set`\n    instances, so repeated elements in the input will produce repeated elements\n    in the output.\n\n        >>> seq = [1, 1, 0]\n        >>> list(powerset(seq))\n        [(), (1,), (1,), (0,), (1, 1), (1, 0), (1, 0), (1, 1, 0)]\n\n    For a variant that efficiently yields actual :class:`set` instances, see\n    :func:`powerset_of_sets`.\n    \"\"\"\n    s = list(iterable)\n    return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))\n\n\ndef unique_everseen(iterable, key=None):\n    \"\"\"\n    Yield unique elements, preserving order.\n\n        >>> list(unique_everseen('AAAABBBCCDAABBB'))\n        ['A', 'B', 'C', 'D']\n        >>> list(unique_everseen('ABBCcAD', str.lower))\n        ['A', 'B', 'C', 'D']\n\n    Sequences with a mix of hashable and unhashable items can be used.\n    The function will be slower (i.e., `O(n^2)`) for unhashable items.\n\n    Remember that ``list`` objects are unhashable - you can use the *key*\n    parameter to transform the list to a tuple (which is hashable) to\n    avoid a slowdown.\n\n        >>> iterable = ([1, 2], [2, 3], [1, 2])\n        >>> list(unique_everseen(iterable))  # Slow\n        [[1, 2], [2, 3]]\n        >>> list(unique_everseen(iterable, key=tuple))  # Faster\n        [[1, 2], [2, 3]]\n\n    Similarly, you may want to convert unhashable ``set`` objects with\n    ``key=frozenset``. For ``dict`` objects,\n    ``key=lambda x: frozenset(x.items())`` can be used.\n\n    \"\"\"\n    seenset = set()\n    seenset_add = seenset.add\n    seenlist = []\n    seenlist_add = seenlist.append\n    use_key = key is not None\n\n    for element in iterable:\n        k = key(element) if use_key else element\n        try:\n            if k not in seenset:\n                seenset_add(k)\n                yield element\n        except TypeError:\n            if k not in seenlist:\n                seenlist_add(k)\n                yield element\n\n\ndef unique_justseen(iterable, key=None):\n    \"\"\"Yields elements in order, ignoring serial duplicates\n\n    >>> list(unique_justseen('AAAABBBCCDAABBB'))\n    ['A', 'B', 'C', 'D', 'A', 'B']\n    >>> list(unique_justseen('ABBCcAD', str.lower))\n    ['A', 'B', 'C', 'A', 'D']\n\n    \"\"\"\n    if key is None:\n        return map(operator.itemgetter(0), groupby(iterable))\n\n    return map(next, map(operator.itemgetter(1), groupby(iterable, key)))\n\n\ndef unique(iterable, key=None, reverse=False):\n    \"\"\"Yields unique elements in sorted order.\n\n    >>> list(unique([[1, 2], [3, 4], [1, 2]]))\n    [[1, 2], [3, 4]]\n\n    *key* and *reverse* are passed to :func:`sorted`.\n\n    >>> list(unique('ABBcCAD', str.casefold))\n    ['A', 'B', 'c', 'D']\n    >>> list(unique('ABBcCAD', str.casefold, reverse=True))\n    ['D', 'c', 'B', 'A']\n\n    The elements in *iterable* need not be hashable, but they must be\n    comparable for sorting to work.\n    \"\"\"\n    return unique_justseen(sorted(iterable, key=key, reverse=reverse), key=key)\n\n\ndef iter_except(func, exception, first=None):\n    \"\"\"Yields results from a function repeatedly until an exception is raised.\n\n    Converts a call-until-exception interface to an iterator interface.\n    Like ``iter(func, sentinel)``, but uses an exception instead of a sentinel\n    to end the loop.\n\n        >>> l = [0, 1, 2]\n        >>> list(iter_except(l.pop, IndexError))\n        [2, 1, 0]\n\n    Multiple exceptions can be specified as a stopping condition:\n\n        >>> l = [1, 2, 3, '...', 4, 5, 6]\n        >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))\n        [7, 6, 5]\n        >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))\n        [4, 3, 2]\n        >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))\n        []\n\n    \"\"\"\n    try:\n        if first is not None:\n            yield first()\n        while 1:\n            yield func()\n    except exception:\n        pass\n\n\ndef first_true(iterable, default=None, pred=None):\n    \"\"\"\n    Returns the first true value in the iterable.\n\n    If no true value is found, returns *default*\n\n    If *pred* is not None, returns the first item for which\n    ``pred(item) == True`` .\n\n        >>> first_true(range(10))\n        1\n        >>> first_true(range(10), pred=lambda x: x > 5)\n        6\n        >>> first_true(range(10), default='missing', pred=lambda x: x > 9)\n        'missing'\n\n    \"\"\"\n    return next(filter(pred, iterable), default)\n\n\ndef random_product(*args, repeat=1):\n    \"\"\"Draw an item at random from each of the input iterables.\n\n        >>> random_product('abc', range(4), 'XYZ')  # doctest:+SKIP\n        ('c', 3, 'Z')\n\n    If *repeat* is provided as a keyword argument, that many items will be\n    drawn from each iterable.\n\n        >>> random_product('abcd', range(4), repeat=2)  # doctest:+SKIP\n        ('a', 2, 'd', 3)\n\n    This equivalent to taking a random selection from\n    ``itertools.product(*args, **kwarg)``.\n\n    \"\"\"\n    pools = [tuple(pool) for pool in args] * repeat\n    return tuple(choice(pool) for pool in pools)\n\n\ndef random_permutation(iterable, r=None):\n    \"\"\"Return a random *r* length permutation of the elements in *iterable*.\n\n    If *r* is not specified or is ``None``, then *r* defaults to the length of\n    *iterable*.\n\n        >>> random_permutation(range(5))  # doctest:+SKIP\n        (3, 4, 0, 1, 2)\n\n    This equivalent to taking a random selection from\n    ``itertools.permutations(iterable, r)``.\n\n    \"\"\"\n    pool = tuple(iterable)\n    r = len(pool) if r is None else r\n    return tuple(sample(pool, r))\n\n\ndef random_combination(iterable, r):\n    \"\"\"Return a random *r* length subsequence of the elements in *iterable*.\n\n        >>> random_combination(range(5), 3)  # doctest:+SKIP\n        (2, 3, 4)\n\n    This equivalent to taking a random selection from\n    ``itertools.combinations(iterable, r)``.\n\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    indices = sorted(sample(range(n), r))\n    return tuple(pool[i] for i in indices)\n\n\ndef random_combination_with_replacement(iterable, r):\n    \"\"\"Return a random *r* length subsequence of elements in *iterable*,\n    allowing individual elements to be repeated.\n\n        >>> random_combination_with_replacement(range(3), 5) # doctest:+SKIP\n        (0, 0, 1, 2, 2)\n\n    This equivalent to taking a random selection from\n    ``itertools.combinations_with_replacement(iterable, r)``.\n\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    indices = sorted(randrange(n) for i in range(r))\n    return tuple(pool[i] for i in indices)\n\n\ndef nth_combination(iterable, r, index):\n    \"\"\"Equivalent to ``list(combinations(iterable, r))[index]``.\n\n    The subsequences of *iterable* that are of length *r* can be ordered\n    lexicographically. :func:`nth_combination` computes the subsequence at\n    sort position *index* directly, without computing the previous\n    subsequences.\n\n        >>> nth_combination(range(5), 3, 5)\n        (0, 3, 4)\n\n    ``ValueError`` will be raised If *r* is negative or greater than the length\n    of *iterable*.\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    if (r < 0) or (r > n):\n        raise ValueError\n\n    c = 1\n    k = min(r, n - r)\n    for i in range(1, k + 1):\n        c = c * (n - k + i) // i\n\n    if index < 0:\n        index += c\n\n    if (index < 0) or (index >= c):\n        raise IndexError\n\n    result = []\n    while r:\n        c, n, r = c * r // n, n - 1, r - 1\n        while index >= c:\n            index -= c\n            c, n = c * (n - r) // n, n - 1\n        result.append(pool[-1 - n])\n\n    return tuple(result)\n\n\ndef prepend(value, iterator):\n    \"\"\"Yield *value*, followed by the elements in *iterator*.\n\n        >>> value = '0'\n        >>> iterator = ['1', '2', '3']\n        >>> list(prepend(value, iterator))\n        ['0', '1', '2', '3']\n\n    To prepend multiple values, see :func:`itertools.chain`\n    or :func:`value_chain`.\n\n    \"\"\"\n    return chain([value], iterator)\n\n\ndef convolve(signal, kernel):\n    \"\"\"Convolve the iterable *signal* with the iterable *kernel*.\n\n        >>> signal = (1, 2, 3, 4, 5)\n        >>> kernel = [3, 2, 1]\n        >>> list(convolve(signal, kernel))\n        [3, 8, 14, 20, 26, 14, 5]\n\n    Note: the input arguments are not interchangeable, as the *kernel*\n    is immediately consumed and stored.\n\n    \"\"\"\n    # This implementation intentionally doesn't match the one in the itertools\n    # documentation.\n    kernel = tuple(kernel)[::-1]\n    n = len(kernel)\n    window = deque([0], maxlen=n) * n\n    for x in chain(signal, repeat(0, n - 1)):\n        window.append(x)\n        yield _sumprod(kernel, window)\n\n\ndef before_and_after(predicate, it):\n    \"\"\"A variant of :func:`takewhile` that allows complete access to the\n    remainder of the iterator.\n\n         >>> it = iter('ABCdEfGhI')\n         >>> all_upper, remainder = before_and_after(str.isupper, it)\n         >>> ''.join(all_upper)\n         'ABC'\n         >>> ''.join(remainder) # takewhile() would lose the 'd'\n         'dEfGhI'\n\n    Note that the first iterator must be fully consumed before the second\n    iterator can generate valid results.\n    \"\"\"\n    it = iter(it)\n    transition = []\n\n    def true_iterator():\n        for elem in it:\n            if predicate(elem):\n                yield elem\n            else:\n                transition.append(elem)\n                return\n\n    # Note: this is different from itertools recipes to allow nesting\n    # before_and_after remainders into before_and_after again. See tests\n    # for an example.\n    remainder_iterator = chain(transition, it)\n\n    return true_iterator(), remainder_iterator\n\n\ndef triplewise(iterable):\n    \"\"\"Return overlapping triplets from *iterable*.\n\n    >>> list(triplewise('ABCDE'))\n    [('A', 'B', 'C'), ('B', 'C', 'D'), ('C', 'D', 'E')]\n\n    \"\"\"\n    for (a, _), (b, c) in pairwise(pairwise(iterable)):\n        yield a, b, c\n\n\ndef sliding_window(iterable, n):\n    \"\"\"Return a sliding window of width *n* over *iterable*.\n\n        >>> list(sliding_window(range(6), 4))\n        [(0, 1, 2, 3), (1, 2, 3, 4), (2, 3, 4, 5)]\n\n    If *iterable* has fewer than *n* items, then nothing is yielded:\n\n        >>> list(sliding_window(range(3), 4))\n        []\n\n    For a variant with more features, see :func:`windowed`.\n    \"\"\"\n    it = iter(iterable)\n    window = deque(islice(it, n - 1), maxlen=n)\n    for x in it:\n        window.append(x)\n        yield tuple(window)\n\n\ndef subslices(iterable):\n    \"\"\"Return all contiguous non-empty subslices of *iterable*.\n\n        >>> list(subslices('ABC'))\n        [['A'], ['A', 'B'], ['A', 'B', 'C'], ['B'], ['B', 'C'], ['C']]\n\n    This is similar to :func:`substrings`, but emits items in a different\n    order.\n    \"\"\"\n    seq = list(iterable)\n    slices = starmap(slice, combinations(range(len(seq) + 1), 2))\n    return map(operator.getitem, repeat(seq), slices)\n\n\ndef polynomial_from_roots(roots):\n    \"\"\"Compute a polynomial's coefficients from its roots.\n\n    >>> roots = [5, -4, 3]  # (x - 5) * (x + 4) * (x - 3)\n    >>> polynomial_from_roots(roots)  # x^3 - 4 * x^2 - 17 * x + 60\n    [1, -4, -17, 60]\n    \"\"\"\n    factors = zip(repeat(1), map(operator.neg, roots))\n    return list(reduce(convolve, factors, [1]))\n\n\ndef iter_index(iterable, value, start=0, stop=None):\n    \"\"\"Yield the index of each place in *iterable* that *value* occurs,\n    beginning with index *start* and ending before index *stop*.\n\n\n    >>> list(iter_index('AABCADEAF', 'A'))\n    [0, 1, 4, 7]\n    >>> list(iter_index('AABCADEAF', 'A', 1))  # start index is inclusive\n    [1, 4, 7]\n    >>> list(iter_index('AABCADEAF', 'A', 1, 7))  # stop index is not inclusive\n    [1, 4]\n\n    The behavior for non-scalar *values* matches the built-in Python types.\n\n    >>> list(iter_index('ABCDABCD', 'AB'))\n    [0, 4]\n    >>> list(iter_index([0, 1, 2, 3, 0, 1, 2, 3], [0, 1]))\n    []\n    >>> list(iter_index([[0, 1], [2, 3], [0, 1], [2, 3]], [0, 1]))\n    [0, 2]\n\n    See :func:`locate` for a more general means of finding the indexes\n    associated with particular values.\n\n    \"\"\"\n    seq_index = getattr(iterable, 'index', None)\n    if seq_index is None:\n        # Slow path for general iterables\n        it = islice(iterable, start, stop)\n        for i, element in enumerate(it, start):\n            if element is value or element == value:\n                yield i\n    else:\n        # Fast path for sequences\n        stop = len(iterable) if stop is None else stop\n        i = start - 1\n        try:\n            while True:\n                yield (i := seq_index(value, i + 1, stop))\n        except ValueError:\n            pass\n\n\ndef sieve(n):\n    \"\"\"Yield the primes less than n.\n\n    >>> list(sieve(30))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    \"\"\"\n    if n > 2:\n        yield 2\n    start = 3\n    data = bytearray((0, 1)) * (n // 2)\n    limit = math.isqrt(n) + 1\n    for p in iter_index(data, 1, start, limit):\n        yield from iter_index(data, 1, start, p * p)\n        data[p * p : n : p + p] = bytes(len(range(p * p, n, p + p)))\n        start = p * p\n    yield from iter_index(data, 1, start)\n\n\ndef _batched(iterable, n, *, strict=False):\n    \"\"\"Batch data into tuples of length *n*. If the number of items in\n    *iterable* is not divisible by *n*:\n    * The last batch will be shorter if *strict* is ``False``.\n    * :exc:`ValueError` will be raised if *strict* is ``True``.\n\n    >>> list(batched('ABCDEFG', 3))\n    [('A', 'B', 'C'), ('D', 'E', 'F'), ('G',)]\n\n    On Python 3.13 and above, this is an alias for :func:`itertools.batched`.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be at least one')\n    it = iter(iterable)\n    while batch := tuple(islice(it, n)):\n        if strict and len(batch) != n:\n            raise ValueError('batched(): incomplete batch')\n        yield batch\n\n\nif hexversion >= 0x30D00A2:\n    from itertools import batched as itertools_batched\n\n    def batched(iterable, n, *, strict=False):\n        return itertools_batched(iterable, n, strict=strict)\n\nelse:\n    batched = _batched\n\n    batched.__doc__ = _batched.__doc__\n\n\ndef transpose(it):\n    \"\"\"Swap the rows and columns of the input matrix.\n\n    >>> list(transpose([(1, 2, 3), (11, 22, 33)]))\n    [(1, 11), (2, 22), (3, 33)]\n\n    The caller should ensure that the dimensions of the input are compatible.\n    If the input is empty, no output will be produced.\n    \"\"\"\n    return _zip_strict(*it)\n\n\ndef reshape(matrix, cols):\n    \"\"\"Reshape the 2-D input *matrix* to have a column count given by *cols*.\n\n    >>> matrix = [(0, 1), (2, 3), (4, 5)]\n    >>> cols = 3\n    >>> list(reshape(matrix, cols))\n    [(0, 1, 2), (3, 4, 5)]\n    \"\"\"\n    return batched(chain.from_iterable(matrix), cols)\n\n\ndef matmul(m1, m2):\n    \"\"\"Multiply two matrices.\n\n    >>> list(matmul([(7, 5), (3, 5)], [(2, 5), (7, 9)]))\n    [(49, 80), (41, 60)]\n\n    The caller should ensure that the dimensions of the input matrices are\n    compatible with each other.\n    \"\"\"\n    n = len(m2[0])\n    return batched(starmap(_sumprod, product(m1, transpose(m2))), n)\n\n\ndef factor(n):\n    \"\"\"Yield the prime factors of n.\n\n    >>> list(factor(360))\n    [2, 2, 2, 3, 3, 5]\n    \"\"\"\n    for prime in sieve(math.isqrt(n) + 1):\n        while not n % prime:\n            yield prime\n            n //= prime\n            if n == 1:\n                return\n    if n > 1:\n        yield n\n\n\ndef polynomial_eval(coefficients, x):\n    \"\"\"Evaluate a polynomial at a specific value.\n\n    Example: evaluating x^3 - 4 * x^2 - 17 * x + 60 at x = 2.5:\n\n    >>> coefficients = [1, -4, -17, 60]\n    >>> x = 2.5\n    >>> polynomial_eval(coefficients, x)\n    8.125\n    \"\"\"\n    n = len(coefficients)\n    if n == 0:\n        return x * 0  # coerce zero to the type of x\n    powers = map(pow, repeat(x), reversed(range(n)))\n    return _sumprod(coefficients, powers)\n\n\ndef sum_of_squares(it):\n    \"\"\"Return the sum of the squares of the input values.\n\n    >>> sum_of_squares([10, 20, 30])\n    1400\n    \"\"\"\n    return _sumprod(*tee(it))\n\n\ndef polynomial_derivative(coefficients):\n    \"\"\"Compute the first derivative of a polynomial.\n\n    Example: evaluating the derivative of x^3 - 4 * x^2 - 17 * x + 60\n\n    >>> coefficients = [1, -4, -17, 60]\n    >>> derivative_coefficients = polynomial_derivative(coefficients)\n    >>> derivative_coefficients\n    [3, -8, -17]\n    \"\"\"\n    n = len(coefficients)\n    powers = reversed(range(1, n))\n    return list(map(operator.mul, coefficients, powers))\n\n\ndef totient(n):\n    \"\"\"Return the count of natural numbers up to *n* that are coprime with *n*.\n\n    >>> totient(9)\n    6\n    >>> totient(12)\n    4\n    \"\"\"\n    # The itertools docs use unique_justseen instead of set; see\n    # https://github.com/more-itertools/more-itertools/issues/823\n    for p in set(factor(n)):\n        n = n // p * (p - 1)\n\n    return n\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/packaging/__init__.py","size":494,"sha1":"50bac0ee902e35d450fe345de5d6c13f5517c687","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n__title__ = \"packaging\"\n__summary__ = \"Core utilities for Python packages\"\n__uri__ = \"https://github.com/pypa/packaging\"\n\n__version__ = \"24.2\"\n\n__author__ = \"Donald Stufft and individual contributors\"\n__email__ = \"donald@stufft.io\"\n\n__license__ = \"BSD-2-Clause or Apache-2.0\"\n__copyright__ = f\"2014 {__author__}\"\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/packaging/_elffile.py","size":3306,"sha1":"dc3c25ff49ee9eb6a37daad8fd6f6664768d7f5a","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nELF file parser.\n\nThis provides a class ``ELFFile`` that parses an ELF executable in a similar\ninterface to ``ZipFile``. Only the read interface is implemented.\n\nBased on: https://gist.github.com/lyssdod/f51579ae8d93c8657a5564aefc2ffbca\nELF header: https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html\n\"\"\"\n\nfrom __future__ import annotations\n\nimport enum\nimport os\nimport struct\nfrom typing import IO\n\n\nclass ELFInvalid(ValueError):\n    pass\n\n\nclass EIClass(enum.IntEnum):\n    C32 = 1\n    C64 = 2\n\n\nclass EIData(enum.IntEnum):\n    Lsb = 1\n    Msb = 2\n\n\nclass EMachine(enum.IntEnum):\n    I386 = 3\n    S390 = 22\n    Arm = 40\n    X8664 = 62\n    AArc64 = 183\n\n\nclass ELFFile:\n    \"\"\"\n    Representation of an ELF executable.\n    \"\"\"\n\n    def __init__(self, f: IO[bytes]) -> None:\n        self._f = f\n\n        try:\n            ident = self._read(\"16B\")\n        except struct.error as e:\n            raise ELFInvalid(\"unable to parse identification\") from e\n        magic = bytes(ident[:4])\n        if magic != b\"\\x7fELF\":\n            raise ELFInvalid(f\"invalid magic: {magic!r}\")\n\n        self.capacity = ident[4]  # Format for program header (bitness).\n        self.encoding = ident[5]  # Data structure encoding (endianness).\n\n        try:\n            # e_fmt: Format for program header.\n            # p_fmt: Format for section header.\n            # p_idx: Indexes to find p_type, p_offset, and p_filesz.\n            e_fmt, self._p_fmt, self._p_idx = {\n                (1, 1): (\"<HHIIIIIHHH\", \"<IIIIIIII\", (0, 1, 4)),  # 32-bit LSB.\n                (1, 2): (\">HHIIIIIHHH\", \">IIIIIIII\", (0, 1, 4)),  # 32-bit MSB.\n                (2, 1): (\"<HHIQQQIHHH\", \"<IIQQQQQQ\", (0, 2, 5)),  # 64-bit LSB.\n                (2, 2): (\">HHIQQQIHHH\", \">IIQQQQQQ\", (0, 2, 5)),  # 64-bit MSB.\n            }[(self.capacity, self.encoding)]\n        except KeyError as e:\n            raise ELFInvalid(\n                f\"unrecognized capacity ({self.capacity}) or \"\n                f\"encoding ({self.encoding})\"\n            ) from e\n\n        try:\n            (\n                _,\n                self.machine,  # Architecture type.\n                _,\n                _,\n                self._e_phoff,  # Offset of program header.\n                _,\n                self.flags,  # Processor-specific flags.\n                _,\n                self._e_phentsize,  # Size of section.\n                self._e_phnum,  # Number of sections.\n            ) = self._read(e_fmt)\n        except struct.error as e:\n            raise ELFInvalid(\"unable to parse machine and section information\") from e\n\n    def _read(self, fmt: str) -> tuple[int, ...]:\n        return struct.unpack(fmt, self._f.read(struct.calcsize(fmt)))\n\n    @property\n    def interpreter(self) -> str | None:\n        \"\"\"\n        The path recorded in the ``PT_INTERP`` section header.\n        \"\"\"\n        for index in range(self._e_phnum):\n            self._f.seek(self._e_phoff + self._e_phentsize * index)\n            try:\n                data = self._read(self._p_fmt)\n            except struct.error:\n                continue\n            if data[self._p_idx[0]] != 3:  # Not PT_INTERP.\n                continue\n            self._f.seek(data[self._p_idx[1]])\n            return os.fsdecode(self._f.read(data[self._p_idx[2]])).strip(\"\\0\")\n        return None\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/packaging/_manylinux.py","size":9612,"sha1":"b1eff66f27c5033317c724bd4b9ac57a0727f271","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport collections\nimport contextlib\nimport functools\nimport os\nimport re\nimport sys\nimport warnings\nfrom typing import Generator, Iterator, NamedTuple, Sequence\n\nfrom ._elffile import EIClass, EIData, ELFFile, EMachine\n\nEF_ARM_ABIMASK = 0xFF000000\nEF_ARM_ABI_VER5 = 0x05000000\nEF_ARM_ABI_FLOAT_HARD = 0x00000400\n\n\n# `os.PathLike` not a generic type until Python 3.9, so sticking with `str`\n# as the type for `path` until then.\n@contextlib.contextmanager\ndef _parse_elf(path: str) -> Generator[ELFFile | None, None, None]:\n    try:\n        with open(path, \"rb\") as f:\n            yield ELFFile(f)\n    except (OSError, TypeError, ValueError):\n        yield None\n\n\ndef _is_linux_armhf(executable: str) -> bool:\n    # hard-float ABI can be detected from the ELF header of the running\n    # process\n    # https://static.docs.arm.com/ihi0044/g/aaelf32.pdf\n    with _parse_elf(executable) as f:\n        return (\n            f is not None\n            and f.capacity == EIClass.C32\n            and f.encoding == EIData.Lsb\n            and f.machine == EMachine.Arm\n            and f.flags & EF_ARM_ABIMASK == EF_ARM_ABI_VER5\n            and f.flags & EF_ARM_ABI_FLOAT_HARD == EF_ARM_ABI_FLOAT_HARD\n        )\n\n\ndef _is_linux_i686(executable: str) -> bool:\n    with _parse_elf(executable) as f:\n        return (\n            f is not None\n            and f.capacity == EIClass.C32\n            and f.encoding == EIData.Lsb\n            and f.machine == EMachine.I386\n        )\n\n\ndef _have_compatible_abi(executable: str, archs: Sequence[str]) -> bool:\n    if \"armv7l\" in archs:\n        return _is_linux_armhf(executable)\n    if \"i686\" in archs:\n        return _is_linux_i686(executable)\n    allowed_archs = {\n        \"x86_64\",\n        \"aarch64\",\n        \"ppc64\",\n        \"ppc64le\",\n        \"s390x\",\n        \"loongarch64\",\n        \"riscv64\",\n    }\n    return any(arch in allowed_archs for arch in archs)\n\n\n# If glibc ever changes its major version, we need to know what the last\n# minor version was, so we can build the complete list of all versions.\n# For now, guess what the highest minor version might be, assume it will\n# be 50 for testing. Once this actually happens, update the dictionary\n# with the actual value.\n_LAST_GLIBC_MINOR: dict[int, int] = collections.defaultdict(lambda: 50)\n\n\nclass _GLibCVersion(NamedTuple):\n    major: int\n    minor: int\n\n\ndef _glibc_version_string_confstr() -> str | None:\n    \"\"\"\n    Primary implementation of glibc_version_string using os.confstr.\n    \"\"\"\n    # os.confstr is quite a bit faster than ctypes.DLL. It's also less likely\n    # to be broken or missing. This strategy is used in the standard library\n    # platform module.\n    # https://github.com/python/cpython/blob/fcf1d003bf4f0100c/Lib/platform.py#L175-L183\n    try:\n        # Should be a string like \"glibc 2.17\".\n        version_string: str | None = os.confstr(\"CS_GNU_LIBC_VERSION\")\n        assert version_string is not None\n        _, version = version_string.rsplit()\n    except (AssertionError, AttributeError, OSError, ValueError):\n        # os.confstr() or CS_GNU_LIBC_VERSION not available (or a bad value)...\n        return None\n    return version\n\n\ndef _glibc_version_string_ctypes() -> str | None:\n    \"\"\"\n    Fallback implementation of glibc_version_string using ctypes.\n    \"\"\"\n    try:\n        import ctypes\n    except ImportError:\n        return None\n\n    # ctypes.CDLL(None) internally calls dlopen(NULL), and as the dlopen\n    # manpage says, \"If filename is NULL, then the returned handle is for the\n    # main program\". This way we can let the linker do the work to figure out\n    # which libc our process is actually using.\n    #\n    # We must also handle the special case where the executable is not a\n    # dynamically linked executable. This can occur when using musl libc,\n    # for example. In this situation, dlopen() will error, leading to an\n    # OSError. Interestingly, at least in the case of musl, there is no\n    # errno set on the OSError. The single string argument used to construct\n    # OSError comes from libc itself and is therefore not portable to\n    # hard code here. In any case, failure to call dlopen() means we\n    # can proceed, so we bail on our attempt.\n    try:\n        process_namespace = ctypes.CDLL(None)\n    except OSError:\n        return None\n\n    try:\n        gnu_get_libc_version = process_namespace.gnu_get_libc_version\n    except AttributeError:\n        # Symbol doesn't exist -> therefore, we are not linked to\n        # glibc.\n        return None\n\n    # Call gnu_get_libc_version, which returns a string like \"2.5\"\n    gnu_get_libc_version.restype = ctypes.c_char_p\n    version_str: str = gnu_get_libc_version()\n    # py2 / py3 compatibility:\n    if not isinstance(version_str, str):\n        version_str = version_str.decode(\"ascii\")\n\n    return version_str\n\n\ndef _glibc_version_string() -> str | None:\n    \"\"\"Returns glibc version string, or None if not using glibc.\"\"\"\n    return _glibc_version_string_confstr() or _glibc_version_string_ctypes()\n\n\ndef _parse_glibc_version(version_str: str) -> tuple[int, int]:\n    \"\"\"Parse glibc version.\n\n    We use a regexp instead of str.split because we want to discard any\n    random junk that might come after the minor version -- this might happen\n    in patched/forked versions of glibc (e.g. Linaro's version of glibc\n    uses version strings like \"2.20-2014.11\"). See gh-3588.\n    \"\"\"\n    m = re.match(r\"(?P<major>[0-9]+)\\.(?P<minor>[0-9]+)\", version_str)\n    if not m:\n        warnings.warn(\n            f\"Expected glibc version with 2 components major.minor,\"\n            f\" got: {version_str}\",\n            RuntimeWarning,\n            stacklevel=2,\n        )\n        return -1, -1\n    return int(m.group(\"major\")), int(m.group(\"minor\"))\n\n\n@functools.lru_cache\ndef _get_glibc_version() -> tuple[int, int]:\n    version_str = _glibc_version_string()\n    if version_str is None:\n        return (-1, -1)\n    return _parse_glibc_version(version_str)\n\n\n# From PEP 513, PEP 600\ndef _is_compatible(arch: str, version: _GLibCVersion) -> bool:\n    sys_glibc = _get_glibc_version()\n    if sys_glibc < version:\n        return False\n    # Check for presence of _manylinux module.\n    try:\n        import _manylinux\n    except ImportError:\n        return True\n    if hasattr(_manylinux, \"manylinux_compatible\"):\n        result = _manylinux.manylinux_compatible(version[0], version[1], arch)\n        if result is not None:\n            return bool(result)\n        return True\n    if version == _GLibCVersion(2, 5):\n        if hasattr(_manylinux, \"manylinux1_compatible\"):\n            return bool(_manylinux.manylinux1_compatible)\n    if version == _GLibCVersion(2, 12):\n        if hasattr(_manylinux, \"manylinux2010_compatible\"):\n            return bool(_manylinux.manylinux2010_compatible)\n    if version == _GLibCVersion(2, 17):\n        if hasattr(_manylinux, \"manylinux2014_compatible\"):\n            return bool(_manylinux.manylinux2014_compatible)\n    return True\n\n\n_LEGACY_MANYLINUX_MAP = {\n    # CentOS 7 w/ glibc 2.17 (PEP 599)\n    (2, 17): \"manylinux2014\",\n    # CentOS 6 w/ glibc 2.12 (PEP 571)\n    (2, 12): \"manylinux2010\",\n    # CentOS 5 w/ glibc 2.5 (PEP 513)\n    (2, 5): \"manylinux1\",\n}\n\n\ndef platform_tags(archs: Sequence[str]) -> Iterator[str]:\n    \"\"\"Generate manylinux tags compatible to the current platform.\n\n    :param archs: Sequence of compatible architectures.\n        The first one shall be the closest to the actual architecture and be the part of\n        platform tag after the ``linux_`` prefix, e.g. ``x86_64``.\n        The ``linux_`` prefix is assumed as a prerequisite for the current platform to\n        be manylinux-compatible.\n\n    :returns: An iterator of compatible manylinux tags.\n    \"\"\"\n    if not _have_compatible_abi(sys.executable, archs):\n        return\n    # Oldest glibc to be supported regardless of architecture is (2, 17).\n    too_old_glibc2 = _GLibCVersion(2, 16)\n    if set(archs) & {\"x86_64\", \"i686\"}:\n        # On x86/i686 also oldest glibc to be supported is (2, 5).\n        too_old_glibc2 = _GLibCVersion(2, 4)\n    current_glibc = _GLibCVersion(*_get_glibc_version())\n    glibc_max_list = [current_glibc]\n    # We can assume compatibility across glibc major versions.\n    # https://sourceware.org/bugzilla/show_bug.cgi?id=24636\n    #\n    # Build a list of maximum glibc versions so that we can\n    # output the canonical list of all glibc from current_glibc\n    # down to too_old_glibc2, including all intermediary versions.\n    for glibc_major in range(current_glibc.major - 1, 1, -1):\n        glibc_minor = _LAST_GLIBC_MINOR[glibc_major]\n        glibc_max_list.append(_GLibCVersion(glibc_major, glibc_minor))\n    for arch in archs:\n        for glibc_max in glibc_max_list:\n            if glibc_max.major == too_old_glibc2.major:\n                min_minor = too_old_glibc2.minor\n            else:\n                # For other glibc major versions oldest supported is (x, 0).\n                min_minor = -1\n            for glibc_minor in range(glibc_max.minor, min_minor, -1):\n                glibc_version = _GLibCVersion(glibc_max.major, glibc_minor)\n                tag = \"manylinux_{}_{}\".format(*glibc_version)\n                if _is_compatible(arch, glibc_version):\n                    yield f\"{tag}_{arch}\"\n                # Handle the legacy manylinux1, manylinux2010, manylinux2014 tags.\n                if glibc_version in _LEGACY_MANYLINUX_MAP:\n                    legacy_tag = _LEGACY_MANYLINUX_MAP[glibc_version]\n                    if _is_compatible(arch, glibc_version):\n                        yield f\"{legacy_tag}_{arch}\"\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/packaging/_musllinux.py","size":2694,"sha1":"7d4819fd7cc78fa2acec97cdbd23939ff45f12b8","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"PEP 656 support.\n\nThis module implements logic to detect if the currently running Python is\nlinked against musl, and what musl version is used.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport functools\nimport re\nimport subprocess\nimport sys\nfrom typing import Iterator, NamedTuple, Sequence\n\nfrom ._elffile import ELFFile\n\n\nclass _MuslVersion(NamedTuple):\n    major: int\n    minor: int\n\n\ndef _parse_musl_version(output: str) -> _MuslVersion | None:\n    lines = [n for n in (n.strip() for n in output.splitlines()) if n]\n    if len(lines) < 2 or lines[0][:4] != \"musl\":\n        return None\n    m = re.match(r\"Version (\\d+)\\.(\\d+)\", lines[1])\n    if not m:\n        return None\n    return _MuslVersion(major=int(m.group(1)), minor=int(m.group(2)))\n\n\n@functools.lru_cache\ndef _get_musl_version(executable: str) -> _MuslVersion | None:\n    \"\"\"Detect currently-running musl runtime version.\n\n    This is done by checking the specified executable's dynamic linking\n    information, and invoking the loader to parse its output for a version\n    string. If the loader is musl, the output would be something like::\n\n        musl libc (x86_64)\n        Version 1.2.2\n        Dynamic Program Loader\n    \"\"\"\n    try:\n        with open(executable, \"rb\") as f:\n            ld = ELFFile(f).interpreter\n    except (OSError, TypeError, ValueError):\n        return None\n    if ld is None or \"musl\" not in ld:\n        return None\n    proc = subprocess.run([ld], stderr=subprocess.PIPE, text=True)\n    return _parse_musl_version(proc.stderr)\n\n\ndef platform_tags(archs: Sequence[str]) -> Iterator[str]:\n    \"\"\"Generate musllinux tags compatible to the current platform.\n\n    :param archs: Sequence of compatible architectures.\n        The first one shall be the closest to the actual architecture and be the part of\n        platform tag after the ``linux_`` prefix, e.g. ``x86_64``.\n        The ``linux_`` prefix is assumed as a prerequisite for the current platform to\n        be musllinux-compatible.\n\n    :returns: An iterator of compatible musllinux tags.\n    \"\"\"\n    sys_musl = _get_musl_version(sys.executable)\n    if sys_musl is None:  # Python not dynamically linked against musl.\n        return\n    for arch in archs:\n        for minor in range(sys_musl.minor, -1, -1):\n            yield f\"musllinux_{sys_musl.major}_{minor}_{arch}\"\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    import sysconfig\n\n    plat = sysconfig.get_platform()\n    assert plat.startswith(\"linux-\"), \"not linux\"\n\n    print(\"plat:\", plat)\n    print(\"musl:\", _get_musl_version(sys.executable))\n    print(\"tags:\", end=\" \")\n    for t in platform_tags(re.sub(r\"[.-]\", \"_\", plat.split(\"-\", 1)[-1])):\n        print(t, end=\"\\n      \")\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/packaging/_parser.py","size":10236,"sha1":"bba6fb5dd1e66f6622a7c9ffeafa127b510d8e30","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Handwritten parser of dependency specifiers.\n\nThe docstring for each __parse_* function contains EBNF-inspired grammar representing\nthe implementation.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport ast\nfrom typing import NamedTuple, Sequence, Tuple, Union\n\nfrom ._tokenizer import DEFAULT_RULES, Tokenizer\n\n\nclass Node:\n    def __init__(self, value: str) -> None:\n        self.value = value\n\n    def __str__(self) -> str:\n        return self.value\n\n    def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__}('{self}')>\"\n\n    def serialize(self) -> str:\n        raise NotImplementedError\n\n\nclass Variable(Node):\n    def serialize(self) -> str:\n        return str(self)\n\n\nclass Value(Node):\n    def serialize(self) -> str:\n        return f'\"{self}\"'\n\n\nclass Op(Node):\n    def serialize(self) -> str:\n        return str(self)\n\n\nMarkerVar = Union[Variable, Value]\nMarkerItem = Tuple[MarkerVar, Op, MarkerVar]\nMarkerAtom = Union[MarkerItem, Sequence[\"MarkerAtom\"]]\nMarkerList = Sequence[Union[\"MarkerList\", MarkerAtom, str]]\n\n\nclass ParsedRequirement(NamedTuple):\n    name: str\n    url: str\n    extras: list[str]\n    specifier: str\n    marker: MarkerList | None\n\n\n# --------------------------------------------------------------------------------------\n# Recursive descent parser for dependency specifier\n# --------------------------------------------------------------------------------------\ndef parse_requirement(source: str) -> ParsedRequirement:\n    return _parse_requirement(Tokenizer(source, rules=DEFAULT_RULES))\n\n\ndef _parse_requirement(tokenizer: Tokenizer) -> ParsedRequirement:\n    \"\"\"\n    requirement = WS? IDENTIFIER WS? extras WS? requirement_details\n    \"\"\"\n    tokenizer.consume(\"WS\")\n\n    name_token = tokenizer.expect(\n        \"IDENTIFIER\", expected=\"package name at the start of dependency specifier\"\n    )\n    name = name_token.text\n    tokenizer.consume(\"WS\")\n\n    extras = _parse_extras(tokenizer)\n    tokenizer.consume(\"WS\")\n\n    url, specifier, marker = _parse_requirement_details(tokenizer)\n    tokenizer.expect(\"END\", expected=\"end of dependency specifier\")\n\n    return ParsedRequirement(name, url, extras, specifier, marker)\n\n\ndef _parse_requirement_details(\n    tokenizer: Tokenizer,\n) -> tuple[str, str, MarkerList | None]:\n    \"\"\"\n    requirement_details = AT URL (WS requirement_marker?)?\n                        | specifier WS? (requirement_marker)?\n    \"\"\"\n\n    specifier = \"\"\n    url = \"\"\n    marker = None\n\n    if tokenizer.check(\"AT\"):\n        tokenizer.read()\n        tokenizer.consume(\"WS\")\n\n        url_start = tokenizer.position\n        url = tokenizer.expect(\"URL\", expected=\"URL after @\").text\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        tokenizer.expect(\"WS\", expected=\"whitespace after URL\")\n\n        # The input might end after whitespace.\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        marker = _parse_requirement_marker(\n            tokenizer, span_start=url_start, after=\"URL and whitespace\"\n        )\n    else:\n        specifier_start = tokenizer.position\n        specifier = _parse_specifier(tokenizer)\n        tokenizer.consume(\"WS\")\n\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        marker = _parse_requirement_marker(\n            tokenizer,\n            span_start=specifier_start,\n            after=(\n                \"version specifier\"\n                if specifier\n                else \"name and no valid version specifier\"\n            ),\n        )\n\n    return (url, specifier, marker)\n\n\ndef _parse_requirement_marker(\n    tokenizer: Tokenizer, *, span_start: int, after: str\n) -> MarkerList:\n    \"\"\"\n    requirement_marker = SEMICOLON marker WS?\n    \"\"\"\n\n    if not tokenizer.check(\"SEMICOLON\"):\n        tokenizer.raise_syntax_error(\n            f\"Expected end or semicolon (after {after})\",\n            span_start=span_start,\n        )\n    tokenizer.read()\n\n    marker = _parse_marker(tokenizer)\n    tokenizer.consume(\"WS\")\n\n    return marker\n\n\ndef _parse_extras(tokenizer: Tokenizer) -> list[str]:\n    \"\"\"\n    extras = (LEFT_BRACKET wsp* extras_list? wsp* RIGHT_BRACKET)?\n    \"\"\"\n    if not tokenizer.check(\"LEFT_BRACKET\", peek=True):\n        return []\n\n    with tokenizer.enclosing_tokens(\n        \"LEFT_BRACKET\",\n        \"RIGHT_BRACKET\",\n        around=\"extras\",\n    ):\n        tokenizer.consume(\"WS\")\n        extras = _parse_extras_list(tokenizer)\n        tokenizer.consume(\"WS\")\n\n    return extras\n\n\ndef _parse_extras_list(tokenizer: Tokenizer) -> list[str]:\n    \"\"\"\n    extras_list = identifier (wsp* ',' wsp* identifier)*\n    \"\"\"\n    extras: list[str] = []\n\n    if not tokenizer.check(\"IDENTIFIER\"):\n        return extras\n\n    extras.append(tokenizer.read().text)\n\n    while True:\n        tokenizer.consume(\"WS\")\n        if tokenizer.check(\"IDENTIFIER\", peek=True):\n            tokenizer.raise_syntax_error(\"Expected comma between extra names\")\n        elif not tokenizer.check(\"COMMA\"):\n            break\n\n        tokenizer.read()\n        tokenizer.consume(\"WS\")\n\n        extra_token = tokenizer.expect(\"IDENTIFIER\", expected=\"extra name after comma\")\n        extras.append(extra_token.text)\n\n    return extras\n\n\ndef _parse_specifier(tokenizer: Tokenizer) -> str:\n    \"\"\"\n    specifier = LEFT_PARENTHESIS WS? version_many WS? RIGHT_PARENTHESIS\n              | WS? version_many WS?\n    \"\"\"\n    with tokenizer.enclosing_tokens(\n        \"LEFT_PARENTHESIS\",\n        \"RIGHT_PARENTHESIS\",\n        around=\"version specifier\",\n    ):\n        tokenizer.consume(\"WS\")\n        parsed_specifiers = _parse_version_many(tokenizer)\n        tokenizer.consume(\"WS\")\n\n    return parsed_specifiers\n\n\ndef _parse_version_many(tokenizer: Tokenizer) -> str:\n    \"\"\"\n    version_many = (SPECIFIER (WS? COMMA WS? SPECIFIER)*)?\n    \"\"\"\n    parsed_specifiers = \"\"\n    while tokenizer.check(\"SPECIFIER\"):\n        span_start = tokenizer.position\n        parsed_specifiers += tokenizer.read().text\n        if tokenizer.check(\"VERSION_PREFIX_TRAIL\", peek=True):\n            tokenizer.raise_syntax_error(\n                \".* suffix can only be used with `==` or `!=` operators\",\n                span_start=span_start,\n                span_end=tokenizer.position + 1,\n            )\n        if tokenizer.check(\"VERSION_LOCAL_LABEL_TRAIL\", peek=True):\n            tokenizer.raise_syntax_error(\n                \"Local version label can only be used with `==` or `!=` operators\",\n                span_start=span_start,\n                span_end=tokenizer.position,\n            )\n        tokenizer.consume(\"WS\")\n        if not tokenizer.check(\"COMMA\"):\n            break\n        parsed_specifiers += tokenizer.read().text\n        tokenizer.consume(\"WS\")\n\n    return parsed_specifiers\n\n\n# --------------------------------------------------------------------------------------\n# Recursive descent parser for marker expression\n# --------------------------------------------------------------------------------------\ndef parse_marker(source: str) -> MarkerList:\n    return _parse_full_marker(Tokenizer(source, rules=DEFAULT_RULES))\n\n\ndef _parse_full_marker(tokenizer: Tokenizer) -> MarkerList:\n    retval = _parse_marker(tokenizer)\n    tokenizer.expect(\"END\", expected=\"end of marker expression\")\n    return retval\n\n\ndef _parse_marker(tokenizer: Tokenizer) -> MarkerList:\n    \"\"\"\n    marker = marker_atom (BOOLOP marker_atom)+\n    \"\"\"\n    expression = [_parse_marker_atom(tokenizer)]\n    while tokenizer.check(\"BOOLOP\"):\n        token = tokenizer.read()\n        expr_right = _parse_marker_atom(tokenizer)\n        expression.extend((token.text, expr_right))\n    return expression\n\n\ndef _parse_marker_atom(tokenizer: Tokenizer) -> MarkerAtom:\n    \"\"\"\n    marker_atom = WS? LEFT_PARENTHESIS WS? marker WS? RIGHT_PARENTHESIS WS?\n                | WS? marker_item WS?\n    \"\"\"\n\n    tokenizer.consume(\"WS\")\n    if tokenizer.check(\"LEFT_PARENTHESIS\", peek=True):\n        with tokenizer.enclosing_tokens(\n            \"LEFT_PARENTHESIS\",\n            \"RIGHT_PARENTHESIS\",\n            around=\"marker expression\",\n        ):\n            tokenizer.consume(\"WS\")\n            marker: MarkerAtom = _parse_marker(tokenizer)\n            tokenizer.consume(\"WS\")\n    else:\n        marker = _parse_marker_item(tokenizer)\n    tokenizer.consume(\"WS\")\n    return marker\n\n\ndef _parse_marker_item(tokenizer: Tokenizer) -> MarkerItem:\n    \"\"\"\n    marker_item = WS? marker_var WS? marker_op WS? marker_var WS?\n    \"\"\"\n    tokenizer.consume(\"WS\")\n    marker_var_left = _parse_marker_var(tokenizer)\n    tokenizer.consume(\"WS\")\n    marker_op = _parse_marker_op(tokenizer)\n    tokenizer.consume(\"WS\")\n    marker_var_right = _parse_marker_var(tokenizer)\n    tokenizer.consume(\"WS\")\n    return (marker_var_left, marker_op, marker_var_right)\n\n\ndef _parse_marker_var(tokenizer: Tokenizer) -> MarkerVar:\n    \"\"\"\n    marker_var = VARIABLE | QUOTED_STRING\n    \"\"\"\n    if tokenizer.check(\"VARIABLE\"):\n        return process_env_var(tokenizer.read().text.replace(\".\", \"_\"))\n    elif tokenizer.check(\"QUOTED_STRING\"):\n        return process_python_str(tokenizer.read().text)\n    else:\n        tokenizer.raise_syntax_error(\n            message=\"Expected a marker variable or quoted string\"\n        )\n\n\ndef process_env_var(env_var: str) -> Variable:\n    if env_var in (\"platform_python_implementation\", \"python_implementation\"):\n        return Variable(\"platform_python_implementation\")\n    else:\n        return Variable(env_var)\n\n\ndef process_python_str(python_str: str) -> Value:\n    value = ast.literal_eval(python_str)\n    return Value(str(value))\n\n\ndef _parse_marker_op(tokenizer: Tokenizer) -> Op:\n    \"\"\"\n    marker_op = IN | NOT IN | OP\n    \"\"\"\n    if tokenizer.check(\"IN\"):\n        tokenizer.read()\n        return Op(\"in\")\n    elif tokenizer.check(\"NOT\"):\n        tokenizer.read()\n        tokenizer.expect(\"WS\", expected=\"whitespace after 'not'\")\n        tokenizer.expect(\"IN\", expected=\"'in' after 'not'\")\n        return Op(\"not in\")\n    elif tokenizer.check(\"OP\"):\n        return Op(tokenizer.read().text)\n    else:\n        return tokenizer.raise_syntax_error(\n            \"Expected marker operator, one of \"\n            \"<=, <, !=, ==, >=, >, ~=, ===, in, not in\"\n        )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/packaging/_structures.py","size":1431,"sha1":"fe0c3747cf14e696276cb6806c6775503de002b8","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nclass InfinityType:\n    def __repr__(self) -> str:\n        return \"Infinity\"\n\n    def __hash__(self) -> int:\n        return hash(repr(self))\n\n    def __lt__(self, other: object) -> bool:\n        return False\n\n    def __le__(self, other: object) -> bool:\n        return False\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__)\n\n    def __gt__(self, other: object) -> bool:\n        return True\n\n    def __ge__(self, other: object) -> bool:\n        return True\n\n    def __neg__(self: object) -> \"NegativeInfinityType\":\n        return NegativeInfinity\n\n\nInfinity = InfinityType()\n\n\nclass NegativeInfinityType:\n    def __repr__(self) -> str:\n        return \"-Infinity\"\n\n    def __hash__(self) -> int:\n        return hash(repr(self))\n\n    def __lt__(self, other: object) -> bool:\n        return True\n\n    def __le__(self, other: object) -> bool:\n        return True\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__)\n\n    def __gt__(self, other: object) -> bool:\n        return False\n\n    def __ge__(self, other: object) -> bool:\n        return False\n\n    def __neg__(self: object) -> InfinityType:\n        return Infinity\n\n\nNegativeInfinity = NegativeInfinityType()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/packaging/_tokenizer.py","size":5273,"sha1":"575e0d0d9f6bae73faccb96833494626bd81fbef","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport contextlib\nimport re\nfrom dataclasses import dataclass\nfrom typing import Iterator, NoReturn\n\nfrom .specifiers import Specifier\n\n\n@dataclass\nclass Token:\n    name: str\n    text: str\n    position: int\n\n\nclass ParserSyntaxError(Exception):\n    \"\"\"The provided source text could not be parsed correctly.\"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        *,\n        source: str,\n        span: tuple[int, int],\n    ) -> None:\n        self.span = span\n        self.message = message\n        self.source = source\n\n        super().__init__()\n\n    def __str__(self) -> str:\n        marker = \" \" * self.span[0] + \"~\" * (self.span[1] - self.span[0]) + \"^\"\n        return \"\\n    \".join([self.message, self.source, marker])\n\n\nDEFAULT_RULES: dict[str, str | re.Pattern[str]] = {\n    \"LEFT_PARENTHESIS\": r\"\\(\",\n    \"RIGHT_PARENTHESIS\": r\"\\)\",\n    \"LEFT_BRACKET\": r\"\\[\",\n    \"RIGHT_BRACKET\": r\"\\]\",\n    \"SEMICOLON\": r\";\",\n    \"COMMA\": r\",\",\n    \"QUOTED_STRING\": re.compile(\n        r\"\"\"\n            (\n                ('[^']*')\n                |\n                (\"[^\"]*\")\n            )\n        \"\"\",\n        re.VERBOSE,\n    ),\n    \"OP\": r\"(===|==|~=|!=|<=|>=|<|>)\",\n    \"BOOLOP\": r\"\\b(or|and)\\b\",\n    \"IN\": r\"\\bin\\b\",\n    \"NOT\": r\"\\bnot\\b\",\n    \"VARIABLE\": re.compile(\n        r\"\"\"\n            \\b(\n                python_version\n                |python_full_version\n                |os[._]name\n                |sys[._]platform\n                |platform_(release|system)\n                |platform[._](version|machine|python_implementation)\n                |python_implementation\n                |implementation_(name|version)\n                |extra\n            )\\b\n        \"\"\",\n        re.VERBOSE,\n    ),\n    \"SPECIFIER\": re.compile(\n        Specifier._operator_regex_str + Specifier._version_regex_str,\n        re.VERBOSE | re.IGNORECASE,\n    ),\n    \"AT\": r\"\\@\",\n    \"URL\": r\"[^ \\t]+\",\n    \"IDENTIFIER\": r\"\\b[a-zA-Z0-9][a-zA-Z0-9._-]*\\b\",\n    \"VERSION_PREFIX_TRAIL\": r\"\\.\\*\",\n    \"VERSION_LOCAL_LABEL_TRAIL\": r\"\\+[a-z0-9]+(?:[-_\\.][a-z0-9]+)*\",\n    \"WS\": r\"[ \\t]+\",\n    \"END\": r\"$\",\n}\n\n\nclass Tokenizer:\n    \"\"\"Context-sensitive token parsing.\n\n    Provides methods to examine the input stream to check whether the next token\n    matches.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: str,\n        *,\n        rules: dict[str, str | re.Pattern[str]],\n    ) -> None:\n        self.source = source\n        self.rules: dict[str, re.Pattern[str]] = {\n            name: re.compile(pattern) for name, pattern in rules.items()\n        }\n        self.next_token: Token | None = None\n        self.position = 0\n\n    def consume(self, name: str) -> None:\n        \"\"\"Move beyond provided token name, if at current position.\"\"\"\n        if self.check(name):\n            self.read()\n\n    def check(self, name: str, *, peek: bool = False) -> bool:\n        \"\"\"Check whether the next token has the provided name.\n\n        By default, if the check succeeds, the token *must* be read before\n        another check. If `peek` is set to `True`, the token is not loaded and\n        would need to be checked again.\n        \"\"\"\n        assert (\n            self.next_token is None\n        ), f\"Cannot check for {name!r}, already have {self.next_token!r}\"\n        assert name in self.rules, f\"Unknown token name: {name!r}\"\n\n        expression = self.rules[name]\n\n        match = expression.match(self.source, self.position)\n        if match is None:\n            return False\n        if not peek:\n            self.next_token = Token(name, match[0], self.position)\n        return True\n\n    def expect(self, name: str, *, expected: str) -> Token:\n        \"\"\"Expect a certain token name next, failing with a syntax error otherwise.\n\n        The token is *not* read.\n        \"\"\"\n        if not self.check(name):\n            raise self.raise_syntax_error(f\"Expected {expected}\")\n        return self.read()\n\n    def read(self) -> Token:\n        \"\"\"Consume the next token and return it.\"\"\"\n        token = self.next_token\n        assert token is not None\n\n        self.position += len(token.text)\n        self.next_token = None\n\n        return token\n\n    def raise_syntax_error(\n        self,\n        message: str,\n        *,\n        span_start: int | None = None,\n        span_end: int | None = None,\n    ) -> NoReturn:\n        \"\"\"Raise ParserSyntaxError at the given position.\"\"\"\n        span = (\n            self.position if span_start is None else span_start,\n            self.position if span_end is None else span_end,\n        )\n        raise ParserSyntaxError(\n            message,\n            source=self.source,\n            span=span,\n        )\n\n    @contextlib.contextmanager\n    def enclosing_tokens(\n        self, open_token: str, close_token: str, *, around: str\n    ) -> Iterator[None]:\n        if self.check(open_token):\n            open_position = self.position\n            self.read()\n        else:\n            open_position = None\n\n        yield\n\n        if open_position is None:\n            return\n\n        if not self.check(close_token):\n            self.raise_syntax_error(\n                f\"Expected matching {close_token} for {open_token}, after {around}\",\n                span_start=open_position,\n            )\n\n        self.read()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/packaging/licenses/__init__.py","size":5715,"sha1":"6e3e8166ad6ee16937bdbeed16c8dab733901b54","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"#######################################################################################\n#\n# Adapted from:\n#  https://github.com/pypa/hatch/blob/5352e44/backend/src/hatchling/licenses/parse.py\n#\n# MIT License\n#\n# Copyright (c) 2017-present Ofek Lev <oss@ofek.dev>\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy of this\n# software and associated documentation files (the \"Software\"), to deal in the Software\n# without restriction, including without limitation the rights to use, copy, modify,\n# merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to the following\n# conditions:\n#\n# The above copyright notice and this permission notice shall be included in all copies\n# or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#\n#\n# With additional allowance of arbitrary `LicenseRef-` identifiers, not just\n# `LicenseRef-Public-Domain` and `LicenseRef-Proprietary`.\n#\n#######################################################################################\nfrom __future__ import annotations\n\nimport re\nfrom typing import NewType, cast\n\nfrom packaging.licenses._spdx import EXCEPTIONS, LICENSES\n\n__all__ = [\n    \"NormalizedLicenseExpression\",\n    \"InvalidLicenseExpression\",\n    \"canonicalize_license_expression\",\n]\n\nlicense_ref_allowed = re.compile(\"^[A-Za-z0-9.-]*$\")\n\nNormalizedLicenseExpression = NewType(\"NormalizedLicenseExpression\", str)\n\n\nclass InvalidLicenseExpression(ValueError):\n    \"\"\"Raised when a license-expression string is invalid\n\n    >>> canonicalize_license_expression(\"invalid\")\n    Traceback (most recent call last):\n        ...\n    packaging.licenses.InvalidLicenseExpression: Invalid license expression: 'invalid'\n    \"\"\"\n\n\ndef canonicalize_license_expression(\n    raw_license_expression: str,\n) -> NormalizedLicenseExpression:\n    if not raw_license_expression:\n        message = f\"Invalid license expression: {raw_license_expression!r}\"\n        raise InvalidLicenseExpression(message)\n\n    # Pad any parentheses so tokenization can be achieved by merely splitting on\n    # whitespace.\n    license_expression = raw_license_expression.replace(\"(\", \" ( \").replace(\")\", \" ) \")\n    licenseref_prefix = \"LicenseRef-\"\n    license_refs = {\n        ref.lower(): \"LicenseRef-\" + ref[len(licenseref_prefix) :]\n        for ref in license_expression.split()\n        if ref.lower().startswith(licenseref_prefix.lower())\n    }\n\n    # Normalize to lower case so we can look up licenses/exceptions\n    # and so boolean operators are Python-compatible.\n    license_expression = license_expression.lower()\n\n    tokens = license_expression.split()\n\n    # Rather than implementing boolean logic, we create an expression that Python can\n    # parse. Everything that is not involved with the grammar itself is treated as\n    # `False` and the expression should evaluate as such.\n    python_tokens = []\n    for token in tokens:\n        if token not in {\"or\", \"and\", \"with\", \"(\", \")\"}:\n            python_tokens.append(\"False\")\n        elif token == \"with\":\n            python_tokens.append(\"or\")\n        elif token == \"(\" and python_tokens and python_tokens[-1] not in {\"or\", \"and\"}:\n            message = f\"Invalid license expression: {raw_license_expression!r}\"\n            raise InvalidLicenseExpression(message)\n        else:\n            python_tokens.append(token)\n\n    python_expression = \" \".join(python_tokens)\n    try:\n        invalid = eval(python_expression, globals(), locals())\n    except Exception:\n        invalid = True\n\n    if invalid is not False:\n        message = f\"Invalid license expression: {raw_license_expression!r}\"\n        raise InvalidLicenseExpression(message) from None\n\n    # Take a final pass to check for unknown licenses/exceptions.\n    normalized_tokens = []\n    for token in tokens:\n        if token in {\"or\", \"and\", \"with\", \"(\", \")\"}:\n            normalized_tokens.append(token.upper())\n            continue\n\n        if normalized_tokens and normalized_tokens[-1] == \"WITH\":\n            if token not in EXCEPTIONS:\n                message = f\"Unknown license exception: {token!r}\"\n                raise InvalidLicenseExpression(message)\n\n            normalized_tokens.append(EXCEPTIONS[token][\"id\"])\n        else:\n            if token.endswith(\"+\"):\n                final_token = token[:-1]\n                suffix = \"+\"\n            else:\n                final_token = token\n                suffix = \"\"\n\n            if final_token.startswith(\"licenseref-\"):\n                if not license_ref_allowed.match(final_token):\n                    message = f\"Invalid licenseref: {final_token!r}\"\n                    raise InvalidLicenseExpression(message)\n                normalized_tokens.append(license_refs[final_token] + suffix)\n            else:\n                if final_token not in LICENSES:\n                    message = f\"Unknown license: {final_token!r}\"\n                    raise InvalidLicenseExpression(message)\n                normalized_tokens.append(LICENSES[final_token][\"id\"] + suffix)\n\n    normalized_expression = \" \".join(normalized_tokens)\n\n    return cast(\n        NormalizedLicenseExpression,\n        normalized_expression.replace(\"( \", \"(\").replace(\" )\", \")\"),\n    )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/packaging/licenses/_spdx.py","size":48398,"sha1":"ebf0b2cfba0cef0c64c1094323f97f7c40f0fc73","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\nfrom __future__ import annotations\n\nfrom typing import TypedDict\n\nclass SPDXLicense(TypedDict):\n    id: str\n    deprecated: bool\n\nclass SPDXException(TypedDict):\n    id: str\n    deprecated: bool\n\n\nVERSION = '3.25.0'\n\nLICENSES: dict[str, SPDXLicense] = {\n    '0bsd': {'id': '0BSD', 'deprecated': False},\n    '3d-slicer-1.0': {'id': '3D-Slicer-1.0', 'deprecated': False},\n    'aal': {'id': 'AAL', 'deprecated': False},\n    'abstyles': {'id': 'Abstyles', 'deprecated': False},\n    'adacore-doc': {'id': 'AdaCore-doc', 'deprecated': False},\n    'adobe-2006': {'id': 'Adobe-2006', 'deprecated': False},\n    'adobe-display-postscript': {'id': 'Adobe-Display-PostScript', 'deprecated': False},\n    'adobe-glyph': {'id': 'Adobe-Glyph', 'deprecated': False},\n    'adobe-utopia': {'id': 'Adobe-Utopia', 'deprecated': False},\n    'adsl': {'id': 'ADSL', 'deprecated': False},\n    'afl-1.1': {'id': 'AFL-1.1', 'deprecated': False},\n    'afl-1.2': {'id': 'AFL-1.2', 'deprecated': False},\n    'afl-2.0': {'id': 'AFL-2.0', 'deprecated': False},\n    'afl-2.1': {'id': 'AFL-2.1', 'deprecated': False},\n    'afl-3.0': {'id': 'AFL-3.0', 'deprecated': False},\n    'afmparse': {'id': 'Afmparse', 'deprecated': False},\n    'agpl-1.0': {'id': 'AGPL-1.0', 'deprecated': True},\n    'agpl-1.0-only': {'id': 'AGPL-1.0-only', 'deprecated': False},\n    'agpl-1.0-or-later': {'id': 'AGPL-1.0-or-later', 'deprecated': False},\n    'agpl-3.0': {'id': 'AGPL-3.0', 'deprecated': True},\n    'agpl-3.0-only': {'id': 'AGPL-3.0-only', 'deprecated': False},\n    'agpl-3.0-or-later': {'id': 'AGPL-3.0-or-later', 'deprecated': False},\n    'aladdin': {'id': 'Aladdin', 'deprecated': False},\n    'amd-newlib': {'id': 'AMD-newlib', 'deprecated': False},\n    'amdplpa': {'id': 'AMDPLPA', 'deprecated': False},\n    'aml': {'id': 'AML', 'deprecated': False},\n    'aml-glslang': {'id': 'AML-glslang', 'deprecated': False},\n    'ampas': {'id': 'AMPAS', 'deprecated': False},\n    'antlr-pd': {'id': 'ANTLR-PD', 'deprecated': False},\n    'antlr-pd-fallback': {'id': 'ANTLR-PD-fallback', 'deprecated': False},\n    'any-osi': {'id': 'any-OSI', 'deprecated': False},\n    'apache-1.0': {'id': 'Apache-1.0', 'deprecated': False},\n    'apache-1.1': {'id': 'Apache-1.1', 'deprecated': False},\n    'apache-2.0': {'id': 'Apache-2.0', 'deprecated': False},\n    'apafml': {'id': 'APAFML', 'deprecated': False},\n    'apl-1.0': {'id': 'APL-1.0', 'deprecated': False},\n    'app-s2p': {'id': 'App-s2p', 'deprecated': False},\n    'apsl-1.0': {'id': 'APSL-1.0', 'deprecated': False},\n    'apsl-1.1': {'id': 'APSL-1.1', 'deprecated': False},\n    'apsl-1.2': {'id': 'APSL-1.2', 'deprecated': False},\n    'apsl-2.0': {'id': 'APSL-2.0', 'deprecated': False},\n    'arphic-1999': {'id': 'Arphic-1999', 'deprecated': False},\n    'artistic-1.0': {'id': 'Artistic-1.0', 'deprecated': False},\n    'artistic-1.0-cl8': {'id': 'Artistic-1.0-cl8', 'deprecated': False},\n    'artistic-1.0-perl': {'id': 'Artistic-1.0-Perl', 'deprecated': False},\n    'artistic-2.0': {'id': 'Artistic-2.0', 'deprecated': False},\n    'aswf-digital-assets-1.0': {'id': 'ASWF-Digital-Assets-1.0', 'deprecated': False},\n    'aswf-digital-assets-1.1': {'id': 'ASWF-Digital-Assets-1.1', 'deprecated': False},\n    'baekmuk': {'id': 'Baekmuk', 'deprecated': False},\n    'bahyph': {'id': 'Bahyph', 'deprecated': False},\n    'barr': {'id': 'Barr', 'deprecated': False},\n    'bcrypt-solar-designer': {'id': 'bcrypt-Solar-Designer', 'deprecated': False},\n    'beerware': {'id': 'Beerware', 'deprecated': False},\n    'bitstream-charter': {'id': 'Bitstream-Charter', 'deprecated': False},\n    'bitstream-vera': {'id': 'Bitstream-Vera', 'deprecated': False},\n    'bittorrent-1.0': {'id': 'BitTorrent-1.0', 'deprecated': False},\n    'bittorrent-1.1': {'id': 'BitTorrent-1.1', 'deprecated': False},\n    'blessing': {'id': 'blessing', 'deprecated': False},\n    'blueoak-1.0.0': {'id': 'BlueOak-1.0.0', 'deprecated': False},\n    'boehm-gc': {'id': 'Boehm-GC', 'deprecated': False},\n    'borceux': {'id': 'Borceux', 'deprecated': False},\n    'brian-gladman-2-clause': {'id': 'Brian-Gladman-2-Clause', 'deprecated': False},\n    'brian-gladman-3-clause': {'id': 'Brian-Gladman-3-Clause', 'deprecated': False},\n    'bsd-1-clause': {'id': 'BSD-1-Clause', 'deprecated': False},\n    'bsd-2-clause': {'id': 'BSD-2-Clause', 'deprecated': False},\n    'bsd-2-clause-darwin': {'id': 'BSD-2-Clause-Darwin', 'deprecated': False},\n    'bsd-2-clause-first-lines': {'id': 'BSD-2-Clause-first-lines', 'deprecated': False},\n    'bsd-2-clause-freebsd': {'id': 'BSD-2-Clause-FreeBSD', 'deprecated': True},\n    'bsd-2-clause-netbsd': {'id': 'BSD-2-Clause-NetBSD', 'deprecated': True},\n    'bsd-2-clause-patent': {'id': 'BSD-2-Clause-Patent', 'deprecated': False},\n    'bsd-2-clause-views': {'id': 'BSD-2-Clause-Views', 'deprecated': False},\n    'bsd-3-clause': {'id': 'BSD-3-Clause', 'deprecated': False},\n    'bsd-3-clause-acpica': {'id': 'BSD-3-Clause-acpica', 'deprecated': False},\n    'bsd-3-clause-attribution': {'id': 'BSD-3-Clause-Attribution', 'deprecated': False},\n    'bsd-3-clause-clear': {'id': 'BSD-3-Clause-Clear', 'deprecated': False},\n    'bsd-3-clause-flex': {'id': 'BSD-3-Clause-flex', 'deprecated': False},\n    'bsd-3-clause-hp': {'id': 'BSD-3-Clause-HP', 'deprecated': False},\n    'bsd-3-clause-lbnl': {'id': 'BSD-3-Clause-LBNL', 'deprecated': False},\n    'bsd-3-clause-modification': {'id': 'BSD-3-Clause-Modification', 'deprecated': False},\n    'bsd-3-clause-no-military-license': {'id': 'BSD-3-Clause-No-Military-License', 'deprecated': False},\n    'bsd-3-clause-no-nuclear-license': {'id': 'BSD-3-Clause-No-Nuclear-License', 'deprecated': False},\n    'bsd-3-clause-no-nuclear-license-2014': {'id': 'BSD-3-Clause-No-Nuclear-License-2014', 'deprecated': False},\n    'bsd-3-clause-no-nuclear-warranty': {'id': 'BSD-3-Clause-No-Nuclear-Warranty', 'deprecated': False},\n    'bsd-3-clause-open-mpi': {'id': 'BSD-3-Clause-Open-MPI', 'deprecated': False},\n    'bsd-3-clause-sun': {'id': 'BSD-3-Clause-Sun', 'deprecated': False},\n    'bsd-4-clause': {'id': 'BSD-4-Clause', 'deprecated': False},\n    'bsd-4-clause-shortened': {'id': 'BSD-4-Clause-Shortened', 'deprecated': False},\n    'bsd-4-clause-uc': {'id': 'BSD-4-Clause-UC', 'deprecated': False},\n    'bsd-4.3reno': {'id': 'BSD-4.3RENO', 'deprecated': False},\n    'bsd-4.3tahoe': {'id': 'BSD-4.3TAHOE', 'deprecated': False},\n    'bsd-advertising-acknowledgement': {'id': 'BSD-Advertising-Acknowledgement', 'deprecated': False},\n    'bsd-attribution-hpnd-disclaimer': {'id': 'BSD-Attribution-HPND-disclaimer', 'deprecated': False},\n    'bsd-inferno-nettverk': {'id': 'BSD-Inferno-Nettverk', 'deprecated': False},\n    'bsd-protection': {'id': 'BSD-Protection', 'deprecated': False},\n    'bsd-source-beginning-file': {'id': 'BSD-Source-beginning-file', 'deprecated': False},\n    'bsd-source-code': {'id': 'BSD-Source-Code', 'deprecated': False},\n    'bsd-systemics': {'id': 'BSD-Systemics', 'deprecated': False},\n    'bsd-systemics-w3works': {'id': 'BSD-Systemics-W3Works', 'deprecated': False},\n    'bsl-1.0': {'id': 'BSL-1.0', 'deprecated': False},\n    'busl-1.1': {'id': 'BUSL-1.1', 'deprecated': False},\n    'bzip2-1.0.5': {'id': 'bzip2-1.0.5', 'deprecated': True},\n    'bzip2-1.0.6': {'id': 'bzip2-1.0.6', 'deprecated': False},\n    'c-uda-1.0': {'id': 'C-UDA-1.0', 'deprecated': False},\n    'cal-1.0': {'id': 'CAL-1.0', 'deprecated': False},\n    'cal-1.0-combined-work-exception': {'id': 'CAL-1.0-Combined-Work-Exception', 'deprecated': False},\n    'caldera': {'id': 'Caldera', 'deprecated': False},\n    'caldera-no-preamble': {'id': 'Caldera-no-preamble', 'deprecated': False},\n    'catharon': {'id': 'Catharon', 'deprecated': False},\n    'catosl-1.1': {'id': 'CATOSL-1.1', 'deprecated': False},\n    'cc-by-1.0': {'id': 'CC-BY-1.0', 'deprecated': False},\n    'cc-by-2.0': {'id': 'CC-BY-2.0', 'deprecated': False},\n    'cc-by-2.5': {'id': 'CC-BY-2.5', 'deprecated': False},\n    'cc-by-2.5-au': {'id': 'CC-BY-2.5-AU', 'deprecated': False},\n    'cc-by-3.0': {'id': 'CC-BY-3.0', 'deprecated': False},\n    'cc-by-3.0-at': {'id': 'CC-BY-3.0-AT', 'deprecated': False},\n    'cc-by-3.0-au': {'id': 'CC-BY-3.0-AU', 'deprecated': False},\n    'cc-by-3.0-de': {'id': 'CC-BY-3.0-DE', 'deprecated': False},\n    'cc-by-3.0-igo': {'id': 'CC-BY-3.0-IGO', 'deprecated': False},\n    'cc-by-3.0-nl': {'id': 'CC-BY-3.0-NL', 'deprecated': False},\n    'cc-by-3.0-us': {'id': 'CC-BY-3.0-US', 'deprecated': False},\n    'cc-by-4.0': {'id': 'CC-BY-4.0', 'deprecated': False},\n    'cc-by-nc-1.0': {'id': 'CC-BY-NC-1.0', 'deprecated': False},\n    'cc-by-nc-2.0': {'id': 'CC-BY-NC-2.0', 'deprecated': False},\n    'cc-by-nc-2.5': {'id': 'CC-BY-NC-2.5', 'deprecated': False},\n    'cc-by-nc-3.0': {'id': 'CC-BY-NC-3.0', 'deprecated': False},\n    'cc-by-nc-3.0-de': {'id': 'CC-BY-NC-3.0-DE', 'deprecated': False},\n    'cc-by-nc-4.0': {'id': 'CC-BY-NC-4.0', 'deprecated': False},\n    'cc-by-nc-nd-1.0': {'id': 'CC-BY-NC-ND-1.0', 'deprecated': False},\n    'cc-by-nc-nd-2.0': {'id': 'CC-BY-NC-ND-2.0', 'deprecated': False},\n    'cc-by-nc-nd-2.5': {'id': 'CC-BY-NC-ND-2.5', 'deprecated': False},\n    'cc-by-nc-nd-3.0': {'id': 'CC-BY-NC-ND-3.0', 'deprecated': False},\n    'cc-by-nc-nd-3.0-de': {'id': 'CC-BY-NC-ND-3.0-DE', 'deprecated': False},\n    'cc-by-nc-nd-3.0-igo': {'id': 'CC-BY-NC-ND-3.0-IGO', 'deprecated': False},\n    'cc-by-nc-nd-4.0': {'id': 'CC-BY-NC-ND-4.0', 'deprecated': False},\n    'cc-by-nc-sa-1.0': {'id': 'CC-BY-NC-SA-1.0', 'deprecated': False},\n    'cc-by-nc-sa-2.0': {'id': 'CC-BY-NC-SA-2.0', 'deprecated': False},\n    'cc-by-nc-sa-2.0-de': {'id': 'CC-BY-NC-SA-2.0-DE', 'deprecated': False},\n    'cc-by-nc-sa-2.0-fr': {'id': 'CC-BY-NC-SA-2.0-FR', 'deprecated': False},\n    'cc-by-nc-sa-2.0-uk': {'id': 'CC-BY-NC-SA-2.0-UK', 'deprecated': False},\n    'cc-by-nc-sa-2.5': {'id': 'CC-BY-NC-SA-2.5', 'deprecated': False},\n    'cc-by-nc-sa-3.0': {'id': 'CC-BY-NC-SA-3.0', 'deprecated': False},\n    'cc-by-nc-sa-3.0-de': {'id': 'CC-BY-NC-SA-3.0-DE', 'deprecated': False},\n    'cc-by-nc-sa-3.0-igo': {'id': 'CC-BY-NC-SA-3.0-IGO', 'deprecated': False},\n    'cc-by-nc-sa-4.0': {'id': 'CC-BY-NC-SA-4.0', 'deprecated': False},\n    'cc-by-nd-1.0': {'id': 'CC-BY-ND-1.0', 'deprecated': False},\n    'cc-by-nd-2.0': {'id': 'CC-BY-ND-2.0', 'deprecated': False},\n    'cc-by-nd-2.5': {'id': 'CC-BY-ND-2.5', 'deprecated': False},\n    'cc-by-nd-3.0': {'id': 'CC-BY-ND-3.0', 'deprecated': False},\n    'cc-by-nd-3.0-de': {'id': 'CC-BY-ND-3.0-DE', 'deprecated': False},\n    'cc-by-nd-4.0': {'id': 'CC-BY-ND-4.0', 'deprecated': False},\n    'cc-by-sa-1.0': {'id': 'CC-BY-SA-1.0', 'deprecated': False},\n    'cc-by-sa-2.0': {'id': 'CC-BY-SA-2.0', 'deprecated': False},\n    'cc-by-sa-2.0-uk': {'id': 'CC-BY-SA-2.0-UK', 'deprecated': False},\n    'cc-by-sa-2.1-jp': {'id': 'CC-BY-SA-2.1-JP', 'deprecated': False},\n    'cc-by-sa-2.5': {'id': 'CC-BY-SA-2.5', 'deprecated': False},\n    'cc-by-sa-3.0': {'id': 'CC-BY-SA-3.0', 'deprecated': False},\n    'cc-by-sa-3.0-at': {'id': 'CC-BY-SA-3.0-AT', 'deprecated': False},\n    'cc-by-sa-3.0-de': {'id': 'CC-BY-SA-3.0-DE', 'deprecated': False},\n    'cc-by-sa-3.0-igo': {'id': 'CC-BY-SA-3.0-IGO', 'deprecated': False},\n    'cc-by-sa-4.0': {'id': 'CC-BY-SA-4.0', 'deprecated': False},\n    'cc-pddc': {'id': 'CC-PDDC', 'deprecated': False},\n    'cc0-1.0': {'id': 'CC0-1.0', 'deprecated': False},\n    'cddl-1.0': {'id': 'CDDL-1.0', 'deprecated': False},\n    'cddl-1.1': {'id': 'CDDL-1.1', 'deprecated': False},\n    'cdl-1.0': {'id': 'CDL-1.0', 'deprecated': False},\n    'cdla-permissive-1.0': {'id': 'CDLA-Permissive-1.0', 'deprecated': False},\n    'cdla-permissive-2.0': {'id': 'CDLA-Permissive-2.0', 'deprecated': False},\n    'cdla-sharing-1.0': {'id': 'CDLA-Sharing-1.0', 'deprecated': False},\n    'cecill-1.0': {'id': 'CECILL-1.0', 'deprecated': False},\n    'cecill-1.1': {'id': 'CECILL-1.1', 'deprecated': False},\n    'cecill-2.0': {'id': 'CECILL-2.0', 'deprecated': False},\n    'cecill-2.1': {'id': 'CECILL-2.1', 'deprecated': False},\n    'cecill-b': {'id': 'CECILL-B', 'deprecated': False},\n    'cecill-c': {'id': 'CECILL-C', 'deprecated': False},\n    'cern-ohl-1.1': {'id': 'CERN-OHL-1.1', 'deprecated': False},\n    'cern-ohl-1.2': {'id': 'CERN-OHL-1.2', 'deprecated': False},\n    'cern-ohl-p-2.0': {'id': 'CERN-OHL-P-2.0', 'deprecated': False},\n    'cern-ohl-s-2.0': {'id': 'CERN-OHL-S-2.0', 'deprecated': False},\n    'cern-ohl-w-2.0': {'id': 'CERN-OHL-W-2.0', 'deprecated': False},\n    'cfitsio': {'id': 'CFITSIO', 'deprecated': False},\n    'check-cvs': {'id': 'check-cvs', 'deprecated': False},\n    'checkmk': {'id': 'checkmk', 'deprecated': False},\n    'clartistic': {'id': 'ClArtistic', 'deprecated': False},\n    'clips': {'id': 'Clips', 'deprecated': False},\n    'cmu-mach': {'id': 'CMU-Mach', 'deprecated': False},\n    'cmu-mach-nodoc': {'id': 'CMU-Mach-nodoc', 'deprecated': False},\n    'cnri-jython': {'id': 'CNRI-Jython', 'deprecated': False},\n    'cnri-python': {'id': 'CNRI-Python', 'deprecated': False},\n    'cnri-python-gpl-compatible': {'id': 'CNRI-Python-GPL-Compatible', 'deprecated': False},\n    'coil-1.0': {'id': 'COIL-1.0', 'deprecated': False},\n    'community-spec-1.0': {'id': 'Community-Spec-1.0', 'deprecated': False},\n    'condor-1.1': {'id': 'Condor-1.1', 'deprecated': False},\n    'copyleft-next-0.3.0': {'id': 'copyleft-next-0.3.0', 'deprecated': False},\n    'copyleft-next-0.3.1': {'id': 'copyleft-next-0.3.1', 'deprecated': False},\n    'cornell-lossless-jpeg': {'id': 'Cornell-Lossless-JPEG', 'deprecated': False},\n    'cpal-1.0': {'id': 'CPAL-1.0', 'deprecated': False},\n    'cpl-1.0': {'id': 'CPL-1.0', 'deprecated': False},\n    'cpol-1.02': {'id': 'CPOL-1.02', 'deprecated': False},\n    'cronyx': {'id': 'Cronyx', 'deprecated': False},\n    'crossword': {'id': 'Crossword', 'deprecated': False},\n    'crystalstacker': {'id': 'CrystalStacker', 'deprecated': False},\n    'cua-opl-1.0': {'id': 'CUA-OPL-1.0', 'deprecated': False},\n    'cube': {'id': 'Cube', 'deprecated': False},\n    'curl': {'id': 'curl', 'deprecated': False},\n    'cve-tou': {'id': 'cve-tou', 'deprecated': False},\n    'd-fsl-1.0': {'id': 'D-FSL-1.0', 'deprecated': False},\n    'dec-3-clause': {'id': 'DEC-3-Clause', 'deprecated': False},\n    'diffmark': {'id': 'diffmark', 'deprecated': False},\n    'dl-de-by-2.0': {'id': 'DL-DE-BY-2.0', 'deprecated': False},\n    'dl-de-zero-2.0': {'id': 'DL-DE-ZERO-2.0', 'deprecated': False},\n    'doc': {'id': 'DOC', 'deprecated': False},\n    'docbook-schema': {'id': 'DocBook-Schema', 'deprecated': False},\n    'docbook-xml': {'id': 'DocBook-XML', 'deprecated': False},\n    'dotseqn': {'id': 'Dotseqn', 'deprecated': False},\n    'drl-1.0': {'id': 'DRL-1.0', 'deprecated': False},\n    'drl-1.1': {'id': 'DRL-1.1', 'deprecated': False},\n    'dsdp': {'id': 'DSDP', 'deprecated': False},\n    'dtoa': {'id': 'dtoa', 'deprecated': False},\n    'dvipdfm': {'id': 'dvipdfm', 'deprecated': False},\n    'ecl-1.0': {'id': 'ECL-1.0', 'deprecated': False},\n    'ecl-2.0': {'id': 'ECL-2.0', 'deprecated': False},\n    'ecos-2.0': {'id': 'eCos-2.0', 'deprecated': True},\n    'efl-1.0': {'id': 'EFL-1.0', 'deprecated': False},\n    'efl-2.0': {'id': 'EFL-2.0', 'deprecated': False},\n    'egenix': {'id': 'eGenix', 'deprecated': False},\n    'elastic-2.0': {'id': 'Elastic-2.0', 'deprecated': False},\n    'entessa': {'id': 'Entessa', 'deprecated': False},\n    'epics': {'id': 'EPICS', 'deprecated': False},\n    'epl-1.0': {'id': 'EPL-1.0', 'deprecated': False},\n    'epl-2.0': {'id': 'EPL-2.0', 'deprecated': False},\n    'erlpl-1.1': {'id': 'ErlPL-1.1', 'deprecated': False},\n    'etalab-2.0': {'id': 'etalab-2.0', 'deprecated': False},\n    'eudatagrid': {'id': 'EUDatagrid', 'deprecated': False},\n    'eupl-1.0': {'id': 'EUPL-1.0', 'deprecated': False},\n    'eupl-1.1': {'id': 'EUPL-1.1', 'deprecated': False},\n    'eupl-1.2': {'id': 'EUPL-1.2', 'deprecated': False},\n    'eurosym': {'id': 'Eurosym', 'deprecated': False},\n    'fair': {'id': 'Fair', 'deprecated': False},\n    'fbm': {'id': 'FBM', 'deprecated': False},\n    'fdk-aac': {'id': 'FDK-AAC', 'deprecated': False},\n    'ferguson-twofish': {'id': 'Ferguson-Twofish', 'deprecated': False},\n    'frameworx-1.0': {'id': 'Frameworx-1.0', 'deprecated': False},\n    'freebsd-doc': {'id': 'FreeBSD-DOC', 'deprecated': False},\n    'freeimage': {'id': 'FreeImage', 'deprecated': False},\n    'fsfap': {'id': 'FSFAP', 'deprecated': False},\n    'fsfap-no-warranty-disclaimer': {'id': 'FSFAP-no-warranty-disclaimer', 'deprecated': False},\n    'fsful': {'id': 'FSFUL', 'deprecated': False},\n    'fsfullr': {'id': 'FSFULLR', 'deprecated': False},\n    'fsfullrwd': {'id': 'FSFULLRWD', 'deprecated': False},\n    'ftl': {'id': 'FTL', 'deprecated': False},\n    'furuseth': {'id': 'Furuseth', 'deprecated': False},\n    'fwlw': {'id': 'fwlw', 'deprecated': False},\n    'gcr-docs': {'id': 'GCR-docs', 'deprecated': False},\n    'gd': {'id': 'GD', 'deprecated': False},\n    'gfdl-1.1': {'id': 'GFDL-1.1', 'deprecated': True},\n    'gfdl-1.1-invariants-only': {'id': 'GFDL-1.1-invariants-only', 'deprecated': False},\n    'gfdl-1.1-invariants-or-later': {'id': 'GFDL-1.1-invariants-or-later', 'deprecated': False},\n    'gfdl-1.1-no-invariants-only': {'id': 'GFDL-1.1-no-invariants-only', 'deprecated': False},\n    'gfdl-1.1-no-invariants-or-later': {'id': 'GFDL-1.1-no-invariants-or-later', 'deprecated': False},\n    'gfdl-1.1-only': {'id': 'GFDL-1.1-only', 'deprecated': False},\n    'gfdl-1.1-or-later': {'id': 'GFDL-1.1-or-later', 'deprecated': False},\n    'gfdl-1.2': {'id': 'GFDL-1.2', 'deprecated': True},\n    'gfdl-1.2-invariants-only': {'id': 'GFDL-1.2-invariants-only', 'deprecated': False},\n    'gfdl-1.2-invariants-or-later': {'id': 'GFDL-1.2-invariants-or-later', 'deprecated': False},\n    'gfdl-1.2-no-invariants-only': {'id': 'GFDL-1.2-no-invariants-only', 'deprecated': False},\n    'gfdl-1.2-no-invariants-or-later': {'id': 'GFDL-1.2-no-invariants-or-later', 'deprecated': False},\n    'gfdl-1.2-only': {'id': 'GFDL-1.2-only', 'deprecated': False},\n    'gfdl-1.2-or-later': {'id': 'GFDL-1.2-or-later', 'deprecated': False},\n    'gfdl-1.3': {'id': 'GFDL-1.3', 'deprecated': True},\n    'gfdl-1.3-invariants-only': {'id': 'GFDL-1.3-invariants-only', 'deprecated': False},\n    'gfdl-1.3-invariants-or-later': {'id': 'GFDL-1.3-invariants-or-later', 'deprecated': False},\n    'gfdl-1.3-no-invariants-only': {'id': 'GFDL-1.3-no-invariants-only', 'deprecated': False},\n    'gfdl-1.3-no-invariants-or-later': {'id': 'GFDL-1.3-no-invariants-or-later', 'deprecated': False},\n    'gfdl-1.3-only': {'id': 'GFDL-1.3-only', 'deprecated': False},\n    'gfdl-1.3-or-later': {'id': 'GFDL-1.3-or-later', 'deprecated': False},\n    'giftware': {'id': 'Giftware', 'deprecated': False},\n    'gl2ps': {'id': 'GL2PS', 'deprecated': False},\n    'glide': {'id': 'Glide', 'deprecated': False},\n    'glulxe': {'id': 'Glulxe', 'deprecated': False},\n    'glwtpl': {'id': 'GLWTPL', 'deprecated': False},\n    'gnuplot': {'id': 'gnuplot', 'deprecated': False},\n    'gpl-1.0': {'id': 'GPL-1.0', 'deprecated': True},\n    'gpl-1.0+': {'id': 'GPL-1.0+', 'deprecated': True},\n    'gpl-1.0-only': {'id': 'GPL-1.0-only', 'deprecated': False},\n    'gpl-1.0-or-later': {'id': 'GPL-1.0-or-later', 'deprecated': False},\n    'gpl-2.0': {'id': 'GPL-2.0', 'deprecated': True},\n    'gpl-2.0+': {'id': 'GPL-2.0+', 'deprecated': True},\n    'gpl-2.0-only': {'id': 'GPL-2.0-only', 'deprecated': False},\n    'gpl-2.0-or-later': {'id': 'GPL-2.0-or-later', 'deprecated': False},\n    'gpl-2.0-with-autoconf-exception': {'id': 'GPL-2.0-with-autoconf-exception', 'deprecated': True},\n    'gpl-2.0-with-bison-exception': {'id': 'GPL-2.0-with-bison-exception', 'deprecated': True},\n    'gpl-2.0-with-classpath-exception': {'id': 'GPL-2.0-with-classpath-exception', 'deprecated': True},\n    'gpl-2.0-with-font-exception': {'id': 'GPL-2.0-with-font-exception', 'deprecated': True},\n    'gpl-2.0-with-gcc-exception': {'id': 'GPL-2.0-with-GCC-exception', 'deprecated': True},\n    'gpl-3.0': {'id': 'GPL-3.0', 'deprecated': True},\n    'gpl-3.0+': {'id': 'GPL-3.0+', 'deprecated': True},\n    'gpl-3.0-only': {'id': 'GPL-3.0-only', 'deprecated': False},\n    'gpl-3.0-or-later': {'id': 'GPL-3.0-or-later', 'deprecated': False},\n    'gpl-3.0-with-autoconf-exception': {'id': 'GPL-3.0-with-autoconf-exception', 'deprecated': True},\n    'gpl-3.0-with-gcc-exception': {'id': 'GPL-3.0-with-GCC-exception', 'deprecated': True},\n    'graphics-gems': {'id': 'Graphics-Gems', 'deprecated': False},\n    'gsoap-1.3b': {'id': 'gSOAP-1.3b', 'deprecated': False},\n    'gtkbook': {'id': 'gtkbook', 'deprecated': False},\n    'gutmann': {'id': 'Gutmann', 'deprecated': False},\n    'haskellreport': {'id': 'HaskellReport', 'deprecated': False},\n    'hdparm': {'id': 'hdparm', 'deprecated': False},\n    'hidapi': {'id': 'HIDAPI', 'deprecated': False},\n    'hippocratic-2.1': {'id': 'Hippocratic-2.1', 'deprecated': False},\n    'hp-1986': {'id': 'HP-1986', 'deprecated': False},\n    'hp-1989': {'id': 'HP-1989', 'deprecated': False},\n    'hpnd': {'id': 'HPND', 'deprecated': False},\n    'hpnd-dec': {'id': 'HPND-DEC', 'deprecated': False},\n    'hpnd-doc': {'id': 'HPND-doc', 'deprecated': False},\n    'hpnd-doc-sell': {'id': 'HPND-doc-sell', 'deprecated': False},\n    'hpnd-export-us': {'id': 'HPND-export-US', 'deprecated': False},\n    'hpnd-export-us-acknowledgement': {'id': 'HPND-export-US-acknowledgement', 'deprecated': False},\n    'hpnd-export-us-modify': {'id': 'HPND-export-US-modify', 'deprecated': False},\n    'hpnd-export2-us': {'id': 'HPND-export2-US', 'deprecated': False},\n    'hpnd-fenneberg-livingston': {'id': 'HPND-Fenneberg-Livingston', 'deprecated': False},\n    'hpnd-inria-imag': {'id': 'HPND-INRIA-IMAG', 'deprecated': False},\n    'hpnd-intel': {'id': 'HPND-Intel', 'deprecated': False},\n    'hpnd-kevlin-henney': {'id': 'HPND-Kevlin-Henney', 'deprecated': False},\n    'hpnd-markus-kuhn': {'id': 'HPND-Markus-Kuhn', 'deprecated': False},\n    'hpnd-merchantability-variant': {'id': 'HPND-merchantability-variant', 'deprecated': False},\n    'hpnd-mit-disclaimer': {'id': 'HPND-MIT-disclaimer', 'deprecated': False},\n    'hpnd-netrek': {'id': 'HPND-Netrek', 'deprecated': False},\n    'hpnd-pbmplus': {'id': 'HPND-Pbmplus', 'deprecated': False},\n    'hpnd-sell-mit-disclaimer-xserver': {'id': 'HPND-sell-MIT-disclaimer-xserver', 'deprecated': False},\n    'hpnd-sell-regexpr': {'id': 'HPND-sell-regexpr', 'deprecated': False},\n    'hpnd-sell-variant': {'id': 'HPND-sell-variant', 'deprecated': False},\n    'hpnd-sell-variant-mit-disclaimer': {'id': 'HPND-sell-variant-MIT-disclaimer', 'deprecated': False},\n    'hpnd-sell-variant-mit-disclaimer-rev': {'id': 'HPND-sell-variant-MIT-disclaimer-rev', 'deprecated': False},\n    'hpnd-uc': {'id': 'HPND-UC', 'deprecated': False},\n    'hpnd-uc-export-us': {'id': 'HPND-UC-export-US', 'deprecated': False},\n    'htmltidy': {'id': 'HTMLTIDY', 'deprecated': False},\n    'ibm-pibs': {'id': 'IBM-pibs', 'deprecated': False},\n    'icu': {'id': 'ICU', 'deprecated': False},\n    'iec-code-components-eula': {'id': 'IEC-Code-Components-EULA', 'deprecated': False},\n    'ijg': {'id': 'IJG', 'deprecated': False},\n    'ijg-short': {'id': 'IJG-short', 'deprecated': False},\n    'imagemagick': {'id': 'ImageMagick', 'deprecated': False},\n    'imatix': {'id': 'iMatix', 'deprecated': False},\n    'imlib2': {'id': 'Imlib2', 'deprecated': False},\n    'info-zip': {'id': 'Info-ZIP', 'deprecated': False},\n    'inner-net-2.0': {'id': 'Inner-Net-2.0', 'deprecated': False},\n    'intel': {'id': 'Intel', 'deprecated': False},\n    'intel-acpi': {'id': 'Intel-ACPI', 'deprecated': False},\n    'interbase-1.0': {'id': 'Interbase-1.0', 'deprecated': False},\n    'ipa': {'id': 'IPA', 'deprecated': False},\n    'ipl-1.0': {'id': 'IPL-1.0', 'deprecated': False},\n    'isc': {'id': 'ISC', 'deprecated': False},\n    'isc-veillard': {'id': 'ISC-Veillard', 'deprecated': False},\n    'jam': {'id': 'Jam', 'deprecated': False},\n    'jasper-2.0': {'id': 'JasPer-2.0', 'deprecated': False},\n    'jpl-image': {'id': 'JPL-image', 'deprecated': False},\n    'jpnic': {'id': 'JPNIC', 'deprecated': False},\n    'json': {'id': 'JSON', 'deprecated': False},\n    'kastrup': {'id': 'Kastrup', 'deprecated': False},\n    'kazlib': {'id': 'Kazlib', 'deprecated': False},\n    'knuth-ctan': {'id': 'Knuth-CTAN', 'deprecated': False},\n    'lal-1.2': {'id': 'LAL-1.2', 'deprecated': False},\n    'lal-1.3': {'id': 'LAL-1.3', 'deprecated': False},\n    'latex2e': {'id': 'Latex2e', 'deprecated': False},\n    'latex2e-translated-notice': {'id': 'Latex2e-translated-notice', 'deprecated': False},\n    'leptonica': {'id': 'Leptonica', 'deprecated': False},\n    'lgpl-2.0': {'id': 'LGPL-2.0', 'deprecated': True},\n    'lgpl-2.0+': {'id': 'LGPL-2.0+', 'deprecated': True},\n    'lgpl-2.0-only': {'id': 'LGPL-2.0-only', 'deprecated': False},\n    'lgpl-2.0-or-later': {'id': 'LGPL-2.0-or-later', 'deprecated': False},\n    'lgpl-2.1': {'id': 'LGPL-2.1', 'deprecated': True},\n    'lgpl-2.1+': {'id': 'LGPL-2.1+', 'deprecated': True},\n    'lgpl-2.1-only': {'id': 'LGPL-2.1-only', 'deprecated': False},\n    'lgpl-2.1-or-later': {'id': 'LGPL-2.1-or-later', 'deprecated': False},\n    'lgpl-3.0': {'id': 'LGPL-3.0', 'deprecated': True},\n    'lgpl-3.0+': {'id': 'LGPL-3.0+', 'deprecated': True},\n    'lgpl-3.0-only': {'id': 'LGPL-3.0-only', 'deprecated': False},\n    'lgpl-3.0-or-later': {'id': 'LGPL-3.0-or-later', 'deprecated': False},\n    'lgpllr': {'id': 'LGPLLR', 'deprecated': False},\n    'libpng': {'id': 'Libpng', 'deprecated': False},\n    'libpng-2.0': {'id': 'libpng-2.0', 'deprecated': False},\n    'libselinux-1.0': {'id': 'libselinux-1.0', 'deprecated': False},\n    'libtiff': {'id': 'libtiff', 'deprecated': False},\n    'libutil-david-nugent': {'id': 'libutil-David-Nugent', 'deprecated': False},\n    'liliq-p-1.1': {'id': 'LiLiQ-P-1.1', 'deprecated': False},\n    'liliq-r-1.1': {'id': 'LiLiQ-R-1.1', 'deprecated': False},\n    'liliq-rplus-1.1': {'id': 'LiLiQ-Rplus-1.1', 'deprecated': False},\n    'linux-man-pages-1-para': {'id': 'Linux-man-pages-1-para', 'deprecated': False},\n    'linux-man-pages-copyleft': {'id': 'Linux-man-pages-copyleft', 'deprecated': False},\n    'linux-man-pages-copyleft-2-para': {'id': 'Linux-man-pages-copyleft-2-para', 'deprecated': False},\n    'linux-man-pages-copyleft-var': {'id': 'Linux-man-pages-copyleft-var', 'deprecated': False},\n    'linux-openib': {'id': 'Linux-OpenIB', 'deprecated': False},\n    'loop': {'id': 'LOOP', 'deprecated': False},\n    'lpd-document': {'id': 'LPD-document', 'deprecated': False},\n    'lpl-1.0': {'id': 'LPL-1.0', 'deprecated': False},\n    'lpl-1.02': {'id': 'LPL-1.02', 'deprecated': False},\n    'lppl-1.0': {'id': 'LPPL-1.0', 'deprecated': False},\n    'lppl-1.1': {'id': 'LPPL-1.1', 'deprecated': False},\n    'lppl-1.2': {'id': 'LPPL-1.2', 'deprecated': False},\n    'lppl-1.3a': {'id': 'LPPL-1.3a', 'deprecated': False},\n    'lppl-1.3c': {'id': 'LPPL-1.3c', 'deprecated': False},\n    'lsof': {'id': 'lsof', 'deprecated': False},\n    'lucida-bitmap-fonts': {'id': 'Lucida-Bitmap-Fonts', 'deprecated': False},\n    'lzma-sdk-9.11-to-9.20': {'id': 'LZMA-SDK-9.11-to-9.20', 'deprecated': False},\n    'lzma-sdk-9.22': {'id': 'LZMA-SDK-9.22', 'deprecated': False},\n    'mackerras-3-clause': {'id': 'Mackerras-3-Clause', 'deprecated': False},\n    'mackerras-3-clause-acknowledgment': {'id': 'Mackerras-3-Clause-acknowledgment', 'deprecated': False},\n    'magaz': {'id': 'magaz', 'deprecated': False},\n    'mailprio': {'id': 'mailprio', 'deprecated': False},\n    'makeindex': {'id': 'MakeIndex', 'deprecated': False},\n    'martin-birgmeier': {'id': 'Martin-Birgmeier', 'deprecated': False},\n    'mcphee-slideshow': {'id': 'McPhee-slideshow', 'deprecated': False},\n    'metamail': {'id': 'metamail', 'deprecated': False},\n    'minpack': {'id': 'Minpack', 'deprecated': False},\n    'miros': {'id': 'MirOS', 'deprecated': False},\n    'mit': {'id': 'MIT', 'deprecated': False},\n    'mit-0': {'id': 'MIT-0', 'deprecated': False},\n    'mit-advertising': {'id': 'MIT-advertising', 'deprecated': False},\n    'mit-cmu': {'id': 'MIT-CMU', 'deprecated': False},\n    'mit-enna': {'id': 'MIT-enna', 'deprecated': False},\n    'mit-feh': {'id': 'MIT-feh', 'deprecated': False},\n    'mit-festival': {'id': 'MIT-Festival', 'deprecated': False},\n    'mit-khronos-old': {'id': 'MIT-Khronos-old', 'deprecated': False},\n    'mit-modern-variant': {'id': 'MIT-Modern-Variant', 'deprecated': False},\n    'mit-open-group': {'id': 'MIT-open-group', 'deprecated': False},\n    'mit-testregex': {'id': 'MIT-testregex', 'deprecated': False},\n    'mit-wu': {'id': 'MIT-Wu', 'deprecated': False},\n    'mitnfa': {'id': 'MITNFA', 'deprecated': False},\n    'mmixware': {'id': 'MMIXware', 'deprecated': False},\n    'motosoto': {'id': 'Motosoto', 'deprecated': False},\n    'mpeg-ssg': {'id': 'MPEG-SSG', 'deprecated': False},\n    'mpi-permissive': {'id': 'mpi-permissive', 'deprecated': False},\n    'mpich2': {'id': 'mpich2', 'deprecated': False},\n    'mpl-1.0': {'id': 'MPL-1.0', 'deprecated': False},\n    'mpl-1.1': {'id': 'MPL-1.1', 'deprecated': False},\n    'mpl-2.0': {'id': 'MPL-2.0', 'deprecated': False},\n    'mpl-2.0-no-copyleft-exception': {'id': 'MPL-2.0-no-copyleft-exception', 'deprecated': False},\n    'mplus': {'id': 'mplus', 'deprecated': False},\n    'ms-lpl': {'id': 'MS-LPL', 'deprecated': False},\n    'ms-pl': {'id': 'MS-PL', 'deprecated': False},\n    'ms-rl': {'id': 'MS-RL', 'deprecated': False},\n    'mtll': {'id': 'MTLL', 'deprecated': False},\n    'mulanpsl-1.0': {'id': 'MulanPSL-1.0', 'deprecated': False},\n    'mulanpsl-2.0': {'id': 'MulanPSL-2.0', 'deprecated': False},\n    'multics': {'id': 'Multics', 'deprecated': False},\n    'mup': {'id': 'Mup', 'deprecated': False},\n    'naist-2003': {'id': 'NAIST-2003', 'deprecated': False},\n    'nasa-1.3': {'id': 'NASA-1.3', 'deprecated': False},\n    'naumen': {'id': 'Naumen', 'deprecated': False},\n    'nbpl-1.0': {'id': 'NBPL-1.0', 'deprecated': False},\n    'ncbi-pd': {'id': 'NCBI-PD', 'deprecated': False},\n    'ncgl-uk-2.0': {'id': 'NCGL-UK-2.0', 'deprecated': False},\n    'ncl': {'id': 'NCL', 'deprecated': False},\n    'ncsa': {'id': 'NCSA', 'deprecated': False},\n    'net-snmp': {'id': 'Net-SNMP', 'deprecated': True},\n    'netcdf': {'id': 'NetCDF', 'deprecated': False},\n    'newsletr': {'id': 'Newsletr', 'deprecated': False},\n    'ngpl': {'id': 'NGPL', 'deprecated': False},\n    'nicta-1.0': {'id': 'NICTA-1.0', 'deprecated': False},\n    'nist-pd': {'id': 'NIST-PD', 'deprecated': False},\n    'nist-pd-fallback': {'id': 'NIST-PD-fallback', 'deprecated': False},\n    'nist-software': {'id': 'NIST-Software', 'deprecated': False},\n    'nlod-1.0': {'id': 'NLOD-1.0', 'deprecated': False},\n    'nlod-2.0': {'id': 'NLOD-2.0', 'deprecated': False},\n    'nlpl': {'id': 'NLPL', 'deprecated': False},\n    'nokia': {'id': 'Nokia', 'deprecated': False},\n    'nosl': {'id': 'NOSL', 'deprecated': False},\n    'noweb': {'id': 'Noweb', 'deprecated': False},\n    'npl-1.0': {'id': 'NPL-1.0', 'deprecated': False},\n    'npl-1.1': {'id': 'NPL-1.1', 'deprecated': False},\n    'nposl-3.0': {'id': 'NPOSL-3.0', 'deprecated': False},\n    'nrl': {'id': 'NRL', 'deprecated': False},\n    'ntp': {'id': 'NTP', 'deprecated': False},\n    'ntp-0': {'id': 'NTP-0', 'deprecated': False},\n    'nunit': {'id': 'Nunit', 'deprecated': True},\n    'o-uda-1.0': {'id': 'O-UDA-1.0', 'deprecated': False},\n    'oar': {'id': 'OAR', 'deprecated': False},\n    'occt-pl': {'id': 'OCCT-PL', 'deprecated': False},\n    'oclc-2.0': {'id': 'OCLC-2.0', 'deprecated': False},\n    'odbl-1.0': {'id': 'ODbL-1.0', 'deprecated': False},\n    'odc-by-1.0': {'id': 'ODC-By-1.0', 'deprecated': False},\n    'offis': {'id': 'OFFIS', 'deprecated': False},\n    'ofl-1.0': {'id': 'OFL-1.0', 'deprecated': False},\n    'ofl-1.0-no-rfn': {'id': 'OFL-1.0-no-RFN', 'deprecated': False},\n    'ofl-1.0-rfn': {'id': 'OFL-1.0-RFN', 'deprecated': False},\n    'ofl-1.1': {'id': 'OFL-1.1', 'deprecated': False},\n    'ofl-1.1-no-rfn': {'id': 'OFL-1.1-no-RFN', 'deprecated': False},\n    'ofl-1.1-rfn': {'id': 'OFL-1.1-RFN', 'deprecated': False},\n    'ogc-1.0': {'id': 'OGC-1.0', 'deprecated': False},\n    'ogdl-taiwan-1.0': {'id': 'OGDL-Taiwan-1.0', 'deprecated': False},\n    'ogl-canada-2.0': {'id': 'OGL-Canada-2.0', 'deprecated': False},\n    'ogl-uk-1.0': {'id': 'OGL-UK-1.0', 'deprecated': False},\n    'ogl-uk-2.0': {'id': 'OGL-UK-2.0', 'deprecated': False},\n    'ogl-uk-3.0': {'id': 'OGL-UK-3.0', 'deprecated': False},\n    'ogtsl': {'id': 'OGTSL', 'deprecated': False},\n    'oldap-1.1': {'id': 'OLDAP-1.1', 'deprecated': False},\n    'oldap-1.2': {'id': 'OLDAP-1.2', 'deprecated': False},\n    'oldap-1.3': {'id': 'OLDAP-1.3', 'deprecated': False},\n    'oldap-1.4': {'id': 'OLDAP-1.4', 'deprecated': False},\n    'oldap-2.0': {'id': 'OLDAP-2.0', 'deprecated': False},\n    'oldap-2.0.1': {'id': 'OLDAP-2.0.1', 'deprecated': False},\n    'oldap-2.1': {'id': 'OLDAP-2.1', 'deprecated': False},\n    'oldap-2.2': {'id': 'OLDAP-2.2', 'deprecated': False},\n    'oldap-2.2.1': {'id': 'OLDAP-2.2.1', 'deprecated': False},\n    'oldap-2.2.2': {'id': 'OLDAP-2.2.2', 'deprecated': False},\n    'oldap-2.3': {'id': 'OLDAP-2.3', 'deprecated': False},\n    'oldap-2.4': {'id': 'OLDAP-2.4', 'deprecated': False},\n    'oldap-2.5': {'id': 'OLDAP-2.5', 'deprecated': False},\n    'oldap-2.6': {'id': 'OLDAP-2.6', 'deprecated': False},\n    'oldap-2.7': {'id': 'OLDAP-2.7', 'deprecated': False},\n    'oldap-2.8': {'id': 'OLDAP-2.8', 'deprecated': False},\n    'olfl-1.3': {'id': 'OLFL-1.3', 'deprecated': False},\n    'oml': {'id': 'OML', 'deprecated': False},\n    'openpbs-2.3': {'id': 'OpenPBS-2.3', 'deprecated': False},\n    'openssl': {'id': 'OpenSSL', 'deprecated': False},\n    'openssl-standalone': {'id': 'OpenSSL-standalone', 'deprecated': False},\n    'openvision': {'id': 'OpenVision', 'deprecated': False},\n    'opl-1.0': {'id': 'OPL-1.0', 'deprecated': False},\n    'opl-uk-3.0': {'id': 'OPL-UK-3.0', 'deprecated': False},\n    'opubl-1.0': {'id': 'OPUBL-1.0', 'deprecated': False},\n    'oset-pl-2.1': {'id': 'OSET-PL-2.1', 'deprecated': False},\n    'osl-1.0': {'id': 'OSL-1.0', 'deprecated': False},\n    'osl-1.1': {'id': 'OSL-1.1', 'deprecated': False},\n    'osl-2.0': {'id': 'OSL-2.0', 'deprecated': False},\n    'osl-2.1': {'id': 'OSL-2.1', 'deprecated': False},\n    'osl-3.0': {'id': 'OSL-3.0', 'deprecated': False},\n    'padl': {'id': 'PADL', 'deprecated': False},\n    'parity-6.0.0': {'id': 'Parity-6.0.0', 'deprecated': False},\n    'parity-7.0.0': {'id': 'Parity-7.0.0', 'deprecated': False},\n    'pddl-1.0': {'id': 'PDDL-1.0', 'deprecated': False},\n    'php-3.0': {'id': 'PHP-3.0', 'deprecated': False},\n    'php-3.01': {'id': 'PHP-3.01', 'deprecated': False},\n    'pixar': {'id': 'Pixar', 'deprecated': False},\n    'pkgconf': {'id': 'pkgconf', 'deprecated': False},\n    'plexus': {'id': 'Plexus', 'deprecated': False},\n    'pnmstitch': {'id': 'pnmstitch', 'deprecated': False},\n    'polyform-noncommercial-1.0.0': {'id': 'PolyForm-Noncommercial-1.0.0', 'deprecated': False},\n    'polyform-small-business-1.0.0': {'id': 'PolyForm-Small-Business-1.0.0', 'deprecated': False},\n    'postgresql': {'id': 'PostgreSQL', 'deprecated': False},\n    'ppl': {'id': 'PPL', 'deprecated': False},\n    'psf-2.0': {'id': 'PSF-2.0', 'deprecated': False},\n    'psfrag': {'id': 'psfrag', 'deprecated': False},\n    'psutils': {'id': 'psutils', 'deprecated': False},\n    'python-2.0': {'id': 'Python-2.0', 'deprecated': False},\n    'python-2.0.1': {'id': 'Python-2.0.1', 'deprecated': False},\n    'python-ldap': {'id': 'python-ldap', 'deprecated': False},\n    'qhull': {'id': 'Qhull', 'deprecated': False},\n    'qpl-1.0': {'id': 'QPL-1.0', 'deprecated': False},\n    'qpl-1.0-inria-2004': {'id': 'QPL-1.0-INRIA-2004', 'deprecated': False},\n    'radvd': {'id': 'radvd', 'deprecated': False},\n    'rdisc': {'id': 'Rdisc', 'deprecated': False},\n    'rhecos-1.1': {'id': 'RHeCos-1.1', 'deprecated': False},\n    'rpl-1.1': {'id': 'RPL-1.1', 'deprecated': False},\n    'rpl-1.5': {'id': 'RPL-1.5', 'deprecated': False},\n    'rpsl-1.0': {'id': 'RPSL-1.0', 'deprecated': False},\n    'rsa-md': {'id': 'RSA-MD', 'deprecated': False},\n    'rscpl': {'id': 'RSCPL', 'deprecated': False},\n    'ruby': {'id': 'Ruby', 'deprecated': False},\n    'ruby-pty': {'id': 'Ruby-pty', 'deprecated': False},\n    'sax-pd': {'id': 'SAX-PD', 'deprecated': False},\n    'sax-pd-2.0': {'id': 'SAX-PD-2.0', 'deprecated': False},\n    'saxpath': {'id': 'Saxpath', 'deprecated': False},\n    'scea': {'id': 'SCEA', 'deprecated': False},\n    'schemereport': {'id': 'SchemeReport', 'deprecated': False},\n    'sendmail': {'id': 'Sendmail', 'deprecated': False},\n    'sendmail-8.23': {'id': 'Sendmail-8.23', 'deprecated': False},\n    'sgi-b-1.0': {'id': 'SGI-B-1.0', 'deprecated': False},\n    'sgi-b-1.1': {'id': 'SGI-B-1.1', 'deprecated': False},\n    'sgi-b-2.0': {'id': 'SGI-B-2.0', 'deprecated': False},\n    'sgi-opengl': {'id': 'SGI-OpenGL', 'deprecated': False},\n    'sgp4': {'id': 'SGP4', 'deprecated': False},\n    'shl-0.5': {'id': 'SHL-0.5', 'deprecated': False},\n    'shl-0.51': {'id': 'SHL-0.51', 'deprecated': False},\n    'simpl-2.0': {'id': 'SimPL-2.0', 'deprecated': False},\n    'sissl': {'id': 'SISSL', 'deprecated': False},\n    'sissl-1.2': {'id': 'SISSL-1.2', 'deprecated': False},\n    'sl': {'id': 'SL', 'deprecated': False},\n    'sleepycat': {'id': 'Sleepycat', 'deprecated': False},\n    'smlnj': {'id': 'SMLNJ', 'deprecated': False},\n    'smppl': {'id': 'SMPPL', 'deprecated': False},\n    'snia': {'id': 'SNIA', 'deprecated': False},\n    'snprintf': {'id': 'snprintf', 'deprecated': False},\n    'softsurfer': {'id': 'softSurfer', 'deprecated': False},\n    'soundex': {'id': 'Soundex', 'deprecated': False},\n    'spencer-86': {'id': 'Spencer-86', 'deprecated': False},\n    'spencer-94': {'id': 'Spencer-94', 'deprecated': False},\n    'spencer-99': {'id': 'Spencer-99', 'deprecated': False},\n    'spl-1.0': {'id': 'SPL-1.0', 'deprecated': False},\n    'ssh-keyscan': {'id': 'ssh-keyscan', 'deprecated': False},\n    'ssh-openssh': {'id': 'SSH-OpenSSH', 'deprecated': False},\n    'ssh-short': {'id': 'SSH-short', 'deprecated': False},\n    'ssleay-standalone': {'id': 'SSLeay-standalone', 'deprecated': False},\n    'sspl-1.0': {'id': 'SSPL-1.0', 'deprecated': False},\n    'standardml-nj': {'id': 'StandardML-NJ', 'deprecated': True},\n    'sugarcrm-1.1.3': {'id': 'SugarCRM-1.1.3', 'deprecated': False},\n    'sun-ppp': {'id': 'Sun-PPP', 'deprecated': False},\n    'sun-ppp-2000': {'id': 'Sun-PPP-2000', 'deprecated': False},\n    'sunpro': {'id': 'SunPro', 'deprecated': False},\n    'swl': {'id': 'SWL', 'deprecated': False},\n    'swrule': {'id': 'swrule', 'deprecated': False},\n    'symlinks': {'id': 'Symlinks', 'deprecated': False},\n    'tapr-ohl-1.0': {'id': 'TAPR-OHL-1.0', 'deprecated': False},\n    'tcl': {'id': 'TCL', 'deprecated': False},\n    'tcp-wrappers': {'id': 'TCP-wrappers', 'deprecated': False},\n    'termreadkey': {'id': 'TermReadKey', 'deprecated': False},\n    'tgppl-1.0': {'id': 'TGPPL-1.0', 'deprecated': False},\n    'threeparttable': {'id': 'threeparttable', 'deprecated': False},\n    'tmate': {'id': 'TMate', 'deprecated': False},\n    'torque-1.1': {'id': 'TORQUE-1.1', 'deprecated': False},\n    'tosl': {'id': 'TOSL', 'deprecated': False},\n    'tpdl': {'id': 'TPDL', 'deprecated': False},\n    'tpl-1.0': {'id': 'TPL-1.0', 'deprecated': False},\n    'ttwl': {'id': 'TTWL', 'deprecated': False},\n    'ttyp0': {'id': 'TTYP0', 'deprecated': False},\n    'tu-berlin-1.0': {'id': 'TU-Berlin-1.0', 'deprecated': False},\n    'tu-berlin-2.0': {'id': 'TU-Berlin-2.0', 'deprecated': False},\n    'ubuntu-font-1.0': {'id': 'Ubuntu-font-1.0', 'deprecated': False},\n    'ucar': {'id': 'UCAR', 'deprecated': False},\n    'ucl-1.0': {'id': 'UCL-1.0', 'deprecated': False},\n    'ulem': {'id': 'ulem', 'deprecated': False},\n    'umich-merit': {'id': 'UMich-Merit', 'deprecated': False},\n    'unicode-3.0': {'id': 'Unicode-3.0', 'deprecated': False},\n    'unicode-dfs-2015': {'id': 'Unicode-DFS-2015', 'deprecated': False},\n    'unicode-dfs-2016': {'id': 'Unicode-DFS-2016', 'deprecated': False},\n    'unicode-tou': {'id': 'Unicode-TOU', 'deprecated': False},\n    'unixcrypt': {'id': 'UnixCrypt', 'deprecated': False},\n    'unlicense': {'id': 'Unlicense', 'deprecated': False},\n    'upl-1.0': {'id': 'UPL-1.0', 'deprecated': False},\n    'urt-rle': {'id': 'URT-RLE', 'deprecated': False},\n    'vim': {'id': 'Vim', 'deprecated': False},\n    'vostrom': {'id': 'VOSTROM', 'deprecated': False},\n    'vsl-1.0': {'id': 'VSL-1.0', 'deprecated': False},\n    'w3c': {'id': 'W3C', 'deprecated': False},\n    'w3c-19980720': {'id': 'W3C-19980720', 'deprecated': False},\n    'w3c-20150513': {'id': 'W3C-20150513', 'deprecated': False},\n    'w3m': {'id': 'w3m', 'deprecated': False},\n    'watcom-1.0': {'id': 'Watcom-1.0', 'deprecated': False},\n    'widget-workshop': {'id': 'Widget-Workshop', 'deprecated': False},\n    'wsuipa': {'id': 'Wsuipa', 'deprecated': False},\n    'wtfpl': {'id': 'WTFPL', 'deprecated': False},\n    'wxwindows': {'id': 'wxWindows', 'deprecated': True},\n    'x11': {'id': 'X11', 'deprecated': False},\n    'x11-distribute-modifications-variant': {'id': 'X11-distribute-modifications-variant', 'deprecated': False},\n    'x11-swapped': {'id': 'X11-swapped', 'deprecated': False},\n    'xdebug-1.03': {'id': 'Xdebug-1.03', 'deprecated': False},\n    'xerox': {'id': 'Xerox', 'deprecated': False},\n    'xfig': {'id': 'Xfig', 'deprecated': False},\n    'xfree86-1.1': {'id': 'XFree86-1.1', 'deprecated': False},\n    'xinetd': {'id': 'xinetd', 'deprecated': False},\n    'xkeyboard-config-zinoviev': {'id': 'xkeyboard-config-Zinoviev', 'deprecated': False},\n    'xlock': {'id': 'xlock', 'deprecated': False},\n    'xnet': {'id': 'Xnet', 'deprecated': False},\n    'xpp': {'id': 'xpp', 'deprecated': False},\n    'xskat': {'id': 'XSkat', 'deprecated': False},\n    'xzoom': {'id': 'xzoom', 'deprecated': False},\n    'ypl-1.0': {'id': 'YPL-1.0', 'deprecated': False},\n    'ypl-1.1': {'id': 'YPL-1.1', 'deprecated': False},\n    'zed': {'id': 'Zed', 'deprecated': False},\n    'zeeff': {'id': 'Zeeff', 'deprecated': False},\n    'zend-2.0': {'id': 'Zend-2.0', 'deprecated': False},\n    'zimbra-1.3': {'id': 'Zimbra-1.3', 'deprecated': False},\n    'zimbra-1.4': {'id': 'Zimbra-1.4', 'deprecated': False},\n    'zlib': {'id': 'Zlib', 'deprecated': False},\n    'zlib-acknowledgement': {'id': 'zlib-acknowledgement', 'deprecated': False},\n    'zpl-1.1': {'id': 'ZPL-1.1', 'deprecated': False},\n    'zpl-2.0': {'id': 'ZPL-2.0', 'deprecated': False},\n    'zpl-2.1': {'id': 'ZPL-2.1', 'deprecated': False},\n}\n\nEXCEPTIONS: dict[str, SPDXException] = {\n    '389-exception': {'id': '389-exception', 'deprecated': False},\n    'asterisk-exception': {'id': 'Asterisk-exception', 'deprecated': False},\n    'asterisk-linking-protocols-exception': {'id': 'Asterisk-linking-protocols-exception', 'deprecated': False},\n    'autoconf-exception-2.0': {'id': 'Autoconf-exception-2.0', 'deprecated': False},\n    'autoconf-exception-3.0': {'id': 'Autoconf-exception-3.0', 'deprecated': False},\n    'autoconf-exception-generic': {'id': 'Autoconf-exception-generic', 'deprecated': False},\n    'autoconf-exception-generic-3.0': {'id': 'Autoconf-exception-generic-3.0', 'deprecated': False},\n    'autoconf-exception-macro': {'id': 'Autoconf-exception-macro', 'deprecated': False},\n    'bison-exception-1.24': {'id': 'Bison-exception-1.24', 'deprecated': False},\n    'bison-exception-2.2': {'id': 'Bison-exception-2.2', 'deprecated': False},\n    'bootloader-exception': {'id': 'Bootloader-exception', 'deprecated': False},\n    'classpath-exception-2.0': {'id': 'Classpath-exception-2.0', 'deprecated': False},\n    'clisp-exception-2.0': {'id': 'CLISP-exception-2.0', 'deprecated': False},\n    'cryptsetup-openssl-exception': {'id': 'cryptsetup-OpenSSL-exception', 'deprecated': False},\n    'digirule-foss-exception': {'id': 'DigiRule-FOSS-exception', 'deprecated': False},\n    'ecos-exception-2.0': {'id': 'eCos-exception-2.0', 'deprecated': False},\n    'erlang-otp-linking-exception': {'id': 'erlang-otp-linking-exception', 'deprecated': False},\n    'fawkes-runtime-exception': {'id': 'Fawkes-Runtime-exception', 'deprecated': False},\n    'fltk-exception': {'id': 'FLTK-exception', 'deprecated': False},\n    'fmt-exception': {'id': 'fmt-exception', 'deprecated': False},\n    'font-exception-2.0': {'id': 'Font-exception-2.0', 'deprecated': False},\n    'freertos-exception-2.0': {'id': 'freertos-exception-2.0', 'deprecated': False},\n    'gcc-exception-2.0': {'id': 'GCC-exception-2.0', 'deprecated': False},\n    'gcc-exception-2.0-note': {'id': 'GCC-exception-2.0-note', 'deprecated': False},\n    'gcc-exception-3.1': {'id': 'GCC-exception-3.1', 'deprecated': False},\n    'gmsh-exception': {'id': 'Gmsh-exception', 'deprecated': False},\n    'gnat-exception': {'id': 'GNAT-exception', 'deprecated': False},\n    'gnome-examples-exception': {'id': 'GNOME-examples-exception', 'deprecated': False},\n    'gnu-compiler-exception': {'id': 'GNU-compiler-exception', 'deprecated': False},\n    'gnu-javamail-exception': {'id': 'gnu-javamail-exception', 'deprecated': False},\n    'gpl-3.0-interface-exception': {'id': 'GPL-3.0-interface-exception', 'deprecated': False},\n    'gpl-3.0-linking-exception': {'id': 'GPL-3.0-linking-exception', 'deprecated': False},\n    'gpl-3.0-linking-source-exception': {'id': 'GPL-3.0-linking-source-exception', 'deprecated': False},\n    'gpl-cc-1.0': {'id': 'GPL-CC-1.0', 'deprecated': False},\n    'gstreamer-exception-2005': {'id': 'GStreamer-exception-2005', 'deprecated': False},\n    'gstreamer-exception-2008': {'id': 'GStreamer-exception-2008', 'deprecated': False},\n    'i2p-gpl-java-exception': {'id': 'i2p-gpl-java-exception', 'deprecated': False},\n    'kicad-libraries-exception': {'id': 'KiCad-libraries-exception', 'deprecated': False},\n    'lgpl-3.0-linking-exception': {'id': 'LGPL-3.0-linking-exception', 'deprecated': False},\n    'libpri-openh323-exception': {'id': 'libpri-OpenH323-exception', 'deprecated': False},\n    'libtool-exception': {'id': 'Libtool-exception', 'deprecated': False},\n    'linux-syscall-note': {'id': 'Linux-syscall-note', 'deprecated': False},\n    'llgpl': {'id': 'LLGPL', 'deprecated': False},\n    'llvm-exception': {'id': 'LLVM-exception', 'deprecated': False},\n    'lzma-exception': {'id': 'LZMA-exception', 'deprecated': False},\n    'mif-exception': {'id': 'mif-exception', 'deprecated': False},\n    'nokia-qt-exception-1.1': {'id': 'Nokia-Qt-exception-1.1', 'deprecated': True},\n    'ocaml-lgpl-linking-exception': {'id': 'OCaml-LGPL-linking-exception', 'deprecated': False},\n    'occt-exception-1.0': {'id': 'OCCT-exception-1.0', 'deprecated': False},\n    'openjdk-assembly-exception-1.0': {'id': 'OpenJDK-assembly-exception-1.0', 'deprecated': False},\n    'openvpn-openssl-exception': {'id': 'openvpn-openssl-exception', 'deprecated': False},\n    'pcre2-exception': {'id': 'PCRE2-exception', 'deprecated': False},\n    'ps-or-pdf-font-exception-20170817': {'id': 'PS-or-PDF-font-exception-20170817', 'deprecated': False},\n    'qpl-1.0-inria-2004-exception': {'id': 'QPL-1.0-INRIA-2004-exception', 'deprecated': False},\n    'qt-gpl-exception-1.0': {'id': 'Qt-GPL-exception-1.0', 'deprecated': False},\n    'qt-lgpl-exception-1.1': {'id': 'Qt-LGPL-exception-1.1', 'deprecated': False},\n    'qwt-exception-1.0': {'id': 'Qwt-exception-1.0', 'deprecated': False},\n    'romic-exception': {'id': 'romic-exception', 'deprecated': False},\n    'rrdtool-floss-exception-2.0': {'id': 'RRDtool-FLOSS-exception-2.0', 'deprecated': False},\n    'sane-exception': {'id': 'SANE-exception', 'deprecated': False},\n    'shl-2.0': {'id': 'SHL-2.0', 'deprecated': False},\n    'shl-2.1': {'id': 'SHL-2.1', 'deprecated': False},\n    'stunnel-exception': {'id': 'stunnel-exception', 'deprecated': False},\n    'swi-exception': {'id': 'SWI-exception', 'deprecated': False},\n    'swift-exception': {'id': 'Swift-exception', 'deprecated': False},\n    'texinfo-exception': {'id': 'Texinfo-exception', 'deprecated': False},\n    'u-boot-exception-2.0': {'id': 'u-boot-exception-2.0', 'deprecated': False},\n    'ubdl-exception': {'id': 'UBDL-exception', 'deprecated': False},\n    'universal-foss-exception-1.0': {'id': 'Universal-FOSS-exception-1.0', 'deprecated': False},\n    'vsftpd-openssl-exception': {'id': 'vsftpd-openssl-exception', 'deprecated': False},\n    'wxwindows-exception-3.1': {'id': 'WxWindows-exception-3.1', 'deprecated': False},\n    'x11vnc-openssl-exception': {'id': 'x11vnc-openssl-exception', 'deprecated': False},\n}\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/packaging/markers.py","size":10561,"sha1":"a33df2510a351b7d15c64b751007a742068602b2","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport operator\nimport os\nimport platform\nimport sys\nfrom typing import Any, Callable, TypedDict, cast\n\nfrom ._parser import MarkerAtom, MarkerList, Op, Value, Variable\nfrom ._parser import parse_marker as _parse_marker\nfrom ._tokenizer import ParserSyntaxError\nfrom .specifiers import InvalidSpecifier, Specifier\nfrom .utils import canonicalize_name\n\n__all__ = [\n    \"InvalidMarker\",\n    \"Marker\",\n    \"UndefinedComparison\",\n    \"UndefinedEnvironmentName\",\n    \"default_environment\",\n]\n\nOperator = Callable[[str, str], bool]\n\n\nclass InvalidMarker(ValueError):\n    \"\"\"\n    An invalid marker was found, users should refer to PEP 508.\n    \"\"\"\n\n\nclass UndefinedComparison(ValueError):\n    \"\"\"\n    An invalid operation was attempted on a value that doesn't support it.\n    \"\"\"\n\n\nclass UndefinedEnvironmentName(ValueError):\n    \"\"\"\n    A name was attempted to be used that does not exist inside of the\n    environment.\n    \"\"\"\n\n\nclass Environment(TypedDict):\n    implementation_name: str\n    \"\"\"The implementation's identifier, e.g. ``'cpython'``.\"\"\"\n\n    implementation_version: str\n    \"\"\"\n    The implementation's version, e.g. ``'3.13.0a2'`` for CPython 3.13.0a2, or\n    ``'7.3.13'`` for PyPy3.10 v7.3.13.\n    \"\"\"\n\n    os_name: str\n    \"\"\"\n    The value of :py:data:`os.name`. The name of the operating system dependent module\n    imported, e.g. ``'posix'``.\n    \"\"\"\n\n    platform_machine: str\n    \"\"\"\n    Returns the machine type, e.g. ``'i386'``.\n\n    An empty string if the value cannot be determined.\n    \"\"\"\n\n    platform_release: str\n    \"\"\"\n    The system's release, e.g. ``'2.2.0'`` or ``'NT'``.\n\n    An empty string if the value cannot be determined.\n    \"\"\"\n\n    platform_system: str\n    \"\"\"\n    The system/OS name, e.g. ``'Linux'``, ``'Windows'`` or ``'Java'``.\n\n    An empty string if the value cannot be determined.\n    \"\"\"\n\n    platform_version: str\n    \"\"\"\n    The system's release version, e.g. ``'#3 on degas'``.\n\n    An empty string if the value cannot be determined.\n    \"\"\"\n\n    python_full_version: str\n    \"\"\"\n    The Python version as string ``'major.minor.patchlevel'``.\n\n    Note that unlike the Python :py:data:`sys.version`, this value will always include\n    the patchlevel (it defaults to 0).\n    \"\"\"\n\n    platform_python_implementation: str\n    \"\"\"\n    A string identifying the Python implementation, e.g. ``'CPython'``.\n    \"\"\"\n\n    python_version: str\n    \"\"\"The Python version as string ``'major.minor'``.\"\"\"\n\n    sys_platform: str\n    \"\"\"\n    This string contains a platform identifier that can be used to append\n    platform-specific components to :py:data:`sys.path`, for instance.\n\n    For Unix systems, except on Linux and AIX, this is the lowercased OS name as\n    returned by ``uname -s`` with the first part of the version as returned by\n    ``uname -r`` appended, e.g. ``'sunos5'`` or ``'freebsd8'``, at the time when Python\n    was built.\n    \"\"\"\n\n\ndef _normalize_extra_values(results: Any) -> Any:\n    \"\"\"\n    Normalize extra values.\n    \"\"\"\n    if isinstance(results[0], tuple):\n        lhs, op, rhs = results[0]\n        if isinstance(lhs, Variable) and lhs.value == \"extra\":\n            normalized_extra = canonicalize_name(rhs.value)\n            rhs = Value(normalized_extra)\n        elif isinstance(rhs, Variable) and rhs.value == \"extra\":\n            normalized_extra = canonicalize_name(lhs.value)\n            lhs = Value(normalized_extra)\n        results[0] = lhs, op, rhs\n    return results\n\n\ndef _format_marker(\n    marker: list[str] | MarkerAtom | str, first: bool | None = True\n) -> str:\n    assert isinstance(marker, (list, tuple, str))\n\n    # Sometimes we have a structure like [[...]] which is a single item list\n    # where the single item is itself it's own list. In that case we want skip\n    # the rest of this function so that we don't get extraneous () on the\n    # outside.\n    if (\n        isinstance(marker, list)\n        and len(marker) == 1\n        and isinstance(marker[0], (list, tuple))\n    ):\n        return _format_marker(marker[0])\n\n    if isinstance(marker, list):\n        inner = (_format_marker(m, first=False) for m in marker)\n        if first:\n            return \" \".join(inner)\n        else:\n            return \"(\" + \" \".join(inner) + \")\"\n    elif isinstance(marker, tuple):\n        return \" \".join([m.serialize() for m in marker])\n    else:\n        return marker\n\n\n_operators: dict[str, Operator] = {\n    \"in\": lambda lhs, rhs: lhs in rhs,\n    \"not in\": lambda lhs, rhs: lhs not in rhs,\n    \"<\": operator.lt,\n    \"<=\": operator.le,\n    \"==\": operator.eq,\n    \"!=\": operator.ne,\n    \">=\": operator.ge,\n    \">\": operator.gt,\n}\n\n\ndef _eval_op(lhs: str, op: Op, rhs: str) -> bool:\n    try:\n        spec = Specifier(\"\".join([op.serialize(), rhs]))\n    except InvalidSpecifier:\n        pass\n    else:\n        return spec.contains(lhs, prereleases=True)\n\n    oper: Operator | None = _operators.get(op.serialize())\n    if oper is None:\n        raise UndefinedComparison(f\"Undefined {op!r} on {lhs!r} and {rhs!r}.\")\n\n    return oper(lhs, rhs)\n\n\ndef _normalize(*values: str, key: str) -> tuple[str, ...]:\n    # PEP 685  Comparison of extra names for optional distribution dependencies\n    # https://peps.python.org/pep-0685/\n    # > When comparing extra names, tools MUST normalize the names being\n    # > compared using the semantics outlined in PEP 503 for names\n    if key == \"extra\":\n        return tuple(canonicalize_name(v) for v in values)\n\n    # other environment markers don't have such standards\n    return values\n\n\ndef _evaluate_markers(markers: MarkerList, environment: dict[str, str]) -> bool:\n    groups: list[list[bool]] = [[]]\n\n    for marker in markers:\n        assert isinstance(marker, (list, tuple, str))\n\n        if isinstance(marker, list):\n            groups[-1].append(_evaluate_markers(marker, environment))\n        elif isinstance(marker, tuple):\n            lhs, op, rhs = marker\n\n            if isinstance(lhs, Variable):\n                environment_key = lhs.value\n                lhs_value = environment[environment_key]\n                rhs_value = rhs.value\n            else:\n                lhs_value = lhs.value\n                environment_key = rhs.value\n                rhs_value = environment[environment_key]\n\n            lhs_value, rhs_value = _normalize(lhs_value, rhs_value, key=environment_key)\n            groups[-1].append(_eval_op(lhs_value, op, rhs_value))\n        else:\n            assert marker in [\"and\", \"or\"]\n            if marker == \"or\":\n                groups.append([])\n\n    return any(all(item) for item in groups)\n\n\ndef format_full_version(info: sys._version_info) -> str:\n    version = f\"{info.major}.{info.minor}.{info.micro}\"\n    kind = info.releaselevel\n    if kind != \"final\":\n        version += kind[0] + str(info.serial)\n    return version\n\n\ndef default_environment() -> Environment:\n    iver = format_full_version(sys.implementation.version)\n    implementation_name = sys.implementation.name\n    return {\n        \"implementation_name\": implementation_name,\n        \"implementation_version\": iver,\n        \"os_name\": os.name,\n        \"platform_machine\": platform.machine(),\n        \"platform_release\": platform.release(),\n        \"platform_system\": platform.system(),\n        \"platform_version\": platform.version(),\n        \"python_full_version\": platform.python_version(),\n        \"platform_python_implementation\": platform.python_implementation(),\n        \"python_version\": \".\".join(platform.python_version_tuple()[:2]),\n        \"sys_platform\": sys.platform,\n    }\n\n\nclass Marker:\n    def __init__(self, marker: str) -> None:\n        # Note: We create a Marker object without calling this constructor in\n        #       packaging.requirements.Requirement. If any additional logic is\n        #       added here, make sure to mirror/adapt Requirement.\n        try:\n            self._markers = _normalize_extra_values(_parse_marker(marker))\n            # The attribute `_markers` can be described in terms of a recursive type:\n            # MarkerList = List[Union[Tuple[Node, ...], str, MarkerList]]\n            #\n            # For example, the following expression:\n            # python_version > \"3.6\" or (python_version == \"3.6\" and os_name == \"unix\")\n            #\n            # is parsed into:\n            # [\n            #     (<Variable('python_version')>, <Op('>')>, <Value('3.6')>),\n            #     'and',\n            #     [\n            #         (<Variable('python_version')>, <Op('==')>, <Value('3.6')>),\n            #         'or',\n            #         (<Variable('os_name')>, <Op('==')>, <Value('unix')>)\n            #     ]\n            # ]\n        except ParserSyntaxError as e:\n            raise InvalidMarker(str(e)) from e\n\n    def __str__(self) -> str:\n        return _format_marker(self._markers)\n\n    def __repr__(self) -> str:\n        return f\"<Marker('{self}')>\"\n\n    def __hash__(self) -> int:\n        return hash((self.__class__.__name__, str(self)))\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, Marker):\n            return NotImplemented\n\n        return str(self) == str(other)\n\n    def evaluate(self, environment: dict[str, str] | None = None) -> bool:\n        \"\"\"Evaluate a marker.\n\n        Return the boolean from evaluating the given marker against the\n        environment. environment is an optional argument to override all or\n        part of the determined environment.\n\n        The environment is determined from the current Python process.\n        \"\"\"\n        current_environment = cast(\"dict[str, str]\", default_environment())\n        current_environment[\"extra\"] = \"\"\n        if environment is not None:\n            current_environment.update(environment)\n            # The API used to allow setting extra to None. We need to handle this\n            # case for backwards compatibility.\n            if current_environment[\"extra\"] is None:\n                current_environment[\"extra\"] = \"\"\n\n        return _evaluate_markers(\n            self._markers, _repair_python_full_version(current_environment)\n        )\n\n\ndef _repair_python_full_version(env: dict[str, str]) -> dict[str, str]:\n    \"\"\"\n    Work around platform.python_version() returning something that is not PEP 440\n    compliant for non-tagged Python builds.\n    \"\"\"\n    if env[\"python_full_version\"].endswith(\"+\"):\n        env[\"python_full_version\"] += \"local\"\n    return env\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/packaging/metadata.py","size":34762,"sha1":"451a6a39253694900b7113e5cb7ba228b4aaf0bb","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport email.feedparser\nimport email.header\nimport email.message\nimport email.parser\nimport email.policy\nimport pathlib\nimport sys\nimport typing\nfrom typing import (\n    Any,\n    Callable,\n    Generic,\n    Literal,\n    TypedDict,\n    cast,\n)\n\nfrom . import licenses, requirements, specifiers, utils\nfrom . import version as version_module\nfrom .licenses import NormalizedLicenseExpression\n\nT = typing.TypeVar(\"T\")\n\n\nif sys.version_info >= (3, 11):  # pragma: no cover\n    ExceptionGroup = ExceptionGroup\nelse:  # pragma: no cover\n\n    class ExceptionGroup(Exception):\n        \"\"\"A minimal implementation of :external:exc:`ExceptionGroup` from Python 3.11.\n\n        If :external:exc:`ExceptionGroup` is already defined by Python itself,\n        that version is used instead.\n        \"\"\"\n\n        message: str\n        exceptions: list[Exception]\n\n        def __init__(self, message: str, exceptions: list[Exception]) -> None:\n            self.message = message\n            self.exceptions = exceptions\n\n        def __repr__(self) -> str:\n            return f\"{self.__class__.__name__}({self.message!r}, {self.exceptions!r})\"\n\n\nclass InvalidMetadata(ValueError):\n    \"\"\"A metadata field contains invalid data.\"\"\"\n\n    field: str\n    \"\"\"The name of the field that contains invalid data.\"\"\"\n\n    def __init__(self, field: str, message: str) -> None:\n        self.field = field\n        super().__init__(message)\n\n\n# The RawMetadata class attempts to make as few assumptions about the underlying\n# serialization formats as possible. The idea is that as long as a serialization\n# formats offer some very basic primitives in *some* way then we can support\n# serializing to and from that format.\nclass RawMetadata(TypedDict, total=False):\n    \"\"\"A dictionary of raw core metadata.\n\n    Each field in core metadata maps to a key of this dictionary (when data is\n    provided). The key is lower-case and underscores are used instead of dashes\n    compared to the equivalent core metadata field. Any core metadata field that\n    can be specified multiple times or can hold multiple values in a single\n    field have a key with a plural name. See :class:`Metadata` whose attributes\n    match the keys of this dictionary.\n\n    Core metadata fields that can be specified multiple times are stored as a\n    list or dict depending on which is appropriate for the field. Any fields\n    which hold multiple values in a single field are stored as a list.\n\n    \"\"\"\n\n    # Metadata 1.0 - PEP 241\n    metadata_version: str\n    name: str\n    version: str\n    platforms: list[str]\n    summary: str\n    description: str\n    keywords: list[str]\n    home_page: str\n    author: str\n    author_email: str\n    license: str\n\n    # Metadata 1.1 - PEP 314\n    supported_platforms: list[str]\n    download_url: str\n    classifiers: list[str]\n    requires: list[str]\n    provides: list[str]\n    obsoletes: list[str]\n\n    # Metadata 1.2 - PEP 345\n    maintainer: str\n    maintainer_email: str\n    requires_dist: list[str]\n    provides_dist: list[str]\n    obsoletes_dist: list[str]\n    requires_python: str\n    requires_external: list[str]\n    project_urls: dict[str, str]\n\n    # Metadata 2.0\n    # PEP 426 attempted to completely revamp the metadata format\n    # but got stuck without ever being able to build consensus on\n    # it and ultimately ended up withdrawn.\n    #\n    # However, a number of tools had started emitting METADATA with\n    # `2.0` Metadata-Version, so for historical reasons, this version\n    # was skipped.\n\n    # Metadata 2.1 - PEP 566\n    description_content_type: str\n    provides_extra: list[str]\n\n    # Metadata 2.2 - PEP 643\n    dynamic: list[str]\n\n    # Metadata 2.3 - PEP 685\n    # No new fields were added in PEP 685, just some edge case were\n    # tightened up to provide better interoptability.\n\n    # Metadata 2.4 - PEP 639\n    license_expression: str\n    license_files: list[str]\n\n\n_STRING_FIELDS = {\n    \"author\",\n    \"author_email\",\n    \"description\",\n    \"description_content_type\",\n    \"download_url\",\n    \"home_page\",\n    \"license\",\n    \"license_expression\",\n    \"maintainer\",\n    \"maintainer_email\",\n    \"metadata_version\",\n    \"name\",\n    \"requires_python\",\n    \"summary\",\n    \"version\",\n}\n\n_LIST_FIELDS = {\n    \"classifiers\",\n    \"dynamic\",\n    \"license_files\",\n    \"obsoletes\",\n    \"obsoletes_dist\",\n    \"platforms\",\n    \"provides\",\n    \"provides_dist\",\n    \"provides_extra\",\n    \"requires\",\n    \"requires_dist\",\n    \"requires_external\",\n    \"supported_platforms\",\n}\n\n_DICT_FIELDS = {\n    \"project_urls\",\n}\n\n\ndef _parse_keywords(data: str) -> list[str]:\n    \"\"\"Split a string of comma-separated keywords into a list of keywords.\"\"\"\n    return [k.strip() for k in data.split(\",\")]\n\n\ndef _parse_project_urls(data: list[str]) -> dict[str, str]:\n    \"\"\"Parse a list of label/URL string pairings separated by a comma.\"\"\"\n    urls = {}\n    for pair in data:\n        # Our logic is slightly tricky here as we want to try and do\n        # *something* reasonable with malformed data.\n        #\n        # The main thing that we have to worry about, is data that does\n        # not have a ',' at all to split the label from the Value. There\n        # isn't a singular right answer here, and we will fail validation\n        # later on (if the caller is validating) so it doesn't *really*\n        # matter, but since the missing value has to be an empty str\n        # and our return value is dict[str, str], if we let the key\n        # be the missing value, then they'd have multiple '' values that\n        # overwrite each other in a accumulating dict.\n        #\n        # The other potentional issue is that it's possible to have the\n        # same label multiple times in the metadata, with no solid \"right\"\n        # answer with what to do in that case. As such, we'll do the only\n        # thing we can, which is treat the field as unparseable and add it\n        # to our list of unparsed fields.\n        parts = [p.strip() for p in pair.split(\",\", 1)]\n        parts.extend([\"\"] * (max(0, 2 - len(parts))))  # Ensure 2 items\n\n        # TODO: The spec doesn't say anything about if the keys should be\n        #       considered case sensitive or not... logically they should\n        #       be case-preserving and case-insensitive, but doing that\n        #       would open up more cases where we might have duplicate\n        #       entries.\n        label, url = parts\n        if label in urls:\n            # The label already exists in our set of urls, so this field\n            # is unparseable, and we can just add the whole thing to our\n            # unparseable data and stop processing it.\n            raise KeyError(\"duplicate labels in project urls\")\n        urls[label] = url\n\n    return urls\n\n\ndef _get_payload(msg: email.message.Message, source: bytes | str) -> str:\n    \"\"\"Get the body of the message.\"\"\"\n    # If our source is a str, then our caller has managed encodings for us,\n    # and we don't need to deal with it.\n    if isinstance(source, str):\n        payload = msg.get_payload()\n        assert isinstance(payload, str)\n        return payload\n    # If our source is a bytes, then we're managing the encoding and we need\n    # to deal with it.\n    else:\n        bpayload = msg.get_payload(decode=True)\n        assert isinstance(bpayload, bytes)\n        try:\n            return bpayload.decode(\"utf8\", \"strict\")\n        except UnicodeDecodeError as exc:\n            raise ValueError(\"payload in an invalid encoding\") from exc\n\n\n# The various parse_FORMAT functions here are intended to be as lenient as\n# possible in their parsing, while still returning a correctly typed\n# RawMetadata.\n#\n# To aid in this, we also generally want to do as little touching of the\n# data as possible, except where there are possibly some historic holdovers\n# that make valid data awkward to work with.\n#\n# While this is a lower level, intermediate format than our ``Metadata``\n# class, some light touch ups can make a massive difference in usability.\n\n# Map METADATA fields to RawMetadata.\n_EMAIL_TO_RAW_MAPPING = {\n    \"author\": \"author\",\n    \"author-email\": \"author_email\",\n    \"classifier\": \"classifiers\",\n    \"description\": \"description\",\n    \"description-content-type\": \"description_content_type\",\n    \"download-url\": \"download_url\",\n    \"dynamic\": \"dynamic\",\n    \"home-page\": \"home_page\",\n    \"keywords\": \"keywords\",\n    \"license\": \"license\",\n    \"license-expression\": \"license_expression\",\n    \"license-file\": \"license_files\",\n    \"maintainer\": \"maintainer\",\n    \"maintainer-email\": \"maintainer_email\",\n    \"metadata-version\": \"metadata_version\",\n    \"name\": \"name\",\n    \"obsoletes\": \"obsoletes\",\n    \"obsoletes-dist\": \"obsoletes_dist\",\n    \"platform\": \"platforms\",\n    \"project-url\": \"project_urls\",\n    \"provides\": \"provides\",\n    \"provides-dist\": \"provides_dist\",\n    \"provides-extra\": \"provides_extra\",\n    \"requires\": \"requires\",\n    \"requires-dist\": \"requires_dist\",\n    \"requires-external\": \"requires_external\",\n    \"requires-python\": \"requires_python\",\n    \"summary\": \"summary\",\n    \"supported-platform\": \"supported_platforms\",\n    \"version\": \"version\",\n}\n_RAW_TO_EMAIL_MAPPING = {raw: email for email, raw in _EMAIL_TO_RAW_MAPPING.items()}\n\n\ndef parse_email(data: bytes | str) -> tuple[RawMetadata, dict[str, list[str]]]:\n    \"\"\"Parse a distribution's metadata stored as email headers (e.g. from ``METADATA``).\n\n    This function returns a two-item tuple of dicts. The first dict is of\n    recognized fields from the core metadata specification. Fields that can be\n    parsed and translated into Python's built-in types are converted\n    appropriately. All other fields are left as-is. Fields that are allowed to\n    appear multiple times are stored as lists.\n\n    The second dict contains all other fields from the metadata. This includes\n    any unrecognized fields. It also includes any fields which are expected to\n    be parsed into a built-in type but were not formatted appropriately. Finally,\n    any fields that are expected to appear only once but are repeated are\n    included in this dict.\n\n    \"\"\"\n    raw: dict[str, str | list[str] | dict[str, str]] = {}\n    unparsed: dict[str, list[str]] = {}\n\n    if isinstance(data, str):\n        parsed = email.parser.Parser(policy=email.policy.compat32).parsestr(data)\n    else:\n        parsed = email.parser.BytesParser(policy=email.policy.compat32).parsebytes(data)\n\n    # We have to wrap parsed.keys() in a set, because in the case of multiple\n    # values for a key (a list), the key will appear multiple times in the\n    # list of keys, but we're avoiding that by using get_all().\n    for name in frozenset(parsed.keys()):\n        # Header names in RFC are case insensitive, so we'll normalize to all\n        # lower case to make comparisons easier.\n        name = name.lower()\n\n        # We use get_all() here, even for fields that aren't multiple use,\n        # because otherwise someone could have e.g. two Name fields, and we\n        # would just silently ignore it rather than doing something about it.\n        headers = parsed.get_all(name) or []\n\n        # The way the email module works when parsing bytes is that it\n        # unconditionally decodes the bytes as ascii using the surrogateescape\n        # handler. When you pull that data back out (such as with get_all() ),\n        # it looks to see if the str has any surrogate escapes, and if it does\n        # it wraps it in a Header object instead of returning the string.\n        #\n        # As such, we'll look for those Header objects, and fix up the encoding.\n        value = []\n        # Flag if we have run into any issues processing the headers, thus\n        # signalling that the data belongs in 'unparsed'.\n        valid_encoding = True\n        for h in headers:\n            # It's unclear if this can return more types than just a Header or\n            # a str, so we'll just assert here to make sure.\n            assert isinstance(h, (email.header.Header, str))\n\n            # If it's a header object, we need to do our little dance to get\n            # the real data out of it. In cases where there is invalid data\n            # we're going to end up with mojibake, but there's no obvious, good\n            # way around that without reimplementing parts of the Header object\n            # ourselves.\n            #\n            # That should be fine since, if mojibacked happens, this key is\n            # going into the unparsed dict anyways.\n            if isinstance(h, email.header.Header):\n                # The Header object stores it's data as chunks, and each chunk\n                # can be independently encoded, so we'll need to check each\n                # of them.\n                chunks: list[tuple[bytes, str | None]] = []\n                for bin, encoding in email.header.decode_header(h):\n                    try:\n                        bin.decode(\"utf8\", \"strict\")\n                    except UnicodeDecodeError:\n                        # Enable mojibake.\n                        encoding = \"latin1\"\n                        valid_encoding = False\n                    else:\n                        encoding = \"utf8\"\n                    chunks.append((bin, encoding))\n\n                # Turn our chunks back into a Header object, then let that\n                # Header object do the right thing to turn them into a\n                # string for us.\n                value.append(str(email.header.make_header(chunks)))\n            # This is already a string, so just add it.\n            else:\n                value.append(h)\n\n        # We've processed all of our values to get them into a list of str,\n        # but we may have mojibake data, in which case this is an unparsed\n        # field.\n        if not valid_encoding:\n            unparsed[name] = value\n            continue\n\n        raw_name = _EMAIL_TO_RAW_MAPPING.get(name)\n        if raw_name is None:\n            # This is a bit of a weird situation, we've encountered a key that\n            # we don't know what it means, so we don't know whether it's meant\n            # to be a list or not.\n            #\n            # Since we can't really tell one way or another, we'll just leave it\n            # as a list, even though it may be a single item list, because that's\n            # what makes the most sense for email headers.\n            unparsed[name] = value\n            continue\n\n        # If this is one of our string fields, then we'll check to see if our\n        # value is a list of a single item. If it is then we'll assume that\n        # it was emitted as a single string, and unwrap the str from inside\n        # the list.\n        #\n        # If it's any other kind of data, then we haven't the faintest clue\n        # what we should parse it as, and we have to just add it to our list\n        # of unparsed stuff.\n        if raw_name in _STRING_FIELDS and len(value) == 1:\n            raw[raw_name] = value[0]\n        # If this is one of our list of string fields, then we can just assign\n        # the value, since email *only* has strings, and our get_all() call\n        # above ensures that this is a list.\n        elif raw_name in _LIST_FIELDS:\n            raw[raw_name] = value\n        # Special Case: Keywords\n        # The keywords field is implemented in the metadata spec as a str,\n        # but it conceptually is a list of strings, and is serialized using\n        # \", \".join(keywords), so we'll do some light data massaging to turn\n        # this into what it logically is.\n        elif raw_name == \"keywords\" and len(value) == 1:\n            raw[raw_name] = _parse_keywords(value[0])\n        # Special Case: Project-URL\n        # The project urls is implemented in the metadata spec as a list of\n        # specially-formatted strings that represent a key and a value, which\n        # is fundamentally a mapping, however the email format doesn't support\n        # mappings in a sane way, so it was crammed into a list of strings\n        # instead.\n        #\n        # We will do a little light data massaging to turn this into a map as\n        # it logically should be.\n        elif raw_name == \"project_urls\":\n            try:\n                raw[raw_name] = _parse_project_urls(value)\n            except KeyError:\n                unparsed[name] = value\n        # Nothing that we've done has managed to parse this, so it'll just\n        # throw it in our unparseable data and move on.\n        else:\n            unparsed[name] = value\n\n    # We need to support getting the Description from the message payload in\n    # addition to getting it from the the headers. This does mean, though, there\n    # is the possibility of it being set both ways, in which case we put both\n    # in 'unparsed' since we don't know which is right.\n    try:\n        payload = _get_payload(parsed, data)\n    except ValueError:\n        unparsed.setdefault(\"description\", []).append(\n            parsed.get_payload(decode=isinstance(data, bytes))  # type: ignore[call-overload]\n        )\n    else:\n        if payload:\n            # Check to see if we've already got a description, if so then both\n            # it, and this body move to unparseable.\n            if \"description\" in raw:\n                description_header = cast(str, raw.pop(\"description\"))\n                unparsed.setdefault(\"description\", []).extend(\n                    [description_header, payload]\n                )\n            elif \"description\" in unparsed:\n                unparsed[\"description\"].append(payload)\n            else:\n                raw[\"description\"] = payload\n\n    # We need to cast our `raw` to a metadata, because a TypedDict only support\n    # literal key names, but we're computing our key names on purpose, but the\n    # way this function is implemented, our `TypedDict` can only have valid key\n    # names.\n    return cast(RawMetadata, raw), unparsed\n\n\n_NOT_FOUND = object()\n\n\n# Keep the two values in sync.\n_VALID_METADATA_VERSIONS = [\"1.0\", \"1.1\", \"1.2\", \"2.1\", \"2.2\", \"2.3\", \"2.4\"]\n_MetadataVersion = Literal[\"1.0\", \"1.1\", \"1.2\", \"2.1\", \"2.2\", \"2.3\", \"2.4\"]\n\n_REQUIRED_ATTRS = frozenset([\"metadata_version\", \"name\", \"version\"])\n\n\nclass _Validator(Generic[T]):\n    \"\"\"Validate a metadata field.\n\n    All _process_*() methods correspond to a core metadata field. The method is\n    called with the field's raw value. If the raw value is valid it is returned\n    in its \"enriched\" form (e.g. ``version.Version`` for the ``Version`` field).\n    If the raw value is invalid, :exc:`InvalidMetadata` is raised (with a cause\n    as appropriate).\n    \"\"\"\n\n    name: str\n    raw_name: str\n    added: _MetadataVersion\n\n    def __init__(\n        self,\n        *,\n        added: _MetadataVersion = \"1.0\",\n    ) -> None:\n        self.added = added\n\n    def __set_name__(self, _owner: Metadata, name: str) -> None:\n        self.name = name\n        self.raw_name = _RAW_TO_EMAIL_MAPPING[name]\n\n    def __get__(self, instance: Metadata, _owner: type[Metadata]) -> T:\n        # With Python 3.8, the caching can be replaced with functools.cached_property().\n        # No need to check the cache as attribute lookup will resolve into the\n        # instance's __dict__ before __get__ is called.\n        cache = instance.__dict__\n        value = instance._raw.get(self.name)\n\n        # To make the _process_* methods easier, we'll check if the value is None\n        # and if this field is NOT a required attribute, and if both of those\n        # things are true, we'll skip the the converter. This will mean that the\n        # converters never have to deal with the None union.\n        if self.name in _REQUIRED_ATTRS or value is not None:\n            try:\n                converter: Callable[[Any], T] = getattr(self, f\"_process_{self.name}\")\n            except AttributeError:\n                pass\n            else:\n                value = converter(value)\n\n        cache[self.name] = value\n        try:\n            del instance._raw[self.name]  # type: ignore[misc]\n        except KeyError:\n            pass\n\n        return cast(T, value)\n\n    def _invalid_metadata(\n        self, msg: str, cause: Exception | None = None\n    ) -> InvalidMetadata:\n        exc = InvalidMetadata(\n            self.raw_name, msg.format_map({\"field\": repr(self.raw_name)})\n        )\n        exc.__cause__ = cause\n        return exc\n\n    def _process_metadata_version(self, value: str) -> _MetadataVersion:\n        # Implicitly makes Metadata-Version required.\n        if value not in _VALID_METADATA_VERSIONS:\n            raise self._invalid_metadata(f\"{value!r} is not a valid metadata version\")\n        return cast(_MetadataVersion, value)\n\n    def _process_name(self, value: str) -> str:\n        if not value:\n            raise self._invalid_metadata(\"{field} is a required field\")\n        # Validate the name as a side-effect.\n        try:\n            utils.canonicalize_name(value, validate=True)\n        except utils.InvalidName as exc:\n            raise self._invalid_metadata(\n                f\"{value!r} is invalid for {{field}}\", cause=exc\n            ) from exc\n        else:\n            return value\n\n    def _process_version(self, value: str) -> version_module.Version:\n        if not value:\n            raise self._invalid_metadata(\"{field} is a required field\")\n        try:\n            return version_module.parse(value)\n        except version_module.InvalidVersion as exc:\n            raise self._invalid_metadata(\n                f\"{value!r} is invalid for {{field}}\", cause=exc\n            ) from exc\n\n    def _process_summary(self, value: str) -> str:\n        \"\"\"Check the field contains no newlines.\"\"\"\n        if \"\\n\" in value:\n            raise self._invalid_metadata(\"{field} must be a single line\")\n        return value\n\n    def _process_description_content_type(self, value: str) -> str:\n        content_types = {\"text/plain\", \"text/x-rst\", \"text/markdown\"}\n        message = email.message.EmailMessage()\n        message[\"content-type\"] = value\n\n        content_type, parameters = (\n            # Defaults to `text/plain` if parsing failed.\n            message.get_content_type().lower(),\n            message[\"content-type\"].params,\n        )\n        # Check if content-type is valid or defaulted to `text/plain` and thus was\n        # not parseable.\n        if content_type not in content_types or content_type not in value.lower():\n            raise self._invalid_metadata(\n                f\"{{field}} must be one of {list(content_types)}, not {value!r}\"\n            )\n\n        charset = parameters.get(\"charset\", \"UTF-8\")\n        if charset != \"UTF-8\":\n            raise self._invalid_metadata(\n                f\"{{field}} can only specify the UTF-8 charset, not {list(charset)}\"\n            )\n\n        markdown_variants = {\"GFM\", \"CommonMark\"}\n        variant = parameters.get(\"variant\", \"GFM\")  # Use an acceptable default.\n        if content_type == \"text/markdown\" and variant not in markdown_variants:\n            raise self._invalid_metadata(\n                f\"valid Markdown variants for {{field}} are {list(markdown_variants)}, \"\n                f\"not {variant!r}\",\n            )\n        return value\n\n    def _process_dynamic(self, value: list[str]) -> list[str]:\n        for dynamic_field in map(str.lower, value):\n            if dynamic_field in {\"name\", \"version\", \"metadata-version\"}:\n                raise self._invalid_metadata(\n                    f\"{dynamic_field!r} is not allowed as a dynamic field\"\n                )\n            elif dynamic_field not in _EMAIL_TO_RAW_MAPPING:\n                raise self._invalid_metadata(\n                    f\"{dynamic_field!r} is not a valid dynamic field\"\n                )\n        return list(map(str.lower, value))\n\n    def _process_provides_extra(\n        self,\n        value: list[str],\n    ) -> list[utils.NormalizedName]:\n        normalized_names = []\n        try:\n            for name in value:\n                normalized_names.append(utils.canonicalize_name(name, validate=True))\n        except utils.InvalidName as exc:\n            raise self._invalid_metadata(\n                f\"{name!r} is invalid for {{field}}\", cause=exc\n            ) from exc\n        else:\n            return normalized_names\n\n    def _process_requires_python(self, value: str) -> specifiers.SpecifierSet:\n        try:\n            return specifiers.SpecifierSet(value)\n        except specifiers.InvalidSpecifier as exc:\n            raise self._invalid_metadata(\n                f\"{value!r} is invalid for {{field}}\", cause=exc\n            ) from exc\n\n    def _process_requires_dist(\n        self,\n        value: list[str],\n    ) -> list[requirements.Requirement]:\n        reqs = []\n        try:\n            for req in value:\n                reqs.append(requirements.Requirement(req))\n        except requirements.InvalidRequirement as exc:\n            raise self._invalid_metadata(\n                f\"{req!r} is invalid for {{field}}\", cause=exc\n            ) from exc\n        else:\n            return reqs\n\n    def _process_license_expression(\n        self, value: str\n    ) -> NormalizedLicenseExpression | None:\n        try:\n            return licenses.canonicalize_license_expression(value)\n        except ValueError as exc:\n            raise self._invalid_metadata(\n                f\"{value!r} is invalid for {{field}}\", cause=exc\n            ) from exc\n\n    def _process_license_files(self, value: list[str]) -> list[str]:\n        paths = []\n        for path in value:\n            if \"..\" in path:\n                raise self._invalid_metadata(\n                    f\"{path!r} is invalid for {{field}}, \"\n                    \"parent directory indicators are not allowed\"\n                )\n            if \"*\" in path:\n                raise self._invalid_metadata(\n                    f\"{path!r} is invalid for {{field}}, paths must be resolved\"\n                )\n            if (\n                pathlib.PurePosixPath(path).is_absolute()\n                or pathlib.PureWindowsPath(path).is_absolute()\n            ):\n                raise self._invalid_metadata(\n                    f\"{path!r} is invalid for {{field}}, paths must be relative\"\n                )\n            if pathlib.PureWindowsPath(path).as_posix() != path:\n                raise self._invalid_metadata(\n                    f\"{path!r} is invalid for {{field}}, \"\n                    \"paths must use '/' delimiter\"\n                )\n            paths.append(path)\n        return paths\n\n\nclass Metadata:\n    \"\"\"Representation of distribution metadata.\n\n    Compared to :class:`RawMetadata`, this class provides objects representing\n    metadata fields instead of only using built-in types. Any invalid metadata\n    will cause :exc:`InvalidMetadata` to be raised (with a\n    :py:attr:`~BaseException.__cause__` attribute as appropriate).\n    \"\"\"\n\n    _raw: RawMetadata\n\n    @classmethod\n    def from_raw(cls, data: RawMetadata, *, validate: bool = True) -> Metadata:\n        \"\"\"Create an instance from :class:`RawMetadata`.\n\n        If *validate* is true, all metadata will be validated. All exceptions\n        related to validation will be gathered and raised as an :class:`ExceptionGroup`.\n        \"\"\"\n        ins = cls()\n        ins._raw = data.copy()  # Mutations occur due to caching enriched values.\n\n        if validate:\n            exceptions: list[Exception] = []\n            try:\n                metadata_version = ins.metadata_version\n                metadata_age = _VALID_METADATA_VERSIONS.index(metadata_version)\n            except InvalidMetadata as metadata_version_exc:\n                exceptions.append(metadata_version_exc)\n                metadata_version = None\n\n            # Make sure to check for the fields that are present, the required\n            # fields (so their absence can be reported).\n            fields_to_check = frozenset(ins._raw) | _REQUIRED_ATTRS\n            # Remove fields that have already been checked.\n            fields_to_check -= {\"metadata_version\"}\n\n            for key in fields_to_check:\n                try:\n                    if metadata_version:\n                        # Can't use getattr() as that triggers descriptor protocol which\n                        # will fail due to no value for the instance argument.\n                        try:\n                            field_metadata_version = cls.__dict__[key].added\n                        except KeyError:\n                            exc = InvalidMetadata(key, f\"unrecognized field: {key!r}\")\n                            exceptions.append(exc)\n                            continue\n                        field_age = _VALID_METADATA_VERSIONS.index(\n                            field_metadata_version\n                        )\n                        if field_age > metadata_age:\n                            field = _RAW_TO_EMAIL_MAPPING[key]\n                            exc = InvalidMetadata(\n                                field,\n                                f\"{field} introduced in metadata version \"\n                                f\"{field_metadata_version}, not {metadata_version}\",\n                            )\n                            exceptions.append(exc)\n                            continue\n                    getattr(ins, key)\n                except InvalidMetadata as exc:\n                    exceptions.append(exc)\n\n            if exceptions:\n                raise ExceptionGroup(\"invalid metadata\", exceptions)\n\n        return ins\n\n    @classmethod\n    def from_email(cls, data: bytes | str, *, validate: bool = True) -> Metadata:\n        \"\"\"Parse metadata from email headers.\n\n        If *validate* is true, the metadata will be validated. All exceptions\n        related to validation will be gathered and raised as an :class:`ExceptionGroup`.\n        \"\"\"\n        raw, unparsed = parse_email(data)\n\n        if validate:\n            exceptions: list[Exception] = []\n            for unparsed_key in unparsed:\n                if unparsed_key in _EMAIL_TO_RAW_MAPPING:\n                    message = f\"{unparsed_key!r} has invalid data\"\n                else:\n                    message = f\"unrecognized field: {unparsed_key!r}\"\n                exceptions.append(InvalidMetadata(unparsed_key, message))\n\n            if exceptions:\n                raise ExceptionGroup(\"unparsed\", exceptions)\n\n        try:\n            return cls.from_raw(raw, validate=validate)\n        except ExceptionGroup as exc_group:\n            raise ExceptionGroup(\n                \"invalid or unparsed metadata\", exc_group.exceptions\n            ) from None\n\n    metadata_version: _Validator[_MetadataVersion] = _Validator()\n    \"\"\":external:ref:`core-metadata-metadata-version`\n    (required; validated to be a valid metadata version)\"\"\"\n    # `name` is not normalized/typed to NormalizedName so as to provide access to\n    # the original/raw name.\n    name: _Validator[str] = _Validator()\n    \"\"\":external:ref:`core-metadata-name`\n    (required; validated using :func:`~packaging.utils.canonicalize_name` and its\n    *validate* parameter)\"\"\"\n    version: _Validator[version_module.Version] = _Validator()\n    \"\"\":external:ref:`core-metadata-version` (required)\"\"\"\n    dynamic: _Validator[list[str] | None] = _Validator(\n        added=\"2.2\",\n    )\n    \"\"\":external:ref:`core-metadata-dynamic`\n    (validated against core metadata field names and lowercased)\"\"\"\n    platforms: _Validator[list[str] | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-platform`\"\"\"\n    supported_platforms: _Validator[list[str] | None] = _Validator(added=\"1.1\")\n    \"\"\":external:ref:`core-metadata-supported-platform`\"\"\"\n    summary: _Validator[str | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-summary` (validated to contain no newlines)\"\"\"\n    description: _Validator[str | None] = _Validator()  # TODO 2.1: can be in body\n    \"\"\":external:ref:`core-metadata-description`\"\"\"\n    description_content_type: _Validator[str | None] = _Validator(added=\"2.1\")\n    \"\"\":external:ref:`core-metadata-description-content-type` (validated)\"\"\"\n    keywords: _Validator[list[str] | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-keywords`\"\"\"\n    home_page: _Validator[str | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-home-page`\"\"\"\n    download_url: _Validator[str | None] = _Validator(added=\"1.1\")\n    \"\"\":external:ref:`core-metadata-download-url`\"\"\"\n    author: _Validator[str | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-author`\"\"\"\n    author_email: _Validator[str | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-author-email`\"\"\"\n    maintainer: _Validator[str | None] = _Validator(added=\"1.2\")\n    \"\"\":external:ref:`core-metadata-maintainer`\"\"\"\n    maintainer_email: _Validator[str | None] = _Validator(added=\"1.2\")\n    \"\"\":external:ref:`core-metadata-maintainer-email`\"\"\"\n    license: _Validator[str | None] = _Validator()\n    \"\"\":external:ref:`core-metadata-license`\"\"\"\n    license_expression: _Validator[NormalizedLicenseExpression | None] = _Validator(\n        added=\"2.4\"\n    )\n    \"\"\":external:ref:`core-metadata-license-expression`\"\"\"\n    license_files: _Validator[list[str] | None] = _Validator(added=\"2.4\")\n    \"\"\":external:ref:`core-metadata-license-file`\"\"\"\n    classifiers: _Validator[list[str] | None] = _Validator(added=\"1.1\")\n    \"\"\":external:ref:`core-metadata-classifier`\"\"\"\n    requires_dist: _Validator[list[requirements.Requirement] | None] = _Validator(\n        added=\"1.2\"\n    )\n    \"\"\":external:ref:`core-metadata-requires-dist`\"\"\"\n    requires_python: _Validator[specifiers.SpecifierSet | None] = _Validator(\n        added=\"1.2\"\n    )\n    \"\"\":external:ref:`core-metadata-requires-python`\"\"\"\n    # Because `Requires-External` allows for non-PEP 440 version specifiers, we\n    # don't do any processing on the values.\n    requires_external: _Validator[list[str] | None] = _Validator(added=\"1.2\")\n    \"\"\":external:ref:`core-metadata-requires-external`\"\"\"\n    project_urls: _Validator[dict[str, str] | None] = _Validator(added=\"1.2\")\n    \"\"\":external:ref:`core-metadata-project-url`\"\"\"\n    # PEP 685 lets us raise an error if an extra doesn't pass `Name` validation\n    # regardless of metadata version.\n    provides_extra: _Validator[list[utils.NormalizedName] | None] = _Validator(\n        added=\"2.1\",\n    )\n    \"\"\":external:ref:`core-metadata-provides-extra`\"\"\"\n    provides_dist: _Validator[list[str] | None] = _Validator(added=\"1.2\")\n    \"\"\":external:ref:`core-metadata-provides-dist`\"\"\"\n    obsoletes_dist: _Validator[list[str] | None] = _Validator(added=\"1.2\")\n    \"\"\":external:ref:`core-metadata-obsoletes-dist`\"\"\"\n    requires: _Validator[list[str] | None] = _Validator(added=\"1.1\")\n    \"\"\"``Requires`` (deprecated)\"\"\"\n    provides: _Validator[list[str] | None] = _Validator(added=\"1.1\")\n    \"\"\"``Provides`` (deprecated)\"\"\"\n    obsoletes: _Validator[list[str] | None] = _Validator(added=\"1.1\")\n    \"\"\"``Obsoletes`` (deprecated)\"\"\"\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/packaging/requirements.py","size":2947,"sha1":"1c36b3e629a0f04f56cfcd9854e23639f2c6a639","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\nfrom __future__ import annotations\n\nfrom typing import Any, Iterator\n\nfrom ._parser import parse_requirement as _parse_requirement\nfrom ._tokenizer import ParserSyntaxError\nfrom .markers import Marker, _normalize_extra_values\nfrom .specifiers import SpecifierSet\nfrom .utils import canonicalize_name\n\n\nclass InvalidRequirement(ValueError):\n    \"\"\"\n    An invalid requirement was found, users should refer to PEP 508.\n    \"\"\"\n\n\nclass Requirement:\n    \"\"\"Parse a requirement.\n\n    Parse a given requirement string into its parts, such as name, specifier,\n    URL, and extras. Raises InvalidRequirement on a badly-formed requirement\n    string.\n    \"\"\"\n\n    # TODO: Can we test whether something is contained within a requirement?\n    #       If so how do we do that? Do we need to test against the _name_ of\n    #       the thing as well as the version? What about the markers?\n    # TODO: Can we normalize the name and extra name?\n\n    def __init__(self, requirement_string: str) -> None:\n        try:\n            parsed = _parse_requirement(requirement_string)\n        except ParserSyntaxError as e:\n            raise InvalidRequirement(str(e)) from e\n\n        self.name: str = parsed.name\n        self.url: str | None = parsed.url or None\n        self.extras: set[str] = set(parsed.extras or [])\n        self.specifier: SpecifierSet = SpecifierSet(parsed.specifier)\n        self.marker: Marker | None = None\n        if parsed.marker is not None:\n            self.marker = Marker.__new__(Marker)\n            self.marker._markers = _normalize_extra_values(parsed.marker)\n\n    def _iter_parts(self, name: str) -> Iterator[str]:\n        yield name\n\n        if self.extras:\n            formatted_extras = \",\".join(sorted(self.extras))\n            yield f\"[{formatted_extras}]\"\n\n        if self.specifier:\n            yield str(self.specifier)\n\n        if self.url:\n            yield f\"@ {self.url}\"\n            if self.marker:\n                yield \" \"\n\n        if self.marker:\n            yield f\"; {self.marker}\"\n\n    def __str__(self) -> str:\n        return \"\".join(self._iter_parts(self.name))\n\n    def __repr__(self) -> str:\n        return f\"<Requirement('{self}')>\"\n\n    def __hash__(self) -> int:\n        return hash(\n            (\n                self.__class__.__name__,\n                *self._iter_parts(canonicalize_name(self.name)),\n            )\n        )\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, Requirement):\n            return NotImplemented\n\n        return (\n            canonicalize_name(self.name) == canonicalize_name(other.name)\n            and self.extras == other.extras\n            and self.specifier == other.specifier\n            and self.url == other.url\n            and self.marker == other.marker\n        )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/packaging/specifiers.py","size":40074,"sha1":"58e79d3fe1e6a5d58a6a6d0bda2b47472685b244","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\"\"\"\n.. testsetup::\n\n    from packaging.specifiers import Specifier, SpecifierSet, InvalidSpecifier\n    from packaging.version import Version\n\"\"\"\n\nfrom __future__ import annotations\n\nimport abc\nimport itertools\nimport re\nfrom typing import Callable, Iterable, Iterator, TypeVar, Union\n\nfrom .utils import canonicalize_version\nfrom .version import Version\n\nUnparsedVersion = Union[Version, str]\nUnparsedVersionVar = TypeVar(\"UnparsedVersionVar\", bound=UnparsedVersion)\nCallableOperator = Callable[[Version, str], bool]\n\n\ndef _coerce_version(version: UnparsedVersion) -> Version:\n    if not isinstance(version, Version):\n        version = Version(version)\n    return version\n\n\nclass InvalidSpecifier(ValueError):\n    \"\"\"\n    Raised when attempting to create a :class:`Specifier` with a specifier\n    string that is invalid.\n\n    >>> Specifier(\"lolwat\")\n    Traceback (most recent call last):\n        ...\n    packaging.specifiers.InvalidSpecifier: Invalid specifier: 'lolwat'\n    \"\"\"\n\n\nclass BaseSpecifier(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __str__(self) -> str:\n        \"\"\"\n        Returns the str representation of this Specifier-like object. This\n        should be representative of the Specifier itself.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __hash__(self) -> int:\n        \"\"\"\n        Returns a hash value for this Specifier-like object.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Returns a boolean representing whether or not the two Specifier-like\n        objects are equal.\n\n        :param other: The other object to check against.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def prereleases(self) -> bool | None:\n        \"\"\"Whether or not pre-releases as a whole are allowed.\n\n        This can be set to either ``True`` or ``False`` to explicitly enable or disable\n        prereleases or it can be set to ``None`` (the default) to use default semantics.\n        \"\"\"\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        \"\"\"Setter for :attr:`prereleases`.\n\n        :param value: The value to set.\n        \"\"\"\n\n    @abc.abstractmethod\n    def contains(self, item: str, prereleases: bool | None = None) -> bool:\n        \"\"\"\n        Determines if the given item is contained within this specifier.\n        \"\"\"\n\n    @abc.abstractmethod\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: bool | None = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"\n        Takes an iterable of items and filters them so that only items which\n        are contained within this specifier are allowed in it.\n        \"\"\"\n\n\nclass Specifier(BaseSpecifier):\n    \"\"\"This class abstracts handling of version specifiers.\n\n    .. tip::\n\n        It is generally not required to instantiate this manually. You should instead\n        prefer to work with :class:`SpecifierSet` instead, which can parse\n        comma-separated version specifiers (which is what package metadata contains).\n    \"\"\"\n\n    _operator_regex_str = r\"\"\"\n        (?P<operator>(~=|==|!=|<=|>=|<|>|===))\n        \"\"\"\n    _version_regex_str = r\"\"\"\n        (?P<version>\n            (?:\n                # The identity operators allow for an escape hatch that will\n                # do an exact string match of the version you wish to install.\n                # This will not be parsed by PEP 440 and we cannot determine\n                # any semantic meaning from it. This operator is discouraged\n                # but included entirely as an escape hatch.\n                (?<====)  # Only match for the identity operator\n                \\s*\n                [^\\s;)]*  # The arbitrary version can be just about anything,\n                          # we match everything except for whitespace, a\n                          # semi-colon for marker support, and a closing paren\n                          # since versions can be enclosed in them.\n            )\n            |\n            (?:\n                # The (non)equality operators allow for wild card and local\n                # versions to be specified so we have to define these two\n                # operators separately to enable that.\n                (?<===|!=)            # Only match for equals and not equals\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)*   # release\n\n                # You cannot use a wild card and a pre-release, post-release, a dev or\n                # local version together so group them with a | and make them optional.\n                (?:\n                    \\.\\*  # Wild card syntax of .*\n                    |\n                    (?:                                  # pre release\n                        [-_\\.]?\n                        (alpha|beta|preview|pre|a|b|c|rc)\n                        [-_\\.]?\n                        [0-9]*\n                    )?\n                    (?:                                  # post release\n                        (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                    )?\n                    (?:[-_\\.]?dev[-_\\.]?[0-9]*)?         # dev release\n                    (?:\\+[a-z0-9]+(?:[-_\\.][a-z0-9]+)*)? # local\n                )?\n            )\n            |\n            (?:\n                # The compatible operator requires at least two digits in the\n                # release segment.\n                (?<=~=)               # Only match for the compatible operator\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)+   # release  (We have a + instead of a *)\n                (?:                   # pre release\n                    [-_\\.]?\n                    (alpha|beta|preview|pre|a|b|c|rc)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n                (?:[-_\\.]?dev[-_\\.]?[0-9]*)?          # dev release\n            )\n            |\n            (?:\n                # All other operators only allow a sub set of what the\n                # (non)equality operators do. Specifically they do not allow\n                # local versions to be specified nor do they allow the prefix\n                # matching wild cards.\n                (?<!==|!=|~=)         # We have special cases for these\n                                      # operators so we want to make sure they\n                                      # don't match here.\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)*   # release\n                (?:                   # pre release\n                    [-_\\.]?\n                    (alpha|beta|preview|pre|a|b|c|rc)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n                (?:[-_\\.]?dev[-_\\.]?[0-9]*)?          # dev release\n            )\n        )\n        \"\"\"\n\n    _regex = re.compile(\n        r\"^\\s*\" + _operator_regex_str + _version_regex_str + r\"\\s*$\",\n        re.VERBOSE | re.IGNORECASE,\n    )\n\n    _operators = {\n        \"~=\": \"compatible\",\n        \"==\": \"equal\",\n        \"!=\": \"not_equal\",\n        \"<=\": \"less_than_equal\",\n        \">=\": \"greater_than_equal\",\n        \"<\": \"less_than\",\n        \">\": \"greater_than\",\n        \"===\": \"arbitrary\",\n    }\n\n    def __init__(self, spec: str = \"\", prereleases: bool | None = None) -> None:\n        \"\"\"Initialize a Specifier instance.\n\n        :param spec:\n            The string representation of a specifier which will be parsed and\n            normalized before use.\n        :param prereleases:\n            This tells the specifier if it should accept prerelease versions if\n            applicable or not. The default of ``None`` will autodetect it from the\n            given specifiers.\n        :raises InvalidSpecifier:\n            If the given specifier is invalid (i.e. bad syntax).\n        \"\"\"\n        match = self._regex.search(spec)\n        if not match:\n            raise InvalidSpecifier(f\"Invalid specifier: {spec!r}\")\n\n        self._spec: tuple[str, str] = (\n            match.group(\"operator\").strip(),\n            match.group(\"version\").strip(),\n        )\n\n        # Store whether or not this Specifier should accept prereleases\n        self._prereleases = prereleases\n\n    # https://github.com/python/mypy/pull/13475#pullrequestreview-1079784515\n    @property  # type: ignore[override]\n    def prereleases(self) -> bool:\n        # If there is an explicit prereleases set for this, then we'll just\n        # blindly use that.\n        if self._prereleases is not None:\n            return self._prereleases\n\n        # Look at all of our specifiers and determine if they are inclusive\n        # operators, and if they are if they are including an explicit\n        # prerelease.\n        operator, version = self._spec\n        if operator in [\"==\", \">=\", \"<=\", \"~=\", \"===\", \">\", \"<\"]:\n            # The == specifier can include a trailing .*, if it does we\n            # want to remove before parsing.\n            if operator == \"==\" and version.endswith(\".*\"):\n                version = version[:-2]\n\n            # Parse the version, and if it is a pre-release than this\n            # specifier allows pre-releases.\n            if Version(version).is_prerelease:\n                return True\n\n        return False\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        self._prereleases = value\n\n    @property\n    def operator(self) -> str:\n        \"\"\"The operator of this specifier.\n\n        >>> Specifier(\"==1.2.3\").operator\n        '=='\n        \"\"\"\n        return self._spec[0]\n\n    @property\n    def version(self) -> str:\n        \"\"\"The version of this specifier.\n\n        >>> Specifier(\"==1.2.3\").version\n        '1.2.3'\n        \"\"\"\n        return self._spec[1]\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the Specifier that shows all internal state.\n\n        >>> Specifier('>=1.0.0')\n        <Specifier('>=1.0.0')>\n        >>> Specifier('>=1.0.0', prereleases=False)\n        <Specifier('>=1.0.0', prereleases=False)>\n        >>> Specifier('>=1.0.0', prereleases=True)\n        <Specifier('>=1.0.0', prereleases=True)>\n        \"\"\"\n        pre = (\n            f\", prereleases={self.prereleases!r}\"\n            if self._prereleases is not None\n            else \"\"\n        )\n\n        return f\"<{self.__class__.__name__}({str(self)!r}{pre})>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the Specifier that can be round-tripped.\n\n        >>> str(Specifier('>=1.0.0'))\n        '>=1.0.0'\n        >>> str(Specifier('>=1.0.0', prereleases=False))\n        '>=1.0.0'\n        \"\"\"\n        return \"{}{}\".format(*self._spec)\n\n    @property\n    def _canonical_spec(self) -> tuple[str, str]:\n        canonical_version = canonicalize_version(\n            self._spec[1],\n            strip_trailing_zero=(self._spec[0] != \"~=\"),\n        )\n        return self._spec[0], canonical_version\n\n    def __hash__(self) -> int:\n        return hash(self._canonical_spec)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Whether or not the two Specifier-like objects are equal.\n\n        :param other: The other object to check against.\n\n        The value of :attr:`prereleases` is ignored.\n\n        >>> Specifier(\"==1.2.3\") == Specifier(\"== 1.2.3.0\")\n        True\n        >>> (Specifier(\"==1.2.3\", prereleases=False) ==\n        ...  Specifier(\"==1.2.3\", prereleases=True))\n        True\n        >>> Specifier(\"==1.2.3\") == \"==1.2.3\"\n        True\n        >>> Specifier(\"==1.2.3\") == Specifier(\"==1.2.4\")\n        False\n        >>> Specifier(\"==1.2.3\") == Specifier(\"~=1.2.3\")\n        False\n        \"\"\"\n        if isinstance(other, str):\n            try:\n                other = self.__class__(str(other))\n            except InvalidSpecifier:\n                return NotImplemented\n        elif not isinstance(other, self.__class__):\n            return NotImplemented\n\n        return self._canonical_spec == other._canonical_spec\n\n    def _get_operator(self, op: str) -> CallableOperator:\n        operator_callable: CallableOperator = getattr(\n            self, f\"_compare_{self._operators[op]}\"\n        )\n        return operator_callable\n\n    def _compare_compatible(self, prospective: Version, spec: str) -> bool:\n        # Compatible releases have an equivalent combination of >= and ==. That\n        # is that ~=2.2 is equivalent to >=2.2,==2.*. This allows us to\n        # implement this in terms of the other specifiers instead of\n        # implementing it ourselves. The only thing we need to do is construct\n        # the other specifiers.\n\n        # We want everything but the last item in the version, but we want to\n        # ignore suffix segments.\n        prefix = _version_join(\n            list(itertools.takewhile(_is_not_suffix, _version_split(spec)))[:-1]\n        )\n\n        # Add the prefix notation to the end of our string\n        prefix += \".*\"\n\n        return self._get_operator(\">=\")(prospective, spec) and self._get_operator(\"==\")(\n            prospective, prefix\n        )\n\n    def _compare_equal(self, prospective: Version, spec: str) -> bool:\n        # We need special logic to handle prefix matching\n        if spec.endswith(\".*\"):\n            # In the case of prefix matching we want to ignore local segment.\n            normalized_prospective = canonicalize_version(\n                prospective.public, strip_trailing_zero=False\n            )\n            # Get the normalized version string ignoring the trailing .*\n            normalized_spec = canonicalize_version(spec[:-2], strip_trailing_zero=False)\n            # Split the spec out by bangs and dots, and pretend that there is\n            # an implicit dot in between a release segment and a pre-release segment.\n            split_spec = _version_split(normalized_spec)\n\n            # Split the prospective version out by bangs and dots, and pretend\n            # that there is an implicit dot in between a release segment and\n            # a pre-release segment.\n            split_prospective = _version_split(normalized_prospective)\n\n            # 0-pad the prospective version before shortening it to get the correct\n            # shortened version.\n            padded_prospective, _ = _pad_version(split_prospective, split_spec)\n\n            # Shorten the prospective version to be the same length as the spec\n            # so that we can determine if the specifier is a prefix of the\n            # prospective version or not.\n            shortened_prospective = padded_prospective[: len(split_spec)]\n\n            return shortened_prospective == split_spec\n        else:\n            # Convert our spec string into a Version\n            spec_version = Version(spec)\n\n            # If the specifier does not have a local segment, then we want to\n            # act as if the prospective version also does not have a local\n            # segment.\n            if not spec_version.local:\n                prospective = Version(prospective.public)\n\n            return prospective == spec_version\n\n    def _compare_not_equal(self, prospective: Version, spec: str) -> bool:\n        return not self._compare_equal(prospective, spec)\n\n    def _compare_less_than_equal(self, prospective: Version, spec: str) -> bool:\n        # NB: Local version identifiers are NOT permitted in the version\n        # specifier, so local version labels can be universally removed from\n        # the prospective version.\n        return Version(prospective.public) <= Version(spec)\n\n    def _compare_greater_than_equal(self, prospective: Version, spec: str) -> bool:\n        # NB: Local version identifiers are NOT permitted in the version\n        # specifier, so local version labels can be universally removed from\n        # the prospective version.\n        return Version(prospective.public) >= Version(spec)\n\n    def _compare_less_than(self, prospective: Version, spec_str: str) -> bool:\n        # Convert our spec to a Version instance, since we'll want to work with\n        # it as a version.\n        spec = Version(spec_str)\n\n        # Check to see if the prospective version is less than the spec\n        # version. If it's not we can short circuit and just return False now\n        # instead of doing extra unneeded work.\n        if not prospective < spec:\n            return False\n\n        # This special case is here so that, unless the specifier itself\n        # includes is a pre-release version, that we do not accept pre-release\n        # versions for the version mentioned in the specifier (e.g. <3.1 should\n        # not match 3.1.dev0, but should match 3.0.dev0).\n        if not spec.is_prerelease and prospective.is_prerelease:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # If we've gotten to here, it means that prospective version is both\n        # less than the spec version *and* it's not a pre-release of the same\n        # version in the spec.\n        return True\n\n    def _compare_greater_than(self, prospective: Version, spec_str: str) -> bool:\n        # Convert our spec to a Version instance, since we'll want to work with\n        # it as a version.\n        spec = Version(spec_str)\n\n        # Check to see if the prospective version is greater than the spec\n        # version. If it's not we can short circuit and just return False now\n        # instead of doing extra unneeded work.\n        if not prospective > spec:\n            return False\n\n        # This special case is here so that, unless the specifier itself\n        # includes is a post-release version, that we do not accept\n        # post-release versions for the version mentioned in the specifier\n        # (e.g. >3.1 should not match 3.0.post0, but should match 3.2.post0).\n        if not spec.is_postrelease and prospective.is_postrelease:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # Ensure that we do not allow a local version of the version mentioned\n        # in the specifier, which is technically greater than, to match.\n        if prospective.local is not None:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # If we've gotten to here, it means that prospective version is both\n        # greater than the spec version *and* it's not a pre-release of the\n        # same version in the spec.\n        return True\n\n    def _compare_arbitrary(self, prospective: Version, spec: str) -> bool:\n        return str(prospective).lower() == str(spec).lower()\n\n    def __contains__(self, item: str | Version) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item: The item to check for.\n\n        This is used for the ``in`` operator and behaves the same as\n        :meth:`contains` with no ``prereleases`` argument passed.\n\n        >>> \"1.2.3\" in Specifier(\">=1.2.3\")\n        True\n        >>> Version(\"1.2.3\") in Specifier(\">=1.2.3\")\n        True\n        >>> \"1.0.0\" in Specifier(\">=1.2.3\")\n        False\n        >>> \"1.3.0a1\" in Specifier(\">=1.2.3\")\n        False\n        >>> \"1.3.0a1\" in Specifier(\">=1.2.3\", prereleases=True)\n        True\n        \"\"\"\n        return self.contains(item)\n\n    def contains(self, item: UnparsedVersion, prereleases: bool | None = None) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item:\n            The item to check for, which can be a version string or a\n            :class:`Version` instance.\n        :param prereleases:\n            Whether or not to match prereleases with this Specifier. If set to\n            ``None`` (the default), it uses :attr:`prereleases` to determine\n            whether or not prereleases are allowed.\n\n        >>> Specifier(\">=1.2.3\").contains(\"1.2.3\")\n        True\n        >>> Specifier(\">=1.2.3\").contains(Version(\"1.2.3\"))\n        True\n        >>> Specifier(\">=1.2.3\").contains(\"1.0.0\")\n        False\n        >>> Specifier(\">=1.2.3\").contains(\"1.3.0a1\")\n        False\n        >>> Specifier(\">=1.2.3\", prereleases=True).contains(\"1.3.0a1\")\n        True\n        >>> Specifier(\">=1.2.3\").contains(\"1.3.0a1\", prereleases=True)\n        True\n        \"\"\"\n\n        # Determine if prereleases are to be allowed or not.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # Normalize item to a Version, this allows us to have a shortcut for\n        # \"2.0\" in Specifier(\">=2\")\n        normalized_item = _coerce_version(item)\n\n        # Determine if we should be supporting prereleases in this specifier\n        # or not, if we do not support prereleases than we can short circuit\n        # logic if this version is a prereleases.\n        if normalized_item.is_prerelease and not prereleases:\n            return False\n\n        # Actually do the comparison to determine if this item is contained\n        # within this Specifier or not.\n        operator_callable: CallableOperator = self._get_operator(self.operator)\n        return operator_callable(normalized_item, self.version)\n\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: bool | None = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"Filter items in the given iterable, that match the specifier.\n\n        :param iterable:\n            An iterable that can contain version strings and :class:`Version` instances.\n            The items in the iterable will be filtered according to the specifier.\n        :param prereleases:\n            Whether or not to allow prereleases in the returned iterator. If set to\n            ``None`` (the default), it will be intelligently decide whether to allow\n            prereleases or not (based on the :attr:`prereleases` attribute, and\n            whether the only versions matching are prereleases).\n\n        This method is smarter than just ``filter(Specifier().contains, [...])``\n        because it implements the rule from :pep:`440` that a prerelease item\n        SHOULD be accepted if no other versions match the given specifier.\n\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.2.3\", \"1.3\", Version(\"1.4\")]))\n        ['1.2.3', '1.3', <Version('1.4')>]\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.5a1\"]))\n        ['1.5a1']\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        >>> list(Specifier(\">=1.2.3\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n        \"\"\"\n\n        yielded = False\n        found_prereleases = []\n\n        kw = {\"prereleases\": prereleases if prereleases is not None else True}\n\n        # Attempt to iterate over all the values in the iterable and if any of\n        # them match, yield them.\n        for version in iterable:\n            parsed_version = _coerce_version(version)\n\n            if self.contains(parsed_version, **kw):\n                # If our version is a prerelease, and we were not set to allow\n                # prereleases, then we'll store it for later in case nothing\n                # else matches this specifier.\n                if parsed_version.is_prerelease and not (\n                    prereleases or self.prereleases\n                ):\n                    found_prereleases.append(version)\n                # Either this is not a prerelease, or we should have been\n                # accepting prereleases from the beginning.\n                else:\n                    yielded = True\n                    yield version\n\n        # Now that we've iterated over everything, determine if we've yielded\n        # any values, and if we have not and we have any prereleases stored up\n        # then we will go ahead and yield the prereleases.\n        if not yielded and found_prereleases:\n            for version in found_prereleases:\n                yield version\n\n\n_prefix_regex = re.compile(r\"^([0-9]+)((?:a|b|c|rc)[0-9]+)$\")\n\n\ndef _version_split(version: str) -> list[str]:\n    \"\"\"Split version into components.\n\n    The split components are intended for version comparison. The logic does\n    not attempt to retain the original version string, so joining the\n    components back with :func:`_version_join` may not produce the original\n    version string.\n    \"\"\"\n    result: list[str] = []\n\n    epoch, _, rest = version.rpartition(\"!\")\n    result.append(epoch or \"0\")\n\n    for item in rest.split(\".\"):\n        match = _prefix_regex.search(item)\n        if match:\n            result.extend(match.groups())\n        else:\n            result.append(item)\n    return result\n\n\ndef _version_join(components: list[str]) -> str:\n    \"\"\"Join split version components into a version string.\n\n    This function assumes the input came from :func:`_version_split`, where the\n    first component must be the epoch (either empty or numeric), and all other\n    components numeric.\n    \"\"\"\n    epoch, *rest = components\n    return f\"{epoch}!{'.'.join(rest)}\"\n\n\ndef _is_not_suffix(segment: str) -> bool:\n    return not any(\n        segment.startswith(prefix) for prefix in (\"dev\", \"a\", \"b\", \"rc\", \"post\")\n    )\n\n\ndef _pad_version(left: list[str], right: list[str]) -> tuple[list[str], list[str]]:\n    left_split, right_split = [], []\n\n    # Get the release segment of our versions\n    left_split.append(list(itertools.takewhile(lambda x: x.isdigit(), left)))\n    right_split.append(list(itertools.takewhile(lambda x: x.isdigit(), right)))\n\n    # Get the rest of our versions\n    left_split.append(left[len(left_split[0]) :])\n    right_split.append(right[len(right_split[0]) :])\n\n    # Insert our padding\n    left_split.insert(1, [\"0\"] * max(0, len(right_split[0]) - len(left_split[0])))\n    right_split.insert(1, [\"0\"] * max(0, len(left_split[0]) - len(right_split[0])))\n\n    return (\n        list(itertools.chain.from_iterable(left_split)),\n        list(itertools.chain.from_iterable(right_split)),\n    )\n\n\nclass SpecifierSet(BaseSpecifier):\n    \"\"\"This class abstracts handling of a set of version specifiers.\n\n    It can be passed a single specifier (``>=3.0``), a comma-separated list of\n    specifiers (``>=3.0,!=3.1``), or no specifier at all.\n    \"\"\"\n\n    def __init__(\n        self,\n        specifiers: str | Iterable[Specifier] = \"\",\n        prereleases: bool | None = None,\n    ) -> None:\n        \"\"\"Initialize a SpecifierSet instance.\n\n        :param specifiers:\n            The string representation of a specifier or a comma-separated list of\n            specifiers which will be parsed and normalized before use.\n            May also be an iterable of ``Specifier`` instances, which will be used\n            as is.\n        :param prereleases:\n            This tells the SpecifierSet if it should accept prerelease versions if\n            applicable or not. The default of ``None`` will autodetect it from the\n            given specifiers.\n\n        :raises InvalidSpecifier:\n            If the given ``specifiers`` are not parseable than this exception will be\n            raised.\n        \"\"\"\n\n        if isinstance(specifiers, str):\n            # Split on `,` to break each individual specifier into its own item, and\n            # strip each item to remove leading/trailing whitespace.\n            split_specifiers = [s.strip() for s in specifiers.split(\",\") if s.strip()]\n\n            # Make each individual specifier a Specifier and save in a frozen set\n            # for later.\n            self._specs = frozenset(map(Specifier, split_specifiers))\n        else:\n            # Save the supplied specifiers in a frozen set.\n            self._specs = frozenset(specifiers)\n\n        # Store our prereleases value so we can use it later to determine if\n        # we accept prereleases or not.\n        self._prereleases = prereleases\n\n    @property\n    def prereleases(self) -> bool | None:\n        # If we have been given an explicit prerelease modifier, then we'll\n        # pass that through here.\n        if self._prereleases is not None:\n            return self._prereleases\n\n        # If we don't have any specifiers, and we don't have a forced value,\n        # then we'll just return None since we don't know if this should have\n        # pre-releases or not.\n        if not self._specs:\n            return None\n\n        # Otherwise we'll see if any of the given specifiers accept\n        # prereleases, if any of them do we'll return True, otherwise False.\n        return any(s.prereleases for s in self._specs)\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        self._prereleases = value\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the specifier set that shows all internal state.\n\n        Note that the ordering of the individual specifiers within the set may not\n        match the input string.\n\n        >>> SpecifierSet('>=1.0.0,!=2.0.0')\n        <SpecifierSet('!=2.0.0,>=1.0.0')>\n        >>> SpecifierSet('>=1.0.0,!=2.0.0', prereleases=False)\n        <SpecifierSet('!=2.0.0,>=1.0.0', prereleases=False)>\n        >>> SpecifierSet('>=1.0.0,!=2.0.0', prereleases=True)\n        <SpecifierSet('!=2.0.0,>=1.0.0', prereleases=True)>\n        \"\"\"\n        pre = (\n            f\", prereleases={self.prereleases!r}\"\n            if self._prereleases is not None\n            else \"\"\n        )\n\n        return f\"<SpecifierSet({str(self)!r}{pre})>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the specifier set that can be round-tripped.\n\n        Note that the ordering of the individual specifiers within the set may not\n        match the input string.\n\n        >>> str(SpecifierSet(\">=1.0.0,!=1.0.1\"))\n        '!=1.0.1,>=1.0.0'\n        >>> str(SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=False))\n        '!=1.0.1,>=1.0.0'\n        \"\"\"\n        return \",\".join(sorted(str(s) for s in self._specs))\n\n    def __hash__(self) -> int:\n        return hash(self._specs)\n\n    def __and__(self, other: SpecifierSet | str) -> SpecifierSet:\n        \"\"\"Return a SpecifierSet which is a combination of the two sets.\n\n        :param other: The other object to combine with.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") & '<=2.0.0,!=2.0.1'\n        <SpecifierSet('!=1.0.1,!=2.0.1,<=2.0.0,>=1.0.0')>\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") & SpecifierSet('<=2.0.0,!=2.0.1')\n        <SpecifierSet('!=1.0.1,!=2.0.1,<=2.0.0,>=1.0.0')>\n        \"\"\"\n        if isinstance(other, str):\n            other = SpecifierSet(other)\n        elif not isinstance(other, SpecifierSet):\n            return NotImplemented\n\n        specifier = SpecifierSet()\n        specifier._specs = frozenset(self._specs | other._specs)\n\n        if self._prereleases is None and other._prereleases is not None:\n            specifier._prereleases = other._prereleases\n        elif self._prereleases is not None and other._prereleases is None:\n            specifier._prereleases = self._prereleases\n        elif self._prereleases == other._prereleases:\n            specifier._prereleases = self._prereleases\n        else:\n            raise ValueError(\n                \"Cannot combine SpecifierSets with True and False prerelease \"\n                \"overrides.\"\n            )\n\n        return specifier\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Whether or not the two SpecifierSet-like objects are equal.\n\n        :param other: The other object to check against.\n\n        The value of :attr:`prereleases` is ignored.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> (SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=False) ==\n        ...  SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True))\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == \">=1.0.0,!=1.0.1\"\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0,!=1.0.2\")\n        False\n        \"\"\"\n        if isinstance(other, (str, Specifier)):\n            other = SpecifierSet(str(other))\n        elif not isinstance(other, SpecifierSet):\n            return NotImplemented\n\n        return self._specs == other._specs\n\n    def __len__(self) -> int:\n        \"\"\"Returns the number of specifiers in this specifier set.\"\"\"\n        return len(self._specs)\n\n    def __iter__(self) -> Iterator[Specifier]:\n        \"\"\"\n        Returns an iterator over all the underlying :class:`Specifier` instances\n        in this specifier set.\n\n        >>> sorted(SpecifierSet(\">=1.0.0,!=1.0.1\"), key=str)\n        [<Specifier('!=1.0.1')>, <Specifier('>=1.0.0')>]\n        \"\"\"\n        return iter(self._specs)\n\n    def __contains__(self, item: UnparsedVersion) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item: The item to check for.\n\n        This is used for the ``in`` operator and behaves the same as\n        :meth:`contains` with no ``prereleases`` argument passed.\n\n        >>> \"1.2.3\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> Version(\"1.2.3\") in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> \"1.0.1\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        False\n        >>> \"1.3.0a1\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        False\n        >>> \"1.3.0a1\" in SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True)\n        True\n        \"\"\"\n        return self.contains(item)\n\n    def contains(\n        self,\n        item: UnparsedVersion,\n        prereleases: bool | None = None,\n        installed: bool | None = None,\n    ) -> bool:\n        \"\"\"Return whether or not the item is contained in this SpecifierSet.\n\n        :param item:\n            The item to check for, which can be a version string or a\n            :class:`Version` instance.\n        :param prereleases:\n            Whether or not to match prereleases with this SpecifierSet. If set to\n            ``None`` (the default), it uses :attr:`prereleases` to determine\n            whether or not prereleases are allowed.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.2.3\")\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(Version(\"1.2.3\"))\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.0.1\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.3.0a1\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True).contains(\"1.3.0a1\")\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.3.0a1\", prereleases=True)\n        True\n        \"\"\"\n        # Ensure that our item is a Version instance.\n        if not isinstance(item, Version):\n            item = Version(item)\n\n        # Determine if we're forcing a prerelease or not, if we're not forcing\n        # one for this particular filter call, then we'll use whatever the\n        # SpecifierSet thinks for whether or not we should support prereleases.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # We can determine if we're going to allow pre-releases by looking to\n        # see if any of the underlying items supports them. If none of them do\n        # and this item is a pre-release then we do not allow it and we can\n        # short circuit that here.\n        # Note: This means that 1.0.dev1 would not be contained in something\n        #       like >=1.0.devabc however it would be in >=1.0.debabc,>0.0.dev0\n        if not prereleases and item.is_prerelease:\n            return False\n\n        if installed and item.is_prerelease:\n            item = Version(item.base_version)\n\n        # We simply dispatch to the underlying specs here to make sure that the\n        # given version is contained within all of them.\n        # Note: This use of all() here means that an empty set of specifiers\n        #       will always return True, this is an explicit design decision.\n        return all(s.contains(item, prereleases=prereleases) for s in self._specs)\n\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: bool | None = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"Filter items in the given iterable, that match the specifiers in this set.\n\n        :param iterable:\n            An iterable that can contain version strings and :class:`Version` instances.\n            The items in the iterable will be filtered according to the specifier.\n        :param prereleases:\n            Whether or not to allow prereleases in the returned iterator. If set to\n            ``None`` (the default), it will be intelligently decide whether to allow\n            prereleases or not (based on the :attr:`prereleases` attribute, and\n            whether the only versions matching are prereleases).\n\n        This method is smarter than just ``filter(SpecifierSet(...).contains, [...])``\n        because it implements the rule from :pep:`440` that a prerelease item\n        SHOULD be accepted if no other versions match the given specifier.\n\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.3\", Version(\"1.4\")]))\n        ['1.3', <Version('1.4')>]\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.5a1\"]))\n        []\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        >>> list(SpecifierSet(\">=1.2.3\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n\n        An \"empty\" SpecifierSet will filter items based on the presence of prerelease\n        versions in the set.\n\n        >>> list(SpecifierSet(\"\").filter([\"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(SpecifierSet(\"\").filter([\"1.5a1\"]))\n        ['1.5a1']\n        >>> list(SpecifierSet(\"\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n        >>> list(SpecifierSet(\"\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        \"\"\"\n        # Determine if we're forcing a prerelease or not, if we're not forcing\n        # one for this particular filter call, then we'll use whatever the\n        # SpecifierSet thinks for whether or not we should support prereleases.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # If we have any specifiers, then we want to wrap our iterable in the\n        # filter method for each one, this will act as a logical AND amongst\n        # each specifier.\n        if self._specs:\n            for spec in self._specs:\n                iterable = spec.filter(iterable, prereleases=bool(prereleases))\n            return iter(iterable)\n        # If we do not have any specifiers, then we need to have a rough filter\n        # which will filter out any pre-releases, unless there are no final\n        # releases.\n        else:\n            filtered: list[UnparsedVersionVar] = []\n            found_prereleases: list[UnparsedVersionVar] = []\n\n            for item in iterable:\n                parsed_version = _coerce_version(item)\n\n                # Store any item which is a pre-release for later unless we've\n                # already found a final version or we are accepting prereleases\n                if parsed_version.is_prerelease and not prereleases:\n                    if not filtered:\n                        found_prereleases.append(item)\n                else:\n                    filtered.append(item)\n\n            # If we've found no items except for pre-releases, then we'll go\n            # ahead and use the pre-releases\n            if not filtered and found_prereleases and prereleases is None:\n                return iter(found_prereleases)\n\n            return iter(filtered)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/packaging/tags.py","size":21014,"sha1":"ad4f459a2d715ce2cec9612ae2c5e4ed05a8cc4f","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport logging\nimport platform\nimport re\nimport struct\nimport subprocess\nimport sys\nimport sysconfig\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom typing import (\n    Iterable,\n    Iterator,\n    Sequence,\n    Tuple,\n    cast,\n)\n\nfrom . import _manylinux, _musllinux\n\nlogger = logging.getLogger(__name__)\n\nPythonVersion = Sequence[int]\nAppleVersion = Tuple[int, int]\n\nINTERPRETER_SHORT_NAMES: dict[str, str] = {\n    \"python\": \"py\",  # Generic.\n    \"cpython\": \"cp\",\n    \"pypy\": \"pp\",\n    \"ironpython\": \"ip\",\n    \"jython\": \"jy\",\n}\n\n\n_32_BIT_INTERPRETER = struct.calcsize(\"P\") == 4\n\n\nclass Tag:\n    \"\"\"\n    A representation of the tag triple for a wheel.\n\n    Instances are considered immutable and thus are hashable. Equality checking\n    is also supported.\n    \"\"\"\n\n    __slots__ = [\"_abi\", \"_hash\", \"_interpreter\", \"_platform\"]\n\n    def __init__(self, interpreter: str, abi: str, platform: str) -> None:\n        self._interpreter = interpreter.lower()\n        self._abi = abi.lower()\n        self._platform = platform.lower()\n        # The __hash__ of every single element in a Set[Tag] will be evaluated each time\n        # that a set calls its `.disjoint()` method, which may be called hundreds of\n        # times when scanning a page of links for packages with tags matching that\n        # Set[Tag]. Pre-computing the value here produces significant speedups for\n        # downstream consumers.\n        self._hash = hash((self._interpreter, self._abi, self._platform))\n\n    @property\n    def interpreter(self) -> str:\n        return self._interpreter\n\n    @property\n    def abi(self) -> str:\n        return self._abi\n\n    @property\n    def platform(self) -> str:\n        return self._platform\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Tag):\n            return NotImplemented\n\n        return (\n            (self._hash == other._hash)  # Short-circuit ASAP for perf reasons.\n            and (self._platform == other._platform)\n            and (self._abi == other._abi)\n            and (self._interpreter == other._interpreter)\n        )\n\n    def __hash__(self) -> int:\n        return self._hash\n\n    def __str__(self) -> str:\n        return f\"{self._interpreter}-{self._abi}-{self._platform}\"\n\n    def __repr__(self) -> str:\n        return f\"<{self} @ {id(self)}>\"\n\n\ndef parse_tag(tag: str) -> frozenset[Tag]:\n    \"\"\"\n    Parses the provided tag (e.g. `py3-none-any`) into a frozenset of Tag instances.\n\n    Returning a set is required due to the possibility that the tag is a\n    compressed tag set.\n    \"\"\"\n    tags = set()\n    interpreters, abis, platforms = tag.split(\"-\")\n    for interpreter in interpreters.split(\".\"):\n        for abi in abis.split(\".\"):\n            for platform_ in platforms.split(\".\"):\n                tags.add(Tag(interpreter, abi, platform_))\n    return frozenset(tags)\n\n\ndef _get_config_var(name: str, warn: bool = False) -> int | str | None:\n    value: int | str | None = sysconfig.get_config_var(name)\n    if value is None and warn:\n        logger.debug(\n            \"Config variable '%s' is unset, Python ABI tag may be incorrect\", name\n        )\n    return value\n\n\ndef _normalize_string(string: str) -> str:\n    return string.replace(\".\", \"_\").replace(\"-\", \"_\").replace(\" \", \"_\")\n\n\ndef _is_threaded_cpython(abis: list[str]) -> bool:\n    \"\"\"\n    Determine if the ABI corresponds to a threaded (`--disable-gil`) build.\n\n    The threaded builds are indicated by a \"t\" in the abiflags.\n    \"\"\"\n    if len(abis) == 0:\n        return False\n    # expect e.g., cp313\n    m = re.match(r\"cp\\d+(.*)\", abis[0])\n    if not m:\n        return False\n    abiflags = m.group(1)\n    return \"t\" in abiflags\n\n\ndef _abi3_applies(python_version: PythonVersion, threading: bool) -> bool:\n    \"\"\"\n    Determine if the Python version supports abi3.\n\n    PEP 384 was first implemented in Python 3.2. The threaded (`--disable-gil`)\n    builds do not support abi3.\n    \"\"\"\n    return len(python_version) > 1 and tuple(python_version) >= (3, 2) and not threading\n\n\ndef _cpython_abis(py_version: PythonVersion, warn: bool = False) -> list[str]:\n    py_version = tuple(py_version)  # To allow for version comparison.\n    abis = []\n    version = _version_nodot(py_version[:2])\n    threading = debug = pymalloc = ucs4 = \"\"\n    with_debug = _get_config_var(\"Py_DEBUG\", warn)\n    has_refcount = hasattr(sys, \"gettotalrefcount\")\n    # Windows doesn't set Py_DEBUG, so checking for support of debug-compiled\n    # extension modules is the best option.\n    # https://github.com/pypa/pip/issues/3383#issuecomment-173267692\n    has_ext = \"_d.pyd\" in EXTENSION_SUFFIXES\n    if with_debug or (with_debug is None and (has_refcount or has_ext)):\n        debug = \"d\"\n    if py_version >= (3, 13) and _get_config_var(\"Py_GIL_DISABLED\", warn):\n        threading = \"t\"\n    if py_version < (3, 8):\n        with_pymalloc = _get_config_var(\"WITH_PYMALLOC\", warn)\n        if with_pymalloc or with_pymalloc is None:\n            pymalloc = \"m\"\n        if py_version < (3, 3):\n            unicode_size = _get_config_var(\"Py_UNICODE_SIZE\", warn)\n            if unicode_size == 4 or (\n                unicode_size is None and sys.maxunicode == 0x10FFFF\n            ):\n                ucs4 = \"u\"\n    elif debug:\n        # Debug builds can also load \"normal\" extension modules.\n        # We can also assume no UCS-4 or pymalloc requirement.\n        abis.append(f\"cp{version}{threading}\")\n    abis.insert(0, f\"cp{version}{threading}{debug}{pymalloc}{ucs4}\")\n    return abis\n\n\ndef cpython_tags(\n    python_version: PythonVersion | None = None,\n    abis: Iterable[str] | None = None,\n    platforms: Iterable[str] | None = None,\n    *,\n    warn: bool = False,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the tags for a CPython interpreter.\n\n    The tags consist of:\n    - cp<python_version>-<abi>-<platform>\n    - cp<python_version>-abi3-<platform>\n    - cp<python_version>-none-<platform>\n    - cp<less than python_version>-abi3-<platform>  # Older Python versions down to 3.2.\n\n    If python_version only specifies a major version then user-provided ABIs and\n    the 'none' ABItag will be used.\n\n    If 'abi3' or 'none' are specified in 'abis' then they will be yielded at\n    their normal position and not at the beginning.\n    \"\"\"\n    if not python_version:\n        python_version = sys.version_info[:2]\n\n    interpreter = f\"cp{_version_nodot(python_version[:2])}\"\n\n    if abis is None:\n        if len(python_version) > 1:\n            abis = _cpython_abis(python_version, warn)\n        else:\n            abis = []\n    abis = list(abis)\n    # 'abi3' and 'none' are explicitly handled later.\n    for explicit_abi in (\"abi3\", \"none\"):\n        try:\n            abis.remove(explicit_abi)\n        except ValueError:\n            pass\n\n    platforms = list(platforms or platform_tags())\n    for abi in abis:\n        for platform_ in platforms:\n            yield Tag(interpreter, abi, platform_)\n\n    threading = _is_threaded_cpython(abis)\n    use_abi3 = _abi3_applies(python_version, threading)\n    if use_abi3:\n        yield from (Tag(interpreter, \"abi3\", platform_) for platform_ in platforms)\n    yield from (Tag(interpreter, \"none\", platform_) for platform_ in platforms)\n\n    if use_abi3:\n        for minor_version in range(python_version[1] - 1, 1, -1):\n            for platform_ in platforms:\n                version = _version_nodot((python_version[0], minor_version))\n                interpreter = f\"cp{version}\"\n                yield Tag(interpreter, \"abi3\", platform_)\n\n\ndef _generic_abi() -> list[str]:\n    \"\"\"\n    Return the ABI tag based on EXT_SUFFIX.\n    \"\"\"\n    # The following are examples of `EXT_SUFFIX`.\n    # We want to keep the parts which are related to the ABI and remove the\n    # parts which are related to the platform:\n    # - linux:   '.cpython-310-x86_64-linux-gnu.so' => cp310\n    # - mac:     '.cpython-310-darwin.so'           => cp310\n    # - win:     '.cp310-win_amd64.pyd'             => cp310\n    # - win:     '.pyd'                             => cp37 (uses _cpython_abis())\n    # - pypy:    '.pypy38-pp73-x86_64-linux-gnu.so' => pypy38_pp73\n    # - graalpy: '.graalpy-38-native-x86_64-darwin.dylib'\n    #                                               => graalpy_38_native\n\n    ext_suffix = _get_config_var(\"EXT_SUFFIX\", warn=True)\n    if not isinstance(ext_suffix, str) or ext_suffix[0] != \".\":\n        raise SystemError(\"invalid sysconfig.get_config_var('EXT_SUFFIX')\")\n    parts = ext_suffix.split(\".\")\n    if len(parts) < 3:\n        # CPython3.7 and earlier uses \".pyd\" on Windows.\n        return _cpython_abis(sys.version_info[:2])\n    soabi = parts[1]\n    if soabi.startswith(\"cpython\"):\n        # non-windows\n        abi = \"cp\" + soabi.split(\"-\")[1]\n    elif soabi.startswith(\"cp\"):\n        # windows\n        abi = soabi.split(\"-\")[0]\n    elif soabi.startswith(\"pypy\"):\n        abi = \"-\".join(soabi.split(\"-\")[:2])\n    elif soabi.startswith(\"graalpy\"):\n        abi = \"-\".join(soabi.split(\"-\")[:3])\n    elif soabi:\n        # pyston, ironpython, others?\n        abi = soabi\n    else:\n        return []\n    return [_normalize_string(abi)]\n\n\ndef generic_tags(\n    interpreter: str | None = None,\n    abis: Iterable[str] | None = None,\n    platforms: Iterable[str] | None = None,\n    *,\n    warn: bool = False,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the tags for a generic interpreter.\n\n    The tags consist of:\n    - <interpreter>-<abi>-<platform>\n\n    The \"none\" ABI will be added if it was not explicitly provided.\n    \"\"\"\n    if not interpreter:\n        interp_name = interpreter_name()\n        interp_version = interpreter_version(warn=warn)\n        interpreter = \"\".join([interp_name, interp_version])\n    if abis is None:\n        abis = _generic_abi()\n    else:\n        abis = list(abis)\n    platforms = list(platforms or platform_tags())\n    if \"none\" not in abis:\n        abis.append(\"none\")\n    for abi in abis:\n        for platform_ in platforms:\n            yield Tag(interpreter, abi, platform_)\n\n\ndef _py_interpreter_range(py_version: PythonVersion) -> Iterator[str]:\n    \"\"\"\n    Yields Python versions in descending order.\n\n    After the latest version, the major-only version will be yielded, and then\n    all previous versions of that major version.\n    \"\"\"\n    if len(py_version) > 1:\n        yield f\"py{_version_nodot(py_version[:2])}\"\n    yield f\"py{py_version[0]}\"\n    if len(py_version) > 1:\n        for minor in range(py_version[1] - 1, -1, -1):\n            yield f\"py{_version_nodot((py_version[0], minor))}\"\n\n\ndef compatible_tags(\n    python_version: PythonVersion | None = None,\n    interpreter: str | None = None,\n    platforms: Iterable[str] | None = None,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the sequence of tags that are compatible with a specific version of Python.\n\n    The tags consist of:\n    - py*-none-<platform>\n    - <interpreter>-none-any  # ... if `interpreter` is provided.\n    - py*-none-any\n    \"\"\"\n    if not python_version:\n        python_version = sys.version_info[:2]\n    platforms = list(platforms or platform_tags())\n    for version in _py_interpreter_range(python_version):\n        for platform_ in platforms:\n            yield Tag(version, \"none\", platform_)\n    if interpreter:\n        yield Tag(interpreter, \"none\", \"any\")\n    for version in _py_interpreter_range(python_version):\n        yield Tag(version, \"none\", \"any\")\n\n\ndef _mac_arch(arch: str, is_32bit: bool = _32_BIT_INTERPRETER) -> str:\n    if not is_32bit:\n        return arch\n\n    if arch.startswith(\"ppc\"):\n        return \"ppc\"\n\n    return \"i386\"\n\n\ndef _mac_binary_formats(version: AppleVersion, cpu_arch: str) -> list[str]:\n    formats = [cpu_arch]\n    if cpu_arch == \"x86_64\":\n        if version < (10, 4):\n            return []\n        formats.extend([\"intel\", \"fat64\", \"fat32\"])\n\n    elif cpu_arch == \"i386\":\n        if version < (10, 4):\n            return []\n        formats.extend([\"intel\", \"fat32\", \"fat\"])\n\n    elif cpu_arch == \"ppc64\":\n        # TODO: Need to care about 32-bit PPC for ppc64 through 10.2?\n        if version > (10, 5) or version < (10, 4):\n            return []\n        formats.append(\"fat64\")\n\n    elif cpu_arch == \"ppc\":\n        if version > (10, 6):\n            return []\n        formats.extend([\"fat32\", \"fat\"])\n\n    if cpu_arch in {\"arm64\", \"x86_64\"}:\n        formats.append(\"universal2\")\n\n    if cpu_arch in {\"x86_64\", \"i386\", \"ppc64\", \"ppc\", \"intel\"}:\n        formats.append(\"universal\")\n\n    return formats\n\n\ndef mac_platforms(\n    version: AppleVersion | None = None, arch: str | None = None\n) -> Iterator[str]:\n    \"\"\"\n    Yields the platform tags for a macOS system.\n\n    The `version` parameter is a two-item tuple specifying the macOS version to\n    generate platform tags for. The `arch` parameter is the CPU architecture to\n    generate platform tags for. Both parameters default to the appropriate value\n    for the current system.\n    \"\"\"\n    version_str, _, cpu_arch = platform.mac_ver()\n    if version is None:\n        version = cast(\"AppleVersion\", tuple(map(int, version_str.split(\".\")[:2])))\n        if version == (10, 16):\n            # When built against an older macOS SDK, Python will report macOS 10.16\n            # instead of the real version.\n            version_str = subprocess.run(\n                [\n                    sys.executable,\n                    \"-sS\",\n                    \"-c\",\n                    \"import platform; print(platform.mac_ver()[0])\",\n                ],\n                check=True,\n                env={\"SYSTEM_VERSION_COMPAT\": \"0\"},\n                stdout=subprocess.PIPE,\n                text=True,\n            ).stdout\n            version = cast(\"AppleVersion\", tuple(map(int, version_str.split(\".\")[:2])))\n    else:\n        version = version\n    if arch is None:\n        arch = _mac_arch(cpu_arch)\n    else:\n        arch = arch\n\n    if (10, 0) <= version and version < (11, 0):\n        # Prior to Mac OS 11, each yearly release of Mac OS bumped the\n        # \"minor\" version number.  The major version was always 10.\n        major_version = 10\n        for minor_version in range(version[1], -1, -1):\n            compat_version = major_version, minor_version\n            binary_formats = _mac_binary_formats(compat_version, arch)\n            for binary_format in binary_formats:\n                yield f\"macosx_{major_version}_{minor_version}_{binary_format}\"\n\n    if version >= (11, 0):\n        # Starting with Mac OS 11, each yearly release bumps the major version\n        # number.   The minor versions are now the midyear updates.\n        minor_version = 0\n        for major_version in range(version[0], 10, -1):\n            compat_version = major_version, minor_version\n            binary_formats = _mac_binary_formats(compat_version, arch)\n            for binary_format in binary_formats:\n                yield f\"macosx_{major_version}_{minor_version}_{binary_format}\"\n\n    if version >= (11, 0):\n        # Mac OS 11 on x86_64 is compatible with binaries from previous releases.\n        # Arm64 support was introduced in 11.0, so no Arm binaries from previous\n        # releases exist.\n        #\n        # However, the \"universal2\" binary format can have a\n        # macOS version earlier than 11.0 when the x86_64 part of the binary supports\n        # that version of macOS.\n        major_version = 10\n        if arch == \"x86_64\":\n            for minor_version in range(16, 3, -1):\n                compat_version = major_version, minor_version\n                binary_formats = _mac_binary_formats(compat_version, arch)\n                for binary_format in binary_formats:\n                    yield f\"macosx_{major_version}_{minor_version}_{binary_format}\"\n        else:\n            for minor_version in range(16, 3, -1):\n                compat_version = major_version, minor_version\n                binary_format = \"universal2\"\n                yield f\"macosx_{major_version}_{minor_version}_{binary_format}\"\n\n\ndef ios_platforms(\n    version: AppleVersion | None = None, multiarch: str | None = None\n) -> Iterator[str]:\n    \"\"\"\n    Yields the platform tags for an iOS system.\n\n    :param version: A two-item tuple specifying the iOS version to generate\n        platform tags for. Defaults to the current iOS version.\n    :param multiarch: The CPU architecture+ABI to generate platform tags for -\n        (the value used by `sys.implementation._multiarch` e.g.,\n        `arm64_iphoneos` or `x84_64_iphonesimulator`). Defaults to the current\n        multiarch value.\n    \"\"\"\n    if version is None:\n        # if iOS is the current platform, ios_ver *must* be defined. However,\n        # it won't exist for CPython versions before 3.13, which causes a mypy\n        # error.\n        _, release, _, _ = platform.ios_ver()  # type: ignore[attr-defined, unused-ignore]\n        version = cast(\"AppleVersion\", tuple(map(int, release.split(\".\")[:2])))\n\n    if multiarch is None:\n        multiarch = sys.implementation._multiarch\n    multiarch = multiarch.replace(\"-\", \"_\")\n\n    ios_platform_template = \"ios_{major}_{minor}_{multiarch}\"\n\n    # Consider any iOS major.minor version from the version requested, down to\n    # 12.0. 12.0 is the first iOS version that is known to have enough features\n    # to support CPython. Consider every possible minor release up to X.9. There\n    # highest the minor has ever gone is 8 (14.8 and 15.8) but having some extra\n    # candidates that won't ever match doesn't really hurt, and it saves us from\n    # having to keep an explicit list of known iOS versions in the code. Return\n    # the results descending order of version number.\n\n    # If the requested major version is less than 12, there won't be any matches.\n    if version[0] < 12:\n        return\n\n    # Consider the actual X.Y version that was requested.\n    yield ios_platform_template.format(\n        major=version[0], minor=version[1], multiarch=multiarch\n    )\n\n    # Consider every minor version from X.0 to the minor version prior to the\n    # version requested by the platform.\n    for minor in range(version[1] - 1, -1, -1):\n        yield ios_platform_template.format(\n            major=version[0], minor=minor, multiarch=multiarch\n        )\n\n    for major in range(version[0] - 1, 11, -1):\n        for minor in range(9, -1, -1):\n            yield ios_platform_template.format(\n                major=major, minor=minor, multiarch=multiarch\n            )\n\n\ndef _linux_platforms(is_32bit: bool = _32_BIT_INTERPRETER) -> Iterator[str]:\n    linux = _normalize_string(sysconfig.get_platform())\n    if not linux.startswith(\"linux_\"):\n        # we should never be here, just yield the sysconfig one and return\n        yield linux\n        return\n    if is_32bit:\n        if linux == \"linux_x86_64\":\n            linux = \"linux_i686\"\n        elif linux == \"linux_aarch64\":\n            linux = \"linux_armv8l\"\n    _, arch = linux.split(\"_\", 1)\n    archs = {\"armv8l\": [\"armv8l\", \"armv7l\"]}.get(arch, [arch])\n    yield from _manylinux.platform_tags(archs)\n    yield from _musllinux.platform_tags(archs)\n    for arch in archs:\n        yield f\"linux_{arch}\"\n\n\ndef _generic_platforms() -> Iterator[str]:\n    yield _normalize_string(sysconfig.get_platform())\n\n\ndef platform_tags() -> Iterator[str]:\n    \"\"\"\n    Provides the platform tags for this installation.\n    \"\"\"\n    if platform.system() == \"Darwin\":\n        return mac_platforms()\n    elif platform.system() == \"iOS\":\n        return ios_platforms()\n    elif platform.system() == \"Linux\":\n        return _linux_platforms()\n    else:\n        return _generic_platforms()\n\n\ndef interpreter_name() -> str:\n    \"\"\"\n    Returns the name of the running interpreter.\n\n    Some implementations have a reserved, two-letter abbreviation which will\n    be returned when appropriate.\n    \"\"\"\n    name = sys.implementation.name\n    return INTERPRETER_SHORT_NAMES.get(name) or name\n\n\ndef interpreter_version(*, warn: bool = False) -> str:\n    \"\"\"\n    Returns the version of the running interpreter.\n    \"\"\"\n    version = _get_config_var(\"py_version_nodot\", warn=warn)\n    if version:\n        version = str(version)\n    else:\n        version = _version_nodot(sys.version_info[:2])\n    return version\n\n\ndef _version_nodot(version: PythonVersion) -> str:\n    return \"\".join(map(str, version))\n\n\ndef sys_tags(*, warn: bool = False) -> Iterator[Tag]:\n    \"\"\"\n    Returns the sequence of tag triples for the running interpreter.\n\n    The order of the sequence corresponds to priority order for the\n    interpreter, from most to least important.\n    \"\"\"\n\n    interp_name = interpreter_name()\n    if interp_name == \"cp\":\n        yield from cpython_tags(warn=warn)\n    else:\n        yield from generic_tags()\n\n    if interp_name == \"pp\":\n        interp = \"pp3\"\n    elif interp_name == \"cp\":\n        interp = \"cp\" + interpreter_version(warn=warn)\n    else:\n        interp = None\n    yield from compatible_tags(interpreter=interp)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/packaging/utils.py","size":5050,"sha1":"a5dd9d67bec31aae3ad6701553031b0f19292cc8","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport functools\nimport re\nfrom typing import NewType, Tuple, Union, cast\n\nfrom .tags import Tag, parse_tag\nfrom .version import InvalidVersion, Version, _TrimmedRelease\n\nBuildTag = Union[Tuple[()], Tuple[int, str]]\nNormalizedName = NewType(\"NormalizedName\", str)\n\n\nclass InvalidName(ValueError):\n    \"\"\"\n    An invalid distribution name; users should refer to the packaging user guide.\n    \"\"\"\n\n\nclass InvalidWheelFilename(ValueError):\n    \"\"\"\n    An invalid wheel filename was found, users should refer to PEP 427.\n    \"\"\"\n\n\nclass InvalidSdistFilename(ValueError):\n    \"\"\"\n    An invalid sdist filename was found, users should refer to the packaging user guide.\n    \"\"\"\n\n\n# Core metadata spec for `Name`\n_validate_regex = re.compile(\n    r\"^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$\", re.IGNORECASE\n)\n_canonicalize_regex = re.compile(r\"[-_.]+\")\n_normalized_regex = re.compile(r\"^([a-z0-9]|[a-z0-9]([a-z0-9-](?!--))*[a-z0-9])$\")\n# PEP 427: The build number must start with a digit.\n_build_tag_regex = re.compile(r\"(\\d+)(.*)\")\n\n\ndef canonicalize_name(name: str, *, validate: bool = False) -> NormalizedName:\n    if validate and not _validate_regex.match(name):\n        raise InvalidName(f\"name is invalid: {name!r}\")\n    # This is taken from PEP 503.\n    value = _canonicalize_regex.sub(\"-\", name).lower()\n    return cast(NormalizedName, value)\n\n\ndef is_normalized_name(name: str) -> bool:\n    return _normalized_regex.match(name) is not None\n\n\n@functools.singledispatch\ndef canonicalize_version(\n    version: Version | str, *, strip_trailing_zero: bool = True\n) -> str:\n    \"\"\"\n    Return a canonical form of a version as a string.\n\n    >>> canonicalize_version('1.0.1')\n    '1.0.1'\n\n    Per PEP 625, versions may have multiple canonical forms, differing\n    only by trailing zeros.\n\n    >>> canonicalize_version('1.0.0')\n    '1'\n    >>> canonicalize_version('1.0.0', strip_trailing_zero=False)\n    '1.0.0'\n\n    Invalid versions are returned unaltered.\n\n    >>> canonicalize_version('foo bar baz')\n    'foo bar baz'\n    \"\"\"\n    return str(_TrimmedRelease(str(version)) if strip_trailing_zero else version)\n\n\n@canonicalize_version.register\ndef _(version: str, *, strip_trailing_zero: bool = True) -> str:\n    try:\n        parsed = Version(version)\n    except InvalidVersion:\n        # Legacy versions cannot be normalized\n        return version\n    return canonicalize_version(parsed, strip_trailing_zero=strip_trailing_zero)\n\n\ndef parse_wheel_filename(\n    filename: str,\n) -> tuple[NormalizedName, Version, BuildTag, frozenset[Tag]]:\n    if not filename.endswith(\".whl\"):\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (extension must be '.whl'): {filename!r}\"\n        )\n\n    filename = filename[:-4]\n    dashes = filename.count(\"-\")\n    if dashes not in (4, 5):\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (wrong number of parts): {filename!r}\"\n        )\n\n    parts = filename.split(\"-\", dashes - 2)\n    name_part = parts[0]\n    # See PEP 427 for the rules on escaping the project name.\n    if \"__\" in name_part or re.match(r\"^[\\w\\d._]*$\", name_part, re.UNICODE) is None:\n        raise InvalidWheelFilename(f\"Invalid project name: {filename!r}\")\n    name = canonicalize_name(name_part)\n\n    try:\n        version = Version(parts[1])\n    except InvalidVersion as e:\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (invalid version): {filename!r}\"\n        ) from e\n\n    if dashes == 5:\n        build_part = parts[2]\n        build_match = _build_tag_regex.match(build_part)\n        if build_match is None:\n            raise InvalidWheelFilename(\n                f\"Invalid build number: {build_part} in {filename!r}\"\n            )\n        build = cast(BuildTag, (int(build_match.group(1)), build_match.group(2)))\n    else:\n        build = ()\n    tags = parse_tag(parts[-1])\n    return (name, version, build, tags)\n\n\ndef parse_sdist_filename(filename: str) -> tuple[NormalizedName, Version]:\n    if filename.endswith(\".tar.gz\"):\n        file_stem = filename[: -len(\".tar.gz\")]\n    elif filename.endswith(\".zip\"):\n        file_stem = filename[: -len(\".zip\")]\n    else:\n        raise InvalidSdistFilename(\n            f\"Invalid sdist filename (extension must be '.tar.gz' or '.zip'):\"\n            f\" {filename!r}\"\n        )\n\n    # We are requiring a PEP 440 version, which cannot contain dashes,\n    # so we split on the last dash.\n    name_part, sep, version_part = file_stem.rpartition(\"-\")\n    if not sep:\n        raise InvalidSdistFilename(f\"Invalid sdist filename: {filename!r}\")\n\n    name = canonicalize_name(name_part)\n\n    try:\n        version = Version(version_part)\n    except InvalidVersion as e:\n        raise InvalidSdistFilename(\n            f\"Invalid sdist filename (invalid version): {filename!r}\"\n        ) from e\n\n    return (name, version)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/packaging/version.py","size":16676,"sha1":"3d6697f35d2242be251765ee7a5a11071495daa9","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\"\"\"\n.. testsetup::\n\n    from packaging.version import parse, Version\n\"\"\"\n\nfrom __future__ import annotations\n\nimport itertools\nimport re\nfrom typing import Any, Callable, NamedTuple, SupportsInt, Tuple, Union\n\nfrom ._structures import Infinity, InfinityType, NegativeInfinity, NegativeInfinityType\n\n__all__ = [\"VERSION_PATTERN\", \"InvalidVersion\", \"Version\", \"parse\"]\n\nLocalType = Tuple[Union[int, str], ...]\n\nCmpPrePostDevType = Union[InfinityType, NegativeInfinityType, Tuple[str, int]]\nCmpLocalType = Union[\n    NegativeInfinityType,\n    Tuple[Union[Tuple[int, str], Tuple[NegativeInfinityType, Union[int, str]]], ...],\n]\nCmpKey = Tuple[\n    int,\n    Tuple[int, ...],\n    CmpPrePostDevType,\n    CmpPrePostDevType,\n    CmpPrePostDevType,\n    CmpLocalType,\n]\nVersionComparisonMethod = Callable[[CmpKey, CmpKey], bool]\n\n\nclass _Version(NamedTuple):\n    epoch: int\n    release: tuple[int, ...]\n    dev: tuple[str, int] | None\n    pre: tuple[str, int] | None\n    post: tuple[str, int] | None\n    local: LocalType | None\n\n\ndef parse(version: str) -> Version:\n    \"\"\"Parse the given version string.\n\n    >>> parse('1.0.dev1')\n    <Version('1.0.dev1')>\n\n    :param version: The version string to parse.\n    :raises InvalidVersion: When the version string is not a valid version.\n    \"\"\"\n    return Version(version)\n\n\nclass InvalidVersion(ValueError):\n    \"\"\"Raised when a version string is not a valid version.\n\n    >>> Version(\"invalid\")\n    Traceback (most recent call last):\n        ...\n    packaging.version.InvalidVersion: Invalid version: 'invalid'\n    \"\"\"\n\n\nclass _BaseVersion:\n    _key: tuple[Any, ...]\n\n    def __hash__(self) -> int:\n        return hash(self._key)\n\n    # Please keep the duplicated `isinstance` check\n    # in the six comparisons hereunder\n    # unless you find a way to avoid adding overhead function calls.\n    def __lt__(self, other: _BaseVersion) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key < other._key\n\n    def __le__(self, other: _BaseVersion) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key <= other._key\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key == other._key\n\n    def __ge__(self, other: _BaseVersion) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key >= other._key\n\n    def __gt__(self, other: _BaseVersion) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key > other._key\n\n    def __ne__(self, other: object) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key != other._key\n\n\n# Deliberately not anchored to the start and end of the string, to make it\n# easier for 3rd party code to reuse\n_VERSION_PATTERN = r\"\"\"\n    v?\n    (?:\n        (?:(?P<epoch>[0-9]+)!)?                           # epoch\n        (?P<release>[0-9]+(?:\\.[0-9]+)*)                  # release segment\n        (?P<pre>                                          # pre-release\n            [-_\\.]?\n            (?P<pre_l>alpha|a|beta|b|preview|pre|c|rc)\n            [-_\\.]?\n            (?P<pre_n>[0-9]+)?\n        )?\n        (?P<post>                                         # post release\n            (?:-(?P<post_n1>[0-9]+))\n            |\n            (?:\n                [-_\\.]?\n                (?P<post_l>post|rev|r)\n                [-_\\.]?\n                (?P<post_n2>[0-9]+)?\n            )\n        )?\n        (?P<dev>                                          # dev release\n            [-_\\.]?\n            (?P<dev_l>dev)\n            [-_\\.]?\n            (?P<dev_n>[0-9]+)?\n        )?\n    )\n    (?:\\+(?P<local>[a-z0-9]+(?:[-_\\.][a-z0-9]+)*))?       # local version\n\"\"\"\n\nVERSION_PATTERN = _VERSION_PATTERN\n\"\"\"\nA string containing the regular expression used to match a valid version.\n\nThe pattern is not anchored at either end, and is intended for embedding in larger\nexpressions (for example, matching a version number as part of a file name). The\nregular expression should be compiled with the ``re.VERBOSE`` and ``re.IGNORECASE``\nflags set.\n\n:meta hide-value:\n\"\"\"\n\n\nclass Version(_BaseVersion):\n    \"\"\"This class abstracts handling of a project's versions.\n\n    A :class:`Version` instance is comparison aware and can be compared and\n    sorted using the standard Python interfaces.\n\n    >>> v1 = Version(\"1.0a5\")\n    >>> v2 = Version(\"1.0\")\n    >>> v1\n    <Version('1.0a5')>\n    >>> v2\n    <Version('1.0')>\n    >>> v1 < v2\n    True\n    >>> v1 == v2\n    False\n    >>> v1 > v2\n    False\n    >>> v1 >= v2\n    False\n    >>> v1 <= v2\n    True\n    \"\"\"\n\n    _regex = re.compile(r\"^\\s*\" + VERSION_PATTERN + r\"\\s*$\", re.VERBOSE | re.IGNORECASE)\n    _key: CmpKey\n\n    def __init__(self, version: str) -> None:\n        \"\"\"Initialize a Version object.\n\n        :param version:\n            The string representation of a version which will be parsed and normalized\n            before use.\n        :raises InvalidVersion:\n            If the ``version`` does not conform to PEP 440 in any way then this\n            exception will be raised.\n        \"\"\"\n\n        # Validate the version and parse it into pieces\n        match = self._regex.search(version)\n        if not match:\n            raise InvalidVersion(f\"Invalid version: {version!r}\")\n\n        # Store the parsed out pieces of the version\n        self._version = _Version(\n            epoch=int(match.group(\"epoch\")) if match.group(\"epoch\") else 0,\n            release=tuple(int(i) for i in match.group(\"release\").split(\".\")),\n            pre=_parse_letter_version(match.group(\"pre_l\"), match.group(\"pre_n\")),\n            post=_parse_letter_version(\n                match.group(\"post_l\"), match.group(\"post_n1\") or match.group(\"post_n2\")\n            ),\n            dev=_parse_letter_version(match.group(\"dev_l\"), match.group(\"dev_n\")),\n            local=_parse_local_version(match.group(\"local\")),\n        )\n\n        # Generate a key which will be used for sorting\n        self._key = _cmpkey(\n            self._version.epoch,\n            self._version.release,\n            self._version.pre,\n            self._version.post,\n            self._version.dev,\n            self._version.local,\n        )\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the Version that shows all internal state.\n\n        >>> Version('1.0.0')\n        <Version('1.0.0')>\n        \"\"\"\n        return f\"<Version('{self}')>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the version that can be round-tripped.\n\n        >>> str(Version(\"1.0a5\"))\n        '1.0a5'\n        \"\"\"\n        parts = []\n\n        # Epoch\n        if self.epoch != 0:\n            parts.append(f\"{self.epoch}!\")\n\n        # Release segment\n        parts.append(\".\".join(str(x) for x in self.release))\n\n        # Pre-release\n        if self.pre is not None:\n            parts.append(\"\".join(str(x) for x in self.pre))\n\n        # Post-release\n        if self.post is not None:\n            parts.append(f\".post{self.post}\")\n\n        # Development release\n        if self.dev is not None:\n            parts.append(f\".dev{self.dev}\")\n\n        # Local version segment\n        if self.local is not None:\n            parts.append(f\"+{self.local}\")\n\n        return \"\".join(parts)\n\n    @property\n    def epoch(self) -> int:\n        \"\"\"The epoch of the version.\n\n        >>> Version(\"2.0.0\").epoch\n        0\n        >>> Version(\"1!2.0.0\").epoch\n        1\n        \"\"\"\n        return self._version.epoch\n\n    @property\n    def release(self) -> tuple[int, ...]:\n        \"\"\"The components of the \"release\" segment of the version.\n\n        >>> Version(\"1.2.3\").release\n        (1, 2, 3)\n        >>> Version(\"2.0.0\").release\n        (2, 0, 0)\n        >>> Version(\"1!2.0.0.post0\").release\n        (2, 0, 0)\n\n        Includes trailing zeroes but not the epoch or any pre-release / development /\n        post-release suffixes.\n        \"\"\"\n        return self._version.release\n\n    @property\n    def pre(self) -> tuple[str, int] | None:\n        \"\"\"The pre-release segment of the version.\n\n        >>> print(Version(\"1.2.3\").pre)\n        None\n        >>> Version(\"1.2.3a1\").pre\n        ('a', 1)\n        >>> Version(\"1.2.3b1\").pre\n        ('b', 1)\n        >>> Version(\"1.2.3rc1\").pre\n        ('rc', 1)\n        \"\"\"\n        return self._version.pre\n\n    @property\n    def post(self) -> int | None:\n        \"\"\"The post-release number of the version.\n\n        >>> print(Version(\"1.2.3\").post)\n        None\n        >>> Version(\"1.2.3.post1\").post\n        1\n        \"\"\"\n        return self._version.post[1] if self._version.post else None\n\n    @property\n    def dev(self) -> int | None:\n        \"\"\"The development number of the version.\n\n        >>> print(Version(\"1.2.3\").dev)\n        None\n        >>> Version(\"1.2.3.dev1\").dev\n        1\n        \"\"\"\n        return self._version.dev[1] if self._version.dev else None\n\n    @property\n    def local(self) -> str | None:\n        \"\"\"The local version segment of the version.\n\n        >>> print(Version(\"1.2.3\").local)\n        None\n        >>> Version(\"1.2.3+abc\").local\n        'abc'\n        \"\"\"\n        if self._version.local:\n            return \".\".join(str(x) for x in self._version.local)\n        else:\n            return None\n\n    @property\n    def public(self) -> str:\n        \"\"\"The public portion of the version.\n\n        >>> Version(\"1.2.3\").public\n        '1.2.3'\n        >>> Version(\"1.2.3+abc\").public\n        '1.2.3'\n        >>> Version(\"1!1.2.3dev1+abc\").public\n        '1!1.2.3.dev1'\n        \"\"\"\n        return str(self).split(\"+\", 1)[0]\n\n    @property\n    def base_version(self) -> str:\n        \"\"\"The \"base version\" of the version.\n\n        >>> Version(\"1.2.3\").base_version\n        '1.2.3'\n        >>> Version(\"1.2.3+abc\").base_version\n        '1.2.3'\n        >>> Version(\"1!1.2.3dev1+abc\").base_version\n        '1!1.2.3'\n\n        The \"base version\" is the public version of the project without any pre or post\n        release markers.\n        \"\"\"\n        parts = []\n\n        # Epoch\n        if self.epoch != 0:\n            parts.append(f\"{self.epoch}!\")\n\n        # Release segment\n        parts.append(\".\".join(str(x) for x in self.release))\n\n        return \"\".join(parts)\n\n    @property\n    def is_prerelease(self) -> bool:\n        \"\"\"Whether this version is a pre-release.\n\n        >>> Version(\"1.2.3\").is_prerelease\n        False\n        >>> Version(\"1.2.3a1\").is_prerelease\n        True\n        >>> Version(\"1.2.3b1\").is_prerelease\n        True\n        >>> Version(\"1.2.3rc1\").is_prerelease\n        True\n        >>> Version(\"1.2.3dev1\").is_prerelease\n        True\n        \"\"\"\n        return self.dev is not None or self.pre is not None\n\n    @property\n    def is_postrelease(self) -> bool:\n        \"\"\"Whether this version is a post-release.\n\n        >>> Version(\"1.2.3\").is_postrelease\n        False\n        >>> Version(\"1.2.3.post1\").is_postrelease\n        True\n        \"\"\"\n        return self.post is not None\n\n    @property\n    def is_devrelease(self) -> bool:\n        \"\"\"Whether this version is a development release.\n\n        >>> Version(\"1.2.3\").is_devrelease\n        False\n        >>> Version(\"1.2.3.dev1\").is_devrelease\n        True\n        \"\"\"\n        return self.dev is not None\n\n    @property\n    def major(self) -> int:\n        \"\"\"The first item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").major\n        1\n        \"\"\"\n        return self.release[0] if len(self.release) >= 1 else 0\n\n    @property\n    def minor(self) -> int:\n        \"\"\"The second item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").minor\n        2\n        >>> Version(\"1\").minor\n        0\n        \"\"\"\n        return self.release[1] if len(self.release) >= 2 else 0\n\n    @property\n    def micro(self) -> int:\n        \"\"\"The third item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").micro\n        3\n        >>> Version(\"1\").micro\n        0\n        \"\"\"\n        return self.release[2] if len(self.release) >= 3 else 0\n\n\nclass _TrimmedRelease(Version):\n    @property\n    def release(self) -> tuple[int, ...]:\n        \"\"\"\n        Release segment without any trailing zeros.\n\n        >>> _TrimmedRelease('1.0.0').release\n        (1,)\n        >>> _TrimmedRelease('0.0').release\n        (0,)\n        \"\"\"\n        rel = super().release\n        nonzeros = (index for index, val in enumerate(rel) if val)\n        last_nonzero = max(nonzeros, default=0)\n        return rel[: last_nonzero + 1]\n\n\ndef _parse_letter_version(\n    letter: str | None, number: str | bytes | SupportsInt | None\n) -> tuple[str, int] | None:\n    if letter:\n        # We consider there to be an implicit 0 in a pre-release if there is\n        # not a numeral associated with it.\n        if number is None:\n            number = 0\n\n        # We normalize any letters to their lower case form\n        letter = letter.lower()\n\n        # We consider some words to be alternate spellings of other words and\n        # in those cases we want to normalize the spellings to our preferred\n        # spelling.\n        if letter == \"alpha\":\n            letter = \"a\"\n        elif letter == \"beta\":\n            letter = \"b\"\n        elif letter in [\"c\", \"pre\", \"preview\"]:\n            letter = \"rc\"\n        elif letter in [\"rev\", \"r\"]:\n            letter = \"post\"\n\n        return letter, int(number)\n\n    assert not letter\n    if number:\n        # We assume if we are given a number, but we are not given a letter\n        # then this is using the implicit post release syntax (e.g. 1.0-1)\n        letter = \"post\"\n\n        return letter, int(number)\n\n    return None\n\n\n_local_version_separators = re.compile(r\"[\\._-]\")\n\n\ndef _parse_local_version(local: str | None) -> LocalType | None:\n    \"\"\"\n    Takes a string like abc.1.twelve and turns it into (\"abc\", 1, \"twelve\").\n    \"\"\"\n    if local is not None:\n        return tuple(\n            part.lower() if not part.isdigit() else int(part)\n            for part in _local_version_separators.split(local)\n        )\n    return None\n\n\ndef _cmpkey(\n    epoch: int,\n    release: tuple[int, ...],\n    pre: tuple[str, int] | None,\n    post: tuple[str, int] | None,\n    dev: tuple[str, int] | None,\n    local: LocalType | None,\n) -> CmpKey:\n    # When we compare a release version, we want to compare it with all of the\n    # trailing zeros removed. So we'll use a reverse the list, drop all the now\n    # leading zeros until we come to something non zero, then take the rest\n    # re-reverse it back into the correct order and make it a tuple and use\n    # that for our sorting key.\n    _release = tuple(\n        reversed(list(itertools.dropwhile(lambda x: x == 0, reversed(release))))\n    )\n\n    # We need to \"trick\" the sorting algorithm to put 1.0.dev0 before 1.0a0.\n    # We'll do this by abusing the pre segment, but we _only_ want to do this\n    # if there is not a pre or a post segment. If we have one of those then\n    # the normal sorting rules will handle this case correctly.\n    if pre is None and post is None and dev is not None:\n        _pre: CmpPrePostDevType = NegativeInfinity\n    # Versions without a pre-release (except as noted above) should sort after\n    # those with one.\n    elif pre is None:\n        _pre = Infinity\n    else:\n        _pre = pre\n\n    # Versions without a post segment should sort before those with one.\n    if post is None:\n        _post: CmpPrePostDevType = NegativeInfinity\n\n    else:\n        _post = post\n\n    # Versions without a development segment should sort after those with one.\n    if dev is None:\n        _dev: CmpPrePostDevType = Infinity\n\n    else:\n        _dev = dev\n\n    if local is None:\n        # Versions without a local segment should sort before those with one.\n        _local: CmpLocalType = NegativeInfinity\n    else:\n        # Versions with a local segment need that segment parsed to implement\n        # the sorting rules in PEP440.\n        # - Alpha numeric segments sort before numeric segments\n        # - Alpha numeric segments sort lexicographically\n        # - Numeric segments sort numerically\n        # - Shorter versions sort before longer versions when the prefixes\n        #   match exactly\n        _local = tuple(\n            (i, \"\") if isinstance(i, int) else (NegativeInfinity, i) for i in local\n        )\n\n    return epoch, _release, _pre, _post, _dev, _local\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/platformdirs/__init__.py","size":22225,"sha1":"452e0c106d3866317e30784ca2059adf47ea3c9d","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nUtilities for determining application-specific dirs.\n\nSee <https://github.com/platformdirs/platformdirs> for details and usage.\n\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport sys\nfrom typing import TYPE_CHECKING\n\nfrom .api import PlatformDirsABC\nfrom .version import __version__\nfrom .version import __version_tuple__ as __version_info__\n\nif TYPE_CHECKING:\n    from pathlib import Path\n    from typing import Literal\n\n\ndef _set_platform_dir_class() -> type[PlatformDirsABC]:\n    if sys.platform == \"win32\":\n        from platformdirs.windows import Windows as Result  # noqa: PLC0415\n    elif sys.platform == \"darwin\":\n        from platformdirs.macos import MacOS as Result  # noqa: PLC0415\n    else:\n        from platformdirs.unix import Unix as Result  # noqa: PLC0415\n\n    if os.getenv(\"ANDROID_DATA\") == \"/data\" and os.getenv(\"ANDROID_ROOT\") == \"/system\":\n        if os.getenv(\"SHELL\") or os.getenv(\"PREFIX\"):\n            return Result\n\n        from platformdirs.android import _android_folder  # noqa: PLC0415\n\n        if _android_folder() is not None:\n            from platformdirs.android import Android  # noqa: PLC0415\n\n            return Android  # return to avoid redefinition of a result\n\n    return Result\n\n\nPlatformDirs = _set_platform_dir_class()  #: Currently active platform\nAppDirs = PlatformDirs  #: Backwards compatibility with appdirs\n\n\ndef user_data_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: data directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        roaming=roaming,\n        ensure_exists=ensure_exists,\n    ).user_data_dir\n\n\ndef site_data_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    multipath: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param multipath: See `roaming <platformdirs.api.PlatformDirsABC.multipath>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: data directory shared by users\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        multipath=multipath,\n        ensure_exists=ensure_exists,\n    ).site_data_dir\n\n\ndef user_config_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: config directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        roaming=roaming,\n        ensure_exists=ensure_exists,\n    ).user_config_dir\n\n\ndef site_config_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    multipath: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param multipath: See `roaming <platformdirs.api.PlatformDirsABC.multipath>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: config directory shared by the users\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        multipath=multipath,\n        ensure_exists=ensure_exists,\n    ).site_config_dir\n\n\ndef user_cache_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `roaming <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: cache directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).user_cache_dir\n\n\ndef site_cache_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: cache directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).site_cache_dir\n\n\ndef user_state_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: state directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        roaming=roaming,\n        ensure_exists=ensure_exists,\n    ).user_state_dir\n\n\ndef user_log_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `roaming <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: log directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).user_log_dir\n\n\ndef user_documents_dir() -> str:\n    \"\"\":returns: documents directory tied to the user\"\"\"\n    return PlatformDirs().user_documents_dir\n\n\ndef user_downloads_dir() -> str:\n    \"\"\":returns: downloads directory tied to the user\"\"\"\n    return PlatformDirs().user_downloads_dir\n\n\ndef user_pictures_dir() -> str:\n    \"\"\":returns: pictures directory tied to the user\"\"\"\n    return PlatformDirs().user_pictures_dir\n\n\ndef user_videos_dir() -> str:\n    \"\"\":returns: videos directory tied to the user\"\"\"\n    return PlatformDirs().user_videos_dir\n\n\ndef user_music_dir() -> str:\n    \"\"\":returns: music directory tied to the user\"\"\"\n    return PlatformDirs().user_music_dir\n\n\ndef user_desktop_dir() -> str:\n    \"\"\":returns: desktop directory tied to the user\"\"\"\n    return PlatformDirs().user_desktop_dir\n\n\ndef user_runtime_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: runtime directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).user_runtime_dir\n\n\ndef site_runtime_dir(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> str:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: runtime directory shared by users\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).site_runtime_dir\n\n\ndef user_data_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: data path tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        roaming=roaming,\n        ensure_exists=ensure_exists,\n    ).user_data_path\n\n\ndef site_data_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    multipath: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param multipath: See `multipath <platformdirs.api.PlatformDirsABC.multipath>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: data path shared by users\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        multipath=multipath,\n        ensure_exists=ensure_exists,\n    ).site_data_path\n\n\ndef user_config_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: config path tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        roaming=roaming,\n        ensure_exists=ensure_exists,\n    ).user_config_path\n\n\ndef site_config_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    multipath: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param multipath: See `roaming <platformdirs.api.PlatformDirsABC.multipath>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: config path shared by the users\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        multipath=multipath,\n        ensure_exists=ensure_exists,\n    ).site_config_path\n\n\ndef site_cache_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: cache directory tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).site_cache_path\n\n\ndef user_cache_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `roaming <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: cache path tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).user_cache_path\n\n\ndef user_state_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    roaming: bool = False,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param roaming: See `roaming <platformdirs.api.PlatformDirsABC.roaming>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: state path tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        roaming=roaming,\n        ensure_exists=ensure_exists,\n    ).user_state_path\n\n\ndef user_log_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `roaming <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: log path tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).user_log_path\n\n\ndef user_documents_path() -> Path:\n    \"\"\":returns: documents a path tied to the user\"\"\"\n    return PlatformDirs().user_documents_path\n\n\ndef user_downloads_path() -> Path:\n    \"\"\":returns: downloads path tied to the user\"\"\"\n    return PlatformDirs().user_downloads_path\n\n\ndef user_pictures_path() -> Path:\n    \"\"\":returns: pictures path tied to the user\"\"\"\n    return PlatformDirs().user_pictures_path\n\n\ndef user_videos_path() -> Path:\n    \"\"\":returns: videos path tied to the user\"\"\"\n    return PlatformDirs().user_videos_path\n\n\ndef user_music_path() -> Path:\n    \"\"\":returns: music path tied to the user\"\"\"\n    return PlatformDirs().user_music_path\n\n\ndef user_desktop_path() -> Path:\n    \"\"\":returns: desktop path tied to the user\"\"\"\n    return PlatformDirs().user_desktop_path\n\n\ndef user_runtime_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: runtime path tied to the user\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).user_runtime_path\n\n\ndef site_runtime_path(\n    appname: str | None = None,\n    appauthor: str | None | Literal[False] = None,\n    version: str | None = None,\n    opinion: bool = True,  # noqa: FBT001, FBT002\n    ensure_exists: bool = False,  # noqa: FBT001, FBT002\n) -> Path:\n    \"\"\"\n    :param appname: See `appname <platformdirs.api.PlatformDirsABC.appname>`.\n    :param appauthor: See `appauthor <platformdirs.api.PlatformDirsABC.appauthor>`.\n    :param version: See `version <platformdirs.api.PlatformDirsABC.version>`.\n    :param opinion: See `opinion <platformdirs.api.PlatformDirsABC.opinion>`.\n    :param ensure_exists: See `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n    :returns: runtime path shared by users\n    \"\"\"\n    return PlatformDirs(\n        appname=appname,\n        appauthor=appauthor,\n        version=version,\n        opinion=opinion,\n        ensure_exists=ensure_exists,\n    ).site_runtime_path\n\n\n__all__ = [\n    \"AppDirs\",\n    \"PlatformDirs\",\n    \"PlatformDirsABC\",\n    \"__version__\",\n    \"__version_info__\",\n    \"site_cache_dir\",\n    \"site_cache_path\",\n    \"site_config_dir\",\n    \"site_config_path\",\n    \"site_data_dir\",\n    \"site_data_path\",\n    \"site_runtime_dir\",\n    \"site_runtime_path\",\n    \"user_cache_dir\",\n    \"user_cache_path\",\n    \"user_config_dir\",\n    \"user_config_path\",\n    \"user_data_dir\",\n    \"user_data_path\",\n    \"user_desktop_dir\",\n    \"user_desktop_path\",\n    \"user_documents_dir\",\n    \"user_documents_path\",\n    \"user_downloads_dir\",\n    \"user_downloads_path\",\n    \"user_log_dir\",\n    \"user_log_path\",\n    \"user_music_dir\",\n    \"user_music_path\",\n    \"user_pictures_dir\",\n    \"user_pictures_path\",\n    \"user_runtime_dir\",\n    \"user_runtime_path\",\n    \"user_state_dir\",\n    \"user_state_path\",\n    \"user_videos_dir\",\n    \"user_videos_path\",\n]\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/platformdirs/__main__.py","size":1493,"sha1":"df2960f680c198bd57b4947844c7fff358b8d8e5","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Main entry point.\"\"\"\n\nfrom __future__ import annotations\n\nfrom platformdirs import PlatformDirs, __version__\n\nPROPS = (\n    \"user_data_dir\",\n    \"user_config_dir\",\n    \"user_cache_dir\",\n    \"user_state_dir\",\n    \"user_log_dir\",\n    \"user_documents_dir\",\n    \"user_downloads_dir\",\n    \"user_pictures_dir\",\n    \"user_videos_dir\",\n    \"user_music_dir\",\n    \"user_runtime_dir\",\n    \"site_data_dir\",\n    \"site_config_dir\",\n    \"site_cache_dir\",\n    \"site_runtime_dir\",\n)\n\n\ndef main() -> None:\n    \"\"\"Run the main entry point.\"\"\"\n    app_name = \"MyApp\"\n    app_author = \"MyCompany\"\n\n    print(f\"-- platformdirs {__version__} --\")  # noqa: T201\n\n    print(\"-- app dirs (with optional 'version')\")  # noqa: T201\n    dirs = PlatformDirs(app_name, app_author, version=\"1.0\")\n    for prop in PROPS:\n        print(f\"{prop}: {getattr(dirs, prop)}\")  # noqa: T201\n\n    print(\"\\n-- app dirs (without optional 'version')\")  # noqa: T201\n    dirs = PlatformDirs(app_name, app_author)\n    for prop in PROPS:\n        print(f\"{prop}: {getattr(dirs, prop)}\")  # noqa: T201\n\n    print(\"\\n-- app dirs (without optional 'appauthor')\")  # noqa: T201\n    dirs = PlatformDirs(app_name)\n    for prop in PROPS:\n        print(f\"{prop}: {getattr(dirs, prop)}\")  # noqa: T201\n\n    print(\"\\n-- app dirs (with disabled 'appauthor')\")  # noqa: T201\n    dirs = PlatformDirs(app_name, appauthor=False)\n    for prop in PROPS:\n        print(f\"{prop}: {getattr(dirs, prop)}\")  # noqa: T201\n\n\nif __name__ == \"__main__\":\n    main()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/platformdirs/android.py","size":9016,"sha1":"bf25c572be665d4c89c5e0ce7dda946477179151","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Android.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport re\nimport sys\nfrom functools import lru_cache\nfrom typing import TYPE_CHECKING, cast\n\nfrom .api import PlatformDirsABC\n\n\nclass Android(PlatformDirsABC):\n    \"\"\"\n    Follows the guidance `from here <https://android.stackexchange.com/a/216132>`_.\n\n    Makes use of the `appname <platformdirs.api.PlatformDirsABC.appname>`, `version\n    <platformdirs.api.PlatformDirsABC.version>`, `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n\n    \"\"\"\n\n    @property\n    def user_data_dir(self) -> str:\n        \"\"\":return: data directory tied to the user, e.g. ``/data/user/<userid>/<packagename>/files/<AppName>``\"\"\"\n        return self._append_app_name_and_version(cast(str, _android_folder()), \"files\")\n\n    @property\n    def site_data_dir(self) -> str:\n        \"\"\":return: data directory shared by users, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def user_config_dir(self) -> str:\n        \"\"\"\n        :return: config directory tied to the user, e.g. \\\n        ``/data/user/<userid>/<packagename>/shared_prefs/<AppName>``\n        \"\"\"\n        return self._append_app_name_and_version(cast(str, _android_folder()), \"shared_prefs\")\n\n    @property\n    def site_config_dir(self) -> str:\n        \"\"\":return: config directory shared by the users, same as `user_config_dir`\"\"\"\n        return self.user_config_dir\n\n    @property\n    def user_cache_dir(self) -> str:\n        \"\"\":return: cache directory tied to the user, e.g.,``/data/user/<userid>/<packagename>/cache/<AppName>``\"\"\"\n        return self._append_app_name_and_version(cast(str, _android_folder()), \"cache\")\n\n    @property\n    def site_cache_dir(self) -> str:\n        \"\"\":return: cache directory shared by users, same as `user_cache_dir`\"\"\"\n        return self.user_cache_dir\n\n    @property\n    def user_state_dir(self) -> str:\n        \"\"\":return: state directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def user_log_dir(self) -> str:\n        \"\"\"\n        :return: log directory tied to the user, same as `user_cache_dir` if not opinionated else ``log`` in it,\n          e.g. ``/data/user/<userid>/<packagename>/cache/<AppName>/log``\n        \"\"\"\n        path = self.user_cache_dir\n        if self.opinion:\n            path = os.path.join(path, \"log\")  # noqa: PTH118\n        return path\n\n    @property\n    def user_documents_dir(self) -> str:\n        \"\"\":return: documents directory tied to the user e.g. ``/storage/emulated/0/Documents``\"\"\"\n        return _android_documents_folder()\n\n    @property\n    def user_downloads_dir(self) -> str:\n        \"\"\":return: downloads directory tied to the user e.g. ``/storage/emulated/0/Downloads``\"\"\"\n        return _android_downloads_folder()\n\n    @property\n    def user_pictures_dir(self) -> str:\n        \"\"\":return: pictures directory tied to the user e.g. ``/storage/emulated/0/Pictures``\"\"\"\n        return _android_pictures_folder()\n\n    @property\n    def user_videos_dir(self) -> str:\n        \"\"\":return: videos directory tied to the user e.g. ``/storage/emulated/0/DCIM/Camera``\"\"\"\n        return _android_videos_folder()\n\n    @property\n    def user_music_dir(self) -> str:\n        \"\"\":return: music directory tied to the user e.g. ``/storage/emulated/0/Music``\"\"\"\n        return _android_music_folder()\n\n    @property\n    def user_desktop_dir(self) -> str:\n        \"\"\":return: desktop directory tied to the user e.g. ``/storage/emulated/0/Desktop``\"\"\"\n        return \"/storage/emulated/0/Desktop\"\n\n    @property\n    def user_runtime_dir(self) -> str:\n        \"\"\"\n        :return: runtime directory tied to the user, same as `user_cache_dir` if not opinionated else ``tmp`` in it,\n          e.g. ``/data/user/<userid>/<packagename>/cache/<AppName>/tmp``\n        \"\"\"\n        path = self.user_cache_dir\n        if self.opinion:\n            path = os.path.join(path, \"tmp\")  # noqa: PTH118\n        return path\n\n    @property\n    def site_runtime_dir(self) -> str:\n        \"\"\":return: runtime directory shared by users, same as `user_runtime_dir`\"\"\"\n        return self.user_runtime_dir\n\n\n@lru_cache(maxsize=1)\ndef _android_folder() -> str | None:  # noqa: C901, PLR0912\n    \"\"\":return: base folder for the Android OS or None if it cannot be found\"\"\"\n    result: str | None = None\n    # type checker isn't happy with our \"import android\", just don't do this when type checking see\n    # https://stackoverflow.com/a/61394121\n    if not TYPE_CHECKING:\n        try:\n            # First try to get a path to android app using python4android (if available)...\n            from android import mActivity  # noqa: PLC0415\n\n            context = cast(\"android.content.Context\", mActivity.getApplicationContext())  # noqa: F821\n            result = context.getFilesDir().getParentFile().getAbsolutePath()\n        except Exception:  # noqa: BLE001\n            result = None\n    if result is None:\n        try:\n            # ...and fall back to using plain pyjnius, if python4android isn't available or doesn't deliver any useful\n            # result...\n            from jnius import autoclass  # noqa: PLC0415\n\n            context = autoclass(\"android.content.Context\")\n            result = context.getFilesDir().getParentFile().getAbsolutePath()\n        except Exception:  # noqa: BLE001\n            result = None\n    if result is None:\n        # and if that fails, too, find an android folder looking at path on the sys.path\n        # warning: only works for apps installed under /data, not adopted storage etc.\n        pattern = re.compile(r\"/data/(data|user/\\d+)/(.+)/files\")\n        for path in sys.path:\n            if pattern.match(path):\n                result = path.split(\"/files\")[0]\n                break\n        else:\n            result = None\n    if result is None:\n        # one last try: find an android folder looking at path on the sys.path taking adopted storage paths into\n        # account\n        pattern = re.compile(r\"/mnt/expand/[a-fA-F0-9-]{36}/(data|user/\\d+)/(.+)/files\")\n        for path in sys.path:\n            if pattern.match(path):\n                result = path.split(\"/files\")[0]\n                break\n        else:\n            result = None\n    return result\n\n\n@lru_cache(maxsize=1)\ndef _android_documents_folder() -> str:\n    \"\"\":return: documents folder for the Android OS\"\"\"\n    # Get directories with pyjnius\n    try:\n        from jnius import autoclass  # noqa: PLC0415\n\n        context = autoclass(\"android.content.Context\")\n        environment = autoclass(\"android.os.Environment\")\n        documents_dir: str = context.getExternalFilesDir(environment.DIRECTORY_DOCUMENTS).getAbsolutePath()\n    except Exception:  # noqa: BLE001\n        documents_dir = \"/storage/emulated/0/Documents\"\n\n    return documents_dir\n\n\n@lru_cache(maxsize=1)\ndef _android_downloads_folder() -> str:\n    \"\"\":return: downloads folder for the Android OS\"\"\"\n    # Get directories with pyjnius\n    try:\n        from jnius import autoclass  # noqa: PLC0415\n\n        context = autoclass(\"android.content.Context\")\n        environment = autoclass(\"android.os.Environment\")\n        downloads_dir: str = context.getExternalFilesDir(environment.DIRECTORY_DOWNLOADS).getAbsolutePath()\n    except Exception:  # noqa: BLE001\n        downloads_dir = \"/storage/emulated/0/Downloads\"\n\n    return downloads_dir\n\n\n@lru_cache(maxsize=1)\ndef _android_pictures_folder() -> str:\n    \"\"\":return: pictures folder for the Android OS\"\"\"\n    # Get directories with pyjnius\n    try:\n        from jnius import autoclass  # noqa: PLC0415\n\n        context = autoclass(\"android.content.Context\")\n        environment = autoclass(\"android.os.Environment\")\n        pictures_dir: str = context.getExternalFilesDir(environment.DIRECTORY_PICTURES).getAbsolutePath()\n    except Exception:  # noqa: BLE001\n        pictures_dir = \"/storage/emulated/0/Pictures\"\n\n    return pictures_dir\n\n\n@lru_cache(maxsize=1)\ndef _android_videos_folder() -> str:\n    \"\"\":return: videos folder for the Android OS\"\"\"\n    # Get directories with pyjnius\n    try:\n        from jnius import autoclass  # noqa: PLC0415\n\n        context = autoclass(\"android.content.Context\")\n        environment = autoclass(\"android.os.Environment\")\n        videos_dir: str = context.getExternalFilesDir(environment.DIRECTORY_DCIM).getAbsolutePath()\n    except Exception:  # noqa: BLE001\n        videos_dir = \"/storage/emulated/0/DCIM/Camera\"\n\n    return videos_dir\n\n\n@lru_cache(maxsize=1)\ndef _android_music_folder() -> str:\n    \"\"\":return: music folder for the Android OS\"\"\"\n    # Get directories with pyjnius\n    try:\n        from jnius import autoclass  # noqa: PLC0415\n\n        context = autoclass(\"android.content.Context\")\n        environment = autoclass(\"android.os.Environment\")\n        music_dir: str = context.getExternalFilesDir(environment.DIRECTORY_MUSIC).getAbsolutePath()\n    except Exception:  # noqa: BLE001\n        music_dir = \"/storage/emulated/0/Music\"\n\n    return music_dir\n\n\n__all__ = [\n    \"Android\",\n]\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/platformdirs/api.py","size":8996,"sha1":"d73982f2b3ec7dea76426031128df47cec8525a4","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Base API.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom abc import ABC, abstractmethod\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from typing import Iterator, Literal\n\n\nclass PlatformDirsABC(ABC):  # noqa: PLR0904\n    \"\"\"Abstract base class for platform directories.\"\"\"\n\n    def __init__(  # noqa: PLR0913, PLR0917\n        self,\n        appname: str | None = None,\n        appauthor: str | None | Literal[False] = None,\n        version: str | None = None,\n        roaming: bool = False,  # noqa: FBT001, FBT002\n        multipath: bool = False,  # noqa: FBT001, FBT002\n        opinion: bool = True,  # noqa: FBT001, FBT002\n        ensure_exists: bool = False,  # noqa: FBT001, FBT002\n    ) -> None:\n        \"\"\"\n        Create a new platform directory.\n\n        :param appname: See `appname`.\n        :param appauthor: See `appauthor`.\n        :param version: See `version`.\n        :param roaming: See `roaming`.\n        :param multipath: See `multipath`.\n        :param opinion: See `opinion`.\n        :param ensure_exists: See `ensure_exists`.\n\n        \"\"\"\n        self.appname = appname  #: The name of application.\n        self.appauthor = appauthor\n        \"\"\"\n        The name of the app author or distributing body for this application.\n\n        Typically, it is the owning company name. Defaults to `appname`. You may pass ``False`` to disable it.\n\n        \"\"\"\n        self.version = version\n        \"\"\"\n        An optional version path element to append to the path.\n\n        You might want to use this if you want multiple versions of your app to be able to run independently. If used,\n        this would typically be ``<major>.<minor>``.\n\n        \"\"\"\n        self.roaming = roaming\n        \"\"\"\n        Whether to use the roaming appdata directory on Windows.\n\n        That means that for users on a Windows network setup for roaming profiles, this user data will be synced on\n        login (see\n        `here <https://technet.microsoft.com/en-us/library/cc766489(WS.10).aspx>`_).\n\n        \"\"\"\n        self.multipath = multipath\n        \"\"\"\n        An optional parameter which indicates that the entire list of data dirs should be returned.\n\n        By default, the first item would only be returned.\n\n        \"\"\"\n        self.opinion = opinion  #: A flag to indicating to use opinionated values.\n        self.ensure_exists = ensure_exists\n        \"\"\"\n        Optionally create the directory (and any missing parents) upon access if it does not exist.\n\n        By default, no directories are created.\n\n        \"\"\"\n\n    def _append_app_name_and_version(self, *base: str) -> str:\n        params = list(base[1:])\n        if self.appname:\n            params.append(self.appname)\n            if self.version:\n                params.append(self.version)\n        path = os.path.join(base[0], *params)  # noqa: PTH118\n        self._optionally_create_directory(path)\n        return path\n\n    def _optionally_create_directory(self, path: str) -> None:\n        if self.ensure_exists:\n            Path(path).mkdir(parents=True, exist_ok=True)\n\n    @property\n    @abstractmethod\n    def user_data_dir(self) -> str:\n        \"\"\":return: data directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def site_data_dir(self) -> str:\n        \"\"\":return: data directory shared by users\"\"\"\n\n    @property\n    @abstractmethod\n    def user_config_dir(self) -> str:\n        \"\"\":return: config directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def site_config_dir(self) -> str:\n        \"\"\":return: config directory shared by the users\"\"\"\n\n    @property\n    @abstractmethod\n    def user_cache_dir(self) -> str:\n        \"\"\":return: cache directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def site_cache_dir(self) -> str:\n        \"\"\":return: cache directory shared by users\"\"\"\n\n    @property\n    @abstractmethod\n    def user_state_dir(self) -> str:\n        \"\"\":return: state directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_log_dir(self) -> str:\n        \"\"\":return: log directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_documents_dir(self) -> str:\n        \"\"\":return: documents directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_downloads_dir(self) -> str:\n        \"\"\":return: downloads directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_pictures_dir(self) -> str:\n        \"\"\":return: pictures directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_videos_dir(self) -> str:\n        \"\"\":return: videos directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_music_dir(self) -> str:\n        \"\"\":return: music directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_desktop_dir(self) -> str:\n        \"\"\":return: desktop directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def user_runtime_dir(self) -> str:\n        \"\"\":return: runtime directory tied to the user\"\"\"\n\n    @property\n    @abstractmethod\n    def site_runtime_dir(self) -> str:\n        \"\"\":return: runtime directory shared by users\"\"\"\n\n    @property\n    def user_data_path(self) -> Path:\n        \"\"\":return: data path tied to the user\"\"\"\n        return Path(self.user_data_dir)\n\n    @property\n    def site_data_path(self) -> Path:\n        \"\"\":return: data path shared by users\"\"\"\n        return Path(self.site_data_dir)\n\n    @property\n    def user_config_path(self) -> Path:\n        \"\"\":return: config path tied to the user\"\"\"\n        return Path(self.user_config_dir)\n\n    @property\n    def site_config_path(self) -> Path:\n        \"\"\":return: config path shared by the users\"\"\"\n        return Path(self.site_config_dir)\n\n    @property\n    def user_cache_path(self) -> Path:\n        \"\"\":return: cache path tied to the user\"\"\"\n        return Path(self.user_cache_dir)\n\n    @property\n    def site_cache_path(self) -> Path:\n        \"\"\":return: cache path shared by users\"\"\"\n        return Path(self.site_cache_dir)\n\n    @property\n    def user_state_path(self) -> Path:\n        \"\"\":return: state path tied to the user\"\"\"\n        return Path(self.user_state_dir)\n\n    @property\n    def user_log_path(self) -> Path:\n        \"\"\":return: log path tied to the user\"\"\"\n        return Path(self.user_log_dir)\n\n    @property\n    def user_documents_path(self) -> Path:\n        \"\"\":return: documents a path tied to the user\"\"\"\n        return Path(self.user_documents_dir)\n\n    @property\n    def user_downloads_path(self) -> Path:\n        \"\"\":return: downloads path tied to the user\"\"\"\n        return Path(self.user_downloads_dir)\n\n    @property\n    def user_pictures_path(self) -> Path:\n        \"\"\":return: pictures path tied to the user\"\"\"\n        return Path(self.user_pictures_dir)\n\n    @property\n    def user_videos_path(self) -> Path:\n        \"\"\":return: videos path tied to the user\"\"\"\n        return Path(self.user_videos_dir)\n\n    @property\n    def user_music_path(self) -> Path:\n        \"\"\":return: music path tied to the user\"\"\"\n        return Path(self.user_music_dir)\n\n    @property\n    def user_desktop_path(self) -> Path:\n        \"\"\":return: desktop path tied to the user\"\"\"\n        return Path(self.user_desktop_dir)\n\n    @property\n    def user_runtime_path(self) -> Path:\n        \"\"\":return: runtime path tied to the user\"\"\"\n        return Path(self.user_runtime_dir)\n\n    @property\n    def site_runtime_path(self) -> Path:\n        \"\"\":return: runtime path shared by users\"\"\"\n        return Path(self.site_runtime_dir)\n\n    def iter_config_dirs(self) -> Iterator[str]:\n        \"\"\":yield: all user and site configuration directories.\"\"\"\n        yield self.user_config_dir\n        yield self.site_config_dir\n\n    def iter_data_dirs(self) -> Iterator[str]:\n        \"\"\":yield: all user and site data directories.\"\"\"\n        yield self.user_data_dir\n        yield self.site_data_dir\n\n    def iter_cache_dirs(self) -> Iterator[str]:\n        \"\"\":yield: all user and site cache directories.\"\"\"\n        yield self.user_cache_dir\n        yield self.site_cache_dir\n\n    def iter_runtime_dirs(self) -> Iterator[str]:\n        \"\"\":yield: all user and site runtime directories.\"\"\"\n        yield self.user_runtime_dir\n        yield self.site_runtime_dir\n\n    def iter_config_paths(self) -> Iterator[Path]:\n        \"\"\":yield: all user and site configuration paths.\"\"\"\n        for path in self.iter_config_dirs():\n            yield Path(path)\n\n    def iter_data_paths(self) -> Iterator[Path]:\n        \"\"\":yield: all user and site data paths.\"\"\"\n        for path in self.iter_data_dirs():\n            yield Path(path)\n\n    def iter_cache_paths(self) -> Iterator[Path]:\n        \"\"\":yield: all user and site cache paths.\"\"\"\n        for path in self.iter_cache_dirs():\n            yield Path(path)\n\n    def iter_runtime_paths(self) -> Iterator[Path]:\n        \"\"\":yield: all user and site runtime paths.\"\"\"\n        for path in self.iter_runtime_dirs():\n            yield Path(path)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/platformdirs/macos.py","size":5580,"sha1":"116c8b94729c9617a4411feb3541e4b5712a21bb","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"macOS.\"\"\"\n\nfrom __future__ import annotations\n\nimport os.path\nimport sys\n\nfrom .api import PlatformDirsABC\n\n\nclass MacOS(PlatformDirsABC):\n    \"\"\"\n    Platform directories for the macOS operating system.\n\n    Follows the guidance from\n    `Apple documentation <https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/MacOSXDirectories/MacOSXDirectories.html>`_.\n    Makes use of the `appname <platformdirs.api.PlatformDirsABC.appname>`,\n    `version <platformdirs.api.PlatformDirsABC.version>`,\n    `ensure_exists <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n\n    \"\"\"\n\n    @property\n    def user_data_dir(self) -> str:\n        \"\"\":return: data directory tied to the user, e.g. ``~/Library/Application Support/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(os.path.expanduser(\"~/Library/Application Support\"))  # noqa: PTH111\n\n    @property\n    def site_data_dir(self) -> str:\n        \"\"\"\n        :return: data directory shared by users, e.g. ``/Library/Application Support/$appname/$version``.\n          If we're using a Python binary managed by `Homebrew <https://brew.sh>`_, the directory\n          will be under the Homebrew prefix, e.g. ``/opt/homebrew/share/$appname/$version``.\n          If `multipath <platformdirs.api.PlatformDirsABC.multipath>` is enabled, and we're in Homebrew,\n          the response is a multi-path string separated by \":\", e.g.\n          ``/opt/homebrew/share/$appname/$version:/Library/Application Support/$appname/$version``\n        \"\"\"\n        is_homebrew = sys.prefix.startswith(\"/opt/homebrew\")\n        path_list = [self._append_app_name_and_version(\"/opt/homebrew/share\")] if is_homebrew else []\n        path_list.append(self._append_app_name_and_version(\"/Library/Application Support\"))\n        if self.multipath:\n            return os.pathsep.join(path_list)\n        return path_list[0]\n\n    @property\n    def user_config_dir(self) -> str:\n        \"\"\":return: config directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def site_config_dir(self) -> str:\n        \"\"\":return: config directory shared by the users, same as `site_data_dir`\"\"\"\n        return self.site_data_dir\n\n    @property\n    def user_cache_dir(self) -> str:\n        \"\"\":return: cache directory tied to the user, e.g. ``~/Library/Caches/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(os.path.expanduser(\"~/Library/Caches\"))  # noqa: PTH111\n\n    @property\n    def site_cache_dir(self) -> str:\n        \"\"\"\n        :return: cache directory shared by users, e.g. ``/Library/Caches/$appname/$version``.\n          If we're using a Python binary managed by `Homebrew <https://brew.sh>`_, the directory\n          will be under the Homebrew prefix, e.g. ``/opt/homebrew/var/cache/$appname/$version``.\n          If `multipath <platformdirs.api.PlatformDirsABC.multipath>` is enabled, and we're in Homebrew,\n          the response is a multi-path string separated by \":\", e.g.\n          ``/opt/homebrew/var/cache/$appname/$version:/Library/Caches/$appname/$version``\n        \"\"\"\n        is_homebrew = sys.prefix.startswith(\"/opt/homebrew\")\n        path_list = [self._append_app_name_and_version(\"/opt/homebrew/var/cache\")] if is_homebrew else []\n        path_list.append(self._append_app_name_and_version(\"/Library/Caches\"))\n        if self.multipath:\n            return os.pathsep.join(path_list)\n        return path_list[0]\n\n    @property\n    def user_state_dir(self) -> str:\n        \"\"\":return: state directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def user_log_dir(self) -> str:\n        \"\"\":return: log directory tied to the user, e.g. ``~/Library/Logs/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(os.path.expanduser(\"~/Library/Logs\"))  # noqa: PTH111\n\n    @property\n    def user_documents_dir(self) -> str:\n        \"\"\":return: documents directory tied to the user, e.g. ``~/Documents``\"\"\"\n        return os.path.expanduser(\"~/Documents\")  # noqa: PTH111\n\n    @property\n    def user_downloads_dir(self) -> str:\n        \"\"\":return: downloads directory tied to the user, e.g. ``~/Downloads``\"\"\"\n        return os.path.expanduser(\"~/Downloads\")  # noqa: PTH111\n\n    @property\n    def user_pictures_dir(self) -> str:\n        \"\"\":return: pictures directory tied to the user, e.g. ``~/Pictures``\"\"\"\n        return os.path.expanduser(\"~/Pictures\")  # noqa: PTH111\n\n    @property\n    def user_videos_dir(self) -> str:\n        \"\"\":return: videos directory tied to the user, e.g. ``~/Movies``\"\"\"\n        return os.path.expanduser(\"~/Movies\")  # noqa: PTH111\n\n    @property\n    def user_music_dir(self) -> str:\n        \"\"\":return: music directory tied to the user, e.g. ``~/Music``\"\"\"\n        return os.path.expanduser(\"~/Music\")  # noqa: PTH111\n\n    @property\n    def user_desktop_dir(self) -> str:\n        \"\"\":return: desktop directory tied to the user, e.g. ``~/Desktop``\"\"\"\n        return os.path.expanduser(\"~/Desktop\")  # noqa: PTH111\n\n    @property\n    def user_runtime_dir(self) -> str:\n        \"\"\":return: runtime directory tied to the user, e.g. ``~/Library/Caches/TemporaryItems/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(os.path.expanduser(\"~/Library/Caches/TemporaryItems\"))  # noqa: PTH111\n\n    @property\n    def site_runtime_dir(self) -> str:\n        \"\"\":return: runtime directory shared by users, same as `user_runtime_dir`\"\"\"\n        return self.user_runtime_dir\n\n\n__all__ = [\n    \"MacOS\",\n]\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/platformdirs/unix.py","size":10643,"sha1":"a0e29caf2d5b3ac218a7ed5ca8c501c591cda060","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Unix.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport sys\nfrom configparser import ConfigParser\nfrom pathlib import Path\nfrom typing import Iterator, NoReturn\n\nfrom .api import PlatformDirsABC\n\nif sys.platform == \"win32\":\n\n    def getuid() -> NoReturn:\n        msg = \"should only be used on Unix\"\n        raise RuntimeError(msg)\n\nelse:\n    from os import getuid\n\n\nclass Unix(PlatformDirsABC):  # noqa: PLR0904\n    \"\"\"\n    On Unix/Linux, we follow the `XDG Basedir Spec <https://specifications.freedesktop.org/basedir-spec/basedir-spec-\n    latest.html>`_.\n\n    The spec allows overriding directories with environment variables. The examples shown are the default values,\n    alongside the name of the environment variable that overrides them. Makes use of the `appname\n    <platformdirs.api.PlatformDirsABC.appname>`, `version <platformdirs.api.PlatformDirsABC.version>`, `multipath\n    <platformdirs.api.PlatformDirsABC.multipath>`, `opinion <platformdirs.api.PlatformDirsABC.opinion>`, `ensure_exists\n    <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n\n    \"\"\"\n\n    @property\n    def user_data_dir(self) -> str:\n        \"\"\"\n        :return: data directory tied to the user, e.g. ``~/.local/share/$appname/$version`` or\n         ``$XDG_DATA_HOME/$appname/$version``\n        \"\"\"\n        path = os.environ.get(\"XDG_DATA_HOME\", \"\")\n        if not path.strip():\n            path = os.path.expanduser(\"~/.local/share\")  # noqa: PTH111\n        return self._append_app_name_and_version(path)\n\n    @property\n    def _site_data_dirs(self) -> list[str]:\n        path = os.environ.get(\"XDG_DATA_DIRS\", \"\")\n        if not path.strip():\n            path = f\"/usr/local/share{os.pathsep}/usr/share\"\n        return [self._append_app_name_and_version(p) for p in path.split(os.pathsep)]\n\n    @property\n    def site_data_dir(self) -> str:\n        \"\"\"\n        :return: data directories shared by users (if `multipath <platformdirs.api.PlatformDirsABC.multipath>` is\n         enabled and ``XDG_DATA_DIRS`` is set and a multi path the response is also a multi path separated by the\n         OS path separator), e.g. ``/usr/local/share/$appname/$version`` or ``/usr/share/$appname/$version``\n        \"\"\"\n        # XDG default for $XDG_DATA_DIRS; only first, if multipath is False\n        dirs = self._site_data_dirs\n        if not self.multipath:\n            return dirs[0]\n        return os.pathsep.join(dirs)\n\n    @property\n    def user_config_dir(self) -> str:\n        \"\"\"\n        :return: config directory tied to the user, e.g. ``~/.config/$appname/$version`` or\n         ``$XDG_CONFIG_HOME/$appname/$version``\n        \"\"\"\n        path = os.environ.get(\"XDG_CONFIG_HOME\", \"\")\n        if not path.strip():\n            path = os.path.expanduser(\"~/.config\")  # noqa: PTH111\n        return self._append_app_name_and_version(path)\n\n    @property\n    def _site_config_dirs(self) -> list[str]:\n        path = os.environ.get(\"XDG_CONFIG_DIRS\", \"\")\n        if not path.strip():\n            path = \"/etc/xdg\"\n        return [self._append_app_name_and_version(p) for p in path.split(os.pathsep)]\n\n    @property\n    def site_config_dir(self) -> str:\n        \"\"\"\n        :return: config directories shared by users (if `multipath <platformdirs.api.PlatformDirsABC.multipath>`\n         is enabled and ``XDG_CONFIG_DIRS`` is set and a multi path the response is also a multi path separated by\n         the OS path separator), e.g. ``/etc/xdg/$appname/$version``\n        \"\"\"\n        # XDG default for $XDG_CONFIG_DIRS only first, if multipath is False\n        dirs = self._site_config_dirs\n        if not self.multipath:\n            return dirs[0]\n        return os.pathsep.join(dirs)\n\n    @property\n    def user_cache_dir(self) -> str:\n        \"\"\"\n        :return: cache directory tied to the user, e.g. ``~/.cache/$appname/$version`` or\n         ``~/$XDG_CACHE_HOME/$appname/$version``\n        \"\"\"\n        path = os.environ.get(\"XDG_CACHE_HOME\", \"\")\n        if not path.strip():\n            path = os.path.expanduser(\"~/.cache\")  # noqa: PTH111\n        return self._append_app_name_and_version(path)\n\n    @property\n    def site_cache_dir(self) -> str:\n        \"\"\":return: cache directory shared by users, e.g. ``/var/cache/$appname/$version``\"\"\"\n        return self._append_app_name_and_version(\"/var/cache\")\n\n    @property\n    def user_state_dir(self) -> str:\n        \"\"\"\n        :return: state directory tied to the user, e.g. ``~/.local/state/$appname/$version`` or\n         ``$XDG_STATE_HOME/$appname/$version``\n        \"\"\"\n        path = os.environ.get(\"XDG_STATE_HOME\", \"\")\n        if not path.strip():\n            path = os.path.expanduser(\"~/.local/state\")  # noqa: PTH111\n        return self._append_app_name_and_version(path)\n\n    @property\n    def user_log_dir(self) -> str:\n        \"\"\":return: log directory tied to the user, same as `user_state_dir` if not opinionated else ``log`` in it\"\"\"\n        path = self.user_state_dir\n        if self.opinion:\n            path = os.path.join(path, \"log\")  # noqa: PTH118\n            self._optionally_create_directory(path)\n        return path\n\n    @property\n    def user_documents_dir(self) -> str:\n        \"\"\":return: documents directory tied to the user, e.g. ``~/Documents``\"\"\"\n        return _get_user_media_dir(\"XDG_DOCUMENTS_DIR\", \"~/Documents\")\n\n    @property\n    def user_downloads_dir(self) -> str:\n        \"\"\":return: downloads directory tied to the user, e.g. ``~/Downloads``\"\"\"\n        return _get_user_media_dir(\"XDG_DOWNLOAD_DIR\", \"~/Downloads\")\n\n    @property\n    def user_pictures_dir(self) -> str:\n        \"\"\":return: pictures directory tied to the user, e.g. ``~/Pictures``\"\"\"\n        return _get_user_media_dir(\"XDG_PICTURES_DIR\", \"~/Pictures\")\n\n    @property\n    def user_videos_dir(self) -> str:\n        \"\"\":return: videos directory tied to the user, e.g. ``~/Videos``\"\"\"\n        return _get_user_media_dir(\"XDG_VIDEOS_DIR\", \"~/Videos\")\n\n    @property\n    def user_music_dir(self) -> str:\n        \"\"\":return: music directory tied to the user, e.g. ``~/Music``\"\"\"\n        return _get_user_media_dir(\"XDG_MUSIC_DIR\", \"~/Music\")\n\n    @property\n    def user_desktop_dir(self) -> str:\n        \"\"\":return: desktop directory tied to the user, e.g. ``~/Desktop``\"\"\"\n        return _get_user_media_dir(\"XDG_DESKTOP_DIR\", \"~/Desktop\")\n\n    @property\n    def user_runtime_dir(self) -> str:\n        \"\"\"\n        :return: runtime directory tied to the user, e.g. ``/run/user/$(id -u)/$appname/$version`` or\n         ``$XDG_RUNTIME_DIR/$appname/$version``.\n\n         For FreeBSD/OpenBSD/NetBSD, it would return ``/var/run/user/$(id -u)/$appname/$version`` if\n         exists, otherwise ``/tmp/runtime-$(id -u)/$appname/$version``, if``$XDG_RUNTIME_DIR``\n         is not set.\n        \"\"\"\n        path = os.environ.get(\"XDG_RUNTIME_DIR\", \"\")\n        if not path.strip():\n            if sys.platform.startswith((\"freebsd\", \"openbsd\", \"netbsd\")):\n                path = f\"/var/run/user/{getuid()}\"\n                if not Path(path).exists():\n                    path = f\"/tmp/runtime-{getuid()}\"  # noqa: S108\n            else:\n                path = f\"/run/user/{getuid()}\"\n        return self._append_app_name_and_version(path)\n\n    @property\n    def site_runtime_dir(self) -> str:\n        \"\"\"\n        :return: runtime directory shared by users, e.g. ``/run/$appname/$version`` or \\\n        ``$XDG_RUNTIME_DIR/$appname/$version``.\n\n        Note that this behaves almost exactly like `user_runtime_dir` if ``$XDG_RUNTIME_DIR`` is set, but will\n        fall back to paths associated to the root user instead of a regular logged-in user if it's not set.\n\n        If you wish to ensure that a logged-in root user path is returned e.g. ``/run/user/0``, use `user_runtime_dir`\n        instead.\n\n        For FreeBSD/OpenBSD/NetBSD, it would return ``/var/run/$appname/$version`` if ``$XDG_RUNTIME_DIR`` is not set.\n        \"\"\"\n        path = os.environ.get(\"XDG_RUNTIME_DIR\", \"\")\n        if not path.strip():\n            if sys.platform.startswith((\"freebsd\", \"openbsd\", \"netbsd\")):\n                path = \"/var/run\"\n            else:\n                path = \"/run\"\n        return self._append_app_name_and_version(path)\n\n    @property\n    def site_data_path(self) -> Path:\n        \"\"\":return: data path shared by users. Only return the first item, even if ``multipath`` is set to ``True``\"\"\"\n        return self._first_item_as_path_if_multipath(self.site_data_dir)\n\n    @property\n    def site_config_path(self) -> Path:\n        \"\"\":return: config path shared by the users, returns the first item, even if ``multipath`` is set to ``True``\"\"\"\n        return self._first_item_as_path_if_multipath(self.site_config_dir)\n\n    @property\n    def site_cache_path(self) -> Path:\n        \"\"\":return: cache path shared by users. Only return the first item, even if ``multipath`` is set to ``True``\"\"\"\n        return self._first_item_as_path_if_multipath(self.site_cache_dir)\n\n    def _first_item_as_path_if_multipath(self, directory: str) -> Path:\n        if self.multipath:\n            # If multipath is True, the first path is returned.\n            directory = directory.split(os.pathsep)[0]\n        return Path(directory)\n\n    def iter_config_dirs(self) -> Iterator[str]:\n        \"\"\":yield: all user and site configuration directories.\"\"\"\n        yield self.user_config_dir\n        yield from self._site_config_dirs\n\n    def iter_data_dirs(self) -> Iterator[str]:\n        \"\"\":yield: all user and site data directories.\"\"\"\n        yield self.user_data_dir\n        yield from self._site_data_dirs\n\n\ndef _get_user_media_dir(env_var: str, fallback_tilde_path: str) -> str:\n    media_dir = _get_user_dirs_folder(env_var)\n    if media_dir is None:\n        media_dir = os.environ.get(env_var, \"\").strip()\n        if not media_dir:\n            media_dir = os.path.expanduser(fallback_tilde_path)  # noqa: PTH111\n\n    return media_dir\n\n\ndef _get_user_dirs_folder(key: str) -> str | None:\n    \"\"\"\n    Return directory from user-dirs.dirs config file.\n\n    See https://freedesktop.org/wiki/Software/xdg-user-dirs/.\n\n    \"\"\"\n    user_dirs_config_path = Path(Unix().user_config_dir) / \"user-dirs.dirs\"\n    if user_dirs_config_path.exists():\n        parser = ConfigParser()\n\n        with user_dirs_config_path.open() as stream:\n            # Add fake section header, so ConfigParser doesn't complain\n            parser.read_string(f\"[top]\\n{stream.read()}\")\n\n        if key not in parser[\"top\"]:\n            return None\n\n        path = parser[\"top\"][key].strip('\"')\n        # Handle relative home paths\n        return path.replace(\"$HOME\", os.path.expanduser(\"~\"))  # noqa: PTH111\n\n    return None\n\n\n__all__ = [\n    \"Unix\",\n]\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/platformdirs/version.py","size":411,"sha1":"21d175117dedb623336ad4880a945be41fe0789b","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# file generated by setuptools_scm\n# don't change, don't track in version control\nTYPE_CHECKING = False\nif TYPE_CHECKING:\n    from typing import Tuple, Union\n    VERSION_TUPLE = Tuple[Union[int, str], ...]\nelse:\n    VERSION_TUPLE = object\n\nversion: str\n__version__: str\n__version_tuple__: VERSION_TUPLE\nversion_tuple: VERSION_TUPLE\n\n__version__ = version = '4.2.2'\n__version_tuple__ = version_tuple = (4, 2, 2)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/platformdirs/windows.py","size":10125,"sha1":"920d92beeaa289b22c86911d1bbb942ca79cc167","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Windows.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport sys\nfrom functools import lru_cache\nfrom typing import TYPE_CHECKING\n\nfrom .api import PlatformDirsABC\n\nif TYPE_CHECKING:\n    from collections.abc import Callable\n\n\nclass Windows(PlatformDirsABC):\n    \"\"\"\n    `MSDN on where to store app data files <https://learn.microsoft.com/en-us/windows/win32/shell/knownfolderid>`_.\n\n    Makes use of the `appname <platformdirs.api.PlatformDirsABC.appname>`, `appauthor\n    <platformdirs.api.PlatformDirsABC.appauthor>`, `version <platformdirs.api.PlatformDirsABC.version>`, `roaming\n    <platformdirs.api.PlatformDirsABC.roaming>`, `opinion <platformdirs.api.PlatformDirsABC.opinion>`, `ensure_exists\n    <platformdirs.api.PlatformDirsABC.ensure_exists>`.\n\n    \"\"\"\n\n    @property\n    def user_data_dir(self) -> str:\n        \"\"\"\n        :return: data directory tied to the user, e.g.\n         ``%USERPROFILE%\\\\AppData\\\\Local\\\\$appauthor\\\\$appname`` (not roaming) or\n         ``%USERPROFILE%\\\\AppData\\\\Roaming\\\\$appauthor\\\\$appname`` (roaming)\n        \"\"\"\n        const = \"CSIDL_APPDATA\" if self.roaming else \"CSIDL_LOCAL_APPDATA\"\n        path = os.path.normpath(get_win_folder(const))\n        return self._append_parts(path)\n\n    def _append_parts(self, path: str, *, opinion_value: str | None = None) -> str:\n        params = []\n        if self.appname:\n            if self.appauthor is not False:\n                author = self.appauthor or self.appname\n                params.append(author)\n            params.append(self.appname)\n            if opinion_value is not None and self.opinion:\n                params.append(opinion_value)\n            if self.version:\n                params.append(self.version)\n        path = os.path.join(path, *params)  # noqa: PTH118\n        self._optionally_create_directory(path)\n        return path\n\n    @property\n    def site_data_dir(self) -> str:\n        \"\"\":return: data directory shared by users, e.g. ``C:\\\\ProgramData\\\\$appauthor\\\\$appname``\"\"\"\n        path = os.path.normpath(get_win_folder(\"CSIDL_COMMON_APPDATA\"))\n        return self._append_parts(path)\n\n    @property\n    def user_config_dir(self) -> str:\n        \"\"\":return: config directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def site_config_dir(self) -> str:\n        \"\"\":return: config directory shared by the users, same as `site_data_dir`\"\"\"\n        return self.site_data_dir\n\n    @property\n    def user_cache_dir(self) -> str:\n        \"\"\"\n        :return: cache directory tied to the user (if opinionated with ``Cache`` folder within ``$appname``) e.g.\n         ``%USERPROFILE%\\\\AppData\\\\Local\\\\$appauthor\\\\$appname\\\\Cache\\\\$version``\n        \"\"\"\n        path = os.path.normpath(get_win_folder(\"CSIDL_LOCAL_APPDATA\"))\n        return self._append_parts(path, opinion_value=\"Cache\")\n\n    @property\n    def site_cache_dir(self) -> str:\n        \"\"\":return: cache directory shared by users, e.g. ``C:\\\\ProgramData\\\\$appauthor\\\\$appname\\\\Cache\\\\$version``\"\"\"\n        path = os.path.normpath(get_win_folder(\"CSIDL_COMMON_APPDATA\"))\n        return self._append_parts(path, opinion_value=\"Cache\")\n\n    @property\n    def user_state_dir(self) -> str:\n        \"\"\":return: state directory tied to the user, same as `user_data_dir`\"\"\"\n        return self.user_data_dir\n\n    @property\n    def user_log_dir(self) -> str:\n        \"\"\":return: log directory tied to the user, same as `user_data_dir` if not opinionated else ``Logs`` in it\"\"\"\n        path = self.user_data_dir\n        if self.opinion:\n            path = os.path.join(path, \"Logs\")  # noqa: PTH118\n            self._optionally_create_directory(path)\n        return path\n\n    @property\n    def user_documents_dir(self) -> str:\n        \"\"\":return: documents directory tied to the user e.g. ``%USERPROFILE%\\\\Documents``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_PERSONAL\"))\n\n    @property\n    def user_downloads_dir(self) -> str:\n        \"\"\":return: downloads directory tied to the user e.g. ``%USERPROFILE%\\\\Downloads``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_DOWNLOADS\"))\n\n    @property\n    def user_pictures_dir(self) -> str:\n        \"\"\":return: pictures directory tied to the user e.g. ``%USERPROFILE%\\\\Pictures``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_MYPICTURES\"))\n\n    @property\n    def user_videos_dir(self) -> str:\n        \"\"\":return: videos directory tied to the user e.g. ``%USERPROFILE%\\\\Videos``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_MYVIDEO\"))\n\n    @property\n    def user_music_dir(self) -> str:\n        \"\"\":return: music directory tied to the user e.g. ``%USERPROFILE%\\\\Music``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_MYMUSIC\"))\n\n    @property\n    def user_desktop_dir(self) -> str:\n        \"\"\":return: desktop directory tied to the user, e.g. ``%USERPROFILE%\\\\Desktop``\"\"\"\n        return os.path.normpath(get_win_folder(\"CSIDL_DESKTOPDIRECTORY\"))\n\n    @property\n    def user_runtime_dir(self) -> str:\n        \"\"\"\n        :return: runtime directory tied to the user, e.g.\n         ``%USERPROFILE%\\\\AppData\\\\Local\\\\Temp\\\\$appauthor\\\\$appname``\n        \"\"\"\n        path = os.path.normpath(os.path.join(get_win_folder(\"CSIDL_LOCAL_APPDATA\"), \"Temp\"))  # noqa: PTH118\n        return self._append_parts(path)\n\n    @property\n    def site_runtime_dir(self) -> str:\n        \"\"\":return: runtime directory shared by users, same as `user_runtime_dir`\"\"\"\n        return self.user_runtime_dir\n\n\ndef get_win_folder_from_env_vars(csidl_name: str) -> str:\n    \"\"\"Get folder from environment variables.\"\"\"\n    result = get_win_folder_if_csidl_name_not_env_var(csidl_name)\n    if result is not None:\n        return result\n\n    env_var_name = {\n        \"CSIDL_APPDATA\": \"APPDATA\",\n        \"CSIDL_COMMON_APPDATA\": \"ALLUSERSPROFILE\",\n        \"CSIDL_LOCAL_APPDATA\": \"LOCALAPPDATA\",\n    }.get(csidl_name)\n    if env_var_name is None:\n        msg = f\"Unknown CSIDL name: {csidl_name}\"\n        raise ValueError(msg)\n    result = os.environ.get(env_var_name)\n    if result is None:\n        msg = f\"Unset environment variable: {env_var_name}\"\n        raise ValueError(msg)\n    return result\n\n\ndef get_win_folder_if_csidl_name_not_env_var(csidl_name: str) -> str | None:\n    \"\"\"Get a folder for a CSIDL name that does not exist as an environment variable.\"\"\"\n    if csidl_name == \"CSIDL_PERSONAL\":\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Documents\")  # noqa: PTH118\n\n    if csidl_name == \"CSIDL_DOWNLOADS\":\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Downloads\")  # noqa: PTH118\n\n    if csidl_name == \"CSIDL_MYPICTURES\":\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Pictures\")  # noqa: PTH118\n\n    if csidl_name == \"CSIDL_MYVIDEO\":\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Videos\")  # noqa: PTH118\n\n    if csidl_name == \"CSIDL_MYMUSIC\":\n        return os.path.join(os.path.normpath(os.environ[\"USERPROFILE\"]), \"Music\")  # noqa: PTH118\n    return None\n\n\ndef get_win_folder_from_registry(csidl_name: str) -> str:\n    \"\"\"\n    Get folder from the registry.\n\n    This is a fallback technique at best. I'm not sure if using the registry for these guarantees us the correct answer\n    for all CSIDL_* names.\n\n    \"\"\"\n    shell_folder_name = {\n        \"CSIDL_APPDATA\": \"AppData\",\n        \"CSIDL_COMMON_APPDATA\": \"Common AppData\",\n        \"CSIDL_LOCAL_APPDATA\": \"Local AppData\",\n        \"CSIDL_PERSONAL\": \"Personal\",\n        \"CSIDL_DOWNLOADS\": \"{374DE290-123F-4565-9164-39C4925E467B}\",\n        \"CSIDL_MYPICTURES\": \"My Pictures\",\n        \"CSIDL_MYVIDEO\": \"My Video\",\n        \"CSIDL_MYMUSIC\": \"My Music\",\n    }.get(csidl_name)\n    if shell_folder_name is None:\n        msg = f\"Unknown CSIDL name: {csidl_name}\"\n        raise ValueError(msg)\n    if sys.platform != \"win32\":  # only needed for mypy type checker to know that this code runs only on Windows\n        raise NotImplementedError\n    import winreg  # noqa: PLC0415\n\n    key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r\"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\")\n    directory, _ = winreg.QueryValueEx(key, shell_folder_name)\n    return str(directory)\n\n\ndef get_win_folder_via_ctypes(csidl_name: str) -> str:\n    \"\"\"Get folder with ctypes.\"\"\"\n    # There is no 'CSIDL_DOWNLOADS'.\n    # Use 'CSIDL_PROFILE' (40) and append the default folder 'Downloads' instead.\n    # https://learn.microsoft.com/en-us/windows/win32/shell/knownfolderid\n\n    import ctypes  # noqa: PLC0415\n\n    csidl_const = {\n        \"CSIDL_APPDATA\": 26,\n        \"CSIDL_COMMON_APPDATA\": 35,\n        \"CSIDL_LOCAL_APPDATA\": 28,\n        \"CSIDL_PERSONAL\": 5,\n        \"CSIDL_MYPICTURES\": 39,\n        \"CSIDL_MYVIDEO\": 14,\n        \"CSIDL_MYMUSIC\": 13,\n        \"CSIDL_DOWNLOADS\": 40,\n        \"CSIDL_DESKTOPDIRECTORY\": 16,\n    }.get(csidl_name)\n    if csidl_const is None:\n        msg = f\"Unknown CSIDL name: {csidl_name}\"\n        raise ValueError(msg)\n\n    buf = ctypes.create_unicode_buffer(1024)\n    windll = getattr(ctypes, \"windll\")  # noqa: B009 # using getattr to avoid false positive with mypy type checker\n    windll.shell32.SHGetFolderPathW(None, csidl_const, None, 0, buf)\n\n    # Downgrade to short path name if it has high-bit chars.\n    if any(ord(c) > 255 for c in buf):  # noqa: PLR2004\n        buf2 = ctypes.create_unicode_buffer(1024)\n        if windll.kernel32.GetShortPathNameW(buf.value, buf2, 1024):\n            buf = buf2\n\n    if csidl_name == \"CSIDL_DOWNLOADS\":\n        return os.path.join(buf.value, \"Downloads\")  # noqa: PTH118\n\n    return buf.value\n\n\ndef _pick_get_win_folder() -> Callable[[str], str]:\n    try:\n        import ctypes  # noqa: PLC0415\n    except ImportError:\n        pass\n    else:\n        if hasattr(ctypes, \"windll\"):\n            return get_win_folder_via_ctypes\n    try:\n        import winreg  # noqa: PLC0415, F401\n    except ImportError:\n        return get_win_folder_from_env_vars\n    else:\n        return get_win_folder_from_registry\n\n\nget_win_folder = lru_cache(maxsize=None)(_pick_get_win_folder())\n\n__all__ = [\n    \"Windows\",\n]\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/tomli/__init__.py","size":396,"sha1":"74c49fb12ed49ef70739f0f9ababcd0cd7346fb9","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# SPDX-License-Identifier: MIT\n# SPDX-FileCopyrightText: 2021 Taneli Hukkinen\n# Licensed to PSF under a Contributor Agreement.\n\n__all__ = (\"loads\", \"load\", \"TOMLDecodeError\")\n__version__ = \"2.0.1\"  # DO NOT EDIT THIS LINE MANUALLY. LET bump2version UTILITY DO IT\n\nfrom ._parser import TOMLDecodeError, load, loads\n\n# Pretend this exception was created here.\nTOMLDecodeError.__module__ = __name__\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/tomli/_parser.py","size":22633,"sha1":"c21682d8065b4c6319654107c4d1691000551a96","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# SPDX-License-Identifier: MIT\n# SPDX-FileCopyrightText: 2021 Taneli Hukkinen\n# Licensed to PSF under a Contributor Agreement.\n\nfrom __future__ import annotations\n\nfrom collections.abc import Iterable\nimport string\nfrom types import MappingProxyType\nfrom typing import Any, BinaryIO, NamedTuple\n\nfrom ._re import (\n    RE_DATETIME,\n    RE_LOCALTIME,\n    RE_NUMBER,\n    match_to_datetime,\n    match_to_localtime,\n    match_to_number,\n)\nfrom ._types import Key, ParseFloat, Pos\n\nASCII_CTRL = frozenset(chr(i) for i in range(32)) | frozenset(chr(127))\n\n# Neither of these sets include quotation mark or backslash. They are\n# currently handled as separate cases in the parser functions.\nILLEGAL_BASIC_STR_CHARS = ASCII_CTRL - frozenset(\"\\t\")\nILLEGAL_MULTILINE_BASIC_STR_CHARS = ASCII_CTRL - frozenset(\"\\t\\n\")\n\nILLEGAL_LITERAL_STR_CHARS = ILLEGAL_BASIC_STR_CHARS\nILLEGAL_MULTILINE_LITERAL_STR_CHARS = ILLEGAL_MULTILINE_BASIC_STR_CHARS\n\nILLEGAL_COMMENT_CHARS = ILLEGAL_BASIC_STR_CHARS\n\nTOML_WS = frozenset(\" \\t\")\nTOML_WS_AND_NEWLINE = TOML_WS | frozenset(\"\\n\")\nBARE_KEY_CHARS = frozenset(string.ascii_letters + string.digits + \"-_\")\nKEY_INITIAL_CHARS = BARE_KEY_CHARS | frozenset(\"\\\"'\")\nHEXDIGIT_CHARS = frozenset(string.hexdigits)\n\nBASIC_STR_ESCAPE_REPLACEMENTS = MappingProxyType(\n    {\n        \"\\\\b\": \"\\u0008\",  # backspace\n        \"\\\\t\": \"\\u0009\",  # tab\n        \"\\\\n\": \"\\u000A\",  # linefeed\n        \"\\\\f\": \"\\u000C\",  # form feed\n        \"\\\\r\": \"\\u000D\",  # carriage return\n        '\\\\\"': \"\\u0022\",  # quote\n        \"\\\\\\\\\": \"\\u005C\",  # backslash\n    }\n)\n\n\nclass TOMLDecodeError(ValueError):\n    \"\"\"An error raised if a document is not valid TOML.\"\"\"\n\n\ndef load(__fp: BinaryIO, *, parse_float: ParseFloat = float) -> dict[str, Any]:\n    \"\"\"Parse TOML from a binary file object.\"\"\"\n    b = __fp.read()\n    try:\n        s = b.decode()\n    except AttributeError:\n        raise TypeError(\n            \"File must be opened in binary mode, e.g. use `open('foo.toml', 'rb')`\"\n        ) from None\n    return loads(s, parse_float=parse_float)\n\n\ndef loads(__s: str, *, parse_float: ParseFloat = float) -> dict[str, Any]:  # noqa: C901\n    \"\"\"Parse TOML from a string.\"\"\"\n\n    # The spec allows converting \"\\r\\n\" to \"\\n\", even in string\n    # literals. Let's do so to simplify parsing.\n    src = __s.replace(\"\\r\\n\", \"\\n\")\n    pos = 0\n    out = Output(NestedDict(), Flags())\n    header: Key = ()\n    parse_float = make_safe_parse_float(parse_float)\n\n    # Parse one statement at a time\n    # (typically means one line in TOML source)\n    while True:\n        # 1. Skip line leading whitespace\n        pos = skip_chars(src, pos, TOML_WS)\n\n        # 2. Parse rules. Expect one of the following:\n        #    - end of file\n        #    - end of line\n        #    - comment\n        #    - key/value pair\n        #    - append dict to list (and move to its namespace)\n        #    - create dict (and move to its namespace)\n        # Skip trailing whitespace when applicable.\n        try:\n            char = src[pos]\n        except IndexError:\n            break\n        if char == \"\\n\":\n            pos += 1\n            continue\n        if char in KEY_INITIAL_CHARS:\n            pos = key_value_rule(src, pos, out, header, parse_float)\n            pos = skip_chars(src, pos, TOML_WS)\n        elif char == \"[\":\n            try:\n                second_char: str | None = src[pos + 1]\n            except IndexError:\n                second_char = None\n            out.flags.finalize_pending()\n            if second_char == \"[\":\n                pos, header = create_list_rule(src, pos, out)\n            else:\n                pos, header = create_dict_rule(src, pos, out)\n            pos = skip_chars(src, pos, TOML_WS)\n        elif char != \"#\":\n            raise suffixed_err(src, pos, \"Invalid statement\")\n\n        # 3. Skip comment\n        pos = skip_comment(src, pos)\n\n        # 4. Expect end of line or end of file\n        try:\n            char = src[pos]\n        except IndexError:\n            break\n        if char != \"\\n\":\n            raise suffixed_err(\n                src, pos, \"Expected newline or end of document after a statement\"\n            )\n        pos += 1\n\n    return out.data.dict\n\n\nclass Flags:\n    \"\"\"Flags that map to parsed keys/namespaces.\"\"\"\n\n    # Marks an immutable namespace (inline array or inline table).\n    FROZEN = 0\n    # Marks a nest that has been explicitly created and can no longer\n    # be opened using the \"[table]\" syntax.\n    EXPLICIT_NEST = 1\n\n    def __init__(self) -> None:\n        self._flags: dict[str, dict] = {}\n        self._pending_flags: set[tuple[Key, int]] = set()\n\n    def add_pending(self, key: Key, flag: int) -> None:\n        self._pending_flags.add((key, flag))\n\n    def finalize_pending(self) -> None:\n        for key, flag in self._pending_flags:\n            self.set(key, flag, recursive=False)\n        self._pending_flags.clear()\n\n    def unset_all(self, key: Key) -> None:\n        cont = self._flags\n        for k in key[:-1]:\n            if k not in cont:\n                return\n            cont = cont[k][\"nested\"]\n        cont.pop(key[-1], None)\n\n    def set(self, key: Key, flag: int, *, recursive: bool) -> None:  # noqa: A003\n        cont = self._flags\n        key_parent, key_stem = key[:-1], key[-1]\n        for k in key_parent:\n            if k not in cont:\n                cont[k] = {\"flags\": set(), \"recursive_flags\": set(), \"nested\": {}}\n            cont = cont[k][\"nested\"]\n        if key_stem not in cont:\n            cont[key_stem] = {\"flags\": set(), \"recursive_flags\": set(), \"nested\": {}}\n        cont[key_stem][\"recursive_flags\" if recursive else \"flags\"].add(flag)\n\n    def is_(self, key: Key, flag: int) -> bool:\n        if not key:\n            return False  # document root has no flags\n        cont = self._flags\n        for k in key[:-1]:\n            if k not in cont:\n                return False\n            inner_cont = cont[k]\n            if flag in inner_cont[\"recursive_flags\"]:\n                return True\n            cont = inner_cont[\"nested\"]\n        key_stem = key[-1]\n        if key_stem in cont:\n            cont = cont[key_stem]\n            return flag in cont[\"flags\"] or flag in cont[\"recursive_flags\"]\n        return False\n\n\nclass NestedDict:\n    def __init__(self) -> None:\n        # The parsed content of the TOML document\n        self.dict: dict[str, Any] = {}\n\n    def get_or_create_nest(\n        self,\n        key: Key,\n        *,\n        access_lists: bool = True,\n    ) -> dict:\n        cont: Any = self.dict\n        for k in key:\n            if k not in cont:\n                cont[k] = {}\n            cont = cont[k]\n            if access_lists and isinstance(cont, list):\n                cont = cont[-1]\n            if not isinstance(cont, dict):\n                raise KeyError(\"There is no nest behind this key\")\n        return cont\n\n    def append_nest_to_list(self, key: Key) -> None:\n        cont = self.get_or_create_nest(key[:-1])\n        last_key = key[-1]\n        if last_key in cont:\n            list_ = cont[last_key]\n            if not isinstance(list_, list):\n                raise KeyError(\"An object other than list found behind this key\")\n            list_.append({})\n        else:\n            cont[last_key] = [{}]\n\n\nclass Output(NamedTuple):\n    data: NestedDict\n    flags: Flags\n\n\ndef skip_chars(src: str, pos: Pos, chars: Iterable[str]) -> Pos:\n    try:\n        while src[pos] in chars:\n            pos += 1\n    except IndexError:\n        pass\n    return pos\n\n\ndef skip_until(\n    src: str,\n    pos: Pos,\n    expect: str,\n    *,\n    error_on: frozenset[str],\n    error_on_eof: bool,\n) -> Pos:\n    try:\n        new_pos = src.index(expect, pos)\n    except ValueError:\n        new_pos = len(src)\n        if error_on_eof:\n            raise suffixed_err(src, new_pos, f\"Expected {expect!r}\") from None\n\n    if not error_on.isdisjoint(src[pos:new_pos]):\n        while src[pos] not in error_on:\n            pos += 1\n        raise suffixed_err(src, pos, f\"Found invalid character {src[pos]!r}\")\n    return new_pos\n\n\ndef skip_comment(src: str, pos: Pos) -> Pos:\n    try:\n        char: str | None = src[pos]\n    except IndexError:\n        char = None\n    if char == \"#\":\n        return skip_until(\n            src, pos + 1, \"\\n\", error_on=ILLEGAL_COMMENT_CHARS, error_on_eof=False\n        )\n    return pos\n\n\ndef skip_comments_and_array_ws(src: str, pos: Pos) -> Pos:\n    while True:\n        pos_before_skip = pos\n        pos = skip_chars(src, pos, TOML_WS_AND_NEWLINE)\n        pos = skip_comment(src, pos)\n        if pos == pos_before_skip:\n            return pos\n\n\ndef create_dict_rule(src: str, pos: Pos, out: Output) -> tuple[Pos, Key]:\n    pos += 1  # Skip \"[\"\n    pos = skip_chars(src, pos, TOML_WS)\n    pos, key = parse_key(src, pos)\n\n    if out.flags.is_(key, Flags.EXPLICIT_NEST) or out.flags.is_(key, Flags.FROZEN):\n        raise suffixed_err(src, pos, f\"Cannot declare {key} twice\")\n    out.flags.set(key, Flags.EXPLICIT_NEST, recursive=False)\n    try:\n        out.data.get_or_create_nest(key)\n    except KeyError:\n        raise suffixed_err(src, pos, \"Cannot overwrite a value\") from None\n\n    if not src.startswith(\"]\", pos):\n        raise suffixed_err(src, pos, \"Expected ']' at the end of a table declaration\")\n    return pos + 1, key\n\n\ndef create_list_rule(src: str, pos: Pos, out: Output) -> tuple[Pos, Key]:\n    pos += 2  # Skip \"[[\"\n    pos = skip_chars(src, pos, TOML_WS)\n    pos, key = parse_key(src, pos)\n\n    if out.flags.is_(key, Flags.FROZEN):\n        raise suffixed_err(src, pos, f\"Cannot mutate immutable namespace {key}\")\n    # Free the namespace now that it points to another empty list item...\n    out.flags.unset_all(key)\n    # ...but this key precisely is still prohibited from table declaration\n    out.flags.set(key, Flags.EXPLICIT_NEST, recursive=False)\n    try:\n        out.data.append_nest_to_list(key)\n    except KeyError:\n        raise suffixed_err(src, pos, \"Cannot overwrite a value\") from None\n\n    if not src.startswith(\"]]\", pos):\n        raise suffixed_err(src, pos, \"Expected ']]' at the end of an array declaration\")\n    return pos + 2, key\n\n\ndef key_value_rule(\n    src: str, pos: Pos, out: Output, header: Key, parse_float: ParseFloat\n) -> Pos:\n    pos, key, value = parse_key_value_pair(src, pos, parse_float)\n    key_parent, key_stem = key[:-1], key[-1]\n    abs_key_parent = header + key_parent\n\n    relative_path_cont_keys = (header + key[:i] for i in range(1, len(key)))\n    for cont_key in relative_path_cont_keys:\n        # Check that dotted key syntax does not redefine an existing table\n        if out.flags.is_(cont_key, Flags.EXPLICIT_NEST):\n            raise suffixed_err(src, pos, f\"Cannot redefine namespace {cont_key}\")\n        # Containers in the relative path can't be opened with the table syntax or\n        # dotted key/value syntax in following table sections.\n        out.flags.add_pending(cont_key, Flags.EXPLICIT_NEST)\n\n    if out.flags.is_(abs_key_parent, Flags.FROZEN):\n        raise suffixed_err(\n            src, pos, f\"Cannot mutate immutable namespace {abs_key_parent}\"\n        )\n\n    try:\n        nest = out.data.get_or_create_nest(abs_key_parent)\n    except KeyError:\n        raise suffixed_err(src, pos, \"Cannot overwrite a value\") from None\n    if key_stem in nest:\n        raise suffixed_err(src, pos, \"Cannot overwrite a value\")\n    # Mark inline table and array namespaces recursively immutable\n    if isinstance(value, (dict, list)):\n        out.flags.set(header + key, Flags.FROZEN, recursive=True)\n    nest[key_stem] = value\n    return pos\n\n\ndef parse_key_value_pair(\n    src: str, pos: Pos, parse_float: ParseFloat\n) -> tuple[Pos, Key, Any]:\n    pos, key = parse_key(src, pos)\n    try:\n        char: str | None = src[pos]\n    except IndexError:\n        char = None\n    if char != \"=\":\n        raise suffixed_err(src, pos, \"Expected '=' after a key in a key/value pair\")\n    pos += 1\n    pos = skip_chars(src, pos, TOML_WS)\n    pos, value = parse_value(src, pos, parse_float)\n    return pos, key, value\n\n\ndef parse_key(src: str, pos: Pos) -> tuple[Pos, Key]:\n    pos, key_part = parse_key_part(src, pos)\n    key: Key = (key_part,)\n    pos = skip_chars(src, pos, TOML_WS)\n    while True:\n        try:\n            char: str | None = src[pos]\n        except IndexError:\n            char = None\n        if char != \".\":\n            return pos, key\n        pos += 1\n        pos = skip_chars(src, pos, TOML_WS)\n        pos, key_part = parse_key_part(src, pos)\n        key += (key_part,)\n        pos = skip_chars(src, pos, TOML_WS)\n\n\ndef parse_key_part(src: str, pos: Pos) -> tuple[Pos, str]:\n    try:\n        char: str | None = src[pos]\n    except IndexError:\n        char = None\n    if char in BARE_KEY_CHARS:\n        start_pos = pos\n        pos = skip_chars(src, pos, BARE_KEY_CHARS)\n        return pos, src[start_pos:pos]\n    if char == \"'\":\n        return parse_literal_str(src, pos)\n    if char == '\"':\n        return parse_one_line_basic_str(src, pos)\n    raise suffixed_err(src, pos, \"Invalid initial character for a key part\")\n\n\ndef parse_one_line_basic_str(src: str, pos: Pos) -> tuple[Pos, str]:\n    pos += 1\n    return parse_basic_str(src, pos, multiline=False)\n\n\ndef parse_array(src: str, pos: Pos, parse_float: ParseFloat) -> tuple[Pos, list]:\n    pos += 1\n    array: list = []\n\n    pos = skip_comments_and_array_ws(src, pos)\n    if src.startswith(\"]\", pos):\n        return pos + 1, array\n    while True:\n        pos, val = parse_value(src, pos, parse_float)\n        array.append(val)\n        pos = skip_comments_and_array_ws(src, pos)\n\n        c = src[pos : pos + 1]\n        if c == \"]\":\n            return pos + 1, array\n        if c != \",\":\n            raise suffixed_err(src, pos, \"Unclosed array\")\n        pos += 1\n\n        pos = skip_comments_and_array_ws(src, pos)\n        if src.startswith(\"]\", pos):\n            return pos + 1, array\n\n\ndef parse_inline_table(src: str, pos: Pos, parse_float: ParseFloat) -> tuple[Pos, dict]:\n    pos += 1\n    nested_dict = NestedDict()\n    flags = Flags()\n\n    pos = skip_chars(src, pos, TOML_WS)\n    if src.startswith(\"}\", pos):\n        return pos + 1, nested_dict.dict\n    while True:\n        pos, key, value = parse_key_value_pair(src, pos, parse_float)\n        key_parent, key_stem = key[:-1], key[-1]\n        if flags.is_(key, Flags.FROZEN):\n            raise suffixed_err(src, pos, f\"Cannot mutate immutable namespace {key}\")\n        try:\n            nest = nested_dict.get_or_create_nest(key_parent, access_lists=False)\n        except KeyError:\n            raise suffixed_err(src, pos, \"Cannot overwrite a value\") from None\n        if key_stem in nest:\n            raise suffixed_err(src, pos, f\"Duplicate inline table key {key_stem!r}\")\n        nest[key_stem] = value\n        pos = skip_chars(src, pos, TOML_WS)\n        c = src[pos : pos + 1]\n        if c == \"}\":\n            return pos + 1, nested_dict.dict\n        if c != \",\":\n            raise suffixed_err(src, pos, \"Unclosed inline table\")\n        if isinstance(value, (dict, list)):\n            flags.set(key, Flags.FROZEN, recursive=True)\n        pos += 1\n        pos = skip_chars(src, pos, TOML_WS)\n\n\ndef parse_basic_str_escape(\n    src: str, pos: Pos, *, multiline: bool = False\n) -> tuple[Pos, str]:\n    escape_id = src[pos : pos + 2]\n    pos += 2\n    if multiline and escape_id in {\"\\\\ \", \"\\\\\\t\", \"\\\\\\n\"}:\n        # Skip whitespace until next non-whitespace character or end of\n        # the doc. Error if non-whitespace is found before newline.\n        if escape_id != \"\\\\\\n\":\n            pos = skip_chars(src, pos, TOML_WS)\n            try:\n                char = src[pos]\n            except IndexError:\n                return pos, \"\"\n            if char != \"\\n\":\n                raise suffixed_err(src, pos, \"Unescaped '\\\\' in a string\")\n            pos += 1\n        pos = skip_chars(src, pos, TOML_WS_AND_NEWLINE)\n        return pos, \"\"\n    if escape_id == \"\\\\u\":\n        return parse_hex_char(src, pos, 4)\n    if escape_id == \"\\\\U\":\n        return parse_hex_char(src, pos, 8)\n    try:\n        return pos, BASIC_STR_ESCAPE_REPLACEMENTS[escape_id]\n    except KeyError:\n        raise suffixed_err(src, pos, \"Unescaped '\\\\' in a string\") from None\n\n\ndef parse_basic_str_escape_multiline(src: str, pos: Pos) -> tuple[Pos, str]:\n    return parse_basic_str_escape(src, pos, multiline=True)\n\n\ndef parse_hex_char(src: str, pos: Pos, hex_len: int) -> tuple[Pos, str]:\n    hex_str = src[pos : pos + hex_len]\n    if len(hex_str) != hex_len or not HEXDIGIT_CHARS.issuperset(hex_str):\n        raise suffixed_err(src, pos, \"Invalid hex value\")\n    pos += hex_len\n    hex_int = int(hex_str, 16)\n    if not is_unicode_scalar_value(hex_int):\n        raise suffixed_err(src, pos, \"Escaped character is not a Unicode scalar value\")\n    return pos, chr(hex_int)\n\n\ndef parse_literal_str(src: str, pos: Pos) -> tuple[Pos, str]:\n    pos += 1  # Skip starting apostrophe\n    start_pos = pos\n    pos = skip_until(\n        src, pos, \"'\", error_on=ILLEGAL_LITERAL_STR_CHARS, error_on_eof=True\n    )\n    return pos + 1, src[start_pos:pos]  # Skip ending apostrophe\n\n\ndef parse_multiline_str(src: str, pos: Pos, *, literal: bool) -> tuple[Pos, str]:\n    pos += 3\n    if src.startswith(\"\\n\", pos):\n        pos += 1\n\n    if literal:\n        delim = \"'\"\n        end_pos = skip_until(\n            src,\n            pos,\n            \"'''\",\n            error_on=ILLEGAL_MULTILINE_LITERAL_STR_CHARS,\n            error_on_eof=True,\n        )\n        result = src[pos:end_pos]\n        pos = end_pos + 3\n    else:\n        delim = '\"'\n        pos, result = parse_basic_str(src, pos, multiline=True)\n\n    # Add at maximum two extra apostrophes/quotes if the end sequence\n    # is 4 or 5 chars long instead of just 3.\n    if not src.startswith(delim, pos):\n        return pos, result\n    pos += 1\n    if not src.startswith(delim, pos):\n        return pos, result + delim\n    pos += 1\n    return pos, result + (delim * 2)\n\n\ndef parse_basic_str(src: str, pos: Pos, *, multiline: bool) -> tuple[Pos, str]:\n    if multiline:\n        error_on = ILLEGAL_MULTILINE_BASIC_STR_CHARS\n        parse_escapes = parse_basic_str_escape_multiline\n    else:\n        error_on = ILLEGAL_BASIC_STR_CHARS\n        parse_escapes = parse_basic_str_escape\n    result = \"\"\n    start_pos = pos\n    while True:\n        try:\n            char = src[pos]\n        except IndexError:\n            raise suffixed_err(src, pos, \"Unterminated string\") from None\n        if char == '\"':\n            if not multiline:\n                return pos + 1, result + src[start_pos:pos]\n            if src.startswith('\"\"\"', pos):\n                return pos + 3, result + src[start_pos:pos]\n            pos += 1\n            continue\n        if char == \"\\\\\":\n            result += src[start_pos:pos]\n            pos, parsed_escape = parse_escapes(src, pos)\n            result += parsed_escape\n            start_pos = pos\n            continue\n        if char in error_on:\n            raise suffixed_err(src, pos, f\"Illegal character {char!r}\")\n        pos += 1\n\n\ndef parse_value(  # noqa: C901\n    src: str, pos: Pos, parse_float: ParseFloat\n) -> tuple[Pos, Any]:\n    try:\n        char: str | None = src[pos]\n    except IndexError:\n        char = None\n\n    # IMPORTANT: order conditions based on speed of checking and likelihood\n\n    # Basic strings\n    if char == '\"':\n        if src.startswith('\"\"\"', pos):\n            return parse_multiline_str(src, pos, literal=False)\n        return parse_one_line_basic_str(src, pos)\n\n    # Literal strings\n    if char == \"'\":\n        if src.startswith(\"'''\", pos):\n            return parse_multiline_str(src, pos, literal=True)\n        return parse_literal_str(src, pos)\n\n    # Booleans\n    if char == \"t\":\n        if src.startswith(\"true\", pos):\n            return pos + 4, True\n    if char == \"f\":\n        if src.startswith(\"false\", pos):\n            return pos + 5, False\n\n    # Arrays\n    if char == \"[\":\n        return parse_array(src, pos, parse_float)\n\n    # Inline tables\n    if char == \"{\":\n        return parse_inline_table(src, pos, parse_float)\n\n    # Dates and times\n    datetime_match = RE_DATETIME.match(src, pos)\n    if datetime_match:\n        try:\n            datetime_obj = match_to_datetime(datetime_match)\n        except ValueError as e:\n            raise suffixed_err(src, pos, \"Invalid date or datetime\") from e\n        return datetime_match.end(), datetime_obj\n    localtime_match = RE_LOCALTIME.match(src, pos)\n    if localtime_match:\n        return localtime_match.end(), match_to_localtime(localtime_match)\n\n    # Integers and \"normal\" floats.\n    # The regex will greedily match any type starting with a decimal\n    # char, so needs to be located after handling of dates and times.\n    number_match = RE_NUMBER.match(src, pos)\n    if number_match:\n        return number_match.end(), match_to_number(number_match, parse_float)\n\n    # Special floats\n    first_three = src[pos : pos + 3]\n    if first_three in {\"inf\", \"nan\"}:\n        return pos + 3, parse_float(first_three)\n    first_four = src[pos : pos + 4]\n    if first_four in {\"-inf\", \"+inf\", \"-nan\", \"+nan\"}:\n        return pos + 4, parse_float(first_four)\n\n    raise suffixed_err(src, pos, \"Invalid value\")\n\n\ndef suffixed_err(src: str, pos: Pos, msg: str) -> TOMLDecodeError:\n    \"\"\"Return a `TOMLDecodeError` where error message is suffixed with\n    coordinates in source.\"\"\"\n\n    def coord_repr(src: str, pos: Pos) -> str:\n        if pos >= len(src):\n            return \"end of document\"\n        line = src.count(\"\\n\", 0, pos) + 1\n        if line == 1:\n            column = pos + 1\n        else:\n            column = pos - src.rindex(\"\\n\", 0, pos)\n        return f\"line {line}, column {column}\"\n\n    return TOMLDecodeError(f\"{msg} (at {coord_repr(src, pos)})\")\n\n\ndef is_unicode_scalar_value(codepoint: int) -> bool:\n    return (0 <= codepoint <= 55295) or (57344 <= codepoint <= 1114111)\n\n\ndef make_safe_parse_float(parse_float: ParseFloat) -> ParseFloat:\n    \"\"\"A decorator to make `parse_float` safe.\n\n    `parse_float` must not return dicts or lists, because these types\n    would be mixed with parsed TOML tables and arrays, thus confusing\n    the parser. The returned decorated callable raises `ValueError`\n    instead of returning illegal types.\n    \"\"\"\n    # The default `float` callable never returns illegal types. Optimize it.\n    if parse_float is float:  # type: ignore[comparison-overlap]\n        return float\n\n    def safe_parse_float(float_str: str) -> Any:\n        float_value = parse_float(float_str)\n        if isinstance(float_value, (dict, list)):\n            raise ValueError(\"parse_float must not return dicts or lists\")\n        return float_value\n\n    return safe_parse_float\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/tomli/_re.py","size":2943,"sha1":"41d8d0205ae11da5308581e62df6da123be415ed","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# SPDX-License-Identifier: MIT\n# SPDX-FileCopyrightText: 2021 Taneli Hukkinen\n# Licensed to PSF under a Contributor Agreement.\n\nfrom __future__ import annotations\n\nfrom datetime import date, datetime, time, timedelta, timezone, tzinfo\nfrom functools import lru_cache\nimport re\nfrom typing import Any\n\nfrom ._types import ParseFloat\n\n# E.g.\n# - 00:32:00.999999\n# - 00:32:00\n_TIME_RE_STR = r\"([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])(?:\\.([0-9]{1,6})[0-9]*)?\"\n\nRE_NUMBER = re.compile(\n    r\"\"\"\n0\n(?:\n    x[0-9A-Fa-f](?:_?[0-9A-Fa-f])*   # hex\n    |\n    b[01](?:_?[01])*                 # bin\n    |\n    o[0-7](?:_?[0-7])*               # oct\n)\n|\n[+-]?(?:0|[1-9](?:_?[0-9])*)         # dec, integer part\n(?P<floatpart>\n    (?:\\.[0-9](?:_?[0-9])*)?         # optional fractional part\n    (?:[eE][+-]?[0-9](?:_?[0-9])*)?  # optional exponent part\n)\n\"\"\",\n    flags=re.VERBOSE,\n)\nRE_LOCALTIME = re.compile(_TIME_RE_STR)\nRE_DATETIME = re.compile(\n    rf\"\"\"\n([0-9]{{4}})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])  # date, e.g. 1988-10-27\n(?:\n    [Tt ]\n    {_TIME_RE_STR}\n    (?:([Zz])|([+-])([01][0-9]|2[0-3]):([0-5][0-9]))?  # optional time offset\n)?\n\"\"\",\n    flags=re.VERBOSE,\n)\n\n\ndef match_to_datetime(match: re.Match) -> datetime | date:\n    \"\"\"Convert a `RE_DATETIME` match to `datetime.datetime` or `datetime.date`.\n\n    Raises ValueError if the match does not correspond to a valid date\n    or datetime.\n    \"\"\"\n    (\n        year_str,\n        month_str,\n        day_str,\n        hour_str,\n        minute_str,\n        sec_str,\n        micros_str,\n        zulu_time,\n        offset_sign_str,\n        offset_hour_str,\n        offset_minute_str,\n    ) = match.groups()\n    year, month, day = int(year_str), int(month_str), int(day_str)\n    if hour_str is None:\n        return date(year, month, day)\n    hour, minute, sec = int(hour_str), int(minute_str), int(sec_str)\n    micros = int(micros_str.ljust(6, \"0\")) if micros_str else 0\n    if offset_sign_str:\n        tz: tzinfo | None = cached_tz(\n            offset_hour_str, offset_minute_str, offset_sign_str\n        )\n    elif zulu_time:\n        tz = timezone.utc\n    else:  # local date-time\n        tz = None\n    return datetime(year, month, day, hour, minute, sec, micros, tzinfo=tz)\n\n\n@lru_cache(maxsize=None)\ndef cached_tz(hour_str: str, minute_str: str, sign_str: str) -> timezone:\n    sign = 1 if sign_str == \"+\" else -1\n    return timezone(\n        timedelta(\n            hours=sign * int(hour_str),\n            minutes=sign * int(minute_str),\n        )\n    )\n\n\ndef match_to_localtime(match: re.Match) -> time:\n    hour_str, minute_str, sec_str, micros_str = match.groups()\n    micros = int(micros_str.ljust(6, \"0\")) if micros_str else 0\n    return time(int(hour_str), int(minute_str), int(sec_str), micros)\n\n\ndef match_to_number(match: re.Match, parse_float: ParseFloat) -> Any:\n    if match.group(\"floatpart\"):\n        return parse_float(match.group())\n    return int(match.group(), 0)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/tomli/_types.py","size":254,"sha1":"6dc6337d888edea5138a094e517be6c0e4bd09f4","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# SPDX-License-Identifier: MIT\n# SPDX-FileCopyrightText: 2021 Taneli Hukkinen\n# Licensed to PSF under a Contributor Agreement.\n\nfrom typing import Any, Callable, Tuple\n\n# Type annotations\nParseFloat = Callable[[str], Any]\nKey = Tuple[str, ...]\nPos = int\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/_vendor/typeguard/__init__.py","size":2071,"sha1":"86d4c0545117072332df0077265ee64768ef449a","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import os\nfrom typing import Any\n\nfrom ._checkers import TypeCheckerCallable as TypeCheckerCallable\nfrom ._checkers import TypeCheckLookupCallback as TypeCheckLookupCallback\nfrom ._checkers import check_type_internal as check_type_internal\nfrom ._checkers import checker_lookup_functions as checker_lookup_functions\nfrom ._checkers import load_plugins as load_plugins\nfrom ._config import CollectionCheckStrategy as CollectionCheckStrategy\nfrom ._config import ForwardRefPolicy as ForwardRefPolicy\nfrom ._config import TypeCheckConfiguration as TypeCheckConfiguration\nfrom ._decorators import typechecked as typechecked\nfrom ._decorators import typeguard_ignore as typeguard_ignore\nfrom ._exceptions import InstrumentationWarning as InstrumentationWarning\nfrom ._exceptions import TypeCheckError as TypeCheckError\nfrom ._exceptions import TypeCheckWarning as TypeCheckWarning\nfrom ._exceptions import TypeHintWarning as TypeHintWarning\nfrom ._functions import TypeCheckFailCallback as TypeCheckFailCallback\nfrom ._functions import check_type as check_type\nfrom ._functions import warn_on_error as warn_on_error\nfrom ._importhook import ImportHookManager as ImportHookManager\nfrom ._importhook import TypeguardFinder as TypeguardFinder\nfrom ._importhook import install_import_hook as install_import_hook\nfrom ._memo import TypeCheckMemo as TypeCheckMemo\nfrom ._suppression import suppress_type_checks as suppress_type_checks\nfrom ._utils import Unset as Unset\n\n# Re-export imports so they look like they live directly in this package\nfor value in list(locals().values()):\n    if getattr(value, \"__module__\", \"\").startswith(f\"{__name__}.\"):\n        value.__module__ = __name__\n\n\nconfig: TypeCheckConfiguration\n\n\ndef __getattr__(name: str) -> Any:\n    if name == \"config\":\n        from ._config import global_config\n\n        return global_config\n\n    raise AttributeError(f\"module {__name__!r} has no attribute {name!r}\")\n\n\n# Automatically load checker lookup functions unless explicitly disabled\nif \"TYPEGUARD_DISABLE_PLUGIN_AUTOLOAD\" not in os.environ:\n    load_plugins()\n"}]}