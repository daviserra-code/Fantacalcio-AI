{"generated_at":"2025-08-17T20:04:18.057896Z","root":"/home/runner/workspace","git":{"head":"7b7135163eb4227ef98e4c2d7b4ab78ea306bd73","branch":"main","status":" M corrections.db\n?? app_changes.json\n?? export_changes.py\n"},"filters":{"git_range":null,"since":null,"include_ext":[".cfg",".css",".env",".htm",".html",".ini",".jinja",".jinja2",".js",".json",".md",".py",".toml",".ts",".yaml",".yml"],"exclude_dirs":[".git",".ipynb_checkpoints",".mypy_cache",".pytest_cache",".pythonlibs",".venv","__pycache__","cache","chroma_db","data/exports","node_modules","venv"],"exclude_globs":["*.bmp","*.db","*.feather","*.gif","*.gz","*.ico","*.jpeg","*.jpg","*.jsonl","*.lock","*.log","*.parquet","*.png","*.sqlite","*.sqlite3","*.tar","*.webp","*.zip"],"max_file_bytes":400000},"summary":{"file_count":876,"total_bytes":9265289},"files":[{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_core_metadata.py","size":19102,"sha1":"e58f9b1b485aa9694621a3880381519c6aad911a","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport functools\nimport importlib\nimport io\nfrom email import message_from_string\nfrom email.generator import Generator\nfrom email.message import EmailMessage, Message\nfrom email.parser import Parser\nfrom email.policy import EmailPolicy\nfrom inspect import cleandoc\nfrom pathlib import Path\nfrom unittest.mock import Mock\n\nimport pytest\nfrom packaging.metadata import Metadata\nfrom packaging.requirements import Requirement\n\nfrom setuptools import _reqs, sic\nfrom setuptools._core_metadata import rfc822_escape, rfc822_unescape\nfrom setuptools.command.egg_info import egg_info, write_requirements\nfrom setuptools.config import expand, setupcfg\nfrom setuptools.dist import Distribution\n\nfrom .config.downloads import retrieve_file, urls_from_file\n\nEXAMPLE_BASE_INFO = dict(\n    name=\"package\",\n    version=\"0.0.1\",\n    author=\"Foo Bar\",\n    author_email=\"foo@bar.net\",\n    long_description=\"Long\\ndescription\",\n    description=\"Short description\",\n    keywords=[\"one\", \"two\"],\n)\n\n\n@pytest.mark.parametrize(\n    (\"content\", \"result\"),\n    (\n        pytest.param(\n            \"Just a single line\",\n            None,\n            id=\"single_line\",\n        ),\n        pytest.param(\n            \"Multiline\\nText\\nwithout\\nextra indents\\n\",\n            None,\n            id=\"multiline\",\n        ),\n        pytest.param(\n            \"Multiline\\n    With\\n\\nadditional\\n  indentation\",\n            None,\n            id=\"multiline_with_indentation\",\n        ),\n        pytest.param(\n            \"  Leading whitespace\",\n            \"Leading whitespace\",\n            id=\"remove_leading_whitespace\",\n        ),\n        pytest.param(\n            \"  Leading whitespace\\nIn\\n    Multiline comment\",\n            \"Leading whitespace\\nIn\\n    Multiline comment\",\n            id=\"remove_leading_whitespace_multiline\",\n        ),\n    ),\n)\ndef test_rfc822_unescape(content, result):\n    assert (result or content) == rfc822_unescape(rfc822_escape(content))\n\n\ndef __read_test_cases():\n    base = EXAMPLE_BASE_INFO\n\n    params = functools.partial(dict, base)\n\n    return [\n        ('Metadata version 1.0', params()),\n        (\n            'Metadata Version 1.0: Short long description',\n            params(\n                long_description='Short long description',\n            ),\n        ),\n        (\n            'Metadata version 1.1: Classifiers',\n            params(\n                classifiers=[\n                    'Programming Language :: Python :: 3',\n                    'Programming Language :: Python :: 3.7',\n                    'License :: OSI Approved :: MIT License',\n                ],\n            ),\n        ),\n        (\n            'Metadata version 1.1: Download URL',\n            params(\n                download_url='https://example.com',\n            ),\n        ),\n        (\n            'Metadata Version 1.2: Requires-Python',\n            params(\n                python_requires='>=3.7',\n            ),\n        ),\n        pytest.param(\n            'Metadata Version 1.2: Project-Url',\n            params(project_urls=dict(Foo='https://example.bar')),\n            marks=pytest.mark.xfail(\n                reason=\"Issue #1578: project_urls not read\",\n            ),\n        ),\n        (\n            'Metadata Version 2.1: Long Description Content Type',\n            params(\n                long_description_content_type='text/x-rst; charset=UTF-8',\n            ),\n        ),\n        (\n            'License',\n            params(\n                license='MIT',\n            ),\n        ),\n        (\n            'License multiline',\n            params(\n                license='This is a long license \\nover multiple lines',\n            ),\n        ),\n        pytest.param(\n            'Metadata Version 2.1: Provides Extra',\n            params(provides_extras=['foo', 'bar']),\n            marks=pytest.mark.xfail(reason=\"provides_extras not read\"),\n        ),\n        (\n            'Missing author',\n            dict(\n                name='foo',\n                version='1.0.0',\n                author_email='snorri@sturluson.name',\n            ),\n        ),\n        (\n            'Missing author e-mail',\n            dict(\n                name='foo',\n                version='1.0.0',\n                author='Snorri Sturluson',\n            ),\n        ),\n        (\n            'Missing author and e-mail',\n            dict(\n                name='foo',\n                version='1.0.0',\n            ),\n        ),\n        (\n            'Bypass normalized version',\n            dict(\n                name='foo',\n                version=sic('1.0.0a'),\n            ),\n        ),\n    ]\n\n\n@pytest.mark.parametrize((\"name\", \"attrs\"), __read_test_cases())\ndef test_read_metadata(name, attrs):\n    dist = Distribution(attrs)\n    metadata_out = dist.metadata\n    dist_class = metadata_out.__class__\n\n    # Write to PKG_INFO and then load into a new metadata object\n    PKG_INFO = io.StringIO()\n\n    metadata_out.write_pkg_file(PKG_INFO)\n    PKG_INFO.seek(0)\n    pkg_info = PKG_INFO.read()\n    assert _valid_metadata(pkg_info)\n\n    PKG_INFO.seek(0)\n    metadata_in = dist_class()\n    metadata_in.read_pkg_file(PKG_INFO)\n\n    tested_attrs = [\n        ('name', dist_class.get_name),\n        ('version', dist_class.get_version),\n        ('author', dist_class.get_contact),\n        ('author_email', dist_class.get_contact_email),\n        ('metadata_version', dist_class.get_metadata_version),\n        ('provides', dist_class.get_provides),\n        ('description', dist_class.get_description),\n        ('long_description', dist_class.get_long_description),\n        ('download_url', dist_class.get_download_url),\n        ('keywords', dist_class.get_keywords),\n        ('platforms', dist_class.get_platforms),\n        ('obsoletes', dist_class.get_obsoletes),\n        ('requires', dist_class.get_requires),\n        ('classifiers', dist_class.get_classifiers),\n        ('project_urls', lambda s: getattr(s, 'project_urls', {})),\n        ('provides_extras', lambda s: getattr(s, 'provides_extras', {})),\n    ]\n\n    for attr, getter in tested_attrs:\n        assert getter(metadata_in) == getter(metadata_out)\n\n\ndef __maintainer_test_cases():\n    attrs = {\"name\": \"package\", \"version\": \"1.0\", \"description\": \"xxx\"}\n\n    def merge_dicts(d1, d2):\n        d1 = d1.copy()\n        d1.update(d2)\n\n        return d1\n\n    return [\n        ('No author, no maintainer', attrs.copy()),\n        (\n            'Author (no e-mail), no maintainer',\n            merge_dicts(attrs, {'author': 'Author Name'}),\n        ),\n        (\n            'Author (e-mail), no maintainer',\n            merge_dicts(\n                attrs, {'author': 'Author Name', 'author_email': 'author@name.com'}\n            ),\n        ),\n        (\n            'No author, maintainer (no e-mail)',\n            merge_dicts(attrs, {'maintainer': 'Maintainer Name'}),\n        ),\n        (\n            'No author, maintainer (e-mail)',\n            merge_dicts(\n                attrs,\n                {\n                    'maintainer': 'Maintainer Name',\n                    'maintainer_email': 'maintainer@name.com',\n                },\n            ),\n        ),\n        (\n            'Author (no e-mail), Maintainer (no-email)',\n            merge_dicts(\n                attrs, {'author': 'Author Name', 'maintainer': 'Maintainer Name'}\n            ),\n        ),\n        (\n            'Author (e-mail), Maintainer (e-mail)',\n            merge_dicts(\n                attrs,\n                {\n                    'author': 'Author Name',\n                    'author_email': 'author@name.com',\n                    'maintainer': 'Maintainer Name',\n                    'maintainer_email': 'maintainer@name.com',\n                },\n            ),\n        ),\n        (\n            'No author (e-mail), no maintainer (e-mail)',\n            merge_dicts(\n                attrs,\n                {\n                    'author_email': 'author@name.com',\n                    'maintainer_email': 'maintainer@name.com',\n                },\n            ),\n        ),\n        ('Author unicode', merge_dicts(attrs, {'author': '鉄沢寛'})),\n        ('Maintainer unicode', merge_dicts(attrs, {'maintainer': 'Jan Łukasiewicz'})),\n    ]\n\n\n@pytest.mark.parametrize((\"name\", \"attrs\"), __maintainer_test_cases())\ndef test_maintainer_author(name, attrs, tmpdir):\n    tested_keys = {\n        'author': 'Author',\n        'author_email': 'Author-email',\n        'maintainer': 'Maintainer',\n        'maintainer_email': 'Maintainer-email',\n    }\n\n    # Generate a PKG-INFO file\n    dist = Distribution(attrs)\n    fn = tmpdir.mkdir('pkg_info')\n    fn_s = str(fn)\n\n    dist.metadata.write_pkg_info(fn_s)\n\n    with open(str(fn.join('PKG-INFO')), 'r', encoding='utf-8') as f:\n        pkg_info = f.read()\n\n    assert _valid_metadata(pkg_info)\n\n    # Drop blank lines and strip lines from default description\n    raw_pkg_lines = pkg_info.splitlines()\n    pkg_lines = list(filter(None, raw_pkg_lines[:-2]))\n\n    pkg_lines_set = set(pkg_lines)\n\n    # Duplicate lines should not be generated\n    assert len(pkg_lines) == len(pkg_lines_set)\n\n    for fkey, dkey in tested_keys.items():\n        val = attrs.get(dkey, None)\n        if val is None:\n            for line in pkg_lines:\n                assert not line.startswith(fkey + ':')\n        else:\n            line = f'{fkey}: {val}'\n            assert line in pkg_lines_set\n\n\nclass TestParityWithMetadataFromPyPaWheel:\n    def base_example(self):\n        attrs = dict(\n            **EXAMPLE_BASE_INFO,\n            # Example with complex requirement definition\n            python_requires=\">=3.8\",\n            install_requires=\"\"\"\n            packaging==23.2\n            more-itertools==8.8.0; extra == \"other\"\n            jaraco.text==3.7.0\n            importlib-resources==5.10.2; python_version<\"3.8\"\n            importlib-metadata==6.0.0 ; python_version<\"3.8\"\n            colorama>=0.4.4; sys_platform == \"win32\"\n            \"\"\",\n            extras_require={\n                \"testing\": \"\"\"\n                    pytest >= 6\n                    pytest-checkdocs >= 2.4\n                    tomli ; \\\\\n                            # Using stdlib when possible\n                            python_version < \"3.11\"\n                    ini2toml[lite]>=0.9\n                    \"\"\",\n                \"other\": [],\n            },\n        )\n        # Generate a PKG-INFO file using setuptools\n        return Distribution(attrs)\n\n    def test_requires_dist(self, tmp_path):\n        dist = self.base_example()\n        pkg_info = _get_pkginfo(dist)\n        assert _valid_metadata(pkg_info)\n\n        # Ensure Requires-Dist is present\n        expected = [\n            'Metadata-Version:',\n            'Requires-Python: >=3.8',\n            'Provides-Extra: other',\n            'Provides-Extra: testing',\n            'Requires-Dist: tomli; python_version < \"3.11\" and extra == \"testing\"',\n            'Requires-Dist: more-itertools==8.8.0; extra == \"other\"',\n            'Requires-Dist: ini2toml[lite]>=0.9; extra == \"testing\"',\n        ]\n        for line in expected:\n            assert line in pkg_info\n\n    HERE = Path(__file__).parent\n    EXAMPLES_FILE = HERE / \"config/setupcfg_examples.txt\"\n\n    @pytest.fixture(params=[None, *urls_from_file(EXAMPLES_FILE)])\n    def dist(self, request, monkeypatch, tmp_path):\n        \"\"\"Example of distribution with arbitrary configuration\"\"\"\n        monkeypatch.chdir(tmp_path)\n        monkeypatch.setattr(expand, \"read_attr\", Mock(return_value=\"0.42\"))\n        monkeypatch.setattr(expand, \"read_files\", Mock(return_value=\"hello world\"))\n        if request.param is None:\n            yield self.base_example()\n        else:\n            # Real-world usage\n            config = retrieve_file(request.param)\n            yield setupcfg.apply_configuration(Distribution({}), config)\n\n    @pytest.mark.uses_network\n    def test_equivalent_output(self, tmp_path, dist):\n        \"\"\"Ensure output from setuptools is equivalent to the one from `pypa/wheel`\"\"\"\n        # Generate a METADATA file using pypa/wheel for comparison\n        wheel_metadata = importlib.import_module(\"wheel.metadata\")\n        pkginfo_to_metadata = getattr(wheel_metadata, \"pkginfo_to_metadata\", None)\n\n        if pkginfo_to_metadata is None:  # pragma: nocover\n            pytest.xfail(\n                \"wheel.metadata.pkginfo_to_metadata is undefined, \"\n                \"(this is likely to be caused by API changes in pypa/wheel\"\n            )\n\n        # Generate an simplified \"egg-info\" dir for pypa/wheel to convert\n        pkg_info = _get_pkginfo(dist)\n        egg_info_dir = tmp_path / \"pkg.egg-info\"\n        egg_info_dir.mkdir(parents=True)\n        (egg_info_dir / \"PKG-INFO\").write_text(pkg_info, encoding=\"utf-8\")\n        write_requirements(egg_info(dist), egg_info_dir, egg_info_dir / \"requires.txt\")\n\n        # Get pypa/wheel generated METADATA but normalize requirements formatting\n        metadata_msg = pkginfo_to_metadata(egg_info_dir, egg_info_dir / \"PKG-INFO\")\n        metadata_str = _normalize_metadata(metadata_msg)\n        pkg_info_msg = message_from_string(pkg_info)\n        pkg_info_str = _normalize_metadata(pkg_info_msg)\n\n        # Compare setuptools PKG-INFO x pypa/wheel METADATA\n        assert metadata_str == pkg_info_str\n\n        # Make sure it parses/serializes well in pypa/wheel\n        _assert_roundtrip_message(pkg_info)\n\n\nclass TestPEP643:\n    STATIC_CONFIG = {\n        \"setup.cfg\": cleandoc(\n            \"\"\"\n            [metadata]\n            name = package\n            version = 0.0.1\n            author = Foo Bar\n            author_email = foo@bar.net\n            long_description = Long\n                               description\n            description = Short description\n            keywords = one, two\n            platforms = abcd\n            [options]\n            install_requires = requests\n            \"\"\"\n        ),\n        \"pyproject.toml\": cleandoc(\n            \"\"\"\n            [project]\n            name = \"package\"\n            version = \"0.0.1\"\n            authors = [\n              {name = \"Foo Bar\", email = \"foo@bar.net\"}\n            ]\n            description = \"Short description\"\n            readme = {text = \"Long\\\\ndescription\", content-type = \"text/plain\"}\n            keywords = [\"one\", \"two\"]\n            dependencies = [\"requests\"]\n            [tool.setuptools]\n            provides = [\"abcd\"]\n            obsoletes = [\"abcd\"]\n            \"\"\"\n        ),\n    }\n\n    @pytest.mark.parametrize(\"file\", STATIC_CONFIG.keys())\n    def test_static_config_has_no_dynamic(self, file, tmpdir_cwd):\n        Path(file).write_text(self.STATIC_CONFIG[file], encoding=\"utf-8\")\n        metadata = _get_metadata()\n        assert metadata.get_all(\"Dynamic\") is None\n        assert metadata.get_all(\"dynamic\") is None\n\n    @pytest.mark.parametrize(\"file\", STATIC_CONFIG.keys())\n    @pytest.mark.parametrize(\n        \"fields\",\n        [\n            # Single dynamic field\n            {\"requires-python\": (\"python_requires\", \">=3.12\")},\n            {\"author-email\": (\"author_email\", \"snoopy@peanuts.com\")},\n            {\"keywords\": (\"keywords\", [\"hello\", \"world\"])},\n            {\"platform\": (\"platforms\", [\"abcd\"])},\n            # Multiple dynamic fields\n            {\n                \"summary\": (\"description\", \"hello world\"),\n                \"description\": (\"long_description\", \"bla bla bla bla\"),\n                \"requires-dist\": (\"install_requires\", [\"hello-world\"]),\n            },\n        ],\n    )\n    def test_modified_fields_marked_as_dynamic(self, file, fields, tmpdir_cwd):\n        # We start with a static config\n        Path(file).write_text(self.STATIC_CONFIG[file], encoding=\"utf-8\")\n        dist = _makedist()\n\n        # ... but then we simulate the effects of a plugin modifying the distribution\n        for attr, value in fields.values():\n            # `dist` and `dist.metadata` are complicated...\n            # Some attributes work when set on `dist`, others on `dist.metadata`...\n            # Here we set in both just in case (this also avoids calling `_finalize_*`)\n            setattr(dist, attr, value)\n            setattr(dist.metadata, attr, value)\n\n        # Then we should be able to list the modified fields as Dynamic\n        metadata = _get_metadata(dist)\n        assert set(metadata.get_all(\"Dynamic\")) == set(fields)\n\n\ndef _makedist(**attrs):\n    dist = Distribution(attrs)\n    dist.parse_config_files()\n    return dist\n\n\ndef _assert_roundtrip_message(metadata: str) -> None:\n    \"\"\"Emulate the way wheel.bdist_wheel parses and regenerates the message,\n    then ensures the metadata generated by setuptools is compatible.\n    \"\"\"\n    with io.StringIO(metadata) as buffer:\n        msg = Parser(EmailMessage).parse(buffer)\n\n    serialization_policy = EmailPolicy(\n        utf8=True,\n        mangle_from_=False,\n        max_line_length=0,\n    )\n    with io.BytesIO() as buffer:\n        out = io.TextIOWrapper(buffer, encoding=\"utf-8\")\n        Generator(out, policy=serialization_policy).flatten(msg)\n        out.flush()\n        regenerated = buffer.getvalue()\n\n    raw_metadata = bytes(metadata, \"utf-8\")\n    # Normalise newlines to avoid test errors on Windows:\n    raw_metadata = b\"\\n\".join(raw_metadata.splitlines())\n    regenerated = b\"\\n\".join(regenerated.splitlines())\n    assert regenerated == raw_metadata\n\n\ndef _normalize_metadata(msg: Message) -> str:\n    \"\"\"Allow equivalent metadata to be compared directly\"\"\"\n    # The main challenge regards the requirements and extras.\n    # Both setuptools and wheel already apply some level of normalization\n    # but they differ regarding which character is chosen, according to the\n    # following spec it should be \"-\":\n    # https://packaging.python.org/en/latest/specifications/name-normalization/\n\n    # Related issues:\n    # https://github.com/pypa/packaging/issues/845\n    # https://github.com/pypa/packaging/issues/644#issuecomment-2429813968\n\n    extras = {x.replace(\"_\", \"-\"): x for x in msg.get_all(\"Provides-Extra\", [])}\n    reqs = [\n        _normalize_req(req, extras)\n        for req in _reqs.parse(msg.get_all(\"Requires-Dist\", []))\n    ]\n    del msg[\"Requires-Dist\"]\n    del msg[\"Provides-Extra\"]\n\n    # Ensure consistent ord\n    for req in sorted(reqs):\n        msg[\"Requires-Dist\"] = req\n    for extra in sorted(extras):\n        msg[\"Provides-Extra\"] = extra\n\n    # TODO: Handle lack of PEP 643 implementation in pypa/wheel?\n    del msg[\"Metadata-Version\"]\n\n    return msg.as_string()\n\n\ndef _normalize_req(req: Requirement, extras: dict[str, str]) -> str:\n    \"\"\"Allow equivalent requirement objects to be compared directly\"\"\"\n    as_str = str(req).replace(req.name, req.name.replace(\"_\", \"-\"))\n    for norm, orig in extras.items():\n        as_str = as_str.replace(orig, norm)\n    return as_str\n\n\ndef _get_pkginfo(dist: Distribution):\n    with io.StringIO() as fp:\n        dist.metadata.write_pkg_file(fp)\n        return fp.getvalue()\n\n\ndef _get_metadata(dist: Distribution | None = None):\n    return message_from_string(_get_pkginfo(dist or _makedist()))\n\n\ndef _valid_metadata(text: str) -> bool:\n    metadata = Metadata.from_email(text, validate=True)  # can raise exceptions\n    return metadata is not None\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_depends.py","size":424,"sha1":"68d31b1b07c991a0b0f802a4f41e003755ac44e4","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\n\nfrom setuptools import depends\n\n\nclass TestGetModuleConstant:\n    def test_basic(self):\n        \"\"\"\n        Invoke get_module_constant on a module in\n        the test package.\n        \"\"\"\n        mod_name = 'setuptools.tests.mod_with_constant'\n        val = depends.get_module_constant(mod_name, 'value')\n        assert val == 'three, sir!'\n        assert 'setuptools.tests.mod_with_constant' not in sys.modules\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_develop.py","size":5142,"sha1":"2e44559602cce9555d950e198f303548a1810c7f","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"develop tests\"\"\"\n\nimport os\nimport pathlib\nimport platform\nimport subprocess\nimport sys\n\nimport pytest\n\nfrom setuptools._path import paths_on_pythonpath\nfrom setuptools.command.develop import develop\nfrom setuptools.dist import Distribution\n\nfrom . import contexts, namespaces\n\nSETUP_PY = \"\"\"\\\nfrom setuptools import setup\n\nsetup(name='foo',\n    packages=['foo'],\n)\n\"\"\"\n\nINIT_PY = \"\"\"print \"foo\"\n\"\"\"\n\n\n@pytest.fixture\ndef temp_user(monkeypatch):\n    with contexts.tempdir() as user_base:\n        with contexts.tempdir() as user_site:\n            monkeypatch.setattr('site.USER_BASE', user_base)\n            monkeypatch.setattr('site.USER_SITE', user_site)\n            yield\n\n\n@pytest.fixture\ndef test_env(tmpdir, temp_user):\n    target = tmpdir\n    foo = target.mkdir('foo')\n    setup = target / 'setup.py'\n    if setup.isfile():\n        raise ValueError(dir(target))\n    with setup.open('w') as f:\n        f.write(SETUP_PY)\n    init = foo / '__init__.py'\n    with init.open('w') as f:\n        f.write(INIT_PY)\n    with target.as_cwd():\n        yield target\n\n\nclass TestDevelop:\n    in_virtualenv = hasattr(sys, 'real_prefix')\n    in_venv = hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix\n\n    def test_console_scripts(self, tmpdir):\n        \"\"\"\n        Test that console scripts are installed and that they reference\n        only the project by name and not the current version.\n        \"\"\"\n        pytest.skip(\n            \"TODO: needs a fixture to cause 'develop' \"\n            \"to be invoked without mutating environment.\"\n        )\n        settings = dict(\n            name='foo',\n            packages=['foo'],\n            version='0.0',\n            entry_points={\n                'console_scripts': [\n                    'foocmd = foo:foo',\n                ],\n            },\n        )\n        dist = Distribution(settings)\n        dist.script_name = 'setup.py'\n        cmd = develop(dist)\n        cmd.ensure_finalized()\n        cmd.install_dir = tmpdir\n        cmd.run()\n        # assert '0.0' not in foocmd_text\n\n    @pytest.mark.xfail(reason=\"legacy behavior retained for compatibility #4167\")\n    def test_egg_link_filename(self):\n        settings = dict(\n            name='Foo $$$ Bar_baz-bing',\n        )\n        dist = Distribution(settings)\n        cmd = develop(dist)\n        cmd.ensure_finalized()\n        link = pathlib.Path(cmd.egg_link)\n        assert link.suffix == '.egg-link'\n        assert link.stem == 'Foo_Bar_baz_bing'\n\n\nclass TestResolver:\n    \"\"\"\n    TODO: These tests were written with a minimal understanding\n    of what _resolve_setup_path is intending to do. Come up with\n    more meaningful cases that look like real-world scenarios.\n    \"\"\"\n\n    def test_resolve_setup_path_cwd(self):\n        assert develop._resolve_setup_path('.', '.', '.') == '.'\n\n    def test_resolve_setup_path_one_dir(self):\n        assert develop._resolve_setup_path('pkgs', '.', 'pkgs') == '../'\n\n    def test_resolve_setup_path_one_dir_trailing_slash(self):\n        assert develop._resolve_setup_path('pkgs/', '.', 'pkgs') == '../'\n\n\nclass TestNamespaces:\n    @staticmethod\n    def install_develop(src_dir, target):\n        develop_cmd = [\n            sys.executable,\n            'setup.py',\n            'develop',\n            '--install-dir',\n            str(target),\n        ]\n        with src_dir.as_cwd():\n            with paths_on_pythonpath([str(target)]):\n                subprocess.check_call(develop_cmd)\n\n    @pytest.mark.skipif(\n        bool(os.environ.get(\"APPVEYOR\")),\n        reason=\"https://github.com/pypa/setuptools/issues/851\",\n    )\n    @pytest.mark.skipif(\n        platform.python_implementation() == 'PyPy',\n        reason=\"https://github.com/pypa/setuptools/issues/1202\",\n    )\n    def test_namespace_package_importable(self, tmpdir):\n        \"\"\"\n        Installing two packages sharing the same namespace, one installed\n        naturally using pip or `--single-version-externally-managed`\n        and the other installed using `develop` should leave the namespace\n        in tact and both packages reachable by import.\n        \"\"\"\n        pkg_A = namespaces.build_namespace_package(tmpdir, 'myns.pkgA')\n        pkg_B = namespaces.build_namespace_package(tmpdir, 'myns.pkgB')\n        target = tmpdir / 'packages'\n        # use pip to install to the target directory\n        install_cmd = [\n            sys.executable,\n            '-m',\n            'pip',\n            'install',\n            str(pkg_A),\n            '-t',\n            str(target),\n        ]\n        subprocess.check_call(install_cmd)\n        self.install_develop(pkg_B, target)\n        namespaces.make_site_dir(target)\n        try_import = [\n            sys.executable,\n            '-c',\n            'import myns.pkgA; import myns.pkgB',\n        ]\n        with paths_on_pythonpath([str(target)]):\n            subprocess.check_call(try_import)\n\n        # additionally ensure that pkg_resources import works\n        pkg_resources_imp = [\n            sys.executable,\n            '-c',\n            'import pkg_resources',\n        ]\n        with paths_on_pythonpath([str(target)]):\n            subprocess.check_call(pkg_resources_imp)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_dist.py","size":8897,"sha1":"5adde2fede46fb86b3724641c093c9033c2d3787","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import os\nimport re\nimport urllib.parse\nimport urllib.request\n\nimport pytest\n\nfrom setuptools import Distribution\nfrom setuptools.dist import check_package_data, check_specifier\n\nfrom .test_easy_install import make_nspkg_sdist\nfrom .test_find_packages import ensure_files\nfrom .textwrap import DALS\n\nfrom distutils.errors import DistutilsSetupError\n\n\ndef test_dist_fetch_build_egg(tmpdir):\n    \"\"\"\n    Check multiple calls to `Distribution.fetch_build_egg` work as expected.\n    \"\"\"\n    index = tmpdir.mkdir('index')\n    index_url = urllib.parse.urljoin('file://', urllib.request.pathname2url(str(index)))\n\n    def sdist_with_index(distname, version):\n        dist_dir = index.mkdir(distname)\n        dist_sdist = f'{distname}-{version}.tar.gz'\n        make_nspkg_sdist(str(dist_dir.join(dist_sdist)), distname, version)\n        with dist_dir.join('index.html').open('w') as fp:\n            fp.write(\n                DALS(\n                    \"\"\"\n                <!DOCTYPE html><html><body>\n                <a href=\"{dist_sdist}\" rel=\"internal\">{dist_sdist}</a><br/>\n                </body></html>\n                \"\"\"\n                ).format(dist_sdist=dist_sdist)\n            )\n\n    sdist_with_index('barbazquux', '3.2.0')\n    sdist_with_index('barbazquux-runner', '2.11.1')\n    with tmpdir.join('setup.cfg').open('w') as fp:\n        fp.write(\n            DALS(\n                \"\"\"\n            [easy_install]\n            index_url = {index_url}\n            \"\"\"\n            ).format(index_url=index_url)\n        )\n    reqs = \"\"\"\n    barbazquux-runner\n    barbazquux\n    \"\"\".split()\n    with tmpdir.as_cwd():\n        dist = Distribution()\n        dist.parse_config_files()\n        resolved_dists = [dist.fetch_build_egg(r) for r in reqs]\n    assert [dist.key for dist in resolved_dists if dist] == reqs\n\n\nEXAMPLE_BASE_INFO = dict(\n    name=\"package\",\n    version=\"0.0.1\",\n    author=\"Foo Bar\",\n    author_email=\"foo@bar.net\",\n    long_description=\"Long\\ndescription\",\n    description=\"Short description\",\n    keywords=[\"one\", \"two\"],\n)\n\n\ndef test_provides_extras_deterministic_order():\n    attrs = dict(extras_require=dict(a=['foo'], b=['bar']))\n    dist = Distribution(attrs)\n    assert list(dist.metadata.provides_extras) == ['a', 'b']\n    attrs['extras_require'] = dict(reversed(attrs['extras_require'].items()))\n    dist = Distribution(attrs)\n    assert list(dist.metadata.provides_extras) == ['b', 'a']\n\n\nCHECK_PACKAGE_DATA_TESTS = (\n    # Valid.\n    (\n        {\n            '': ['*.txt', '*.rst'],\n            'hello': ['*.msg'],\n        },\n        None,\n    ),\n    # Not a dictionary.\n    (\n        (\n            ('', ['*.txt', '*.rst']),\n            ('hello', ['*.msg']),\n        ),\n        (\n            \"'package_data' must be a dictionary mapping package\"\n            \" names to lists of string wildcard patterns\"\n        ),\n    ),\n    # Invalid key type.\n    (\n        {\n            400: ['*.txt', '*.rst'],\n        },\n        (\"keys of 'package_data' dict must be strings (got 400)\"),\n    ),\n    # Invalid value type.\n    (\n        {\n            'hello': '*.msg',\n        },\n        (\n            \"\\\"values of 'package_data' dict\\\" must be of type <tuple[str, ...] | list[str]>\"\n            \" (got '*.msg')\"\n        ),\n    ),\n    # Invalid value type (generators are single use)\n    (\n        {\n            'hello': (x for x in \"generator\"),\n        },\n        (\n            \"\\\"values of 'package_data' dict\\\" must be of type <tuple[str, ...] | list[str]>\"\n            \" (got <generator object\"\n        ),\n    ),\n)\n\n\n@pytest.mark.parametrize(('package_data', 'expected_message'), CHECK_PACKAGE_DATA_TESTS)\ndef test_check_package_data(package_data, expected_message):\n    if expected_message is None:\n        assert check_package_data(None, 'package_data', package_data) is None\n    else:\n        with pytest.raises(DistutilsSetupError, match=re.escape(expected_message)):\n            check_package_data(None, 'package_data', package_data)\n\n\ndef test_check_specifier():\n    # valid specifier value\n    attrs = {'name': 'foo', 'python_requires': '>=3.0, !=3.1'}\n    dist = Distribution(attrs)\n    check_specifier(dist, attrs, attrs['python_requires'])\n\n    attrs = {'name': 'foo', 'python_requires': ['>=3.0', '!=3.1']}\n    dist = Distribution(attrs)\n    check_specifier(dist, attrs, attrs['python_requires'])\n\n    # invalid specifier value\n    attrs = {'name': 'foo', 'python_requires': '>=invalid-version'}\n    with pytest.raises(DistutilsSetupError):\n        dist = Distribution(attrs)\n\n\ndef test_metadata_name():\n    with pytest.raises(DistutilsSetupError, match='missing.*name'):\n        Distribution()._validate_metadata()\n\n\n@pytest.mark.parametrize(\n    ('dist_name', 'py_module'),\n    [\n        (\"my.pkg\", \"my_pkg\"),\n        (\"my-pkg\", \"my_pkg\"),\n        (\"my_pkg\", \"my_pkg\"),\n        (\"pkg\", \"pkg\"),\n    ],\n)\ndef test_dist_default_py_modules(tmp_path, dist_name, py_module):\n    (tmp_path / f\"{py_module}.py\").touch()\n\n    (tmp_path / \"setup.py\").touch()\n    (tmp_path / \"noxfile.py\").touch()\n    # ^-- make sure common tool files are ignored\n\n    attrs = {**EXAMPLE_BASE_INFO, \"name\": dist_name, \"src_root\": str(tmp_path)}\n    # Find `py_modules` corresponding to dist_name if not given\n    dist = Distribution(attrs)\n    dist.set_defaults()\n    assert dist.py_modules == [py_module]\n    # When `py_modules` is given, don't do anything\n    dist = Distribution({**attrs, \"py_modules\": [\"explicity_py_module\"]})\n    dist.set_defaults()\n    assert dist.py_modules == [\"explicity_py_module\"]\n    # When `packages` is given, don't do anything\n    dist = Distribution({**attrs, \"packages\": [\"explicity_package\"]})\n    dist.set_defaults()\n    assert not dist.py_modules\n\n\n@pytest.mark.parametrize(\n    ('dist_name', 'package_dir', 'package_files', 'packages'),\n    [\n        (\"my.pkg\", None, [\"my_pkg/__init__.py\", \"my_pkg/mod.py\"], [\"my_pkg\"]),\n        (\"my-pkg\", None, [\"my_pkg/__init__.py\", \"my_pkg/mod.py\"], [\"my_pkg\"]),\n        (\"my_pkg\", None, [\"my_pkg/__init__.py\", \"my_pkg/mod.py\"], [\"my_pkg\"]),\n        (\"my.pkg\", None, [\"my/pkg/__init__.py\"], [\"my\", \"my.pkg\"]),\n        (\n            \"my_pkg\",\n            None,\n            [\"src/my_pkg/__init__.py\", \"src/my_pkg2/__init__.py\"],\n            [\"my_pkg\", \"my_pkg2\"],\n        ),\n        (\n            \"my_pkg\",\n            {\"pkg\": \"lib\", \"pkg2\": \"lib2\"},\n            [\"lib/__init__.py\", \"lib/nested/__init__.pyt\", \"lib2/__init__.py\"],\n            [\"pkg\", \"pkg.nested\", \"pkg2\"],\n        ),\n    ],\n)\ndef test_dist_default_packages(\n    tmp_path, dist_name, package_dir, package_files, packages\n):\n    ensure_files(tmp_path, package_files)\n\n    (tmp_path / \"setup.py\").touch()\n    (tmp_path / \"noxfile.py\").touch()\n    # ^-- should not be included by default\n\n    attrs = {\n        **EXAMPLE_BASE_INFO,\n        \"name\": dist_name,\n        \"src_root\": str(tmp_path),\n        \"package_dir\": package_dir,\n    }\n    # Find `packages` either corresponding to dist_name or inside src\n    dist = Distribution(attrs)\n    dist.set_defaults()\n    assert not dist.py_modules\n    assert not dist.py_modules\n    assert set(dist.packages) == set(packages)\n    # When `py_modules` is given, don't do anything\n    dist = Distribution({**attrs, \"py_modules\": [\"explicit_py_module\"]})\n    dist.set_defaults()\n    assert not dist.packages\n    assert set(dist.py_modules) == {\"explicit_py_module\"}\n    # When `packages` is given, don't do anything\n    dist = Distribution({**attrs, \"packages\": [\"explicit_package\"]})\n    dist.set_defaults()\n    assert not dist.py_modules\n    assert set(dist.packages) == {\"explicit_package\"}\n\n\n@pytest.mark.parametrize(\n    ('dist_name', 'package_dir', 'package_files'),\n    [\n        (\"my.pkg.nested\", None, [\"my/pkg/nested/__init__.py\"]),\n        (\"my.pkg\", None, [\"my/pkg/__init__.py\", \"my/pkg/file.py\"]),\n        (\"my_pkg\", None, [\"my_pkg.py\"]),\n        (\"my_pkg\", None, [\"my_pkg/__init__.py\", \"my_pkg/nested/__init__.py\"]),\n        (\"my_pkg\", None, [\"src/my_pkg/__init__.py\", \"src/my_pkg/nested/__init__.py\"]),\n        (\n            \"my_pkg\",\n            {\"my_pkg\": \"lib\", \"my_pkg.lib2\": \"lib2\"},\n            [\"lib/__init__.py\", \"lib/nested/__init__.pyt\", \"lib2/__init__.py\"],\n        ),\n        # Should not try to guess a name from multiple py_modules/packages\n        (\"UNKNOWN\", None, [\"src/mod1.py\", \"src/mod2.py\"]),\n        (\"UNKNOWN\", None, [\"src/pkg1/__ini__.py\", \"src/pkg2/__init__.py\"]),\n    ],\n)\ndef test_dist_default_name(tmp_path, dist_name, package_dir, package_files):\n    \"\"\"Make sure dist.name is discovered from packages/py_modules\"\"\"\n    ensure_files(tmp_path, package_files)\n    attrs = {\n        **EXAMPLE_BASE_INFO,\n        \"src_root\": \"/\".join(os.path.split(tmp_path)),  # POSIX-style\n        \"package_dir\": package_dir,\n    }\n    del attrs[\"name\"]\n\n    dist = Distribution(attrs)\n    dist.set_defaults()\n    assert dist.py_modules or dist.packages\n    assert dist.get_name() == dist_name\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_dist_info.py","size":7094,"sha1":"0a88a23457b983575bc2a2530964a22689d0c0bf","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Test .dist-info style distributions.\"\"\"\n\nimport pathlib\nimport re\nimport shutil\nimport subprocess\nimport sys\nfrom functools import partial\n\nimport pytest\n\nimport pkg_resources\nfrom setuptools.archive_util import unpack_archive\n\nfrom .textwrap import DALS\n\nread = partial(pathlib.Path.read_text, encoding=\"utf-8\")\n\n\nclass TestDistInfo:\n    metadata_base = DALS(\n        \"\"\"\n        Metadata-Version: 1.2\n        Requires-Dist: splort (==4)\n        Provides-Extra: baz\n        Requires-Dist: quux (>=1.1); extra == 'baz'\n        \"\"\"\n    )\n\n    @classmethod\n    def build_metadata(cls, **kwargs):\n        lines = ('{key}: {value}\\n'.format(**locals()) for key, value in kwargs.items())\n        return cls.metadata_base + ''.join(lines)\n\n    @pytest.fixture\n    def metadata(self, tmpdir):\n        dist_info_name = 'VersionedDistribution-2.718.dist-info'\n        versioned = tmpdir / dist_info_name\n        versioned.mkdir()\n        filename = versioned / 'METADATA'\n        content = self.build_metadata(\n            Name='VersionedDistribution',\n        )\n        filename.write_text(content, encoding='utf-8')\n\n        dist_info_name = 'UnversionedDistribution.dist-info'\n        unversioned = tmpdir / dist_info_name\n        unversioned.mkdir()\n        filename = unversioned / 'METADATA'\n        content = self.build_metadata(\n            Name='UnversionedDistribution',\n            Version='0.3',\n        )\n        filename.write_text(content, encoding='utf-8')\n\n        return str(tmpdir)\n\n    def test_distinfo(self, metadata):\n        dists = dict(\n            (d.project_name, d) for d in pkg_resources.find_distributions(metadata)\n        )\n\n        assert len(dists) == 2, dists\n\n        unversioned = dists['UnversionedDistribution']\n        versioned = dists['VersionedDistribution']\n\n        assert versioned.version == '2.718'  # from filename\n        assert unversioned.version == '0.3'  # from METADATA\n\n    def test_conditional_dependencies(self, metadata):\n        specs = 'splort==4', 'quux>=1.1'\n        requires = list(map(pkg_resources.Requirement.parse, specs))\n\n        for d in pkg_resources.find_distributions(metadata):\n            assert d.requires() == requires[:1]\n            assert d.requires(extras=('baz',)) == [\n                requires[0],\n                pkg_resources.Requirement.parse('quux>=1.1;extra==\"baz\"'),\n            ]\n            assert d.extras == ['baz']\n\n    def test_invalid_version(self, tmp_path):\n        \"\"\"\n        Supplying an invalid version crashes dist_info.\n        \"\"\"\n        config = \"[metadata]\\nname=proj\\nversion=42\\n[egg_info]\\ntag_build=invalid!!!\\n\"\n        (tmp_path / \"setup.cfg\").write_text(config, encoding=\"utf-8\")\n        msg = re.compile(\"invalid version\", re.M | re.I)\n        proc = run_command_inner(\"dist_info\", cwd=tmp_path, check=False)\n        assert proc.returncode\n        assert msg.search(proc.stdout)\n        assert not list(tmp_path.glob(\"*.dist-info\"))\n\n    def test_tag_arguments(self, tmp_path):\n        config = \"\"\"\n        [metadata]\n        name=proj\n        version=42\n        [egg_info]\n        tag_date=1\n        tag_build=.post\n        \"\"\"\n        (tmp_path / \"setup.cfg\").write_text(config, encoding=\"utf-8\")\n\n        print(run_command(\"dist_info\", \"--no-date\", cwd=tmp_path))\n        dist_info = next(tmp_path.glob(\"*.dist-info\"))\n        assert dist_info.name.startswith(\"proj-42\")\n        shutil.rmtree(dist_info)\n\n        print(run_command(\"dist_info\", \"--tag-build\", \".a\", cwd=tmp_path))\n        dist_info = next(tmp_path.glob(\"*.dist-info\"))\n        assert dist_info.name.startswith(\"proj-42a\")\n\n    @pytest.mark.parametrize(\"keep_egg_info\", (False, True))\n    def test_output_dir(self, tmp_path, keep_egg_info):\n        config = \"[metadata]\\nname=proj\\nversion=42\\n\"\n        (tmp_path / \"setup.cfg\").write_text(config, encoding=\"utf-8\")\n        out = tmp_path / \"__out\"\n        out.mkdir()\n        opts = [\"--keep-egg-info\"] if keep_egg_info else []\n        run_command(\"dist_info\", \"--output-dir\", out, *opts, cwd=tmp_path)\n        assert len(list(out.glob(\"*.dist-info\"))) == 1\n        assert len(list(tmp_path.glob(\"*.dist-info\"))) == 0\n        expected_egg_info = int(keep_egg_info)\n        assert len(list(out.glob(\"*.egg-info\"))) == expected_egg_info\n        assert len(list(tmp_path.glob(\"*.egg-info\"))) == 0\n        assert len(list(out.glob(\"*.__bkp__\"))) == 0\n        assert len(list(tmp_path.glob(\"*.__bkp__\"))) == 0\n\n\nclass TestWheelCompatibility:\n    \"\"\"Make sure the .dist-info directory produced with the ``dist_info`` command\n    is the same as the one produced by ``bdist_wheel``.\n    \"\"\"\n\n    SETUPCFG = DALS(\n        \"\"\"\n    [metadata]\n    name = {name}\n    version = {version}\n\n    [options]\n    install_requires =\n        foo>=12; sys_platform != \"linux\"\n\n    [options.extras_require]\n    test = pytest\n\n    [options.entry_points]\n    console_scripts =\n        executable-name = my_package.module:function\n    discover =\n        myproj = my_package.other_module:function\n    \"\"\"\n    )\n\n    EGG_INFO_OPTS = [\n        # Related: #3088 #2872\n        (\"\", \"\"),\n        (\".post\", \"[egg_info]\\ntag_build = post\\n\"),\n        (\".post\", \"[egg_info]\\ntag_build = .post\\n\"),\n        (\".post\", \"[egg_info]\\ntag_build = post\\ntag_date = 1\\n\"),\n        (\".dev\", \"[egg_info]\\ntag_build = .dev\\n\"),\n        (\".dev\", \"[egg_info]\\ntag_build = .dev\\ntag_date = 1\\n\"),\n        (\"a1\", \"[egg_info]\\ntag_build = .a1\\n\"),\n        (\"+local\", \"[egg_info]\\ntag_build = +local\\n\"),\n    ]\n\n    @pytest.mark.parametrize(\"name\", \"my-proj my_proj my.proj My.Proj\".split())\n    @pytest.mark.parametrize(\"version\", [\"0.42.13\"])\n    @pytest.mark.parametrize((\"suffix\", \"cfg\"), EGG_INFO_OPTS)\n    def test_dist_info_is_the_same_as_in_wheel(\n        self, name, version, tmp_path, suffix, cfg\n    ):\n        config = self.SETUPCFG.format(name=name, version=version) + cfg\n\n        for i in \"dir_wheel\", \"dir_dist\":\n            (tmp_path / i).mkdir()\n            (tmp_path / i / \"setup.cfg\").write_text(config, encoding=\"utf-8\")\n\n        run_command(\"bdist_wheel\", cwd=tmp_path / \"dir_wheel\")\n        wheel = next(tmp_path.glob(\"dir_wheel/dist/*.whl\"))\n        unpack_archive(wheel, tmp_path / \"unpack\")\n        wheel_dist_info = next(tmp_path.glob(\"unpack/*.dist-info\"))\n\n        run_command(\"dist_info\", cwd=tmp_path / \"dir_dist\")\n        dist_info = next(tmp_path.glob(\"dir_dist/*.dist-info\"))\n\n        assert dist_info.name == wheel_dist_info.name\n        assert dist_info.name.startswith(f\"{name.replace('-', '_')}-{version}{suffix}\")\n        for file in \"METADATA\", \"entry_points.txt\":\n            assert read(dist_info / file) == read(wheel_dist_info / file)\n\n\ndef run_command_inner(*cmd, **kwargs):\n    opts = {\n        \"stderr\": subprocess.STDOUT,\n        \"stdout\": subprocess.PIPE,\n        \"text\": True,\n        \"encoding\": \"utf-8\",\n        \"check\": True,\n        **kwargs,\n    }\n    cmd = [sys.executable, \"-c\", \"__import__('setuptools').setup()\", *map(str, cmd)]\n    return subprocess.run(cmd, **opts)\n\n\ndef run_command(*args, **kwargs):\n    return run_command_inner(*args, **kwargs).stdout\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_distutils_adoption.py","size":5987,"sha1":"f47bd13506ba24843d5fa2c8de4a8ac271ddc7e7","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import os\nimport platform\nimport sys\nimport textwrap\n\nimport pytest\n\nIS_PYPY = '__pypy__' in sys.builtin_module_names\n\n_TEXT_KWARGS = {\"text\": True, \"encoding\": \"utf-8\"}  # For subprocess.run\n\n\ndef win_sr(env):\n    \"\"\"\n    On Windows, SYSTEMROOT must be present to avoid\n\n    > Fatal Python error: _Py_HashRandomization_Init: failed to\n    > get random numbers to initialize Python\n    \"\"\"\n    if env and platform.system() == 'Windows':\n        env['SYSTEMROOT'] = os.environ['SYSTEMROOT']\n    return env\n\n\ndef find_distutils(venv, imports='distutils', env=None, **kwargs):\n    py_cmd = 'import {imports}; print(distutils.__file__)'.format(**locals())\n    cmd = ['python', '-c', py_cmd]\n    return venv.run(cmd, env=win_sr(env), **_TEXT_KWARGS, **kwargs)\n\n\ndef count_meta_path(venv, env=None):\n    py_cmd = textwrap.dedent(\n        \"\"\"\n        import sys\n        is_distutils = lambda finder: finder.__class__.__name__ == \"DistutilsMetaFinder\"\n        print(len(list(filter(is_distutils, sys.meta_path))))\n        \"\"\"\n    )\n    cmd = ['python', '-c', py_cmd]\n    return int(venv.run(cmd, env=win_sr(env), **_TEXT_KWARGS))\n\n\nskip_without_stdlib_distutils = pytest.mark.skipif(\n    sys.version_info >= (3, 12),\n    reason='stdlib distutils is removed from Python 3.12+',\n)\n\n\n@skip_without_stdlib_distutils\ndef test_distutils_stdlib(venv):\n    \"\"\"\n    Ensure stdlib distutils is used when appropriate.\n    \"\"\"\n    env = dict(SETUPTOOLS_USE_DISTUTILS='stdlib')\n    assert venv.name not in find_distutils(venv, env=env).split(os.sep)\n    assert count_meta_path(venv, env=env) == 0\n\n\ndef test_distutils_local_with_setuptools(venv):\n    \"\"\"\n    Ensure local distutils is used when appropriate.\n    \"\"\"\n    env = dict(SETUPTOOLS_USE_DISTUTILS='local')\n    loc = find_distutils(venv, imports='setuptools, distutils', env=env)\n    assert venv.name in loc.split(os.sep)\n    assert count_meta_path(venv, env=env) <= 1\n\n\n@pytest.mark.xfail('IS_PYPY', reason='pypy imports distutils on startup')\ndef test_distutils_local(venv):\n    \"\"\"\n    Even without importing, the setuptools-local copy of distutils is\n    preferred.\n    \"\"\"\n    env = dict(SETUPTOOLS_USE_DISTUTILS='local')\n    assert venv.name in find_distutils(venv, env=env).split(os.sep)\n    assert count_meta_path(venv, env=env) <= 1\n\n\ndef test_pip_import(venv):\n    \"\"\"\n    Ensure pip can be imported.\n    Regression test for #3002.\n    \"\"\"\n    cmd = ['python', '-c', 'import pip']\n    venv.run(cmd, **_TEXT_KWARGS)\n\n\ndef test_distutils_has_origin():\n    \"\"\"\n    Distutils module spec should have an origin. #2990.\n    \"\"\"\n    assert __import__('distutils').__spec__.origin\n\n\nENSURE_IMPORTS_ARE_NOT_DUPLICATED = r\"\"\"\n# Depending on the importlib machinery and _distutils_hack, some imports are\n# duplicated resulting in different module objects being loaded, which prevents\n# patches as shown in #3042.\n# This script provides a way of verifying if this duplication is happening.\n\nfrom distutils import cmd\nimport distutils.command.sdist as sdist\n\n# import last to prevent caching\nfrom distutils import {imported_module}\n\nfor mod in (cmd, sdist):\n    assert mod.{imported_module} == {imported_module}, (\n        f\"\\n{{mod.dir_util}}\\n!=\\n{{{imported_module}}}\"\n    )\n\nprint(\"success\")\n\"\"\"\n\n\n@pytest.mark.usefixtures(\"tmpdir_cwd\")\n@pytest.mark.parametrize(\n    ('distutils_version', 'imported_module'),\n    [\n        pytest.param(\"stdlib\", \"dir_util\", marks=skip_without_stdlib_distutils),\n        pytest.param(\"stdlib\", \"file_util\", marks=skip_without_stdlib_distutils),\n        pytest.param(\"stdlib\", \"archive_util\", marks=skip_without_stdlib_distutils),\n        (\"local\", \"dir_util\"),\n        (\"local\", \"file_util\"),\n        (\"local\", \"archive_util\"),\n    ],\n)\ndef test_modules_are_not_duplicated_on_import(distutils_version, imported_module, venv):\n    env = dict(SETUPTOOLS_USE_DISTUTILS=distutils_version)\n    script = ENSURE_IMPORTS_ARE_NOT_DUPLICATED.format(imported_module=imported_module)\n    cmd = ['python', '-c', script]\n    output = venv.run(cmd, env=win_sr(env), **_TEXT_KWARGS).strip()\n    assert output == \"success\"\n\n\nENSURE_LOG_IMPORT_IS_NOT_DUPLICATED = r\"\"\"\nimport types\nimport distutils.dist as dist\nfrom distutils import log\nif isinstance(dist.log, types.ModuleType):\n    assert dist.log == log, f\"\\n{dist.log}\\n!=\\n{log}\"\nprint(\"success\")\n\"\"\"\n\n\n@pytest.mark.usefixtures(\"tmpdir_cwd\")\n@pytest.mark.parametrize(\n    \"distutils_version\",\n    [\n        \"local\",\n        pytest.param(\"stdlib\", marks=skip_without_stdlib_distutils),\n    ],\n)\ndef test_log_module_is_not_duplicated_on_import(distutils_version, venv):\n    env = dict(SETUPTOOLS_USE_DISTUTILS=distutils_version)\n    cmd = ['python', '-c', ENSURE_LOG_IMPORT_IS_NOT_DUPLICATED]\n    output = venv.run(cmd, env=win_sr(env), **_TEXT_KWARGS).strip()\n    assert output == \"success\"\n\n\nENSURE_CONSISTENT_ERROR_FROM_MODIFIED_PY = r\"\"\"\nfrom setuptools.modified import newer\nfrom {imported_module}.errors import DistutilsError\n\n# Can't use pytest.raises in this context\ntry:\n    newer(\"\", \"\")\nexcept DistutilsError:\n    print(\"success\")\nelse:\n    raise AssertionError(\"Expected to raise\")\n\"\"\"\n\n\n@pytest.mark.usefixtures(\"tmpdir_cwd\")\n@pytest.mark.parametrize(\n    ('distutils_version', 'imported_module'),\n    [\n        (\"local\", \"distutils\"),\n        # Unfortunately we still get ._distutils.errors.DistutilsError with SETUPTOOLS_USE_DISTUTILS=stdlib\n        # But that's a deprecated use-case we don't mind not fully supporting in newer code\n        pytest.param(\n            \"stdlib\", \"setuptools._distutils\", marks=skip_without_stdlib_distutils\n        ),\n    ],\n)\ndef test_consistent_error_from_modified_py(distutils_version, imported_module, venv):\n    env = dict(SETUPTOOLS_USE_DISTUTILS=distutils_version)\n    cmd = [\n        'python',\n        '-c',\n        ENSURE_CONSISTENT_ERROR_FROM_MODIFIED_PY.format(\n            imported_module=imported_module\n        ),\n    ]\n    output = venv.run(cmd, env=win_sr(env), **_TEXT_KWARGS).strip()\n    assert output == \"success\"\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_easy_install.py","size":53308,"sha1":"37f36165bc69ced97d17569ebc750a9d23c2a20e","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Easy install Tests\"\"\"\n\nimport contextlib\nimport io\nimport itertools\nimport logging\nimport os\nimport pathlib\nimport re\nimport site\nimport subprocess\nimport sys\nimport tarfile\nimport tempfile\nimport time\nimport warnings\nimport zipfile\nfrom pathlib import Path\nfrom typing import NamedTuple\nfrom unittest import mock\n\nimport pytest\nfrom jaraco import path\n\nimport pkg_resources\nimport setuptools.command.easy_install as ei\nfrom pkg_resources import Distribution as PRDistribution, normalize_path, working_set\nfrom setuptools import sandbox\nfrom setuptools.command.easy_install import PthDistributions\nfrom setuptools.dist import Distribution\nfrom setuptools.sandbox import run_setup\nfrom setuptools.tests import fail_on_ascii\nfrom setuptools.tests.server import MockServer, path_to_url\n\nfrom . import contexts\nfrom .textwrap import DALS\n\nimport distutils.errors\n\n\n@pytest.fixture(autouse=True)\ndef pip_disable_index(monkeypatch):\n    \"\"\"\n    Important: Disable the default index for pip to avoid\n    querying packages in the index and potentially resolving\n    and installing packages there.\n    \"\"\"\n    monkeypatch.setenv('PIP_NO_INDEX', 'true')\n\n\nclass FakeDist:\n    def get_entry_map(self, group):\n        if group != 'console_scripts':\n            return {}\n        return {'name': 'ep'}\n\n    def as_requirement(self):\n        return 'spec'\n\n\nSETUP_PY = DALS(\n    \"\"\"\n    from setuptools import setup\n\n    setup()\n    \"\"\"\n)\n\n\nclass TestEasyInstallTest:\n    def test_get_script_args(self):\n        header = ei.CommandSpec.best().from_environment().as_header()\n        dist = FakeDist()\n        args = next(ei.ScriptWriter.get_args(dist))\n        _name, script = itertools.islice(args, 2)\n        assert script.startswith(header)\n        assert \"'spec'\" in script\n        assert \"'console_scripts'\" in script\n        assert \"'name'\" in script\n        assert re.search('^# EASY-INSTALL-ENTRY-SCRIPT', script, flags=re.MULTILINE)\n\n    def test_no_find_links(self):\n        # new option '--no-find-links', that blocks find-links added at\n        # the project level\n        dist = Distribution()\n        cmd = ei.easy_install(dist)\n        cmd.check_pth_processing = lambda: True\n        cmd.no_find_links = True\n        cmd.find_links = ['link1', 'link2']\n        cmd.install_dir = os.path.join(tempfile.mkdtemp(), 'ok')\n        cmd.args = ['ok']\n        cmd.ensure_finalized()\n        assert cmd.package_index.scanned_urls == {}\n\n        # let's try without it (default behavior)\n        cmd = ei.easy_install(dist)\n        cmd.check_pth_processing = lambda: True\n        cmd.find_links = ['link1', 'link2']\n        cmd.install_dir = os.path.join(tempfile.mkdtemp(), 'ok')\n        cmd.args = ['ok']\n        cmd.ensure_finalized()\n        keys = sorted(cmd.package_index.scanned_urls.keys())\n        assert keys == ['link1', 'link2']\n\n    def test_write_exception(self):\n        \"\"\"\n        Test that `cant_write_to_target` is rendered as a DistutilsError.\n        \"\"\"\n        dist = Distribution()\n        cmd = ei.easy_install(dist)\n        cmd.install_dir = os.getcwd()\n        with pytest.raises(distutils.errors.DistutilsError):\n            cmd.cant_write_to_target()\n\n    def test_all_site_dirs(self, monkeypatch):\n        \"\"\"\n        get_site_dirs should always return site dirs reported by\n        site.getsitepackages.\n        \"\"\"\n        path = normalize_path('/setuptools/test/site-packages')\n\n        def mock_gsp():\n            return [path]\n\n        monkeypatch.setattr(site, 'getsitepackages', mock_gsp, raising=False)\n        assert path in ei.get_site_dirs()\n\n    def test_all_site_dirs_works_without_getsitepackages(self, monkeypatch):\n        monkeypatch.delattr(site, 'getsitepackages', raising=False)\n        assert ei.get_site_dirs()\n\n    @pytest.fixture\n    def sdist_unicode(self, tmpdir):\n        files = [\n            (\n                'setup.py',\n                DALS(\n                    \"\"\"\n                    import setuptools\n                    setuptools.setup(\n                        name=\"setuptools-test-unicode\",\n                        version=\"1.0\",\n                        packages=[\"mypkg\"],\n                        include_package_data=True,\n                    )\n                    \"\"\"\n                ),\n            ),\n            (\n                'mypkg/__init__.py',\n                \"\",\n            ),\n            (\n                'mypkg/☃.txt',\n                \"\",\n            ),\n        ]\n        sdist_name = 'setuptools-test-unicode-1.0.zip'\n        sdist = tmpdir / sdist_name\n        # can't use make_sdist, because the issue only occurs\n        #  with zip sdists.\n        sdist_zip = zipfile.ZipFile(str(sdist), 'w')\n        for filename, content in files:\n            sdist_zip.writestr(filename, content)\n        sdist_zip.close()\n        return str(sdist)\n\n    @fail_on_ascii\n    def test_unicode_filename_in_sdist(self, sdist_unicode, tmpdir, monkeypatch):\n        \"\"\"\n        The install command should execute correctly even if\n        the package has unicode filenames.\n        \"\"\"\n        dist = Distribution({'script_args': ['easy_install']})\n        target = (tmpdir / 'target').ensure_dir()\n        cmd = ei.easy_install(\n            dist,\n            install_dir=str(target),\n            args=['x'],\n        )\n        monkeypatch.setitem(os.environ, 'PYTHONPATH', str(target))\n        cmd.ensure_finalized()\n        cmd.easy_install(sdist_unicode)\n\n    @pytest.fixture\n    def sdist_unicode_in_script(self, tmpdir):\n        files = [\n            (\n                \"setup.py\",\n                DALS(\n                    \"\"\"\n                    import setuptools\n                    setuptools.setup(\n                        name=\"setuptools-test-unicode\",\n                        version=\"1.0\",\n                        packages=[\"mypkg\"],\n                        include_package_data=True,\n                        scripts=['mypkg/unicode_in_script'],\n                    )\n                    \"\"\"\n                ),\n            ),\n            (\"mypkg/__init__.py\", \"\"),\n            (\n                \"mypkg/unicode_in_script\",\n                DALS(\n                    \"\"\"\n                    #!/bin/sh\n                    # á\n\n                    non_python_fn() {\n                    }\n                \"\"\"\n                ),\n            ),\n        ]\n        sdist_name = \"setuptools-test-unicode-script-1.0.zip\"\n        sdist = tmpdir / sdist_name\n        # can't use make_sdist, because the issue only occurs\n        #  with zip sdists.\n        sdist_zip = zipfile.ZipFile(str(sdist), \"w\")\n        for filename, content in files:\n            sdist_zip.writestr(filename, content.encode('utf-8'))\n        sdist_zip.close()\n        return str(sdist)\n\n    @fail_on_ascii\n    def test_unicode_content_in_sdist(\n        self, sdist_unicode_in_script, tmpdir, monkeypatch\n    ):\n        \"\"\"\n        The install command should execute correctly even if\n        the package has unicode in scripts.\n        \"\"\"\n        dist = Distribution({\"script_args\": [\"easy_install\"]})\n        target = (tmpdir / \"target\").ensure_dir()\n        cmd = ei.easy_install(dist, install_dir=str(target), args=[\"x\"])\n        monkeypatch.setitem(os.environ, \"PYTHONPATH\", str(target))\n        cmd.ensure_finalized()\n        cmd.easy_install(sdist_unicode_in_script)\n\n    @pytest.fixture\n    def sdist_script(self, tmpdir):\n        files = [\n            (\n                'setup.py',\n                DALS(\n                    \"\"\"\n                    import setuptools\n                    setuptools.setup(\n                        name=\"setuptools-test-script\",\n                        version=\"1.0\",\n                        scripts=[\"mypkg_script\"],\n                    )\n                    \"\"\"\n                ),\n            ),\n            (\n                'mypkg_script',\n                DALS(\n                    \"\"\"\n                     #/usr/bin/python\n                     print('mypkg_script')\n                     \"\"\"\n                ),\n            ),\n        ]\n        sdist_name = 'setuptools-test-script-1.0.zip'\n        sdist = str(tmpdir / sdist_name)\n        make_sdist(sdist, files)\n        return sdist\n\n    @pytest.mark.skipif(\n        not sys.platform.startswith('linux'), reason=\"Test can only be run on Linux\"\n    )\n    def test_script_install(self, sdist_script, tmpdir, monkeypatch):\n        \"\"\"\n        Check scripts are installed.\n        \"\"\"\n        dist = Distribution({'script_args': ['easy_install']})\n        target = (tmpdir / 'target').ensure_dir()\n        cmd = ei.easy_install(\n            dist,\n            install_dir=str(target),\n            args=['x'],\n        )\n        monkeypatch.setitem(os.environ, 'PYTHONPATH', str(target))\n        cmd.ensure_finalized()\n        cmd.easy_install(sdist_script)\n        assert (target / 'mypkg_script').exists()\n\n\n@pytest.mark.filterwarnings('ignore:Unbuilt egg')\nclass TestPTHFileWriter:\n    def test_add_from_cwd_site_sets_dirty(self):\n        \"\"\"a pth file manager should set dirty\n        if a distribution is in site but also the cwd\n        \"\"\"\n        pth = PthDistributions('does-not_exist', [os.getcwd()])\n        assert not pth.dirty\n        pth.add(PRDistribution(os.getcwd()))\n        assert pth.dirty\n\n    def test_add_from_site_is_ignored(self):\n        location = '/test/location/does-not-have-to-exist'\n        # PthDistributions expects all locations to be normalized\n        location = pkg_resources.normalize_path(location)\n        pth = PthDistributions(\n            'does-not_exist',\n            [\n                location,\n            ],\n        )\n        assert not pth.dirty\n        pth.add(PRDistribution(location))\n        assert not pth.dirty\n\n    def test_many_pth_distributions_merge_together(self, tmpdir):\n        \"\"\"\n        If the pth file is modified under the hood, then PthDistribution\n        will refresh its content before saving, merging contents when\n        necessary.\n        \"\"\"\n        # putting the pth file in a dedicated sub-folder,\n        pth_subdir = tmpdir.join(\"pth_subdir\")\n        pth_subdir.mkdir()\n        pth_path = str(pth_subdir.join(\"file1.pth\"))\n        pth1 = PthDistributions(pth_path)\n        pth2 = PthDistributions(pth_path)\n        assert pth1.paths == pth2.paths == [], (\n            \"unless there would be some default added at some point\"\n        )\n        # and so putting the src_subdir in folder distinct than the pth one,\n        # so to keep it absolute by PthDistributions\n        new_src_path = tmpdir.join(\"src_subdir\")\n        new_src_path.mkdir()  # must exist to be accounted\n        new_src_path_str = str(new_src_path)\n        pth1.paths.append(new_src_path_str)\n        pth1.save()\n        assert pth1.paths, (\n            \"the new_src_path added must still be present/valid in pth1 after save\"\n        )\n        # now,\n        assert new_src_path_str not in pth2.paths, (\n            \"right before we save the entry should still not be present\"\n        )\n        pth2.save()\n        assert new_src_path_str in pth2.paths, (\n            \"the new_src_path entry should have been added by pth2 with its save() call\"\n        )\n        assert pth2.paths[-1] == new_src_path, (\n            \"and it should match exactly on the last entry actually \"\n            \"given we append to it in save()\"\n        )\n        # finally,\n        assert PthDistributions(pth_path).paths == pth2.paths, (\n            \"and we should have the exact same list at the end \"\n            \"with a fresh PthDistributions instance\"\n        )\n\n\n@pytest.fixture\ndef setup_context(tmpdir):\n    with (tmpdir / 'setup.py').open('w', encoding=\"utf-8\") as f:\n        f.write(SETUP_PY)\n    with tmpdir.as_cwd():\n        yield tmpdir\n\n\n@pytest.mark.usefixtures(\"user_override\")\n@pytest.mark.usefixtures(\"setup_context\")\nclass TestUserInstallTest:\n    # prevent check that site-packages is writable. easy_install\n    # shouldn't be writing to system site-packages during finalize\n    # options, but while it does, bypass the behavior.\n    prev_sp_write = mock.patch(\n        'setuptools.command.easy_install.easy_install.check_site_dir',\n        mock.Mock(),\n    )\n\n    # simulate setuptools installed in user site packages\n    @mock.patch('setuptools.command.easy_install.__file__', site.USER_SITE)\n    @mock.patch('site.ENABLE_USER_SITE', True)\n    @prev_sp_write\n    def test_user_install_not_implied_user_site_enabled(self):\n        self.assert_not_user_site()\n\n    @mock.patch('site.ENABLE_USER_SITE', False)\n    @prev_sp_write\n    def test_user_install_not_implied_user_site_disabled(self):\n        self.assert_not_user_site()\n\n    @staticmethod\n    def assert_not_user_site():\n        # create a finalized easy_install command\n        dist = Distribution()\n        dist.script_name = 'setup.py'\n        cmd = ei.easy_install(dist)\n        cmd.args = ['py']\n        cmd.ensure_finalized()\n        assert not cmd.user, 'user should not be implied'\n\n    def test_multiproc_atexit(self):\n        pytest.importorskip('multiprocessing')\n\n        log = logging.getLogger('test_easy_install')\n        logging.basicConfig(level=logging.INFO, stream=sys.stderr)\n        log.info('this should not break')\n\n    @pytest.fixture\n    def foo_package(self, tmpdir):\n        egg_file = tmpdir / 'foo-1.0.egg-info'\n        with egg_file.open('w') as f:\n            f.write('Name: foo\\n')\n        return str(tmpdir)\n\n    @pytest.fixture\n    def install_target(self, tmpdir):\n        target = str(tmpdir)\n        with mock.patch('sys.path', sys.path + [target]):\n            python_path = os.path.pathsep.join(sys.path)\n            with mock.patch.dict(os.environ, PYTHONPATH=python_path):\n                yield target\n\n    def test_local_index(self, foo_package, install_target):\n        \"\"\"\n        The local index must be used when easy_install locates installed\n        packages.\n        \"\"\"\n        dist = Distribution()\n        dist.script_name = 'setup.py'\n        cmd = ei.easy_install(dist)\n        cmd.install_dir = install_target\n        cmd.args = ['foo']\n        cmd.ensure_finalized()\n        cmd.local_index.scan([foo_package])\n        res = cmd.easy_install('foo')\n        actual = os.path.normcase(os.path.realpath(res.location))\n        expected = os.path.normcase(os.path.realpath(foo_package))\n        assert actual == expected\n\n    @contextlib.contextmanager\n    def user_install_setup_context(self, *args, **kwargs):\n        \"\"\"\n        Wrap sandbox.setup_context to patch easy_install in that context to\n        appear as user-installed.\n        \"\"\"\n        with self.orig_context(*args, **kwargs):\n            import setuptools.command.easy_install as ei\n\n            ei.__file__ = site.USER_SITE\n            yield\n\n    def patched_setup_context(self):\n        self.orig_context = sandbox.setup_context\n\n        return mock.patch(\n            'setuptools.sandbox.setup_context',\n            self.user_install_setup_context,\n        )\n\n\n@pytest.fixture\ndef distutils_package():\n    distutils_setup_py = SETUP_PY.replace(\n        'from setuptools import setup',\n        'from distutils.core import setup',\n    )\n    with contexts.tempdir(cd=os.chdir):\n        with open('setup.py', 'w', encoding=\"utf-8\") as f:\n            f.write(distutils_setup_py)\n        yield\n\n\n@pytest.mark.usefixtures(\"distutils_package\")\nclass TestDistutilsPackage:\n    def test_bdist_egg_available_on_distutils_pkg(self):\n        run_setup('setup.py', ['bdist_egg'])\n\n\n@pytest.fixture\ndef mock_index():\n    # set up a server which will simulate an alternate package index.\n    p_index = MockServer()\n    if p_index.server_port == 0:\n        # Some platforms (Jython) don't find a port to which to bind,\n        # so skip test for them.\n        pytest.skip(\"could not find a valid port\")\n    p_index.start()\n    return p_index\n\n\nclass TestInstallRequires:\n    def test_setup_install_includes_dependencies(self, tmp_path, mock_index):\n        \"\"\"\n        When ``python setup.py install`` is called directly, it will use easy_install\n        to fetch dependencies.\n        \"\"\"\n        # TODO: Remove these tests once `setup.py install` is completely removed\n        project_root = tmp_path / \"project\"\n        project_root.mkdir(exist_ok=True)\n        install_root = tmp_path / \"install\"\n        install_root.mkdir(exist_ok=True)\n\n        self.create_project(project_root)\n        cmd = [\n            sys.executable,\n            '-c',\n            '__import__(\"setuptools\").setup()',\n            'install',\n            '--install-base',\n            str(install_root),\n            '--install-lib',\n            str(install_root),\n            '--install-headers',\n            str(install_root),\n            '--install-scripts',\n            str(install_root),\n            '--install-data',\n            str(install_root),\n            '--install-purelib',\n            str(install_root),\n            '--install-platlib',\n            str(install_root),\n        ]\n        env = {**os.environ, \"__EASYINSTALL_INDEX\": mock_index.url}\n        cp = subprocess.run(\n            cmd,\n            cwd=str(project_root),\n            env=env,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            text=True,\n            encoding=\"utf-8\",\n        )\n        assert cp.returncode != 0\n        try:\n            assert '/does-not-exist/' in {r.path for r in mock_index.requests}\n            assert next(\n                line\n                for line in cp.stdout.splitlines()\n                if \"not find suitable distribution for\" in line\n                and \"does-not-exist\" in line\n            )\n        except Exception:\n            if \"failed to get random numbers\" in cp.stdout:\n                pytest.xfail(f\"{sys.platform} failure - {cp.stdout}\")\n            raise\n\n    def create_project(self, root):\n        config = \"\"\"\n        [metadata]\n        name = project\n        version = 42\n\n        [options]\n        install_requires = does-not-exist\n        py_modules = mod\n        \"\"\"\n        (root / 'setup.cfg').write_text(DALS(config), encoding=\"utf-8\")\n        (root / 'mod.py').touch()\n\n\nclass TestSetupRequires:\n    def test_setup_requires_honors_fetch_params(self, mock_index, monkeypatch):\n        \"\"\"\n        When easy_install installs a source distribution which specifies\n        setup_requires, it should honor the fetch parameters (such as\n        index-url, and find-links).\n        \"\"\"\n        monkeypatch.setenv('PIP_RETRIES', '0')\n        monkeypatch.setenv('PIP_TIMEOUT', '0')\n        monkeypatch.setenv('PIP_NO_INDEX', 'false')\n        with contexts.quiet():\n            # create an sdist that has a build-time dependency.\n            with TestSetupRequires.create_sdist() as dist_file:\n                with contexts.tempdir() as temp_install_dir:\n                    with contexts.environment(PYTHONPATH=temp_install_dir):\n                        cmd = [\n                            sys.executable,\n                            '-c',\n                            '__import__(\"setuptools\").setup()',\n                            'easy_install',\n                            '--index-url',\n                            mock_index.url,\n                            '--exclude-scripts',\n                            '--install-dir',\n                            temp_install_dir,\n                            dist_file,\n                        ]\n                        subprocess.Popen(cmd).wait()\n        # there should have been one requests to the server\n        assert [r.path for r in mock_index.requests] == ['/does-not-exist/']\n\n    @staticmethod\n    @contextlib.contextmanager\n    def create_sdist():\n        \"\"\"\n        Return an sdist with a setup_requires dependency (of something that\n        doesn't exist)\n        \"\"\"\n        with contexts.tempdir() as dir:\n            dist_path = os.path.join(dir, 'setuptools-test-fetcher-1.0.tar.gz')\n            make_sdist(\n                dist_path,\n                [\n                    (\n                        'setup.py',\n                        DALS(\n                            \"\"\"\n                    import setuptools\n                    setuptools.setup(\n                        name=\"setuptools-test-fetcher\",\n                        version=\"1.0\",\n                        setup_requires = ['does-not-exist'],\n                    )\n                \"\"\"\n                        ),\n                    ),\n                    ('setup.cfg', ''),\n                ],\n            )\n            yield dist_path\n\n    use_setup_cfg = (\n        (),\n        ('dependency_links',),\n        ('setup_requires',),\n        ('dependency_links', 'setup_requires'),\n    )\n\n    @pytest.mark.parametrize('use_setup_cfg', use_setup_cfg)\n    def test_setup_requires_overrides_version_conflict(self, use_setup_cfg):\n        \"\"\"\n        Regression test for distribution issue 323:\n        https://bitbucket.org/tarek/distribute/issues/323\n\n        Ensures that a distribution's setup_requires requirements can still be\n        installed and used locally even if a conflicting version of that\n        requirement is already on the path.\n        \"\"\"\n\n        fake_dist = PRDistribution(\n            'does-not-matter', project_name='foobar', version='0.0'\n        )\n        working_set.add(fake_dist)\n\n        with contexts.save_pkg_resources_state():\n            with contexts.tempdir() as temp_dir:\n                test_pkg = create_setup_requires_package(\n                    temp_dir, use_setup_cfg=use_setup_cfg\n                )\n                test_setup_py = os.path.join(test_pkg, 'setup.py')\n                with contexts.quiet() as (stdout, _stderr):\n                    # Don't even need to install the package, just\n                    # running the setup.py at all is sufficient\n                    run_setup(test_setup_py, ['--name'])\n\n                lines = stdout.readlines()\n                assert len(lines) > 0\n                assert lines[-1].strip() == 'test_pkg'\n\n    @pytest.mark.parametrize('use_setup_cfg', use_setup_cfg)\n    def test_setup_requires_override_nspkg(self, use_setup_cfg):\n        \"\"\"\n        Like ``test_setup_requires_overrides_version_conflict`` but where the\n        ``setup_requires`` package is part of a namespace package that has\n        *already* been imported.\n        \"\"\"\n\n        with contexts.save_pkg_resources_state():\n            with contexts.tempdir() as temp_dir:\n                foobar_1_archive = os.path.join(temp_dir, 'foo.bar-0.1.tar.gz')\n                make_nspkg_sdist(foobar_1_archive, 'foo.bar', '0.1')\n                # Now actually go ahead an extract to the temp dir and add the\n                # extracted path to sys.path so foo.bar v0.1 is importable\n                foobar_1_dir = os.path.join(temp_dir, 'foo.bar-0.1')\n                os.mkdir(foobar_1_dir)\n                with tarfile.open(foobar_1_archive) as tf:\n                    tf.extraction_filter = lambda member, path: member\n                    tf.extractall(foobar_1_dir)\n                sys.path.insert(1, foobar_1_dir)\n\n                dist = PRDistribution(\n                    foobar_1_dir, project_name='foo.bar', version='0.1'\n                )\n                working_set.add(dist)\n\n                template = DALS(\n                    \"\"\"\\\n                    import foo  # Even with foo imported first the\n                                # setup_requires package should override\n                    import setuptools\n                    setuptools.setup(**%r)\n\n                    if not (hasattr(foo, '__path__') and\n                            len(foo.__path__) == 2):\n                        print('FAIL')\n\n                    if 'foo.bar-0.2' not in foo.__path__[0]:\n                        print('FAIL')\n                \"\"\"\n                )\n\n                test_pkg = create_setup_requires_package(\n                    temp_dir,\n                    'foo.bar',\n                    '0.2',\n                    make_nspkg_sdist,\n                    template,\n                    use_setup_cfg=use_setup_cfg,\n                )\n\n                test_setup_py = os.path.join(test_pkg, 'setup.py')\n\n                with contexts.quiet() as (stdout, _stderr):\n                    try:\n                        # Don't even need to install the package, just\n                        # running the setup.py at all is sufficient\n                        run_setup(test_setup_py, ['--name'])\n                    except pkg_resources.VersionConflict:\n                        self.fail(\n                            'Installing setup.py requirements caused a VersionConflict'\n                        )\n\n                assert 'FAIL' not in stdout.getvalue()\n                lines = stdout.readlines()\n                assert len(lines) > 0\n                assert lines[-1].strip() == 'test_pkg'\n\n    @pytest.mark.parametrize('use_setup_cfg', use_setup_cfg)\n    def test_setup_requires_with_attr_version(self, use_setup_cfg):\n        def make_dependency_sdist(dist_path, distname, version):\n            files = [\n                (\n                    'setup.py',\n                    DALS(\n                        f\"\"\"\n                    import setuptools\n                    setuptools.setup(\n                        name={distname!r},\n                        version={version!r},\n                        py_modules=[{distname!r}],\n                    )\n                    \"\"\"\n                    ),\n                ),\n                (\n                    distname + '.py',\n                    DALS(\n                        \"\"\"\n                    version = 42\n                    \"\"\"\n                    ),\n                ),\n            ]\n            make_sdist(dist_path, files)\n\n        with contexts.save_pkg_resources_state():\n            with contexts.tempdir() as temp_dir:\n                test_pkg = create_setup_requires_package(\n                    temp_dir,\n                    setup_attrs=dict(version='attr: foobar.version'),\n                    make_package=make_dependency_sdist,\n                    use_setup_cfg=use_setup_cfg + ('version',),\n                )\n                test_setup_py = os.path.join(test_pkg, 'setup.py')\n                with contexts.quiet() as (stdout, _stderr):\n                    run_setup(test_setup_py, ['--version'])\n                lines = stdout.readlines()\n                assert len(lines) > 0\n                assert lines[-1].strip() == '42'\n\n    def test_setup_requires_honors_pip_env(self, mock_index, monkeypatch):\n        monkeypatch.setenv('PIP_RETRIES', '0')\n        monkeypatch.setenv('PIP_TIMEOUT', '0')\n        monkeypatch.setenv('PIP_NO_INDEX', 'false')\n        monkeypatch.setenv('PIP_INDEX_URL', mock_index.url)\n        with contexts.save_pkg_resources_state():\n            with contexts.tempdir() as temp_dir:\n                test_pkg = create_setup_requires_package(\n                    temp_dir,\n                    'python-xlib',\n                    '0.19',\n                    setup_attrs=dict(dependency_links=[]),\n                )\n                test_setup_cfg = os.path.join(test_pkg, 'setup.cfg')\n                with open(test_setup_cfg, 'w', encoding=\"utf-8\") as fp:\n                    fp.write(\n                        DALS(\n                            \"\"\"\n                        [easy_install]\n                        index_url = https://pypi.org/legacy/\n                        \"\"\"\n                        )\n                    )\n                test_setup_py = os.path.join(test_pkg, 'setup.py')\n                with pytest.raises(distutils.errors.DistutilsError):\n                    run_setup(test_setup_py, ['--version'])\n        assert len(mock_index.requests) == 1\n        assert mock_index.requests[0].path == '/python-xlib/'\n\n    def test_setup_requires_with_pep508_url(self, mock_index, monkeypatch):\n        monkeypatch.setenv('PIP_RETRIES', '0')\n        monkeypatch.setenv('PIP_TIMEOUT', '0')\n        monkeypatch.setenv('PIP_INDEX_URL', mock_index.url)\n        with contexts.save_pkg_resources_state():\n            with contexts.tempdir() as temp_dir:\n                dep_sdist = os.path.join(temp_dir, 'dep.tar.gz')\n                make_trivial_sdist(dep_sdist, 'dependency', '42')\n                dep_url = path_to_url(dep_sdist, authority='localhost')\n                test_pkg = create_setup_requires_package(\n                    temp_dir,\n                    # Ignored (overridden by setup_attrs)\n                    'python-xlib',\n                    '0.19',\n                    setup_attrs=dict(setup_requires=f'dependency @ {dep_url}'),\n                )\n                test_setup_py = os.path.join(test_pkg, 'setup.py')\n                run_setup(test_setup_py, ['--version'])\n        assert len(mock_index.requests) == 0\n\n    def test_setup_requires_with_allow_hosts(self, mock_index):\n        \"\"\"The `allow-hosts` option in not supported anymore.\"\"\"\n        files = {\n            'test_pkg': {\n                'setup.py': DALS(\n                    \"\"\"\n                    from setuptools import setup\n                    setup(setup_requires='python-xlib')\n                    \"\"\"\n                ),\n                'setup.cfg': DALS(\n                    \"\"\"\n                    [easy_install]\n                    allow_hosts = *\n                    \"\"\"\n                ),\n            }\n        }\n        with contexts.save_pkg_resources_state():\n            with contexts.tempdir() as temp_dir:\n                path.build(files, prefix=temp_dir)\n                setup_py = str(pathlib.Path(temp_dir, 'test_pkg', 'setup.py'))\n                with pytest.raises(distutils.errors.DistutilsError):\n                    run_setup(setup_py, ['--version'])\n        assert len(mock_index.requests) == 0\n\n    def test_setup_requires_with_python_requires(self, monkeypatch, tmpdir):\n        \"\"\"Check `python_requires` is honored.\"\"\"\n        monkeypatch.setenv('PIP_RETRIES', '0')\n        monkeypatch.setenv('PIP_TIMEOUT', '0')\n        monkeypatch.setenv('PIP_NO_INDEX', '1')\n        monkeypatch.setenv('PIP_VERBOSE', '1')\n        dep_1_0_sdist = 'dep-1.0.tar.gz'\n        dep_1_0_url = path_to_url(str(tmpdir / dep_1_0_sdist))\n        dep_1_0_python_requires = '>=2.7'\n        make_python_requires_sdist(\n            str(tmpdir / dep_1_0_sdist), 'dep', '1.0', dep_1_0_python_requires\n        )\n        dep_2_0_sdist = 'dep-2.0.tar.gz'\n        dep_2_0_url = path_to_url(str(tmpdir / dep_2_0_sdist))\n        dep_2_0_python_requires = (\n            f'!={sys.version_info.major}.{sys.version_info.minor}.*'\n        )\n        make_python_requires_sdist(\n            str(tmpdir / dep_2_0_sdist), 'dep', '2.0', dep_2_0_python_requires\n        )\n        index = tmpdir / 'index.html'\n        index.write_text(\n            DALS(\n                \"\"\"\n            <!DOCTYPE html>\n            <html><head><title>Links for dep</title></head>\n            <body>\n                <h1>Links for dep</h1>\n                <a href=\"{dep_1_0_url}\"\\\ndata-requires-python=\"{dep_1_0_python_requires}\">{dep_1_0_sdist}</a><br/>\n                <a href=\"{dep_2_0_url}\"\\\ndata-requires-python=\"{dep_2_0_python_requires}\">{dep_2_0_sdist}</a><br/>\n            </body>\n            </html>\n            \"\"\"\n            ).format(\n                dep_1_0_url=dep_1_0_url,\n                dep_1_0_sdist=dep_1_0_sdist,\n                dep_1_0_python_requires=dep_1_0_python_requires,\n                dep_2_0_url=dep_2_0_url,\n                dep_2_0_sdist=dep_2_0_sdist,\n                dep_2_0_python_requires=dep_2_0_python_requires,\n            ),\n            'utf-8',\n        )\n        index_url = path_to_url(str(index))\n        with contexts.save_pkg_resources_state():\n            test_pkg = create_setup_requires_package(\n                str(tmpdir),\n                'python-xlib',\n                '0.19',  # Ignored (overridden by setup_attrs).\n                setup_attrs=dict(setup_requires='dep', dependency_links=[index_url]),\n            )\n            test_setup_py = os.path.join(test_pkg, 'setup.py')\n            run_setup(test_setup_py, ['--version'])\n        eggs = list(\n            map(str, pkg_resources.find_distributions(os.path.join(test_pkg, '.eggs')))\n        )\n        assert eggs == ['dep 1.0']\n\n    @pytest.mark.parametrize('with_dependency_links_in_setup_py', (False, True))\n    def test_setup_requires_with_find_links_in_setup_cfg(\n        self, monkeypatch, with_dependency_links_in_setup_py\n    ):\n        monkeypatch.setenv('PIP_RETRIES', '0')\n        monkeypatch.setenv('PIP_TIMEOUT', '0')\n        with contexts.save_pkg_resources_state():\n            with contexts.tempdir() as temp_dir:\n                make_trivial_sdist(\n                    os.path.join(temp_dir, 'python-xlib-42.tar.gz'), 'python-xlib', '42'\n                )\n                test_pkg = os.path.join(temp_dir, 'test_pkg')\n                test_setup_py = os.path.join(test_pkg, 'setup.py')\n                test_setup_cfg = os.path.join(test_pkg, 'setup.cfg')\n                os.mkdir(test_pkg)\n                with open(test_setup_py, 'w', encoding=\"utf-8\") as fp:\n                    if with_dependency_links_in_setup_py:\n                        dependency_links = [os.path.join(temp_dir, 'links')]\n                    else:\n                        dependency_links = []\n                    fp.write(\n                        DALS(\n                            \"\"\"\n                        from setuptools import installer, setup\n                        setup(setup_requires='python-xlib==42',\n                        dependency_links={dependency_links!r})\n                        \"\"\"\n                        ).format(dependency_links=dependency_links)\n                    )\n                with open(test_setup_cfg, 'w', encoding=\"utf-8\") as fp:\n                    fp.write(\n                        DALS(\n                            \"\"\"\n                        [easy_install]\n                        index_url = {index_url}\n                        find_links = {find_links}\n                        \"\"\"\n                        ).format(\n                            index_url=os.path.join(temp_dir, 'index'),\n                            find_links=temp_dir,\n                        )\n                    )\n                run_setup(test_setup_py, ['--version'])\n\n    def test_setup_requires_with_transitive_extra_dependency(self, monkeypatch):\n        \"\"\"\n        Use case: installing a package with a build dependency on\n        an already installed `dep[extra]`, which in turn depends\n        on `extra_dep` (whose is not already installed).\n        \"\"\"\n        with contexts.save_pkg_resources_state():\n            with contexts.tempdir() as temp_dir:\n                # Create source distribution for `extra_dep`.\n                make_trivial_sdist(\n                    os.path.join(temp_dir, 'extra_dep-1.0.tar.gz'), 'extra_dep', '1.0'\n                )\n                # Create source tree for `dep`.\n                dep_pkg = os.path.join(temp_dir, 'dep')\n                os.mkdir(dep_pkg)\n                path.build(\n                    {\n                        'setup.py': DALS(\n                            \"\"\"\n                          import setuptools\n                          setuptools.setup(\n                              name='dep', version='2.0',\n                              extras_require={'extra': ['extra_dep']},\n                          )\n                         \"\"\"\n                        ),\n                        'setup.cfg': '',\n                    },\n                    prefix=dep_pkg,\n                )\n                # \"Install\" dep.\n                run_setup(os.path.join(dep_pkg, 'setup.py'), ['dist_info'])\n                working_set.add_entry(dep_pkg)\n                # Create source tree for test package.\n                test_pkg = os.path.join(temp_dir, 'test_pkg')\n                test_setup_py = os.path.join(test_pkg, 'setup.py')\n                os.mkdir(test_pkg)\n                with open(test_setup_py, 'w', encoding=\"utf-8\") as fp:\n                    fp.write(\n                        DALS(\n                            \"\"\"\n                        from setuptools import installer, setup\n                        setup(setup_requires='dep[extra]')\n                        \"\"\"\n                        )\n                    )\n                # Check...\n                monkeypatch.setenv('PIP_FIND_LINKS', str(temp_dir))\n                monkeypatch.setenv('PIP_NO_INDEX', '1')\n                monkeypatch.setenv('PIP_RETRIES', '0')\n                monkeypatch.setenv('PIP_TIMEOUT', '0')\n                run_setup(test_setup_py, ['--version'])\n\n    def test_setup_requires_with_distutils_command_dep(self, monkeypatch):\n        \"\"\"\n        Use case: ensure build requirements' extras\n        are properly installed and activated.\n        \"\"\"\n        with contexts.save_pkg_resources_state():\n            with contexts.tempdir() as temp_dir:\n                # Create source distribution for `extra_dep`.\n                make_sdist(\n                    os.path.join(temp_dir, 'extra_dep-1.0.tar.gz'),\n                    [\n                        (\n                            'setup.py',\n                            DALS(\n                                \"\"\"\n                          import setuptools\n                          setuptools.setup(\n                              name='extra_dep',\n                              version='1.0',\n                              py_modules=['extra_dep'],\n                          )\n                          \"\"\"\n                            ),\n                        ),\n                        ('setup.cfg', ''),\n                        ('extra_dep.py', ''),\n                    ],\n                )\n                # Create source tree for `epdep`.\n                dep_pkg = os.path.join(temp_dir, 'epdep')\n                os.mkdir(dep_pkg)\n                path.build(\n                    {\n                        'setup.py': DALS(\n                            \"\"\"\n                          import setuptools\n                          setuptools.setup(\n                              name='dep', version='2.0',\n                              py_modules=['epcmd'],\n                              extras_require={'extra': ['extra_dep']},\n                              entry_points='''\n                                           [distutils.commands]\n                                           epcmd = epcmd:epcmd [extra]\n                                           ''',\n                          )\n                         \"\"\"\n                        ),\n                        'setup.cfg': '',\n                        'epcmd.py': DALS(\n                            \"\"\"\n                                     from distutils.command.build_py import build_py\n\n                                     import extra_dep\n\n                                     class epcmd(build_py):\n                                         pass\n                                     \"\"\"\n                        ),\n                    },\n                    prefix=dep_pkg,\n                )\n                # \"Install\" dep.\n                run_setup(os.path.join(dep_pkg, 'setup.py'), ['dist_info'])\n                working_set.add_entry(dep_pkg)\n                # Create source tree for test package.\n                test_pkg = os.path.join(temp_dir, 'test_pkg')\n                test_setup_py = os.path.join(test_pkg, 'setup.py')\n                os.mkdir(test_pkg)\n                with open(test_setup_py, 'w', encoding=\"utf-8\") as fp:\n                    fp.write(\n                        DALS(\n                            \"\"\"\n                        from setuptools import installer, setup\n                        setup(setup_requires='dep[extra]')\n                        \"\"\"\n                        )\n                    )\n                # Check...\n                monkeypatch.setenv('PIP_FIND_LINKS', str(temp_dir))\n                monkeypatch.setenv('PIP_NO_INDEX', '1')\n                monkeypatch.setenv('PIP_RETRIES', '0')\n                monkeypatch.setenv('PIP_TIMEOUT', '0')\n                run_setup(test_setup_py, ['epcmd'])\n\n\ndef make_trivial_sdist(dist_path, distname, version):\n    \"\"\"\n    Create a simple sdist tarball at dist_path, containing just a simple\n    setup.py.\n    \"\"\"\n\n    make_sdist(\n        dist_path,\n        [\n            (\n                'setup.py',\n                DALS(\n                    f\"\"\"\\\n             import setuptools\n             setuptools.setup(\n                 name={distname!r},\n                 version={version!r}\n             )\n         \"\"\"\n                ),\n            ),\n            ('setup.cfg', ''),\n        ],\n    )\n\n\ndef make_nspkg_sdist(dist_path, distname, version):\n    \"\"\"\n    Make an sdist tarball with distname and version which also contains one\n    package with the same name as distname.  The top-level package is\n    designated a namespace package).\n    \"\"\"\n\n    parts = distname.split('.')\n    nspackage = parts[0]\n\n    packages = ['.'.join(parts[:idx]) for idx in range(1, len(parts) + 1)]\n\n    setup_py = DALS(\n        f\"\"\"\\\n        import setuptools\n        setuptools.setup(\n            name={distname!r},\n            version={version!r},\n            packages={packages!r},\n            namespace_packages=[{nspackage!r}]\n        )\n    \"\"\"\n    )\n\n    init = \"__import__('pkg_resources').declare_namespace(__name__)\"\n\n    files = [('setup.py', setup_py), (os.path.join(nspackage, '__init__.py'), init)]\n    for package in packages[1:]:\n        filename = os.path.join(*(package.split('.') + ['__init__.py']))\n        files.append((filename, ''))\n\n    make_sdist(dist_path, files)\n\n\ndef make_python_requires_sdist(dist_path, distname, version, python_requires):\n    make_sdist(\n        dist_path,\n        [\n            (\n                'setup.py',\n                DALS(\n                    \"\"\"\\\n                import setuptools\n                setuptools.setup(\n                  name={name!r},\n                  version={version!r},\n                  python_requires={python_requires!r},\n                )\n                \"\"\"\n                ).format(\n                    name=distname, version=version, python_requires=python_requires\n                ),\n            ),\n            ('setup.cfg', ''),\n        ],\n    )\n\n\ndef make_sdist(dist_path, files):\n    \"\"\"\n    Create a simple sdist tarball at dist_path, containing the files\n    listed in ``files`` as ``(filename, content)`` tuples.\n    \"\"\"\n\n    # Distributions with only one file don't play well with pip.\n    assert len(files) > 1\n    with tarfile.open(dist_path, 'w:gz') as dist:\n        for filename, content in files:\n            file_bytes = io.BytesIO(content.encode('utf-8'))\n            file_info = tarfile.TarInfo(name=filename)\n            file_info.size = len(file_bytes.getvalue())\n            file_info.mtime = int(time.time())\n            dist.addfile(file_info, fileobj=file_bytes)\n\n\ndef create_setup_requires_package(\n    path,\n    distname='foobar',\n    version='0.1',\n    make_package=make_trivial_sdist,\n    setup_py_template=None,\n    setup_attrs=None,\n    use_setup_cfg=(),\n):\n    \"\"\"Creates a source tree under path for a trivial test package that has a\n    single requirement in setup_requires--a tarball for that requirement is\n    also created and added to the dependency_links argument.\n\n    ``distname`` and ``version`` refer to the name/version of the package that\n    the test package requires via ``setup_requires``.  The name of the test\n    package itself is just 'test_pkg'.\n    \"\"\"\n\n    test_setup_attrs = {\n        'name': 'test_pkg',\n        'version': '0.0',\n        'setup_requires': [f'{distname}=={version}'],\n        'dependency_links': [os.path.abspath(path)],\n    }\n    if setup_attrs:\n        test_setup_attrs.update(setup_attrs)\n\n    test_pkg = os.path.join(path, 'test_pkg')\n    os.mkdir(test_pkg)\n\n    # setup.cfg\n    if use_setup_cfg:\n        options = []\n        metadata = []\n        for name in use_setup_cfg:\n            value = test_setup_attrs.pop(name)\n            if name in 'name version'.split():\n                section = metadata\n            else:\n                section = options\n            if isinstance(value, (tuple, list)):\n                value = ';'.join(value)\n            section.append(f'{name}: {value}')\n        test_setup_cfg_contents = DALS(\n            \"\"\"\n            [metadata]\n            {metadata}\n            [options]\n            {options}\n            \"\"\"\n        ).format(\n            options='\\n'.join(options),\n            metadata='\\n'.join(metadata),\n        )\n    else:\n        test_setup_cfg_contents = ''\n    with open(os.path.join(test_pkg, 'setup.cfg'), 'w', encoding=\"utf-8\") as f:\n        f.write(test_setup_cfg_contents)\n\n    # setup.py\n    if setup_py_template is None:\n        setup_py_template = DALS(\n            \"\"\"\\\n            import setuptools\n            setuptools.setup(**%r)\n        \"\"\"\n        )\n    with open(os.path.join(test_pkg, 'setup.py'), 'w', encoding=\"utf-8\") as f:\n        f.write(setup_py_template % test_setup_attrs)\n\n    foobar_path = os.path.join(path, f'{distname}-{version}.tar.gz')\n    make_package(foobar_path, distname, version)\n\n    return test_pkg\n\n\n@pytest.mark.skipif(\n    sys.platform.startswith('java') and ei.is_sh(sys.executable),\n    reason=\"Test cannot run under java when executable is sh\",\n)\nclass TestScriptHeader:\n    non_ascii_exe = '/Users/José/bin/python'\n    exe_with_spaces = r'C:\\Program Files\\Python36\\python.exe'\n\n    def test_get_script_header(self):\n        expected = f'#!{ei.nt_quote_arg(os.path.normpath(sys.executable))}\\n'\n        actual = ei.ScriptWriter.get_header('#!/usr/local/bin/python')\n        assert actual == expected\n\n    def test_get_script_header_args(self):\n        expected = f'#!{ei.nt_quote_arg(os.path.normpath(sys.executable))} -x\\n'\n        actual = ei.ScriptWriter.get_header('#!/usr/bin/python -x')\n        assert actual == expected\n\n    def test_get_script_header_non_ascii_exe(self):\n        actual = ei.ScriptWriter.get_header(\n            '#!/usr/bin/python', executable=self.non_ascii_exe\n        )\n        expected = f'#!{self.non_ascii_exe} -x\\n'\n        assert actual == expected\n\n    def test_get_script_header_exe_with_spaces(self):\n        actual = ei.ScriptWriter.get_header(\n            '#!/usr/bin/python', executable='\"' + self.exe_with_spaces + '\"'\n        )\n        expected = f'#!\"{self.exe_with_spaces}\"\\n'\n        assert actual == expected\n\n\nclass TestCommandSpec:\n    def test_custom_launch_command(self):\n        \"\"\"\n        Show how a custom CommandSpec could be used to specify a #! executable\n        which takes parameters.\n        \"\"\"\n        cmd = ei.CommandSpec(['/usr/bin/env', 'python3'])\n        assert cmd.as_header() == '#!/usr/bin/env python3\\n'\n\n    def test_from_param_for_CommandSpec_is_passthrough(self):\n        \"\"\"\n        from_param should return an instance of a CommandSpec\n        \"\"\"\n        cmd = ei.CommandSpec(['python'])\n        cmd_new = ei.CommandSpec.from_param(cmd)\n        assert cmd is cmd_new\n\n    @mock.patch('sys.executable', TestScriptHeader.exe_with_spaces)\n    @mock.patch.dict(os.environ)\n    def test_from_environment_with_spaces_in_executable(self):\n        os.environ.pop('__PYVENV_LAUNCHER__', None)\n        cmd = ei.CommandSpec.from_environment()\n        assert len(cmd) == 1\n        assert cmd.as_header().startswith('#!\"')\n\n    def test_from_simple_string_uses_shlex(self):\n        \"\"\"\n        In order to support `executable = /usr/bin/env my-python`, make sure\n        from_param invokes shlex on that input.\n        \"\"\"\n        cmd = ei.CommandSpec.from_param('/usr/bin/env my-python')\n        assert len(cmd) == 2\n        assert '\"' not in cmd.as_header()\n\n    def test_from_param_raises_expected_error(self) -> None:\n        \"\"\"\n        from_param should raise its own TypeError when the argument's type is unsupported\n        \"\"\"\n        with pytest.raises(TypeError) as exc_info:\n            ei.CommandSpec.from_param(object())  # type: ignore[arg-type] # We want a type error here\n        assert (\n            str(exc_info.value) == \"Argument has an unsupported type <class 'object'>\"\n        ), exc_info.value\n\n\nclass TestWindowsScriptWriter:\n    def test_header(self):\n        hdr = ei.WindowsScriptWriter.get_header('')\n        assert hdr.startswith('#!')\n        assert hdr.endswith('\\n')\n        hdr = hdr.lstrip('#!')\n        hdr = hdr.rstrip('\\n')\n        # header should not start with an escaped quote\n        assert not hdr.startswith('\\\\\"')\n\n\nclass VersionStub(NamedTuple):\n    major: int\n    minor: int\n    micro: int\n    releaselevel: str\n    serial: int\n\n\ndef test_use_correct_python_version_string(tmpdir, tmpdir_cwd, monkeypatch):\n    # In issue #3001, easy_install wrongly uses the `python3.1` directory\n    # when the interpreter is `python3.10` and the `--user` option is given.\n    # See pypa/setuptools#3001.\n    dist = Distribution()\n    cmd = dist.get_command_obj('easy_install')\n    cmd.args = ['ok']\n    cmd.optimize = 0\n    cmd.user = True\n    cmd.install_userbase = str(tmpdir)\n    cmd.install_usersite = None\n    install_cmd = dist.get_command_obj('install')\n    install_cmd.install_userbase = str(tmpdir)\n    install_cmd.install_usersite = None\n\n    with monkeypatch.context() as patch, warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        version = '3.10.1 (main, Dec 21 2021, 09:17:12) [GCC 10.2.1 20210110]'\n        info = VersionStub(3, 10, 1, \"final\", 0)\n        patch.setattr('site.ENABLE_USER_SITE', True)\n        patch.setattr('sys.version', version)\n        patch.setattr('sys.version_info', info)\n        patch.setattr(cmd, 'create_home_path', mock.Mock())\n        cmd.finalize_options()\n\n    name = \"pypy\" if hasattr(sys, 'pypy_version_info') else \"python\"\n    install_dir = cmd.install_dir.lower()\n\n    # In some platforms (e.g. Windows), install_dir is mostly determined\n    # via `sysconfig`, which define constants eagerly at module creation.\n    # This means that monkeypatching `sys.version` to emulate 3.10 for testing\n    # may have no effect.\n    # The safest test here is to rely on the fact that 3.1 is no longer\n    # supported/tested, and make sure that if 'python3.1' ever appears in the string\n    # it is followed by another digit (e.g. 'python3.10').\n    if re.search(name + r'3\\.?1', install_dir):\n        assert re.search(name + r'3\\.?1\\d', install_dir)\n\n    # The following \"variables\" are used for interpolation in distutils\n    # installation schemes, so it should be fair to treat them as \"semi-public\",\n    # or at least public enough so we can have a test to make sure they are correct\n    assert cmd.config_vars['py_version'] == '3.10.1'\n    assert cmd.config_vars['py_version_short'] == '3.10'\n    assert cmd.config_vars['py_version_nodot'] == '310'\n\n\n@pytest.mark.xfail(\n    sys.platform == \"darwin\",\n    reason=\"https://github.com/pypa/setuptools/pull/4716#issuecomment-2447624418\",\n)\ndef test_editable_user_and_build_isolation(setup_context, monkeypatch, tmp_path):\n    \"\"\"`setup.py develop` should honor `--user` even under build isolation\"\"\"\n\n    # == Arrange ==\n    # Pretend that build isolation was enabled\n    # e.g pip sets the environment variable PYTHONNOUSERSITE=1\n    monkeypatch.setattr('site.ENABLE_USER_SITE', False)\n\n    # Patching $HOME for 2 reasons:\n    # 1. setuptools/command/easy_install.py:create_home_path\n    #    tries creating directories in $HOME.\n    #    Given::\n    #        self.config_vars['DESTDIRS'] = (\n    #            \"/home/user/.pyenv/versions/3.9.10 \"\n    #            \"/home/user/.pyenv/versions/3.9.10/lib \"\n    #            \"/home/user/.pyenv/versions/3.9.10/lib/python3.9 \"\n    #            \"/home/user/.pyenv/versions/3.9.10/lib/python3.9/lib-dynload\")\n    #    `create_home_path` will::\n    #        makedirs(\n    #            \"/home/user/.pyenv/versions/3.9.10 \"\n    #            \"/home/user/.pyenv/versions/3.9.10/lib \"\n    #            \"/home/user/.pyenv/versions/3.9.10/lib/python3.9 \"\n    #            \"/home/user/.pyenv/versions/3.9.10/lib/python3.9/lib-dynload\")\n    #\n    # 2. We are going to force `site` to update site.USER_BASE and site.USER_SITE\n    #    To point inside our new home\n    monkeypatch.setenv('HOME', str(tmp_path / '.home'))\n    monkeypatch.setenv('USERPROFILE', str(tmp_path / '.home'))\n    monkeypatch.setenv('APPDATA', str(tmp_path / '.home'))\n    monkeypatch.setattr('site.USER_BASE', None)\n    monkeypatch.setattr('site.USER_SITE', None)\n    user_site = Path(site.getusersitepackages())\n    user_site.mkdir(parents=True, exist_ok=True)\n\n    sys_prefix = tmp_path / '.sys_prefix'\n    sys_prefix.mkdir(parents=True, exist_ok=True)\n    monkeypatch.setattr('sys.prefix', str(sys_prefix))\n\n    setup_script = (\n        \"__import__('setuptools').setup(name='aproj', version=42, packages=[])\\n\"\n    )\n    (tmp_path / \"setup.py\").write_text(setup_script, encoding=\"utf-8\")\n\n    # == Sanity check ==\n    assert list(sys_prefix.glob(\"*\")) == []\n    assert list(user_site.glob(\"*\")) == []\n\n    # == Act ==\n    run_setup('setup.py', ['develop', '--user'])\n\n    # == Assert ==\n    # Should not install to sys.prefix\n    assert list(sys_prefix.glob(\"*\")) == []\n    # Should install to user site\n    installed = {f.name for f in user_site.glob(\"*\")}\n    # sometimes easy-install.pth is created and sometimes not\n    installed = installed - {\"easy-install.pth\"}\n    assert installed == {'aproj.egg-link'}\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_editable_install.py","size":43383,"sha1":"936e5121eee7cc4fa66accbd8674e584b02ee664","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport os\nimport platform\nimport stat\nimport subprocess\nimport sys\nfrom copy import deepcopy\nfrom importlib import import_module\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom pathlib import Path\nfrom textwrap import dedent\nfrom typing import Any\nfrom unittest.mock import Mock\nfrom uuid import uuid4\n\nimport jaraco.envs\nimport jaraco.path\nimport pytest\nfrom path import Path as _Path\n\nfrom setuptools._importlib import resources as importlib_resources\nfrom setuptools.command.editable_wheel import (\n    _DebuggingTips,\n    _encode_pth,\n    _find_namespaces,\n    _find_package_roots,\n    _find_virtual_namespaces,\n    _finder_template,\n    _LinkTree,\n    _TopLevelFinder,\n    editable_wheel,\n)\nfrom setuptools.dist import Distribution\nfrom setuptools.extension import Extension\nfrom setuptools.warnings import SetuptoolsDeprecationWarning\n\nfrom . import contexts, namespaces\n\nfrom distutils.core import run_setup\n\n\n@pytest.fixture(params=[\"strict\", \"lenient\"])\ndef editable_opts(request):\n    if request.param == \"strict\":\n        return [\"--config-settings\", \"editable-mode=strict\"]\n    return []\n\n\nEXAMPLE = {\n    'pyproject.toml': dedent(\n        \"\"\"\\\n        [build-system]\n        requires = [\"setuptools\"]\n        build-backend = \"setuptools.build_meta\"\n\n        [project]\n        name = \"mypkg\"\n        version = \"3.14159\"\n        license = {text = \"MIT\"}\n        description = \"This is a Python package\"\n        dynamic = [\"readme\"]\n        classifiers = [\n            \"Development Status :: 5 - Production/Stable\",\n            \"Intended Audience :: Developers\"\n        ]\n        urls = {Homepage = \"https://github.com\"}\n\n        [tool.setuptools]\n        package-dir = {\"\" = \"src\"}\n        packages = {find = {where = [\"src\"]}}\n        license-files = [\"LICENSE*\"]\n\n        [tool.setuptools.dynamic]\n        readme = {file = \"README.rst\"}\n\n        [tool.distutils.egg_info]\n        tag-build = \".post0\"\n        \"\"\"\n    ),\n    \"MANIFEST.in\": dedent(\n        \"\"\"\\\n        global-include *.py *.txt\n        global-exclude *.py[cod]\n        prune dist\n        prune build\n        \"\"\"\n    ).strip(),\n    \"README.rst\": \"This is a ``README``\",\n    \"LICENSE.txt\": \"---- placeholder MIT license ----\",\n    \"src\": {\n        \"mypkg\": {\n            \"__init__.py\": dedent(\n                \"\"\"\\\n                import sys\n                from importlib.metadata import PackageNotFoundError, version\n\n                try:\n                    __version__ = version(__name__)\n                except PackageNotFoundError:\n                    __version__ = \"unknown\"\n                \"\"\"\n            ),\n            \"__main__.py\": dedent(\n                \"\"\"\\\n                from importlib.resources import read_text\n                from . import __version__, __name__ as parent\n                from .mod import x\n\n                data = read_text(parent, \"data.txt\")\n                print(__version__, data, x)\n                \"\"\"\n            ),\n            \"mod.py\": \"x = ''\",\n            \"data.txt\": \"Hello World\",\n        }\n    },\n}\n\n\nSETUP_SCRIPT_STUB = \"__import__('setuptools').setup()\"\n\n\n@pytest.mark.xfail(sys.platform == \"darwin\", reason=\"pypa/setuptools#4328\")\n@pytest.mark.parametrize(\n    \"files\",\n    [\n        {**EXAMPLE, \"setup.py\": SETUP_SCRIPT_STUB},\n        EXAMPLE,  # No setup.py script\n    ],\n)\ndef test_editable_with_pyproject(tmp_path, venv, files, editable_opts):\n    project = tmp_path / \"mypkg\"\n    project.mkdir()\n    jaraco.path.build(files, prefix=project)\n\n    cmd = [\n        \"python\",\n        \"-m\",\n        \"pip\",\n        \"install\",\n        \"--no-build-isolation\",  # required to force current version of setuptools\n        \"-e\",\n        str(project),\n        *editable_opts,\n    ]\n    print(venv.run(cmd))\n\n    cmd = [\"python\", \"-m\", \"mypkg\"]\n    assert venv.run(cmd).strip() == \"3.14159.post0 Hello World\"\n\n    (project / \"src/mypkg/data.txt\").write_text(\"foobar\", encoding=\"utf-8\")\n    (project / \"src/mypkg/mod.py\").write_text(\"x = 42\", encoding=\"utf-8\")\n    assert venv.run(cmd).strip() == \"3.14159.post0 foobar 42\"\n\n\ndef test_editable_with_flat_layout(tmp_path, venv, editable_opts):\n    files = {\n        \"mypkg\": {\n            \"pyproject.toml\": dedent(\n                \"\"\"\\\n                [build-system]\n                requires = [\"setuptools\", \"wheel\"]\n                build-backend = \"setuptools.build_meta\"\n\n                [project]\n                name = \"mypkg\"\n                version = \"3.14159\"\n\n                [tool.setuptools]\n                packages = [\"pkg\"]\n                py-modules = [\"mod\"]\n                \"\"\"\n            ),\n            \"pkg\": {\"__init__.py\": \"a = 4\"},\n            \"mod.py\": \"b = 2\",\n        },\n    }\n    jaraco.path.build(files, prefix=tmp_path)\n    project = tmp_path / \"mypkg\"\n\n    cmd = [\n        \"python\",\n        \"-m\",\n        \"pip\",\n        \"install\",\n        \"--no-build-isolation\",  # required to force current version of setuptools\n        \"-e\",\n        str(project),\n        *editable_opts,\n    ]\n    print(venv.run(cmd))\n    cmd = [\"python\", \"-c\", \"import pkg, mod; print(pkg.a, mod.b)\"]\n    assert venv.run(cmd).strip() == \"4 2\"\n\n\ndef test_editable_with_single_module(tmp_path, venv, editable_opts):\n    files = {\n        \"mypkg\": {\n            \"pyproject.toml\": dedent(\n                \"\"\"\\\n                [build-system]\n                requires = [\"setuptools\", \"wheel\"]\n                build-backend = \"setuptools.build_meta\"\n\n                [project]\n                name = \"mod\"\n                version = \"3.14159\"\n\n                [tool.setuptools]\n                py-modules = [\"mod\"]\n                \"\"\"\n            ),\n            \"mod.py\": \"b = 2\",\n        },\n    }\n    jaraco.path.build(files, prefix=tmp_path)\n    project = tmp_path / \"mypkg\"\n\n    cmd = [\n        \"python\",\n        \"-m\",\n        \"pip\",\n        \"install\",\n        \"--no-build-isolation\",  # required to force current version of setuptools\n        \"-e\",\n        str(project),\n        *editable_opts,\n    ]\n    print(venv.run(cmd))\n    cmd = [\"python\", \"-c\", \"import mod; print(mod.b)\"]\n    assert venv.run(cmd).strip() == \"2\"\n\n\nclass TestLegacyNamespaces:\n    # legacy => pkg_resources.declare_namespace(...) + setup(namespace_packages=...)\n\n    def test_nspkg_file_is_unique(self, tmp_path, monkeypatch):\n        deprecation = pytest.warns(\n            SetuptoolsDeprecationWarning, match=\".*namespace_packages parameter.*\"\n        )\n        installation_dir = tmp_path / \".installation_dir\"\n        installation_dir.mkdir()\n        examples = (\n            \"myns.pkgA\",\n            \"myns.pkgB\",\n            \"myns.n.pkgA\",\n            \"myns.n.pkgB\",\n        )\n\n        for name in examples:\n            pkg = namespaces.build_namespace_package(tmp_path, name, version=\"42\")\n            with deprecation, monkeypatch.context() as ctx:\n                ctx.chdir(pkg)\n                dist = run_setup(\"setup.py\", stop_after=\"config\")\n                cmd = editable_wheel(dist)\n                cmd.finalize_options()\n                editable_name = cmd.get_finalized_command(\"dist_info\").name\n                cmd._install_namespaces(installation_dir, editable_name)\n\n        files = list(installation_dir.glob(\"*-nspkg.pth\"))\n        assert len(files) == len(examples)\n\n    @pytest.mark.parametrize(\n        \"impl\",\n        (\n            \"pkg_resources\",\n            #  \"pkgutil\",  => does not work\n        ),\n    )\n    @pytest.mark.parametrize(\"ns\", (\"myns.n\",))\n    def test_namespace_package_importable(\n        self, venv, tmp_path, ns, impl, editable_opts\n    ):\n        \"\"\"\n        Installing two packages sharing the same namespace, one installed\n        naturally using pip or `--single-version-externally-managed`\n        and the other installed in editable mode should leave the namespace\n        intact and both packages reachable by import.\n        (Ported from test_develop).\n        \"\"\"\n        build_system = \"\"\"\\\n        [build-system]\n        requires = [\"setuptools\"]\n        build-backend = \"setuptools.build_meta\"\n        \"\"\"\n        pkg_A = namespaces.build_namespace_package(tmp_path, f\"{ns}.pkgA\", impl=impl)\n        pkg_B = namespaces.build_namespace_package(tmp_path, f\"{ns}.pkgB\", impl=impl)\n        (pkg_A / \"pyproject.toml\").write_text(build_system, encoding=\"utf-8\")\n        (pkg_B / \"pyproject.toml\").write_text(build_system, encoding=\"utf-8\")\n        # use pip to install to the target directory\n        opts = editable_opts[:]\n        opts.append(\"--no-build-isolation\")  # force current version of setuptools\n        venv.run([\"python\", \"-m\", \"pip\", \"install\", str(pkg_A), *opts])\n        venv.run([\"python\", \"-m\", \"pip\", \"install\", \"-e\", str(pkg_B), *opts])\n        venv.run([\"python\", \"-c\", f\"import {ns}.pkgA; import {ns}.pkgB\"])\n        # additionally ensure that pkg_resources import works\n        venv.run([\"python\", \"-c\", \"import pkg_resources\"])\n\n\nclass TestPep420Namespaces:\n    def test_namespace_package_importable(self, venv, tmp_path, editable_opts):\n        \"\"\"\n        Installing two packages sharing the same namespace, one installed\n        normally using pip and the other installed in editable mode\n        should allow importing both packages.\n        \"\"\"\n        pkg_A = namespaces.build_pep420_namespace_package(tmp_path, 'myns.n.pkgA')\n        pkg_B = namespaces.build_pep420_namespace_package(tmp_path, 'myns.n.pkgB')\n        # use pip to install to the target directory\n        opts = editable_opts[:]\n        opts.append(\"--no-build-isolation\")  # force current version of setuptools\n        venv.run([\"python\", \"-m\", \"pip\", \"install\", str(pkg_A), *opts])\n        venv.run([\"python\", \"-m\", \"pip\", \"install\", \"-e\", str(pkg_B), *opts])\n        venv.run([\"python\", \"-c\", \"import myns.n.pkgA; import myns.n.pkgB\"])\n\n    def test_namespace_created_via_package_dir(self, venv, tmp_path, editable_opts):\n        \"\"\"Currently users can create a namespace by tweaking `package_dir`\"\"\"\n        files = {\n            \"pkgA\": {\n                \"pyproject.toml\": dedent(\n                    \"\"\"\\\n                    [build-system]\n                    requires = [\"setuptools\", \"wheel\"]\n                    build-backend = \"setuptools.build_meta\"\n\n                    [project]\n                    name = \"pkgA\"\n                    version = \"3.14159\"\n\n                    [tool.setuptools]\n                    package-dir = {\"myns.n.pkgA\" = \"src\"}\n                    \"\"\"\n                ),\n                \"src\": {\"__init__.py\": \"a = 1\"},\n            },\n        }\n        jaraco.path.build(files, prefix=tmp_path)\n        pkg_A = tmp_path / \"pkgA\"\n        pkg_B = namespaces.build_pep420_namespace_package(tmp_path, 'myns.n.pkgB')\n        pkg_C = namespaces.build_pep420_namespace_package(tmp_path, 'myns.n.pkgC')\n\n        # use pip to install to the target directory\n        opts = editable_opts[:]\n        opts.append(\"--no-build-isolation\")  # force current version of setuptools\n        venv.run([\"python\", \"-m\", \"pip\", \"install\", str(pkg_A), *opts])\n        venv.run([\"python\", \"-m\", \"pip\", \"install\", \"-e\", str(pkg_B), *opts])\n        venv.run([\"python\", \"-m\", \"pip\", \"install\", \"-e\", str(pkg_C), *opts])\n        venv.run([\"python\", \"-c\", \"from myns.n import pkgA, pkgB, pkgC\"])\n\n    def test_namespace_accidental_config_in_lenient_mode(self, venv, tmp_path):\n        \"\"\"Sometimes users might specify an ``include`` pattern that ignores parent\n        packages. In a normal installation this would ignore all modules inside the\n        parent packages, and make them namespaces (reported in issue #3504),\n        so the editable mode should preserve this behaviour.\n        \"\"\"\n        files = {\n            \"pkgA\": {\n                \"pyproject.toml\": dedent(\n                    \"\"\"\\\n                    [build-system]\n                    requires = [\"setuptools\", \"wheel\"]\n                    build-backend = \"setuptools.build_meta\"\n\n                    [project]\n                    name = \"pkgA\"\n                    version = \"3.14159\"\n\n                    [tool.setuptools]\n                    packages.find.include = [\"mypkg.*\"]\n                    \"\"\"\n                ),\n                \"mypkg\": {\n                    \"__init__.py\": \"\",\n                    \"other.py\": \"b = 1\",\n                    \"n\": {\n                        \"__init__.py\": \"\",\n                        \"pkgA.py\": \"a = 1\",\n                    },\n                },\n                \"MANIFEST.in\": EXAMPLE[\"MANIFEST.in\"],\n            },\n        }\n        jaraco.path.build(files, prefix=tmp_path)\n        pkg_A = tmp_path / \"pkgA\"\n\n        # use pip to install to the target directory\n        opts = [\"--no-build-isolation\"]  # force current version of setuptools\n        venv.run([\"python\", \"-m\", \"pip\", \"-v\", \"install\", \"-e\", str(pkg_A), *opts])\n        out = venv.run([\"python\", \"-c\", \"from mypkg.n import pkgA; print(pkgA.a)\"])\n        assert out.strip() == \"1\"\n        cmd = \"\"\"\\\n        try:\n            import mypkg.other\n        except ImportError:\n            print(\"mypkg.other not defined\")\n        \"\"\"\n        out = venv.run([\"python\", \"-c\", dedent(cmd)])\n        assert \"mypkg.other not defined\" in out\n\n\ndef test_editable_with_prefix(tmp_path, sample_project, editable_opts):\n    \"\"\"\n    Editable install to a prefix should be discoverable.\n    \"\"\"\n    prefix = tmp_path / 'prefix'\n\n    # figure out where pip will likely install the package\n    site_packages_all = [\n        prefix / Path(path).relative_to(sys.prefix)\n        for path in sys.path\n        if 'site-packages' in path and path.startswith(sys.prefix)\n    ]\n\n    for sp in site_packages_all:\n        sp.mkdir(parents=True)\n\n    # install workaround\n    _addsitedirs(site_packages_all)\n\n    env = dict(os.environ, PYTHONPATH=os.pathsep.join(map(str, site_packages_all)))\n    cmd = [\n        sys.executable,\n        '-m',\n        'pip',\n        'install',\n        '--editable',\n        str(sample_project),\n        '--prefix',\n        str(prefix),\n        '--no-build-isolation',\n        *editable_opts,\n    ]\n    subprocess.check_call(cmd, env=env)\n\n    # now run 'sample' with the prefix on the PYTHONPATH\n    bin = 'Scripts' if platform.system() == 'Windows' else 'bin'\n    exe = prefix / bin / 'sample'\n    subprocess.check_call([exe], env=env)\n\n\nclass TestFinderTemplate:\n    \"\"\"This test focus in getting a particular implementation detail right.\n    If at some point in time the implementation is changed for something different,\n    this test can be modified or even excluded.\n    \"\"\"\n\n    def install_finder(self, finder):\n        loc = {}\n        exec(finder, loc, loc)\n        loc[\"install\"]()\n\n    def test_packages(self, tmp_path):\n        files = {\n            \"src1\": {\n                \"pkg1\": {\n                    \"__init__.py\": \"\",\n                    \"subpkg\": {\"mod1.py\": \"a = 42\"},\n                },\n            },\n            \"src2\": {\"mod2.py\": \"a = 43\"},\n        }\n        jaraco.path.build(files, prefix=tmp_path)\n\n        mapping = {\n            \"pkg1\": str(tmp_path / \"src1/pkg1\"),\n            \"mod2\": str(tmp_path / \"src2/mod2\"),\n        }\n        template = _finder_template(str(uuid4()), mapping, {})\n\n        with contexts.save_paths(), contexts.save_sys_modules():\n            for mod in (\"pkg1\", \"pkg1.subpkg\", \"pkg1.subpkg.mod1\", \"mod2\"):\n                sys.modules.pop(mod, None)\n\n            self.install_finder(template)\n            mod1 = import_module(\"pkg1.subpkg.mod1\")\n            mod2 = import_module(\"mod2\")\n            subpkg = import_module(\"pkg1.subpkg\")\n\n            assert mod1.a == 42\n            assert mod2.a == 43\n            expected = str((tmp_path / \"src1/pkg1/subpkg\").resolve())\n            assert_path(subpkg, expected)\n\n    def test_namespace(self, tmp_path):\n        files = {\"pkg\": {\"__init__.py\": \"a = 13\", \"text.txt\": \"abc\"}}\n        jaraco.path.build(files, prefix=tmp_path)\n\n        mapping = {\"ns.othername\": str(tmp_path / \"pkg\")}\n        namespaces = {\"ns\": []}\n\n        template = _finder_template(str(uuid4()), mapping, namespaces)\n        with contexts.save_paths(), contexts.save_sys_modules():\n            for mod in (\"ns\", \"ns.othername\"):\n                sys.modules.pop(mod, None)\n\n            self.install_finder(template)\n            pkg = import_module(\"ns.othername\")\n            text = importlib_resources.files(pkg) / \"text.txt\"\n\n            expected = str((tmp_path / \"pkg\").resolve())\n            assert_path(pkg, expected)\n            assert pkg.a == 13\n\n            # Make sure resources can also be found\n            assert text.read_text(encoding=\"utf-8\") == \"abc\"\n\n    def test_combine_namespaces(self, tmp_path):\n        files = {\n            \"src1\": {\"ns\": {\"pkg1\": {\"__init__.py\": \"a = 13\"}}},\n            \"src2\": {\"ns\": {\"mod2.py\": \"b = 37\"}},\n        }\n        jaraco.path.build(files, prefix=tmp_path)\n\n        mapping = {\n            \"ns.pkgA\": str(tmp_path / \"src1/ns/pkg1\"),\n            \"ns\": str(tmp_path / \"src2/ns\"),\n        }\n        namespaces_ = {\"ns\": [str(tmp_path / \"src1\"), str(tmp_path / \"src2\")]}\n        template = _finder_template(str(uuid4()), mapping, namespaces_)\n\n        with contexts.save_paths(), contexts.save_sys_modules():\n            for mod in (\"ns\", \"ns.pkgA\", \"ns.mod2\"):\n                sys.modules.pop(mod, None)\n\n            self.install_finder(template)\n            pkgA = import_module(\"ns.pkgA\")\n            mod2 = import_module(\"ns.mod2\")\n\n            expected = str((tmp_path / \"src1/ns/pkg1\").resolve())\n            assert_path(pkgA, expected)\n            assert pkgA.a == 13\n            assert mod2.b == 37\n\n    def test_combine_namespaces_nested(self, tmp_path):\n        \"\"\"\n        Users may attempt to combine namespace packages in a nested way via\n        ``package_dir`` as shown in pypa/setuptools#4248.\n        \"\"\"\n\n        files = {\n            \"src\": {\"my_package\": {\"my_module.py\": \"a = 13\"}},\n            \"src2\": {\"my_package2\": {\"my_module2.py\": \"b = 37\"}},\n        }\n\n        stack = jaraco.path.DirectoryStack()\n        with stack.context(tmp_path):\n            jaraco.path.build(files)\n            attrs = {\n                \"script_name\": \"%PEP 517%\",\n                \"package_dir\": {\n                    \"different_name\": \"src/my_package\",\n                    \"different_name.subpkg\": \"src2/my_package2\",\n                },\n                \"packages\": [\"different_name\", \"different_name.subpkg\"],\n            }\n            dist = Distribution(attrs)\n            finder = _TopLevelFinder(dist, str(uuid4()))\n            code = next(v for k, v in finder.get_implementation() if k.endswith(\".py\"))\n\n        with contexts.save_paths(), contexts.save_sys_modules():\n            for mod in attrs[\"packages\"]:\n                sys.modules.pop(mod, None)\n\n            self.install_finder(code)\n            mod1 = import_module(\"different_name.my_module\")\n            mod2 = import_module(\"different_name.subpkg.my_module2\")\n\n            expected = str((tmp_path / \"src/my_package/my_module.py\").resolve())\n            assert str(Path(mod1.__file__).resolve()) == expected\n\n            expected = str((tmp_path / \"src2/my_package2/my_module2.py\").resolve())\n            assert str(Path(mod2.__file__).resolve()) == expected\n\n            assert mod1.a == 13\n            assert mod2.b == 37\n\n    def test_dynamic_path_computation(self, tmp_path):\n        # Follows the example in PEP 420\n        files = {\n            \"project1\": {\"parent\": {\"child\": {\"one.py\": \"x = 1\"}}},\n            \"project2\": {\"parent\": {\"child\": {\"two.py\": \"x = 2\"}}},\n            \"project3\": {\"parent\": {\"child\": {\"three.py\": \"x = 3\"}}},\n        }\n        jaraco.path.build(files, prefix=tmp_path)\n        mapping = {}\n        namespaces_ = {\"parent\": [str(tmp_path / \"project1/parent\")]}\n        template = _finder_template(str(uuid4()), mapping, namespaces_)\n\n        mods = (f\"parent.child.{name}\" for name in (\"one\", \"two\", \"three\"))\n        with contexts.save_paths(), contexts.save_sys_modules():\n            for mod in (\"parent\", \"parent.child\", \"parent.child\", *mods):\n                sys.modules.pop(mod, None)\n\n            self.install_finder(template)\n\n            one = import_module(\"parent.child.one\")\n            assert one.x == 1\n\n            with pytest.raises(ImportError):\n                import_module(\"parent.child.two\")\n\n            sys.path.append(str(tmp_path / \"project2\"))\n            two = import_module(\"parent.child.two\")\n            assert two.x == 2\n\n            with pytest.raises(ImportError):\n                import_module(\"parent.child.three\")\n\n            sys.path.append(str(tmp_path / \"project3\"))\n            three = import_module(\"parent.child.three\")\n            assert three.x == 3\n\n    def test_no_recursion(self, tmp_path):\n        # See issue #3550\n        files = {\n            \"pkg\": {\n                \"__init__.py\": \"from . import pkg\",\n            },\n        }\n        jaraco.path.build(files, prefix=tmp_path)\n\n        mapping = {\n            \"pkg\": str(tmp_path / \"pkg\"),\n        }\n        template = _finder_template(str(uuid4()), mapping, {})\n\n        with contexts.save_paths(), contexts.save_sys_modules():\n            sys.modules.pop(\"pkg\", None)\n\n            self.install_finder(template)\n            with pytest.raises(ImportError, match=\"pkg\"):\n                import_module(\"pkg\")\n\n    def test_similar_name(self, tmp_path):\n        files = {\n            \"foo\": {\n                \"__init__.py\": \"\",\n                \"bar\": {\n                    \"__init__.py\": \"\",\n                },\n            },\n        }\n        jaraco.path.build(files, prefix=tmp_path)\n\n        mapping = {\n            \"foo\": str(tmp_path / \"foo\"),\n        }\n        template = _finder_template(str(uuid4()), mapping, {})\n\n        with contexts.save_paths(), contexts.save_sys_modules():\n            sys.modules.pop(\"foo\", None)\n            sys.modules.pop(\"foo.bar\", None)\n\n            self.install_finder(template)\n            with pytest.raises(ImportError, match=\"foobar\"):\n                import_module(\"foobar\")\n\n    def test_case_sensitivity(self, tmp_path):\n        files = {\n            \"foo\": {\n                \"__init__.py\": \"\",\n                \"lowercase.py\": \"x = 1\",\n                \"bar\": {\n                    \"__init__.py\": \"\",\n                    \"lowercase.py\": \"x = 2\",\n                },\n            },\n        }\n        jaraco.path.build(files, prefix=tmp_path)\n        mapping = {\n            \"foo\": str(tmp_path / \"foo\"),\n        }\n        template = _finder_template(str(uuid4()), mapping, {})\n        with contexts.save_paths(), contexts.save_sys_modules():\n            sys.modules.pop(\"foo\", None)\n\n            self.install_finder(template)\n            with pytest.raises(ImportError, match=\"'FOO'\"):\n                import_module(\"FOO\")\n\n            with pytest.raises(ImportError, match=\"'foo\\\\.LOWERCASE'\"):\n                import_module(\"foo.LOWERCASE\")\n\n            with pytest.raises(ImportError, match=\"'foo\\\\.bar\\\\.Lowercase'\"):\n                import_module(\"foo.bar.Lowercase\")\n\n            with pytest.raises(ImportError, match=\"'foo\\\\.BAR'\"):\n                import_module(\"foo.BAR.lowercase\")\n\n            with pytest.raises(ImportError, match=\"'FOO'\"):\n                import_module(\"FOO.bar.lowercase\")\n\n            mod = import_module(\"foo.lowercase\")\n            assert mod.x == 1\n\n            mod = import_module(\"foo.bar.lowercase\")\n            assert mod.x == 2\n\n    def test_namespace_case_sensitivity(self, tmp_path):\n        files = {\n            \"pkg\": {\n                \"__init__.py\": \"a = 13\",\n                \"foo\": {\n                    \"__init__.py\": \"b = 37\",\n                    \"bar.py\": \"c = 42\",\n                },\n            },\n        }\n        jaraco.path.build(files, prefix=tmp_path)\n\n        mapping = {\"ns.othername\": str(tmp_path / \"pkg\")}\n        namespaces = {\"ns\": []}\n\n        template = _finder_template(str(uuid4()), mapping, namespaces)\n        with contexts.save_paths(), contexts.save_sys_modules():\n            for mod in (\"ns\", \"ns.othername\"):\n                sys.modules.pop(mod, None)\n\n            self.install_finder(template)\n            pkg = import_module(\"ns.othername\")\n            expected = str((tmp_path / \"pkg\").resolve())\n            assert_path(pkg, expected)\n            assert pkg.a == 13\n\n            foo = import_module(\"ns.othername.foo\")\n            assert foo.b == 37\n\n            bar = import_module(\"ns.othername.foo.bar\")\n            assert bar.c == 42\n\n            with pytest.raises(ImportError, match=\"'NS'\"):\n                import_module(\"NS.othername.foo\")\n\n            with pytest.raises(ImportError, match=\"'ns\\\\.othername\\\\.FOO\\\\'\"):\n                import_module(\"ns.othername.FOO\")\n\n            with pytest.raises(ImportError, match=\"'ns\\\\.othername\\\\.foo\\\\.BAR\\\\'\"):\n                import_module(\"ns.othername.foo.BAR\")\n\n    def test_intermediate_packages(self, tmp_path):\n        \"\"\"\n        The finder should not import ``fullname`` if the intermediate segments\n        don't exist (see pypa/setuptools#4019).\n        \"\"\"\n        files = {\n            \"src\": {\n                \"mypkg\": {\n                    \"__init__.py\": \"\",\n                    \"config.py\": \"a = 13\",\n                    \"helloworld.py\": \"b = 13\",\n                    \"components\": {\n                        \"config.py\": \"a = 37\",\n                    },\n                },\n            }\n        }\n        jaraco.path.build(files, prefix=tmp_path)\n\n        mapping = {\"mypkg\": str(tmp_path / \"src/mypkg\")}\n        template = _finder_template(str(uuid4()), mapping, {})\n\n        with contexts.save_paths(), contexts.save_sys_modules():\n            for mod in (\n                \"mypkg\",\n                \"mypkg.config\",\n                \"mypkg.helloworld\",\n                \"mypkg.components\",\n                \"mypkg.components.config\",\n                \"mypkg.components.helloworld\",\n            ):\n                sys.modules.pop(mod, None)\n\n            self.install_finder(template)\n\n            config = import_module(\"mypkg.components.config\")\n            assert config.a == 37\n\n            helloworld = import_module(\"mypkg.helloworld\")\n            assert helloworld.b == 13\n\n            with pytest.raises(ImportError):\n                import_module(\"mypkg.components.helloworld\")\n\n\ndef test_pkg_roots(tmp_path):\n    \"\"\"This test focus in getting a particular implementation detail right.\n    If at some point in time the implementation is changed for something different,\n    this test can be modified or even excluded.\n    \"\"\"\n    files = {\n        \"a\": {\"b\": {\"__init__.py\": \"ab = 1\"}, \"__init__.py\": \"a = 1\"},\n        \"d\": {\"__init__.py\": \"d = 1\", \"e\": {\"__init__.py\": \"de = 1\"}},\n        \"f\": {\"g\": {\"h\": {\"__init__.py\": \"fgh = 1\"}}},\n        \"other\": {\"__init__.py\": \"abc = 1\"},\n        \"another\": {\"__init__.py\": \"abcxyz = 1\"},\n        \"yet_another\": {\"__init__.py\": \"mnopq = 1\"},\n    }\n    jaraco.path.build(files, prefix=tmp_path)\n    package_dir = {\n        \"a.b.c\": \"other\",\n        \"a.b.c.x.y.z\": \"another\",\n        \"m.n.o.p.q\": \"yet_another\",\n    }\n    packages = [\n        \"a\",\n        \"a.b\",\n        \"a.b.c\",\n        \"a.b.c.x.y\",\n        \"a.b.c.x.y.z\",\n        \"d\",\n        \"d.e\",\n        \"f\",\n        \"f.g\",\n        \"f.g.h\",\n        \"m.n.o.p.q\",\n    ]\n    roots = _find_package_roots(packages, package_dir, tmp_path)\n    assert roots == {\n        \"a\": str(tmp_path / \"a\"),\n        \"a.b.c\": str(tmp_path / \"other\"),\n        \"a.b.c.x.y.z\": str(tmp_path / \"another\"),\n        \"d\": str(tmp_path / \"d\"),\n        \"f\": str(tmp_path / \"f\"),\n        \"m.n.o.p.q\": str(tmp_path / \"yet_another\"),\n    }\n\n    ns = set(dict(_find_namespaces(packages, roots)))\n    assert ns == {\"f\", \"f.g\"}\n\n    ns = set(_find_virtual_namespaces(roots))\n    assert ns == {\"a.b\", \"a.b.c.x\", \"a.b.c.x.y\", \"m\", \"m.n\", \"m.n.o\", \"m.n.o.p\"}\n\n\nclass TestOverallBehaviour:\n    PYPROJECT = \"\"\"\\\n        [build-system]\n        requires = [\"setuptools\"]\n        build-backend = \"setuptools.build_meta\"\n\n        [project]\n        name = \"mypkg\"\n        version = \"3.14159\"\n        \"\"\"\n\n    # Any: Would need a TypedDict. Keep it simple for tests\n    FLAT_LAYOUT: dict[str, Any] = {\n        \"pyproject.toml\": dedent(PYPROJECT),\n        \"MANIFEST.in\": EXAMPLE[\"MANIFEST.in\"],\n        \"otherfile.py\": \"\",\n        \"mypkg\": {\n            \"__init__.py\": \"\",\n            \"mod1.py\": \"var = 42\",\n            \"subpackage\": {\n                \"__init__.py\": \"\",\n                \"mod2.py\": \"var = 13\",\n                \"resource_file.txt\": \"resource 39\",\n            },\n        },\n    }\n\n    EXAMPLES = {\n        \"flat-layout\": FLAT_LAYOUT,\n        \"src-layout\": {\n            \"pyproject.toml\": dedent(PYPROJECT),\n            \"MANIFEST.in\": EXAMPLE[\"MANIFEST.in\"],\n            \"otherfile.py\": \"\",\n            \"src\": {\"mypkg\": FLAT_LAYOUT[\"mypkg\"]},\n        },\n        \"custom-layout\": {\n            \"pyproject.toml\": dedent(PYPROJECT)\n            + dedent(\n                \"\"\"\\\n                [tool.setuptools]\n                packages = [\"mypkg\", \"mypkg.subpackage\"]\n\n                [tool.setuptools.package-dir]\n                \"mypkg.subpackage\" = \"other\"\n                \"\"\"\n            ),\n            \"MANIFEST.in\": EXAMPLE[\"MANIFEST.in\"],\n            \"otherfile.py\": \"\",\n            \"mypkg\": {\n                \"__init__.py\": \"\",\n                \"mod1.py\": FLAT_LAYOUT[\"mypkg\"][\"mod1.py\"],\n            },\n            \"other\": FLAT_LAYOUT[\"mypkg\"][\"subpackage\"],\n        },\n        \"namespace\": {\n            \"pyproject.toml\": dedent(PYPROJECT),\n            \"MANIFEST.in\": EXAMPLE[\"MANIFEST.in\"],\n            \"otherfile.py\": \"\",\n            \"src\": {\n                \"mypkg\": {\n                    \"mod1.py\": FLAT_LAYOUT[\"mypkg\"][\"mod1.py\"],\n                    \"subpackage\": FLAT_LAYOUT[\"mypkg\"][\"subpackage\"],\n                },\n            },\n        },\n    }\n\n    @pytest.mark.xfail(sys.platform == \"darwin\", reason=\"pypa/setuptools#4328\")\n    @pytest.mark.parametrize(\"layout\", EXAMPLES.keys())\n    def test_editable_install(self, tmp_path, venv, layout, editable_opts):\n        project, _ = install_project(\n            \"mypkg\", venv, tmp_path, self.EXAMPLES[layout], *editable_opts\n        )\n\n        # Ensure stray files are not importable\n        cmd_import_error = \"\"\"\\\n        try:\n            import otherfile\n        except ImportError as ex:\n            print(ex)\n        \"\"\"\n        out = venv.run([\"python\", \"-c\", dedent(cmd_import_error)])\n        assert \"No module named 'otherfile'\" in out\n\n        # Ensure the modules are importable\n        cmd_get_vars = \"\"\"\\\n        import mypkg, mypkg.mod1, mypkg.subpackage.mod2\n        print(mypkg.mod1.var, mypkg.subpackage.mod2.var)\n        \"\"\"\n        out = venv.run([\"python\", \"-c\", dedent(cmd_get_vars)])\n        assert \"42 13\" in out\n\n        # Ensure resources are reachable\n        cmd_get_resource = \"\"\"\\\n        import mypkg.subpackage\n        from setuptools._importlib import resources as importlib_resources\n        text = importlib_resources.files(mypkg.subpackage) / \"resource_file.txt\"\n        print(text.read_text(encoding=\"utf-8\"))\n        \"\"\"\n        out = venv.run([\"python\", \"-c\", dedent(cmd_get_resource)])\n        assert \"resource 39\" in out\n\n        # Ensure files are editable\n        mod1 = next(project.glob(\"**/mod1.py\"))\n        mod2 = next(project.glob(\"**/mod2.py\"))\n        resource_file = next(project.glob(\"**/resource_file.txt\"))\n\n        mod1.write_text(\"var = 17\", encoding=\"utf-8\")\n        mod2.write_text(\"var = 781\", encoding=\"utf-8\")\n        resource_file.write_text(\"resource 374\", encoding=\"utf-8\")\n\n        out = venv.run([\"python\", \"-c\", dedent(cmd_get_vars)])\n        assert \"42 13\" not in out\n        assert \"17 781\" in out\n\n        out = venv.run([\"python\", \"-c\", dedent(cmd_get_resource)])\n        assert \"resource 39\" not in out\n        assert \"resource 374\" in out\n\n\nclass TestLinkTree:\n    FILES = deepcopy(TestOverallBehaviour.EXAMPLES[\"src-layout\"])\n    FILES[\"pyproject.toml\"] += dedent(\n        \"\"\"\\\n        [tool.setuptools]\n        # Temporary workaround: both `include-package-data` and `package-data` configs\n        # can be removed after #3260 is fixed.\n        include-package-data = false\n        package-data = {\"*\" = [\"*.txt\"]}\n\n        [tool.setuptools.packages.find]\n        where = [\"src\"]\n        exclude = [\"*.subpackage*\"]\n        \"\"\"\n    )\n    FILES[\"src\"][\"mypkg\"][\"resource.not_in_manifest\"] = \"abc\"\n\n    def test_generated_tree(self, tmp_path):\n        jaraco.path.build(self.FILES, prefix=tmp_path)\n\n        with _Path(tmp_path):\n            name = \"mypkg-3.14159\"\n            dist = Distribution({\"script_name\": \"%PEP 517%\"})\n            dist.parse_config_files()\n\n            wheel = Mock()\n            aux = tmp_path / \".aux\"\n            build = tmp_path / \".build\"\n            aux.mkdir()\n            build.mkdir()\n\n            build_py = dist.get_command_obj(\"build_py\")\n            build_py.editable_mode = True\n            build_py.build_lib = str(build)\n            build_py.ensure_finalized()\n            outputs = build_py.get_outputs()\n            output_mapping = build_py.get_output_mapping()\n\n            make_tree = _LinkTree(dist, name, aux, build)\n            make_tree(wheel, outputs, output_mapping)\n\n            mod1 = next(aux.glob(\"**/mod1.py\"))\n            expected = tmp_path / \"src/mypkg/mod1.py\"\n            assert_link_to(mod1, expected)\n\n            assert next(aux.glob(\"**/subpackage\"), None) is None\n            assert next(aux.glob(\"**/mod2.py\"), None) is None\n            assert next(aux.glob(\"**/resource_file.txt\"), None) is None\n\n            assert next(aux.glob(\"**/resource.not_in_manifest\"), None) is None\n\n    def test_strict_install(self, tmp_path, venv):\n        opts = [\"--config-settings\", \"editable-mode=strict\"]\n        install_project(\"mypkg\", venv, tmp_path, self.FILES, *opts)\n\n        out = venv.run([\"python\", \"-c\", \"import mypkg.mod1; print(mypkg.mod1.var)\"])\n        assert \"42\" in out\n\n        # Ensure packages excluded from distribution are not importable\n        cmd_import_error = \"\"\"\\\n        try:\n            from mypkg import subpackage\n        except ImportError as ex:\n            print(ex)\n        \"\"\"\n        out = venv.run([\"python\", \"-c\", dedent(cmd_import_error)])\n        assert \"cannot import name 'subpackage'\" in out\n\n        # Ensure resource files excluded from distribution are not reachable\n        cmd_get_resource = \"\"\"\\\n        import mypkg\n        from setuptools._importlib import resources as importlib_resources\n        try:\n            text = importlib_resources.files(mypkg) / \"resource.not_in_manifest\"\n            print(text.read_text(encoding=\"utf-8\"))\n        except FileNotFoundError as ex:\n            print(ex)\n        \"\"\"\n        out = venv.run([\"python\", \"-c\", dedent(cmd_get_resource)])\n        assert \"No such file or directory\" in out\n        assert \"resource.not_in_manifest\" in out\n\n\n@pytest.mark.filterwarnings(\"ignore:.*compat.*:setuptools.SetuptoolsDeprecationWarning\")\ndef test_compat_install(tmp_path, venv):\n    # TODO: Remove `compat` after Dec/2022.\n    opts = [\"--config-settings\", \"editable-mode=compat\"]\n    files = TestOverallBehaviour.EXAMPLES[\"custom-layout\"]\n    install_project(\"mypkg\", venv, tmp_path, files, *opts)\n\n    out = venv.run([\"python\", \"-c\", \"import mypkg.mod1; print(mypkg.mod1.var)\"])\n    assert \"42\" in out\n\n    expected_path = comparable_path(str(tmp_path))\n\n    # Compatible behaviour will make spurious modules and excluded\n    # files importable directly from the original path\n    for cmd in (\n        \"import otherfile; print(otherfile)\",\n        \"import other; print(other)\",\n        \"import mypkg; print(mypkg)\",\n    ):\n        out = comparable_path(venv.run([\"python\", \"-c\", cmd]))\n        assert expected_path in out\n\n    # Compatible behaviour will not consider custom mappings\n    cmd = \"\"\"\\\n    try:\n        from mypkg import subpackage;\n    except ImportError as ex:\n        print(ex)\n    \"\"\"\n    out = venv.run([\"python\", \"-c\", dedent(cmd)])\n    assert \"cannot import name 'subpackage'\" in out\n\n\ndef test_pbr_integration(tmp_path, venv, editable_opts):\n    \"\"\"Ensure editable installs work with pbr, issue #3500\"\"\"\n    files = {\n        \"pyproject.toml\": dedent(\n            \"\"\"\\\n            [build-system]\n            requires = [\"setuptools\"]\n            build-backend = \"setuptools.build_meta\"\n            \"\"\"\n        ),\n        \"setup.py\": dedent(\n            \"\"\"\\\n            __import__('setuptools').setup(\n                pbr=True,\n                setup_requires=[\"pbr\"],\n            )\n            \"\"\"\n        ),\n        \"setup.cfg\": dedent(\n            \"\"\"\\\n            [metadata]\n            name = mypkg\n\n            [files]\n            packages =\n                mypkg\n            \"\"\"\n        ),\n        \"mypkg\": {\n            \"__init__.py\": \"\",\n            \"hello.py\": \"print('Hello world!')\",\n        },\n        \"other\": {\"test.txt\": \"Another file in here.\"},\n    }\n    venv.run([\"python\", \"-m\", \"pip\", \"install\", \"pbr\"])\n\n    with contexts.environment(PBR_VERSION=\"0.42\"):\n        install_project(\"mypkg\", venv, tmp_path, files, *editable_opts)\n\n    out = venv.run([\"python\", \"-c\", \"import mypkg.hello\"])\n    assert \"Hello world!\" in out\n\n\nclass TestCustomBuildPy:\n    \"\"\"\n    Issue #3501 indicates that some plugins/customizations might rely on:\n\n    1. ``build_py`` not running\n    2. ``build_py`` always copying files to ``build_lib``\n\n    During the transition period setuptools should prevent potential errors from\n    happening due to those assumptions.\n    \"\"\"\n\n    # TODO: Remove tests after _run_build_steps is removed.\n\n    FILES = {\n        **TestOverallBehaviour.EXAMPLES[\"flat-layout\"],\n        \"setup.py\": dedent(\n            \"\"\"\\\n            import pathlib\n            from setuptools import setup\n            from setuptools.command.build_py import build_py as orig\n\n            class my_build_py(orig):\n                def run(self):\n                    super().run()\n                    raise ValueError(\"TEST_RAISE\")\n\n            setup(cmdclass={\"build_py\": my_build_py})\n            \"\"\"\n        ),\n    }\n\n    def test_safeguarded_from_errors(self, tmp_path, venv):\n        \"\"\"Ensure that errors in custom build_py are reported as warnings\"\"\"\n        # Warnings should show up\n        _, out = install_project(\"mypkg\", venv, tmp_path, self.FILES)\n        assert \"SetuptoolsDeprecationWarning\" in out\n        assert \"ValueError: TEST_RAISE\" in out\n        # but installation should be successful\n        out = venv.run([\"python\", \"-c\", \"import mypkg.mod1; print(mypkg.mod1.var)\"])\n        assert \"42\" in out\n\n\nclass TestCustomBuildWheel:\n    def install_custom_build_wheel(self, dist):\n        bdist_wheel_cls = dist.get_command_class(\"bdist_wheel\")\n\n        class MyBdistWheel(bdist_wheel_cls):\n            def get_tag(self):\n                # In issue #3513, we can see that some extensions may try to access\n                # the `plat_name` property in bdist_wheel\n                if self.plat_name.startswith(\"macosx-\"):\n                    _ = \"macOS platform\"\n                return super().get_tag()\n\n        dist.cmdclass[\"bdist_wheel\"] = MyBdistWheel\n\n    def test_access_plat_name(self, tmpdir_cwd):\n        # Even when a custom bdist_wheel tries to access plat_name the build should\n        # be successful\n        jaraco.path.build({\"module.py\": \"x = 42\"})\n        dist = Distribution()\n        dist.script_name = \"setup.py\"\n        dist.set_defaults()\n        self.install_custom_build_wheel(dist)\n        cmd = editable_wheel(dist)\n        cmd.ensure_finalized()\n        cmd.run()\n        wheel_file = str(next(Path().glob('dist/*.whl')))\n        assert \"editable\" in wheel_file\n\n\nclass TestCustomBuildExt:\n    def install_custom_build_ext_distutils(self, dist):\n        from distutils.command.build_ext import build_ext as build_ext_cls\n\n        class MyBuildExt(build_ext_cls):\n            pass\n\n        dist.cmdclass[\"build_ext\"] = MyBuildExt\n\n    @pytest.mark.skipif(\n        sys.platform != \"linux\", reason=\"compilers may fail without correct setup\"\n    )\n    def test_distutils_leave_inplace_files(self, tmpdir_cwd):\n        jaraco.path.build({\"module.c\": \"\"})\n        attrs = {\n            \"ext_modules\": [Extension(\"module\", [\"module.c\"])],\n        }\n        dist = Distribution(attrs)\n        dist.script_name = \"setup.py\"\n        dist.set_defaults()\n        self.install_custom_build_ext_distutils(dist)\n        cmd = editable_wheel(dist)\n        cmd.ensure_finalized()\n        cmd.run()\n        wheel_file = str(next(Path().glob('dist/*.whl')))\n        assert \"editable\" in wheel_file\n        files = [p for p in Path().glob(\"module.*\") if p.suffix != \".c\"]\n        assert len(files) == 1\n        name = files[0].name\n        assert any(name.endswith(ext) for ext in EXTENSION_SUFFIXES)\n\n\ndef test_debugging_tips(tmpdir_cwd, monkeypatch):\n    \"\"\"Make sure to display useful debugging tips to the user.\"\"\"\n    jaraco.path.build({\"module.py\": \"x = 42\"})\n    dist = Distribution()\n    dist.script_name = \"setup.py\"\n    dist.set_defaults()\n    cmd = editable_wheel(dist)\n    cmd.ensure_finalized()\n\n    SimulatedErr = type(\"SimulatedErr\", (Exception,), {})\n    simulated_failure = Mock(side_effect=SimulatedErr())\n    monkeypatch.setattr(cmd, \"get_finalized_command\", simulated_failure)\n\n    expected_msg = \"following steps are recommended to help debug\"\n    with pytest.raises(SimulatedErr), pytest.warns(_DebuggingTips, match=expected_msg):\n        cmd.run()\n\n\n@pytest.mark.filterwarnings(\"error\")\ndef test_encode_pth():\n    \"\"\"Ensure _encode_pth function does not produce encoding warnings\"\"\"\n    content = _encode_pth(\"tkmilan_ç_utf8\")  # no warnings (would be turned into errors)\n    assert isinstance(content, bytes)\n\n\ndef install_project(name, venv, tmp_path, files, *opts):\n    project = tmp_path / name\n    project.mkdir()\n    jaraco.path.build(files, prefix=project)\n    opts = [*opts, \"--no-build-isolation\"]  # force current version of setuptools\n    out = venv.run(\n        [\"python\", \"-m\", \"pip\", \"-v\", \"install\", \"-e\", str(project), *opts],\n        stderr=subprocess.STDOUT,\n    )\n    return project, out\n\n\ndef _addsitedirs(new_dirs):\n    \"\"\"To use this function, it is necessary to insert new_dir in front of sys.path.\n    The Python process will try to import a ``sitecustomize`` module on startup.\n    If we manipulate sys.path/PYTHONPATH, we can force it to run our code,\n    which invokes ``addsitedir`` and ensure ``.pth`` files are loaded.\n    \"\"\"\n    content = '\\n'.join(\n        (\"import site\",)\n        + tuple(f\"site.addsitedir({os.fspath(new_dir)!r})\" for new_dir in new_dirs)\n    )\n    (new_dirs[0] / \"sitecustomize.py\").write_text(content, encoding=\"utf-8\")\n\n\n# ---- Assertion Helpers ----\n\n\ndef assert_path(pkg, expected):\n    # __path__ is not guaranteed to exist, so we have to account for that\n    if pkg.__path__:\n        path = next(iter(pkg.__path__), None)\n        if path:\n            assert str(Path(path).resolve()) == expected\n\n\ndef assert_link_to(file: Path, other: Path) -> None:\n    if file.is_symlink():\n        assert str(file.resolve()) == str(other.resolve())\n    else:\n        file_stat = file.stat()\n        other_stat = other.stat()\n        assert file_stat[stat.ST_INO] == other_stat[stat.ST_INO]\n        assert file_stat[stat.ST_DEV] == other_stat[stat.ST_DEV]\n\n\ndef comparable_path(str_with_path: str) -> str:\n    return str_with_path.lower().replace(os.sep, \"/\").replace(\"//\", \"/\")\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_egg_info.py","size":43963,"sha1":"6837f753e9fa59c982ab3457aa94ad6bc6b39203","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport ast\nimport glob\nimport os\nimport re\nimport stat\nimport sys\nimport time\nfrom pathlib import Path\nfrom unittest import mock\n\nimport pytest\nfrom jaraco import path\n\nfrom setuptools import errors\nfrom setuptools.command.egg_info import egg_info, manifest_maker, write_entries\nfrom setuptools.dist import Distribution\n\nfrom . import contexts, environment\nfrom .textwrap import DALS\n\n\nclass Environment(str):\n    pass\n\n\n@pytest.fixture\ndef env():\n    with contexts.tempdir(prefix='setuptools-test.') as env_dir:\n        env = Environment(env_dir)\n        os.chmod(env_dir, stat.S_IRWXU)\n        subs = 'home', 'lib', 'scripts', 'data', 'egg-base'\n        env.paths = dict((dirname, os.path.join(env_dir, dirname)) for dirname in subs)\n        list(map(os.mkdir, env.paths.values()))\n        path.build({\n            env.paths['home']: {\n                '.pydistutils.cfg': DALS(\n                    \"\"\"\n                [egg_info]\n                egg-base = {egg-base}\n                \"\"\".format(**env.paths)\n                )\n            }\n        })\n        yield env\n\n\nclass TestEggInfo:\n    setup_script = DALS(\n        \"\"\"\n        from setuptools import setup\n\n        setup(\n            name='foo',\n            py_modules=['hello'],\n            entry_points={'console_scripts': ['hi = hello.run']},\n            zip_safe=False,\n        )\n        \"\"\"\n    )\n\n    def _create_project(self):\n        path.build({\n            'setup.py': self.setup_script,\n            'hello.py': DALS(\n                \"\"\"\n                def run():\n                    print('hello')\n                \"\"\"\n            ),\n        })\n\n    @staticmethod\n    def _extract_mv_version(pkg_info_lines: list[str]) -> tuple[int, int]:\n        version_str = pkg_info_lines[0].split(' ')[1]\n        major, minor = map(int, version_str.split('.')[:2])\n        return major, minor\n\n    def test_egg_info_save_version_info_setup_empty(self, tmpdir_cwd, env):\n        \"\"\"\n        When the egg_info section is empty or not present, running\n        save_version_info should add the settings to the setup.cfg\n        in a deterministic order.\n        \"\"\"\n        setup_cfg = os.path.join(env.paths['home'], 'setup.cfg')\n        dist = Distribution()\n        ei = egg_info(dist)\n        ei.initialize_options()\n        ei.save_version_info(setup_cfg)\n\n        with open(setup_cfg, 'r', encoding=\"utf-8\") as f:\n            content = f.read()\n\n        assert '[egg_info]' in content\n        assert 'tag_build =' in content\n        assert 'tag_date = 0' in content\n\n        expected_order = (\n            'tag_build',\n            'tag_date',\n        )\n\n        self._validate_content_order(content, expected_order)\n\n    @staticmethod\n    def _validate_content_order(content, expected):\n        \"\"\"\n        Assert that the strings in expected appear in content\n        in order.\n        \"\"\"\n        pattern = '.*'.join(expected)\n        flags = re.MULTILINE | re.DOTALL\n        assert re.search(pattern, content, flags)\n\n    def test_egg_info_save_version_info_setup_defaults(self, tmpdir_cwd, env):\n        \"\"\"\n        When running save_version_info on an existing setup.cfg\n        with the 'default' values present from a previous run,\n        the file should remain unchanged.\n        \"\"\"\n        setup_cfg = os.path.join(env.paths['home'], 'setup.cfg')\n        path.build({\n            setup_cfg: DALS(\n                \"\"\"\n            [egg_info]\n            tag_build =\n            tag_date = 0\n            \"\"\"\n            ),\n        })\n        dist = Distribution()\n        ei = egg_info(dist)\n        ei.initialize_options()\n        ei.save_version_info(setup_cfg)\n\n        with open(setup_cfg, 'r', encoding=\"utf-8\") as f:\n            content = f.read()\n\n        assert '[egg_info]' in content\n        assert 'tag_build =' in content\n        assert 'tag_date = 0' in content\n\n        expected_order = (\n            'tag_build',\n            'tag_date',\n        )\n\n        self._validate_content_order(content, expected_order)\n\n    def test_expected_files_produced(self, tmpdir_cwd, env):\n        self._create_project()\n\n        self._run_egg_info_command(tmpdir_cwd, env)\n        actual = os.listdir('foo.egg-info')\n\n        expected = [\n            'PKG-INFO',\n            'SOURCES.txt',\n            'dependency_links.txt',\n            'entry_points.txt',\n            'not-zip-safe',\n            'top_level.txt',\n        ]\n        assert sorted(actual) == expected\n\n    def test_handling_utime_error(self, tmpdir_cwd, env):\n        dist = Distribution()\n        ei = egg_info(dist)\n        utime_patch = mock.patch('os.utime', side_effect=OSError(\"TEST\"))\n        mkpath_patch = mock.patch(\n            'setuptools.command.egg_info.egg_info.mkpath', return_val=None\n        )\n\n        with utime_patch, mkpath_patch:\n            import distutils.errors\n\n            msg = r\"Cannot update time stamp of directory 'None'\"\n            with pytest.raises(distutils.errors.DistutilsFileError, match=msg):\n                ei.run()\n\n    def test_license_is_a_string(self, tmpdir_cwd, env):\n        setup_config = DALS(\n            \"\"\"\n            [metadata]\n            name=foo\n            version=0.0.1\n            license=file:MIT\n            \"\"\"\n        )\n\n        setup_script = DALS(\n            \"\"\"\n            from setuptools import setup\n\n            setup()\n            \"\"\"\n        )\n\n        path.build({\n            'setup.py': setup_script,\n            'setup.cfg': setup_config,\n        })\n\n        # This command should fail with a ValueError, but because it's\n        # currently configured to use a subprocess, the actual traceback\n        # object is lost and we need to parse it from stderr\n        with pytest.raises(AssertionError) as exc:\n            self._run_egg_info_command(tmpdir_cwd, env)\n\n        # The only argument to the assertion error should be a traceback\n        # containing a ValueError\n        assert 'ValueError' in exc.value.args[0]\n\n    def test_rebuilt(self, tmpdir_cwd, env):\n        \"\"\"Ensure timestamps are updated when the command is re-run.\"\"\"\n        self._create_project()\n\n        self._run_egg_info_command(tmpdir_cwd, env)\n        timestamp_a = os.path.getmtime('foo.egg-info')\n\n        # arbitrary sleep just to handle *really* fast systems\n        time.sleep(0.001)\n\n        self._run_egg_info_command(tmpdir_cwd, env)\n        timestamp_b = os.path.getmtime('foo.egg-info')\n\n        assert timestamp_a != timestamp_b\n\n    def test_manifest_template_is_read(self, tmpdir_cwd, env):\n        self._create_project()\n        path.build({\n            'MANIFEST.in': DALS(\n                \"\"\"\n                recursive-include docs *.rst\n            \"\"\"\n            ),\n            'docs': {\n                'usage.rst': \"Run 'hi'\",\n            },\n        })\n        self._run_egg_info_command(tmpdir_cwd, env)\n        egg_info_dir = os.path.join('.', 'foo.egg-info')\n        sources_txt = os.path.join(egg_info_dir, 'SOURCES.txt')\n        with open(sources_txt, encoding=\"utf-8\") as f:\n            assert 'docs/usage.rst' in f.read().split('\\n')\n\n    def _setup_script_with_requires(self, requires, use_setup_cfg=False):\n        setup_script = DALS(\n            \"\"\"\n            from setuptools import setup\n\n            setup(name='foo', zip_safe=False, %s)\n            \"\"\"\n        ) % ('' if use_setup_cfg else requires)\n        setup_config = requires if use_setup_cfg else ''\n        path.build({\n            'setup.py': setup_script,\n            'setup.cfg': setup_config,\n        })\n\n    mismatch_marker = f\"python_version<'{sys.version_info[0]}'\"\n    # Alternate equivalent syntax.\n    mismatch_marker_alternate = f'python_version < \"{sys.version_info[0]}\"'\n    invalid_marker = \"<=>++\"\n\n    class RequiresTestHelper:\n        @staticmethod\n        def parametrize(*test_list, **format_dict):\n            idlist = []\n            argvalues = []\n            for test in test_list:\n                test_params = test.lstrip().split('\\n\\n', 3)\n                name_kwargs = test_params.pop(0).split('\\n')\n                if len(name_kwargs) > 1:\n                    val = name_kwargs[1].strip()\n                    install_cmd_kwargs = ast.literal_eval(val)\n                else:\n                    install_cmd_kwargs = {}\n                name = name_kwargs[0].strip()\n                setup_py_requires, setup_cfg_requires, expected_requires = [\n                    DALS(a).format(**format_dict) for a in test_params\n                ]\n                for id_, requires, use_cfg in (\n                    (name, setup_py_requires, False),\n                    (name + '_in_setup_cfg', setup_cfg_requires, True),\n                ):\n                    idlist.append(id_)\n                    marks = ()\n                    if requires.startswith('@xfail\\n'):\n                        requires = requires[7:]\n                        marks = pytest.mark.xfail\n                    argvalues.append(\n                        pytest.param(\n                            requires,\n                            use_cfg,\n                            expected_requires,\n                            install_cmd_kwargs,\n                            marks=marks,\n                        )\n                    )\n            return pytest.mark.parametrize(\n                'requires,use_setup_cfg,expected_requires,install_cmd_kwargs',\n                argvalues,\n                ids=idlist,\n            )\n\n    @RequiresTestHelper.parametrize(\n        # Format of a test:\n        #\n        # id\n        # install_cmd_kwargs [optional]\n        #\n        # requires block (when used in setup.py)\n        #\n        # requires block (when used in setup.cfg)\n        #\n        # expected contents of requires.txt\n        \"\"\"\n        install_requires_deterministic\n\n        install_requires=[\"wheel>=0.5\", \"pytest\"]\n\n        [options]\n        install_requires =\n            wheel>=0.5\n            pytest\n\n        wheel>=0.5\n        pytest\n        \"\"\",\n        \"\"\"\n        install_requires_ordered\n\n        install_requires=[\"pytest>=3.0.2,!=10.9999\"]\n\n        [options]\n        install_requires =\n            pytest>=3.0.2,!=10.9999\n\n        pytest!=10.9999,>=3.0.2\n        \"\"\",\n        \"\"\"\n        install_requires_with_marker\n\n        install_requires=[\"barbazquux;{mismatch_marker}\"],\n\n        [options]\n        install_requires =\n            barbazquux; {mismatch_marker}\n\n        [:{mismatch_marker_alternate}]\n        barbazquux\n        \"\"\",\n        \"\"\"\n        install_requires_with_extra\n        {'cmd': ['egg_info']}\n\n        install_requires=[\"barbazquux [test]\"],\n\n        [options]\n        install_requires =\n            barbazquux [test]\n\n        barbazquux[test]\n        \"\"\",\n        \"\"\"\n        install_requires_with_extra_and_marker\n\n        install_requires=[\"barbazquux [test]; {mismatch_marker}\"],\n\n        [options]\n        install_requires =\n            barbazquux [test]; {mismatch_marker}\n\n        [:{mismatch_marker_alternate}]\n        barbazquux[test]\n        \"\"\",\n        \"\"\"\n        setup_requires_with_markers\n\n        setup_requires=[\"barbazquux;{mismatch_marker}\"],\n\n        [options]\n        setup_requires =\n            barbazquux; {mismatch_marker}\n\n        \"\"\",\n        \"\"\"\n        extras_require_with_extra\n        {'cmd': ['egg_info']}\n\n        extras_require={{\"extra\": [\"barbazquux [test]\"]}},\n\n        [options.extras_require]\n        extra = barbazquux [test]\n\n        [extra]\n        barbazquux[test]\n        \"\"\",\n        \"\"\"\n        extras_require_with_extra_and_marker_in_req\n\n        extras_require={{\"extra\": [\"barbazquux [test]; {mismatch_marker}\"]}},\n\n        [options.extras_require]\n        extra =\n            barbazquux [test]; {mismatch_marker}\n\n        [extra]\n\n        [extra:{mismatch_marker_alternate}]\n        barbazquux[test]\n        \"\"\",\n        # FIXME: ConfigParser does not allow : in key names!\n        \"\"\"\n        extras_require_with_marker\n\n        extras_require={{\":{mismatch_marker}\": [\"barbazquux\"]}},\n\n        @xfail\n        [options.extras_require]\n        :{mismatch_marker} = barbazquux\n\n        [:{mismatch_marker}]\n        barbazquux\n        \"\"\",\n        \"\"\"\n        extras_require_with_marker_in_req\n\n        extras_require={{\"extra\": [\"barbazquux; {mismatch_marker}\"]}},\n\n        [options.extras_require]\n        extra =\n            barbazquux; {mismatch_marker}\n\n        [extra]\n\n        [extra:{mismatch_marker_alternate}]\n        barbazquux\n        \"\"\",\n        \"\"\"\n        extras_require_with_empty_section\n\n        extras_require={{\"empty\": []}},\n\n        [options.extras_require]\n        empty =\n\n        [empty]\n        \"\"\",\n        # Format arguments.\n        invalid_marker=invalid_marker,\n        mismatch_marker=mismatch_marker,\n        mismatch_marker_alternate=mismatch_marker_alternate,\n    )\n    def test_requires(\n        self,\n        tmpdir_cwd,\n        env,\n        requires,\n        use_setup_cfg,\n        expected_requires,\n        install_cmd_kwargs,\n    ):\n        self._setup_script_with_requires(requires, use_setup_cfg)\n        self._run_egg_info_command(tmpdir_cwd, env, **install_cmd_kwargs)\n        egg_info_dir = os.path.join('.', 'foo.egg-info')\n        requires_txt = os.path.join(egg_info_dir, 'requires.txt')\n        if os.path.exists(requires_txt):\n            with open(requires_txt, encoding=\"utf-8\") as fp:\n                install_requires = fp.read()\n        else:\n            install_requires = ''\n        assert install_requires.lstrip() == expected_requires\n        assert glob.glob(os.path.join(env.paths['lib'], 'barbazquux*')) == []\n\n    def test_install_requires_unordered_disallowed(self, tmpdir_cwd, env):\n        \"\"\"\n        Packages that pass unordered install_requires sequences\n        should be rejected as they produce non-deterministic\n        builds. See #458.\n        \"\"\"\n        req = 'install_requires={\"fake-factory==0.5.2\", \"pytz\"}'\n        self._setup_script_with_requires(req)\n        with pytest.raises(AssertionError):\n            self._run_egg_info_command(tmpdir_cwd, env)\n\n    def test_extras_require_with_invalid_marker(self, tmpdir_cwd, env):\n        tmpl = 'extras_require={{\":{marker}\": [\"barbazquux\"]}},'\n        req = tmpl.format(marker=self.invalid_marker)\n        self._setup_script_with_requires(req)\n        with pytest.raises(AssertionError):\n            self._run_egg_info_command(tmpdir_cwd, env)\n        assert glob.glob(os.path.join(env.paths['lib'], 'barbazquux*')) == []\n\n    def test_extras_require_with_invalid_marker_in_req(self, tmpdir_cwd, env):\n        tmpl = 'extras_require={{\"extra\": [\"barbazquux; {marker}\"]}},'\n        req = tmpl.format(marker=self.invalid_marker)\n        self._setup_script_with_requires(req)\n        with pytest.raises(AssertionError):\n            self._run_egg_info_command(tmpdir_cwd, env)\n        assert glob.glob(os.path.join(env.paths['lib'], 'barbazquux*')) == []\n\n    def test_provides_extra(self, tmpdir_cwd, env):\n        self._setup_script_with_requires('extras_require={\"foobar\": [\"barbazquux\"]},')\n        environ = os.environ.copy().update(\n            HOME=env.paths['home'],\n        )\n        environment.run_setup_py(\n            cmd=['egg_info'],\n            pypath=os.pathsep.join([env.paths['lib'], str(tmpdir_cwd)]),\n            data_stream=1,\n            env=environ,\n        )\n        egg_info_dir = os.path.join('.', 'foo.egg-info')\n        with open(os.path.join(egg_info_dir, 'PKG-INFO'), encoding=\"utf-8\") as fp:\n            pkg_info_lines = fp.read().split('\\n')\n        assert 'Provides-Extra: foobar' in pkg_info_lines\n        assert 'Metadata-Version: 2.2' in pkg_info_lines\n\n    def test_doesnt_provides_extra(self, tmpdir_cwd, env):\n        self._setup_script_with_requires(\n            \"\"\"install_requires=[\"spam ; python_version<'3.6'\"]\"\"\"\n        )\n        environ = os.environ.copy().update(\n            HOME=env.paths['home'],\n        )\n        environment.run_setup_py(\n            cmd=['egg_info'],\n            pypath=os.pathsep.join([env.paths['lib'], str(tmpdir_cwd)]),\n            data_stream=1,\n            env=environ,\n        )\n        egg_info_dir = os.path.join('.', 'foo.egg-info')\n        with open(os.path.join(egg_info_dir, 'PKG-INFO'), encoding=\"utf-8\") as fp:\n            pkg_info_text = fp.read()\n        assert 'Provides-Extra:' not in pkg_info_text\n\n    @pytest.mark.parametrize(\n        ('files', 'license_in_sources'),\n        [\n            (\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_file = LICENSE\n                              \"\"\"\n                    ),\n                    'LICENSE': \"Test license\",\n                },\n                True,\n            ),  # with license\n            (\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_file = INVALID_LICENSE\n                              \"\"\"\n                    ),\n                    'LICENSE': \"Test license\",\n                },\n                False,\n            ),  # with an invalid license\n            (\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              \"\"\"\n                    ),\n                    'LICENSE': \"Test license\",\n                },\n                True,\n            ),  # no license_file attribute, LICENSE auto-included\n            (\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_file = LICENSE\n                              \"\"\"\n                    ),\n                    'MANIFEST.in': \"exclude LICENSE\",\n                    'LICENSE': \"Test license\",\n                },\n                True,\n            ),  # manifest is overwritten by license_file\n            pytest.param(\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_file = LICEN[CS]E*\n                              \"\"\"\n                    ),\n                    'LICENSE': \"Test license\",\n                },\n                True,\n                id=\"glob_pattern\",\n            ),\n        ],\n    )\n    def test_setup_cfg_license_file(self, tmpdir_cwd, env, files, license_in_sources):\n        self._create_project()\n        path.build(files)\n\n        environment.run_setup_py(\n            cmd=['egg_info'],\n            pypath=os.pathsep.join([env.paths['lib'], str(tmpdir_cwd)]),\n        )\n        egg_info_dir = os.path.join('.', 'foo.egg-info')\n\n        sources_text = Path(egg_info_dir, \"SOURCES.txt\").read_text(encoding=\"utf-8\")\n\n        if license_in_sources:\n            assert 'LICENSE' in sources_text\n        else:\n            assert 'LICENSE' not in sources_text\n            # for invalid license test\n            assert 'INVALID_LICENSE' not in sources_text\n\n    @pytest.mark.parametrize(\n        ('files', 'incl_licenses', 'excl_licenses'),\n        [\n            (\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_files =\n                                  LICENSE-ABC\n                                  LICENSE-XYZ\n                              \"\"\"\n                    ),\n                    'LICENSE-ABC': \"ABC license\",\n                    'LICENSE-XYZ': \"XYZ license\",\n                },\n                ['LICENSE-ABC', 'LICENSE-XYZ'],\n                [],\n            ),  # with licenses\n            (\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_files = LICENSE-ABC, LICENSE-XYZ\n                              \"\"\"\n                    ),\n                    'LICENSE-ABC': \"ABC license\",\n                    'LICENSE-XYZ': \"XYZ license\",\n                },\n                ['LICENSE-ABC', 'LICENSE-XYZ'],\n                [],\n            ),  # with commas\n            (\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_files =\n                                  LICENSE-ABC\n                              \"\"\"\n                    ),\n                    'LICENSE-ABC': \"ABC license\",\n                    'LICENSE-XYZ': \"XYZ license\",\n                },\n                ['LICENSE-ABC'],\n                ['LICENSE-XYZ'],\n            ),  # with one license\n            (\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_files =\n                              \"\"\"\n                    ),\n                    'LICENSE-ABC': \"ABC license\",\n                    'LICENSE-XYZ': \"XYZ license\",\n                },\n                [],\n                ['LICENSE-ABC', 'LICENSE-XYZ'],\n            ),  # empty\n            (\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_files = LICENSE-XYZ\n                              \"\"\"\n                    ),\n                    'LICENSE-ABC': \"ABC license\",\n                    'LICENSE-XYZ': \"XYZ license\",\n                },\n                ['LICENSE-XYZ'],\n                ['LICENSE-ABC'],\n            ),  # on same line\n            (\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_files =\n                                  LICENSE-ABC\n                                  INVALID_LICENSE\n                              \"\"\"\n                    ),\n                    'LICENSE-ABC': \"Test license\",\n                },\n                ['LICENSE-ABC'],\n                ['INVALID_LICENSE'],\n            ),  # with an invalid license\n            (\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              \"\"\"\n                    ),\n                    'LICENSE': \"Test license\",\n                },\n                ['LICENSE'],\n                [],\n            ),  # no license_files attribute, LICENSE auto-included\n            (\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_files = LICENSE\n                              \"\"\"\n                    ),\n                    'MANIFEST.in': \"exclude LICENSE\",\n                    'LICENSE': \"Test license\",\n                },\n                ['LICENSE'],\n                [],\n            ),  # manifest is overwritten by license_files\n            (\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_files =\n                                  LICENSE-ABC\n                                  LICENSE-XYZ\n                              \"\"\"\n                    ),\n                    'MANIFEST.in': \"exclude LICENSE-XYZ\",\n                    'LICENSE-ABC': \"ABC license\",\n                    'LICENSE-XYZ': \"XYZ license\",\n                    # manifest is overwritten by license_files\n                },\n                ['LICENSE-ABC', 'LICENSE-XYZ'],\n                [],\n            ),\n            pytest.param(\n                {\n                    'setup.cfg': \"\",\n                    'LICENSE-ABC': \"ABC license\",\n                    'COPYING-ABC': \"ABC copying\",\n                    'NOTICE-ABC': \"ABC notice\",\n                    'AUTHORS-ABC': \"ABC authors\",\n                    'LICENCE-XYZ': \"XYZ license\",\n                    'LICENSE': \"License\",\n                    'INVALID-LICENSE': \"Invalid license\",\n                },\n                [\n                    'LICENSE-ABC',\n                    'COPYING-ABC',\n                    'NOTICE-ABC',\n                    'AUTHORS-ABC',\n                    'LICENCE-XYZ',\n                    'LICENSE',\n                ],\n                ['INVALID-LICENSE'],\n                # ('LICEN[CS]E*', 'COPYING*', 'NOTICE*', 'AUTHORS*')\n                id=\"default_glob_patterns\",\n            ),\n            pytest.param(\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_files =\n                                  LICENSE*\n                              \"\"\"\n                    ),\n                    'LICENSE-ABC': \"ABC license\",\n                    'NOTICE-XYZ': \"XYZ notice\",\n                },\n                ['LICENSE-ABC'],\n                ['NOTICE-XYZ'],\n                id=\"no_default_glob_patterns\",\n            ),\n            pytest.param(\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_files =\n                                  LICENSE-ABC\n                                  LICENSE*\n                              \"\"\"\n                    ),\n                    'LICENSE-ABC': \"ABC license\",\n                },\n                ['LICENSE-ABC'],\n                [],\n                id=\"files_only_added_once\",\n            ),\n        ],\n    )\n    def test_setup_cfg_license_files(\n        self, tmpdir_cwd, env, files, incl_licenses, excl_licenses\n    ):\n        self._create_project()\n        path.build(files)\n\n        environment.run_setup_py(\n            cmd=['egg_info'],\n            pypath=os.pathsep.join([env.paths['lib'], str(tmpdir_cwd)]),\n        )\n        egg_info_dir = os.path.join('.', 'foo.egg-info')\n\n        sources_text = Path(egg_info_dir, \"SOURCES.txt\").read_text(encoding=\"utf-8\")\n        sources_lines = [line.strip() for line in sources_text.splitlines()]\n\n        for lf in incl_licenses:\n            assert sources_lines.count(lf) == 1\n\n        for lf in excl_licenses:\n            assert sources_lines.count(lf) == 0\n\n    @pytest.mark.parametrize(\n        ('files', 'incl_licenses', 'excl_licenses'),\n        [\n            (\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_file =\n                              license_files =\n                              \"\"\"\n                    ),\n                    'LICENSE-ABC': \"ABC license\",\n                    'LICENSE-XYZ': \"XYZ license\",\n                },\n                [],\n                ['LICENSE-ABC', 'LICENSE-XYZ'],\n            ),  # both empty\n            (\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_file =\n                                  LICENSE-ABC\n                                  LICENSE-XYZ\n                              \"\"\"\n                    ),\n                    'LICENSE-ABC': \"ABC license\",\n                    'LICENSE-XYZ': \"XYZ license\",\n                    # license_file is still singular\n                },\n                [],\n                ['LICENSE-ABC', 'LICENSE-XYZ'],\n            ),\n            (\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_file = LICENSE-ABC\n                              license_files =\n                                  LICENSE-XYZ\n                                  LICENSE-PQR\n                              \"\"\"\n                    ),\n                    'LICENSE-ABC': \"ABC license\",\n                    'LICENSE-PQR': \"PQR license\",\n                    'LICENSE-XYZ': \"XYZ license\",\n                },\n                ['LICENSE-ABC', 'LICENSE-PQR', 'LICENSE-XYZ'],\n                [],\n            ),  # combined\n            (\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_file = LICENSE-ABC\n                              license_files =\n                                  LICENSE-ABC\n                                  LICENSE-XYZ\n                                  LICENSE-PQR\n                              \"\"\"\n                    ),\n                    'LICENSE-ABC': \"ABC license\",\n                    'LICENSE-PQR': \"PQR license\",\n                    'LICENSE-XYZ': \"XYZ license\",\n                    # duplicate license\n                },\n                ['LICENSE-ABC', 'LICENSE-PQR', 'LICENSE-XYZ'],\n                [],\n            ),\n            (\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_file = LICENSE-ABC\n                              license_files =\n                                  LICENSE-XYZ\n                              \"\"\"\n                    ),\n                    'LICENSE-ABC': \"ABC license\",\n                    'LICENSE-PQR': \"PQR license\",\n                    'LICENSE-XYZ': \"XYZ license\",\n                    # combined subset\n                },\n                ['LICENSE-ABC', 'LICENSE-XYZ'],\n                ['LICENSE-PQR'],\n            ),\n            (\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_file = LICENSE-ABC\n                              license_files =\n                                  LICENSE-XYZ\n                                  LICENSE-PQR\n                              \"\"\"\n                    ),\n                    'LICENSE-PQR': \"Test license\",\n                    # with invalid licenses\n                },\n                ['LICENSE-PQR'],\n                ['LICENSE-ABC', 'LICENSE-XYZ'],\n            ),\n            (\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_file = LICENSE-ABC\n                              license_files =\n                                LICENSE-PQR\n                                LICENSE-XYZ\n                              \"\"\"\n                    ),\n                    'MANIFEST.in': \"exclude LICENSE-ABC\\nexclude LICENSE-PQR\",\n                    'LICENSE-ABC': \"ABC license\",\n                    'LICENSE-PQR': \"PQR license\",\n                    'LICENSE-XYZ': \"XYZ license\",\n                    # manifest is overwritten\n                },\n                ['LICENSE-ABC', 'LICENSE-PQR', 'LICENSE-XYZ'],\n                [],\n            ),\n            pytest.param(\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_file = LICENSE*\n                              \"\"\"\n                    ),\n                    'LICENSE-ABC': \"ABC license\",\n                    'NOTICE-XYZ': \"XYZ notice\",\n                },\n                ['LICENSE-ABC'],\n                ['NOTICE-XYZ'],\n                id=\"no_default_glob_patterns\",\n            ),\n            pytest.param(\n                {\n                    'setup.cfg': DALS(\n                        \"\"\"\n                              [metadata]\n                              license_file = LICENSE*\n                              license_files =\n                                NOTICE*\n                              \"\"\"\n                    ),\n                    'LICENSE-ABC': \"ABC license\",\n                    'NOTICE-ABC': \"ABC notice\",\n                    'AUTHORS-ABC': \"ABC authors\",\n                },\n                ['LICENSE-ABC', 'NOTICE-ABC'],\n                ['AUTHORS-ABC'],\n                id=\"combined_glob_patterrns\",\n            ),\n        ],\n    )\n    def test_setup_cfg_license_file_license_files(\n        self, tmpdir_cwd, env, files, incl_licenses, excl_licenses\n    ):\n        self._create_project()\n        path.build(files)\n\n        environment.run_setup_py(\n            cmd=['egg_info'],\n            pypath=os.pathsep.join([env.paths['lib'], str(tmpdir_cwd)]),\n        )\n        egg_info_dir = os.path.join('.', 'foo.egg-info')\n\n        sources_text = Path(egg_info_dir, \"SOURCES.txt\").read_text(encoding=\"utf-8\")\n        sources_lines = [line.strip() for line in sources_text.splitlines()]\n\n        for lf in incl_licenses:\n            assert sources_lines.count(lf) == 1\n\n        for lf in excl_licenses:\n            assert sources_lines.count(lf) == 0\n\n    def test_license_file_attr_pkg_info(self, tmpdir_cwd, env):\n        \"\"\"All matched license files should have a corresponding License-File.\"\"\"\n        self._create_project()\n        path.build({\n            \"setup.cfg\": DALS(\n                \"\"\"\n                              [metadata]\n                              license_files =\n                                  NOTICE*\n                                  LICENSE*\n                              \"\"\"\n            ),\n            \"LICENSE-ABC\": \"ABC license\",\n            \"LICENSE-XYZ\": \"XYZ license\",\n            \"NOTICE\": \"included\",\n            \"IGNORE\": \"not include\",\n        })\n\n        environment.run_setup_py(\n            cmd=['egg_info'],\n            pypath=os.pathsep.join([env.paths['lib'], str(tmpdir_cwd)]),\n        )\n        egg_info_dir = os.path.join('.', 'foo.egg-info')\n        with open(os.path.join(egg_info_dir, 'PKG-INFO'), encoding=\"utf-8\") as fp:\n            pkg_info_lines = fp.read().split('\\n')\n        license_file_lines = [\n            line for line in pkg_info_lines if line.startswith('License-File:')\n        ]\n\n        # Only 'NOTICE', LICENSE-ABC', and 'LICENSE-XYZ' should have been matched\n        # Also assert that order from license_files is keeped\n        assert \"License-File: NOTICE\" == license_file_lines[0]\n        assert \"License-File: LICENSE-ABC\" in license_file_lines[1:]\n        assert \"License-File: LICENSE-XYZ\" in license_file_lines[1:]\n\n    def test_metadata_version(self, tmpdir_cwd, env):\n        \"\"\"Make sure latest metadata version is used by default.\"\"\"\n        self._setup_script_with_requires(\"\")\n        environment.run_setup_py(\n            cmd=['egg_info'],\n            pypath=os.pathsep.join([env.paths['lib'], str(tmpdir_cwd)]),\n            data_stream=1,\n        )\n        egg_info_dir = os.path.join('.', 'foo.egg-info')\n        with open(os.path.join(egg_info_dir, 'PKG-INFO'), encoding=\"utf-8\") as fp:\n            pkg_info_lines = fp.read().split('\\n')\n        # Update metadata version if changed\n        assert self._extract_mv_version(pkg_info_lines) == (2, 2)\n\n    def test_long_description_content_type(self, tmpdir_cwd, env):\n        # Test that specifying a `long_description_content_type` keyword arg to\n        # the `setup` function results in writing a `Description-Content-Type`\n        # line to the `PKG-INFO` file in the `<distribution>.egg-info`\n        # directory.\n        # `Description-Content-Type` is described at\n        # https://github.com/pypa/python-packaging-user-guide/pull/258\n\n        self._setup_script_with_requires(\n            \"\"\"long_description_content_type='text/markdown',\"\"\"\n        )\n        environ = os.environ.copy().update(\n            HOME=env.paths['home'],\n        )\n        environment.run_setup_py(\n            cmd=['egg_info'],\n            pypath=os.pathsep.join([env.paths['lib'], str(tmpdir_cwd)]),\n            data_stream=1,\n            env=environ,\n        )\n        egg_info_dir = os.path.join('.', 'foo.egg-info')\n        with open(os.path.join(egg_info_dir, 'PKG-INFO'), encoding=\"utf-8\") as fp:\n            pkg_info_lines = fp.read().split('\\n')\n        expected_line = 'Description-Content-Type: text/markdown'\n        assert expected_line in pkg_info_lines\n        assert 'Metadata-Version: 2.2' in pkg_info_lines\n\n    def test_long_description(self, tmpdir_cwd, env):\n        # Test that specifying `long_description` and `long_description_content_type`\n        # keyword args to the `setup` function results in writing\n        # the description in the message payload of the `PKG-INFO` file\n        # in the `<distribution>.egg-info` directory.\n        self._setup_script_with_requires(\n            \"long_description='This is a long description\\\\nover multiple lines',\"\n            \"long_description_content_type='text/markdown',\"\n        )\n        environment.run_setup_py(\n            cmd=['egg_info'],\n            pypath=os.pathsep.join([env.paths['lib'], str(tmpdir_cwd)]),\n            data_stream=1,\n        )\n        egg_info_dir = os.path.join('.', 'foo.egg-info')\n        with open(os.path.join(egg_info_dir, 'PKG-INFO'), encoding=\"utf-8\") as fp:\n            pkg_info_lines = fp.read().split('\\n')\n        assert 'Metadata-Version: 2.2' in pkg_info_lines\n        assert '' == pkg_info_lines[-1]  # last line should be empty\n        long_desc_lines = pkg_info_lines[pkg_info_lines.index('') :]\n        assert 'This is a long description' in long_desc_lines\n        assert 'over multiple lines' in long_desc_lines\n\n    def test_project_urls(self, tmpdir_cwd, env):\n        # Test that specifying a `project_urls` dict to the `setup`\n        # function results in writing multiple `Project-URL` lines to\n        # the `PKG-INFO` file in the `<distribution>.egg-info`\n        # directory.\n        # `Project-URL` is described at https://packaging.python.org\n        #     /specifications/core-metadata/#project-url-multiple-use\n\n        self._setup_script_with_requires(\n            \"\"\"project_urls={\n                'Link One': 'https://example.com/one/',\n                'Link Two': 'https://example.com/two/',\n                },\"\"\"\n        )\n        environ = os.environ.copy().update(\n            HOME=env.paths['home'],\n        )\n        environment.run_setup_py(\n            cmd=['egg_info'],\n            pypath=os.pathsep.join([env.paths['lib'], str(tmpdir_cwd)]),\n            data_stream=1,\n            env=environ,\n        )\n        egg_info_dir = os.path.join('.', 'foo.egg-info')\n        with open(os.path.join(egg_info_dir, 'PKG-INFO'), encoding=\"utf-8\") as fp:\n            pkg_info_lines = fp.read().split('\\n')\n        expected_line = 'Project-URL: Link One, https://example.com/one/'\n        assert expected_line in pkg_info_lines\n        expected_line = 'Project-URL: Link Two, https://example.com/two/'\n        assert expected_line in pkg_info_lines\n        assert self._extract_mv_version(pkg_info_lines) >= (1, 2)\n\n    def test_license(self, tmpdir_cwd, env):\n        \"\"\"Test single line license.\"\"\"\n        self._setup_script_with_requires(\"license='MIT',\")\n        environment.run_setup_py(\n            cmd=['egg_info'],\n            pypath=os.pathsep.join([env.paths['lib'], str(tmpdir_cwd)]),\n            data_stream=1,\n        )\n        egg_info_dir = os.path.join('.', 'foo.egg-info')\n        with open(os.path.join(egg_info_dir, 'PKG-INFO'), encoding=\"utf-8\") as fp:\n            pkg_info_lines = fp.read().split('\\n')\n        assert 'License: MIT' in pkg_info_lines\n\n    def test_license_escape(self, tmpdir_cwd, env):\n        \"\"\"Test license is escaped correctly if longer than one line.\"\"\"\n        self._setup_script_with_requires(\n            \"license='This is a long license text \\\\nover multiple lines',\"\n        )\n        environment.run_setup_py(\n            cmd=['egg_info'],\n            pypath=os.pathsep.join([env.paths['lib'], str(tmpdir_cwd)]),\n            data_stream=1,\n        )\n        egg_info_dir = os.path.join('.', 'foo.egg-info')\n        with open(os.path.join(egg_info_dir, 'PKG-INFO'), encoding=\"utf-8\") as fp:\n            pkg_info_lines = fp.read().split('\\n')\n\n        assert 'License: This is a long license text ' in pkg_info_lines\n        assert '        over multiple lines' in pkg_info_lines\n        assert 'text \\n        over multiple' in '\\n'.join(pkg_info_lines)\n\n    def test_python_requires_egg_info(self, tmpdir_cwd, env):\n        self._setup_script_with_requires(\"\"\"python_requires='>=2.7.12',\"\"\")\n        environ = os.environ.copy().update(\n            HOME=env.paths['home'],\n        )\n        environment.run_setup_py(\n            cmd=['egg_info'],\n            pypath=os.pathsep.join([env.paths['lib'], str(tmpdir_cwd)]),\n            data_stream=1,\n            env=environ,\n        )\n        egg_info_dir = os.path.join('.', 'foo.egg-info')\n        with open(os.path.join(egg_info_dir, 'PKG-INFO'), encoding=\"utf-8\") as fp:\n            pkg_info_lines = fp.read().split('\\n')\n        assert 'Requires-Python: >=2.7.12' in pkg_info_lines\n        assert self._extract_mv_version(pkg_info_lines) >= (1, 2)\n\n    def test_manifest_maker_warning_suppression(self):\n        fixtures = [\n            \"standard file not found: should have one of foo.py, bar.py\",\n            \"standard file 'setup.py' not found\",\n        ]\n\n        for msg in fixtures:\n            assert manifest_maker._should_suppress_warning(msg)\n\n    def test_egg_info_includes_setup_py(self, tmpdir_cwd):\n        self._create_project()\n        dist = Distribution({\"name\": \"foo\", \"version\": \"0.0.1\"})\n        dist.script_name = \"non_setup.py\"\n        egg_info_instance = egg_info(dist)\n        egg_info_instance.finalize_options()\n        egg_info_instance.run()\n\n        assert 'setup.py' in egg_info_instance.filelist.files\n\n        with open(egg_info_instance.egg_info + \"/SOURCES.txt\", encoding=\"utf-8\") as f:\n            sources = f.read().split('\\n')\n            assert 'setup.py' in sources\n\n    def _run_egg_info_command(self, tmpdir_cwd, env, cmd=None, output=None):\n        environ = os.environ.copy().update(\n            HOME=env.paths['home'],\n        )\n        if cmd is None:\n            cmd = [\n                'egg_info',\n            ]\n        code, data = environment.run_setup_py(\n            cmd=cmd,\n            pypath=os.pathsep.join([env.paths['lib'], str(tmpdir_cwd)]),\n            data_stream=1,\n            env=environ,\n        )\n        assert not code, data\n\n        if output:\n            assert output in data\n\n    def test_egg_info_tag_only_once(self, tmpdir_cwd, env):\n        self._create_project()\n        path.build({\n            'setup.cfg': DALS(\n                \"\"\"\n                              [egg_info]\n                              tag_build = dev\n                              tag_date = 0\n                              tag_svn_revision = 0\n                              \"\"\"\n            ),\n        })\n        self._run_egg_info_command(tmpdir_cwd, env)\n        egg_info_dir = os.path.join('.', 'foo.egg-info')\n        with open(os.path.join(egg_info_dir, 'PKG-INFO'), encoding=\"utf-8\") as fp:\n            pkg_info_lines = fp.read().split('\\n')\n        assert 'Version: 0.0.0.dev0' in pkg_info_lines\n\n\nclass TestWriteEntries:\n    def test_invalid_entry_point(self, tmpdir_cwd, env):\n        dist = Distribution({\"name\": \"foo\", \"version\": \"0.0.1\"})\n        dist.entry_points = {\"foo\": \"foo = invalid-identifier:foo\"}\n        cmd = dist.get_command_obj(\"egg_info\")\n        expected_msg = r\"Problems to parse .*invalid-identifier.*\"\n        with pytest.raises(errors.OptionError, match=expected_msg) as ex:\n            write_entries(cmd, \"entry_points\", \"entry_points.txt\")\n            assert \"ensure entry-point follows the spec\" in ex.value.args[0]\n\n    def test_valid_entry_point(self, tmpdir_cwd, env):\n        dist = Distribution({\"name\": \"foo\", \"version\": \"0.0.1\"})\n        dist.entry_points = {\n            \"abc\": \"foo = bar:baz\",\n            \"def\": [\"faa = bor:boz\"],\n        }\n        cmd = dist.get_command_obj(\"egg_info\")\n        write_entries(cmd, \"entry_points\", \"entry_points.txt\")\n        content = Path(\"entry_points.txt\").read_text(encoding=\"utf-8\")\n        assert \"[abc]\\nfoo = bar:baz\\n\" in content\n        assert \"[def]\\nfaa = bor:boz\\n\" in content\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_extern.py","size":296,"sha1":"d8378d8b48eba72dc441111e105d623a811cac95","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import importlib\nimport pickle\n\nimport packaging\n\nfrom setuptools import Distribution\n\n\ndef test_reimport_extern():\n    packaging2 = importlib.import_module(packaging.__name__)\n    assert packaging is packaging2\n\n\ndef test_distribution_picklable():\n    pickle.loads(pickle.dumps(Distribution()))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_find_packages.py","size":7819,"sha1":"ccb9833dc8eb3da33d4ae01c8834607ea889f823","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for automatic package discovery\"\"\"\n\nimport os\nimport shutil\nimport tempfile\n\nimport pytest\n\nfrom setuptools import find_namespace_packages, find_packages\nfrom setuptools.discovery import FlatLayoutPackageFinder\n\nfrom .compat.py39 import os_helper\n\n\nclass TestFindPackages:\n    def setup_method(self, method):\n        self.dist_dir = tempfile.mkdtemp()\n        self._make_pkg_structure()\n\n    def teardown_method(self, method):\n        shutil.rmtree(self.dist_dir)\n\n    def _make_pkg_structure(self):\n        \"\"\"Make basic package structure.\n\n        dist/\n            docs/\n                conf.py\n            pkg/\n                __pycache__/\n                nspkg/\n                    mod.py\n                subpkg/\n                    assets/\n                        asset\n                    __init__.py\n            setup.py\n\n        \"\"\"\n        self.docs_dir = self._mkdir('docs', self.dist_dir)\n        self._touch('conf.py', self.docs_dir)\n        self.pkg_dir = self._mkdir('pkg', self.dist_dir)\n        self._mkdir('__pycache__', self.pkg_dir)\n        self.ns_pkg_dir = self._mkdir('nspkg', self.pkg_dir)\n        self._touch('mod.py', self.ns_pkg_dir)\n        self.sub_pkg_dir = self._mkdir('subpkg', self.pkg_dir)\n        self.asset_dir = self._mkdir('assets', self.sub_pkg_dir)\n        self._touch('asset', self.asset_dir)\n        self._touch('__init__.py', self.sub_pkg_dir)\n        self._touch('setup.py', self.dist_dir)\n\n    def _mkdir(self, path, parent_dir=None):\n        if parent_dir:\n            path = os.path.join(parent_dir, path)\n        os.mkdir(path)\n        return path\n\n    def _touch(self, path, dir_=None):\n        if dir_:\n            path = os.path.join(dir_, path)\n        open(path, 'wb').close()\n        return path\n\n    def test_regular_package(self):\n        self._touch('__init__.py', self.pkg_dir)\n        packages = find_packages(self.dist_dir)\n        assert packages == ['pkg', 'pkg.subpkg']\n\n    def test_exclude(self):\n        self._touch('__init__.py', self.pkg_dir)\n        packages = find_packages(self.dist_dir, exclude=('pkg.*',))\n        assert packages == ['pkg']\n\n    def test_exclude_recursive(self):\n        \"\"\"\n        Excluding a parent package should not exclude child packages as well.\n        \"\"\"\n        self._touch('__init__.py', self.pkg_dir)\n        self._touch('__init__.py', self.sub_pkg_dir)\n        packages = find_packages(self.dist_dir, exclude=('pkg',))\n        assert packages == ['pkg.subpkg']\n\n    def test_include_excludes_other(self):\n        \"\"\"\n        If include is specified, other packages should be excluded.\n        \"\"\"\n        self._touch('__init__.py', self.pkg_dir)\n        alt_dir = self._mkdir('other_pkg', self.dist_dir)\n        self._touch('__init__.py', alt_dir)\n        packages = find_packages(self.dist_dir, include=['other_pkg'])\n        assert packages == ['other_pkg']\n\n    def test_dir_with_dot_is_skipped(self):\n        shutil.rmtree(os.path.join(self.dist_dir, 'pkg/subpkg/assets'))\n        data_dir = self._mkdir('some.data', self.pkg_dir)\n        self._touch('__init__.py', data_dir)\n        self._touch('file.dat', data_dir)\n        packages = find_packages(self.dist_dir)\n        assert 'pkg.some.data' not in packages\n\n    def test_dir_with_packages_in_subdir_is_excluded(self):\n        \"\"\"\n        Ensure that a package in a non-package such as build/pkg/__init__.py\n        is excluded.\n        \"\"\"\n        build_dir = self._mkdir('build', self.dist_dir)\n        build_pkg_dir = self._mkdir('pkg', build_dir)\n        self._touch('__init__.py', build_pkg_dir)\n        packages = find_packages(self.dist_dir)\n        assert 'build.pkg' not in packages\n\n    @pytest.mark.skipif(not os_helper.can_symlink(), reason='Symlink support required')\n    def test_symlinked_packages_are_included(self):\n        \"\"\"\n        A symbolically-linked directory should be treated like any other\n        directory when matched as a package.\n\n        Create a link from lpkg -> pkg.\n        \"\"\"\n        self._touch('__init__.py', self.pkg_dir)\n        linked_pkg = os.path.join(self.dist_dir, 'lpkg')\n        os.symlink('pkg', linked_pkg)\n        assert os.path.isdir(linked_pkg)\n        packages = find_packages(self.dist_dir)\n        assert 'lpkg' in packages\n\n    def _assert_packages(self, actual, expected):\n        assert set(actual) == set(expected)\n\n    def test_pep420_ns_package(self):\n        packages = find_namespace_packages(\n            self.dist_dir, include=['pkg*'], exclude=['pkg.subpkg.assets']\n        )\n        self._assert_packages(packages, ['pkg', 'pkg.nspkg', 'pkg.subpkg'])\n\n    def test_pep420_ns_package_no_includes(self):\n        packages = find_namespace_packages(self.dist_dir, exclude=['pkg.subpkg.assets'])\n        self._assert_packages(packages, ['docs', 'pkg', 'pkg.nspkg', 'pkg.subpkg'])\n\n    def test_pep420_ns_package_no_includes_or_excludes(self):\n        packages = find_namespace_packages(self.dist_dir)\n        expected = ['docs', 'pkg', 'pkg.nspkg', 'pkg.subpkg', 'pkg.subpkg.assets']\n        self._assert_packages(packages, expected)\n\n    def test_regular_package_with_nested_pep420_ns_packages(self):\n        self._touch('__init__.py', self.pkg_dir)\n        packages = find_namespace_packages(\n            self.dist_dir, exclude=['docs', 'pkg.subpkg.assets']\n        )\n        self._assert_packages(packages, ['pkg', 'pkg.nspkg', 'pkg.subpkg'])\n\n    def test_pep420_ns_package_no_non_package_dirs(self):\n        shutil.rmtree(self.docs_dir)\n        shutil.rmtree(os.path.join(self.dist_dir, 'pkg/subpkg/assets'))\n        packages = find_namespace_packages(self.dist_dir)\n        self._assert_packages(packages, ['pkg', 'pkg.nspkg', 'pkg.subpkg'])\n\n\nclass TestFlatLayoutPackageFinder:\n    EXAMPLES = {\n        \"hidden-folders\": (\n            [\".pkg/__init__.py\", \"pkg/__init__.py\", \"pkg/nested/file.txt\"],\n            [\"pkg\", \"pkg.nested\"],\n        ),\n        \"private-packages\": (\n            [\"_pkg/__init__.py\", \"pkg/_private/__init__.py\"],\n            [\"pkg\", \"pkg._private\"],\n        ),\n        \"invalid-name\": (\n            [\"invalid-pkg/__init__.py\", \"other.pkg/__init__.py\", \"yet,another/file.py\"],\n            [],\n        ),\n        \"docs\": ([\"pkg/__init__.py\", \"docs/conf.py\", \"docs/readme.rst\"], [\"pkg\"]),\n        \"tests\": (\n            [\"pkg/__init__.py\", \"tests/test_pkg.py\", \"tests/__init__.py\"],\n            [\"pkg\"],\n        ),\n        \"examples\": (\n            [\n                \"pkg/__init__.py\",\n                \"examples/__init__.py\",\n                \"examples/file.py\",\n                \"example/other_file.py\",\n                # Sub-packages should always be fine\n                \"pkg/example/__init__.py\",\n                \"pkg/examples/__init__.py\",\n            ],\n            [\"pkg\", \"pkg.examples\", \"pkg.example\"],\n        ),\n        \"tool-specific\": (\n            [\n                \"htmlcov/index.html\",\n                \"pkg/__init__.py\",\n                \"tasks/__init__.py\",\n                \"tasks/subpackage/__init__.py\",\n                \"fabfile/__init__.py\",\n                \"fabfile/subpackage/__init__.py\",\n                # Sub-packages should always be fine\n                \"pkg/tasks/__init__.py\",\n                \"pkg/fabfile/__init__.py\",\n            ],\n            [\"pkg\", \"pkg.tasks\", \"pkg.fabfile\"],\n        ),\n    }\n\n    @pytest.mark.parametrize(\"example\", EXAMPLES.keys())\n    def test_unwanted_directories_not_included(self, tmp_path, example):\n        files, expected_packages = self.EXAMPLES[example]\n        ensure_files(tmp_path, files)\n        found_packages = FlatLayoutPackageFinder.find(str(tmp_path))\n        assert set(found_packages) == set(expected_packages)\n\n\ndef ensure_files(root_path, files):\n    for file in files:\n        path = root_path / file\n        path.parent.mkdir(parents=True, exist_ok=True)\n        path.touch()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_find_py_modules.py","size":2404,"sha1":"cc95f2ae6977aa91ed9677b6bfc9951dc214e5b0","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for automatic discovery of modules\"\"\"\n\nimport os\n\nimport pytest\n\nfrom setuptools.discovery import FlatLayoutModuleFinder, ModuleFinder\n\nfrom .compat.py39 import os_helper\nfrom .test_find_packages import ensure_files\n\n\nclass TestModuleFinder:\n    def find(self, path, *args, **kwargs):\n        return set(ModuleFinder.find(str(path), *args, **kwargs))\n\n    EXAMPLES = {\n        # circumstance: (files, kwargs, expected_modules)\n        \"simple_folder\": (\n            [\"file.py\", \"other.py\"],\n            {},  # kwargs\n            [\"file\", \"other\"],\n        ),\n        \"exclude\": (\n            [\"file.py\", \"other.py\"],\n            {\"exclude\": [\"f*\"]},\n            [\"other\"],\n        ),\n        \"include\": (\n            [\"file.py\", \"fole.py\", \"other.py\"],\n            {\"include\": [\"f*\"], \"exclude\": [\"fo*\"]},\n            [\"file\"],\n        ),\n        \"invalid-name\": ([\"my-file.py\", \"other.file.py\"], {}, []),\n    }\n\n    @pytest.mark.parametrize(\"example\", EXAMPLES.keys())\n    def test_finder(self, tmp_path, example):\n        files, kwargs, expected_modules = self.EXAMPLES[example]\n        ensure_files(tmp_path, files)\n        assert self.find(tmp_path, **kwargs) == set(expected_modules)\n\n    @pytest.mark.skipif(not os_helper.can_symlink(), reason='Symlink support required')\n    def test_symlinked_packages_are_included(self, tmp_path):\n        src = \"_myfiles/file.py\"\n        ensure_files(tmp_path, [src])\n        os.symlink(tmp_path / src, tmp_path / \"link.py\")\n        assert self.find(tmp_path) == {\"link\"}\n\n\nclass TestFlatLayoutModuleFinder:\n    def find(self, path, *args, **kwargs):\n        return set(FlatLayoutModuleFinder.find(str(path)))\n\n    EXAMPLES = {\n        # circumstance: (files, expected_modules)\n        \"hidden-files\": ([\".module.py\"], []),\n        \"private-modules\": ([\"_module.py\"], []),\n        \"common-names\": (\n            [\"setup.py\", \"conftest.py\", \"test.py\", \"tests.py\", \"example.py\", \"mod.py\"],\n            [\"mod\"],\n        ),\n        \"tool-specific\": (\n            [\"tasks.py\", \"fabfile.py\", \"noxfile.py\", \"dodo.py\", \"manage.py\", \"mod.py\"],\n            [\"mod\"],\n        ),\n    }\n\n    @pytest.mark.parametrize(\"example\", EXAMPLES.keys())\n    def test_unwanted_files_not_included(self, tmp_path, example):\n        files, expected_modules = self.EXAMPLES[example]\n        ensure_files(tmp_path, files)\n        assert self.find(tmp_path) == set(expected_modules)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_glob.py","size":887,"sha1":"a4f9a8259daac9cb780773a3f14c0fd6a341c4bd","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import pytest\nfrom jaraco import path\n\nfrom setuptools.glob import glob\n\n\n@pytest.mark.parametrize(\n    ('tree', 'pattern', 'matches'),\n    (\n        ('', b'', []),\n        ('', '', []),\n        (\n            \"\"\"\n     appveyor.yml\n     CHANGES.rst\n     LICENSE\n     MANIFEST.in\n     pyproject.toml\n     README.rst\n     setup.cfg\n     setup.py\n     \"\"\",\n            '*.rst',\n            ('CHANGES.rst', 'README.rst'),\n        ),\n        (\n            \"\"\"\n     appveyor.yml\n     CHANGES.rst\n     LICENSE\n     MANIFEST.in\n     pyproject.toml\n     README.rst\n     setup.cfg\n     setup.py\n     \"\"\",\n            b'*.rst',\n            (b'CHANGES.rst', b'README.rst'),\n        ),\n    ),\n)\ndef test_glob(monkeypatch, tmpdir, tree, pattern, matches):\n    monkeypatch.chdir(tmpdir)\n    path.build({name: '' for name in tree.split()})\n    assert list(sorted(glob(pattern))) == list(sorted(matches))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_install_scripts.py","size":3433,"sha1":"5a1495b1c425b73da42f8e62bba715e0d052f63d","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"install_scripts tests\"\"\"\n\nimport sys\n\nimport pytest\n\nfrom setuptools.command.install_scripts import install_scripts\nfrom setuptools.dist import Distribution\n\nfrom . import contexts\n\n\nclass TestInstallScripts:\n    settings = dict(\n        name='foo',\n        entry_points={'console_scripts': ['foo=foo:foo']},\n        version='0.0',\n    )\n    unix_exe = '/usr/dummy-test-path/local/bin/python'\n    unix_spaces_exe = '/usr/bin/env dummy-test-python'\n    win32_exe = 'C:\\\\Dummy Test Path\\\\Program Files\\\\Python 3.6\\\\python.exe'\n\n    def _run_install_scripts(self, install_dir, executable=None):\n        dist = Distribution(self.settings)\n        dist.script_name = 'setup.py'\n        cmd = install_scripts(dist)\n        cmd.install_dir = install_dir\n        if executable is not None:\n            bs = cmd.get_finalized_command('build_scripts')\n            bs.executable = executable\n        cmd.ensure_finalized()\n        with contexts.quiet():\n            cmd.run()\n\n    @pytest.mark.skipif(sys.platform == 'win32', reason='non-Windows only')\n    def test_sys_executable_escaping_unix(self, tmpdir, monkeypatch):\n        \"\"\"\n        Ensure that shebang is not quoted on Unix when getting the Python exe\n        from sys.executable.\n        \"\"\"\n        expected = f'#!{self.unix_exe}\\n'\n        monkeypatch.setattr('sys.executable', self.unix_exe)\n        with tmpdir.as_cwd():\n            self._run_install_scripts(str(tmpdir))\n            with open(str(tmpdir.join('foo')), 'r', encoding=\"utf-8\") as f:\n                actual = f.readline()\n        assert actual == expected\n\n    @pytest.mark.skipif(sys.platform != 'win32', reason='Windows only')\n    def test_sys_executable_escaping_win32(self, tmpdir, monkeypatch):\n        \"\"\"\n        Ensure that shebang is quoted on Windows when getting the Python exe\n        from sys.executable and it contains a space.\n        \"\"\"\n        expected = f'#!\"{self.win32_exe}\"\\n'\n        monkeypatch.setattr('sys.executable', self.win32_exe)\n        with tmpdir.as_cwd():\n            self._run_install_scripts(str(tmpdir))\n            with open(str(tmpdir.join('foo-script.py')), 'r', encoding=\"utf-8\") as f:\n                actual = f.readline()\n        assert actual == expected\n\n    @pytest.mark.skipif(sys.platform == 'win32', reason='non-Windows only')\n    def test_executable_with_spaces_escaping_unix(self, tmpdir):\n        \"\"\"\n        Ensure that shebang on Unix is not quoted, even when\n        a value with spaces\n        is specified using --executable.\n        \"\"\"\n        expected = f'#!{self.unix_spaces_exe}\\n'\n        with tmpdir.as_cwd():\n            self._run_install_scripts(str(tmpdir), self.unix_spaces_exe)\n            with open(str(tmpdir.join('foo')), 'r', encoding=\"utf-8\") as f:\n                actual = f.readline()\n        assert actual == expected\n\n    @pytest.mark.skipif(sys.platform != 'win32', reason='Windows only')\n    def test_executable_arg_escaping_win32(self, tmpdir):\n        \"\"\"\n        Ensure that shebang on Windows is quoted when\n        getting a path with spaces\n        from --executable, that is itself properly quoted.\n        \"\"\"\n        expected = f'#!\"{self.win32_exe}\"\\n'\n        with tmpdir.as_cwd():\n            self._run_install_scripts(str(tmpdir), '\"' + self.win32_exe + '\"')\n            with open(str(tmpdir.join('foo-script.py')), 'r', encoding=\"utf-8\") as f:\n                actual = f.readline()\n        assert actual == expected\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_logging.py","size":2099,"sha1":"d64a0407a72f34a3b24b8ffee6eb1ab10fbcd165","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import functools\nimport inspect\nimport logging\nimport sys\n\nimport pytest\n\nIS_PYPY = '__pypy__' in sys.builtin_module_names\n\n\nsetup_py = \"\"\"\\\nfrom setuptools import setup\n\nsetup(\n    name=\"test_logging\",\n    version=\"0.0\"\n)\n\"\"\"\n\n\n@pytest.mark.parametrize(\n    ('flag', 'expected_level'), [(\"--dry-run\", \"INFO\"), (\"--verbose\", \"DEBUG\")]\n)\ndef test_verbosity_level(tmp_path, monkeypatch, flag, expected_level):\n    \"\"\"Make sure the correct verbosity level is set (issue #3038)\"\"\"\n    import setuptools  # noqa: F401  # import setuptools to monkeypatch distutils\n\n    import distutils  # <- load distutils after all the patches take place\n\n    logger = logging.Logger(__name__)\n    monkeypatch.setattr(logging, \"root\", logger)\n    unset_log_level = logger.getEffectiveLevel()\n    assert logging.getLevelName(unset_log_level) == \"NOTSET\"\n\n    setup_script = tmp_path / \"setup.py\"\n    setup_script.write_text(setup_py, encoding=\"utf-8\")\n    dist = distutils.core.run_setup(setup_script, stop_after=\"init\")\n    dist.script_args = [flag, \"sdist\"]\n    dist.parse_command_line()  # <- where the log level is set\n    log_level = logger.getEffectiveLevel()\n    log_level_name = logging.getLevelName(log_level)\n    assert log_level_name == expected_level\n\n\ndef flaky_on_pypy(func):\n    @functools.wraps(func)\n    def _func():\n        try:\n            func()\n        except AssertionError:  # pragma: no cover\n            if IS_PYPY:\n                msg = \"Flaky monkeypatch on PyPy (#4124)\"\n                pytest.xfail(f\"{msg}. Original discussion in #3707, #3709.\")\n            raise\n\n    return _func\n\n\n@flaky_on_pypy\ndef test_patching_does_not_cause_problems():\n    # Ensure `dist.log` is only patched if necessary\n\n    import _distutils_hack\n\n    import setuptools.logging\n\n    from distutils import dist\n\n    setuptools.logging.configure()\n\n    if _distutils_hack.enabled():\n        # Modern logging infra, no problematic patching.\n        assert dist.__file__ is None or \"setuptools\" in dist.__file__\n        assert isinstance(dist.log, logging.Logger)\n    else:\n        assert inspect.ismodule(dist.log)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_manifest.py","size":18562,"sha1":"30c4d6e8b10589f1ff0ea1991f3549e2f96ac9b5","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"sdist tests\"\"\"\n\nfrom __future__ import annotations\n\nimport contextlib\nimport io\nimport itertools\nimport logging\nimport os\nimport shutil\nimport sys\nimport tempfile\n\nimport pytest\n\nfrom setuptools.command.egg_info import FileList, egg_info, translate_pattern\nfrom setuptools.dist import Distribution\nfrom setuptools.tests.textwrap import DALS\n\nfrom distutils import log\nfrom distutils.errors import DistutilsTemplateError\n\nIS_PYPY = '__pypy__' in sys.builtin_module_names\n\n\ndef make_local_path(s):\n    \"\"\"Converts '/' in a string to os.sep\"\"\"\n    return s.replace('/', os.sep)\n\n\nSETUP_ATTRS = {\n    'name': 'app',\n    'version': '0.0',\n    'packages': ['app'],\n}\n\nSETUP_PY = f\"\"\"\\\nfrom setuptools import setup\n\nsetup(**{SETUP_ATTRS!r})\n\"\"\"\n\n\n@contextlib.contextmanager\ndef quiet():\n    old_stdout, old_stderr = sys.stdout, sys.stderr\n    sys.stdout, sys.stderr = io.StringIO(), io.StringIO()\n    try:\n        yield\n    finally:\n        sys.stdout, sys.stderr = old_stdout, old_stderr\n\n\ndef touch(filename):\n    open(filename, 'wb').close()\n\n\n# The set of files always in the manifest, including all files in the\n# .egg-info directory\ndefault_files = frozenset(\n    map(\n        make_local_path,\n        [\n            'README.rst',\n            'MANIFEST.in',\n            'setup.py',\n            'app.egg-info/PKG-INFO',\n            'app.egg-info/SOURCES.txt',\n            'app.egg-info/dependency_links.txt',\n            'app.egg-info/top_level.txt',\n            'app/__init__.py',\n        ],\n    )\n)\n\n\ntranslate_specs: list[tuple[str, list[str], list[str]]] = [\n    ('foo', ['foo'], ['bar', 'foobar']),\n    ('foo/bar', ['foo/bar'], ['foo/bar/baz', './foo/bar', 'foo']),\n    # Glob matching\n    ('*.txt', ['foo.txt', 'bar.txt'], ['foo/foo.txt']),\n    ('dir/*.txt', ['dir/foo.txt', 'dir/bar.txt', 'dir/.txt'], ['notdir/foo.txt']),\n    ('*/*.py', ['bin/start.py'], []),\n    ('docs/page-?.txt', ['docs/page-9.txt'], ['docs/page-10.txt']),\n    # Globstars change what they mean depending upon where they are\n    (\n        'foo/**/bar',\n        ['foo/bing/bar', 'foo/bing/bang/bar', 'foo/bar'],\n        ['foo/abar'],\n    ),\n    (\n        'foo/**',\n        ['foo/bar/bing.py', 'foo/x'],\n        ['/foo/x'],\n    ),\n    (\n        '**',\n        ['x', 'abc/xyz', '@nything'],\n        [],\n    ),\n    # Character classes\n    (\n        'pre[one]post',\n        ['preopost', 'prenpost', 'preepost'],\n        ['prepost', 'preonepost'],\n    ),\n    (\n        'hello[!one]world',\n        ['helloxworld', 'helloyworld'],\n        ['hellooworld', 'helloworld', 'hellooneworld'],\n    ),\n    (\n        '[]one].txt',\n        ['o.txt', '].txt', 'e.txt'],\n        ['one].txt'],\n    ),\n    (\n        'foo[!]one]bar',\n        ['fooybar'],\n        ['foo]bar', 'fooobar', 'fooebar'],\n    ),\n]\n\"\"\"\nA spec of inputs for 'translate_pattern' and matches and mismatches\nfor that input.\n\"\"\"\n\nmatch_params = itertools.chain.from_iterable(\n    zip(itertools.repeat(pattern), matches)\n    for pattern, matches, mismatches in translate_specs\n)\n\n\n@pytest.fixture(params=match_params)\ndef pattern_match(request):\n    return map(make_local_path, request.param)\n\n\nmismatch_params = itertools.chain.from_iterable(\n    zip(itertools.repeat(pattern), mismatches)\n    for pattern, matches, mismatches in translate_specs\n)\n\n\n@pytest.fixture(params=mismatch_params)\ndef pattern_mismatch(request):\n    return map(make_local_path, request.param)\n\n\ndef test_translated_pattern_match(pattern_match):\n    pattern, target = pattern_match\n    assert translate_pattern(pattern).match(target)\n\n\ndef test_translated_pattern_mismatch(pattern_mismatch):\n    pattern, target = pattern_mismatch\n    assert not translate_pattern(pattern).match(target)\n\n\nclass TempDirTestCase:\n    def setup_method(self, method):\n        self.temp_dir = tempfile.mkdtemp()\n        self.old_cwd = os.getcwd()\n        os.chdir(self.temp_dir)\n\n    def teardown_method(self, method):\n        os.chdir(self.old_cwd)\n        shutil.rmtree(self.temp_dir)\n\n\nclass TestManifestTest(TempDirTestCase):\n    def setup_method(self, method):\n        super().setup_method(method)\n\n        f = open(os.path.join(self.temp_dir, 'setup.py'), 'w', encoding=\"utf-8\")\n        f.write(SETUP_PY)\n        f.close()\n        \"\"\"\n        Create a file tree like:\n        - LICENSE\n        - README.rst\n        - testing.rst\n        - .hidden.rst\n        - app/\n            - __init__.py\n            - a.txt\n            - b.txt\n            - c.rst\n            - static/\n                - app.js\n                - app.js.map\n                - app.css\n                - app.css.map\n        \"\"\"\n\n        for fname in ['README.rst', '.hidden.rst', 'testing.rst', 'LICENSE']:\n            touch(os.path.join(self.temp_dir, fname))\n\n        # Set up the rest of the test package\n        test_pkg = os.path.join(self.temp_dir, 'app')\n        os.mkdir(test_pkg)\n        for fname in ['__init__.py', 'a.txt', 'b.txt', 'c.rst']:\n            touch(os.path.join(test_pkg, fname))\n\n        # Some compiled front-end assets to include\n        static = os.path.join(test_pkg, 'static')\n        os.mkdir(static)\n        for fname in ['app.js', 'app.js.map', 'app.css', 'app.css.map']:\n            touch(os.path.join(static, fname))\n\n    def make_manifest(self, contents):\n        \"\"\"Write a MANIFEST.in.\"\"\"\n        manifest = os.path.join(self.temp_dir, 'MANIFEST.in')\n        with open(manifest, 'w', encoding=\"utf-8\") as f:\n            f.write(DALS(contents))\n\n    def get_files(self):\n        \"\"\"Run egg_info and get all the files to include, as a set\"\"\"\n        dist = Distribution(SETUP_ATTRS)\n        dist.script_name = 'setup.py'\n        cmd = egg_info(dist)\n        cmd.ensure_finalized()\n\n        cmd.run()\n\n        return set(cmd.filelist.files)\n\n    def test_no_manifest(self):\n        \"\"\"Check a missing MANIFEST.in includes only the standard files.\"\"\"\n        assert (default_files - set(['MANIFEST.in'])) == self.get_files()\n\n    def test_empty_files(self):\n        \"\"\"Check an empty MANIFEST.in includes only the standard files.\"\"\"\n        self.make_manifest(\"\")\n        assert default_files == self.get_files()\n\n    def test_include(self):\n        \"\"\"Include extra rst files in the project root.\"\"\"\n        self.make_manifest(\"include *.rst\")\n        files = default_files | set(['testing.rst', '.hidden.rst'])\n        assert files == self.get_files()\n\n    def test_exclude(self):\n        \"\"\"Include everything in app/ except the text files\"\"\"\n        ml = make_local_path\n        self.make_manifest(\n            \"\"\"\n            include app/*\n            exclude app/*.txt\n            \"\"\"\n        )\n        files = default_files | set([ml('app/c.rst')])\n        assert files == self.get_files()\n\n    def test_include_multiple(self):\n        \"\"\"Include with multiple patterns.\"\"\"\n        ml = make_local_path\n        self.make_manifest(\"include app/*.txt app/static/*\")\n        files = default_files | set([\n            ml('app/a.txt'),\n            ml('app/b.txt'),\n            ml('app/static/app.js'),\n            ml('app/static/app.js.map'),\n            ml('app/static/app.css'),\n            ml('app/static/app.css.map'),\n        ])\n        assert files == self.get_files()\n\n    def test_graft(self):\n        \"\"\"Include the whole app/static/ directory.\"\"\"\n        ml = make_local_path\n        self.make_manifest(\"graft app/static\")\n        files = default_files | set([\n            ml('app/static/app.js'),\n            ml('app/static/app.js.map'),\n            ml('app/static/app.css'),\n            ml('app/static/app.css.map'),\n        ])\n        assert files == self.get_files()\n\n    def test_graft_glob_syntax(self):\n        \"\"\"Include the whole app/static/ directory.\"\"\"\n        ml = make_local_path\n        self.make_manifest(\"graft */static\")\n        files = default_files | set([\n            ml('app/static/app.js'),\n            ml('app/static/app.js.map'),\n            ml('app/static/app.css'),\n            ml('app/static/app.css.map'),\n        ])\n        assert files == self.get_files()\n\n    def test_graft_global_exclude(self):\n        \"\"\"Exclude all *.map files in the project.\"\"\"\n        ml = make_local_path\n        self.make_manifest(\n            \"\"\"\n            graft app/static\n            global-exclude *.map\n            \"\"\"\n        )\n        files = default_files | set([ml('app/static/app.js'), ml('app/static/app.css')])\n        assert files == self.get_files()\n\n    def test_global_include(self):\n        \"\"\"Include all *.rst, *.js, and *.css files in the whole tree.\"\"\"\n        ml = make_local_path\n        self.make_manifest(\n            \"\"\"\n            global-include *.rst *.js *.css\n            \"\"\"\n        )\n        files = default_files | set([\n            '.hidden.rst',\n            'testing.rst',\n            ml('app/c.rst'),\n            ml('app/static/app.js'),\n            ml('app/static/app.css'),\n        ])\n        assert files == self.get_files()\n\n    def test_graft_prune(self):\n        \"\"\"Include all files in app/, except for the whole app/static/ dir.\"\"\"\n        ml = make_local_path\n        self.make_manifest(\n            \"\"\"\n            graft app\n            prune app/static\n            \"\"\"\n        )\n        files = default_files | set([ml('app/a.txt'), ml('app/b.txt'), ml('app/c.rst')])\n        assert files == self.get_files()\n\n\nclass TestFileListTest(TempDirTestCase):\n    \"\"\"\n    A copy of the relevant bits of distutils/tests/test_filelist.py,\n    to ensure setuptools' version of FileList keeps parity with distutils.\n    \"\"\"\n\n    @pytest.fixture(autouse=os.getenv(\"SETUPTOOLS_USE_DISTUTILS\") == \"stdlib\")\n    def _compat_record_logs(self, monkeypatch, caplog):\n        \"\"\"Account for stdlib compatibility\"\"\"\n\n        def _log(_logger, level, msg, args):\n            exc = sys.exc_info()\n            rec = logging.LogRecord(\"distutils\", level, \"\", 0, msg, args, exc)\n            caplog.records.append(rec)\n\n        monkeypatch.setattr(log.Log, \"_log\", _log)\n\n    def get_records(self, caplog, *levels):\n        return [r for r in caplog.records if r.levelno in levels]\n\n    def assertNoWarnings(self, caplog):\n        assert self.get_records(caplog, log.WARN) == []\n        caplog.clear()\n\n    def assertWarnings(self, caplog):\n        if IS_PYPY and not caplog.records:\n            pytest.xfail(\"caplog checks may not work well in PyPy\")\n        else:\n            assert len(self.get_records(caplog, log.WARN)) > 0\n            caplog.clear()\n\n    def make_files(self, files):\n        for file in files:\n            file = os.path.join(self.temp_dir, file)\n            dirname, _basename = os.path.split(file)\n            os.makedirs(dirname, exist_ok=True)\n            touch(file)\n\n    def test_process_template_line(self):\n        # testing  all MANIFEST.in template patterns\n        file_list = FileList()\n        ml = make_local_path\n\n        # simulated file list\n        self.make_files([\n            'foo.tmp',\n            'ok',\n            'xo',\n            'four.txt',\n            'buildout.cfg',\n            # filelist does not filter out VCS directories,\n            # it's sdist that does\n            ml('.hg/last-message.txt'),\n            ml('global/one.txt'),\n            ml('global/two.txt'),\n            ml('global/files.x'),\n            ml('global/here.tmp'),\n            ml('f/o/f.oo'),\n            ml('dir/graft-one'),\n            ml('dir/dir2/graft2'),\n            ml('dir3/ok'),\n            ml('dir3/sub/ok.txt'),\n        ])\n\n        MANIFEST_IN = DALS(\n            \"\"\"\\\n        include ok\n        include xo\n        exclude xo\n        include foo.tmp\n        include buildout.cfg\n        global-include *.x\n        global-include *.txt\n        global-exclude *.tmp\n        recursive-include f *.oo\n        recursive-exclude global *.x\n        graft dir\n        prune dir3\n        \"\"\"\n        )\n\n        for line in MANIFEST_IN.split('\\n'):\n            if not line:\n                continue\n            file_list.process_template_line(line)\n\n        wanted = [\n            'buildout.cfg',\n            'four.txt',\n            'ok',\n            ml('.hg/last-message.txt'),\n            ml('dir/graft-one'),\n            ml('dir/dir2/graft2'),\n            ml('f/o/f.oo'),\n            ml('global/one.txt'),\n            ml('global/two.txt'),\n        ]\n\n        file_list.sort()\n        assert file_list.files == wanted\n\n    def test_exclude_pattern(self):\n        # return False if no match\n        file_list = FileList()\n        assert not file_list.exclude_pattern('*.py')\n\n        # return True if files match\n        file_list = FileList()\n        file_list.files = ['a.py', 'b.py']\n        assert file_list.exclude_pattern('*.py')\n\n        # test excludes\n        file_list = FileList()\n        file_list.files = ['a.py', 'a.txt']\n        file_list.exclude_pattern('*.py')\n        file_list.sort()\n        assert file_list.files == ['a.txt']\n\n    def test_include_pattern(self):\n        # return False if no match\n        file_list = FileList()\n        self.make_files([])\n        assert not file_list.include_pattern('*.py')\n\n        # return True if files match\n        file_list = FileList()\n        self.make_files(['a.py', 'b.txt'])\n        assert file_list.include_pattern('*.py')\n\n        # test * matches all files\n        file_list = FileList()\n        self.make_files(['a.py', 'b.txt'])\n        file_list.include_pattern('*')\n        file_list.sort()\n        assert file_list.files == ['a.py', 'b.txt']\n\n    def test_process_template_line_invalid(self):\n        # invalid lines\n        file_list = FileList()\n        for action in (\n            'include',\n            'exclude',\n            'global-include',\n            'global-exclude',\n            'recursive-include',\n            'recursive-exclude',\n            'graft',\n            'prune',\n            'blarg',\n        ):\n            with pytest.raises(DistutilsTemplateError):\n                file_list.process_template_line(action)\n\n    def test_include(self, caplog):\n        caplog.set_level(logging.DEBUG)\n        ml = make_local_path\n        # include\n        file_list = FileList()\n        self.make_files(['a.py', 'b.txt', ml('d/c.py')])\n\n        file_list.process_template_line('include *.py')\n        file_list.sort()\n        assert file_list.files == ['a.py']\n        self.assertNoWarnings(caplog)\n\n        file_list.process_template_line('include *.rb')\n        file_list.sort()\n        assert file_list.files == ['a.py']\n        self.assertWarnings(caplog)\n\n    def test_exclude(self, caplog):\n        caplog.set_level(logging.DEBUG)\n        ml = make_local_path\n        # exclude\n        file_list = FileList()\n        file_list.files = ['a.py', 'b.txt', ml('d/c.py')]\n\n        file_list.process_template_line('exclude *.py')\n        file_list.sort()\n        assert file_list.files == ['b.txt', ml('d/c.py')]\n        self.assertNoWarnings(caplog)\n\n        file_list.process_template_line('exclude *.rb')\n        file_list.sort()\n        assert file_list.files == ['b.txt', ml('d/c.py')]\n        self.assertWarnings(caplog)\n\n    def test_global_include(self, caplog):\n        caplog.set_level(logging.DEBUG)\n        ml = make_local_path\n        # global-include\n        file_list = FileList()\n        self.make_files(['a.py', 'b.txt', ml('d/c.py')])\n\n        file_list.process_template_line('global-include *.py')\n        file_list.sort()\n        assert file_list.files == ['a.py', ml('d/c.py')]\n        self.assertNoWarnings(caplog)\n\n        file_list.process_template_line('global-include *.rb')\n        file_list.sort()\n        assert file_list.files == ['a.py', ml('d/c.py')]\n        self.assertWarnings(caplog)\n\n    def test_global_exclude(self, caplog):\n        caplog.set_level(logging.DEBUG)\n        ml = make_local_path\n        # global-exclude\n        file_list = FileList()\n        file_list.files = ['a.py', 'b.txt', ml('d/c.py')]\n\n        file_list.process_template_line('global-exclude *.py')\n        file_list.sort()\n        assert file_list.files == ['b.txt']\n        self.assertNoWarnings(caplog)\n\n        file_list.process_template_line('global-exclude *.rb')\n        file_list.sort()\n        assert file_list.files == ['b.txt']\n        self.assertWarnings(caplog)\n\n    def test_recursive_include(self, caplog):\n        caplog.set_level(logging.DEBUG)\n        ml = make_local_path\n        # recursive-include\n        file_list = FileList()\n        self.make_files(['a.py', ml('d/b.py'), ml('d/c.txt'), ml('d/d/e.py')])\n\n        file_list.process_template_line('recursive-include d *.py')\n        file_list.sort()\n        assert file_list.files == [ml('d/b.py'), ml('d/d/e.py')]\n        self.assertNoWarnings(caplog)\n\n        file_list.process_template_line('recursive-include e *.py')\n        file_list.sort()\n        assert file_list.files == [ml('d/b.py'), ml('d/d/e.py')]\n        self.assertWarnings(caplog)\n\n    def test_recursive_exclude(self, caplog):\n        caplog.set_level(logging.DEBUG)\n        ml = make_local_path\n        # recursive-exclude\n        file_list = FileList()\n        file_list.files = ['a.py', ml('d/b.py'), ml('d/c.txt'), ml('d/d/e.py')]\n\n        file_list.process_template_line('recursive-exclude d *.py')\n        file_list.sort()\n        assert file_list.files == ['a.py', ml('d/c.txt')]\n        self.assertNoWarnings(caplog)\n\n        file_list.process_template_line('recursive-exclude e *.py')\n        file_list.sort()\n        assert file_list.files == ['a.py', ml('d/c.txt')]\n        self.assertWarnings(caplog)\n\n    def test_graft(self, caplog):\n        caplog.set_level(logging.DEBUG)\n        ml = make_local_path\n        # graft\n        file_list = FileList()\n        self.make_files(['a.py', ml('d/b.py'), ml('d/d/e.py'), ml('f/f.py')])\n\n        file_list.process_template_line('graft d')\n        file_list.sort()\n        assert file_list.files == [ml('d/b.py'), ml('d/d/e.py')]\n        self.assertNoWarnings(caplog)\n\n        file_list.process_template_line('graft e')\n        file_list.sort()\n        assert file_list.files == [ml('d/b.py'), ml('d/d/e.py')]\n        self.assertWarnings(caplog)\n\n    def test_prune(self, caplog):\n        caplog.set_level(logging.DEBUG)\n        ml = make_local_path\n        # prune\n        file_list = FileList()\n        file_list.files = ['a.py', ml('d/b.py'), ml('d/d/e.py'), ml('f/f.py')]\n\n        file_list.process_template_line('prune d')\n        file_list.sort()\n        assert file_list.files == ['a.py', ml('f/f.py')]\n        self.assertNoWarnings(caplog)\n\n        file_list.process_template_line('prune e')\n        file_list.sort()\n        assert file_list.files == ['a.py', ml('f/f.py')]\n        self.assertWarnings(caplog)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_namespaces.py","size":4515,"sha1":"a5a25936334d94ffaa640f516e46c7ddfb904351","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import subprocess\nimport sys\n\nfrom setuptools._path import paths_on_pythonpath\n\nfrom . import namespaces\n\n\nclass TestNamespaces:\n    def test_mixed_site_and_non_site(self, tmpdir):\n        \"\"\"\n        Installing two packages sharing the same namespace, one installed\n        to a site dir and the other installed just to a path on PYTHONPATH\n        should leave the namespace in tact and both packages reachable by\n        import.\n        \"\"\"\n        pkg_A = namespaces.build_namespace_package(tmpdir, 'myns.pkgA')\n        pkg_B = namespaces.build_namespace_package(tmpdir, 'myns.pkgB')\n        site_packages = tmpdir / 'site-packages'\n        path_packages = tmpdir / 'path-packages'\n        targets = site_packages, path_packages\n        # use pip to install to the target directory\n        install_cmd = [\n            sys.executable,\n            '-m',\n            'pip.__main__',\n            'install',\n            str(pkg_A),\n            '-t',\n            str(site_packages),\n        ]\n        subprocess.check_call(install_cmd)\n        namespaces.make_site_dir(site_packages)\n        install_cmd = [\n            sys.executable,\n            '-m',\n            'pip.__main__',\n            'install',\n            str(pkg_B),\n            '-t',\n            str(path_packages),\n        ]\n        subprocess.check_call(install_cmd)\n        try_import = [\n            sys.executable,\n            '-c',\n            'import myns.pkgA; import myns.pkgB',\n        ]\n        with paths_on_pythonpath(map(str, targets)):\n            subprocess.check_call(try_import)\n\n    def test_pkg_resources_import(self, tmpdir):\n        \"\"\"\n        Ensure that a namespace package doesn't break on import\n        of pkg_resources.\n        \"\"\"\n        pkg = namespaces.build_namespace_package(tmpdir, 'myns.pkgA')\n        target = tmpdir / 'packages'\n        target.mkdir()\n        install_cmd = [\n            sys.executable,\n            '-m',\n            'pip',\n            'install',\n            '-t',\n            str(target),\n            str(pkg),\n        ]\n        with paths_on_pythonpath([str(target)]):\n            subprocess.check_call(install_cmd)\n        namespaces.make_site_dir(target)\n        try_import = [\n            sys.executable,\n            '-c',\n            'import pkg_resources',\n        ]\n        with paths_on_pythonpath([str(target)]):\n            subprocess.check_call(try_import)\n\n    def test_namespace_package_installed_and_cwd(self, tmpdir):\n        \"\"\"\n        Installing a namespace packages but also having it in the current\n        working directory, only one version should take precedence.\n        \"\"\"\n        pkg_A = namespaces.build_namespace_package(tmpdir, 'myns.pkgA')\n        target = tmpdir / 'packages'\n        # use pip to install to the target directory\n        install_cmd = [\n            sys.executable,\n            '-m',\n            'pip.__main__',\n            'install',\n            str(pkg_A),\n            '-t',\n            str(target),\n        ]\n        subprocess.check_call(install_cmd)\n        namespaces.make_site_dir(target)\n\n        # ensure that package imports and pkg_resources imports\n        pkg_resources_imp = [\n            sys.executable,\n            '-c',\n            'import pkg_resources; import myns.pkgA',\n        ]\n        with paths_on_pythonpath([str(target)]):\n            subprocess.check_call(pkg_resources_imp, cwd=str(pkg_A))\n\n    def test_packages_in_the_same_namespace_installed_and_cwd(self, tmpdir):\n        \"\"\"\n        Installing one namespace package and also have another in the same\n        namespace in the current working directory, both of them must be\n        importable.\n        \"\"\"\n        pkg_A = namespaces.build_namespace_package(tmpdir, 'myns.pkgA')\n        pkg_B = namespaces.build_namespace_package(tmpdir, 'myns.pkgB')\n        target = tmpdir / 'packages'\n        # use pip to install to the target directory\n        install_cmd = [\n            sys.executable,\n            '-m',\n            'pip.__main__',\n            'install',\n            str(pkg_A),\n            '-t',\n            str(target),\n        ]\n        subprocess.check_call(install_cmd)\n        namespaces.make_site_dir(target)\n\n        # ensure that all packages import and pkg_resources imports\n        pkg_resources_imp = [\n            sys.executable,\n            '-c',\n            'import pkg_resources; import myns.pkgA; import myns.pkgB',\n        ]\n        with paths_on_pythonpath([str(target)]):\n            subprocess.check_call(pkg_resources_imp, cwd=str(pkg_B))\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_packageindex.py","size":8775,"sha1":"91c69f2f87f3c5ecd39e0d0b4426ae653829d6fd","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import http.client\nimport re\nimport urllib.error\nimport urllib.request\nfrom inspect import cleandoc\n\nimport pytest\n\nimport setuptools.package_index\n\nimport distutils.errors\n\n\nclass TestPackageIndex:\n    def test_regex(self):\n        hash_url = 'http://other_url?:action=show_md5&amp;'\n        hash_url += 'digest=0123456789abcdef0123456789abcdef'\n        doc = \"\"\"\n            <a href=\"http://some_url\">Name</a>\n            (<a title=\"MD5 hash\"\n            href=\"{hash_url}\">md5</a>)\n        \"\"\".lstrip().format(**locals())\n        assert setuptools.package_index.PYPI_MD5.match(doc)\n\n    def test_bad_url_bad_port(self):\n        index = setuptools.package_index.PackageIndex()\n        url = 'http://127.0.0.1:0/nonesuch/test_package_index'\n        with pytest.raises(Exception, match=re.escape(url)):\n            v = index.open_url(url)\n            assert isinstance(v, urllib.error.HTTPError)\n\n    def test_bad_url_typo(self):\n        # issue 16\n        # easy_install inquant.contentmirror.plone breaks because of a typo\n        # in its home URL\n        index = setuptools.package_index.PackageIndex(hosts=('www.example.com',))\n\n        url = 'url:%20https://svn.plone.org/svn/collective/inquant.contentmirror.plone/trunk'\n\n        with pytest.raises(Exception, match=re.escape(url)):\n            v = index.open_url(url)\n            assert isinstance(v, urllib.error.HTTPError)\n\n    def test_bad_url_bad_status_line(self):\n        index = setuptools.package_index.PackageIndex(hosts=('www.example.com',))\n\n        def _urlopen(*args):\n            raise http.client.BadStatusLine('line')\n\n        index.opener = _urlopen\n        url = 'http://example.com'\n        with pytest.raises(Exception, match=r'line'):\n            index.open_url(url)\n\n    def test_bad_url_double_scheme(self):\n        \"\"\"\n        A bad URL with a double scheme should raise a DistutilsError.\n        \"\"\"\n        index = setuptools.package_index.PackageIndex(hosts=('www.example.com',))\n\n        # issue 20\n        url = 'http://http://svn.pythonpaste.org/Paste/wphp/trunk'\n        try:\n            index.open_url(url)\n        except distutils.errors.DistutilsError as error:\n            msg = str(error)\n            assert (\n                'nonnumeric port' in msg\n                or 'getaddrinfo failed' in msg\n                or 'Name or service not known' in msg\n            )\n            return\n        raise RuntimeError(\"Did not raise\")\n\n    def test_url_ok(self):\n        index = setuptools.package_index.PackageIndex(hosts=('www.example.com',))\n        url = 'file:///tmp/test_package_index'\n        assert index.url_ok(url, True)\n\n    def test_parse_bdist_wininst(self):\n        parse = setuptools.package_index.parse_bdist_wininst\n\n        actual = parse('reportlab-2.5.win32-py2.4.exe')\n        expected = 'reportlab-2.5', '2.4', 'win32'\n        assert actual == expected\n\n        actual = parse('reportlab-2.5.win32.exe')\n        expected = 'reportlab-2.5', None, 'win32'\n        assert actual == expected\n\n        actual = parse('reportlab-2.5.win-amd64-py2.7.exe')\n        expected = 'reportlab-2.5', '2.7', 'win-amd64'\n        assert actual == expected\n\n        actual = parse('reportlab-2.5.win-amd64.exe')\n        expected = 'reportlab-2.5', None, 'win-amd64'\n        assert actual == expected\n\n    def test__vcs_split_rev_from_url(self):\n        \"\"\"\n        Test the basic usage of _vcs_split_rev_from_url\n        \"\"\"\n        vsrfu = setuptools.package_index.PackageIndex._vcs_split_rev_from_url\n        url, rev = vsrfu('https://example.com/bar@2995')\n        assert url == 'https://example.com/bar'\n        assert rev == '2995'\n\n    def test_local_index(self, tmpdir):\n        \"\"\"\n        local_open should be able to read an index from the file system.\n        \"\"\"\n        index_file = tmpdir / 'index.html'\n        with index_file.open('w') as f:\n            f.write('<div>content</div>')\n        url = 'file:' + urllib.request.pathname2url(str(tmpdir)) + '/'\n        res = setuptools.package_index.local_open(url)\n        assert 'content' in res.read()\n\n    def test_egg_fragment(self):\n        \"\"\"\n        EGG fragments must comply to PEP 440\n        \"\"\"\n        epoch = [\n            '',\n            '1!',\n        ]\n        releases = [\n            '0',\n            '0.0',\n            '0.0.0',\n        ]\n        pre = [\n            'a0',\n            'b0',\n            'rc0',\n        ]\n        post = ['.post0']\n        dev = [\n            '.dev0',\n        ]\n        local = [\n            ('', ''),\n            ('+ubuntu.0', '+ubuntu.0'),\n            ('+ubuntu-0', '+ubuntu.0'),\n            ('+ubuntu_0', '+ubuntu.0'),\n        ]\n        versions = [\n            [''.join([e, r, p, loc]) for loc in locs]\n            for e in epoch\n            for r in releases\n            for p in sum([pre, post, dev], [''])\n            for locs in local\n        ]\n        for v, vc in versions:\n            dists = list(\n                setuptools.package_index.distros_for_url(\n                    'http://example.com/example-foo.zip#egg=example-foo-' + v\n                )\n            )\n            assert dists[0].version == ''\n            assert dists[1].version == vc\n\n    def test_download_git_with_rev(self, tmp_path, fp):\n        url = 'git+https://github.example/group/project@master#egg=foo'\n        index = setuptools.package_index.PackageIndex()\n\n        expected_dir = tmp_path / 'project@master'\n        fp.register([\n            'git',\n            'clone',\n            '--quiet',\n            'https://github.example/group/project',\n            expected_dir,\n        ])\n        fp.register(['git', '-C', expected_dir, 'checkout', '--quiet', 'master'])\n\n        result = index.download(url, tmp_path)\n\n        assert result == str(expected_dir)\n        assert len(fp.calls) == 2\n\n    def test_download_git_no_rev(self, tmp_path, fp):\n        url = 'git+https://github.example/group/project#egg=foo'\n        index = setuptools.package_index.PackageIndex()\n\n        expected_dir = tmp_path / 'project'\n        fp.register([\n            'git',\n            'clone',\n            '--quiet',\n            'https://github.example/group/project',\n            expected_dir,\n        ])\n        index.download(url, tmp_path)\n\n    def test_download_svn(self, tmp_path):\n        url = 'svn+https://svn.example/project#egg=foo'\n        index = setuptools.package_index.PackageIndex()\n\n        msg = r\".*SVN download is not supported.*\"\n        with pytest.raises(distutils.errors.DistutilsError, match=msg):\n            index.download(url, tmp_path)\n\n\nclass TestContentCheckers:\n    def test_md5(self):\n        checker = setuptools.package_index.HashChecker.from_url(\n            'http://foo/bar#md5=f12895fdffbd45007040d2e44df98478'\n        )\n        checker.feed('You should probably not be using MD5'.encode('ascii'))\n        assert checker.hash.hexdigest() == 'f12895fdffbd45007040d2e44df98478'\n        assert checker.is_valid()\n\n    def test_other_fragment(self):\n        \"Content checks should succeed silently if no hash is present\"\n        checker = setuptools.package_index.HashChecker.from_url(\n            'http://foo/bar#something%20completely%20different'\n        )\n        checker.feed('anything'.encode('ascii'))\n        assert checker.is_valid()\n\n    def test_blank_md5(self):\n        \"Content checks should succeed if a hash is empty\"\n        checker = setuptools.package_index.HashChecker.from_url('http://foo/bar#md5=')\n        checker.feed('anything'.encode('ascii'))\n        assert checker.is_valid()\n\n    def test_get_hash_name_md5(self):\n        checker = setuptools.package_index.HashChecker.from_url(\n            'http://foo/bar#md5=f12895fdffbd45007040d2e44df98478'\n        )\n        assert checker.hash_name == 'md5'\n\n    def test_report(self):\n        checker = setuptools.package_index.HashChecker.from_url(\n            'http://foo/bar#md5=f12895fdffbd45007040d2e44df98478'\n        )\n        rep = checker.report(lambda x: x, 'My message about %s')\n        assert rep == 'My message about md5'\n\n\nclass TestPyPIConfig:\n    def test_percent_in_password(self, tmp_home_dir):\n        pypirc = tmp_home_dir / '.pypirc'\n        pypirc.write_text(\n            cleandoc(\n                \"\"\"\n                [pypi]\n                repository=https://pypi.org\n                username=jaraco\n                password=pity%\n                \"\"\"\n            ),\n            encoding=\"utf-8\",\n        )\n        cfg = setuptools.package_index.PyPIConfig()\n        cred = cfg.creds_by_repository['https://pypi.org']\n        assert cred.username == 'jaraco'\n        assert cred.password == 'pity%'\n\n\n@pytest.mark.timeout(1)\ndef test_REL_DoS():\n    \"\"\"\n    REL should not hang on a contrived attack string.\n    \"\"\"\n    setuptools.package_index.REL.search('< rel=' + ' ' * 2**12)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_sandbox.py","size":4330,"sha1":"d613b7ece4f190a4e3e8ed0ac0f97198f787e111","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"develop tests\"\"\"\n\nimport os\nimport types\n\nimport pytest\n\nimport pkg_resources\nimport setuptools.sandbox\n\n\nclass TestSandbox:\n    def test_devnull(self, tmpdir):\n        with setuptools.sandbox.DirectorySandbox(str(tmpdir)):\n            self._file_writer(os.devnull)\n\n    @staticmethod\n    def _file_writer(path):\n        def do_write():\n            with open(path, 'w', encoding=\"utf-8\") as f:\n                f.write('xxx')\n\n        return do_write\n\n    def test_setup_py_with_BOM(self):\n        \"\"\"\n        It should be possible to execute a setup.py with a Byte Order Mark\n        \"\"\"\n        target = pkg_resources.resource_filename(__name__, 'script-with-bom.py')\n        namespace = types.ModuleType('namespace')\n        setuptools.sandbox._execfile(target, vars(namespace))\n        assert namespace.result == 'passed'\n\n    def test_setup_py_with_CRLF(self, tmpdir):\n        setup_py = tmpdir / 'setup.py'\n        with setup_py.open('wb') as stream:\n            stream.write(b'\"degenerate script\"\\r\\n')\n        setuptools.sandbox._execfile(str(setup_py), globals())\n\n\nclass TestExceptionSaver:\n    def test_exception_trapped(self):\n        with setuptools.sandbox.ExceptionSaver():\n            raise ValueError(\"details\")\n\n    def test_exception_resumed(self):\n        with setuptools.sandbox.ExceptionSaver() as saved_exc:\n            raise ValueError(\"details\")\n\n        with pytest.raises(ValueError) as caught:\n            saved_exc.resume()\n\n        assert isinstance(caught.value, ValueError)\n        assert str(caught.value) == 'details'\n\n    def test_exception_reconstructed(self):\n        orig_exc = ValueError(\"details\")\n\n        with setuptools.sandbox.ExceptionSaver() as saved_exc:\n            raise orig_exc\n\n        with pytest.raises(ValueError) as caught:\n            saved_exc.resume()\n\n        assert isinstance(caught.value, ValueError)\n        assert caught.value is not orig_exc\n\n    def test_no_exception_passes_quietly(self):\n        with setuptools.sandbox.ExceptionSaver() as saved_exc:\n            pass\n\n        saved_exc.resume()\n\n    def test_unpickleable_exception(self):\n        class CantPickleThis(Exception):\n            \"This Exception is unpickleable because it's not in globals\"\n\n            def __repr__(self) -> str:\n                return f'CantPickleThis{self.args!r}'\n\n        with setuptools.sandbox.ExceptionSaver() as saved_exc:\n            raise CantPickleThis('detail')\n\n        with pytest.raises(setuptools.sandbox.UnpickleableException) as caught:\n            saved_exc.resume()\n\n        assert str(caught.value) == \"CantPickleThis('detail',)\"\n\n    def test_unpickleable_exception_when_hiding_setuptools(self):\n        \"\"\"\n        As revealed in #440, an infinite recursion can occur if an unpickleable\n        exception while setuptools is hidden. Ensure this doesn't happen.\n        \"\"\"\n\n        class ExceptionUnderTest(Exception):\n            \"\"\"\n            An unpickleable exception (not in globals).\n            \"\"\"\n\n        with pytest.raises(setuptools.sandbox.UnpickleableException) as caught:\n            with setuptools.sandbox.save_modules():\n                setuptools.sandbox.hide_setuptools()\n                raise ExceptionUnderTest\n\n        (msg,) = caught.value.args\n        assert msg == 'ExceptionUnderTest()'\n\n    def test_sandbox_violation_raised_hiding_setuptools(self, tmpdir):\n        \"\"\"\n        When in a sandbox with setuptools hidden, a SandboxViolation\n        should reflect a proper exception and not be wrapped in\n        an UnpickleableException.\n        \"\"\"\n\n        def write_file():\n            \"Trigger a SandboxViolation by writing outside the sandbox\"\n            with open('/etc/foo', 'w', encoding=\"utf-8\"):\n                pass\n\n        with pytest.raises(setuptools.sandbox.SandboxViolation) as caught:\n            with setuptools.sandbox.save_modules():\n                setuptools.sandbox.hide_setuptools()\n                with setuptools.sandbox.DirectorySandbox(str(tmpdir)):\n                    write_file()\n\n        cmd, args, kwargs = caught.value.args\n        assert cmd == 'open'\n        assert args == ('/etc/foo', 'w')\n        assert kwargs == {\"encoding\": \"utf-8\"}\n\n        msg = str(caught.value)\n        assert 'open' in msg\n        assert \"('/etc/foo', 'w')\" in msg\n        assert \"{'encoding': 'utf-8'}\" in msg\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_sdist.py","size":32428,"sha1":"6dd9bc36c0ffdc2c86cfc326cd65173036f81802","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"sdist tests\"\"\"\n\nimport contextlib\nimport io\nimport logging\nimport os\nimport pathlib\nimport sys\nimport tarfile\nimport tempfile\nimport unicodedata\nfrom inspect import cleandoc\nfrom pathlib import Path\nfrom unittest import mock\n\nimport jaraco.path\nimport pytest\n\nfrom setuptools import Command, SetuptoolsDeprecationWarning\nfrom setuptools._importlib import metadata\nfrom setuptools.command.egg_info import manifest_maker\nfrom setuptools.command.sdist import sdist\nfrom setuptools.dist import Distribution\nfrom setuptools.extension import Extension\nfrom setuptools.tests import fail_on_ascii\n\nfrom .text import Filenames\n\nimport distutils\nfrom distutils.core import run_setup\n\nSETUP_ATTRS = {\n    'name': 'sdist_test',\n    'version': '0.0',\n    'packages': ['sdist_test'],\n    'package_data': {'sdist_test': ['*.txt']},\n    'data_files': [(\"data\", [os.path.join(\"d\", \"e.dat\")])],\n}\n\nSETUP_PY = f\"\"\"\\\nfrom setuptools import setup\n\nsetup(**{SETUP_ATTRS!r})\n\"\"\"\n\nEXTENSION = Extension(\n    name=\"sdist_test.f\",\n    sources=[os.path.join(\"sdist_test\", \"f.c\")],\n    depends=[os.path.join(\"sdist_test\", \"f.h\")],\n)\nEXTENSION_SOURCES = EXTENSION.sources + EXTENSION.depends\n\n\n@contextlib.contextmanager\ndef quiet():\n    old_stdout, old_stderr = sys.stdout, sys.stderr\n    sys.stdout, sys.stderr = io.StringIO(), io.StringIO()\n    try:\n        yield\n    finally:\n        sys.stdout, sys.stderr = old_stdout, old_stderr\n\n\n# Convert to POSIX path\ndef posix(path):\n    if not isinstance(path, str):\n        return path.replace(os.sep.encode('ascii'), b'/')\n    else:\n        return path.replace(os.sep, '/')\n\n\n# HFS Plus uses decomposed UTF-8\ndef decompose(path):\n    if isinstance(path, str):\n        return unicodedata.normalize('NFD', path)\n    try:\n        path = path.decode('utf-8')\n        path = unicodedata.normalize('NFD', path)\n        path = path.encode('utf-8')\n    except UnicodeError:\n        pass  # Not UTF-8\n    return path\n\n\ndef read_all_bytes(filename):\n    with open(filename, 'rb') as fp:\n        return fp.read()\n\n\ndef latin1_fail():\n    try:\n        desc, filename = tempfile.mkstemp(suffix=Filenames.latin_1)\n        os.close(desc)\n        os.remove(filename)\n    except Exception:\n        return True\n\n\nfail_on_latin1_encoded_filenames = pytest.mark.xfail(\n    latin1_fail(),\n    reason=\"System does not support latin-1 filenames\",\n)\n\n\nskip_under_xdist = pytest.mark.skipif(\n    \"os.environ.get('PYTEST_XDIST_WORKER')\",\n    reason=\"pytest-dev/pytest-xdist#843\",\n)\nskip_under_stdlib_distutils = pytest.mark.skipif(\n    not distutils.__package__.startswith('setuptools'),\n    reason=\"the test is not supported with stdlib distutils\",\n)\n\n\ndef touch(path):\n    open(path, 'wb').close()\n    return path\n\n\ndef symlink_or_skip_test(src, dst):\n    try:\n        os.symlink(src, dst)\n    except (OSError, NotImplementedError):\n        pytest.skip(\"symlink not supported in OS\")\n        return None\n    return dst\n\n\nclass TestSdistTest:\n    @pytest.fixture(autouse=True)\n    def source_dir(self, tmpdir):\n        tmpdir = tmpdir / \"project_root\"\n        tmpdir.mkdir()\n\n        (tmpdir / 'setup.py').write_text(SETUP_PY, encoding='utf-8')\n\n        # Set up the rest of the test package\n        test_pkg = tmpdir / 'sdist_test'\n        test_pkg.mkdir()\n        data_folder = tmpdir / 'd'\n        data_folder.mkdir()\n        # *.rst was not included in package_data, so c.rst should not be\n        # automatically added to the manifest when not under version control\n        for fname in ['__init__.py', 'a.txt', 'b.txt', 'c.rst']:\n            touch(test_pkg / fname)\n        touch(data_folder / 'e.dat')\n        # C sources are not included by default, but they will be,\n        # if an extension module uses them as sources or depends\n        for fname in EXTENSION_SOURCES:\n            touch(tmpdir / fname)\n\n        with tmpdir.as_cwd():\n            yield tmpdir\n\n    def assert_package_data_in_manifest(self, cmd):\n        manifest = cmd.filelist.files\n        assert os.path.join('sdist_test', 'a.txt') in manifest\n        assert os.path.join('sdist_test', 'b.txt') in manifest\n        assert os.path.join('sdist_test', 'c.rst') not in manifest\n        assert os.path.join('d', 'e.dat') in manifest\n\n    def setup_with_extension(self):\n        setup_attrs = {**SETUP_ATTRS, 'ext_modules': [EXTENSION]}\n\n        dist = Distribution(setup_attrs)\n        dist.script_name = 'setup.py'\n        cmd = sdist(dist)\n        cmd.ensure_finalized()\n\n        with quiet():\n            cmd.run()\n\n        return cmd\n\n    def test_package_data_in_sdist(self):\n        \"\"\"Regression test for pull request #4: ensures that files listed in\n        package_data are included in the manifest even if they're not added to\n        version control.\n        \"\"\"\n\n        dist = Distribution(SETUP_ATTRS)\n        dist.script_name = 'setup.py'\n        cmd = sdist(dist)\n        cmd.ensure_finalized()\n\n        with quiet():\n            cmd.run()\n\n        self.assert_package_data_in_manifest(cmd)\n\n    def test_package_data_and_include_package_data_in_sdist(self):\n        \"\"\"\n        Ensure package_data and include_package_data work\n        together.\n        \"\"\"\n        setup_attrs = {**SETUP_ATTRS, 'include_package_data': True}\n        assert setup_attrs['package_data']\n\n        dist = Distribution(setup_attrs)\n        dist.script_name = 'setup.py'\n        cmd = sdist(dist)\n        cmd.ensure_finalized()\n\n        with quiet():\n            cmd.run()\n\n        self.assert_package_data_in_manifest(cmd)\n\n    def test_extension_sources_in_sdist(self):\n        \"\"\"\n        Ensure that the files listed in Extension.sources and Extension.depends\n        are automatically included in the manifest.\n        \"\"\"\n        cmd = self.setup_with_extension()\n        self.assert_package_data_in_manifest(cmd)\n        manifest = cmd.filelist.files\n        for path in EXTENSION_SOURCES:\n            assert path in manifest\n\n    def test_missing_extension_sources(self):\n        \"\"\"\n        Similar to test_extension_sources_in_sdist but the referenced files don't exist.\n        Missing files should not be included in distribution (with no error raised).\n        \"\"\"\n        for path in EXTENSION_SOURCES:\n            os.remove(path)\n\n        cmd = self.setup_with_extension()\n        self.assert_package_data_in_manifest(cmd)\n        manifest = cmd.filelist.files\n        for path in EXTENSION_SOURCES:\n            assert path not in manifest\n\n    def test_symlinked_extension_sources(self):\n        \"\"\"\n        Similar to test_extension_sources_in_sdist but the referenced files are\n        instead symbolic links to project-local files. Referenced file paths\n        should be included. Symlink targets themselves should NOT be included.\n        \"\"\"\n        symlinked = []\n        for path in EXTENSION_SOURCES:\n            base, ext = os.path.splitext(path)\n            target = base + \"_target.\" + ext\n\n            os.rename(path, target)\n            symlink_or_skip_test(os.path.basename(target), path)\n            symlinked.append(target)\n\n        cmd = self.setup_with_extension()\n        self.assert_package_data_in_manifest(cmd)\n        manifest = cmd.filelist.files\n        for path in EXTENSION_SOURCES:\n            assert path in manifest\n        for path in symlinked:\n            assert path not in manifest\n\n    _INVALID_PATHS = {\n        \"must be relative\": lambda: (\n            os.path.abspath(os.path.join(\"sdist_test\", \"f.h\"))\n        ),\n        \"can't have `..` segments\": lambda: (\n            os.path.join(\"sdist_test\", \"..\", \"sdist_test\", \"f.h\")\n        ),\n        \"doesn't exist\": lambda: (\n            os.path.join(\"sdist_test\", \"this_file_does_not_exist.h\")\n        ),\n        \"must be inside the project root\": lambda: (\n            symlink_or_skip_test(\n                touch(os.path.join(\"..\", \"outside_of_project_root.h\")),\n                \"symlink.h\",\n            )\n        ),\n    }\n\n    @skip_under_stdlib_distutils\n    @pytest.mark.parametrize(\"reason\", _INVALID_PATHS.keys())\n    def test_invalid_extension_depends(self, reason, caplog):\n        \"\"\"\n        Due to backwards compatibility reasons, `Extension.depends` should accept\n        invalid/weird paths, but then ignore them when building a sdist.\n\n        This test verifies that the source distribution is still built\n        successfully with such paths, but that instead of adding these paths to\n        the manifest, we emit an informational message, notifying the user that\n        the invalid path won't be automatically included.\n        \"\"\"\n        invalid_path = self._INVALID_PATHS[reason]()\n        extension = Extension(\n            name=\"sdist_test.f\",\n            sources=[],\n            depends=[invalid_path],\n        )\n        setup_attrs = {**SETUP_ATTRS, 'ext_modules': [extension]}\n\n        dist = Distribution(setup_attrs)\n        dist.script_name = 'setup.py'\n        cmd = sdist(dist)\n        cmd.ensure_finalized()\n\n        with quiet(), caplog.at_level(logging.INFO):\n            cmd.run()\n\n        self.assert_package_data_in_manifest(cmd)\n        manifest = cmd.filelist.files\n        assert invalid_path not in manifest\n\n        expected_message = [\n            message\n            for (logger, level, message) in caplog.record_tuples\n            if (\n                logger == \"root\"  #\n                and level == logging.INFO  #\n                and invalid_path in message  #\n            )\n        ]\n        assert len(expected_message) == 1\n        (expected_message,) = expected_message\n        assert reason in expected_message\n\n    def test_custom_build_py(self):\n        \"\"\"\n        Ensure projects defining custom build_py don't break\n        when creating sdists (issue #2849)\n        \"\"\"\n        from distutils.command.build_py import build_py as OrigBuildPy\n\n        using_custom_command_guard = mock.Mock()\n\n        class CustomBuildPy(OrigBuildPy):\n            \"\"\"\n            Some projects have custom commands inheriting from `distutils`\n            \"\"\"\n\n            def get_data_files(self):\n                using_custom_command_guard()\n                return super().get_data_files()\n\n        setup_attrs = {**SETUP_ATTRS, 'include_package_data': True}\n        assert setup_attrs['package_data']\n\n        dist = Distribution(setup_attrs)\n        dist.script_name = 'setup.py'\n        cmd = sdist(dist)\n        cmd.ensure_finalized()\n\n        # Make sure we use the custom command\n        cmd.cmdclass = {'build_py': CustomBuildPy}\n        cmd.distribution.cmdclass = {'build_py': CustomBuildPy}\n        assert cmd.distribution.get_command_class('build_py') == CustomBuildPy\n\n        msg = \"setuptools instead of distutils\"\n        with quiet(), pytest.warns(SetuptoolsDeprecationWarning, match=msg):\n            cmd.run()\n\n        using_custom_command_guard.assert_called()\n        self.assert_package_data_in_manifest(cmd)\n\n    def test_setup_py_exists(self):\n        dist = Distribution(SETUP_ATTRS)\n        dist.script_name = 'foo.py'\n        cmd = sdist(dist)\n        cmd.ensure_finalized()\n\n        with quiet():\n            cmd.run()\n\n        manifest = cmd.filelist.files\n        assert 'setup.py' in manifest\n\n    def test_setup_py_missing(self):\n        dist = Distribution(SETUP_ATTRS)\n        dist.script_name = 'foo.py'\n        cmd = sdist(dist)\n        cmd.ensure_finalized()\n\n        if os.path.exists(\"setup.py\"):\n            os.remove(\"setup.py\")\n        with quiet():\n            cmd.run()\n\n        manifest = cmd.filelist.files\n        assert 'setup.py' not in manifest\n\n    def test_setup_py_excluded(self):\n        with open(\"MANIFEST.in\", \"w\", encoding=\"utf-8\") as manifest_file:\n            manifest_file.write(\"exclude setup.py\")\n\n        dist = Distribution(SETUP_ATTRS)\n        dist.script_name = 'foo.py'\n        cmd = sdist(dist)\n        cmd.ensure_finalized()\n\n        with quiet():\n            cmd.run()\n\n        manifest = cmd.filelist.files\n        assert 'setup.py' not in manifest\n\n    def test_defaults_case_sensitivity(self, source_dir):\n        \"\"\"\n        Make sure default files (README.*, etc.) are added in a case-sensitive\n        way to avoid problems with packages built on Windows.\n        \"\"\"\n\n        touch(source_dir / 'readme.rst')\n        touch(source_dir / 'SETUP.cfg')\n\n        dist = Distribution(SETUP_ATTRS)\n        # the extension deliberately capitalized for this test\n        # to make sure the actual filename (not capitalized) gets added\n        # to the manifest\n        dist.script_name = 'setup.PY'\n        cmd = sdist(dist)\n        cmd.ensure_finalized()\n\n        with quiet():\n            cmd.run()\n\n        # lowercase all names so we can test in a\n        # case-insensitive way to make sure the files\n        # are not included.\n        manifest = map(lambda x: x.lower(), cmd.filelist.files)\n        assert 'readme.rst' not in manifest, manifest\n        assert 'setup.py' not in manifest, manifest\n        assert 'setup.cfg' not in manifest, manifest\n\n    def test_exclude_dev_only_cache_folders(self, source_dir):\n        included = {\n            # Emulate problem in https://github.com/pypa/setuptools/issues/4601\n            \"MANIFEST.in\": (\n                \"global-include LICEN[CS]E* COPYING* NOTICE* AUTHORS*\\n\"\n                \"global-include *.txt\\n\"\n            ),\n            # For the sake of being conservative and limiting unforeseen side-effects\n            # we just exclude dev-only cache folders at the root of the repository:\n            \"test/.venv/lib/python3.9/site-packages/bar-2.dist-info/AUTHORS.rst\": \"\",\n            \"src/.nox/py/lib/python3.12/site-packages/bar-2.dist-info/COPYING.txt\": \"\",\n            \"doc/.tox/default/lib/python3.11/site-packages/foo-4.dist-info/LICENSE\": \"\",\n            # Let's test against false positives with similarly named files:\n            \".venv-requirements.txt\": \"\",\n            \".tox-coveragerc.txt\": \"\",\n            \".noxy/coveragerc.txt\": \"\",\n        }\n\n        excluded = {\n            # .tox/.nox/.venv are well-know folders present at the root of Python repos\n            # and therefore should be excluded\n            \".tox/release/lib/python3.11/site-packages/foo-4.dist-info/LICENSE\": \"\",\n            \".nox/py/lib/python3.12/site-packages/bar-2.dist-info/COPYING.txt\": \"\",\n            \".venv/lib/python3.9/site-packages/bar-2.dist-info/AUTHORS.rst\": \"\",\n        }\n\n        for file, content in {**excluded, **included}.items():\n            Path(source_dir, file).parent.mkdir(parents=True, exist_ok=True)\n            Path(source_dir, file).write_text(content, encoding=\"utf-8\")\n\n        cmd = self.setup_with_extension()\n        self.assert_package_data_in_manifest(cmd)\n        manifest = {f.replace(os.sep, '/') for f in cmd.filelist.files}\n        for path in excluded:\n            assert os.path.exists(path)\n            assert path not in manifest, (path, manifest)\n        for path in included:\n            assert os.path.exists(path)\n            assert path in manifest, (path, manifest)\n\n    @fail_on_ascii\n    def test_manifest_is_written_with_utf8_encoding(self):\n        # Test for #303.\n        dist = Distribution(SETUP_ATTRS)\n        dist.script_name = 'setup.py'\n        mm = manifest_maker(dist)\n        mm.manifest = os.path.join('sdist_test.egg-info', 'SOURCES.txt')\n        os.mkdir('sdist_test.egg-info')\n\n        # UTF-8 filename\n        filename = os.path.join('sdist_test', 'smörbröd.py')\n\n        # Must create the file or it will get stripped.\n        touch(filename)\n\n        # Add UTF-8 filename and write manifest\n        with quiet():\n            mm.run()\n            mm.filelist.append(filename)\n            mm.write_manifest()\n\n        contents = read_all_bytes(mm.manifest)\n\n        # The manifest should be UTF-8 encoded\n        u_contents = contents.decode('UTF-8')\n\n        # The manifest should contain the UTF-8 filename\n        assert posix(filename) in u_contents\n\n    @fail_on_ascii\n    def test_write_manifest_allows_utf8_filenames(self):\n        # Test for #303.\n        dist = Distribution(SETUP_ATTRS)\n        dist.script_name = 'setup.py'\n        mm = manifest_maker(dist)\n        mm.manifest = os.path.join('sdist_test.egg-info', 'SOURCES.txt')\n        os.mkdir('sdist_test.egg-info')\n\n        filename = os.path.join(b'sdist_test', Filenames.utf_8)\n\n        # Must touch the file or risk removal\n        touch(filename)\n\n        # Add filename and write manifest\n        with quiet():\n            mm.run()\n            u_filename = filename.decode('utf-8')\n            mm.filelist.files.append(u_filename)\n            # Re-write manifest\n            mm.write_manifest()\n\n        contents = read_all_bytes(mm.manifest)\n\n        # The manifest should be UTF-8 encoded\n        contents.decode('UTF-8')\n\n        # The manifest should contain the UTF-8 filename\n        assert posix(filename) in contents\n\n        # The filelist should have been updated as well\n        assert u_filename in mm.filelist.files\n\n    @skip_under_xdist\n    def test_write_manifest_skips_non_utf8_filenames(self):\n        \"\"\"\n        Files that cannot be encoded to UTF-8 (specifically, those that\n        weren't originally successfully decoded and have surrogate\n        escapes) should be omitted from the manifest.\n        See https://bitbucket.org/tarek/distribute/issue/303 for history.\n        \"\"\"\n        dist = Distribution(SETUP_ATTRS)\n        dist.script_name = 'setup.py'\n        mm = manifest_maker(dist)\n        mm.manifest = os.path.join('sdist_test.egg-info', 'SOURCES.txt')\n        os.mkdir('sdist_test.egg-info')\n\n        # Latin-1 filename\n        filename = os.path.join(b'sdist_test', Filenames.latin_1)\n\n        # Add filename with surrogates and write manifest\n        with quiet():\n            mm.run()\n            u_filename = filename.decode('utf-8', 'surrogateescape')\n            mm.filelist.append(u_filename)\n            # Re-write manifest\n            mm.write_manifest()\n\n        contents = read_all_bytes(mm.manifest)\n\n        # The manifest should be UTF-8 encoded\n        contents.decode('UTF-8')\n\n        # The Latin-1 filename should have been skipped\n        assert posix(filename) not in contents\n\n        # The filelist should have been updated as well\n        assert u_filename not in mm.filelist.files\n\n    @fail_on_ascii\n    def test_manifest_is_read_with_utf8_encoding(self):\n        # Test for #303.\n        dist = Distribution(SETUP_ATTRS)\n        dist.script_name = 'setup.py'\n        cmd = sdist(dist)\n        cmd.ensure_finalized()\n\n        # Create manifest\n        with quiet():\n            cmd.run()\n\n        # Add UTF-8 filename to manifest\n        filename = os.path.join(b'sdist_test', Filenames.utf_8)\n        cmd.manifest = os.path.join('sdist_test.egg-info', 'SOURCES.txt')\n        manifest = open(cmd.manifest, 'ab')\n        manifest.write(b'\\n' + filename)\n        manifest.close()\n\n        # The file must exist to be included in the filelist\n        touch(filename)\n\n        # Re-read manifest\n        cmd.filelist.files = []\n        with quiet():\n            cmd.read_manifest()\n\n        # The filelist should contain the UTF-8 filename\n        filename = filename.decode('utf-8')\n        assert filename in cmd.filelist.files\n\n    @fail_on_latin1_encoded_filenames\n    def test_read_manifest_skips_non_utf8_filenames(self):\n        # Test for #303.\n        dist = Distribution(SETUP_ATTRS)\n        dist.script_name = 'setup.py'\n        cmd = sdist(dist)\n        cmd.ensure_finalized()\n\n        # Create manifest\n        with quiet():\n            cmd.run()\n\n        # Add Latin-1 filename to manifest\n        filename = os.path.join(b'sdist_test', Filenames.latin_1)\n        cmd.manifest = os.path.join('sdist_test.egg-info', 'SOURCES.txt')\n        manifest = open(cmd.manifest, 'ab')\n        manifest.write(b'\\n' + filename)\n        manifest.close()\n\n        # The file must exist to be included in the filelist\n        touch(filename)\n\n        # Re-read manifest\n        cmd.filelist.files = []\n        with quiet():\n            cmd.read_manifest()\n\n        # The Latin-1 filename should have been skipped\n        filename = filename.decode('latin-1')\n        assert filename not in cmd.filelist.files\n\n    @fail_on_ascii\n    @fail_on_latin1_encoded_filenames\n    def test_sdist_with_utf8_encoded_filename(self):\n        # Test for #303.\n        dist = Distribution(self.make_strings(SETUP_ATTRS))\n        dist.script_name = 'setup.py'\n        cmd = sdist(dist)\n        cmd.ensure_finalized()\n\n        filename = os.path.join(b'sdist_test', Filenames.utf_8)\n        touch(filename)\n\n        with quiet():\n            cmd.run()\n\n        if sys.platform == 'darwin':\n            filename = decompose(filename)\n\n        fs_enc = sys.getfilesystemencoding()\n\n        if sys.platform == 'win32':\n            if fs_enc == 'cp1252':\n                # Python mangles the UTF-8 filename\n                filename = filename.decode('cp1252')\n                assert filename in cmd.filelist.files\n            else:\n                filename = filename.decode('mbcs')\n                assert filename in cmd.filelist.files\n        else:\n            filename = filename.decode('utf-8')\n            assert filename in cmd.filelist.files\n\n    @classmethod\n    def make_strings(cls, item):\n        if isinstance(item, dict):\n            return {key: cls.make_strings(value) for key, value in item.items()}\n        if isinstance(item, list):\n            return list(map(cls.make_strings, item))\n        return str(item)\n\n    @fail_on_latin1_encoded_filenames\n    @skip_under_xdist\n    def test_sdist_with_latin1_encoded_filename(self):\n        # Test for #303.\n        dist = Distribution(self.make_strings(SETUP_ATTRS))\n        dist.script_name = 'setup.py'\n        cmd = sdist(dist)\n        cmd.ensure_finalized()\n\n        # Latin-1 filename\n        filename = os.path.join(b'sdist_test', Filenames.latin_1)\n        touch(filename)\n        assert os.path.isfile(filename)\n\n        with quiet():\n            cmd.run()\n\n        # not all windows systems have a default FS encoding of cp1252\n        if sys.platform == 'win32':\n            # Latin-1 is similar to Windows-1252 however\n            # on mbcs filesys it is not in latin-1 encoding\n            fs_enc = sys.getfilesystemencoding()\n            if fs_enc != 'mbcs':\n                fs_enc = 'latin-1'\n            filename = filename.decode(fs_enc)\n\n            assert filename in cmd.filelist.files\n        else:\n            # The Latin-1 filename should have been skipped\n            filename = filename.decode('latin-1')\n            assert filename not in cmd.filelist.files\n\n    _EXAMPLE_DIRECTIVES = {\n        \"setup.cfg - long_description and version\": \"\"\"\n            [metadata]\n            name = testing\n            version = file: src/VERSION.txt\n            license_files = DOWHATYOUWANT\n            long_description = file: README.rst, USAGE.rst\n            \"\"\",\n        \"pyproject.toml - static readme/license files and dynamic version\": \"\"\"\n            [project]\n            name = \"testing\"\n            readme = \"USAGE.rst\"\n            license = {file = \"DOWHATYOUWANT\"}\n            dynamic = [\"version\"]\n            [tool.setuptools.dynamic]\n            version = {file = [\"src/VERSION.txt\"]}\n            \"\"\",\n        \"pyproject.toml - directive with str instead of list\": \"\"\"\n            [project]\n            name = \"testing\"\n            readme = \"USAGE.rst\"\n            license = {file = \"DOWHATYOUWANT\"}\n            dynamic = [\"version\"]\n            [tool.setuptools.dynamic]\n            version = {file = \"src/VERSION.txt\"}\n            \"\"\",\n    }\n\n    @pytest.mark.parametrize(\"config\", _EXAMPLE_DIRECTIVES.keys())\n    def test_add_files_referenced_by_config_directives(self, source_dir, config):\n        config_file, _, _ = config.partition(\" - \")\n        config_text = self._EXAMPLE_DIRECTIVES[config]\n        (source_dir / 'src').mkdir()\n        (source_dir / 'src/VERSION.txt').write_text(\"0.42\", encoding=\"utf-8\")\n        (source_dir / 'README.rst').write_text(\"hello world!\", encoding=\"utf-8\")\n        (source_dir / 'USAGE.rst').write_text(\"hello world!\", encoding=\"utf-8\")\n        (source_dir / 'DOWHATYOUWANT').write_text(\"hello world!\", encoding=\"utf-8\")\n        (source_dir / config_file).write_text(config_text, encoding=\"utf-8\")\n\n        dist = Distribution({\"packages\": []})\n        dist.script_name = 'setup.py'\n        dist.parse_config_files()\n\n        cmd = sdist(dist)\n        cmd.ensure_finalized()\n        with quiet():\n            cmd.run()\n\n        assert (\n            'src/VERSION.txt' in cmd.filelist.files\n            or 'src\\\\VERSION.txt' in cmd.filelist.files\n        )\n        assert 'USAGE.rst' in cmd.filelist.files\n        assert 'DOWHATYOUWANT' in cmd.filelist.files\n        assert '/' not in cmd.filelist.files\n        assert '\\\\' not in cmd.filelist.files\n\n    def test_pyproject_toml_in_sdist(self, source_dir):\n        \"\"\"\n        Check if pyproject.toml is included in source distribution if present\n        \"\"\"\n        touch(source_dir / 'pyproject.toml')\n        dist = Distribution(SETUP_ATTRS)\n        dist.script_name = 'setup.py'\n        cmd = sdist(dist)\n        cmd.ensure_finalized()\n        with quiet():\n            cmd.run()\n        manifest = cmd.filelist.files\n        assert 'pyproject.toml' in manifest\n\n    def test_pyproject_toml_excluded(self, source_dir):\n        \"\"\"\n        Check that pyproject.toml can excluded even if present\n        \"\"\"\n        touch(source_dir / 'pyproject.toml')\n        with open('MANIFEST.in', 'w', encoding=\"utf-8\") as mts:\n            print('exclude pyproject.toml', file=mts)\n        dist = Distribution(SETUP_ATTRS)\n        dist.script_name = 'setup.py'\n        cmd = sdist(dist)\n        cmd.ensure_finalized()\n        with quiet():\n            cmd.run()\n        manifest = cmd.filelist.files\n        assert 'pyproject.toml' not in manifest\n\n    def test_build_subcommand_source_files(self, source_dir):\n        touch(source_dir / '.myfile~')\n\n        # Sanity check: without custom commands file list should not be affected\n        dist = Distribution({**SETUP_ATTRS, \"script_name\": \"setup.py\"})\n        cmd = sdist(dist)\n        cmd.ensure_finalized()\n        with quiet():\n            cmd.run()\n        manifest = cmd.filelist.files\n        assert '.myfile~' not in manifest\n\n        # Test: custom command should be able to augment file list\n        dist = Distribution({**SETUP_ATTRS, \"script_name\": \"setup.py\"})\n        build = dist.get_command_obj(\"build\")\n        build.sub_commands = [*build.sub_commands, (\"build_custom\", None)]\n\n        class build_custom(Command):\n            def initialize_options(self): ...\n\n            def finalize_options(self): ...\n\n            def run(self): ...\n\n            def get_source_files(self):\n                return ['.myfile~']\n\n        dist.cmdclass.update(build_custom=build_custom)\n\n        cmd = sdist(dist)\n        cmd.use_defaults = True\n        cmd.ensure_finalized()\n        with quiet():\n            cmd.run()\n        manifest = cmd.filelist.files\n        assert '.myfile~' in manifest\n\n    @pytest.mark.skipif(\"os.environ.get('SETUPTOOLS_USE_DISTUTILS') == 'stdlib'\")\n    def test_build_base_pathlib(self, source_dir):\n        \"\"\"\n        Ensure if build_base is a pathlib.Path, the build still succeeds.\n        \"\"\"\n        dist = Distribution({\n            **SETUP_ATTRS,\n            \"script_name\": \"setup.py\",\n            \"options\": {\"build\": {\"build_base\": pathlib.Path('build')}},\n        })\n        cmd = sdist(dist)\n        cmd.ensure_finalized()\n        with quiet():\n            cmd.run()\n\n\ndef test_default_revctrl():\n    \"\"\"\n    When _default_revctrl was removed from the `setuptools.command.sdist`\n    module in 10.0, it broke some systems which keep an old install of\n    setuptools (Distribute) around. Those old versions require that the\n    setuptools package continue to implement that interface, so this\n    function provides that interface, stubbed. See #320 for details.\n\n    This interface must be maintained until Ubuntu 12.04 is no longer\n    supported (by Setuptools).\n    \"\"\"\n    (ep,) = metadata.EntryPoints._from_text(\n        \"\"\"\n        [setuptools.file_finders]\n        svn_cvs = setuptools.command.sdist:_default_revctrl\n        \"\"\"\n    )\n    res = ep.load()\n    assert hasattr(res, '__iter__')\n\n\nclass TestRegressions:\n    \"\"\"\n    Can be removed/changed if the project decides to change how it handles symlinks\n    or external files.\n    \"\"\"\n\n    @staticmethod\n    def files_for_symlink_in_extension_depends(tmp_path, dep_path):\n        return {\n            \"external\": {\n                \"dir\": {\"file.h\": \"\"},\n            },\n            \"project\": {\n                \"setup.py\": cleandoc(\n                    f\"\"\"\n                    from setuptools import Extension, setup\n                    setup(\n                        name=\"myproj\",\n                        version=\"42\",\n                        ext_modules=[\n                            Extension(\n                                \"hello\", sources=[\"hello.pyx\"],\n                                depends=[{dep_path!r}]\n                            )\n                        ],\n                    )\n                    \"\"\"\n                ),\n                \"hello.pyx\": \"\",\n                \"MANIFEST.in\": \"global-include *.h\",\n            },\n        }\n\n    @pytest.mark.parametrize(\n        \"dep_path\", (\"myheaders/dir/file.h\", \"myheaders/dir/../dir/file.h\")\n    )\n    def test_symlink_in_extension_depends(self, monkeypatch, tmp_path, dep_path):\n        # Given a project with a symlinked dir and a \"depends\" targeting that dir\n        files = self.files_for_symlink_in_extension_depends(tmp_path, dep_path)\n        jaraco.path.build(files, prefix=str(tmp_path))\n        symlink_or_skip_test(tmp_path / \"external\", tmp_path / \"project/myheaders\")\n\n        # When `sdist` runs, there should be no error\n        members = run_sdist(monkeypatch, tmp_path / \"project\")\n        # and the sdist should contain the symlinked files\n        for expected in (\n            \"myproj-42/hello.pyx\",\n            \"myproj-42/myheaders/dir/file.h\",\n        ):\n            assert expected in members\n\n    @staticmethod\n    def files_for_external_path_in_extension_depends(tmp_path, dep_path):\n        head, _, tail = dep_path.partition(\"$tmp_path$/\")\n        dep_path = tmp_path / tail if tail else head\n\n        return {\n            \"external\": {\n                \"dir\": {\"file.h\": \"\"},\n            },\n            \"project\": {\n                \"setup.py\": cleandoc(\n                    f\"\"\"\n                    from setuptools import Extension, setup\n                    setup(\n                        name=\"myproj\",\n                        version=\"42\",\n                        ext_modules=[\n                            Extension(\n                                \"hello\", sources=[\"hello.pyx\"],\n                                depends=[{str(dep_path)!r}]\n                            )\n                        ],\n                    )\n                    \"\"\"\n                ),\n                \"hello.pyx\": \"\",\n                \"MANIFEST.in\": \"global-include *.h\",\n            },\n        }\n\n    @pytest.mark.parametrize(\n        \"dep_path\", (\"$tmp_path$/external/dir/file.h\", \"../external/dir/file.h\")\n    )\n    def test_external_path_in_extension_depends(self, monkeypatch, tmp_path, dep_path):\n        # Given a project with a \"depends\" targeting an external dir\n        files = self.files_for_external_path_in_extension_depends(tmp_path, dep_path)\n        jaraco.path.build(files, prefix=str(tmp_path))\n        # When `sdist` runs, there should be no error\n        members = run_sdist(monkeypatch, tmp_path / \"project\")\n        # and the sdist should not contain the external file\n        for name in members:\n            assert \"file.h\" not in name\n\n\ndef run_sdist(monkeypatch, project):\n    \"\"\"Given a project directory, run the sdist and return its contents\"\"\"\n    monkeypatch.chdir(project)\n    with quiet():\n        run_setup(\"setup.py\", [\"sdist\"])\n\n    archive = next((project / \"dist\").glob(\"*.tar.gz\"))\n    with tarfile.open(str(archive)) as tar:\n        return set(tar.getnames())\n\n\ndef test_sanity_check_setuptools_own_sdist(setuptools_sdist):\n    with tarfile.open(setuptools_sdist) as tar:\n        files = tar.getnames()\n\n    # setuptools sdist should not include the .tox folder\n    tox_files = [name for name in files if \".tox\" in name]\n    assert len(tox_files) == 0, f\"not empty {tox_files}\"\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_setopt.py","size":1365,"sha1":"117fd59592c28b5881ccc134af7a0df2ba88aa09","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import configparser\n\nfrom setuptools.command import setopt\n\n\nclass TestEdit:\n    @staticmethod\n    def parse_config(filename):\n        parser = configparser.ConfigParser()\n        with open(filename, encoding='utf-8') as reader:\n            parser.read_file(reader)\n        return parser\n\n    @staticmethod\n    def write_text(file, content):\n        with open(file, 'wb') as strm:\n            strm.write(content.encode('utf-8'))\n\n    def test_utf8_encoding_retained(self, tmpdir):\n        \"\"\"\n        When editing a file, non-ASCII characters encoded in\n        UTF-8 should be retained.\n        \"\"\"\n        config = tmpdir.join('setup.cfg')\n        self.write_text(str(config), '[names]\\njaraco=джарако')\n        setopt.edit_config(str(config), dict(names=dict(other='yes')))\n        parser = self.parse_config(str(config))\n        assert parser.get('names', 'jaraco') == 'джарако'\n        assert parser.get('names', 'other') == 'yes'\n\n    def test_case_retained(self, tmpdir):\n        \"\"\"\n        When editing a file, case of keys should be retained.\n        \"\"\"\n        config = tmpdir.join('setup.cfg')\n        self.write_text(str(config), '[names]\\nFoO=bAr')\n        setopt.edit_config(str(config), dict(names=dict(oTher='yes')))\n        actual = config.read_text(encoding='ascii')\n        assert 'FoO' in actual\n        assert 'oTher' in actual\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_setuptools.py","size":9008,"sha1":"6bdeddca1009e86447a7b1aec01ae8bbbdcde748","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Tests for the 'setuptools' package\"\"\"\n\nimport os\nimport re\nimport sys\nfrom zipfile import ZipFile\n\nimport pytest\nfrom packaging.version import Version\n\nimport setuptools\nimport setuptools.depends as dep\nimport setuptools.dist\nfrom setuptools.depends import Require\n\nimport distutils.cmd\nimport distutils.core\nfrom distutils.core import Extension\nfrom distutils.errors import DistutilsSetupError\n\n\n@pytest.fixture(autouse=True)\ndef isolated_dir(tmpdir_cwd):\n    return\n\n\ndef makeSetup(**args):\n    \"\"\"Return distribution from 'setup(**args)', without executing commands\"\"\"\n\n    distutils.core._setup_stop_after = \"commandline\"\n\n    # Don't let system command line leak into tests!\n    args.setdefault('script_args', ['install'])\n\n    try:\n        return setuptools.setup(**args)\n    finally:\n        distutils.core._setup_stop_after = None\n\n\nneeds_bytecode = pytest.mark.skipif(\n    not hasattr(dep, 'get_module_constant'),\n    reason=\"bytecode support not available\",\n)\n\n\nclass TestDepends:\n    def testExtractConst(self):\n        if not hasattr(dep, 'extract_constant'):\n            # skip on non-bytecode platforms\n            return\n\n        def f1():\n            global x, y, z\n            x = \"test\"\n            y = z  # pyright: ignore[reportUnboundVariable] # Explicitly testing for this runtime issue\n\n        fc = f1.__code__\n\n        # unrecognized name\n        assert dep.extract_constant(fc, 'q', -1) is None\n\n        # constant assigned\n        assert dep.extract_constant(fc, 'x', -1) == \"test\"\n\n        # expression assigned\n        assert dep.extract_constant(fc, 'y', -1) == -1\n\n        # recognized name, not assigned\n        assert dep.extract_constant(fc, 'z', -1) is None\n\n    def testFindModule(self):\n        with pytest.raises(ImportError):\n            dep.find_module('no-such.-thing')\n        with pytest.raises(ImportError):\n            dep.find_module('setuptools.non-existent')\n        f, _p, _i = dep.find_module('setuptools.tests')\n        f.close()\n\n    @needs_bytecode\n    def testModuleExtract(self):\n        from json import __version__\n\n        assert dep.get_module_constant('json', '__version__') == __version__\n        assert dep.get_module_constant('sys', 'version') == sys.version\n        assert (\n            dep.get_module_constant('setuptools.tests.test_setuptools', '__doc__')\n            == __doc__\n        )\n\n    @needs_bytecode\n    def testRequire(self):\n        req = Require('Json', '1.0.3', 'json')\n\n        assert req.name == 'Json'\n        assert req.module == 'json'\n        assert req.requested_version == Version('1.0.3')\n        assert req.attribute == '__version__'\n        assert req.full_name() == 'Json-1.0.3'\n\n        from json import __version__\n\n        assert str(req.get_version()) == __version__\n        assert req.version_ok('1.0.9')\n        assert not req.version_ok('0.9.1')\n        assert not req.version_ok('unknown')\n\n        assert req.is_present()\n        assert req.is_current()\n\n        req = Require('Do-what-I-mean', '1.0', 'd-w-i-m')\n        assert not req.is_present()\n        assert not req.is_current()\n\n    @needs_bytecode\n    def test_require_present(self):\n        # In #1896, this test was failing for months with the only\n        # complaint coming from test runners (not end users).\n        # TODO: Evaluate if this code is needed at all.\n        req = Require('Tests', None, 'tests', homepage=\"http://example.com\")\n        assert req.format is None\n        assert req.attribute is None\n        assert req.requested_version is None\n        assert req.full_name() == 'Tests'\n        assert req.homepage == 'http://example.com'\n\n        from setuptools.tests import __path__\n\n        paths = [os.path.dirname(p) for p in __path__]\n        assert req.is_present(paths)\n        assert req.is_current(paths)\n\n\nclass TestDistro:\n    def setup_method(self, method):\n        self.e1 = Extension('bar.ext', ['bar.c'])\n        self.e2 = Extension('c.y', ['y.c'])\n\n        self.dist = makeSetup(\n            packages=['a', 'a.b', 'a.b.c', 'b', 'c'],\n            py_modules=['b.d', 'x'],\n            ext_modules=(self.e1, self.e2),\n            package_dir={},\n        )\n\n    def testDistroType(self):\n        assert isinstance(self.dist, setuptools.dist.Distribution)\n\n    def testExcludePackage(self):\n        self.dist.exclude_package('a')\n        assert self.dist.packages == ['b', 'c']\n\n        self.dist.exclude_package('b')\n        assert self.dist.packages == ['c']\n        assert self.dist.py_modules == ['x']\n        assert self.dist.ext_modules == [self.e1, self.e2]\n\n        self.dist.exclude_package('c')\n        assert self.dist.packages == []\n        assert self.dist.py_modules == ['x']\n        assert self.dist.ext_modules == [self.e1]\n\n        # test removals from unspecified options\n        makeSetup().exclude_package('x')\n\n    def testIncludeExclude(self):\n        # remove an extension\n        self.dist.exclude(ext_modules=[self.e1])\n        assert self.dist.ext_modules == [self.e2]\n\n        # add it back in\n        self.dist.include(ext_modules=[self.e1])\n        assert self.dist.ext_modules == [self.e2, self.e1]\n\n        # should not add duplicate\n        self.dist.include(ext_modules=[self.e1])\n        assert self.dist.ext_modules == [self.e2, self.e1]\n\n    def testExcludePackages(self):\n        self.dist.exclude(packages=['c', 'b', 'a'])\n        assert self.dist.packages == []\n        assert self.dist.py_modules == ['x']\n        assert self.dist.ext_modules == [self.e1]\n\n    def testEmpty(self):\n        dist = makeSetup()\n        dist.include(packages=['a'], py_modules=['b'], ext_modules=[self.e2])\n        dist = makeSetup()\n        dist.exclude(packages=['a'], py_modules=['b'], ext_modules=[self.e2])\n\n    def testContents(self):\n        assert self.dist.has_contents_for('a')\n        self.dist.exclude_package('a')\n        assert not self.dist.has_contents_for('a')\n\n        assert self.dist.has_contents_for('b')\n        self.dist.exclude_package('b')\n        assert not self.dist.has_contents_for('b')\n\n        assert self.dist.has_contents_for('c')\n        self.dist.exclude_package('c')\n        assert not self.dist.has_contents_for('c')\n\n    def testInvalidIncludeExclude(self):\n        with pytest.raises(DistutilsSetupError):\n            self.dist.include(nonexistent_option='x')\n        with pytest.raises(DistutilsSetupError):\n            self.dist.exclude(nonexistent_option='x')\n        with pytest.raises(DistutilsSetupError):\n            self.dist.include(packages={'x': 'y'})\n        with pytest.raises(DistutilsSetupError):\n            self.dist.exclude(packages={'x': 'y'})\n        with pytest.raises(DistutilsSetupError):\n            self.dist.include(ext_modules={'x': 'y'})\n        with pytest.raises(DistutilsSetupError):\n            self.dist.exclude(ext_modules={'x': 'y'})\n\n        with pytest.raises(DistutilsSetupError):\n            self.dist.include(package_dir=['q'])\n        with pytest.raises(DistutilsSetupError):\n            self.dist.exclude(package_dir=['q'])\n\n\n@pytest.fixture\ndef example_source(tmpdir):\n    tmpdir.mkdir('foo')\n    (tmpdir / 'foo/bar.py').write('')\n    (tmpdir / 'readme.txt').write('')\n    return tmpdir\n\n\ndef test_findall(example_source):\n    found = list(setuptools.findall(str(example_source)))\n    expected = ['readme.txt', 'foo/bar.py']\n    expected = [example_source.join(fn) for fn in expected]\n    assert found == expected\n\n\ndef test_findall_curdir(example_source):\n    with example_source.as_cwd():\n        found = list(setuptools.findall())\n    expected = ['readme.txt', os.path.join('foo', 'bar.py')]\n    assert found == expected\n\n\n@pytest.fixture\ndef can_symlink(tmpdir):\n    \"\"\"\n    Skip if cannot create a symbolic link\n    \"\"\"\n    link_fn = 'link'\n    target_fn = 'target'\n    try:\n        os.symlink(target_fn, link_fn)\n    except (OSError, NotImplementedError, AttributeError):\n        pytest.skip(\"Cannot create symbolic links\")\n    os.remove(link_fn)\n\n\n@pytest.mark.usefixtures(\"can_symlink\")\ndef test_findall_missing_symlink(tmpdir):\n    with tmpdir.as_cwd():\n        os.symlink('foo', 'bar')\n        found = list(setuptools.findall())\n        assert found == []\n\n\n@pytest.mark.xfail(reason=\"unable to exclude tests; #4475 #3260\")\ndef test_its_own_wheel_does_not_contain_tests(setuptools_wheel):\n    with ZipFile(setuptools_wheel) as zipfile:\n        contents = [f.replace(os.sep, '/') for f in zipfile.namelist()]\n\n    for member in contents:\n        assert '/tests/' not in member\n\n\ndef test_wheel_includes_cli_scripts(setuptools_wheel):\n    with ZipFile(setuptools_wheel) as zipfile:\n        contents = [f.replace(os.sep, '/') for f in zipfile.namelist()]\n\n    assert any('cli-64.exe' in member for member in contents)\n\n\ndef test_wheel_includes_vendored_metadata(setuptools_wheel):\n    with ZipFile(setuptools_wheel) as zipfile:\n        contents = [f.replace(os.sep, '/') for f in zipfile.namelist()]\n\n    assert any(\n        re.search(r'_vendor/.*\\.dist-info/METADATA', member) for member in contents\n    )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_shutil_wrapper.py","size":641,"sha1":"692c747c9e6d74690eb1e0c8693714ccb5db7de9","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import stat\nimport sys\nfrom unittest.mock import Mock\n\nfrom setuptools import _shutil\n\n\ndef test_rmtree_readonly(monkeypatch, tmp_path):\n    \"\"\"Verify onerr works as expected\"\"\"\n\n    tmp_dir = tmp_path / \"with_readonly\"\n    tmp_dir.mkdir()\n    some_file = tmp_dir.joinpath(\"file.txt\")\n    some_file.touch()\n    some_file.chmod(stat.S_IREAD)\n\n    expected_count = 1 if sys.platform.startswith(\"win\") else 0\n    chmod_fn = Mock(wraps=_shutil.attempt_chmod_verbose)\n    monkeypatch.setattr(_shutil, \"attempt_chmod_verbose\", chmod_fn)\n\n    _shutil.rmtree(tmp_dir)\n    assert chmod_fn.call_count == expected_count\n    assert not tmp_dir.is_dir()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_unicode_utils.py","size":316,"sha1":"c175ce477b212626b5bbf7d887350a42efda459e","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from setuptools import unicode_utils\n\n\ndef test_filesys_decode_fs_encoding_is_None(monkeypatch):\n    \"\"\"\n    Test filesys_decode does not raise TypeError when\n    getfilesystemencoding returns None.\n    \"\"\"\n    monkeypatch.setattr('sys.getfilesystemencoding', lambda: None)\n    unicode_utils.filesys_decode(b'test')\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_virtualenv.py","size":3730,"sha1":"ebaff0d631182acfdfb62c797650e61e2dc45b82","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import os\nimport subprocess\nimport sys\nfrom urllib.error import URLError\nfrom urllib.request import urlopen\n\nimport pytest\n\n\n@pytest.fixture(autouse=True)\ndef pytest_virtualenv_works(venv):\n    \"\"\"\n    pytest_virtualenv may not work. if it doesn't, skip these\n    tests. See #1284.\n    \"\"\"\n    venv_prefix = venv.run([\"python\", \"-c\", \"import sys; print(sys.prefix)\"]).strip()\n    if venv_prefix == sys.prefix:\n        pytest.skip(\"virtualenv is broken (see pypa/setuptools#1284)\")\n\n\ndef test_clean_env_install(venv_without_setuptools, setuptools_wheel):\n    \"\"\"\n    Check setuptools can be installed in a clean environment.\n    \"\"\"\n    cmd = [\"python\", \"-m\", \"pip\", \"install\", str(setuptools_wheel)]\n    venv_without_setuptools.run(cmd)\n\n\ndef access_pypi():\n    # Detect if tests are being run without connectivity\n    if not os.environ.get('NETWORK_REQUIRED', False):  # pragma: nocover\n        try:\n            urlopen('https://pypi.org', timeout=1)\n        except URLError:\n            # No network, disable most of these tests\n            return False\n\n    return True\n\n\n@pytest.mark.skipif(\n    'platform.python_implementation() == \"PyPy\"',\n    reason=\"https://github.com/pypa/setuptools/pull/2865#issuecomment-965834995\",\n)\n@pytest.mark.skipif(not access_pypi(), reason=\"no network\")\n# ^-- Even when it is not necessary to install a different version of `pip`\n#     the build process will still try to download `wheel`, see #3147 and #2986.\n@pytest.mark.parametrize(\n    'pip_version',\n    [\n        None,\n        pytest.param(\n            'pip<20.1',\n            marks=pytest.mark.xfail(\n                'sys.version_info >= (3, 12)',\n                reason=\"pip 23.1.2 required for Python 3.12 and later\",\n            ),\n        ),\n        pytest.param(\n            'pip<21',\n            marks=pytest.mark.xfail(\n                'sys.version_info >= (3, 12)',\n                reason=\"pip 23.1.2 required for Python 3.12 and later\",\n            ),\n        ),\n        pytest.param(\n            'pip<22',\n            marks=pytest.mark.xfail(\n                'sys.version_info >= (3, 12)',\n                reason=\"pip 23.1.2 required for Python 3.12 and later\",\n            ),\n        ),\n        pytest.param(\n            'pip<23',\n            marks=pytest.mark.xfail(\n                'sys.version_info >= (3, 12)',\n                reason=\"pip 23.1.2 required for Python 3.12 and later\",\n            ),\n        ),\n        pytest.param(\n            'https://github.com/pypa/pip/archive/main.zip',\n            marks=pytest.mark.xfail(reason='#2975'),\n        ),\n    ],\n)\ndef test_pip_upgrade_from_source(\n    pip_version, venv_without_setuptools, setuptools_wheel, setuptools_sdist\n):\n    \"\"\"\n    Check pip can upgrade setuptools from source.\n    \"\"\"\n    # Install pip/wheel, in a venv without setuptools (as it\n    # should not be needed for bootstrapping from source)\n    venv = venv_without_setuptools\n    venv.run([\"pip\", \"install\", \"-U\", \"wheel\"])\n    if pip_version is not None:\n        venv.run([\"python\", \"-m\", \"pip\", \"install\", \"-U\", pip_version, \"--retries=1\"])\n    with pytest.raises(subprocess.CalledProcessError):\n        # Meta-test to make sure setuptools is not installed\n        venv.run([\"python\", \"-c\", \"import setuptools\"])\n\n    # Then install from wheel.\n    venv.run([\"pip\", \"install\", str(setuptools_wheel)])\n    # And finally try to upgrade from source.\n    venv.run([\"pip\", \"install\", \"--no-cache-dir\", \"--upgrade\", str(setuptools_sdist)])\n\n\ndef test_no_missing_dependencies(bare_venv, request):\n    \"\"\"\n    Quick and dirty test to ensure all external dependencies are vendored.\n    \"\"\"\n    setuptools_dir = request.config.rootdir\n    bare_venv.run(['python', 'setup.py', '--help'], cwd=setuptools_dir)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_warnings.py","size":3347,"sha1":"410a3dd774e74470dd915c6c1e334a574c0eba50","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from inspect import cleandoc\n\nimport pytest\n\nfrom setuptools.warnings import SetuptoolsDeprecationWarning, SetuptoolsWarning\n\n_EXAMPLES = {\n    \"default\": dict(\n        args=(\"Hello {x}\", \"\\n\\t{target} {v:.1f}\"),\n        kwargs={\"x\": 5, \"v\": 3, \"target\": \"World\"},\n        expected=\"\"\"\n    Hello 5\n    !!\n\n            ********************************************************************************\n            World 3.0\n            ********************************************************************************\n\n    !!\n    \"\"\",\n    ),\n    \"futue_due_date\": dict(\n        args=(\"Summary\", \"Lorem ipsum\"),\n        kwargs={\"due_date\": (9999, 11, 22)},\n        expected=\"\"\"\n    Summary\n    !!\n\n            ********************************************************************************\n            Lorem ipsum\n\n            By 9999-Nov-22, you need to update your project and remove deprecated calls\n            or your builds will no longer be supported.\n            ********************************************************************************\n\n    !!\n    \"\"\",\n    ),\n    \"past_due_date_with_docs\": dict(\n        args=(\"Summary\", \"Lorem ipsum\"),\n        kwargs={\"due_date\": (2000, 11, 22), \"see_docs\": \"some_page.html\"},\n        expected=\"\"\"\n    Summary\n    !!\n\n            ********************************************************************************\n            Lorem ipsum\n\n            This deprecation is overdue, please update your project and remove deprecated\n            calls to avoid build errors in the future.\n\n            See https://setuptools.pypa.io/en/latest/some_page.html for details.\n            ********************************************************************************\n\n    !!\n    \"\"\",\n    ),\n}\n\n\n@pytest.mark.parametrize(\"example_name\", _EXAMPLES.keys())\ndef test_formatting(monkeypatch, example_name):\n    \"\"\"\n    It should automatically handle indentation, interpolation and things like due date.\n    \"\"\"\n    args = _EXAMPLES[example_name][\"args\"]\n    kwargs = _EXAMPLES[example_name][\"kwargs\"]\n    expected = _EXAMPLES[example_name][\"expected\"]\n\n    monkeypatch.setenv(\"SETUPTOOLS_ENFORCE_DEPRECATION\", \"false\")\n    with pytest.warns(SetuptoolsWarning) as warn_info:\n        SetuptoolsWarning.emit(*args, **kwargs)\n    assert _get_message(warn_info) == cleandoc(expected)\n\n\ndef test_due_date_enforcement(monkeypatch):\n    class _MyDeprecation(SetuptoolsDeprecationWarning):\n        _SUMMARY = \"Summary\"\n        _DETAILS = \"Lorem ipsum\"\n        _DUE_DATE = (2000, 11, 22)\n        _SEE_DOCS = \"some_page.html\"\n\n    monkeypatch.setenv(\"SETUPTOOLS_ENFORCE_DEPRECATION\", \"true\")\n    with pytest.raises(SetuptoolsDeprecationWarning) as exc_info:\n        _MyDeprecation.emit()\n\n    expected = \"\"\"\n    Summary\n    !!\n\n            ********************************************************************************\n            Lorem ipsum\n\n            This deprecation is overdue, please update your project and remove deprecated\n            calls to avoid build errors in the future.\n\n            See https://setuptools.pypa.io/en/latest/some_page.html for details.\n            ********************************************************************************\n\n    !!\n    \"\"\"\n    assert str(exc_info.value) == cleandoc(expected)\n\n\ndef _get_message(warn_info):\n    return next(warn.message.args[0] for warn in warn_info)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_wheel.py","size":19370,"sha1":"6bb3f257b307e6aa837a3fbe9eb86c2ed36dc6fc","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"wheel tests\"\"\"\n\nfrom __future__ import annotations\n\nimport contextlib\nimport glob\nimport inspect\nimport os\nimport pathlib\nimport shutil\nimport stat\nimport subprocess\nimport sys\nimport zipfile\nfrom typing import Any\n\nimport pytest\nfrom jaraco import path\nfrom packaging.tags import parse_tag\nfrom packaging.utils import canonicalize_name\n\nfrom pkg_resources import PY_MAJOR, Distribution, PathMetadata\nfrom setuptools.wheel import Wheel\n\nfrom .contexts import tempdir\nfrom .textwrap import DALS\n\nfrom distutils.sysconfig import get_config_var\nfrom distutils.util import get_platform\n\nWHEEL_INFO_TESTS = (\n    ('invalid.whl', ValueError),\n    (\n        'simplewheel-2.0-1-py2.py3-none-any.whl',\n        {\n            'project_name': 'simplewheel',\n            'version': '2.0',\n            'build': '1',\n            'py_version': 'py2.py3',\n            'abi': 'none',\n            'platform': 'any',\n        },\n    ),\n    (\n        'simple.dist-0.1-py2.py3-none-any.whl',\n        {\n            'project_name': 'simple.dist',\n            'version': '0.1',\n            'build': None,\n            'py_version': 'py2.py3',\n            'abi': 'none',\n            'platform': 'any',\n        },\n    ),\n    (\n        'example_pkg_a-1-py3-none-any.whl',\n        {\n            'project_name': 'example_pkg_a',\n            'version': '1',\n            'build': None,\n            'py_version': 'py3',\n            'abi': 'none',\n            'platform': 'any',\n        },\n    ),\n    (\n        'PyQt5-5.9-5.9.1-cp35.cp36.cp37-abi3-manylinux1_x86_64.whl',\n        {\n            'project_name': 'PyQt5',\n            'version': '5.9',\n            'build': '5.9.1',\n            'py_version': 'cp35.cp36.cp37',\n            'abi': 'abi3',\n            'platform': 'manylinux1_x86_64',\n        },\n    ),\n)\n\n\n@pytest.mark.parametrize(\n    ('filename', 'info'), WHEEL_INFO_TESTS, ids=[t[0] for t in WHEEL_INFO_TESTS]\n)\ndef test_wheel_info(filename, info):\n    if inspect.isclass(info):\n        with pytest.raises(info):\n            Wheel(filename)\n        return\n    w = Wheel(filename)\n    assert {k: getattr(w, k) for k in info.keys()} == info\n\n\n@contextlib.contextmanager\ndef build_wheel(extra_file_defs=None, **kwargs):\n    file_defs = {\n        'setup.py': (\n            DALS(\n                \"\"\"\n            # -*- coding: utf-8 -*-\n            from setuptools import setup\n            import setuptools\n            setup(**%r)\n            \"\"\"\n            )\n            % kwargs\n        ).encode('utf-8'),\n    }\n    if extra_file_defs:\n        file_defs.update(extra_file_defs)\n    with tempdir() as source_dir:\n        path.build(file_defs, source_dir)\n        subprocess.check_call(\n            (sys.executable, 'setup.py', '-q', 'bdist_wheel'), cwd=source_dir\n        )\n        yield glob.glob(os.path.join(source_dir, 'dist', '*.whl'))[0]\n\n\ndef tree_set(root):\n    contents = set()\n    for dirpath, dirnames, filenames in os.walk(root):\n        for filename in filenames:\n            contents.add(os.path.join(os.path.relpath(dirpath, root), filename))\n    return contents\n\n\ndef flatten_tree(tree):\n    \"\"\"Flatten nested dicts and lists into a full list of paths\"\"\"\n    output = set()\n    for node, contents in tree.items():\n        if isinstance(contents, dict):\n            contents = flatten_tree(contents)\n\n        for elem in contents:\n            if isinstance(elem, dict):\n                output |= {os.path.join(node, val) for val in flatten_tree(elem)}\n            else:\n                output.add(os.path.join(node, elem))\n    return output\n\n\ndef format_install_tree(tree):\n    return {\n        x.format(\n            py_version=PY_MAJOR,\n            platform=get_platform(),\n            shlib_ext=get_config_var('EXT_SUFFIX') or get_config_var('SO'),\n        )\n        for x in tree\n    }\n\n\ndef _check_wheel_install(\n    filename, install_dir, install_tree_includes, project_name, version, requires_txt\n):\n    w = Wheel(filename)\n    egg_path = os.path.join(install_dir, w.egg_name())\n    w.install_as_egg(egg_path)\n    if install_tree_includes is not None:\n        install_tree = format_install_tree(install_tree_includes)\n        exp = tree_set(install_dir)\n        assert install_tree.issubset(exp), install_tree - exp\n\n    metadata = PathMetadata(egg_path, os.path.join(egg_path, 'EGG-INFO'))\n    dist = Distribution.from_filename(egg_path, metadata=metadata)\n    assert dist.project_name == project_name\n    assert dist.version == version\n    if requires_txt is None:\n        assert not dist.has_metadata('requires.txt')\n    else:\n        # Order must match to ensure reproducibility.\n        assert requires_txt == dist.get_metadata('requires.txt').lstrip()\n\n\nclass Record:\n    def __init__(self, id, **kwargs):\n        self._id = id\n        self._fields = kwargs\n\n    def __repr__(self) -> str:\n        return f'{self._id}(**{self._fields!r})'\n\n\n# Using Any to avoid possible type union issues later in test\n# making a TypedDict is not worth in a test and anonymous/inline TypedDict are experimental\n# https://github.com/python/mypy/issues/9884\nWHEEL_INSTALL_TESTS: tuple[dict[str, Any], ...] = (\n    dict(\n        id='basic',\n        file_defs={'foo': {'__init__.py': ''}},\n        setup_kwargs=dict(\n            packages=['foo'],\n        ),\n        install_tree=flatten_tree({\n            'foo-1.0-py{py_version}.egg': {\n                'EGG-INFO': ['PKG-INFO', 'RECORD', 'WHEEL', 'top_level.txt'],\n                'foo': ['__init__.py'],\n            }\n        }),\n    ),\n    dict(\n        id='utf-8',\n        setup_kwargs=dict(\n            description='Description accentuée',\n        ),\n    ),\n    dict(\n        id='data',\n        file_defs={\n            'data.txt': DALS(\n                \"\"\"\n                Some data...\n                \"\"\"\n            ),\n        },\n        setup_kwargs=dict(\n            data_files=[('data_dir', ['data.txt'])],\n        ),\n        install_tree=flatten_tree({\n            'foo-1.0-py{py_version}.egg': {\n                'EGG-INFO': ['PKG-INFO', 'RECORD', 'WHEEL', 'top_level.txt'],\n                'data_dir': ['data.txt'],\n            }\n        }),\n    ),\n    dict(\n        id='extension',\n        file_defs={\n            'extension.c': DALS(\n                \"\"\"\n                #include \"Python.h\"\n\n                #if PY_MAJOR_VERSION >= 3\n\n                static struct PyModuleDef moduledef = {\n                        PyModuleDef_HEAD_INIT,\n                        \"extension\",\n                        NULL,\n                        0,\n                        NULL,\n                        NULL,\n                        NULL,\n                        NULL,\n                        NULL\n                };\n\n                #define INITERROR return NULL\n\n                PyMODINIT_FUNC PyInit_extension(void)\n\n                #else\n\n                #define INITERROR return\n\n                void initextension(void)\n\n                #endif\n                {\n                #if PY_MAJOR_VERSION >= 3\n                    PyObject *module = PyModule_Create(&moduledef);\n                #else\n                    PyObject *module = Py_InitModule(\"extension\", NULL);\n                #endif\n                    if (module == NULL)\n                        INITERROR;\n                #if PY_MAJOR_VERSION >= 3\n                    return module;\n                #endif\n                }\n                \"\"\"\n            ),\n        },\n        setup_kwargs=dict(\n            ext_modules=[\n                Record(\n                    'setuptools.Extension', name='extension', sources=['extension.c']\n                )\n            ],\n        ),\n        install_tree=flatten_tree({\n            'foo-1.0-py{py_version}-{platform}.egg': [\n                'extension{shlib_ext}',\n                {\n                    'EGG-INFO': [\n                        'PKG-INFO',\n                        'RECORD',\n                        'WHEEL',\n                        'top_level.txt',\n                    ]\n                },\n            ]\n        }),\n    ),\n    dict(\n        id='header',\n        file_defs={\n            'header.h': DALS(\n                \"\"\"\n                \"\"\"\n            ),\n        },\n        setup_kwargs=dict(\n            headers=['header.h'],\n        ),\n        install_tree=flatten_tree({\n            'foo-1.0-py{py_version}.egg': [\n                'header.h',\n                {\n                    'EGG-INFO': [\n                        'PKG-INFO',\n                        'RECORD',\n                        'WHEEL',\n                        'top_level.txt',\n                    ]\n                },\n            ]\n        }),\n    ),\n    dict(\n        id='script',\n        file_defs={\n            'script.py': DALS(\n                \"\"\"\n                #/usr/bin/python\n                print('hello world!')\n                \"\"\"\n            ),\n            'script.sh': DALS(\n                \"\"\"\n                #/bin/sh\n                echo 'hello world!'\n                \"\"\"\n            ),\n        },\n        setup_kwargs=dict(\n            scripts=['script.py', 'script.sh'],\n        ),\n        install_tree=flatten_tree({\n            'foo-1.0-py{py_version}.egg': {\n                'EGG-INFO': [\n                    'PKG-INFO',\n                    'RECORD',\n                    'WHEEL',\n                    'top_level.txt',\n                    {'scripts': ['script.py', 'script.sh']},\n                ]\n            }\n        }),\n    ),\n    dict(\n        id='requires1',\n        install_requires='foobar==2.0',\n        install_tree=flatten_tree({\n            'foo-1.0-py{py_version}.egg': {\n                'EGG-INFO': [\n                    'PKG-INFO',\n                    'RECORD',\n                    'WHEEL',\n                    'requires.txt',\n                    'top_level.txt',\n                ]\n            }\n        }),\n        requires_txt=DALS(\n            \"\"\"\n            foobar==2.0\n            \"\"\"\n        ),\n    ),\n    dict(\n        id='requires2',\n        install_requires=f\"\"\"\n        bar\n        foo<=2.0; {sys.platform!r} in sys_platform\n        \"\"\",\n        requires_txt=DALS(\n            \"\"\"\n            bar\n            foo<=2.0\n            \"\"\"\n        ),\n    ),\n    dict(\n        id='requires3',\n        install_requires=f\"\"\"\n        bar; {sys.platform!r} != sys_platform\n        \"\"\",\n    ),\n    dict(\n        id='requires4',\n        install_requires=\"\"\"\n        foo\n        \"\"\",\n        extras_require={\n            'extra': 'foobar>3',\n        },\n        requires_txt=DALS(\n            \"\"\"\n            foo\n\n            [extra]\n            foobar>3\n            \"\"\"\n        ),\n    ),\n    dict(\n        id='requires5',\n        extras_require={\n            'extra': f'foobar; {sys.platform!r} != sys_platform',\n        },\n        requires_txt=DALS(\n            \"\"\"\n            [extra]\n            \"\"\"\n        ),\n    ),\n    dict(\n        id='requires_ensure_order',\n        install_requires=\"\"\"\n        foo\n        bar\n        baz\n        qux\n        \"\"\",\n        extras_require={\n            'extra': \"\"\"\n            foobar>3\n            barbaz>4\n            bazqux>5\n            quxzap>6\n            \"\"\",\n        },\n        requires_txt=DALS(\n            \"\"\"\n            foo\n            bar\n            baz\n            qux\n\n            [extra]\n            foobar>3\n            barbaz>4\n            bazqux>5\n            quxzap>6\n            \"\"\"\n        ),\n    ),\n    dict(\n        id='namespace_package',\n        file_defs={\n            'foo': {\n                'bar': {'__init__.py': ''},\n            },\n        },\n        setup_kwargs=dict(\n            namespace_packages=['foo'],\n            packages=['foo.bar'],\n        ),\n        install_tree=flatten_tree({\n            'foo-1.0-py{py_version}.egg': [\n                'foo-1.0-py{py_version}-nspkg.pth',\n                {\n                    'EGG-INFO': [\n                        'PKG-INFO',\n                        'RECORD',\n                        'WHEEL',\n                        'namespace_packages.txt',\n                        'top_level.txt',\n                    ]\n                },\n                {\n                    'foo': [\n                        '__init__.py',\n                        {'bar': ['__init__.py']},\n                    ]\n                },\n            ]\n        }),\n    ),\n    dict(\n        id='empty_namespace_package',\n        file_defs={\n            'foobar': {\n                '__init__.py': (\n                    \"__import__('pkg_resources').declare_namespace(__name__)\"\n                )\n            },\n        },\n        setup_kwargs=dict(\n            namespace_packages=['foobar'],\n            packages=['foobar'],\n        ),\n        install_tree=flatten_tree({\n            'foo-1.0-py{py_version}.egg': [\n                'foo-1.0-py{py_version}-nspkg.pth',\n                {\n                    'EGG-INFO': [\n                        'PKG-INFO',\n                        'RECORD',\n                        'WHEEL',\n                        'namespace_packages.txt',\n                        'top_level.txt',\n                    ]\n                },\n                {\n                    'foobar': [\n                        '__init__.py',\n                    ]\n                },\n            ]\n        }),\n    ),\n    dict(\n        id='data_in_package',\n        file_defs={\n            'foo': {\n                '__init__.py': '',\n                'data_dir': {\n                    'data.txt': DALS(\n                        \"\"\"\n                        Some data...\n                        \"\"\"\n                    ),\n                },\n            }\n        },\n        setup_kwargs=dict(\n            packages=['foo'],\n            data_files=[('foo/data_dir', ['foo/data_dir/data.txt'])],\n        ),\n        install_tree=flatten_tree({\n            'foo-1.0-py{py_version}.egg': {\n                'EGG-INFO': [\n                    'PKG-INFO',\n                    'RECORD',\n                    'WHEEL',\n                    'top_level.txt',\n                ],\n                'foo': [\n                    '__init__.py',\n                    {\n                        'data_dir': [\n                            'data.txt',\n                        ]\n                    },\n                ],\n            }\n        }),\n    ),\n)\n\n\n@pytest.mark.parametrize(\n    'params',\n    WHEEL_INSTALL_TESTS,\n    ids=[params['id'] for params in WHEEL_INSTALL_TESTS],\n)\ndef test_wheel_install(params):\n    project_name = params.get('name', 'foo')\n    version = params.get('version', '1.0')\n    install_requires = params.get('install_requires', [])\n    extras_require = params.get('extras_require', {})\n    requires_txt = params.get('requires_txt', None)\n    install_tree = params.get('install_tree')\n    file_defs = params.get('file_defs', {})\n    setup_kwargs = params.get('setup_kwargs', {})\n    with (\n        build_wheel(\n            name=project_name,\n            version=version,\n            install_requires=install_requires,\n            extras_require=extras_require,\n            extra_file_defs=file_defs,\n            **setup_kwargs,\n        ) as filename,\n        tempdir() as install_dir,\n    ):\n        _check_wheel_install(\n            filename, install_dir, install_tree, project_name, version, requires_txt\n        )\n\n\ndef test_wheel_install_pep_503():\n    project_name = 'Foo_Bar'  # PEP 503 canonicalized name is \"foo-bar\"\n    version = '1.0'\n    with (\n        build_wheel(\n            name=project_name,\n            version=version,\n        ) as filename,\n        tempdir() as install_dir,\n    ):\n        new_filename = filename.replace(project_name, canonicalize_name(project_name))\n        shutil.move(filename, new_filename)\n        _check_wheel_install(\n            new_filename,\n            install_dir,\n            None,\n            canonicalize_name(project_name),\n            version,\n            None,\n        )\n\n\ndef test_wheel_no_dist_dir():\n    project_name = 'nodistinfo'\n    version = '1.0'\n    wheel_name = f'{project_name}-{version}-py2.py3-none-any.whl'\n    with tempdir() as source_dir:\n        wheel_path = os.path.join(source_dir, wheel_name)\n        # create an empty zip file\n        zipfile.ZipFile(wheel_path, 'w').close()\n        with tempdir() as install_dir:\n            with pytest.raises(ValueError):\n                _check_wheel_install(\n                    wheel_path, install_dir, None, project_name, version, None\n                )\n\n\ndef test_wheel_is_compatible(monkeypatch):\n    def sys_tags():\n        return {\n            (t.interpreter, t.abi, t.platform)\n            for t in parse_tag('cp36-cp36m-manylinux1_x86_64')\n        }\n\n    monkeypatch.setattr('setuptools.wheel._get_supported_tags', sys_tags)\n    assert Wheel('onnxruntime-0.1.2-cp36-cp36m-manylinux1_x86_64.whl').is_compatible()\n\n\ndef test_wheel_mode():\n    @contextlib.contextmanager\n    def build_wheel(extra_file_defs=None, **kwargs):\n        file_defs = {\n            'setup.py': (\n                DALS(\n                    \"\"\"\n                # -*- coding: utf-8 -*-\n                from setuptools import setup\n                import setuptools\n                setup(**%r)\n                \"\"\"\n                )\n                % kwargs\n            ).encode('utf-8'),\n        }\n        if extra_file_defs:\n            file_defs.update(extra_file_defs)\n        with tempdir() as source_dir:\n            path.build(file_defs, source_dir)\n            runsh = pathlib.Path(source_dir) / \"script.sh\"\n            os.chmod(runsh, 0o777)\n            subprocess.check_call(\n                (sys.executable, 'setup.py', '-q', 'bdist_wheel'), cwd=source_dir\n            )\n            yield glob.glob(os.path.join(source_dir, 'dist', '*.whl'))[0]\n\n    params = dict(\n        id='script',\n        file_defs={\n            'script.py': DALS(\n                \"\"\"\n                #/usr/bin/python\n                print('hello world!')\n                \"\"\"\n            ),\n            'script.sh': DALS(\n                \"\"\"\n                #/bin/sh\n                echo 'hello world!'\n                \"\"\"\n            ),\n        },\n        setup_kwargs=dict(\n            scripts=['script.py', 'script.sh'],\n        ),\n        install_tree=flatten_tree({\n            'foo-1.0-py{py_version}.egg': {\n                'EGG-INFO': [\n                    'PKG-INFO',\n                    'RECORD',\n                    'WHEEL',\n                    'top_level.txt',\n                    {'scripts': ['script.py', 'script.sh']},\n                ]\n            }\n        }),\n    )\n\n    project_name = params.get('name', 'foo')\n    version = params.get('version', '1.0')\n    install_tree = params.get('install_tree')\n    file_defs = params.get('file_defs', {})\n    setup_kwargs = params.get('setup_kwargs', {})\n\n    with (\n        build_wheel(\n            name=project_name,\n            version=version,\n            install_requires=[],\n            extras_require={},\n            extra_file_defs=file_defs,\n            **setup_kwargs,\n        ) as filename,\n        tempdir() as install_dir,\n    ):\n        _check_wheel_install(\n            filename, install_dir, install_tree, project_name, version, None\n        )\n        w = Wheel(filename)\n        base = pathlib.Path(install_dir) / w.egg_name()\n        script_sh = base / \"EGG-INFO\" / \"scripts\" / \"script.sh\"\n        assert script_sh.exists()\n        if sys.platform != 'win32':\n            # Editable file mode has no effect on Windows\n            assert oct(stat.S_IMODE(script_sh.stat().st_mode)) == \"0o777\"\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/test_windows_wrappers.py","size":7881,"sha1":"dc6e809a88e2f952b600dd50cb5ced43a75c35ec","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nPython Script Wrapper for Windows\n=================================\n\nsetuptools includes wrappers for Python scripts that allows them to be\nexecuted like regular windows programs.  There are 2 wrappers, one\nfor command-line programs, cli.exe, and one for graphical programs,\ngui.exe.  These programs are almost identical, function pretty much\nthe same way, and are generated from the same source file.  The\nwrapper programs are used by copying them to the directory containing\nthe script they are to wrap and with the same name as the script they\nare to wrap.\n\"\"\"\n\nimport pathlib\nimport platform\nimport subprocess\nimport sys\nimport textwrap\n\nimport pytest\n\nimport pkg_resources\nfrom setuptools.command.easy_install import nt_quote_arg\n\npytestmark = pytest.mark.skipif(sys.platform != 'win32', reason=\"Windows only\")\n\n\nclass WrapperTester:\n    @classmethod\n    def prep_script(cls, template):\n        python_exe = nt_quote_arg(sys.executable)\n        return template % locals()\n\n    @classmethod\n    def create_script(cls, tmpdir):\n        \"\"\"\n        Create a simple script, foo-script.py\n\n        Note that the script starts with a Unix-style '#!' line saying which\n        Python executable to run.  The wrapper will use this line to find the\n        correct Python executable.\n        \"\"\"\n\n        script = cls.prep_script(cls.script_tmpl)\n\n        with (tmpdir / cls.script_name).open('w') as f:\n            f.write(script)\n\n        # also copy cli.exe to the sample directory\n        with (tmpdir / cls.wrapper_name).open('wb') as f:\n            w = pkg_resources.resource_string('setuptools', cls.wrapper_source)\n            f.write(w)\n\n\ndef win_launcher_exe(prefix):\n    \"\"\"A simple routine to select launcher script based on platform.\"\"\"\n    assert prefix in ('cli', 'gui')\n    if platform.machine() == \"ARM64\":\n        return f\"{prefix}-arm64.exe\"\n    else:\n        return f\"{prefix}-32.exe\"\n\n\nclass TestCLI(WrapperTester):\n    script_name = 'foo-script.py'\n    wrapper_name = 'foo.exe'\n    wrapper_source = win_launcher_exe('cli')\n\n    script_tmpl = textwrap.dedent(\n        \"\"\"\n        #!%(python_exe)s\n        import sys\n        input = repr(sys.stdin.read())\n        print(sys.argv[0][-14:])\n        print(sys.argv[1:])\n        print(input)\n        if __debug__:\n            print('non-optimized')\n        \"\"\"\n    ).lstrip()\n\n    def test_basic(self, tmpdir):\n        \"\"\"\n        When the copy of cli.exe, foo.exe in this example, runs, it examines\n        the path name it was run with and computes a Python script path name\n        by removing the '.exe' suffix and adding the '-script.py' suffix. (For\n        GUI programs, the suffix '-script.pyw' is added.)  This is why we\n        named out script the way we did.  Now we can run out script by running\n        the wrapper:\n\n        This example was a little pathological in that it exercised windows\n        (MS C runtime) quoting rules:\n\n        - Strings containing spaces are surrounded by double quotes.\n\n        - Double quotes in strings need to be escaped by preceding them with\n          back slashes.\n\n        - One or more backslashes preceding double quotes need to be escaped\n          by preceding each of them with back slashes.\n        \"\"\"\n        self.create_script(tmpdir)\n        cmd = [\n            str(tmpdir / 'foo.exe'),\n            'arg1',\n            'arg 2',\n            'arg \"2\\\\\"',\n            'arg 4\\\\',\n            'arg5 a\\\\\\\\b',\n        ]\n        proc = subprocess.Popen(\n            cmd,\n            stdout=subprocess.PIPE,\n            stdin=subprocess.PIPE,\n            text=True,\n            encoding=\"utf-8\",\n        )\n        stdout, _stderr = proc.communicate('hello\\nworld\\n')\n        actual = stdout.replace('\\r\\n', '\\n')\n        expected = textwrap.dedent(\n            r\"\"\"\n            \\foo-script.py\n            ['arg1', 'arg 2', 'arg \"2\\\\\"', 'arg 4\\\\', 'arg5 a\\\\\\\\b']\n            'hello\\nworld\\n'\n            non-optimized\n            \"\"\"\n        ).lstrip()\n        assert actual == expected\n\n    def test_symlink(self, tmpdir):\n        \"\"\"\n        Ensure that symlink for the foo.exe is working correctly.\n        \"\"\"\n        script_dir = tmpdir / \"script_dir\"\n        script_dir.mkdir()\n        self.create_script(script_dir)\n        symlink = pathlib.Path(tmpdir / \"foo.exe\")\n        symlink.symlink_to(script_dir / \"foo.exe\")\n\n        cmd = [\n            str(tmpdir / 'foo.exe'),\n            'arg1',\n            'arg 2',\n            'arg \"2\\\\\"',\n            'arg 4\\\\',\n            'arg5 a\\\\\\\\b',\n        ]\n        proc = subprocess.Popen(\n            cmd,\n            stdout=subprocess.PIPE,\n            stdin=subprocess.PIPE,\n            text=True,\n            encoding=\"utf-8\",\n        )\n        stdout, _stderr = proc.communicate('hello\\nworld\\n')\n        actual = stdout.replace('\\r\\n', '\\n')\n        expected = textwrap.dedent(\n            r\"\"\"\n            \\foo-script.py\n            ['arg1', 'arg 2', 'arg \"2\\\\\"', 'arg 4\\\\', 'arg5 a\\\\\\\\b']\n            'hello\\nworld\\n'\n            non-optimized\n            \"\"\"\n        ).lstrip()\n        assert actual == expected\n\n    def test_with_options(self, tmpdir):\n        \"\"\"\n        Specifying Python Command-line Options\n        --------------------------------------\n\n        You can specify a single argument on the '#!' line.  This can be used\n        to specify Python options like -O, to run in optimized mode or -i\n        to start the interactive interpreter.  You can combine multiple\n        options as usual. For example, to run in optimized mode and\n        enter the interpreter after running the script, you could use -Oi:\n        \"\"\"\n        self.create_script(tmpdir)\n        tmpl = textwrap.dedent(\n            \"\"\"\n            #!%(python_exe)s  -Oi\n            import sys\n            input = repr(sys.stdin.read())\n            print(sys.argv[0][-14:])\n            print(sys.argv[1:])\n            print(input)\n            if __debug__:\n                print('non-optimized')\n            sys.ps1 = '---'\n            \"\"\"\n        ).lstrip()\n        with (tmpdir / 'foo-script.py').open('w') as f:\n            f.write(self.prep_script(tmpl))\n        cmd = [str(tmpdir / 'foo.exe')]\n        proc = subprocess.Popen(\n            cmd,\n            stdout=subprocess.PIPE,\n            stdin=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            text=True,\n            encoding=\"utf-8\",\n        )\n        stdout, _stderr = proc.communicate()\n        actual = stdout.replace('\\r\\n', '\\n')\n        expected = textwrap.dedent(\n            r\"\"\"\n            \\foo-script.py\n            []\n            ''\n            ---\n            \"\"\"\n        ).lstrip()\n        assert actual == expected\n\n\nclass TestGUI(WrapperTester):\n    \"\"\"\n    Testing the GUI Version\n    -----------------------\n    \"\"\"\n\n    script_name = 'bar-script.pyw'\n    wrapper_source = win_launcher_exe('gui')\n    wrapper_name = 'bar.exe'\n\n    script_tmpl = textwrap.dedent(\n        \"\"\"\n        #!%(python_exe)s\n        import sys\n        f = open(sys.argv[1], 'wb')\n        bytes_written = f.write(repr(sys.argv[2]).encode('utf-8'))\n        f.close()\n        \"\"\"\n    ).strip()\n\n    def test_basic(self, tmpdir):\n        \"\"\"Test the GUI version with the simple script, bar-script.py\"\"\"\n        self.create_script(tmpdir)\n\n        cmd = [\n            str(tmpdir / 'bar.exe'),\n            str(tmpdir / 'test_output.txt'),\n            'Test Argument',\n        ]\n        proc = subprocess.Popen(\n            cmd,\n            stdout=subprocess.PIPE,\n            stdin=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            text=True,\n            encoding=\"utf-8\",\n        )\n        stdout, stderr = proc.communicate()\n        assert not stdout\n        assert not stderr\n        with (tmpdir / 'test_output.txt').open('rb') as f_out:\n            actual = f_out.read().decode('ascii')\n        assert actual == repr('Test Argument')\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/text.py","size":123,"sha1":"98ed26debb25efcf402f2ad8422f04d373905335","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"class Filenames:\n    unicode = 'smörbröd.py'\n    latin_1 = unicode.encode('latin-1')\n    utf_8 = unicode.encode('utf-8')\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/tests/textwrap.py","size":98,"sha1":"1aeaaeef01368314c8d611daeec4d7f8da50cdcc","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import textwrap\n\n\ndef DALS(s):\n    \"dedent and left-strip\"\n    return textwrap.dedent(s).lstrip()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/unicode_utils.py","size":3190,"sha1":"c2997c87f933de8931124f0afaf8143c59e3533a","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import sys\nimport unicodedata\nfrom configparser import RawConfigParser\n\nfrom .compat import py39\nfrom .warnings import SetuptoolsDeprecationWarning\n\n\n# HFS Plus uses decomposed UTF-8\ndef decompose(path):\n    if isinstance(path, str):\n        return unicodedata.normalize('NFD', path)\n    try:\n        path = path.decode('utf-8')\n        path = unicodedata.normalize('NFD', path)\n        path = path.encode('utf-8')\n    except UnicodeError:\n        pass  # Not UTF-8\n    return path\n\n\ndef filesys_decode(path):\n    \"\"\"\n    Ensure that the given path is decoded,\n    ``None`` when no expected encoding works\n    \"\"\"\n\n    if isinstance(path, str):\n        return path\n\n    fs_enc = sys.getfilesystemencoding() or 'utf-8'\n    candidates = fs_enc, 'utf-8'\n\n    for enc in candidates:\n        try:\n            return path.decode(enc)\n        except UnicodeDecodeError:\n            continue\n\n    return None\n\n\ndef try_encode(string, enc):\n    \"turn unicode encoding into a functional routine\"\n    try:\n        return string.encode(enc)\n    except UnicodeEncodeError:\n        return None\n\n\ndef _read_utf8_with_fallback(file: str, fallback_encoding=py39.LOCALE_ENCODING) -> str:\n    \"\"\"\n    First try to read the file with UTF-8, if there is an error fallback to a\n    different encoding (\"locale\" by default). Returns the content of the file.\n    Also useful when reading files that might have been produced by an older version of\n    setuptools.\n    \"\"\"\n    try:\n        with open(file, \"r\", encoding=\"utf-8\") as f:\n            return f.read()\n    except UnicodeDecodeError:  # pragma: no cover\n        _Utf8EncodingNeeded.emit(file=file, fallback_encoding=fallback_encoding)\n        with open(file, \"r\", encoding=fallback_encoding) as f:\n            return f.read()\n\n\ndef _cfg_read_utf8_with_fallback(\n    cfg: RawConfigParser, file: str, fallback_encoding=py39.LOCALE_ENCODING\n) -> None:\n    \"\"\"Same idea as :func:`_read_utf8_with_fallback`, but for the\n    :meth:`RawConfigParser.read` method.\n\n    This method may call ``cfg.clear()``.\n    \"\"\"\n    try:\n        cfg.read(file, encoding=\"utf-8\")\n    except UnicodeDecodeError:  # pragma: no cover\n        _Utf8EncodingNeeded.emit(file=file, fallback_encoding=fallback_encoding)\n        cfg.clear()\n        cfg.read(file, encoding=fallback_encoding)\n\n\nclass _Utf8EncodingNeeded(SetuptoolsDeprecationWarning):\n    _SUMMARY = \"\"\"\n    `encoding=\"utf-8\"` fails with {file!r}, trying `encoding={fallback_encoding!r}`.\n    \"\"\"\n\n    _DETAILS = \"\"\"\n    Fallback behaviour for UTF-8 is considered **deprecated** and future versions of\n    `setuptools` may not implement it.\n\n    Please encode {file!r} with \"utf-8\" to ensure future builds will succeed.\n\n    If this file was produced by `setuptools` itself, cleaning up the cached files\n    and re-building/re-installing the package with a newer version of `setuptools`\n    (e.g. by updating `build-system.requires` in its `pyproject.toml`)\n    might solve the problem.\n    \"\"\"\n    # TODO: Add a deadline?\n    #       Will we be able to remove this?\n    #       The question comes to mind mainly because of sdists that have been produced\n    #       by old versions of setuptools and published to PyPI...\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/version.py","size":161,"sha1":"03c12e63bd70f530120700a5685be92f531cff57","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from ._importlib import metadata\n\ntry:\n    __version__ = metadata.version('setuptools') or '0.dev0+unknown'\nexcept Exception:\n    __version__ = '0.dev0+unknown'\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/warnings.py","size":3796,"sha1":"ba4266dc44cda3abea165f304459e9cf81b167af","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Provide basic warnings used by setuptools modules.\n\nUsing custom classes (other than ``UserWarning``) allow users to set\n``PYTHONWARNINGS`` filters to run tests and prepare for upcoming changes in\nsetuptools.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport warnings\nfrom datetime import date\nfrom inspect import cleandoc\nfrom textwrap import indent\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from typing_extensions import TypeAlias\n\n_DueDate: TypeAlias = tuple[int, int, int]  # time tuple\n_INDENT = 8 * \" \"\n_TEMPLATE = f\"\"\"{80 * '*'}\\n{{details}}\\n{80 * '*'}\"\"\"\n\n\nclass SetuptoolsWarning(UserWarning):\n    \"\"\"Base class in ``setuptools`` warning hierarchy.\"\"\"\n\n    @classmethod\n    def emit(\n        cls,\n        summary: str | None = None,\n        details: str | None = None,\n        due_date: _DueDate | None = None,\n        see_docs: str | None = None,\n        see_url: str | None = None,\n        stacklevel: int = 2,\n        **kwargs,\n    ) -> None:\n        \"\"\"Private: reserved for ``setuptools`` internal use only\"\"\"\n        # Default values:\n        summary_ = summary or getattr(cls, \"_SUMMARY\", None) or \"\"\n        details_ = details or getattr(cls, \"_DETAILS\", None) or \"\"\n        due_date = due_date or getattr(cls, \"_DUE_DATE\", None)\n        docs_ref = see_docs or getattr(cls, \"_SEE_DOCS\", None)\n        docs_url = docs_ref and f\"https://setuptools.pypa.io/en/latest/{docs_ref}\"\n        see_url = see_url or getattr(cls, \"_SEE_URL\", None)\n        due = date(*due_date) if due_date else None\n\n        text = cls._format(summary_, details_, due, see_url or docs_url, kwargs)\n        if due and due < date.today() and _should_enforce():\n            raise cls(text)\n        warnings.warn(text, cls, stacklevel=stacklevel + 1)\n\n    @classmethod\n    def _format(\n        cls,\n        summary: str,\n        details: str,\n        due_date: date | None = None,\n        see_url: str | None = None,\n        format_args: dict | None = None,\n    ) -> str:\n        \"\"\"Private: reserved for ``setuptools`` internal use only\"\"\"\n        today = date.today()\n        summary = cleandoc(summary).format_map(format_args or {})\n        possible_parts = [\n            cleandoc(details).format_map(format_args or {}),\n            (\n                f\"\\nBy {due_date:%Y-%b-%d}, you need to update your project and remove \"\n                \"deprecated calls\\nor your builds will no longer be supported.\"\n                if due_date and due_date > today\n                else None\n            ),\n            (\n                \"\\nThis deprecation is overdue, please update your project and remove \"\n                \"deprecated\\ncalls to avoid build errors in the future.\"\n                if due_date and due_date < today\n                else None\n            ),\n            (f\"\\nSee {see_url} for details.\" if see_url else None),\n        ]\n        parts = [x for x in possible_parts if x]\n        if parts:\n            body = indent(_TEMPLATE.format(details=\"\\n\".join(parts)), _INDENT)\n            return \"\\n\".join([summary, \"!!\\n\", body, \"\\n!!\"])\n        return summary\n\n\nclass InformationOnly(SetuptoolsWarning):\n    \"\"\"Currently there is no clear way of displaying messages to the users\n    that use the setuptools backend directly via ``pip``.\n    The only thing that might work is a warning, although it is not the\n    most appropriate tool for the job...\n\n    See pypa/packaging-problems#558.\n    \"\"\"\n\n\nclass SetuptoolsDeprecationWarning(SetuptoolsWarning):\n    \"\"\"\n    Base class for warning deprecations in ``setuptools``\n\n    This class is not derived from ``DeprecationWarning``, and as such is\n    visible by default.\n    \"\"\"\n\n\ndef _should_enforce():\n    enforce = os.getenv(\"SETUPTOOLS_ENFORCE_DEPRECATION\", \"false\").lower()\n    return enforce in (\"true\", \"on\", \"ok\", \"1\")\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/wheel.py","size":8624,"sha1":"7fa6c89febd40cb6d69cf4ea1740111f2804a998","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Wheels support.\"\"\"\n\nimport contextlib\nimport email\nimport functools\nimport itertools\nimport os\nimport posixpath\nimport re\nimport zipfile\n\nfrom packaging.tags import sys_tags\nfrom packaging.utils import canonicalize_name\nfrom packaging.version import Version as parse_version\n\nimport setuptools\nfrom setuptools.archive_util import _unpack_zipfile_obj\nfrom setuptools.command.egg_info import _egg_basename, write_requirements\n\nfrom .unicode_utils import _read_utf8_with_fallback\n\nfrom distutils.util import get_platform\n\nWHEEL_NAME = re.compile(\n    r\"\"\"^(?P<project_name>.+?)-(?P<version>\\d.*?)\n    ((-(?P<build>\\d.*?))?-(?P<py_version>.+?)-(?P<abi>.+?)-(?P<platform>.+?)\n    )\\.whl$\"\"\",\n    re.VERBOSE,\n).match\n\nNAMESPACE_PACKAGE_INIT = \"__import__('pkg_resources').declare_namespace(__name__)\\n\"\n\n\n@functools.cache\ndef _get_supported_tags():\n    # We calculate the supported tags only once, otherwise calling\n    # this method on thousands of wheels takes seconds instead of\n    # milliseconds.\n    return {(t.interpreter, t.abi, t.platform) for t in sys_tags()}\n\n\ndef unpack(src_dir, dst_dir) -> None:\n    \"\"\"Move everything under `src_dir` to `dst_dir`, and delete the former.\"\"\"\n    for dirpath, dirnames, filenames in os.walk(src_dir):\n        subdir = os.path.relpath(dirpath, src_dir)\n        for f in filenames:\n            src = os.path.join(dirpath, f)\n            dst = os.path.join(dst_dir, subdir, f)\n            os.renames(src, dst)\n        for n, d in reversed(list(enumerate(dirnames))):\n            src = os.path.join(dirpath, d)\n            dst = os.path.join(dst_dir, subdir, d)\n            if not os.path.exists(dst):\n                # Directory does not exist in destination,\n                # rename it and prune it from os.walk list.\n                os.renames(src, dst)\n                del dirnames[n]\n    # Cleanup.\n    for dirpath, dirnames, filenames in os.walk(src_dir, topdown=True):\n        assert not filenames\n        os.rmdir(dirpath)\n\n\n@contextlib.contextmanager\ndef disable_info_traces():\n    \"\"\"\n    Temporarily disable info traces.\n    \"\"\"\n    from distutils import log\n\n    saved = log.set_threshold(log.WARN)\n    try:\n        yield\n    finally:\n        log.set_threshold(saved)\n\n\nclass Wheel:\n    def __init__(self, filename) -> None:\n        match = WHEEL_NAME(os.path.basename(filename))\n        if match is None:\n            raise ValueError(f'invalid wheel name: {filename!r}')\n        self.filename = filename\n        for k, v in match.groupdict().items():\n            setattr(self, k, v)\n\n    def tags(self):\n        \"\"\"List tags (py_version, abi, platform) supported by this wheel.\"\"\"\n        return itertools.product(\n            self.py_version.split('.'),\n            self.abi.split('.'),\n            self.platform.split('.'),\n        )\n\n    def is_compatible(self):\n        \"\"\"Is the wheel compatible with the current platform?\"\"\"\n        return next((True for t in self.tags() if t in _get_supported_tags()), False)\n\n    def egg_name(self):\n        return (\n            _egg_basename(\n                self.project_name,\n                self.version,\n                platform=(None if self.platform == 'any' else get_platform()),\n            )\n            + \".egg\"\n        )\n\n    def get_dist_info(self, zf):\n        # find the correct name of the .dist-info dir in the wheel file\n        for member in zf.namelist():\n            dirname = posixpath.dirname(member)\n            if dirname.endswith('.dist-info') and canonicalize_name(dirname).startswith(\n                canonicalize_name(self.project_name)\n            ):\n                return dirname\n        raise ValueError(\"unsupported wheel format. .dist-info not found\")\n\n    def install_as_egg(self, destination_eggdir) -> None:\n        \"\"\"Install wheel as an egg directory.\"\"\"\n        with zipfile.ZipFile(self.filename) as zf:\n            self._install_as_egg(destination_eggdir, zf)\n\n    def _install_as_egg(self, destination_eggdir, zf):\n        dist_basename = f'{self.project_name}-{self.version}'\n        dist_info = self.get_dist_info(zf)\n        dist_data = f'{dist_basename}.data'\n        egg_info = os.path.join(destination_eggdir, 'EGG-INFO')\n\n        self._convert_metadata(zf, destination_eggdir, dist_info, egg_info)\n        self._move_data_entries(destination_eggdir, dist_data)\n        self._fix_namespace_packages(egg_info, destination_eggdir)\n\n    @staticmethod\n    def _convert_metadata(zf, destination_eggdir, dist_info, egg_info):\n        import pkg_resources\n\n        def get_metadata(name):\n            with zf.open(posixpath.join(dist_info, name)) as fp:\n                value = fp.read().decode('utf-8')\n                return email.parser.Parser().parsestr(value)\n\n        wheel_metadata = get_metadata('WHEEL')\n        # Check wheel format version is supported.\n        wheel_version = parse_version(wheel_metadata.get('Wheel-Version'))\n        wheel_v1 = parse_version('1.0') <= wheel_version < parse_version('2.0dev0')\n        if not wheel_v1:\n            raise ValueError(f'unsupported wheel format version: {wheel_version}')\n        # Extract to target directory.\n        _unpack_zipfile_obj(zf, destination_eggdir)\n        # Convert metadata.\n        dist_info = os.path.join(destination_eggdir, dist_info)\n        dist = pkg_resources.Distribution.from_location(\n            destination_eggdir,\n            dist_info,\n            metadata=pkg_resources.PathMetadata(destination_eggdir, dist_info),\n        )\n\n        # Note: Evaluate and strip markers now,\n        # as it's difficult to convert back from the syntax:\n        # foobar; \"linux\" in sys_platform and extra == 'test'\n        def raw_req(req):\n            req.marker = None\n            return str(req)\n\n        install_requires = list(map(raw_req, dist.requires()))\n        extras_require = {\n            extra: [\n                req\n                for req in map(raw_req, dist.requires((extra,)))\n                if req not in install_requires\n            ]\n            for extra in dist.extras\n        }\n        os.rename(dist_info, egg_info)\n        os.rename(\n            os.path.join(egg_info, 'METADATA'),\n            os.path.join(egg_info, 'PKG-INFO'),\n        )\n        setup_dist = setuptools.Distribution(\n            attrs=dict(\n                install_requires=install_requires,\n                extras_require=extras_require,\n            ),\n        )\n        with disable_info_traces():\n            write_requirements(\n                setup_dist.get_command_obj('egg_info'),\n                None,\n                os.path.join(egg_info, 'requires.txt'),\n            )\n\n    @staticmethod\n    def _move_data_entries(destination_eggdir, dist_data):\n        \"\"\"Move data entries to their correct location.\"\"\"\n        dist_data = os.path.join(destination_eggdir, dist_data)\n        dist_data_scripts = os.path.join(dist_data, 'scripts')\n        if os.path.exists(dist_data_scripts):\n            egg_info_scripts = os.path.join(destination_eggdir, 'EGG-INFO', 'scripts')\n            os.mkdir(egg_info_scripts)\n            for entry in os.listdir(dist_data_scripts):\n                # Remove bytecode, as it's not properly handled\n                # during easy_install scripts install phase.\n                if entry.endswith('.pyc'):\n                    os.unlink(os.path.join(dist_data_scripts, entry))\n                else:\n                    os.rename(\n                        os.path.join(dist_data_scripts, entry),\n                        os.path.join(egg_info_scripts, entry),\n                    )\n            os.rmdir(dist_data_scripts)\n        for subdir in filter(\n            os.path.exists,\n            (\n                os.path.join(dist_data, d)\n                for d in ('data', 'headers', 'purelib', 'platlib')\n            ),\n        ):\n            unpack(subdir, destination_eggdir)\n        if os.path.exists(dist_data):\n            os.rmdir(dist_data)\n\n    @staticmethod\n    def _fix_namespace_packages(egg_info, destination_eggdir):\n        namespace_packages = os.path.join(egg_info, 'namespace_packages.txt')\n        if os.path.exists(namespace_packages):\n            namespace_packages = _read_utf8_with_fallback(namespace_packages).split()\n\n            for mod in namespace_packages:\n                mod_dir = os.path.join(destination_eggdir, *mod.split('.'))\n                mod_init = os.path.join(mod_dir, '__init__.py')\n                if not os.path.exists(mod_dir):\n                    os.mkdir(mod_dir)\n                if not os.path.exists(mod_init):\n                    with open(mod_init, 'w', encoding=\"utf-8\") as fp:\n                        fp.write(NAMESPACE_PACKAGE_INIT)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/setuptools-75.8.0-py3-none-any/setuptools/windows_support.py","size":726,"sha1":"363fc4dc1669cc49b2fbea5436b7897470f10bcc","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import platform\n\n\ndef windows_only(func):\n    if platform.system() != 'Windows':\n        return lambda *args, **kwargs: None\n    return func\n\n\n@windows_only\ndef hide_file(path: str) -> None:\n    \"\"\"\n    Set the hidden attribute on a file or directory.\n\n    From https://stackoverflow.com/questions/19622133/\n\n    `path` must be text.\n    \"\"\"\n    import ctypes\n    import ctypes.wintypes\n\n    SetFileAttributes = ctypes.windll.kernel32.SetFileAttributesW\n    SetFileAttributes.argtypes = ctypes.wintypes.LPWSTR, ctypes.wintypes.DWORD\n    SetFileAttributes.restype = ctypes.wintypes.BOOL\n\n    FILE_ATTRIBUTE_HIDDEN = 0x02\n\n    ret = SetFileAttributes(path, FILE_ATTRIBUTE_HIDDEN)\n    if not ret:\n        raise ctypes.WinError()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/__init__.py","size":59,"sha1":"3f287c0c0c61add9b3d9af46827070b136477da7","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\n__version__ = \"0.45.1\"\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/__main__.py","size":455,"sha1":"ffe3e2c7d64812ecfb2becdb41cec1dbb2359618","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nWheel command line tool (enable python -m wheel syntax)\n\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\n\n\ndef main():  # needed for console script\n    if __package__ == \"\":\n        # To be able to run 'python wheel-0.9.whl/wheel':\n        import os.path\n\n        path = os.path.dirname(os.path.dirname(__file__))\n        sys.path[0:0] = [path]\n    import wheel.cli\n\n    sys.exit(wheel.cli.main())\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/_bdist_wheel.py","size":21694,"sha1":"10002df34fb0664f7a1616646b109881e5ca2863","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nCreate a wheel (.whl) distribution.\n\nA wheel is a built archive format.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport re\nimport shutil\nimport stat\nimport struct\nimport sys\nimport sysconfig\nimport warnings\nfrom email.generator import BytesGenerator, Generator\nfrom email.policy import EmailPolicy\nfrom glob import iglob\nfrom shutil import rmtree\nfrom typing import TYPE_CHECKING, Callable, Iterable, Literal, Sequence, cast\nfrom zipfile import ZIP_DEFLATED, ZIP_STORED\n\nimport setuptools\nfrom setuptools import Command\n\nfrom . import __version__ as wheel_version\nfrom .metadata import pkginfo_to_metadata\nfrom .util import log\nfrom .vendored.packaging import tags\nfrom .vendored.packaging import version as _packaging_version\nfrom .wheelfile import WheelFile\n\nif TYPE_CHECKING:\n    import types\n\n# ensure Python logging is configured\ntry:\n    __import__(\"setuptools.logging\")\nexcept ImportError:\n    # setuptools < ??\n    from . import _setuptools_logging\n\n    _setuptools_logging.configure()\n\n\ndef safe_name(name: str) -> str:\n    \"\"\"Convert an arbitrary string to a standard distribution name\n    Any runs of non-alphanumeric/. characters are replaced with a single '-'.\n    \"\"\"\n    return re.sub(\"[^A-Za-z0-9.]+\", \"-\", name)\n\n\ndef safe_version(version: str) -> str:\n    \"\"\"\n    Convert an arbitrary string to a standard version string\n    \"\"\"\n    try:\n        # normalize the version\n        return str(_packaging_version.Version(version))\n    except _packaging_version.InvalidVersion:\n        version = version.replace(\" \", \".\")\n        return re.sub(\"[^A-Za-z0-9.]+\", \"-\", version)\n\n\nsetuptools_major_version = int(setuptools.__version__.split(\".\")[0])\n\nPY_LIMITED_API_PATTERN = r\"cp3\\d\"\n\n\ndef _is_32bit_interpreter() -> bool:\n    return struct.calcsize(\"P\") == 4\n\n\ndef python_tag() -> str:\n    return f\"py{sys.version_info[0]}\"\n\n\ndef get_platform(archive_root: str | None) -> str:\n    \"\"\"Return our platform name 'win32', 'linux_x86_64'\"\"\"\n    result = sysconfig.get_platform()\n    if result.startswith(\"macosx\") and archive_root is not None:\n        from .macosx_libfile import calculate_macosx_platform_tag\n\n        result = calculate_macosx_platform_tag(archive_root, result)\n    elif _is_32bit_interpreter():\n        if result == \"linux-x86_64\":\n            # pip pull request #3497\n            result = \"linux-i686\"\n        elif result == \"linux-aarch64\":\n            # packaging pull request #234\n            # TODO armv8l, packaging pull request #690 => this did not land\n            # in pip/packaging yet\n            result = \"linux-armv7l\"\n\n    return result.replace(\"-\", \"_\")\n\n\ndef get_flag(\n    var: str, fallback: bool, expected: bool = True, warn: bool = True\n) -> bool:\n    \"\"\"Use a fallback value for determining SOABI flags if the needed config\n    var is unset or unavailable.\"\"\"\n    val = sysconfig.get_config_var(var)\n    if val is None:\n        if warn:\n            warnings.warn(\n                f\"Config variable '{var}' is unset, Python ABI tag may be incorrect\",\n                RuntimeWarning,\n                stacklevel=2,\n            )\n        return fallback\n    return val == expected\n\n\ndef get_abi_tag() -> str | None:\n    \"\"\"Return the ABI tag based on SOABI (if available) or emulate SOABI (PyPy2).\"\"\"\n    soabi: str = sysconfig.get_config_var(\"SOABI\")\n    impl = tags.interpreter_name()\n    if not soabi and impl in (\"cp\", \"pp\") and hasattr(sys, \"maxunicode\"):\n        d = \"\"\n        m = \"\"\n        u = \"\"\n        if get_flag(\"Py_DEBUG\", hasattr(sys, \"gettotalrefcount\"), warn=(impl == \"cp\")):\n            d = \"d\"\n\n        if get_flag(\n            \"WITH_PYMALLOC\",\n            impl == \"cp\",\n            warn=(impl == \"cp\" and sys.version_info < (3, 8)),\n        ) and sys.version_info < (3, 8):\n            m = \"m\"\n\n        abi = f\"{impl}{tags.interpreter_version()}{d}{m}{u}\"\n    elif soabi and impl == \"cp\" and soabi.startswith(\"cpython\"):\n        # non-Windows\n        abi = \"cp\" + soabi.split(\"-\")[1]\n    elif soabi and impl == \"cp\" and soabi.startswith(\"cp\"):\n        # Windows\n        abi = soabi.split(\"-\")[0]\n    elif soabi and impl == \"pp\":\n        # we want something like pypy36-pp73\n        abi = \"-\".join(soabi.split(\"-\")[:2])\n        abi = abi.replace(\".\", \"_\").replace(\"-\", \"_\")\n    elif soabi and impl == \"graalpy\":\n        abi = \"-\".join(soabi.split(\"-\")[:3])\n        abi = abi.replace(\".\", \"_\").replace(\"-\", \"_\")\n    elif soabi:\n        abi = soabi.replace(\".\", \"_\").replace(\"-\", \"_\")\n    else:\n        abi = None\n\n    return abi\n\n\ndef safer_name(name: str) -> str:\n    return safe_name(name).replace(\"-\", \"_\")\n\n\ndef safer_version(version: str) -> str:\n    return safe_version(version).replace(\"-\", \"_\")\n\n\ndef remove_readonly(\n    func: Callable[..., object],\n    path: str,\n    excinfo: tuple[type[Exception], Exception, types.TracebackType],\n) -> None:\n    remove_readonly_exc(func, path, excinfo[1])\n\n\ndef remove_readonly_exc(func: Callable[..., object], path: str, exc: Exception) -> None:\n    os.chmod(path, stat.S_IWRITE)\n    func(path)\n\n\nclass bdist_wheel(Command):\n    description = \"create a wheel distribution\"\n\n    supported_compressions = {\n        \"stored\": ZIP_STORED,\n        \"deflated\": ZIP_DEFLATED,\n    }\n\n    user_options = [\n        (\"bdist-dir=\", \"b\", \"temporary directory for creating the distribution\"),\n        (\n            \"plat-name=\",\n            \"p\",\n            \"platform name to embed in generated filenames \"\n            f\"(default: {get_platform(None)})\",\n        ),\n        (\n            \"keep-temp\",\n            \"k\",\n            \"keep the pseudo-installation tree around after \"\n            \"creating the distribution archive\",\n        ),\n        (\"dist-dir=\", \"d\", \"directory to put final built distributions in\"),\n        (\"skip-build\", None, \"skip rebuilding everything (for testing/debugging)\"),\n        (\n            \"relative\",\n            None,\n            \"build the archive using relative paths (default: false)\",\n        ),\n        (\n            \"owner=\",\n            \"u\",\n            \"Owner name used when creating a tar file [default: current user]\",\n        ),\n        (\n            \"group=\",\n            \"g\",\n            \"Group name used when creating a tar file [default: current group]\",\n        ),\n        (\"universal\", None, \"make a universal wheel (default: false)\"),\n        (\n            \"compression=\",\n            None,\n            \"zipfile compression (one of: {}) (default: 'deflated')\".format(\n                \", \".join(supported_compressions)\n            ),\n        ),\n        (\n            \"python-tag=\",\n            None,\n            f\"Python implementation compatibility tag (default: '{python_tag()}')\",\n        ),\n        (\n            \"build-number=\",\n            None,\n            \"Build number for this particular version. \"\n            \"As specified in PEP-0427, this must start with a digit. \"\n            \"[default: None]\",\n        ),\n        (\n            \"py-limited-api=\",\n            None,\n            \"Python tag (cp32|cp33|cpNN) for abi3 wheel tag (default: false)\",\n        ),\n    ]\n\n    boolean_options = [\"keep-temp\", \"skip-build\", \"relative\", \"universal\"]\n\n    def initialize_options(self):\n        self.bdist_dir: str = None\n        self.data_dir = None\n        self.plat_name: str | None = None\n        self.plat_tag = None\n        self.format = \"zip\"\n        self.keep_temp = False\n        self.dist_dir: str | None = None\n        self.egginfo_dir = None\n        self.root_is_pure: bool | None = None\n        self.skip_build = None\n        self.relative = False\n        self.owner = None\n        self.group = None\n        self.universal: bool = False\n        self.compression: str | int = \"deflated\"\n        self.python_tag: str = python_tag()\n        self.build_number: str | None = None\n        self.py_limited_api: str | Literal[False] = False\n        self.plat_name_supplied = False\n\n    def finalize_options(self):\n        if self.bdist_dir is None:\n            bdist_base = self.get_finalized_command(\"bdist\").bdist_base\n            self.bdist_dir = os.path.join(bdist_base, \"wheel\")\n\n        egg_info = self.distribution.get_command_obj(\"egg_info\")\n        egg_info.ensure_finalized()  # needed for correct `wheel_dist_name`\n\n        self.data_dir = self.wheel_dist_name + \".data\"\n        self.plat_name_supplied = self.plat_name is not None\n\n        try:\n            self.compression = self.supported_compressions[self.compression]\n        except KeyError:\n            raise ValueError(f\"Unsupported compression: {self.compression}\") from None\n\n        need_options = (\"dist_dir\", \"plat_name\", \"skip_build\")\n\n        self.set_undefined_options(\"bdist\", *zip(need_options, need_options))\n\n        self.root_is_pure = not (\n            self.distribution.has_ext_modules() or self.distribution.has_c_libraries()\n        )\n\n        if self.py_limited_api and not re.match(\n            PY_LIMITED_API_PATTERN, self.py_limited_api\n        ):\n            raise ValueError(f\"py-limited-api must match '{PY_LIMITED_API_PATTERN}'\")\n\n        # Support legacy [wheel] section for setting universal\n        wheel = self.distribution.get_option_dict(\"wheel\")\n        if \"universal\" in wheel:\n            # please don't define this in your global configs\n            log.warning(\n                \"The [wheel] section is deprecated. Use [bdist_wheel] instead.\",\n            )\n            val = wheel[\"universal\"][1].strip()\n            if val.lower() in (\"1\", \"true\", \"yes\"):\n                self.universal = True\n\n        if self.build_number is not None and not self.build_number[:1].isdigit():\n            raise ValueError(\"Build tag (build-number) must start with a digit.\")\n\n    @property\n    def wheel_dist_name(self):\n        \"\"\"Return distribution full name with - replaced with _\"\"\"\n        components = (\n            safer_name(self.distribution.get_name()),\n            safer_version(self.distribution.get_version()),\n        )\n        if self.build_number:\n            components += (self.build_number,)\n        return \"-\".join(components)\n\n    def get_tag(self) -> tuple[str, str, str]:\n        # bdist sets self.plat_name if unset, we should only use it for purepy\n        # wheels if the user supplied it.\n        if self.plat_name_supplied:\n            plat_name = cast(str, self.plat_name)\n        elif self.root_is_pure:\n            plat_name = \"any\"\n        else:\n            # macosx contains system version in platform name so need special handle\n            if self.plat_name and not self.plat_name.startswith(\"macosx\"):\n                plat_name = self.plat_name\n            else:\n                # on macosx always limit the platform name to comply with any\n                # c-extension modules in bdist_dir, since the user can specify\n                # a higher MACOSX_DEPLOYMENT_TARGET via tools like CMake\n\n                # on other platforms, and on macosx if there are no c-extension\n                # modules, use the default platform name.\n                plat_name = get_platform(self.bdist_dir)\n\n            if _is_32bit_interpreter():\n                if plat_name in (\"linux-x86_64\", \"linux_x86_64\"):\n                    plat_name = \"linux_i686\"\n                if plat_name in (\"linux-aarch64\", \"linux_aarch64\"):\n                    # TODO armv8l, packaging pull request #690 => this did not land\n                    # in pip/packaging yet\n                    plat_name = \"linux_armv7l\"\n\n        plat_name = (\n            plat_name.lower().replace(\"-\", \"_\").replace(\".\", \"_\").replace(\" \", \"_\")\n        )\n\n        if self.root_is_pure:\n            if self.universal:\n                impl = \"py2.py3\"\n            else:\n                impl = self.python_tag\n            tag = (impl, \"none\", plat_name)\n        else:\n            impl_name = tags.interpreter_name()\n            impl_ver = tags.interpreter_version()\n            impl = impl_name + impl_ver\n            # We don't work on CPython 3.1, 3.0.\n            if self.py_limited_api and (impl_name + impl_ver).startswith(\"cp3\"):\n                impl = self.py_limited_api\n                abi_tag = \"abi3\"\n            else:\n                abi_tag = str(get_abi_tag()).lower()\n            tag = (impl, abi_tag, plat_name)\n            # issue gh-374: allow overriding plat_name\n            supported_tags = [\n                (t.interpreter, t.abi, plat_name) for t in tags.sys_tags()\n            ]\n            assert (\n                tag in supported_tags\n            ), f\"would build wheel with unsupported tag {tag}\"\n        return tag\n\n    def run(self):\n        build_scripts = self.reinitialize_command(\"build_scripts\")\n        build_scripts.executable = \"python\"\n        build_scripts.force = True\n\n        build_ext = self.reinitialize_command(\"build_ext\")\n        build_ext.inplace = False\n\n        if not self.skip_build:\n            self.run_command(\"build\")\n\n        install = self.reinitialize_command(\"install\", reinit_subcommands=True)\n        install.root = self.bdist_dir\n        install.compile = False\n        install.skip_build = self.skip_build\n        install.warn_dir = False\n\n        # A wheel without setuptools scripts is more cross-platform.\n        # Use the (undocumented) `no_ep` option to setuptools'\n        # install_scripts command to avoid creating entry point scripts.\n        install_scripts = self.reinitialize_command(\"install_scripts\")\n        install_scripts.no_ep = True\n\n        # Use a custom scheme for the archive, because we have to decide\n        # at installation time which scheme to use.\n        for key in (\"headers\", \"scripts\", \"data\", \"purelib\", \"platlib\"):\n            setattr(install, \"install_\" + key, os.path.join(self.data_dir, key))\n\n        basedir_observed = \"\"\n\n        if os.name == \"nt\":\n            # win32 barfs if any of these are ''; could be '.'?\n            # (distutils.command.install:change_roots bug)\n            basedir_observed = os.path.normpath(os.path.join(self.data_dir, \"..\"))\n            self.install_libbase = self.install_lib = basedir_observed\n\n        setattr(\n            install,\n            \"install_purelib\" if self.root_is_pure else \"install_platlib\",\n            basedir_observed,\n        )\n\n        log.info(f\"installing to {self.bdist_dir}\")\n\n        self.run_command(\"install\")\n\n        impl_tag, abi_tag, plat_tag = self.get_tag()\n        archive_basename = f\"{self.wheel_dist_name}-{impl_tag}-{abi_tag}-{plat_tag}\"\n        if not self.relative:\n            archive_root = self.bdist_dir\n        else:\n            archive_root = os.path.join(\n                self.bdist_dir, self._ensure_relative(install.install_base)\n            )\n\n        self.set_undefined_options(\"install_egg_info\", (\"target\", \"egginfo_dir\"))\n        distinfo_dirname = (\n            f\"{safer_name(self.distribution.get_name())}-\"\n            f\"{safer_version(self.distribution.get_version())}.dist-info\"\n        )\n        distinfo_dir = os.path.join(self.bdist_dir, distinfo_dirname)\n        self.egg2dist(self.egginfo_dir, distinfo_dir)\n\n        self.write_wheelfile(distinfo_dir)\n\n        # Make the archive\n        if not os.path.exists(self.dist_dir):\n            os.makedirs(self.dist_dir)\n\n        wheel_path = os.path.join(self.dist_dir, archive_basename + \".whl\")\n        with WheelFile(wheel_path, \"w\", self.compression) as wf:\n            wf.write_files(archive_root)\n\n        # Add to 'Distribution.dist_files' so that the \"upload\" command works\n        getattr(self.distribution, \"dist_files\", []).append(\n            (\n                \"bdist_wheel\",\n                \"{}.{}\".format(*sys.version_info[:2]),  # like 3.7\n                wheel_path,\n            )\n        )\n\n        if not self.keep_temp:\n            log.info(f\"removing {self.bdist_dir}\")\n            if not self.dry_run:\n                if sys.version_info < (3, 12):\n                    rmtree(self.bdist_dir, onerror=remove_readonly)\n                else:\n                    rmtree(self.bdist_dir, onexc=remove_readonly_exc)\n\n    def write_wheelfile(\n        self, wheelfile_base: str, generator: str = f\"bdist_wheel ({wheel_version})\"\n    ):\n        from email.message import Message\n\n        msg = Message()\n        msg[\"Wheel-Version\"] = \"1.0\"  # of the spec\n        msg[\"Generator\"] = generator\n        msg[\"Root-Is-Purelib\"] = str(self.root_is_pure).lower()\n        if self.build_number is not None:\n            msg[\"Build\"] = self.build_number\n\n        # Doesn't work for bdist_wininst\n        impl_tag, abi_tag, plat_tag = self.get_tag()\n        for impl in impl_tag.split(\".\"):\n            for abi in abi_tag.split(\".\"):\n                for plat in plat_tag.split(\".\"):\n                    msg[\"Tag\"] = \"-\".join((impl, abi, plat))\n\n        wheelfile_path = os.path.join(wheelfile_base, \"WHEEL\")\n        log.info(f\"creating {wheelfile_path}\")\n        with open(wheelfile_path, \"wb\") as f:\n            BytesGenerator(f, maxheaderlen=0).flatten(msg)\n\n    def _ensure_relative(self, path: str) -> str:\n        # copied from dir_util, deleted\n        drive, path = os.path.splitdrive(path)\n        if path[0:1] == os.sep:\n            path = drive + path[1:]\n        return path\n\n    @property\n    def license_paths(self) -> Iterable[str]:\n        if setuptools_major_version >= 57:\n            # Setuptools has resolved any patterns to actual file names\n            return self.distribution.metadata.license_files or ()\n\n        files: set[str] = set()\n        metadata = self.distribution.get_option_dict(\"metadata\")\n        if setuptools_major_version >= 42:\n            # Setuptools recognizes the license_files option but does not do globbing\n            patterns = cast(Sequence[str], self.distribution.metadata.license_files)\n        else:\n            # Prior to those, wheel is entirely responsible for handling license files\n            if \"license_files\" in metadata:\n                patterns = metadata[\"license_files\"][1].split()\n            else:\n                patterns = ()\n\n        if \"license_file\" in metadata:\n            warnings.warn(\n                'The \"license_file\" option is deprecated. Use \"license_files\" instead.',\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            files.add(metadata[\"license_file\"][1])\n\n        if not files and not patterns and not isinstance(patterns, list):\n            patterns = (\"LICEN[CS]E*\", \"COPYING*\", \"NOTICE*\", \"AUTHORS*\")\n\n        for pattern in patterns:\n            for path in iglob(pattern):\n                if path.endswith(\"~\"):\n                    log.debug(\n                        f'ignoring license file \"{path}\" as it looks like a backup'\n                    )\n                    continue\n\n                if path not in files and os.path.isfile(path):\n                    log.info(\n                        f'adding license file \"{path}\" (matched pattern \"{pattern}\")'\n                    )\n                    files.add(path)\n\n        return files\n\n    def egg2dist(self, egginfo_path: str, distinfo_path: str):\n        \"\"\"Convert an .egg-info directory into a .dist-info directory\"\"\"\n\n        def adios(p: str) -> None:\n            \"\"\"Appropriately delete directory, file or link.\"\"\"\n            if os.path.exists(p) and not os.path.islink(p) and os.path.isdir(p):\n                shutil.rmtree(p)\n            elif os.path.exists(p):\n                os.unlink(p)\n\n        adios(distinfo_path)\n\n        if not os.path.exists(egginfo_path):\n            # There is no egg-info. This is probably because the egg-info\n            # file/directory is not named matching the distribution name used\n            # to name the archive file. Check for this case and report\n            # accordingly.\n            import glob\n\n            pat = os.path.join(os.path.dirname(egginfo_path), \"*.egg-info\")\n            possible = glob.glob(pat)\n            err = f\"Egg metadata expected at {egginfo_path} but not found\"\n            if possible:\n                alt = os.path.basename(possible[0])\n                err += f\" ({alt} found - possible misnamed archive file?)\"\n\n            raise ValueError(err)\n\n        if os.path.isfile(egginfo_path):\n            # .egg-info is a single file\n            pkg_info = pkginfo_to_metadata(egginfo_path, egginfo_path)\n            os.mkdir(distinfo_path)\n        else:\n            # .egg-info is a directory\n            pkginfo_path = os.path.join(egginfo_path, \"PKG-INFO\")\n            pkg_info = pkginfo_to_metadata(egginfo_path, pkginfo_path)\n\n            # ignore common egg metadata that is useless to wheel\n            shutil.copytree(\n                egginfo_path,\n                distinfo_path,\n                ignore=lambda x, y: {\n                    \"PKG-INFO\",\n                    \"requires.txt\",\n                    \"SOURCES.txt\",\n                    \"not-zip-safe\",\n                },\n            )\n\n            # delete dependency_links if it is only whitespace\n            dependency_links_path = os.path.join(distinfo_path, \"dependency_links.txt\")\n            with open(dependency_links_path, encoding=\"utf-8\") as dependency_links_file:\n                dependency_links = dependency_links_file.read().strip()\n            if not dependency_links:\n                adios(dependency_links_path)\n\n        pkg_info_path = os.path.join(distinfo_path, \"METADATA\")\n        serialization_policy = EmailPolicy(\n            utf8=True,\n            mangle_from_=False,\n            max_line_length=0,\n        )\n        with open(pkg_info_path, \"w\", encoding=\"utf-8\") as out:\n            Generator(out, policy=serialization_policy).flatten(pkg_info)\n\n        for license_path in self.license_paths:\n            filename = os.path.basename(license_path)\n            shutil.copy(license_path, os.path.join(distinfo_path, filename))\n\n        adios(egginfo_path)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/_setuptools_logging.py","size":781,"sha1":"7dc11a747a2baea5b8ff2b54249bc174c7d6ed16","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# copied from setuptools.logging, omitting monkeypatching\nfrom __future__ import annotations\n\nimport logging\nimport sys\n\n\ndef _not_warning(record: logging.LogRecord) -> bool:\n    return record.levelno < logging.WARNING\n\n\ndef configure() -> None:\n    \"\"\"\n    Configure logging to emit warning and above to stderr\n    and everything else to stdout. This behavior is provided\n    for compatibility with distutils.log but may change in\n    the future.\n    \"\"\"\n    err_handler = logging.StreamHandler()\n    err_handler.setLevel(logging.WARNING)\n    out_handler = logging.StreamHandler(sys.stdout)\n    out_handler.addFilter(_not_warning)\n    handlers = err_handler, out_handler\n    logging.basicConfig(\n        format=\"{message}\", style=\"{\", handlers=handlers, level=logging.DEBUG\n    )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/bdist_wheel.py","size":1107,"sha1":"d8d66c8b1a3f700bd6faadf664045d2683410946","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from typing import TYPE_CHECKING\nfrom warnings import warn\n\nwarn(\n    \"The 'wheel' package is no longer the canonical location of the 'bdist_wheel' \"\n    \"command, and will be removed in a future release. Please update to setuptools \"\n    \"v70.1 or later which contains an integrated version of this command.\",\n    DeprecationWarning,\n    stacklevel=1,\n)\n\nif TYPE_CHECKING:\n    from ._bdist_wheel import bdist_wheel as bdist_wheel\nelse:\n    try:\n        # Better integration/compatibility with setuptools:\n        # in the case new fixes or PEPs are implemented in setuptools\n        # there is no need to backport them to the deprecated code base.\n        # This is useful in the case of old packages in the ecosystem\n        # that are still used but have low maintenance.\n        from setuptools.command.bdist_wheel import bdist_wheel\n    except ImportError:\n        # Only used in the case of old setuptools versions.\n        # If the user wants to get the latest fixes/PEPs,\n        # they are encouraged to address the deprecation warning.\n        from ._bdist_wheel import bdist_wheel as bdist_wheel\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/cli/__init__.py","size":4402,"sha1":"f31622c90b9e463a312c9addbcd9ca0baa266c2e","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nWheel command-line utility.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport argparse\nimport os\nimport sys\nfrom argparse import ArgumentTypeError\n\n\nclass WheelError(Exception):\n    pass\n\n\ndef unpack_f(args: argparse.Namespace) -> None:\n    from .unpack import unpack\n\n    unpack(args.wheelfile, args.dest)\n\n\ndef pack_f(args: argparse.Namespace) -> None:\n    from .pack import pack\n\n    pack(args.directory, args.dest_dir, args.build_number)\n\n\ndef convert_f(args: argparse.Namespace) -> None:\n    from .convert import convert\n\n    convert(args.files, args.dest_dir, args.verbose)\n\n\ndef tags_f(args: argparse.Namespace) -> None:\n    from .tags import tags\n\n    names = (\n        tags(\n            wheel,\n            args.python_tag,\n            args.abi_tag,\n            args.platform_tag,\n            args.build,\n            args.remove,\n        )\n        for wheel in args.wheel\n    )\n\n    for name in names:\n        print(name)\n\n\ndef version_f(args: argparse.Namespace) -> None:\n    from .. import __version__\n\n    print(f\"wheel {__version__}\")\n\n\ndef parse_build_tag(build_tag: str) -> str:\n    if build_tag and not build_tag[0].isdigit():\n        raise ArgumentTypeError(\"build tag must begin with a digit\")\n    elif \"-\" in build_tag:\n        raise ArgumentTypeError(\"invalid character ('-') in build tag\")\n\n    return build_tag\n\n\nTAGS_HELP = \"\"\"\\\nMake a new wheel with given tags. Any tags unspecified will remain the same.\nStarting the tags with a \"+\" will append to the existing tags. Starting with a\n\"-\" will remove a tag (use --option=-TAG syntax). Multiple tags can be\nseparated by \".\". The original file will remain unless --remove is given.  The\noutput filename(s) will be displayed on stdout for further processing.\n\"\"\"\n\n\ndef parser():\n    p = argparse.ArgumentParser()\n    s = p.add_subparsers(help=\"commands\")\n\n    unpack_parser = s.add_parser(\"unpack\", help=\"Unpack wheel\")\n    unpack_parser.add_argument(\n        \"--dest\", \"-d\", help=\"Destination directory\", default=\".\"\n    )\n    unpack_parser.add_argument(\"wheelfile\", help=\"Wheel file\")\n    unpack_parser.set_defaults(func=unpack_f)\n\n    repack_parser = s.add_parser(\"pack\", help=\"Repack wheel\")\n    repack_parser.add_argument(\"directory\", help=\"Root directory of the unpacked wheel\")\n    repack_parser.add_argument(\n        \"--dest-dir\",\n        \"-d\",\n        default=os.path.curdir,\n        help=\"Directory to store the wheel (default %(default)s)\",\n    )\n    repack_parser.add_argument(\n        \"--build-number\", help=\"Build tag to use in the wheel name\"\n    )\n    repack_parser.set_defaults(func=pack_f)\n\n    convert_parser = s.add_parser(\"convert\", help=\"Convert egg or wininst to wheel\")\n    convert_parser.add_argument(\"files\", nargs=\"*\", help=\"Files to convert\")\n    convert_parser.add_argument(\n        \"--dest-dir\",\n        \"-d\",\n        default=os.path.curdir,\n        help=\"Directory to store wheels (default %(default)s)\",\n    )\n    convert_parser.add_argument(\"--verbose\", \"-v\", action=\"store_true\")\n    convert_parser.set_defaults(func=convert_f)\n\n    tags_parser = s.add_parser(\n        \"tags\", help=\"Add or replace the tags on a wheel\", description=TAGS_HELP\n    )\n    tags_parser.add_argument(\"wheel\", nargs=\"*\", help=\"Existing wheel(s) to retag\")\n    tags_parser.add_argument(\n        \"--remove\",\n        action=\"store_true\",\n        help=\"Remove the original files, keeping only the renamed ones\",\n    )\n    tags_parser.add_argument(\n        \"--python-tag\", metavar=\"TAG\", help=\"Specify an interpreter tag(s)\"\n    )\n    tags_parser.add_argument(\"--abi-tag\", metavar=\"TAG\", help=\"Specify an ABI tag(s)\")\n    tags_parser.add_argument(\n        \"--platform-tag\", metavar=\"TAG\", help=\"Specify a platform tag(s)\"\n    )\n    tags_parser.add_argument(\n        \"--build\", type=parse_build_tag, metavar=\"BUILD\", help=\"Specify a build tag\"\n    )\n    tags_parser.set_defaults(func=tags_f)\n\n    version_parser = s.add_parser(\"version\", help=\"Print version and exit\")\n    version_parser.set_defaults(func=version_f)\n\n    help_parser = s.add_parser(\"help\", help=\"Show this help\")\n    help_parser.set_defaults(func=lambda args: p.print_help())\n\n    return p\n\n\ndef main():\n    p = parser()\n    args = p.parse_args()\n    if not hasattr(args, \"func\"):\n        p.print_help()\n    else:\n        try:\n            args.func(args)\n            return 0\n        except WheelError as e:\n            print(e, file=sys.stderr)\n\n    return 1\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/cli/convert.py","size":12634,"sha1":"97be977afa10a3d76bedea5a9a00c3562a85570d","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport os.path\nimport re\nfrom abc import ABCMeta, abstractmethod\nfrom collections import defaultdict\nfrom collections.abc import Iterator\nfrom email.message import Message\nfrom email.parser import Parser\nfrom email.policy import EmailPolicy\nfrom glob import iglob\nfrom pathlib import Path\nfrom textwrap import dedent\nfrom zipfile import ZipFile\n\nfrom .. import __version__\nfrom ..metadata import generate_requirements\nfrom ..vendored.packaging.tags import parse_tag\nfrom ..wheelfile import WheelFile\n\negg_filename_re = re.compile(\n    r\"\"\"\n    (?P<name>.+?)-(?P<ver>.+?)\n    (-(?P<pyver>py\\d\\.\\d+)\n     (-(?P<arch>.+?))?\n    )?.egg$\"\"\",\n    re.VERBOSE,\n)\negg_info_re = re.compile(\n    r\"\"\"\n    ^(?P<name>.+?)-(?P<ver>.+?)\n    (-(?P<pyver>py\\d\\.\\d+)\n    )?.egg-info/\"\"\",\n    re.VERBOSE,\n)\nwininst_re = re.compile(\n    r\"\\.(?P<platform>win32|win-amd64)(?:-(?P<pyver>py\\d\\.\\d))?\\.exe$\"\n)\npyd_re = re.compile(r\"\\.(?P<abi>[a-z0-9]+)-(?P<platform>win32|win_amd64)\\.pyd$\")\nserialization_policy = EmailPolicy(\n    utf8=True,\n    mangle_from_=False,\n    max_line_length=0,\n)\nGENERATOR = f\"wheel {__version__}\"\n\n\ndef convert_requires(requires: str, metadata: Message) -> None:\n    extra: str | None = None\n    requirements: dict[str | None, list[str]] = defaultdict(list)\n    for line in requires.splitlines():\n        line = line.strip()\n        if not line:\n            continue\n\n        if line.startswith(\"[\") and line.endswith(\"]\"):\n            extra = line[1:-1]\n            continue\n\n        requirements[extra].append(line)\n\n    for key, value in generate_requirements(requirements):\n        metadata.add_header(key, value)\n\n\ndef convert_pkg_info(pkginfo: str, metadata: Message):\n    parsed_message = Parser().parsestr(pkginfo)\n    for key, value in parsed_message.items():\n        key_lower = key.lower()\n        if value == \"UNKNOWN\":\n            continue\n\n        if key_lower == \"description\":\n            description_lines = value.splitlines()\n            value = \"\\n\".join(\n                (\n                    description_lines[0].lstrip(),\n                    dedent(\"\\n\".join(description_lines[1:])),\n                    \"\\n\",\n                )\n            )\n            metadata.set_payload(value)\n        elif key_lower == \"home-page\":\n            metadata.add_header(\"Project-URL\", f\"Homepage, {value}\")\n        elif key_lower == \"download-url\":\n            metadata.add_header(\"Project-URL\", f\"Download, {value}\")\n        else:\n            metadata.add_header(key, value)\n\n    metadata.replace_header(\"Metadata-Version\", \"2.4\")\n\n\ndef normalize(name: str) -> str:\n    return re.sub(r\"[-_.]+\", \"-\", name).lower().replace(\"-\", \"_\")\n\n\nclass ConvertSource(metaclass=ABCMeta):\n    name: str\n    version: str\n    pyver: str = \"py2.py3\"\n    abi: str = \"none\"\n    platform: str = \"any\"\n    metadata: Message\n\n    @property\n    def dist_info_dir(self) -> str:\n        return f\"{self.name}-{self.version}.dist-info\"\n\n    @abstractmethod\n    def generate_contents(self) -> Iterator[tuple[str, bytes]]:\n        pass\n\n\nclass EggFileSource(ConvertSource):\n    def __init__(self, path: Path):\n        if not (match := egg_filename_re.match(path.name)):\n            raise ValueError(f\"Invalid egg file name: {path.name}\")\n\n        # Binary wheels are assumed to be for CPython\n        self.path = path\n        self.name = normalize(match.group(\"name\"))\n        self.version = match.group(\"ver\")\n        if pyver := match.group(\"pyver\"):\n            self.pyver = pyver.replace(\".\", \"\")\n            if arch := match.group(\"arch\"):\n                self.abi = self.pyver.replace(\"py\", \"cp\")\n                self.platform = normalize(arch)\n\n        self.metadata = Message()\n\n    def generate_contents(self) -> Iterator[tuple[str, bytes]]:\n        with ZipFile(self.path, \"r\") as zip_file:\n            for filename in sorted(zip_file.namelist()):\n                # Skip pure directory entries\n                if filename.endswith(\"/\"):\n                    continue\n\n                # Handle files in the egg-info directory specially, selectively moving\n                # them to the dist-info directory while converting as needed\n                if filename.startswith(\"EGG-INFO/\"):\n                    if filename == \"EGG-INFO/requires.txt\":\n                        requires = zip_file.read(filename).decode(\"utf-8\")\n                        convert_requires(requires, self.metadata)\n                    elif filename == \"EGG-INFO/PKG-INFO\":\n                        pkginfo = zip_file.read(filename).decode(\"utf-8\")\n                        convert_pkg_info(pkginfo, self.metadata)\n                    elif filename == \"EGG-INFO/entry_points.txt\":\n                        yield (\n                            f\"{self.dist_info_dir}/entry_points.txt\",\n                            zip_file.read(filename),\n                        )\n\n                    continue\n\n                # For any other file, just pass it through\n                yield filename, zip_file.read(filename)\n\n\nclass EggDirectorySource(EggFileSource):\n    def generate_contents(self) -> Iterator[tuple[str, bytes]]:\n        for dirpath, _, filenames in os.walk(self.path):\n            for filename in sorted(filenames):\n                path = Path(dirpath, filename)\n                if path.parent.name == \"EGG-INFO\":\n                    if path.name == \"requires.txt\":\n                        requires = path.read_text(\"utf-8\")\n                        convert_requires(requires, self.metadata)\n                    elif path.name == \"PKG-INFO\":\n                        pkginfo = path.read_text(\"utf-8\")\n                        convert_pkg_info(pkginfo, self.metadata)\n                        if name := self.metadata.get(\"Name\"):\n                            self.name = normalize(name)\n\n                        if version := self.metadata.get(\"Version\"):\n                            self.version = version\n                    elif path.name == \"entry_points.txt\":\n                        yield (\n                            f\"{self.dist_info_dir}/entry_points.txt\",\n                            path.read_bytes(),\n                        )\n\n                    continue\n\n                # For any other file, just pass it through\n                yield str(path.relative_to(self.path)), path.read_bytes()\n\n\nclass WininstFileSource(ConvertSource):\n    \"\"\"\n    Handles distributions created with ``bdist_wininst``.\n\n    The egginfo filename has the format::\n\n        name-ver(-pyver)(-arch).egg-info\n\n    The installer filename has the format::\n\n        name-ver.arch(-pyver).exe\n\n    Some things to note:\n\n    1. The installer filename is not definitive. An installer can be renamed\n       and work perfectly well as an installer. So more reliable data should\n       be used whenever possible.\n    2. The egg-info data should be preferred for the name and version, because\n       these come straight from the distutils metadata, and are mandatory.\n    3. The pyver from the egg-info data should be ignored, as it is\n       constructed from the version of Python used to build the installer,\n       which is irrelevant - the installer filename is correct here (even to\n       the point that when it's not there, any version is implied).\n    4. The architecture must be taken from the installer filename, as it is\n       not included in the egg-info data.\n    5. Architecture-neutral installers still have an architecture because the\n       installer format itself (being executable) is architecture-specific. We\n       should therefore ignore the architecture if the content is pure-python.\n    \"\"\"\n\n    def __init__(self, path: Path):\n        self.path = path\n        self.metadata = Message()\n\n        # Determine the initial architecture and Python version from the file name\n        # (if possible)\n        if match := wininst_re.search(path.name):\n            self.platform = normalize(match.group(\"platform\"))\n            if pyver := match.group(\"pyver\"):\n                self.pyver = pyver.replace(\".\", \"\")\n\n        # Look for an .egg-info directory and any .pyd files for more precise info\n        egg_info_found = pyd_found = False\n        with ZipFile(self.path) as zip_file:\n            for filename in zip_file.namelist():\n                prefix, filename = filename.split(\"/\", 1)\n                if not egg_info_found and (match := egg_info_re.match(filename)):\n                    egg_info_found = True\n                    self.name = normalize(match.group(\"name\"))\n                    self.version = match.group(\"ver\")\n                    if pyver := match.group(\"pyver\"):\n                        self.pyver = pyver.replace(\".\", \"\")\n                elif not pyd_found and (match := pyd_re.search(filename)):\n                    pyd_found = True\n                    self.abi = match.group(\"abi\")\n                    self.platform = match.group(\"platform\")\n\n                if egg_info_found and pyd_found:\n                    break\n\n    def generate_contents(self) -> Iterator[tuple[str, bytes]]:\n        dist_info_dir = f\"{self.name}-{self.version}.dist-info\"\n        data_dir = f\"{self.name}-{self.version}.data\"\n        with ZipFile(self.path, \"r\") as zip_file:\n            for filename in sorted(zip_file.namelist()):\n                # Skip pure directory entries\n                if filename.endswith(\"/\"):\n                    continue\n\n                # Handle files in the egg-info directory specially, selectively moving\n                # them to the dist-info directory while converting as needed\n                prefix, target_filename = filename.split(\"/\", 1)\n                if egg_info_re.search(target_filename):\n                    basename = target_filename.rsplit(\"/\", 1)[-1]\n                    if basename == \"requires.txt\":\n                        requires = zip_file.read(filename).decode(\"utf-8\")\n                        convert_requires(requires, self.metadata)\n                    elif basename == \"PKG-INFO\":\n                        pkginfo = zip_file.read(filename).decode(\"utf-8\")\n                        convert_pkg_info(pkginfo, self.metadata)\n                    elif basename == \"entry_points.txt\":\n                        yield (\n                            f\"{dist_info_dir}/entry_points.txt\",\n                            zip_file.read(filename),\n                        )\n\n                    continue\n                elif prefix == \"SCRIPTS\":\n                    target_filename = f\"{data_dir}/scripts/{target_filename}\"\n\n                # For any other file, just pass it through\n                yield target_filename, zip_file.read(filename)\n\n\ndef convert(files: list[str], dest_dir: str, verbose: bool) -> None:\n    for pat in files:\n        for archive in iglob(pat):\n            path = Path(archive)\n            if path.suffix == \".egg\":\n                if path.is_dir():\n                    source: ConvertSource = EggDirectorySource(path)\n                else:\n                    source = EggFileSource(path)\n            else:\n                source = WininstFileSource(path)\n\n            if verbose:\n                print(f\"{archive}...\", flush=True, end=\"\")\n\n            dest_path = Path(dest_dir) / (\n                f\"{source.name}-{source.version}-{source.pyver}-{source.abi}\"\n                f\"-{source.platform}.whl\"\n            )\n            with WheelFile(dest_path, \"w\") as wheelfile:\n                for name_or_zinfo, contents in source.generate_contents():\n                    wheelfile.writestr(name_or_zinfo, contents)\n\n                # Write the METADATA file\n                wheelfile.writestr(\n                    f\"{source.dist_info_dir}/METADATA\",\n                    source.metadata.as_string(policy=serialization_policy).encode(\n                        \"utf-8\"\n                    ),\n                )\n\n                # Write the WHEEL file\n                wheel_message = Message()\n                wheel_message.add_header(\"Wheel-Version\", \"1.0\")\n                wheel_message.add_header(\"Generator\", GENERATOR)\n                wheel_message.add_header(\n                    \"Root-Is-Purelib\", str(source.platform == \"any\").lower()\n                )\n                tags = parse_tag(f\"{source.pyver}-{source.abi}-{source.platform}\")\n                for tag in sorted(tags, key=lambda tag: tag.interpreter):\n                    wheel_message.add_header(\"Tag\", str(tag))\n\n                wheelfile.writestr(\n                    f\"{source.dist_info_dir}/WHEEL\",\n                    wheel_message.as_string(policy=serialization_policy).encode(\n                        \"utf-8\"\n                    ),\n                )\n\n            if verbose:\n                print(\"OK\")\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/cli/pack.py","size":3103,"sha1":"8ed643c3d003b233b98aa1ff49c5c7799d73e304","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport email.policy\nimport os.path\nimport re\nfrom email.generator import BytesGenerator\nfrom email.parser import BytesParser\n\nfrom wheel.cli import WheelError\nfrom wheel.wheelfile import WheelFile\n\nDIST_INFO_RE = re.compile(r\"^(?P<namever>(?P<name>.+?)-(?P<ver>\\d.*?))\\.dist-info$\")\n\n\ndef pack(directory: str, dest_dir: str, build_number: str | None) -> None:\n    \"\"\"Repack a previously unpacked wheel directory into a new wheel file.\n\n    The .dist-info/WHEEL file must contain one or more tags so that the target\n    wheel file name can be determined.\n\n    :param directory: The unpacked wheel directory\n    :param dest_dir: Destination directory (defaults to the current directory)\n    \"\"\"\n    # Find the .dist-info directory\n    dist_info_dirs = [\n        fn\n        for fn in os.listdir(directory)\n        if os.path.isdir(os.path.join(directory, fn)) and DIST_INFO_RE.match(fn)\n    ]\n    if len(dist_info_dirs) > 1:\n        raise WheelError(f\"Multiple .dist-info directories found in {directory}\")\n    elif not dist_info_dirs:\n        raise WheelError(f\"No .dist-info directories found in {directory}\")\n\n    # Determine the target wheel filename\n    dist_info_dir = dist_info_dirs[0]\n    name_version = DIST_INFO_RE.match(dist_info_dir).group(\"namever\")\n\n    # Read the tags and the existing build number from .dist-info/WHEEL\n    wheel_file_path = os.path.join(directory, dist_info_dir, \"WHEEL\")\n    with open(wheel_file_path, \"rb\") as f:\n        info = BytesParser(policy=email.policy.compat32).parse(f)\n        tags: list[str] = info.get_all(\"Tag\", [])\n        existing_build_number = info.get(\"Build\")\n\n        if not tags:\n            raise WheelError(\n                f\"No tags present in {dist_info_dir}/WHEEL; cannot determine target \"\n                f\"wheel filename\"\n            )\n\n    # Set the wheel file name and add/replace/remove the Build tag in .dist-info/WHEEL\n    build_number = build_number if build_number is not None else existing_build_number\n    if build_number is not None:\n        del info[\"Build\"]\n        if build_number:\n            info[\"Build\"] = build_number\n            name_version += \"-\" + build_number\n\n        if build_number != existing_build_number:\n            with open(wheel_file_path, \"wb\") as f:\n                BytesGenerator(f, maxheaderlen=0).flatten(info)\n\n    # Reassemble the tags for the wheel file\n    tagline = compute_tagline(tags)\n\n    # Repack the wheel\n    wheel_path = os.path.join(dest_dir, f\"{name_version}-{tagline}.whl\")\n    with WheelFile(wheel_path, \"w\") as wf:\n        print(f\"Repacking wheel as {wheel_path}...\", end=\"\", flush=True)\n        wf.write_files(directory)\n\n    print(\"OK\")\n\n\ndef compute_tagline(tags: list[str]) -> str:\n    \"\"\"Compute a tagline from a list of tags.\n\n    :param tags: A list of tags\n    :return: A tagline\n    \"\"\"\n    impls = sorted({tag.split(\"-\")[0] for tag in tags})\n    abivers = sorted({tag.split(\"-\")[1] for tag in tags})\n    platforms = sorted({tag.split(\"-\")[2] for tag in tags})\n    return \"-\".join([\".\".join(impls), \".\".join(abivers), \".\".join(platforms)])\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/cli/tags.py","size":4760,"sha1":"2c64402ed05e39936574200e18dcf3f53d60ac49","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport email.policy\nimport itertools\nimport os\nfrom collections.abc import Iterable\nfrom email.parser import BytesParser\n\nfrom ..wheelfile import WheelFile\n\n\ndef _compute_tags(original_tags: Iterable[str], new_tags: str | None) -> set[str]:\n    \"\"\"Add or replace tags. Supports dot-separated tags\"\"\"\n    if new_tags is None:\n        return set(original_tags)\n\n    if new_tags.startswith(\"+\"):\n        return {*original_tags, *new_tags[1:].split(\".\")}\n\n    if new_tags.startswith(\"-\"):\n        return set(original_tags) - set(new_tags[1:].split(\".\"))\n\n    return set(new_tags.split(\".\"))\n\n\ndef tags(\n    wheel: str,\n    python_tags: str | None = None,\n    abi_tags: str | None = None,\n    platform_tags: str | None = None,\n    build_tag: str | None = None,\n    remove: bool = False,\n) -> str:\n    \"\"\"Change the tags on a wheel file.\n\n    The tags are left unchanged if they are not specified. To specify \"none\",\n    use [\"none\"]. To append to the previous tags, a tag should start with a\n    \"+\".  If a tag starts with \"-\", it will be removed from existing tags.\n    Processing is done left to right.\n\n    :param wheel: The paths to the wheels\n    :param python_tags: The Python tags to set\n    :param abi_tags: The ABI tags to set\n    :param platform_tags: The platform tags to set\n    :param build_tag: The build tag to set\n    :param remove: Remove the original wheel\n    \"\"\"\n    with WheelFile(wheel, \"r\") as f:\n        assert f.filename, f\"{f.filename} must be available\"\n\n        wheel_info = f.read(f.dist_info_path + \"/WHEEL\")\n        info = BytesParser(policy=email.policy.compat32).parsebytes(wheel_info)\n\n        original_wheel_name = os.path.basename(f.filename)\n        namever = f.parsed_filename.group(\"namever\")\n        build = f.parsed_filename.group(\"build\")\n        original_python_tags = f.parsed_filename.group(\"pyver\").split(\".\")\n        original_abi_tags = f.parsed_filename.group(\"abi\").split(\".\")\n        original_plat_tags = f.parsed_filename.group(\"plat\").split(\".\")\n\n    tags: list[str] = info.get_all(\"Tag\", [])\n    existing_build_tag = info.get(\"Build\")\n\n    impls = {tag.split(\"-\")[0] for tag in tags}\n    abivers = {tag.split(\"-\")[1] for tag in tags}\n    platforms = {tag.split(\"-\")[2] for tag in tags}\n\n    if impls != set(original_python_tags):\n        msg = f\"Wheel internal tags {impls!r} != filename tags {original_python_tags!r}\"\n        raise AssertionError(msg)\n\n    if abivers != set(original_abi_tags):\n        msg = f\"Wheel internal tags {abivers!r} != filename tags {original_abi_tags!r}\"\n        raise AssertionError(msg)\n\n    if platforms != set(original_plat_tags):\n        msg = (\n            f\"Wheel internal tags {platforms!r} != filename tags {original_plat_tags!r}\"\n        )\n        raise AssertionError(msg)\n\n    if existing_build_tag != build:\n        msg = (\n            f\"Incorrect filename '{build}' \"\n            f\"& *.dist-info/WHEEL '{existing_build_tag}' build numbers\"\n        )\n        raise AssertionError(msg)\n\n    # Start changing as needed\n    if build_tag is not None:\n        build = build_tag\n\n    final_python_tags = sorted(_compute_tags(original_python_tags, python_tags))\n    final_abi_tags = sorted(_compute_tags(original_abi_tags, abi_tags))\n    final_plat_tags = sorted(_compute_tags(original_plat_tags, platform_tags))\n\n    final_tags = [\n        namever,\n        \".\".join(final_python_tags),\n        \".\".join(final_abi_tags),\n        \".\".join(final_plat_tags),\n    ]\n    if build:\n        final_tags.insert(1, build)\n\n    final_wheel_name = \"-\".join(final_tags) + \".whl\"\n\n    if original_wheel_name != final_wheel_name:\n        del info[\"Tag\"], info[\"Build\"]\n        for a, b, c in itertools.product(\n            final_python_tags, final_abi_tags, final_plat_tags\n        ):\n            info[\"Tag\"] = f\"{a}-{b}-{c}\"\n        if build:\n            info[\"Build\"] = build\n\n        original_wheel_path = os.path.join(\n            os.path.dirname(f.filename), original_wheel_name\n        )\n        final_wheel_path = os.path.join(os.path.dirname(f.filename), final_wheel_name)\n\n        with WheelFile(original_wheel_path, \"r\") as fin, WheelFile(\n            final_wheel_path, \"w\"\n        ) as fout:\n            fout.comment = fin.comment  # preserve the comment\n            for item in fin.infolist():\n                if item.is_dir():\n                    continue\n                if item.filename == f.dist_info_path + \"/RECORD\":\n                    continue\n                if item.filename == f.dist_info_path + \"/WHEEL\":\n                    fout.writestr(item, info.as_bytes())\n                else:\n                    fout.writestr(item, fin.read(item))\n\n        if remove:\n            os.remove(original_wheel_path)\n\n    return final_wheel_name\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/cli/unpack.py","size":1021,"sha1":"2b8c046ef5b7bd057804871532b93360e67b6a90","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nfrom pathlib import Path\n\nfrom ..wheelfile import WheelFile\n\n\ndef unpack(path: str, dest: str = \".\") -> None:\n    \"\"\"Unpack a wheel.\n\n    Wheel content will be unpacked to {dest}/{name}-{ver}, where {name}\n    is the package name and {ver} its version.\n\n    :param path: The path to the wheel.\n    :param dest: Destination directory (default to current directory).\n    \"\"\"\n    with WheelFile(path) as wf:\n        namever = wf.parsed_filename.group(\"namever\")\n        destination = Path(dest) / namever\n        print(f\"Unpacking to: {destination}...\", end=\"\", flush=True)\n        for zinfo in wf.filelist:\n            wf.extract(zinfo, destination)\n\n            # Set permissions to the same values as they were set in the archive\n            # We have to do this manually due to\n            # https://github.com/python/cpython/issues/59999\n            permissions = zinfo.external_attr >> 16 & 0o777\n            destination.joinpath(zinfo.filename).chmod(permissions)\n\n    print(\"OK\")\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/macosx_libfile.py","size":16572,"sha1":"a3af47725c69a1949162b3cd6a4643f5dfdafde2","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nThis module contains function to analyse dynamic library\nheaders to extract system information\n\nCurrently only for MacOSX\n\nLibrary file on macosx system starts with Mach-O or Fat field.\nThis can be distinguish by first 32 bites and it is called magic number.\nProper value of magic number is with suffix _MAGIC. Suffix _CIGAM means\nreversed bytes order.\nBoth fields can occur in two types: 32 and 64 bytes.\n\nFAT field inform that this library contains few version of library\n(typically for different types version). It contains\ninformation where Mach-O headers starts.\n\nEach section started with Mach-O header contains one library\n(So if file starts with this field it contains only one version).\n\nAfter filed Mach-O there are section fields.\nEach of them starts with two fields:\ncmd - magic number for this command\ncmdsize - total size occupied by this section information.\n\nIn this case only sections LC_VERSION_MIN_MACOSX (for macosx 10.13 and earlier)\nand LC_BUILD_VERSION (for macosx 10.14 and newer) are interesting,\nbecause them contains information about minimal system version.\n\nImportant remarks:\n- For fat files this implementation looks for maximum number version.\n  It not check if it is 32 or 64 and do not compare it with currently built package.\n  So it is possible to false report higher version that needed.\n- All structures signatures are taken form macosx header files.\n- I think that binary format will be more stable than `otool` output.\n  and if apple introduce some changes both implementation will need to be updated.\n- The system compile will set the deployment target no lower than\n  11.0 for arm64 builds. For \"Universal 2\" builds use the x86_64 deployment\n  target when the arm64 target is 11.0.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport ctypes\nimport os\nimport sys\nfrom io import BufferedIOBase\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from typing import Union\n\n    StrPath = Union[str, os.PathLike[str]]\n\n\"\"\"here the needed const and struct from mach-o header files\"\"\"\n\nFAT_MAGIC = 0xCAFEBABE\nFAT_CIGAM = 0xBEBAFECA\nFAT_MAGIC_64 = 0xCAFEBABF\nFAT_CIGAM_64 = 0xBFBAFECA\nMH_MAGIC = 0xFEEDFACE\nMH_CIGAM = 0xCEFAEDFE\nMH_MAGIC_64 = 0xFEEDFACF\nMH_CIGAM_64 = 0xCFFAEDFE\n\nLC_VERSION_MIN_MACOSX = 0x24\nLC_BUILD_VERSION = 0x32\n\nCPU_TYPE_ARM64 = 0x0100000C\n\nmach_header_fields = [\n    (\"magic\", ctypes.c_uint32),\n    (\"cputype\", ctypes.c_int),\n    (\"cpusubtype\", ctypes.c_int),\n    (\"filetype\", ctypes.c_uint32),\n    (\"ncmds\", ctypes.c_uint32),\n    (\"sizeofcmds\", ctypes.c_uint32),\n    (\"flags\", ctypes.c_uint32),\n]\n\"\"\"\nstruct mach_header {\n    uint32_t\tmagic;\t\t/* mach magic number identifier */\n    cpu_type_t\tcputype;\t/* cpu specifier */\n    cpu_subtype_t\tcpusubtype;\t/* machine specifier */\n    uint32_t\tfiletype;\t/* type of file */\n    uint32_t\tncmds;\t\t/* number of load commands */\n    uint32_t\tsizeofcmds;\t/* the size of all the load commands */\n    uint32_t\tflags;\t\t/* flags */\n};\ntypedef integer_t cpu_type_t;\ntypedef integer_t cpu_subtype_t;\n\"\"\"\n\nmach_header_fields_64 = mach_header_fields + [(\"reserved\", ctypes.c_uint32)]\n\"\"\"\nstruct mach_header_64 {\n    uint32_t\tmagic;\t\t/* mach magic number identifier */\n    cpu_type_t\tcputype;\t/* cpu specifier */\n    cpu_subtype_t\tcpusubtype;\t/* machine specifier */\n    uint32_t\tfiletype;\t/* type of file */\n    uint32_t\tncmds;\t\t/* number of load commands */\n    uint32_t\tsizeofcmds;\t/* the size of all the load commands */\n    uint32_t\tflags;\t\t/* flags */\n    uint32_t\treserved;\t/* reserved */\n};\n\"\"\"\n\nfat_header_fields = [(\"magic\", ctypes.c_uint32), (\"nfat_arch\", ctypes.c_uint32)]\n\"\"\"\nstruct fat_header {\n    uint32_t\tmagic;\t\t/* FAT_MAGIC or FAT_MAGIC_64 */\n    uint32_t\tnfat_arch;\t/* number of structs that follow */\n};\n\"\"\"\n\nfat_arch_fields = [\n    (\"cputype\", ctypes.c_int),\n    (\"cpusubtype\", ctypes.c_int),\n    (\"offset\", ctypes.c_uint32),\n    (\"size\", ctypes.c_uint32),\n    (\"align\", ctypes.c_uint32),\n]\n\"\"\"\nstruct fat_arch {\n    cpu_type_t\tcputype;\t/* cpu specifier (int) */\n    cpu_subtype_t\tcpusubtype;\t/* machine specifier (int) */\n    uint32_t\toffset;\t\t/* file offset to this object file */\n    uint32_t\tsize;\t\t/* size of this object file */\n    uint32_t\talign;\t\t/* alignment as a power of 2 */\n};\n\"\"\"\n\nfat_arch_64_fields = [\n    (\"cputype\", ctypes.c_int),\n    (\"cpusubtype\", ctypes.c_int),\n    (\"offset\", ctypes.c_uint64),\n    (\"size\", ctypes.c_uint64),\n    (\"align\", ctypes.c_uint32),\n    (\"reserved\", ctypes.c_uint32),\n]\n\"\"\"\nstruct fat_arch_64 {\n    cpu_type_t\tcputype;\t/* cpu specifier (int) */\n    cpu_subtype_t\tcpusubtype;\t/* machine specifier (int) */\n    uint64_t\toffset;\t\t/* file offset to this object file */\n    uint64_t\tsize;\t\t/* size of this object file */\n    uint32_t\talign;\t\t/* alignment as a power of 2 */\n    uint32_t\treserved;\t/* reserved */\n};\n\"\"\"\n\nsegment_base_fields = [(\"cmd\", ctypes.c_uint32), (\"cmdsize\", ctypes.c_uint32)]\n\"\"\"base for reading segment info\"\"\"\n\nsegment_command_fields = [\n    (\"cmd\", ctypes.c_uint32),\n    (\"cmdsize\", ctypes.c_uint32),\n    (\"segname\", ctypes.c_char * 16),\n    (\"vmaddr\", ctypes.c_uint32),\n    (\"vmsize\", ctypes.c_uint32),\n    (\"fileoff\", ctypes.c_uint32),\n    (\"filesize\", ctypes.c_uint32),\n    (\"maxprot\", ctypes.c_int),\n    (\"initprot\", ctypes.c_int),\n    (\"nsects\", ctypes.c_uint32),\n    (\"flags\", ctypes.c_uint32),\n]\n\"\"\"\nstruct segment_command { /* for 32-bit architectures */\n    uint32_t\tcmd;\t\t/* LC_SEGMENT */\n    uint32_t\tcmdsize;\t/* includes sizeof section structs */\n    char\t\tsegname[16];\t/* segment name */\n    uint32_t\tvmaddr;\t\t/* memory address of this segment */\n    uint32_t\tvmsize;\t\t/* memory size of this segment */\n    uint32_t\tfileoff;\t/* file offset of this segment */\n    uint32_t\tfilesize;\t/* amount to map from the file */\n    vm_prot_t\tmaxprot;\t/* maximum VM protection */\n    vm_prot_t\tinitprot;\t/* initial VM protection */\n    uint32_t\tnsects;\t\t/* number of sections in segment */\n    uint32_t\tflags;\t\t/* flags */\n};\ntypedef int vm_prot_t;\n\"\"\"\n\nsegment_command_fields_64 = [\n    (\"cmd\", ctypes.c_uint32),\n    (\"cmdsize\", ctypes.c_uint32),\n    (\"segname\", ctypes.c_char * 16),\n    (\"vmaddr\", ctypes.c_uint64),\n    (\"vmsize\", ctypes.c_uint64),\n    (\"fileoff\", ctypes.c_uint64),\n    (\"filesize\", ctypes.c_uint64),\n    (\"maxprot\", ctypes.c_int),\n    (\"initprot\", ctypes.c_int),\n    (\"nsects\", ctypes.c_uint32),\n    (\"flags\", ctypes.c_uint32),\n]\n\"\"\"\nstruct segment_command_64 { /* for 64-bit architectures */\n    uint32_t\tcmd;\t\t/* LC_SEGMENT_64 */\n    uint32_t\tcmdsize;\t/* includes sizeof section_64 structs */\n    char\t\tsegname[16];\t/* segment name */\n    uint64_t\tvmaddr;\t\t/* memory address of this segment */\n    uint64_t\tvmsize;\t\t/* memory size of this segment */\n    uint64_t\tfileoff;\t/* file offset of this segment */\n    uint64_t\tfilesize;\t/* amount to map from the file */\n    vm_prot_t\tmaxprot;\t/* maximum VM protection */\n    vm_prot_t\tinitprot;\t/* initial VM protection */\n    uint32_t\tnsects;\t\t/* number of sections in segment */\n    uint32_t\tflags;\t\t/* flags */\n};\n\"\"\"\n\nversion_min_command_fields = segment_base_fields + [\n    (\"version\", ctypes.c_uint32),\n    (\"sdk\", ctypes.c_uint32),\n]\n\"\"\"\nstruct version_min_command {\n    uint32_t\tcmd;\t\t/* LC_VERSION_MIN_MACOSX or\n                               LC_VERSION_MIN_IPHONEOS or\n                               LC_VERSION_MIN_WATCHOS or\n                               LC_VERSION_MIN_TVOS */\n    uint32_t\tcmdsize;\t/* sizeof(struct min_version_command) */\n    uint32_t\tversion;\t/* X.Y.Z is encoded in nibbles xxxx.yy.zz */\n    uint32_t\tsdk;\t\t/* X.Y.Z is encoded in nibbles xxxx.yy.zz */\n};\n\"\"\"\n\nbuild_version_command_fields = segment_base_fields + [\n    (\"platform\", ctypes.c_uint32),\n    (\"minos\", ctypes.c_uint32),\n    (\"sdk\", ctypes.c_uint32),\n    (\"ntools\", ctypes.c_uint32),\n]\n\"\"\"\nstruct build_version_command {\n    uint32_t\tcmd;\t\t/* LC_BUILD_VERSION */\n    uint32_t\tcmdsize;\t/* sizeof(struct build_version_command) plus */\n                                /* ntools * sizeof(struct build_tool_version) */\n    uint32_t\tplatform;\t/* platform */\n    uint32_t\tminos;\t\t/* X.Y.Z is encoded in nibbles xxxx.yy.zz */\n    uint32_t\tsdk;\t\t/* X.Y.Z is encoded in nibbles xxxx.yy.zz */\n    uint32_t\tntools;\t\t/* number of tool entries following this */\n};\n\"\"\"\n\n\ndef swap32(x: int) -> int:\n    return (\n        ((x << 24) & 0xFF000000)\n        | ((x << 8) & 0x00FF0000)\n        | ((x >> 8) & 0x0000FF00)\n        | ((x >> 24) & 0x000000FF)\n    )\n\n\ndef get_base_class_and_magic_number(\n    lib_file: BufferedIOBase,\n    seek: int | None = None,\n) -> tuple[type[ctypes.Structure], int]:\n    if seek is None:\n        seek = lib_file.tell()\n    else:\n        lib_file.seek(seek)\n    magic_number = ctypes.c_uint32.from_buffer_copy(\n        lib_file.read(ctypes.sizeof(ctypes.c_uint32))\n    ).value\n\n    # Handle wrong byte order\n    if magic_number in [FAT_CIGAM, FAT_CIGAM_64, MH_CIGAM, MH_CIGAM_64]:\n        if sys.byteorder == \"little\":\n            BaseClass = ctypes.BigEndianStructure\n        else:\n            BaseClass = ctypes.LittleEndianStructure\n\n        magic_number = swap32(magic_number)\n    else:\n        BaseClass = ctypes.Structure\n\n    lib_file.seek(seek)\n    return BaseClass, magic_number\n\n\ndef read_data(struct_class: type[ctypes.Structure], lib_file: BufferedIOBase):\n    return struct_class.from_buffer_copy(lib_file.read(ctypes.sizeof(struct_class)))\n\n\ndef extract_macosx_min_system_version(path_to_lib: str):\n    with open(path_to_lib, \"rb\") as lib_file:\n        BaseClass, magic_number = get_base_class_and_magic_number(lib_file, 0)\n        if magic_number not in [FAT_MAGIC, FAT_MAGIC_64, MH_MAGIC, MH_MAGIC_64]:\n            return\n\n        if magic_number in [FAT_MAGIC, FAT_CIGAM_64]:\n\n            class FatHeader(BaseClass):\n                _fields_ = fat_header_fields\n\n            fat_header = read_data(FatHeader, lib_file)\n            if magic_number == FAT_MAGIC:\n\n                class FatArch(BaseClass):\n                    _fields_ = fat_arch_fields\n\n            else:\n\n                class FatArch(BaseClass):\n                    _fields_ = fat_arch_64_fields\n\n            fat_arch_list = [\n                read_data(FatArch, lib_file) for _ in range(fat_header.nfat_arch)\n            ]\n\n            versions_list: list[tuple[int, int, int]] = []\n            for el in fat_arch_list:\n                try:\n                    version = read_mach_header(lib_file, el.offset)\n                    if version is not None:\n                        if el.cputype == CPU_TYPE_ARM64 and len(fat_arch_list) != 1:\n                            # Xcode will not set the deployment target below 11.0.0\n                            # for the arm64 architecture. Ignore the arm64 deployment\n                            # in fat binaries when the target is 11.0.0, that way\n                            # the other architectures can select a lower deployment\n                            # target.\n                            # This is safe because there is no arm64 variant for\n                            # macOS 10.15 or earlier.\n                            if version == (11, 0, 0):\n                                continue\n                        versions_list.append(version)\n                except ValueError:\n                    pass\n\n            if len(versions_list) > 0:\n                return max(versions_list)\n            else:\n                return None\n\n        else:\n            try:\n                return read_mach_header(lib_file, 0)\n            except ValueError:\n                \"\"\"when some error during read library files\"\"\"\n                return None\n\n\ndef read_mach_header(\n    lib_file: BufferedIOBase,\n    seek: int | None = None,\n) -> tuple[int, int, int] | None:\n    \"\"\"\n    This function parses a Mach-O header and extracts\n    information about the minimal macOS version.\n\n    :param lib_file: reference to opened library file with pointer\n    \"\"\"\n    base_class, magic_number = get_base_class_and_magic_number(lib_file, seek)\n    arch = \"32\" if magic_number == MH_MAGIC else \"64\"\n\n    class SegmentBase(base_class):\n        _fields_ = segment_base_fields\n\n    if arch == \"32\":\n\n        class MachHeader(base_class):\n            _fields_ = mach_header_fields\n\n    else:\n\n        class MachHeader(base_class):\n            _fields_ = mach_header_fields_64\n\n    mach_header = read_data(MachHeader, lib_file)\n    for _i in range(mach_header.ncmds):\n        pos = lib_file.tell()\n        segment_base = read_data(SegmentBase, lib_file)\n        lib_file.seek(pos)\n        if segment_base.cmd == LC_VERSION_MIN_MACOSX:\n\n            class VersionMinCommand(base_class):\n                _fields_ = version_min_command_fields\n\n            version_info = read_data(VersionMinCommand, lib_file)\n            return parse_version(version_info.version)\n        elif segment_base.cmd == LC_BUILD_VERSION:\n\n            class VersionBuild(base_class):\n                _fields_ = build_version_command_fields\n\n            version_info = read_data(VersionBuild, lib_file)\n            return parse_version(version_info.minos)\n        else:\n            lib_file.seek(pos + segment_base.cmdsize)\n            continue\n\n\ndef parse_version(version: int) -> tuple[int, int, int]:\n    x = (version & 0xFFFF0000) >> 16\n    y = (version & 0x0000FF00) >> 8\n    z = version & 0x000000FF\n    return x, y, z\n\n\ndef calculate_macosx_platform_tag(archive_root: StrPath, platform_tag: str) -> str:\n    \"\"\"\n    Calculate proper macosx platform tag basing on files which are included to wheel\n\n    Example platform tag `macosx-10.14-x86_64`\n    \"\"\"\n    prefix, base_version, suffix = platform_tag.split(\"-\")\n    base_version = tuple(int(x) for x in base_version.split(\".\"))\n    base_version = base_version[:2]\n    if base_version[0] > 10:\n        base_version = (base_version[0], 0)\n    assert len(base_version) == 2\n    if \"MACOSX_DEPLOYMENT_TARGET\" in os.environ:\n        deploy_target = tuple(\n            int(x) for x in os.environ[\"MACOSX_DEPLOYMENT_TARGET\"].split(\".\")\n        )\n        deploy_target = deploy_target[:2]\n        if deploy_target[0] > 10:\n            deploy_target = (deploy_target[0], 0)\n        if deploy_target < base_version:\n            sys.stderr.write(\n                \"[WARNING] MACOSX_DEPLOYMENT_TARGET is set to a lower value ({}) than \"\n                \"the version on which the Python interpreter was compiled ({}), and \"\n                \"will be ignored.\\n\".format(\n                    \".\".join(str(x) for x in deploy_target),\n                    \".\".join(str(x) for x in base_version),\n                )\n            )\n        else:\n            base_version = deploy_target\n\n    assert len(base_version) == 2\n    start_version = base_version\n    versions_dict: dict[str, tuple[int, int]] = {}\n    for dirpath, _dirnames, filenames in os.walk(archive_root):\n        for filename in filenames:\n            if filename.endswith(\".dylib\") or filename.endswith(\".so\"):\n                lib_path = os.path.join(dirpath, filename)\n                min_ver = extract_macosx_min_system_version(lib_path)\n                if min_ver is not None:\n                    min_ver = min_ver[0:2]\n                    if min_ver[0] > 10:\n                        min_ver = (min_ver[0], 0)\n                    versions_dict[lib_path] = min_ver\n\n    if len(versions_dict) > 0:\n        base_version = max(base_version, max(versions_dict.values()))\n\n    # macosx platform tag do not support minor bugfix release\n    fin_base_version = \"_\".join([str(x) for x in base_version])\n    if start_version < base_version:\n        problematic_files = [k for k, v in versions_dict.items() if v > start_version]\n        problematic_files = \"\\n\".join(problematic_files)\n        if len(problematic_files) == 1:\n            files_form = \"this file\"\n        else:\n            files_form = \"these files\"\n        error_message = (\n            \"[WARNING] This wheel needs a higher macOS version than {}  \"\n            \"To silence this warning, set MACOSX_DEPLOYMENT_TARGET to at least \"\n            + fin_base_version\n            + \" or recreate \"\n            + files_form\n            + \" with lower \"\n            \"MACOSX_DEPLOYMENT_TARGET:  \\n\" + problematic_files\n        )\n\n        if \"MACOSX_DEPLOYMENT_TARGET\" in os.environ:\n            error_message = error_message.format(\n                \"is set in MACOSX_DEPLOYMENT_TARGET variable.\"\n            )\n        else:\n            error_message = error_message.format(\n                \"the version your Python interpreter is compiled against.\"\n            )\n\n        sys.stderr.write(error_message)\n\n    platform_tag = prefix + \"_\" + fin_base_version + \"_\" + suffix\n    return platform_tag\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/metadata.py","size":6171,"sha1":"1e4a516407ca6c7ca0ad0c954714297ec8661a72","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nTools for converting old- to new-style metadata.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport functools\nimport itertools\nimport os.path\nimport re\nimport textwrap\nfrom email.message import Message\nfrom email.parser import Parser\nfrom typing import Generator, Iterable, Iterator, Literal\n\nfrom .vendored.packaging.requirements import Requirement\n\n\ndef _nonblank(str: str) -> bool | Literal[\"\"]:\n    return str and not str.startswith(\"#\")\n\n\n@functools.singledispatch\ndef yield_lines(iterable: Iterable[str]) -> Iterator[str]:\n    r\"\"\"\n    Yield valid lines of a string or iterable.\n    >>> list(yield_lines(''))\n    []\n    >>> list(yield_lines(['foo', 'bar']))\n    ['foo', 'bar']\n    >>> list(yield_lines('foo\\nbar'))\n    ['foo', 'bar']\n    >>> list(yield_lines('\\nfoo\\n#bar\\nbaz #comment'))\n    ['foo', 'baz #comment']\n    >>> list(yield_lines(['foo\\nbar', 'baz', 'bing\\n\\n\\n']))\n    ['foo', 'bar', 'baz', 'bing']\n    \"\"\"\n    return itertools.chain.from_iterable(map(yield_lines, iterable))\n\n\n@yield_lines.register(str)\ndef _(text: str) -> Iterator[str]:\n    return filter(_nonblank, map(str.strip, text.splitlines()))\n\n\ndef split_sections(\n    s: str | Iterator[str],\n) -> Generator[tuple[str | None, list[str]], None, None]:\n    \"\"\"Split a string or iterable thereof into (section, content) pairs\n    Each ``section`` is a stripped version of the section header (\"[section]\")\n    and each ``content`` is a list of stripped lines excluding blank lines and\n    comment-only lines.  If there are any such lines before the first section\n    header, they're returned in a first ``section`` of ``None``.\n    \"\"\"\n    section = None\n    content: list[str] = []\n    for line in yield_lines(s):\n        if line.startswith(\"[\"):\n            if line.endswith(\"]\"):\n                if section or content:\n                    yield section, content\n                section = line[1:-1].strip()\n                content = []\n            else:\n                raise ValueError(\"Invalid section heading\", line)\n        else:\n            content.append(line)\n\n    # wrap up last segment\n    yield section, content\n\n\ndef safe_extra(extra: str) -> str:\n    \"\"\"Convert an arbitrary string to a standard 'extra' name\n    Any runs of non-alphanumeric characters are replaced with a single '_',\n    and the result is always lowercased.\n    \"\"\"\n    return re.sub(\"[^A-Za-z0-9.-]+\", \"_\", extra).lower()\n\n\ndef safe_name(name: str) -> str:\n    \"\"\"Convert an arbitrary string to a standard distribution name\n    Any runs of non-alphanumeric/. characters are replaced with a single '-'.\n    \"\"\"\n    return re.sub(\"[^A-Za-z0-9.]+\", \"-\", name)\n\n\ndef requires_to_requires_dist(requirement: Requirement) -> str:\n    \"\"\"Return the version specifier for a requirement in PEP 345/566 fashion.\"\"\"\n    if requirement.url:\n        return \" @ \" + requirement.url\n\n    requires_dist: list[str] = []\n    for spec in requirement.specifier:\n        requires_dist.append(spec.operator + spec.version)\n\n    if requires_dist:\n        return \" \" + \",\".join(sorted(requires_dist))\n    else:\n        return \"\"\n\n\ndef convert_requirements(requirements: list[str]) -> Iterator[str]:\n    \"\"\"Yield Requires-Dist: strings for parsed requirements strings.\"\"\"\n    for req in requirements:\n        parsed_requirement = Requirement(req)\n        spec = requires_to_requires_dist(parsed_requirement)\n        extras = \",\".join(sorted(safe_extra(e) for e in parsed_requirement.extras))\n        if extras:\n            extras = f\"[{extras}]\"\n\n        yield safe_name(parsed_requirement.name) + extras + spec\n\n\ndef generate_requirements(\n    extras_require: dict[str | None, list[str]],\n) -> Iterator[tuple[str, str]]:\n    \"\"\"\n    Convert requirements from a setup()-style dictionary to\n    ('Requires-Dist', 'requirement') and ('Provides-Extra', 'extra') tuples.\n\n    extras_require is a dictionary of {extra: [requirements]} as passed to setup(),\n    using the empty extra {'': [requirements]} to hold install_requires.\n    \"\"\"\n    for extra, depends in extras_require.items():\n        condition = \"\"\n        extra = extra or \"\"\n        if \":\" in extra:  # setuptools extra:condition syntax\n            extra, condition = extra.split(\":\", 1)\n\n        extra = safe_extra(extra)\n        if extra:\n            yield \"Provides-Extra\", extra\n            if condition:\n                condition = \"(\" + condition + \") and \"\n            condition += f\"extra == '{extra}'\"\n\n        if condition:\n            condition = \" ; \" + condition\n\n        for new_req in convert_requirements(depends):\n            canonical_req = str(Requirement(new_req + condition))\n            yield \"Requires-Dist\", canonical_req\n\n\ndef pkginfo_to_metadata(egg_info_path: str, pkginfo_path: str) -> Message:\n    \"\"\"\n    Convert .egg-info directory with PKG-INFO to the Metadata 2.1 format\n    \"\"\"\n    with open(pkginfo_path, encoding=\"utf-8\") as headers:\n        pkg_info = Parser().parse(headers)\n\n    pkg_info.replace_header(\"Metadata-Version\", \"2.1\")\n    # Those will be regenerated from `requires.txt`.\n    del pkg_info[\"Provides-Extra\"]\n    del pkg_info[\"Requires-Dist\"]\n    requires_path = os.path.join(egg_info_path, \"requires.txt\")\n    if os.path.exists(requires_path):\n        with open(requires_path, encoding=\"utf-8\") as requires_file:\n            requires = requires_file.read()\n\n        parsed_requirements = sorted(split_sections(requires), key=lambda x: x[0] or \"\")\n        for extra, reqs in parsed_requirements:\n            for key, value in generate_requirements({extra: reqs}):\n                if (key, value) not in pkg_info.items():\n                    pkg_info[key] = value\n\n    description = pkg_info[\"Description\"]\n    if description:\n        description_lines = pkg_info[\"Description\"].splitlines()\n        dedented_description = \"\\n\".join(\n            # if the first line of long_description is blank,\n            # the first line here will be indented.\n            (\n                description_lines[0].lstrip(),\n                textwrap.dedent(\"\\n\".join(description_lines[1:])),\n                \"\\n\",\n            )\n        )\n        pkg_info.set_payload(dedented_description)\n        del pkg_info[\"Description\"]\n\n    return pkg_info\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/util.py","size":423,"sha1":"6ba57861fe6c2b0556e0db4de2dff3bac00c0d0c","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport base64\nimport logging\n\nlog = logging.getLogger(\"wheel\")\n\n\ndef urlsafe_b64encode(data: bytes) -> bytes:\n    \"\"\"urlsafe_b64encode without padding\"\"\"\n    return base64.urlsafe_b64encode(data).rstrip(b\"=\")\n\n\ndef urlsafe_b64decode(data: bytes) -> bytes:\n    \"\"\"urlsafe_b64decode without padding\"\"\"\n    pad = b\"=\" * (4 - (len(data) & 3))\n    return base64.urlsafe_b64decode(data + pad)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/vendored/__init__.py","size":0,"sha1":"da39a3ee5e6b4b0d3255bfef95601890afd80709","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":""},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/vendored/packaging/__init__.py","size":0,"sha1":"da39a3ee5e6b4b0d3255bfef95601890afd80709","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":""},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/vendored/packaging/_elffile.py","size":3266,"sha1":"34190a771dc51364fc58f05326e0fed1f37eac61","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"\nELF file parser.\n\nThis provides a class ``ELFFile`` that parses an ELF executable in a similar\ninterface to ``ZipFile``. Only the read interface is implemented.\n\nBased on: https://gist.github.com/lyssdod/f51579ae8d93c8657a5564aefc2ffbca\nELF header: https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html\n\"\"\"\n\nimport enum\nimport os\nimport struct\nfrom typing import IO, Optional, Tuple\n\n\nclass ELFInvalid(ValueError):\n    pass\n\n\nclass EIClass(enum.IntEnum):\n    C32 = 1\n    C64 = 2\n\n\nclass EIData(enum.IntEnum):\n    Lsb = 1\n    Msb = 2\n\n\nclass EMachine(enum.IntEnum):\n    I386 = 3\n    S390 = 22\n    Arm = 40\n    X8664 = 62\n    AArc64 = 183\n\n\nclass ELFFile:\n    \"\"\"\n    Representation of an ELF executable.\n    \"\"\"\n\n    def __init__(self, f: IO[bytes]) -> None:\n        self._f = f\n\n        try:\n            ident = self._read(\"16B\")\n        except struct.error:\n            raise ELFInvalid(\"unable to parse identification\")\n        magic = bytes(ident[:4])\n        if magic != b\"\\x7fELF\":\n            raise ELFInvalid(f\"invalid magic: {magic!r}\")\n\n        self.capacity = ident[4]  # Format for program header (bitness).\n        self.encoding = ident[5]  # Data structure encoding (endianness).\n\n        try:\n            # e_fmt: Format for program header.\n            # p_fmt: Format for section header.\n            # p_idx: Indexes to find p_type, p_offset, and p_filesz.\n            e_fmt, self._p_fmt, self._p_idx = {\n                (1, 1): (\"<HHIIIIIHHH\", \"<IIIIIIII\", (0, 1, 4)),  # 32-bit LSB.\n                (1, 2): (\">HHIIIIIHHH\", \">IIIIIIII\", (0, 1, 4)),  # 32-bit MSB.\n                (2, 1): (\"<HHIQQQIHHH\", \"<IIQQQQQQ\", (0, 2, 5)),  # 64-bit LSB.\n                (2, 2): (\">HHIQQQIHHH\", \">IIQQQQQQ\", (0, 2, 5)),  # 64-bit MSB.\n            }[(self.capacity, self.encoding)]\n        except KeyError:\n            raise ELFInvalid(\n                f\"unrecognized capacity ({self.capacity}) or \"\n                f\"encoding ({self.encoding})\"\n            )\n\n        try:\n            (\n                _,\n                self.machine,  # Architecture type.\n                _,\n                _,\n                self._e_phoff,  # Offset of program header.\n                _,\n                self.flags,  # Processor-specific flags.\n                _,\n                self._e_phentsize,  # Size of section.\n                self._e_phnum,  # Number of sections.\n            ) = self._read(e_fmt)\n        except struct.error as e:\n            raise ELFInvalid(\"unable to parse machine and section information\") from e\n\n    def _read(self, fmt: str) -> Tuple[int, ...]:\n        return struct.unpack(fmt, self._f.read(struct.calcsize(fmt)))\n\n    @property\n    def interpreter(self) -> Optional[str]:\n        \"\"\"\n        The path recorded in the ``PT_INTERP`` section header.\n        \"\"\"\n        for index in range(self._e_phnum):\n            self._f.seek(self._e_phoff + self._e_phentsize * index)\n            try:\n                data = self._read(self._p_fmt)\n            except struct.error:\n                continue\n            if data[self._p_idx[0]] != 3:  # Not PT_INTERP.\n                continue\n            self._f.seek(data[self._p_idx[1]])\n            return os.fsdecode(self._f.read(data[self._p_idx[2]])).strip(\"\\0\")\n        return None\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/vendored/packaging/_manylinux.py","size":9588,"sha1":"4f06dcc509cf427a7294036631b07a36af765208","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import collections\nimport contextlib\nimport functools\nimport os\nimport re\nimport sys\nimport warnings\nfrom typing import Dict, Generator, Iterator, NamedTuple, Optional, Sequence, Tuple\n\nfrom ._elffile import EIClass, EIData, ELFFile, EMachine\n\nEF_ARM_ABIMASK = 0xFF000000\nEF_ARM_ABI_VER5 = 0x05000000\nEF_ARM_ABI_FLOAT_HARD = 0x00000400\n\n\n# `os.PathLike` not a generic type until Python 3.9, so sticking with `str`\n# as the type for `path` until then.\n@contextlib.contextmanager\ndef _parse_elf(path: str) -> Generator[Optional[ELFFile], None, None]:\n    try:\n        with open(path, \"rb\") as f:\n            yield ELFFile(f)\n    except (OSError, TypeError, ValueError):\n        yield None\n\n\ndef _is_linux_armhf(executable: str) -> bool:\n    # hard-float ABI can be detected from the ELF header of the running\n    # process\n    # https://static.docs.arm.com/ihi0044/g/aaelf32.pdf\n    with _parse_elf(executable) as f:\n        return (\n            f is not None\n            and f.capacity == EIClass.C32\n            and f.encoding == EIData.Lsb\n            and f.machine == EMachine.Arm\n            and f.flags & EF_ARM_ABIMASK == EF_ARM_ABI_VER5\n            and f.flags & EF_ARM_ABI_FLOAT_HARD == EF_ARM_ABI_FLOAT_HARD\n        )\n\n\ndef _is_linux_i686(executable: str) -> bool:\n    with _parse_elf(executable) as f:\n        return (\n            f is not None\n            and f.capacity == EIClass.C32\n            and f.encoding == EIData.Lsb\n            and f.machine == EMachine.I386\n        )\n\n\ndef _have_compatible_abi(executable: str, archs: Sequence[str]) -> bool:\n    if \"armv7l\" in archs:\n        return _is_linux_armhf(executable)\n    if \"i686\" in archs:\n        return _is_linux_i686(executable)\n    allowed_archs = {\n        \"x86_64\",\n        \"aarch64\",\n        \"ppc64\",\n        \"ppc64le\",\n        \"s390x\",\n        \"loongarch64\",\n        \"riscv64\",\n    }\n    return any(arch in allowed_archs for arch in archs)\n\n\n# If glibc ever changes its major version, we need to know what the last\n# minor version was, so we can build the complete list of all versions.\n# For now, guess what the highest minor version might be, assume it will\n# be 50 for testing. Once this actually happens, update the dictionary\n# with the actual value.\n_LAST_GLIBC_MINOR: Dict[int, int] = collections.defaultdict(lambda: 50)\n\n\nclass _GLibCVersion(NamedTuple):\n    major: int\n    minor: int\n\n\ndef _glibc_version_string_confstr() -> Optional[str]:\n    \"\"\"\n    Primary implementation of glibc_version_string using os.confstr.\n    \"\"\"\n    # os.confstr is quite a bit faster than ctypes.DLL. It's also less likely\n    # to be broken or missing. This strategy is used in the standard library\n    # platform module.\n    # https://github.com/python/cpython/blob/fcf1d003bf4f0100c/Lib/platform.py#L175-L183\n    try:\n        # Should be a string like \"glibc 2.17\".\n        version_string: Optional[str] = os.confstr(\"CS_GNU_LIBC_VERSION\")\n        assert version_string is not None\n        _, version = version_string.rsplit()\n    except (AssertionError, AttributeError, OSError, ValueError):\n        # os.confstr() or CS_GNU_LIBC_VERSION not available (or a bad value)...\n        return None\n    return version\n\n\ndef _glibc_version_string_ctypes() -> Optional[str]:\n    \"\"\"\n    Fallback implementation of glibc_version_string using ctypes.\n    \"\"\"\n    try:\n        import ctypes\n    except ImportError:\n        return None\n\n    # ctypes.CDLL(None) internally calls dlopen(NULL), and as the dlopen\n    # manpage says, \"If filename is NULL, then the returned handle is for the\n    # main program\". This way we can let the linker do the work to figure out\n    # which libc our process is actually using.\n    #\n    # We must also handle the special case where the executable is not a\n    # dynamically linked executable. This can occur when using musl libc,\n    # for example. In this situation, dlopen() will error, leading to an\n    # OSError. Interestingly, at least in the case of musl, there is no\n    # errno set on the OSError. The single string argument used to construct\n    # OSError comes from libc itself and is therefore not portable to\n    # hard code here. In any case, failure to call dlopen() means we\n    # can proceed, so we bail on our attempt.\n    try:\n        process_namespace = ctypes.CDLL(None)\n    except OSError:\n        return None\n\n    try:\n        gnu_get_libc_version = process_namespace.gnu_get_libc_version\n    except AttributeError:\n        # Symbol doesn't exist -> therefore, we are not linked to\n        # glibc.\n        return None\n\n    # Call gnu_get_libc_version, which returns a string like \"2.5\"\n    gnu_get_libc_version.restype = ctypes.c_char_p\n    version_str: str = gnu_get_libc_version()\n    # py2 / py3 compatibility:\n    if not isinstance(version_str, str):\n        version_str = version_str.decode(\"ascii\")\n\n    return version_str\n\n\ndef _glibc_version_string() -> Optional[str]:\n    \"\"\"Returns glibc version string, or None if not using glibc.\"\"\"\n    return _glibc_version_string_confstr() or _glibc_version_string_ctypes()\n\n\ndef _parse_glibc_version(version_str: str) -> Tuple[int, int]:\n    \"\"\"Parse glibc version.\n\n    We use a regexp instead of str.split because we want to discard any\n    random junk that might come after the minor version -- this might happen\n    in patched/forked versions of glibc (e.g. Linaro's version of glibc\n    uses version strings like \"2.20-2014.11\"). See gh-3588.\n    \"\"\"\n    m = re.match(r\"(?P<major>[0-9]+)\\.(?P<minor>[0-9]+)\", version_str)\n    if not m:\n        warnings.warn(\n            f\"Expected glibc version with 2 components major.minor,\"\n            f\" got: {version_str}\",\n            RuntimeWarning,\n        )\n        return -1, -1\n    return int(m.group(\"major\")), int(m.group(\"minor\"))\n\n\n@functools.lru_cache\ndef _get_glibc_version() -> Tuple[int, int]:\n    version_str = _glibc_version_string()\n    if version_str is None:\n        return (-1, -1)\n    return _parse_glibc_version(version_str)\n\n\n# From PEP 513, PEP 600\ndef _is_compatible(arch: str, version: _GLibCVersion) -> bool:\n    sys_glibc = _get_glibc_version()\n    if sys_glibc < version:\n        return False\n    # Check for presence of _manylinux module.\n    try:\n        import _manylinux\n    except ImportError:\n        return True\n    if hasattr(_manylinux, \"manylinux_compatible\"):\n        result = _manylinux.manylinux_compatible(version[0], version[1], arch)\n        if result is not None:\n            return bool(result)\n        return True\n    if version == _GLibCVersion(2, 5):\n        if hasattr(_manylinux, \"manylinux1_compatible\"):\n            return bool(_manylinux.manylinux1_compatible)\n    if version == _GLibCVersion(2, 12):\n        if hasattr(_manylinux, \"manylinux2010_compatible\"):\n            return bool(_manylinux.manylinux2010_compatible)\n    if version == _GLibCVersion(2, 17):\n        if hasattr(_manylinux, \"manylinux2014_compatible\"):\n            return bool(_manylinux.manylinux2014_compatible)\n    return True\n\n\n_LEGACY_MANYLINUX_MAP = {\n    # CentOS 7 w/ glibc 2.17 (PEP 599)\n    (2, 17): \"manylinux2014\",\n    # CentOS 6 w/ glibc 2.12 (PEP 571)\n    (2, 12): \"manylinux2010\",\n    # CentOS 5 w/ glibc 2.5 (PEP 513)\n    (2, 5): \"manylinux1\",\n}\n\n\ndef platform_tags(archs: Sequence[str]) -> Iterator[str]:\n    \"\"\"Generate manylinux tags compatible to the current platform.\n\n    :param archs: Sequence of compatible architectures.\n        The first one shall be the closest to the actual architecture and be the part of\n        platform tag after the ``linux_`` prefix, e.g. ``x86_64``.\n        The ``linux_`` prefix is assumed as a prerequisite for the current platform to\n        be manylinux-compatible.\n\n    :returns: An iterator of compatible manylinux tags.\n    \"\"\"\n    if not _have_compatible_abi(sys.executable, archs):\n        return\n    # Oldest glibc to be supported regardless of architecture is (2, 17).\n    too_old_glibc2 = _GLibCVersion(2, 16)\n    if set(archs) & {\"x86_64\", \"i686\"}:\n        # On x86/i686 also oldest glibc to be supported is (2, 5).\n        too_old_glibc2 = _GLibCVersion(2, 4)\n    current_glibc = _GLibCVersion(*_get_glibc_version())\n    glibc_max_list = [current_glibc]\n    # We can assume compatibility across glibc major versions.\n    # https://sourceware.org/bugzilla/show_bug.cgi?id=24636\n    #\n    # Build a list of maximum glibc versions so that we can\n    # output the canonical list of all glibc from current_glibc\n    # down to too_old_glibc2, including all intermediary versions.\n    for glibc_major in range(current_glibc.major - 1, 1, -1):\n        glibc_minor = _LAST_GLIBC_MINOR[glibc_major]\n        glibc_max_list.append(_GLibCVersion(glibc_major, glibc_minor))\n    for arch in archs:\n        for glibc_max in glibc_max_list:\n            if glibc_max.major == too_old_glibc2.major:\n                min_minor = too_old_glibc2.minor\n            else:\n                # For other glibc major versions oldest supported is (x, 0).\n                min_minor = -1\n            for glibc_minor in range(glibc_max.minor, min_minor, -1):\n                glibc_version = _GLibCVersion(glibc_max.major, glibc_minor)\n                tag = \"manylinux_{}_{}\".format(*glibc_version)\n                if _is_compatible(arch, glibc_version):\n                    yield f\"{tag}_{arch}\"\n                # Handle the legacy manylinux1, manylinux2010, manylinux2014 tags.\n                if glibc_version in _LEGACY_MANYLINUX_MAP:\n                    legacy_tag = _LEGACY_MANYLINUX_MAP[glibc_version]\n                    if _is_compatible(arch, glibc_version):\n                        yield f\"{legacy_tag}_{arch}\"\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/vendored/packaging/_musllinux.py","size":2674,"sha1":"b1e7ad6daec419442bc20ce5e15269e2d3fe43cf","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"PEP 656 support.\n\nThis module implements logic to detect if the currently running Python is\nlinked against musl, and what musl version is used.\n\"\"\"\n\nimport functools\nimport re\nimport subprocess\nimport sys\nfrom typing import Iterator, NamedTuple, Optional, Sequence\n\nfrom ._elffile import ELFFile\n\n\nclass _MuslVersion(NamedTuple):\n    major: int\n    minor: int\n\n\ndef _parse_musl_version(output: str) -> Optional[_MuslVersion]:\n    lines = [n for n in (n.strip() for n in output.splitlines()) if n]\n    if len(lines) < 2 or lines[0][:4] != \"musl\":\n        return None\n    m = re.match(r\"Version (\\d+)\\.(\\d+)\", lines[1])\n    if not m:\n        return None\n    return _MuslVersion(major=int(m.group(1)), minor=int(m.group(2)))\n\n\n@functools.lru_cache\ndef _get_musl_version(executable: str) -> Optional[_MuslVersion]:\n    \"\"\"Detect currently-running musl runtime version.\n\n    This is done by checking the specified executable's dynamic linking\n    information, and invoking the loader to parse its output for a version\n    string. If the loader is musl, the output would be something like::\n\n        musl libc (x86_64)\n        Version 1.2.2\n        Dynamic Program Loader\n    \"\"\"\n    try:\n        with open(executable, \"rb\") as f:\n            ld = ELFFile(f).interpreter\n    except (OSError, TypeError, ValueError):\n        return None\n    if ld is None or \"musl\" not in ld:\n        return None\n    proc = subprocess.run([ld], stderr=subprocess.PIPE, text=True)\n    return _parse_musl_version(proc.stderr)\n\n\ndef platform_tags(archs: Sequence[str]) -> Iterator[str]:\n    \"\"\"Generate musllinux tags compatible to the current platform.\n\n    :param archs: Sequence of compatible architectures.\n        The first one shall be the closest to the actual architecture and be the part of\n        platform tag after the ``linux_`` prefix, e.g. ``x86_64``.\n        The ``linux_`` prefix is assumed as a prerequisite for the current platform to\n        be musllinux-compatible.\n\n    :returns: An iterator of compatible musllinux tags.\n    \"\"\"\n    sys_musl = _get_musl_version(sys.executable)\n    if sys_musl is None:  # Python not dynamically linked against musl.\n        return\n    for arch in archs:\n        for minor in range(sys_musl.minor, -1, -1):\n            yield f\"musllinux_{sys_musl.major}_{minor}_{arch}\"\n\n\nif __name__ == \"__main__\":  # pragma: no cover\n    import sysconfig\n\n    plat = sysconfig.get_platform()\n    assert plat.startswith(\"linux-\"), \"not linux\"\n\n    print(\"plat:\", plat)\n    print(\"musl:\", _get_musl_version(sys.executable))\n    print(\"tags:\", end=\" \")\n    for t in platform_tags(re.sub(r\"[.-]\", \"_\", plat.split(\"-\", 1)[-1])):\n        print(t, end=\"\\n      \")\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/vendored/packaging/_parser.py","size":10347,"sha1":"1157c9f4e715af26ea88c794f8e552fd28afcb05","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"\"\"\"Handwritten parser of dependency specifiers.\n\nThe docstring for each __parse_* function contains EBNF-inspired grammar representing\nthe implementation.\n\"\"\"\n\nimport ast\nfrom typing import Any, List, NamedTuple, Optional, Tuple, Union\n\nfrom ._tokenizer import DEFAULT_RULES, Tokenizer\n\n\nclass Node:\n    def __init__(self, value: str) -> None:\n        self.value = value\n\n    def __str__(self) -> str:\n        return self.value\n\n    def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__}('{self}')>\"\n\n    def serialize(self) -> str:\n        raise NotImplementedError\n\n\nclass Variable(Node):\n    def serialize(self) -> str:\n        return str(self)\n\n\nclass Value(Node):\n    def serialize(self) -> str:\n        return f'\"{self}\"'\n\n\nclass Op(Node):\n    def serialize(self) -> str:\n        return str(self)\n\n\nMarkerVar = Union[Variable, Value]\nMarkerItem = Tuple[MarkerVar, Op, MarkerVar]\n# MarkerAtom = Union[MarkerItem, List[\"MarkerAtom\"]]\n# MarkerList = List[Union[\"MarkerList\", MarkerAtom, str]]\n# mypy does not support recursive type definition\n# https://github.com/python/mypy/issues/731\nMarkerAtom = Any\nMarkerList = List[Any]\n\n\nclass ParsedRequirement(NamedTuple):\n    name: str\n    url: str\n    extras: List[str]\n    specifier: str\n    marker: Optional[MarkerList]\n\n\n# --------------------------------------------------------------------------------------\n# Recursive descent parser for dependency specifier\n# --------------------------------------------------------------------------------------\ndef parse_requirement(source: str) -> ParsedRequirement:\n    return _parse_requirement(Tokenizer(source, rules=DEFAULT_RULES))\n\n\ndef _parse_requirement(tokenizer: Tokenizer) -> ParsedRequirement:\n    \"\"\"\n    requirement = WS? IDENTIFIER WS? extras WS? requirement_details\n    \"\"\"\n    tokenizer.consume(\"WS\")\n\n    name_token = tokenizer.expect(\n        \"IDENTIFIER\", expected=\"package name at the start of dependency specifier\"\n    )\n    name = name_token.text\n    tokenizer.consume(\"WS\")\n\n    extras = _parse_extras(tokenizer)\n    tokenizer.consume(\"WS\")\n\n    url, specifier, marker = _parse_requirement_details(tokenizer)\n    tokenizer.expect(\"END\", expected=\"end of dependency specifier\")\n\n    return ParsedRequirement(name, url, extras, specifier, marker)\n\n\ndef _parse_requirement_details(\n    tokenizer: Tokenizer,\n) -> Tuple[str, str, Optional[MarkerList]]:\n    \"\"\"\n    requirement_details = AT URL (WS requirement_marker?)?\n                        | specifier WS? (requirement_marker)?\n    \"\"\"\n\n    specifier = \"\"\n    url = \"\"\n    marker = None\n\n    if tokenizer.check(\"AT\"):\n        tokenizer.read()\n        tokenizer.consume(\"WS\")\n\n        url_start = tokenizer.position\n        url = tokenizer.expect(\"URL\", expected=\"URL after @\").text\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        tokenizer.expect(\"WS\", expected=\"whitespace after URL\")\n\n        # The input might end after whitespace.\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        marker = _parse_requirement_marker(\n            tokenizer, span_start=url_start, after=\"URL and whitespace\"\n        )\n    else:\n        specifier_start = tokenizer.position\n        specifier = _parse_specifier(tokenizer)\n        tokenizer.consume(\"WS\")\n\n        if tokenizer.check(\"END\", peek=True):\n            return (url, specifier, marker)\n\n        marker = _parse_requirement_marker(\n            tokenizer,\n            span_start=specifier_start,\n            after=(\n                \"version specifier\"\n                if specifier\n                else \"name and no valid version specifier\"\n            ),\n        )\n\n    return (url, specifier, marker)\n\n\ndef _parse_requirement_marker(\n    tokenizer: Tokenizer, *, span_start: int, after: str\n) -> MarkerList:\n    \"\"\"\n    requirement_marker = SEMICOLON marker WS?\n    \"\"\"\n\n    if not tokenizer.check(\"SEMICOLON\"):\n        tokenizer.raise_syntax_error(\n            f\"Expected end or semicolon (after {after})\",\n            span_start=span_start,\n        )\n    tokenizer.read()\n\n    marker = _parse_marker(tokenizer)\n    tokenizer.consume(\"WS\")\n\n    return marker\n\n\ndef _parse_extras(tokenizer: Tokenizer) -> List[str]:\n    \"\"\"\n    extras = (LEFT_BRACKET wsp* extras_list? wsp* RIGHT_BRACKET)?\n    \"\"\"\n    if not tokenizer.check(\"LEFT_BRACKET\", peek=True):\n        return []\n\n    with tokenizer.enclosing_tokens(\n        \"LEFT_BRACKET\",\n        \"RIGHT_BRACKET\",\n        around=\"extras\",\n    ):\n        tokenizer.consume(\"WS\")\n        extras = _parse_extras_list(tokenizer)\n        tokenizer.consume(\"WS\")\n\n    return extras\n\n\ndef _parse_extras_list(tokenizer: Tokenizer) -> List[str]:\n    \"\"\"\n    extras_list = identifier (wsp* ',' wsp* identifier)*\n    \"\"\"\n    extras: List[str] = []\n\n    if not tokenizer.check(\"IDENTIFIER\"):\n        return extras\n\n    extras.append(tokenizer.read().text)\n\n    while True:\n        tokenizer.consume(\"WS\")\n        if tokenizer.check(\"IDENTIFIER\", peek=True):\n            tokenizer.raise_syntax_error(\"Expected comma between extra names\")\n        elif not tokenizer.check(\"COMMA\"):\n            break\n\n        tokenizer.read()\n        tokenizer.consume(\"WS\")\n\n        extra_token = tokenizer.expect(\"IDENTIFIER\", expected=\"extra name after comma\")\n        extras.append(extra_token.text)\n\n    return extras\n\n\ndef _parse_specifier(tokenizer: Tokenizer) -> str:\n    \"\"\"\n    specifier = LEFT_PARENTHESIS WS? version_many WS? RIGHT_PARENTHESIS\n              | WS? version_many WS?\n    \"\"\"\n    with tokenizer.enclosing_tokens(\n        \"LEFT_PARENTHESIS\",\n        \"RIGHT_PARENTHESIS\",\n        around=\"version specifier\",\n    ):\n        tokenizer.consume(\"WS\")\n        parsed_specifiers = _parse_version_many(tokenizer)\n        tokenizer.consume(\"WS\")\n\n    return parsed_specifiers\n\n\ndef _parse_version_many(tokenizer: Tokenizer) -> str:\n    \"\"\"\n    version_many = (SPECIFIER (WS? COMMA WS? SPECIFIER)*)?\n    \"\"\"\n    parsed_specifiers = \"\"\n    while tokenizer.check(\"SPECIFIER\"):\n        span_start = tokenizer.position\n        parsed_specifiers += tokenizer.read().text\n        if tokenizer.check(\"VERSION_PREFIX_TRAIL\", peek=True):\n            tokenizer.raise_syntax_error(\n                \".* suffix can only be used with `==` or `!=` operators\",\n                span_start=span_start,\n                span_end=tokenizer.position + 1,\n            )\n        if tokenizer.check(\"VERSION_LOCAL_LABEL_TRAIL\", peek=True):\n            tokenizer.raise_syntax_error(\n                \"Local version label can only be used with `==` or `!=` operators\",\n                span_start=span_start,\n                span_end=tokenizer.position,\n            )\n        tokenizer.consume(\"WS\")\n        if not tokenizer.check(\"COMMA\"):\n            break\n        parsed_specifiers += tokenizer.read().text\n        tokenizer.consume(\"WS\")\n\n    return parsed_specifiers\n\n\n# --------------------------------------------------------------------------------------\n# Recursive descent parser for marker expression\n# --------------------------------------------------------------------------------------\ndef parse_marker(source: str) -> MarkerList:\n    return _parse_full_marker(Tokenizer(source, rules=DEFAULT_RULES))\n\n\ndef _parse_full_marker(tokenizer: Tokenizer) -> MarkerList:\n    retval = _parse_marker(tokenizer)\n    tokenizer.expect(\"END\", expected=\"end of marker expression\")\n    return retval\n\n\ndef _parse_marker(tokenizer: Tokenizer) -> MarkerList:\n    \"\"\"\n    marker = marker_atom (BOOLOP marker_atom)+\n    \"\"\"\n    expression = [_parse_marker_atom(tokenizer)]\n    while tokenizer.check(\"BOOLOP\"):\n        token = tokenizer.read()\n        expr_right = _parse_marker_atom(tokenizer)\n        expression.extend((token.text, expr_right))\n    return expression\n\n\ndef _parse_marker_atom(tokenizer: Tokenizer) -> MarkerAtom:\n    \"\"\"\n    marker_atom = WS? LEFT_PARENTHESIS WS? marker WS? RIGHT_PARENTHESIS WS?\n                | WS? marker_item WS?\n    \"\"\"\n\n    tokenizer.consume(\"WS\")\n    if tokenizer.check(\"LEFT_PARENTHESIS\", peek=True):\n        with tokenizer.enclosing_tokens(\n            \"LEFT_PARENTHESIS\",\n            \"RIGHT_PARENTHESIS\",\n            around=\"marker expression\",\n        ):\n            tokenizer.consume(\"WS\")\n            marker: MarkerAtom = _parse_marker(tokenizer)\n            tokenizer.consume(\"WS\")\n    else:\n        marker = _parse_marker_item(tokenizer)\n    tokenizer.consume(\"WS\")\n    return marker\n\n\ndef _parse_marker_item(tokenizer: Tokenizer) -> MarkerItem:\n    \"\"\"\n    marker_item = WS? marker_var WS? marker_op WS? marker_var WS?\n    \"\"\"\n    tokenizer.consume(\"WS\")\n    marker_var_left = _parse_marker_var(tokenizer)\n    tokenizer.consume(\"WS\")\n    marker_op = _parse_marker_op(tokenizer)\n    tokenizer.consume(\"WS\")\n    marker_var_right = _parse_marker_var(tokenizer)\n    tokenizer.consume(\"WS\")\n    return (marker_var_left, marker_op, marker_var_right)\n\n\ndef _parse_marker_var(tokenizer: Tokenizer) -> MarkerVar:\n    \"\"\"\n    marker_var = VARIABLE | QUOTED_STRING\n    \"\"\"\n    if tokenizer.check(\"VARIABLE\"):\n        return process_env_var(tokenizer.read().text.replace(\".\", \"_\"))\n    elif tokenizer.check(\"QUOTED_STRING\"):\n        return process_python_str(tokenizer.read().text)\n    else:\n        tokenizer.raise_syntax_error(\n            message=\"Expected a marker variable or quoted string\"\n        )\n\n\ndef process_env_var(env_var: str) -> Variable:\n    if env_var in (\"platform_python_implementation\", \"python_implementation\"):\n        return Variable(\"platform_python_implementation\")\n    else:\n        return Variable(env_var)\n\n\ndef process_python_str(python_str: str) -> Value:\n    value = ast.literal_eval(python_str)\n    return Value(str(value))\n\n\ndef _parse_marker_op(tokenizer: Tokenizer) -> Op:\n    \"\"\"\n    marker_op = IN | NOT IN | OP\n    \"\"\"\n    if tokenizer.check(\"IN\"):\n        tokenizer.read()\n        return Op(\"in\")\n    elif tokenizer.check(\"NOT\"):\n        tokenizer.read()\n        tokenizer.expect(\"WS\", expected=\"whitespace after 'not'\")\n        tokenizer.expect(\"IN\", expected=\"'in' after 'not'\")\n        return Op(\"not in\")\n    elif tokenizer.check(\"OP\"):\n        return Op(tokenizer.read().text)\n    else:\n        return tokenizer.raise_syntax_error(\n            \"Expected marker operator, one of \"\n            \"<=, <, !=, ==, >=, >, ~=, ===, in, not in\"\n        )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/vendored/packaging/_structures.py","size":1431,"sha1":"fe0c3747cf14e696276cb6806c6775503de002b8","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nclass InfinityType:\n    def __repr__(self) -> str:\n        return \"Infinity\"\n\n    def __hash__(self) -> int:\n        return hash(repr(self))\n\n    def __lt__(self, other: object) -> bool:\n        return False\n\n    def __le__(self, other: object) -> bool:\n        return False\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__)\n\n    def __gt__(self, other: object) -> bool:\n        return True\n\n    def __ge__(self, other: object) -> bool:\n        return True\n\n    def __neg__(self: object) -> \"NegativeInfinityType\":\n        return NegativeInfinity\n\n\nInfinity = InfinityType()\n\n\nclass NegativeInfinityType:\n    def __repr__(self) -> str:\n        return \"-Infinity\"\n\n    def __hash__(self) -> int:\n        return hash(repr(self))\n\n    def __lt__(self, other: object) -> bool:\n        return True\n\n    def __le__(self, other: object) -> bool:\n        return True\n\n    def __eq__(self, other: object) -> bool:\n        return isinstance(other, self.__class__)\n\n    def __gt__(self, other: object) -> bool:\n        return False\n\n    def __ge__(self, other: object) -> bool:\n        return False\n\n    def __neg__(self: object) -> InfinityType:\n        return Infinity\n\n\nNegativeInfinity = NegativeInfinityType()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/vendored/packaging/_tokenizer.py","size":5292,"sha1":"7e894dba389a70c4e5e3916705b5525788066a62","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"import contextlib\nimport re\nfrom dataclasses import dataclass\nfrom typing import Dict, Iterator, NoReturn, Optional, Tuple, Union\n\nfrom .specifiers import Specifier\n\n\n@dataclass\nclass Token:\n    name: str\n    text: str\n    position: int\n\n\nclass ParserSyntaxError(Exception):\n    \"\"\"The provided source text could not be parsed correctly.\"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        *,\n        source: str,\n        span: Tuple[int, int],\n    ) -> None:\n        self.span = span\n        self.message = message\n        self.source = source\n\n        super().__init__()\n\n    def __str__(self) -> str:\n        marker = \" \" * self.span[0] + \"~\" * (self.span[1] - self.span[0]) + \"^\"\n        return \"\\n    \".join([self.message, self.source, marker])\n\n\nDEFAULT_RULES: \"Dict[str, Union[str, re.Pattern[str]]]\" = {\n    \"LEFT_PARENTHESIS\": r\"\\(\",\n    \"RIGHT_PARENTHESIS\": r\"\\)\",\n    \"LEFT_BRACKET\": r\"\\[\",\n    \"RIGHT_BRACKET\": r\"\\]\",\n    \"SEMICOLON\": r\";\",\n    \"COMMA\": r\",\",\n    \"QUOTED_STRING\": re.compile(\n        r\"\"\"\n            (\n                ('[^']*')\n                |\n                (\"[^\"]*\")\n            )\n        \"\"\",\n        re.VERBOSE,\n    ),\n    \"OP\": r\"(===|==|~=|!=|<=|>=|<|>)\",\n    \"BOOLOP\": r\"\\b(or|and)\\b\",\n    \"IN\": r\"\\bin\\b\",\n    \"NOT\": r\"\\bnot\\b\",\n    \"VARIABLE\": re.compile(\n        r\"\"\"\n            \\b(\n                python_version\n                |python_full_version\n                |os[._]name\n                |sys[._]platform\n                |platform_(release|system)\n                |platform[._](version|machine|python_implementation)\n                |python_implementation\n                |implementation_(name|version)\n                |extra\n            )\\b\n        \"\"\",\n        re.VERBOSE,\n    ),\n    \"SPECIFIER\": re.compile(\n        Specifier._operator_regex_str + Specifier._version_regex_str,\n        re.VERBOSE | re.IGNORECASE,\n    ),\n    \"AT\": r\"\\@\",\n    \"URL\": r\"[^ \\t]+\",\n    \"IDENTIFIER\": r\"\\b[a-zA-Z0-9][a-zA-Z0-9._-]*\\b\",\n    \"VERSION_PREFIX_TRAIL\": r\"\\.\\*\",\n    \"VERSION_LOCAL_LABEL_TRAIL\": r\"\\+[a-z0-9]+(?:[-_\\.][a-z0-9]+)*\",\n    \"WS\": r\"[ \\t]+\",\n    \"END\": r\"$\",\n}\n\n\nclass Tokenizer:\n    \"\"\"Context-sensitive token parsing.\n\n    Provides methods to examine the input stream to check whether the next token\n    matches.\n    \"\"\"\n\n    def __init__(\n        self,\n        source: str,\n        *,\n        rules: \"Dict[str, Union[str, re.Pattern[str]]]\",\n    ) -> None:\n        self.source = source\n        self.rules: Dict[str, re.Pattern[str]] = {\n            name: re.compile(pattern) for name, pattern in rules.items()\n        }\n        self.next_token: Optional[Token] = None\n        self.position = 0\n\n    def consume(self, name: str) -> None:\n        \"\"\"Move beyond provided token name, if at current position.\"\"\"\n        if self.check(name):\n            self.read()\n\n    def check(self, name: str, *, peek: bool = False) -> bool:\n        \"\"\"Check whether the next token has the provided name.\n\n        By default, if the check succeeds, the token *must* be read before\n        another check. If `peek` is set to `True`, the token is not loaded and\n        would need to be checked again.\n        \"\"\"\n        assert (\n            self.next_token is None\n        ), f\"Cannot check for {name!r}, already have {self.next_token!r}\"\n        assert name in self.rules, f\"Unknown token name: {name!r}\"\n\n        expression = self.rules[name]\n\n        match = expression.match(self.source, self.position)\n        if match is None:\n            return False\n        if not peek:\n            self.next_token = Token(name, match[0], self.position)\n        return True\n\n    def expect(self, name: str, *, expected: str) -> Token:\n        \"\"\"Expect a certain token name next, failing with a syntax error otherwise.\n\n        The token is *not* read.\n        \"\"\"\n        if not self.check(name):\n            raise self.raise_syntax_error(f\"Expected {expected}\")\n        return self.read()\n\n    def read(self) -> Token:\n        \"\"\"Consume the next token and return it.\"\"\"\n        token = self.next_token\n        assert token is not None\n\n        self.position += len(token.text)\n        self.next_token = None\n\n        return token\n\n    def raise_syntax_error(\n        self,\n        message: str,\n        *,\n        span_start: Optional[int] = None,\n        span_end: Optional[int] = None,\n    ) -> NoReturn:\n        \"\"\"Raise ParserSyntaxError at the given position.\"\"\"\n        span = (\n            self.position if span_start is None else span_start,\n            self.position if span_end is None else span_end,\n        )\n        raise ParserSyntaxError(\n            message,\n            source=self.source,\n            span=span,\n        )\n\n    @contextlib.contextmanager\n    def enclosing_tokens(\n        self, open_token: str, close_token: str, *, around: str\n    ) -> Iterator[None]:\n        if self.check(open_token):\n            open_position = self.position\n            self.read()\n        else:\n            open_position = None\n\n        yield\n\n        if open_position is None:\n            return\n\n        if not self.check(close_token):\n            self.raise_syntax_error(\n                f\"Expected matching {close_token} for {open_token}, after {around}\",\n                span_start=open_position,\n            )\n\n        self.read()\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/vendored/packaging/markers.py","size":8232,"sha1":"bcbf9f914c03309d2e07d05b0e4d277d13b11411","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport operator\nimport os\nimport platform\nimport sys\nfrom typing import Any, Callable, Dict, List, Optional, Tuple, Union\n\nfrom ._parser import (\n    MarkerAtom,\n    MarkerList,\n    Op,\n    Value,\n    Variable,\n)\nfrom ._parser import (\n    parse_marker as _parse_marker,\n)\nfrom ._tokenizer import ParserSyntaxError\nfrom .specifiers import InvalidSpecifier, Specifier\nfrom .utils import canonicalize_name\n\n__all__ = [\n    \"InvalidMarker\",\n    \"UndefinedComparison\",\n    \"UndefinedEnvironmentName\",\n    \"Marker\",\n    \"default_environment\",\n]\n\nOperator = Callable[[str, str], bool]\n\n\nclass InvalidMarker(ValueError):\n    \"\"\"\n    An invalid marker was found, users should refer to PEP 508.\n    \"\"\"\n\n\nclass UndefinedComparison(ValueError):\n    \"\"\"\n    An invalid operation was attempted on a value that doesn't support it.\n    \"\"\"\n\n\nclass UndefinedEnvironmentName(ValueError):\n    \"\"\"\n    A name was attempted to be used that does not exist inside of the\n    environment.\n    \"\"\"\n\n\ndef _normalize_extra_values(results: Any) -> Any:\n    \"\"\"\n    Normalize extra values.\n    \"\"\"\n    if isinstance(results[0], tuple):\n        lhs, op, rhs = results[0]\n        if isinstance(lhs, Variable) and lhs.value == \"extra\":\n            normalized_extra = canonicalize_name(rhs.value)\n            rhs = Value(normalized_extra)\n        elif isinstance(rhs, Variable) and rhs.value == \"extra\":\n            normalized_extra = canonicalize_name(lhs.value)\n            lhs = Value(normalized_extra)\n        results[0] = lhs, op, rhs\n    return results\n\n\ndef _format_marker(\n    marker: Union[List[str], MarkerAtom, str], first: Optional[bool] = True\n) -> str:\n    assert isinstance(marker, (list, tuple, str))\n\n    # Sometimes we have a structure like [[...]] which is a single item list\n    # where the single item is itself it's own list. In that case we want skip\n    # the rest of this function so that we don't get extraneous () on the\n    # outside.\n    if (\n        isinstance(marker, list)\n        and len(marker) == 1\n        and isinstance(marker[0], (list, tuple))\n    ):\n        return _format_marker(marker[0])\n\n    if isinstance(marker, list):\n        inner = (_format_marker(m, first=False) for m in marker)\n        if first:\n            return \" \".join(inner)\n        else:\n            return \"(\" + \" \".join(inner) + \")\"\n    elif isinstance(marker, tuple):\n        return \" \".join([m.serialize() for m in marker])\n    else:\n        return marker\n\n\n_operators: Dict[str, Operator] = {\n    \"in\": lambda lhs, rhs: lhs in rhs,\n    \"not in\": lambda lhs, rhs: lhs not in rhs,\n    \"<\": operator.lt,\n    \"<=\": operator.le,\n    \"==\": operator.eq,\n    \"!=\": operator.ne,\n    \">=\": operator.ge,\n    \">\": operator.gt,\n}\n\n\ndef _eval_op(lhs: str, op: Op, rhs: str) -> bool:\n    try:\n        spec = Specifier(\"\".join([op.serialize(), rhs]))\n    except InvalidSpecifier:\n        pass\n    else:\n        return spec.contains(lhs, prereleases=True)\n\n    oper: Optional[Operator] = _operators.get(op.serialize())\n    if oper is None:\n        raise UndefinedComparison(f\"Undefined {op!r} on {lhs!r} and {rhs!r}.\")\n\n    return oper(lhs, rhs)\n\n\ndef _normalize(*values: str, key: str) -> Tuple[str, ...]:\n    # PEP 685 – Comparison of extra names for optional distribution dependencies\n    # https://peps.python.org/pep-0685/\n    # > When comparing extra names, tools MUST normalize the names being\n    # > compared using the semantics outlined in PEP 503 for names\n    if key == \"extra\":\n        return tuple(canonicalize_name(v) for v in values)\n\n    # other environment markers don't have such standards\n    return values\n\n\ndef _evaluate_markers(markers: MarkerList, environment: Dict[str, str]) -> bool:\n    groups: List[List[bool]] = [[]]\n\n    for marker in markers:\n        assert isinstance(marker, (list, tuple, str))\n\n        if isinstance(marker, list):\n            groups[-1].append(_evaluate_markers(marker, environment))\n        elif isinstance(marker, tuple):\n            lhs, op, rhs = marker\n\n            if isinstance(lhs, Variable):\n                environment_key = lhs.value\n                lhs_value = environment[environment_key]\n                rhs_value = rhs.value\n            else:\n                lhs_value = lhs.value\n                environment_key = rhs.value\n                rhs_value = environment[environment_key]\n\n            lhs_value, rhs_value = _normalize(lhs_value, rhs_value, key=environment_key)\n            groups[-1].append(_eval_op(lhs_value, op, rhs_value))\n        else:\n            assert marker in [\"and\", \"or\"]\n            if marker == \"or\":\n                groups.append([])\n\n    return any(all(item) for item in groups)\n\n\ndef format_full_version(info: \"sys._version_info\") -> str:\n    version = \"{0.major}.{0.minor}.{0.micro}\".format(info)\n    kind = info.releaselevel\n    if kind != \"final\":\n        version += kind[0] + str(info.serial)\n    return version\n\n\ndef default_environment() -> Dict[str, str]:\n    iver = format_full_version(sys.implementation.version)\n    implementation_name = sys.implementation.name\n    return {\n        \"implementation_name\": implementation_name,\n        \"implementation_version\": iver,\n        \"os_name\": os.name,\n        \"platform_machine\": platform.machine(),\n        \"platform_release\": platform.release(),\n        \"platform_system\": platform.system(),\n        \"platform_version\": platform.version(),\n        \"python_full_version\": platform.python_version(),\n        \"platform_python_implementation\": platform.python_implementation(),\n        \"python_version\": \".\".join(platform.python_version_tuple()[:2]),\n        \"sys_platform\": sys.platform,\n    }\n\n\nclass Marker:\n    def __init__(self, marker: str) -> None:\n        # Note: We create a Marker object without calling this constructor in\n        #       packaging.requirements.Requirement. If any additional logic is\n        #       added here, make sure to mirror/adapt Requirement.\n        try:\n            self._markers = _normalize_extra_values(_parse_marker(marker))\n            # The attribute `_markers` can be described in terms of a recursive type:\n            # MarkerList = List[Union[Tuple[Node, ...], str, MarkerList]]\n            #\n            # For example, the following expression:\n            # python_version > \"3.6\" or (python_version == \"3.6\" and os_name == \"unix\")\n            #\n            # is parsed into:\n            # [\n            #     (<Variable('python_version')>, <Op('>')>, <Value('3.6')>),\n            #     'and',\n            #     [\n            #         (<Variable('python_version')>, <Op('==')>, <Value('3.6')>),\n            #         'or',\n            #         (<Variable('os_name')>, <Op('==')>, <Value('unix')>)\n            #     ]\n            # ]\n        except ParserSyntaxError as e:\n            raise InvalidMarker(str(e)) from e\n\n    def __str__(self) -> str:\n        return _format_marker(self._markers)\n\n    def __repr__(self) -> str:\n        return f\"<Marker('{self}')>\"\n\n    def __hash__(self) -> int:\n        return hash((self.__class__.__name__, str(self)))\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, Marker):\n            return NotImplemented\n\n        return str(self) == str(other)\n\n    def evaluate(self, environment: Optional[Dict[str, str]] = None) -> bool:\n        \"\"\"Evaluate a marker.\n\n        Return the boolean from evaluating the given marker against the\n        environment. environment is an optional argument to override all or\n        part of the determined environment.\n\n        The environment is determined from the current Python process.\n        \"\"\"\n        current_environment = default_environment()\n        current_environment[\"extra\"] = \"\"\n        if environment is not None:\n            current_environment.update(environment)\n            # The API used to allow setting extra to None. We need to handle this\n            # case for backwards compatibility.\n            if current_environment[\"extra\"] is None:\n                current_environment[\"extra\"] = \"\"\n\n        return _evaluate_markers(self._markers, current_environment)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/vendored/packaging/requirements.py","size":2933,"sha1":"fdea96ee084c035525face93abe03e82d55a8f8e","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom typing import Any, Iterator, Optional, Set\n\nfrom ._parser import parse_requirement as _parse_requirement\nfrom ._tokenizer import ParserSyntaxError\nfrom .markers import Marker, _normalize_extra_values\nfrom .specifiers import SpecifierSet\nfrom .utils import canonicalize_name\n\n\nclass InvalidRequirement(ValueError):\n    \"\"\"\n    An invalid requirement was found, users should refer to PEP 508.\n    \"\"\"\n\n\nclass Requirement:\n    \"\"\"Parse a requirement.\n\n    Parse a given requirement string into its parts, such as name, specifier,\n    URL, and extras. Raises InvalidRequirement on a badly-formed requirement\n    string.\n    \"\"\"\n\n    # TODO: Can we test whether something is contained within a requirement?\n    #       If so how do we do that? Do we need to test against the _name_ of\n    #       the thing as well as the version? What about the markers?\n    # TODO: Can we normalize the name and extra name?\n\n    def __init__(self, requirement_string: str) -> None:\n        try:\n            parsed = _parse_requirement(requirement_string)\n        except ParserSyntaxError as e:\n            raise InvalidRequirement(str(e)) from e\n\n        self.name: str = parsed.name\n        self.url: Optional[str] = parsed.url or None\n        self.extras: Set[str] = set(parsed.extras or [])\n        self.specifier: SpecifierSet = SpecifierSet(parsed.specifier)\n        self.marker: Optional[Marker] = None\n        if parsed.marker is not None:\n            self.marker = Marker.__new__(Marker)\n            self.marker._markers = _normalize_extra_values(parsed.marker)\n\n    def _iter_parts(self, name: str) -> Iterator[str]:\n        yield name\n\n        if self.extras:\n            formatted_extras = \",\".join(sorted(self.extras))\n            yield f\"[{formatted_extras}]\"\n\n        if self.specifier:\n            yield str(self.specifier)\n\n        if self.url:\n            yield f\"@ {self.url}\"\n            if self.marker:\n                yield \" \"\n\n        if self.marker:\n            yield f\"; {self.marker}\"\n\n    def __str__(self) -> str:\n        return \"\".join(self._iter_parts(self.name))\n\n    def __repr__(self) -> str:\n        return f\"<Requirement('{self}')>\"\n\n    def __hash__(self) -> int:\n        return hash(\n            (\n                self.__class__.__name__,\n                *self._iter_parts(canonicalize_name(self.name)),\n            )\n        )\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, Requirement):\n            return NotImplemented\n\n        return (\n            canonicalize_name(self.name) == canonicalize_name(other.name)\n            and self.extras == other.extras\n            and self.specifier == other.specifier\n            and self.url == other.url\n            and self.marker == other.marker\n        )\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/vendored/packaging/specifiers.py","size":39778,"sha1":"dcbbddd7b97bcbeefa4e78ad4654cd4c7c2c1c1a","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\"\"\"\n.. testsetup::\n\n    from packaging.specifiers import Specifier, SpecifierSet, InvalidSpecifier\n    from packaging.version import Version\n\"\"\"\n\nimport abc\nimport itertools\nimport re\nfrom typing import Callable, Iterable, Iterator, List, Optional, Tuple, TypeVar, Union\n\nfrom .utils import canonicalize_version\nfrom .version import Version\n\nUnparsedVersion = Union[Version, str]\nUnparsedVersionVar = TypeVar(\"UnparsedVersionVar\", bound=UnparsedVersion)\nCallableOperator = Callable[[Version, str], bool]\n\n\ndef _coerce_version(version: UnparsedVersion) -> Version:\n    if not isinstance(version, Version):\n        version = Version(version)\n    return version\n\n\nclass InvalidSpecifier(ValueError):\n    \"\"\"\n    Raised when attempting to create a :class:`Specifier` with a specifier\n    string that is invalid.\n\n    >>> Specifier(\"lolwat\")\n    Traceback (most recent call last):\n        ...\n    packaging.specifiers.InvalidSpecifier: Invalid specifier: 'lolwat'\n    \"\"\"\n\n\nclass BaseSpecifier(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __str__(self) -> str:\n        \"\"\"\n        Returns the str representation of this Specifier-like object. This\n        should be representative of the Specifier itself.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __hash__(self) -> int:\n        \"\"\"\n        Returns a hash value for this Specifier-like object.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Returns a boolean representing whether or not the two Specifier-like\n        objects are equal.\n\n        :param other: The other object to check against.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def prereleases(self) -> Optional[bool]:\n        \"\"\"Whether or not pre-releases as a whole are allowed.\n\n        This can be set to either ``True`` or ``False`` to explicitly enable or disable\n        prereleases or it can be set to ``None`` (the default) to use default semantics.\n        \"\"\"\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        \"\"\"Setter for :attr:`prereleases`.\n\n        :param value: The value to set.\n        \"\"\"\n\n    @abc.abstractmethod\n    def contains(self, item: str, prereleases: Optional[bool] = None) -> bool:\n        \"\"\"\n        Determines if the given item is contained within this specifier.\n        \"\"\"\n\n    @abc.abstractmethod\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: Optional[bool] = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"\n        Takes an iterable of items and filters them so that only items which\n        are contained within this specifier are allowed in it.\n        \"\"\"\n\n\nclass Specifier(BaseSpecifier):\n    \"\"\"This class abstracts handling of version specifiers.\n\n    .. tip::\n\n        It is generally not required to instantiate this manually. You should instead\n        prefer to work with :class:`SpecifierSet` instead, which can parse\n        comma-separated version specifiers (which is what package metadata contains).\n    \"\"\"\n\n    _operator_regex_str = r\"\"\"\n        (?P<operator>(~=|==|!=|<=|>=|<|>|===))\n        \"\"\"\n    _version_regex_str = r\"\"\"\n        (?P<version>\n            (?:\n                # The identity operators allow for an escape hatch that will\n                # do an exact string match of the version you wish to install.\n                # This will not be parsed by PEP 440 and we cannot determine\n                # any semantic meaning from it. This operator is discouraged\n                # but included entirely as an escape hatch.\n                (?<====)  # Only match for the identity operator\n                \\s*\n                [^\\s;)]*  # The arbitrary version can be just about anything,\n                          # we match everything except for whitespace, a\n                          # semi-colon for marker support, and a closing paren\n                          # since versions can be enclosed in them.\n            )\n            |\n            (?:\n                # The (non)equality operators allow for wild card and local\n                # versions to be specified so we have to define these two\n                # operators separately to enable that.\n                (?<===|!=)            # Only match for equals and not equals\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)*   # release\n\n                # You cannot use a wild card and a pre-release, post-release, a dev or\n                # local version together so group them with a | and make them optional.\n                (?:\n                    \\.\\*  # Wild card syntax of .*\n                    |\n                    (?:                                  # pre release\n                        [-_\\.]?\n                        (alpha|beta|preview|pre|a|b|c|rc)\n                        [-_\\.]?\n                        [0-9]*\n                    )?\n                    (?:                                  # post release\n                        (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                    )?\n                    (?:[-_\\.]?dev[-_\\.]?[0-9]*)?         # dev release\n                    (?:\\+[a-z0-9]+(?:[-_\\.][a-z0-9]+)*)? # local\n                )?\n            )\n            |\n            (?:\n                # The compatible operator requires at least two digits in the\n                # release segment.\n                (?<=~=)               # Only match for the compatible operator\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)+   # release  (We have a + instead of a *)\n                (?:                   # pre release\n                    [-_\\.]?\n                    (alpha|beta|preview|pre|a|b|c|rc)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n                (?:[-_\\.]?dev[-_\\.]?[0-9]*)?          # dev release\n            )\n            |\n            (?:\n                # All other operators only allow a sub set of what the\n                # (non)equality operators do. Specifically they do not allow\n                # local versions to be specified nor do they allow the prefix\n                # matching wild cards.\n                (?<!==|!=|~=)         # We have special cases for these\n                                      # operators so we want to make sure they\n                                      # don't match here.\n\n                \\s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\\.[0-9]+)*   # release\n                (?:                   # pre release\n                    [-_\\.]?\n                    (alpha|beta|preview|pre|a|b|c|rc)\n                    [-_\\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\\.]?(post|rev|r)[-_\\.]?[0-9]*)\n                )?\n                (?:[-_\\.]?dev[-_\\.]?[0-9]*)?          # dev release\n            )\n        )\n        \"\"\"\n\n    _regex = re.compile(\n        r\"^\\s*\" + _operator_regex_str + _version_regex_str + r\"\\s*$\",\n        re.VERBOSE | re.IGNORECASE,\n    )\n\n    _operators = {\n        \"~=\": \"compatible\",\n        \"==\": \"equal\",\n        \"!=\": \"not_equal\",\n        \"<=\": \"less_than_equal\",\n        \">=\": \"greater_than_equal\",\n        \"<\": \"less_than\",\n        \">\": \"greater_than\",\n        \"===\": \"arbitrary\",\n    }\n\n    def __init__(self, spec: str = \"\", prereleases: Optional[bool] = None) -> None:\n        \"\"\"Initialize a Specifier instance.\n\n        :param spec:\n            The string representation of a specifier which will be parsed and\n            normalized before use.\n        :param prereleases:\n            This tells the specifier if it should accept prerelease versions if\n            applicable or not. The default of ``None`` will autodetect it from the\n            given specifiers.\n        :raises InvalidSpecifier:\n            If the given specifier is invalid (i.e. bad syntax).\n        \"\"\"\n        match = self._regex.search(spec)\n        if not match:\n            raise InvalidSpecifier(f\"Invalid specifier: '{spec}'\")\n\n        self._spec: Tuple[str, str] = (\n            match.group(\"operator\").strip(),\n            match.group(\"version\").strip(),\n        )\n\n        # Store whether or not this Specifier should accept prereleases\n        self._prereleases = prereleases\n\n    # https://github.com/python/mypy/pull/13475#pullrequestreview-1079784515\n    @property  # type: ignore[override]\n    def prereleases(self) -> bool:\n        # If there is an explicit prereleases set for this, then we'll just\n        # blindly use that.\n        if self._prereleases is not None:\n            return self._prereleases\n\n        # Look at all of our specifiers and determine if they are inclusive\n        # operators, and if they are if they are including an explicit\n        # prerelease.\n        operator, version = self._spec\n        if operator in [\"==\", \">=\", \"<=\", \"~=\", \"===\"]:\n            # The == specifier can include a trailing .*, if it does we\n            # want to remove before parsing.\n            if operator == \"==\" and version.endswith(\".*\"):\n                version = version[:-2]\n\n            # Parse the version, and if it is a pre-release than this\n            # specifier allows pre-releases.\n            if Version(version).is_prerelease:\n                return True\n\n        return False\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        self._prereleases = value\n\n    @property\n    def operator(self) -> str:\n        \"\"\"The operator of this specifier.\n\n        >>> Specifier(\"==1.2.3\").operator\n        '=='\n        \"\"\"\n        return self._spec[0]\n\n    @property\n    def version(self) -> str:\n        \"\"\"The version of this specifier.\n\n        >>> Specifier(\"==1.2.3\").version\n        '1.2.3'\n        \"\"\"\n        return self._spec[1]\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the Specifier that shows all internal state.\n\n        >>> Specifier('>=1.0.0')\n        <Specifier('>=1.0.0')>\n        >>> Specifier('>=1.0.0', prereleases=False)\n        <Specifier('>=1.0.0', prereleases=False)>\n        >>> Specifier('>=1.0.0', prereleases=True)\n        <Specifier('>=1.0.0', prereleases=True)>\n        \"\"\"\n        pre = (\n            f\", prereleases={self.prereleases!r}\"\n            if self._prereleases is not None\n            else \"\"\n        )\n\n        return f\"<{self.__class__.__name__}({str(self)!r}{pre})>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the Specifier that can be round-tripped.\n\n        >>> str(Specifier('>=1.0.0'))\n        '>=1.0.0'\n        >>> str(Specifier('>=1.0.0', prereleases=False))\n        '>=1.0.0'\n        \"\"\"\n        return \"{}{}\".format(*self._spec)\n\n    @property\n    def _canonical_spec(self) -> Tuple[str, str]:\n        canonical_version = canonicalize_version(\n            self._spec[1],\n            strip_trailing_zero=(self._spec[0] != \"~=\"),\n        )\n        return self._spec[0], canonical_version\n\n    def __hash__(self) -> int:\n        return hash(self._canonical_spec)\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Whether or not the two Specifier-like objects are equal.\n\n        :param other: The other object to check against.\n\n        The value of :attr:`prereleases` is ignored.\n\n        >>> Specifier(\"==1.2.3\") == Specifier(\"== 1.2.3.0\")\n        True\n        >>> (Specifier(\"==1.2.3\", prereleases=False) ==\n        ...  Specifier(\"==1.2.3\", prereleases=True))\n        True\n        >>> Specifier(\"==1.2.3\") == \"==1.2.3\"\n        True\n        >>> Specifier(\"==1.2.3\") == Specifier(\"==1.2.4\")\n        False\n        >>> Specifier(\"==1.2.3\") == Specifier(\"~=1.2.3\")\n        False\n        \"\"\"\n        if isinstance(other, str):\n            try:\n                other = self.__class__(str(other))\n            except InvalidSpecifier:\n                return NotImplemented\n        elif not isinstance(other, self.__class__):\n            return NotImplemented\n\n        return self._canonical_spec == other._canonical_spec\n\n    def _get_operator(self, op: str) -> CallableOperator:\n        operator_callable: CallableOperator = getattr(\n            self, f\"_compare_{self._operators[op]}\"\n        )\n        return operator_callable\n\n    def _compare_compatible(self, prospective: Version, spec: str) -> bool:\n        # Compatible releases have an equivalent combination of >= and ==. That\n        # is that ~=2.2 is equivalent to >=2.2,==2.*. This allows us to\n        # implement this in terms of the other specifiers instead of\n        # implementing it ourselves. The only thing we need to do is construct\n        # the other specifiers.\n\n        # We want everything but the last item in the version, but we want to\n        # ignore suffix segments.\n        prefix = _version_join(\n            list(itertools.takewhile(_is_not_suffix, _version_split(spec)))[:-1]\n        )\n\n        # Add the prefix notation to the end of our string\n        prefix += \".*\"\n\n        return self._get_operator(\">=\")(prospective, spec) and self._get_operator(\"==\")(\n            prospective, prefix\n        )\n\n    def _compare_equal(self, prospective: Version, spec: str) -> bool:\n        # We need special logic to handle prefix matching\n        if spec.endswith(\".*\"):\n            # In the case of prefix matching we want to ignore local segment.\n            normalized_prospective = canonicalize_version(\n                prospective.public, strip_trailing_zero=False\n            )\n            # Get the normalized version string ignoring the trailing .*\n            normalized_spec = canonicalize_version(spec[:-2], strip_trailing_zero=False)\n            # Split the spec out by bangs and dots, and pretend that there is\n            # an implicit dot in between a release segment and a pre-release segment.\n            split_spec = _version_split(normalized_spec)\n\n            # Split the prospective version out by bangs and dots, and pretend\n            # that there is an implicit dot in between a release segment and\n            # a pre-release segment.\n            split_prospective = _version_split(normalized_prospective)\n\n            # 0-pad the prospective version before shortening it to get the correct\n            # shortened version.\n            padded_prospective, _ = _pad_version(split_prospective, split_spec)\n\n            # Shorten the prospective version to be the same length as the spec\n            # so that we can determine if the specifier is a prefix of the\n            # prospective version or not.\n            shortened_prospective = padded_prospective[: len(split_spec)]\n\n            return shortened_prospective == split_spec\n        else:\n            # Convert our spec string into a Version\n            spec_version = Version(spec)\n\n            # If the specifier does not have a local segment, then we want to\n            # act as if the prospective version also does not have a local\n            # segment.\n            if not spec_version.local:\n                prospective = Version(prospective.public)\n\n            return prospective == spec_version\n\n    def _compare_not_equal(self, prospective: Version, spec: str) -> bool:\n        return not self._compare_equal(prospective, spec)\n\n    def _compare_less_than_equal(self, prospective: Version, spec: str) -> bool:\n        # NB: Local version identifiers are NOT permitted in the version\n        # specifier, so local version labels can be universally removed from\n        # the prospective version.\n        return Version(prospective.public) <= Version(spec)\n\n    def _compare_greater_than_equal(self, prospective: Version, spec: str) -> bool:\n        # NB: Local version identifiers are NOT permitted in the version\n        # specifier, so local version labels can be universally removed from\n        # the prospective version.\n        return Version(prospective.public) >= Version(spec)\n\n    def _compare_less_than(self, prospective: Version, spec_str: str) -> bool:\n        # Convert our spec to a Version instance, since we'll want to work with\n        # it as a version.\n        spec = Version(spec_str)\n\n        # Check to see if the prospective version is less than the spec\n        # version. If it's not we can short circuit and just return False now\n        # instead of doing extra unneeded work.\n        if not prospective < spec:\n            return False\n\n        # This special case is here so that, unless the specifier itself\n        # includes is a pre-release version, that we do not accept pre-release\n        # versions for the version mentioned in the specifier (e.g. <3.1 should\n        # not match 3.1.dev0, but should match 3.0.dev0).\n        if not spec.is_prerelease and prospective.is_prerelease:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # If we've gotten to here, it means that prospective version is both\n        # less than the spec version *and* it's not a pre-release of the same\n        # version in the spec.\n        return True\n\n    def _compare_greater_than(self, prospective: Version, spec_str: str) -> bool:\n        # Convert our spec to a Version instance, since we'll want to work with\n        # it as a version.\n        spec = Version(spec_str)\n\n        # Check to see if the prospective version is greater than the spec\n        # version. If it's not we can short circuit and just return False now\n        # instead of doing extra unneeded work.\n        if not prospective > spec:\n            return False\n\n        # This special case is here so that, unless the specifier itself\n        # includes is a post-release version, that we do not accept\n        # post-release versions for the version mentioned in the specifier\n        # (e.g. >3.1 should not match 3.0.post0, but should match 3.2.post0).\n        if not spec.is_postrelease and prospective.is_postrelease:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # Ensure that we do not allow a local version of the version mentioned\n        # in the specifier, which is technically greater than, to match.\n        if prospective.local is not None:\n            if Version(prospective.base_version) == Version(spec.base_version):\n                return False\n\n        # If we've gotten to here, it means that prospective version is both\n        # greater than the spec version *and* it's not a pre-release of the\n        # same version in the spec.\n        return True\n\n    def _compare_arbitrary(self, prospective: Version, spec: str) -> bool:\n        return str(prospective).lower() == str(spec).lower()\n\n    def __contains__(self, item: Union[str, Version]) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item: The item to check for.\n\n        This is used for the ``in`` operator and behaves the same as\n        :meth:`contains` with no ``prereleases`` argument passed.\n\n        >>> \"1.2.3\" in Specifier(\">=1.2.3\")\n        True\n        >>> Version(\"1.2.3\") in Specifier(\">=1.2.3\")\n        True\n        >>> \"1.0.0\" in Specifier(\">=1.2.3\")\n        False\n        >>> \"1.3.0a1\" in Specifier(\">=1.2.3\")\n        False\n        >>> \"1.3.0a1\" in Specifier(\">=1.2.3\", prereleases=True)\n        True\n        \"\"\"\n        return self.contains(item)\n\n    def contains(\n        self, item: UnparsedVersion, prereleases: Optional[bool] = None\n    ) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item:\n            The item to check for, which can be a version string or a\n            :class:`Version` instance.\n        :param prereleases:\n            Whether or not to match prereleases with this Specifier. If set to\n            ``None`` (the default), it uses :attr:`prereleases` to determine\n            whether or not prereleases are allowed.\n\n        >>> Specifier(\">=1.2.3\").contains(\"1.2.3\")\n        True\n        >>> Specifier(\">=1.2.3\").contains(Version(\"1.2.3\"))\n        True\n        >>> Specifier(\">=1.2.3\").contains(\"1.0.0\")\n        False\n        >>> Specifier(\">=1.2.3\").contains(\"1.3.0a1\")\n        False\n        >>> Specifier(\">=1.2.3\", prereleases=True).contains(\"1.3.0a1\")\n        True\n        >>> Specifier(\">=1.2.3\").contains(\"1.3.0a1\", prereleases=True)\n        True\n        \"\"\"\n\n        # Determine if prereleases are to be allowed or not.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # Normalize item to a Version, this allows us to have a shortcut for\n        # \"2.0\" in Specifier(\">=2\")\n        normalized_item = _coerce_version(item)\n\n        # Determine if we should be supporting prereleases in this specifier\n        # or not, if we do not support prereleases than we can short circuit\n        # logic if this version is a prereleases.\n        if normalized_item.is_prerelease and not prereleases:\n            return False\n\n        # Actually do the comparison to determine if this item is contained\n        # within this Specifier or not.\n        operator_callable: CallableOperator = self._get_operator(self.operator)\n        return operator_callable(normalized_item, self.version)\n\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: Optional[bool] = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"Filter items in the given iterable, that match the specifier.\n\n        :param iterable:\n            An iterable that can contain version strings and :class:`Version` instances.\n            The items in the iterable will be filtered according to the specifier.\n        :param prereleases:\n            Whether or not to allow prereleases in the returned iterator. If set to\n            ``None`` (the default), it will be intelligently decide whether to allow\n            prereleases or not (based on the :attr:`prereleases` attribute, and\n            whether the only versions matching are prereleases).\n\n        This method is smarter than just ``filter(Specifier().contains, [...])``\n        because it implements the rule from :pep:`440` that a prerelease item\n        SHOULD be accepted if no other versions match the given specifier.\n\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.2.3\", \"1.3\", Version(\"1.4\")]))\n        ['1.2.3', '1.3', <Version('1.4')>]\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.2\", \"1.5a1\"]))\n        ['1.5a1']\n        >>> list(Specifier(\">=1.2.3\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        >>> list(Specifier(\">=1.2.3\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n        \"\"\"\n\n        yielded = False\n        found_prereleases = []\n\n        kw = {\"prereleases\": prereleases if prereleases is not None else True}\n\n        # Attempt to iterate over all the values in the iterable and if any of\n        # them match, yield them.\n        for version in iterable:\n            parsed_version = _coerce_version(version)\n\n            if self.contains(parsed_version, **kw):\n                # If our version is a prerelease, and we were not set to allow\n                # prereleases, then we'll store it for later in case nothing\n                # else matches this specifier.\n                if parsed_version.is_prerelease and not (\n                    prereleases or self.prereleases\n                ):\n                    found_prereleases.append(version)\n                # Either this is not a prerelease, or we should have been\n                # accepting prereleases from the beginning.\n                else:\n                    yielded = True\n                    yield version\n\n        # Now that we've iterated over everything, determine if we've yielded\n        # any values, and if we have not and we have any prereleases stored up\n        # then we will go ahead and yield the prereleases.\n        if not yielded and found_prereleases:\n            for version in found_prereleases:\n                yield version\n\n\n_prefix_regex = re.compile(r\"^([0-9]+)((?:a|b|c|rc)[0-9]+)$\")\n\n\ndef _version_split(version: str) -> List[str]:\n    \"\"\"Split version into components.\n\n    The split components are intended for version comparison. The logic does\n    not attempt to retain the original version string, so joining the\n    components back with :func:`_version_join` may not produce the original\n    version string.\n    \"\"\"\n    result: List[str] = []\n\n    epoch, _, rest = version.rpartition(\"!\")\n    result.append(epoch or \"0\")\n\n    for item in rest.split(\".\"):\n        match = _prefix_regex.search(item)\n        if match:\n            result.extend(match.groups())\n        else:\n            result.append(item)\n    return result\n\n\ndef _version_join(components: List[str]) -> str:\n    \"\"\"Join split version components into a version string.\n\n    This function assumes the input came from :func:`_version_split`, where the\n    first component must be the epoch (either empty or numeric), and all other\n    components numeric.\n    \"\"\"\n    epoch, *rest = components\n    return f\"{epoch}!{'.'.join(rest)}\"\n\n\ndef _is_not_suffix(segment: str) -> bool:\n    return not any(\n        segment.startswith(prefix) for prefix in (\"dev\", \"a\", \"b\", \"rc\", \"post\")\n    )\n\n\ndef _pad_version(left: List[str], right: List[str]) -> Tuple[List[str], List[str]]:\n    left_split, right_split = [], []\n\n    # Get the release segment of our versions\n    left_split.append(list(itertools.takewhile(lambda x: x.isdigit(), left)))\n    right_split.append(list(itertools.takewhile(lambda x: x.isdigit(), right)))\n\n    # Get the rest of our versions\n    left_split.append(left[len(left_split[0]) :])\n    right_split.append(right[len(right_split[0]) :])\n\n    # Insert our padding\n    left_split.insert(1, [\"0\"] * max(0, len(right_split[0]) - len(left_split[0])))\n    right_split.insert(1, [\"0\"] * max(0, len(left_split[0]) - len(right_split[0])))\n\n    return (\n        list(itertools.chain.from_iterable(left_split)),\n        list(itertools.chain.from_iterable(right_split)),\n    )\n\n\nclass SpecifierSet(BaseSpecifier):\n    \"\"\"This class abstracts handling of a set of version specifiers.\n\n    It can be passed a single specifier (``>=3.0``), a comma-separated list of\n    specifiers (``>=3.0,!=3.1``), or no specifier at all.\n    \"\"\"\n\n    def __init__(\n        self, specifiers: str = \"\", prereleases: Optional[bool] = None\n    ) -> None:\n        \"\"\"Initialize a SpecifierSet instance.\n\n        :param specifiers:\n            The string representation of a specifier or a comma-separated list of\n            specifiers which will be parsed and normalized before use.\n        :param prereleases:\n            This tells the SpecifierSet if it should accept prerelease versions if\n            applicable or not. The default of ``None`` will autodetect it from the\n            given specifiers.\n\n        :raises InvalidSpecifier:\n            If the given ``specifiers`` are not parseable than this exception will be\n            raised.\n        \"\"\"\n\n        # Split on `,` to break each individual specifier into it's own item, and\n        # strip each item to remove leading/trailing whitespace.\n        split_specifiers = [s.strip() for s in specifiers.split(\",\") if s.strip()]\n\n        # Make each individual specifier a Specifier and save in a frozen set for later.\n        self._specs = frozenset(map(Specifier, split_specifiers))\n\n        # Store our prereleases value so we can use it later to determine if\n        # we accept prereleases or not.\n        self._prereleases = prereleases\n\n    @property\n    def prereleases(self) -> Optional[bool]:\n        # If we have been given an explicit prerelease modifier, then we'll\n        # pass that through here.\n        if self._prereleases is not None:\n            return self._prereleases\n\n        # If we don't have any specifiers, and we don't have a forced value,\n        # then we'll just return None since we don't know if this should have\n        # pre-releases or not.\n        if not self._specs:\n            return None\n\n        # Otherwise we'll see if any of the given specifiers accept\n        # prereleases, if any of them do we'll return True, otherwise False.\n        return any(s.prereleases for s in self._specs)\n\n    @prereleases.setter\n    def prereleases(self, value: bool) -> None:\n        self._prereleases = value\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the specifier set that shows all internal state.\n\n        Note that the ordering of the individual specifiers within the set may not\n        match the input string.\n\n        >>> SpecifierSet('>=1.0.0,!=2.0.0')\n        <SpecifierSet('!=2.0.0,>=1.0.0')>\n        >>> SpecifierSet('>=1.0.0,!=2.0.0', prereleases=False)\n        <SpecifierSet('!=2.0.0,>=1.0.0', prereleases=False)>\n        >>> SpecifierSet('>=1.0.0,!=2.0.0', prereleases=True)\n        <SpecifierSet('!=2.0.0,>=1.0.0', prereleases=True)>\n        \"\"\"\n        pre = (\n            f\", prereleases={self.prereleases!r}\"\n            if self._prereleases is not None\n            else \"\"\n        )\n\n        return f\"<SpecifierSet({str(self)!r}{pre})>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the specifier set that can be round-tripped.\n\n        Note that the ordering of the individual specifiers within the set may not\n        match the input string.\n\n        >>> str(SpecifierSet(\">=1.0.0,!=1.0.1\"))\n        '!=1.0.1,>=1.0.0'\n        >>> str(SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=False))\n        '!=1.0.1,>=1.0.0'\n        \"\"\"\n        return \",\".join(sorted(str(s) for s in self._specs))\n\n    def __hash__(self) -> int:\n        return hash(self._specs)\n\n    def __and__(self, other: Union[\"SpecifierSet\", str]) -> \"SpecifierSet\":\n        \"\"\"Return a SpecifierSet which is a combination of the two sets.\n\n        :param other: The other object to combine with.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") & '<=2.0.0,!=2.0.1'\n        <SpecifierSet('!=1.0.1,!=2.0.1,<=2.0.0,>=1.0.0')>\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") & SpecifierSet('<=2.0.0,!=2.0.1')\n        <SpecifierSet('!=1.0.1,!=2.0.1,<=2.0.0,>=1.0.0')>\n        \"\"\"\n        if isinstance(other, str):\n            other = SpecifierSet(other)\n        elif not isinstance(other, SpecifierSet):\n            return NotImplemented\n\n        specifier = SpecifierSet()\n        specifier._specs = frozenset(self._specs | other._specs)\n\n        if self._prereleases is None and other._prereleases is not None:\n            specifier._prereleases = other._prereleases\n        elif self._prereleases is not None and other._prereleases is None:\n            specifier._prereleases = self._prereleases\n        elif self._prereleases == other._prereleases:\n            specifier._prereleases = self._prereleases\n        else:\n            raise ValueError(\n                \"Cannot combine SpecifierSets with True and False prerelease \"\n                \"overrides.\"\n            )\n\n        return specifier\n\n    def __eq__(self, other: object) -> bool:\n        \"\"\"Whether or not the two SpecifierSet-like objects are equal.\n\n        :param other: The other object to check against.\n\n        The value of :attr:`prereleases` is ignored.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> (SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=False) ==\n        ...  SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True))\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == \">=1.0.0,!=1.0.1\"\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\") == SpecifierSet(\">=1.0.0,!=1.0.2\")\n        False\n        \"\"\"\n        if isinstance(other, (str, Specifier)):\n            other = SpecifierSet(str(other))\n        elif not isinstance(other, SpecifierSet):\n            return NotImplemented\n\n        return self._specs == other._specs\n\n    def __len__(self) -> int:\n        \"\"\"Returns the number of specifiers in this specifier set.\"\"\"\n        return len(self._specs)\n\n    def __iter__(self) -> Iterator[Specifier]:\n        \"\"\"\n        Returns an iterator over all the underlying :class:`Specifier` instances\n        in this specifier set.\n\n        >>> sorted(SpecifierSet(\">=1.0.0,!=1.0.1\"), key=str)\n        [<Specifier('!=1.0.1')>, <Specifier('>=1.0.0')>]\n        \"\"\"\n        return iter(self._specs)\n\n    def __contains__(self, item: UnparsedVersion) -> bool:\n        \"\"\"Return whether or not the item is contained in this specifier.\n\n        :param item: The item to check for.\n\n        This is used for the ``in`` operator and behaves the same as\n        :meth:`contains` with no ``prereleases`` argument passed.\n\n        >>> \"1.2.3\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> Version(\"1.2.3\") in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        True\n        >>> \"1.0.1\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        False\n        >>> \"1.3.0a1\" in SpecifierSet(\">=1.0.0,!=1.0.1\")\n        False\n        >>> \"1.3.0a1\" in SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True)\n        True\n        \"\"\"\n        return self.contains(item)\n\n    def contains(\n        self,\n        item: UnparsedVersion,\n        prereleases: Optional[bool] = None,\n        installed: Optional[bool] = None,\n    ) -> bool:\n        \"\"\"Return whether or not the item is contained in this SpecifierSet.\n\n        :param item:\n            The item to check for, which can be a version string or a\n            :class:`Version` instance.\n        :param prereleases:\n            Whether or not to match prereleases with this SpecifierSet. If set to\n            ``None`` (the default), it uses :attr:`prereleases` to determine\n            whether or not prereleases are allowed.\n\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.2.3\")\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(Version(\"1.2.3\"))\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.0.1\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.3.0a1\")\n        False\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\", prereleases=True).contains(\"1.3.0a1\")\n        True\n        >>> SpecifierSet(\">=1.0.0,!=1.0.1\").contains(\"1.3.0a1\", prereleases=True)\n        True\n        \"\"\"\n        # Ensure that our item is a Version instance.\n        if not isinstance(item, Version):\n            item = Version(item)\n\n        # Determine if we're forcing a prerelease or not, if we're not forcing\n        # one for this particular filter call, then we'll use whatever the\n        # SpecifierSet thinks for whether or not we should support prereleases.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # We can determine if we're going to allow pre-releases by looking to\n        # see if any of the underlying items supports them. If none of them do\n        # and this item is a pre-release then we do not allow it and we can\n        # short circuit that here.\n        # Note: This means that 1.0.dev1 would not be contained in something\n        #       like >=1.0.devabc however it would be in >=1.0.debabc,>0.0.dev0\n        if not prereleases and item.is_prerelease:\n            return False\n\n        if installed and item.is_prerelease:\n            item = Version(item.base_version)\n\n        # We simply dispatch to the underlying specs here to make sure that the\n        # given version is contained within all of them.\n        # Note: This use of all() here means that an empty set of specifiers\n        #       will always return True, this is an explicit design decision.\n        return all(s.contains(item, prereleases=prereleases) for s in self._specs)\n\n    def filter(\n        self, iterable: Iterable[UnparsedVersionVar], prereleases: Optional[bool] = None\n    ) -> Iterator[UnparsedVersionVar]:\n        \"\"\"Filter items in the given iterable, that match the specifiers in this set.\n\n        :param iterable:\n            An iterable that can contain version strings and :class:`Version` instances.\n            The items in the iterable will be filtered according to the specifier.\n        :param prereleases:\n            Whether or not to allow prereleases in the returned iterator. If set to\n            ``None`` (the default), it will be intelligently decide whether to allow\n            prereleases or not (based on the :attr:`prereleases` attribute, and\n            whether the only versions matching are prereleases).\n\n        This method is smarter than just ``filter(SpecifierSet(...).contains, [...])``\n        because it implements the rule from :pep:`440` that a prerelease item\n        SHOULD be accepted if no other versions match the given specifier.\n\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.3\", Version(\"1.4\")]))\n        ['1.3', <Version('1.4')>]\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.2\", \"1.5a1\"]))\n        []\n        >>> list(SpecifierSet(\">=1.2.3\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        >>> list(SpecifierSet(\">=1.2.3\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n\n        An \"empty\" SpecifierSet will filter items based on the presence of prerelease\n        versions in the set.\n\n        >>> list(SpecifierSet(\"\").filter([\"1.3\", \"1.5a1\"]))\n        ['1.3']\n        >>> list(SpecifierSet(\"\").filter([\"1.5a1\"]))\n        ['1.5a1']\n        >>> list(SpecifierSet(\"\", prereleases=True).filter([\"1.3\", \"1.5a1\"]))\n        ['1.3', '1.5a1']\n        >>> list(SpecifierSet(\"\").filter([\"1.3\", \"1.5a1\"], prereleases=True))\n        ['1.3', '1.5a1']\n        \"\"\"\n        # Determine if we're forcing a prerelease or not, if we're not forcing\n        # one for this particular filter call, then we'll use whatever the\n        # SpecifierSet thinks for whether or not we should support prereleases.\n        if prereleases is None:\n            prereleases = self.prereleases\n\n        # If we have any specifiers, then we want to wrap our iterable in the\n        # filter method for each one, this will act as a logical AND amongst\n        # each specifier.\n        if self._specs:\n            for spec in self._specs:\n                iterable = spec.filter(iterable, prereleases=bool(prereleases))\n            return iter(iterable)\n        # If we do not have any specifiers, then we need to have a rough filter\n        # which will filter out any pre-releases, unless there are no final\n        # releases.\n        else:\n            filtered: List[UnparsedVersionVar] = []\n            found_prereleases: List[UnparsedVersionVar] = []\n\n            for item in iterable:\n                parsed_version = _coerce_version(item)\n\n                # Store any item which is a pre-release for later unless we've\n                # already found a final version or we are accepting prereleases\n                if parsed_version.is_prerelease and not prereleases:\n                    if not filtered:\n                        found_prereleases.append(item)\n                else:\n                    filtered.append(item)\n\n            # If we've found no items except for pre-releases, then we'll go\n            # ahead and use the pre-releases\n            if not filtered and found_prereleases and prereleases is None:\n                return iter(found_prereleases)\n\n            return iter(filtered)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/vendored/packaging/tags.py","size":18950,"sha1":"d0e8626cb65a650cf790493be9981f427eec05c7","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport logging\nimport platform\nimport re\nimport struct\nimport subprocess\nimport sys\nimport sysconfig\nfrom importlib.machinery import EXTENSION_SUFFIXES\nfrom typing import (\n    Dict,\n    FrozenSet,\n    Iterable,\n    Iterator,\n    List,\n    Optional,\n    Sequence,\n    Tuple,\n    Union,\n    cast,\n)\n\nfrom . import _manylinux, _musllinux\n\nlogger = logging.getLogger(__name__)\n\nPythonVersion = Sequence[int]\nMacVersion = Tuple[int, int]\n\nINTERPRETER_SHORT_NAMES: Dict[str, str] = {\n    \"python\": \"py\",  # Generic.\n    \"cpython\": \"cp\",\n    \"pypy\": \"pp\",\n    \"ironpython\": \"ip\",\n    \"jython\": \"jy\",\n}\n\n\n_32_BIT_INTERPRETER = struct.calcsize(\"P\") == 4\n\n\nclass Tag:\n    \"\"\"\n    A representation of the tag triple for a wheel.\n\n    Instances are considered immutable and thus are hashable. Equality checking\n    is also supported.\n    \"\"\"\n\n    __slots__ = [\"_interpreter\", \"_abi\", \"_platform\", \"_hash\"]\n\n    def __init__(self, interpreter: str, abi: str, platform: str) -> None:\n        self._interpreter = interpreter.lower()\n        self._abi = abi.lower()\n        self._platform = platform.lower()\n        # The __hash__ of every single element in a Set[Tag] will be evaluated each time\n        # that a set calls its `.disjoint()` method, which may be called hundreds of\n        # times when scanning a page of links for packages with tags matching that\n        # Set[Tag]. Pre-computing the value here produces significant speedups for\n        # downstream consumers.\n        self._hash = hash((self._interpreter, self._abi, self._platform))\n\n    @property\n    def interpreter(self) -> str:\n        return self._interpreter\n\n    @property\n    def abi(self) -> str:\n        return self._abi\n\n    @property\n    def platform(self) -> str:\n        return self._platform\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Tag):\n            return NotImplemented\n\n        return (\n            (self._hash == other._hash)  # Short-circuit ASAP for perf reasons.\n            and (self._platform == other._platform)\n            and (self._abi == other._abi)\n            and (self._interpreter == other._interpreter)\n        )\n\n    def __hash__(self) -> int:\n        return self._hash\n\n    def __str__(self) -> str:\n        return f\"{self._interpreter}-{self._abi}-{self._platform}\"\n\n    def __repr__(self) -> str:\n        return f\"<{self} @ {id(self)}>\"\n\n\ndef parse_tag(tag: str) -> FrozenSet[Tag]:\n    \"\"\"\n    Parses the provided tag (e.g. `py3-none-any`) into a frozenset of Tag instances.\n\n    Returning a set is required due to the possibility that the tag is a\n    compressed tag set.\n    \"\"\"\n    tags = set()\n    interpreters, abis, platforms = tag.split(\"-\")\n    for interpreter in interpreters.split(\".\"):\n        for abi in abis.split(\".\"):\n            for platform_ in platforms.split(\".\"):\n                tags.add(Tag(interpreter, abi, platform_))\n    return frozenset(tags)\n\n\ndef _get_config_var(name: str, warn: bool = False) -> Union[int, str, None]:\n    value: Union[int, str, None] = sysconfig.get_config_var(name)\n    if value is None and warn:\n        logger.debug(\n            \"Config variable '%s' is unset, Python ABI tag may be incorrect\", name\n        )\n    return value\n\n\ndef _normalize_string(string: str) -> str:\n    return string.replace(\".\", \"_\").replace(\"-\", \"_\").replace(\" \", \"_\")\n\n\ndef _is_threaded_cpython(abis: List[str]) -> bool:\n    \"\"\"\n    Determine if the ABI corresponds to a threaded (`--disable-gil`) build.\n\n    The threaded builds are indicated by a \"t\" in the abiflags.\n    \"\"\"\n    if len(abis) == 0:\n        return False\n    # expect e.g., cp313\n    m = re.match(r\"cp\\d+(.*)\", abis[0])\n    if not m:\n        return False\n    abiflags = m.group(1)\n    return \"t\" in abiflags\n\n\ndef _abi3_applies(python_version: PythonVersion, threading: bool) -> bool:\n    \"\"\"\n    Determine if the Python version supports abi3.\n\n    PEP 384 was first implemented in Python 3.2. The threaded (`--disable-gil`)\n    builds do not support abi3.\n    \"\"\"\n    return len(python_version) > 1 and tuple(python_version) >= (3, 2) and not threading\n\n\ndef _cpython_abis(py_version: PythonVersion, warn: bool = False) -> List[str]:\n    py_version = tuple(py_version)  # To allow for version comparison.\n    abis = []\n    version = _version_nodot(py_version[:2])\n    threading = debug = pymalloc = ucs4 = \"\"\n    with_debug = _get_config_var(\"Py_DEBUG\", warn)\n    has_refcount = hasattr(sys, \"gettotalrefcount\")\n    # Windows doesn't set Py_DEBUG, so checking for support of debug-compiled\n    # extension modules is the best option.\n    # https://github.com/pypa/pip/issues/3383#issuecomment-173267692\n    has_ext = \"_d.pyd\" in EXTENSION_SUFFIXES\n    if with_debug or (with_debug is None and (has_refcount or has_ext)):\n        debug = \"d\"\n    if py_version >= (3, 13) and _get_config_var(\"Py_GIL_DISABLED\", warn):\n        threading = \"t\"\n    if py_version < (3, 8):\n        with_pymalloc = _get_config_var(\"WITH_PYMALLOC\", warn)\n        if with_pymalloc or with_pymalloc is None:\n            pymalloc = \"m\"\n        if py_version < (3, 3):\n            unicode_size = _get_config_var(\"Py_UNICODE_SIZE\", warn)\n            if unicode_size == 4 or (\n                unicode_size is None and sys.maxunicode == 0x10FFFF\n            ):\n                ucs4 = \"u\"\n    elif debug:\n        # Debug builds can also load \"normal\" extension modules.\n        # We can also assume no UCS-4 or pymalloc requirement.\n        abis.append(f\"cp{version}{threading}\")\n    abis.insert(0, f\"cp{version}{threading}{debug}{pymalloc}{ucs4}\")\n    return abis\n\n\ndef cpython_tags(\n    python_version: Optional[PythonVersion] = None,\n    abis: Optional[Iterable[str]] = None,\n    platforms: Optional[Iterable[str]] = None,\n    *,\n    warn: bool = False,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the tags for a CPython interpreter.\n\n    The tags consist of:\n    - cp<python_version>-<abi>-<platform>\n    - cp<python_version>-abi3-<platform>\n    - cp<python_version>-none-<platform>\n    - cp<less than python_version>-abi3-<platform>  # Older Python versions down to 3.2.\n\n    If python_version only specifies a major version then user-provided ABIs and\n    the 'none' ABItag will be used.\n\n    If 'abi3' or 'none' are specified in 'abis' then they will be yielded at\n    their normal position and not at the beginning.\n    \"\"\"\n    if not python_version:\n        python_version = sys.version_info[:2]\n\n    interpreter = f\"cp{_version_nodot(python_version[:2])}\"\n\n    if abis is None:\n        if len(python_version) > 1:\n            abis = _cpython_abis(python_version, warn)\n        else:\n            abis = []\n    abis = list(abis)\n    # 'abi3' and 'none' are explicitly handled later.\n    for explicit_abi in (\"abi3\", \"none\"):\n        try:\n            abis.remove(explicit_abi)\n        except ValueError:\n            pass\n\n    platforms = list(platforms or platform_tags())\n    for abi in abis:\n        for platform_ in platforms:\n            yield Tag(interpreter, abi, platform_)\n\n    threading = _is_threaded_cpython(abis)\n    use_abi3 = _abi3_applies(python_version, threading)\n    if use_abi3:\n        yield from (Tag(interpreter, \"abi3\", platform_) for platform_ in platforms)\n    yield from (Tag(interpreter, \"none\", platform_) for platform_ in platforms)\n\n    if use_abi3:\n        for minor_version in range(python_version[1] - 1, 1, -1):\n            for platform_ in platforms:\n                interpreter = \"cp{version}\".format(\n                    version=_version_nodot((python_version[0], minor_version))\n                )\n                yield Tag(interpreter, \"abi3\", platform_)\n\n\ndef _generic_abi() -> List[str]:\n    \"\"\"\n    Return the ABI tag based on EXT_SUFFIX.\n    \"\"\"\n    # The following are examples of `EXT_SUFFIX`.\n    # We want to keep the parts which are related to the ABI and remove the\n    # parts which are related to the platform:\n    # - linux:   '.cpython-310-x86_64-linux-gnu.so' => cp310\n    # - mac:     '.cpython-310-darwin.so'           => cp310\n    # - win:     '.cp310-win_amd64.pyd'             => cp310\n    # - win:     '.pyd'                             => cp37 (uses _cpython_abis())\n    # - pypy:    '.pypy38-pp73-x86_64-linux-gnu.so' => pypy38_pp73\n    # - graalpy: '.graalpy-38-native-x86_64-darwin.dylib'\n    #                                               => graalpy_38_native\n\n    ext_suffix = _get_config_var(\"EXT_SUFFIX\", warn=True)\n    if not isinstance(ext_suffix, str) or ext_suffix[0] != \".\":\n        raise SystemError(\"invalid sysconfig.get_config_var('EXT_SUFFIX')\")\n    parts = ext_suffix.split(\".\")\n    if len(parts) < 3:\n        # CPython3.7 and earlier uses \".pyd\" on Windows.\n        return _cpython_abis(sys.version_info[:2])\n    soabi = parts[1]\n    if soabi.startswith(\"cpython\"):\n        # non-windows\n        abi = \"cp\" + soabi.split(\"-\")[1]\n    elif soabi.startswith(\"cp\"):\n        # windows\n        abi = soabi.split(\"-\")[0]\n    elif soabi.startswith(\"pypy\"):\n        abi = \"-\".join(soabi.split(\"-\")[:2])\n    elif soabi.startswith(\"graalpy\"):\n        abi = \"-\".join(soabi.split(\"-\")[:3])\n    elif soabi:\n        # pyston, ironpython, others?\n        abi = soabi\n    else:\n        return []\n    return [_normalize_string(abi)]\n\n\ndef generic_tags(\n    interpreter: Optional[str] = None,\n    abis: Optional[Iterable[str]] = None,\n    platforms: Optional[Iterable[str]] = None,\n    *,\n    warn: bool = False,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the tags for a generic interpreter.\n\n    The tags consist of:\n    - <interpreter>-<abi>-<platform>\n\n    The \"none\" ABI will be added if it was not explicitly provided.\n    \"\"\"\n    if not interpreter:\n        interp_name = interpreter_name()\n        interp_version = interpreter_version(warn=warn)\n        interpreter = \"\".join([interp_name, interp_version])\n    if abis is None:\n        abis = _generic_abi()\n    else:\n        abis = list(abis)\n    platforms = list(platforms or platform_tags())\n    if \"none\" not in abis:\n        abis.append(\"none\")\n    for abi in abis:\n        for platform_ in platforms:\n            yield Tag(interpreter, abi, platform_)\n\n\ndef _py_interpreter_range(py_version: PythonVersion) -> Iterator[str]:\n    \"\"\"\n    Yields Python versions in descending order.\n\n    After the latest version, the major-only version will be yielded, and then\n    all previous versions of that major version.\n    \"\"\"\n    if len(py_version) > 1:\n        yield f\"py{_version_nodot(py_version[:2])}\"\n    yield f\"py{py_version[0]}\"\n    if len(py_version) > 1:\n        for minor in range(py_version[1] - 1, -1, -1):\n            yield f\"py{_version_nodot((py_version[0], minor))}\"\n\n\ndef compatible_tags(\n    python_version: Optional[PythonVersion] = None,\n    interpreter: Optional[str] = None,\n    platforms: Optional[Iterable[str]] = None,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the sequence of tags that are compatible with a specific version of Python.\n\n    The tags consist of:\n    - py*-none-<platform>\n    - <interpreter>-none-any  # ... if `interpreter` is provided.\n    - py*-none-any\n    \"\"\"\n    if not python_version:\n        python_version = sys.version_info[:2]\n    platforms = list(platforms or platform_tags())\n    for version in _py_interpreter_range(python_version):\n        for platform_ in platforms:\n            yield Tag(version, \"none\", platform_)\n    if interpreter:\n        yield Tag(interpreter, \"none\", \"any\")\n    for version in _py_interpreter_range(python_version):\n        yield Tag(version, \"none\", \"any\")\n\n\ndef _mac_arch(arch: str, is_32bit: bool = _32_BIT_INTERPRETER) -> str:\n    if not is_32bit:\n        return arch\n\n    if arch.startswith(\"ppc\"):\n        return \"ppc\"\n\n    return \"i386\"\n\n\ndef _mac_binary_formats(version: MacVersion, cpu_arch: str) -> List[str]:\n    formats = [cpu_arch]\n    if cpu_arch == \"x86_64\":\n        if version < (10, 4):\n            return []\n        formats.extend([\"intel\", \"fat64\", \"fat32\"])\n\n    elif cpu_arch == \"i386\":\n        if version < (10, 4):\n            return []\n        formats.extend([\"intel\", \"fat32\", \"fat\"])\n\n    elif cpu_arch == \"ppc64\":\n        # TODO: Need to care about 32-bit PPC for ppc64 through 10.2?\n        if version > (10, 5) or version < (10, 4):\n            return []\n        formats.append(\"fat64\")\n\n    elif cpu_arch == \"ppc\":\n        if version > (10, 6):\n            return []\n        formats.extend([\"fat32\", \"fat\"])\n\n    if cpu_arch in {\"arm64\", \"x86_64\"}:\n        formats.append(\"universal2\")\n\n    if cpu_arch in {\"x86_64\", \"i386\", \"ppc64\", \"ppc\", \"intel\"}:\n        formats.append(\"universal\")\n\n    return formats\n\n\ndef mac_platforms(\n    version: Optional[MacVersion] = None, arch: Optional[str] = None\n) -> Iterator[str]:\n    \"\"\"\n    Yields the platform tags for a macOS system.\n\n    The `version` parameter is a two-item tuple specifying the macOS version to\n    generate platform tags for. The `arch` parameter is the CPU architecture to\n    generate platform tags for. Both parameters default to the appropriate value\n    for the current system.\n    \"\"\"\n    version_str, _, cpu_arch = platform.mac_ver()\n    if version is None:\n        version = cast(\"MacVersion\", tuple(map(int, version_str.split(\".\")[:2])))\n        if version == (10, 16):\n            # When built against an older macOS SDK, Python will report macOS 10.16\n            # instead of the real version.\n            version_str = subprocess.run(\n                [\n                    sys.executable,\n                    \"-sS\",\n                    \"-c\",\n                    \"import platform; print(platform.mac_ver()[0])\",\n                ],\n                check=True,\n                env={\"SYSTEM_VERSION_COMPAT\": \"0\"},\n                stdout=subprocess.PIPE,\n                text=True,\n            ).stdout\n            version = cast(\"MacVersion\", tuple(map(int, version_str.split(\".\")[:2])))\n    else:\n        version = version\n    if arch is None:\n        arch = _mac_arch(cpu_arch)\n    else:\n        arch = arch\n\n    if (10, 0) <= version and version < (11, 0):\n        # Prior to Mac OS 11, each yearly release of Mac OS bumped the\n        # \"minor\" version number.  The major version was always 10.\n        for minor_version in range(version[1], -1, -1):\n            compat_version = 10, minor_version\n            binary_formats = _mac_binary_formats(compat_version, arch)\n            for binary_format in binary_formats:\n                yield \"macosx_{major}_{minor}_{binary_format}\".format(\n                    major=10, minor=minor_version, binary_format=binary_format\n                )\n\n    if version >= (11, 0):\n        # Starting with Mac OS 11, each yearly release bumps the major version\n        # number.   The minor versions are now the midyear updates.\n        for major_version in range(version[0], 10, -1):\n            compat_version = major_version, 0\n            binary_formats = _mac_binary_formats(compat_version, arch)\n            for binary_format in binary_formats:\n                yield \"macosx_{major}_{minor}_{binary_format}\".format(\n                    major=major_version, minor=0, binary_format=binary_format\n                )\n\n    if version >= (11, 0):\n        # Mac OS 11 on x86_64 is compatible with binaries from previous releases.\n        # Arm64 support was introduced in 11.0, so no Arm binaries from previous\n        # releases exist.\n        #\n        # However, the \"universal2\" binary format can have a\n        # macOS version earlier than 11.0 when the x86_64 part of the binary supports\n        # that version of macOS.\n        if arch == \"x86_64\":\n            for minor_version in range(16, 3, -1):\n                compat_version = 10, minor_version\n                binary_formats = _mac_binary_formats(compat_version, arch)\n                for binary_format in binary_formats:\n                    yield \"macosx_{major}_{minor}_{binary_format}\".format(\n                        major=compat_version[0],\n                        minor=compat_version[1],\n                        binary_format=binary_format,\n                    )\n        else:\n            for minor_version in range(16, 3, -1):\n                compat_version = 10, minor_version\n                binary_format = \"universal2\"\n                yield \"macosx_{major}_{minor}_{binary_format}\".format(\n                    major=compat_version[0],\n                    minor=compat_version[1],\n                    binary_format=binary_format,\n                )\n\n\ndef _linux_platforms(is_32bit: bool = _32_BIT_INTERPRETER) -> Iterator[str]:\n    linux = _normalize_string(sysconfig.get_platform())\n    if not linux.startswith(\"linux_\"):\n        # we should never be here, just yield the sysconfig one and return\n        yield linux\n        return\n    if is_32bit:\n        if linux == \"linux_x86_64\":\n            linux = \"linux_i686\"\n        elif linux == \"linux_aarch64\":\n            linux = \"linux_armv8l\"\n    _, arch = linux.split(\"_\", 1)\n    archs = {\"armv8l\": [\"armv8l\", \"armv7l\"]}.get(arch, [arch])\n    yield from _manylinux.platform_tags(archs)\n    yield from _musllinux.platform_tags(archs)\n    for arch in archs:\n        yield f\"linux_{arch}\"\n\n\ndef _generic_platforms() -> Iterator[str]:\n    yield _normalize_string(sysconfig.get_platform())\n\n\ndef platform_tags() -> Iterator[str]:\n    \"\"\"\n    Provides the platform tags for this installation.\n    \"\"\"\n    if platform.system() == \"Darwin\":\n        return mac_platforms()\n    elif platform.system() == \"Linux\":\n        return _linux_platforms()\n    else:\n        return _generic_platforms()\n\n\ndef interpreter_name() -> str:\n    \"\"\"\n    Returns the name of the running interpreter.\n\n    Some implementations have a reserved, two-letter abbreviation which will\n    be returned when appropriate.\n    \"\"\"\n    name = sys.implementation.name\n    return INTERPRETER_SHORT_NAMES.get(name) or name\n\n\ndef interpreter_version(*, warn: bool = False) -> str:\n    \"\"\"\n    Returns the version of the running interpreter.\n    \"\"\"\n    version = _get_config_var(\"py_version_nodot\", warn=warn)\n    if version:\n        version = str(version)\n    else:\n        version = _version_nodot(sys.version_info[:2])\n    return version\n\n\ndef _version_nodot(version: PythonVersion) -> str:\n    return \"\".join(map(str, version))\n\n\ndef sys_tags(*, warn: bool = False) -> Iterator[Tag]:\n    \"\"\"\n    Returns the sequence of tag triples for the running interpreter.\n\n    The order of the sequence corresponds to priority order for the\n    interpreter, from most to least important.\n    \"\"\"\n\n    interp_name = interpreter_name()\n    if interp_name == \"cp\":\n        yield from cpython_tags(warn=warn)\n    else:\n        yield from generic_tags()\n\n    if interp_name == \"pp\":\n        interp = \"pp3\"\n    elif interp_name == \"cp\":\n        interp = \"cp\" + interpreter_version(warn=warn)\n    else:\n        interp = None\n    yield from compatible_tags(interpreter=interp)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/vendored/packaging/utils.py","size":5268,"sha1":"832a86edb71c6c5e128f0a4172fd063de7858e71","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport re\nfrom typing import FrozenSet, NewType, Tuple, Union, cast\n\nfrom .tags import Tag, parse_tag\nfrom .version import InvalidVersion, Version\n\nBuildTag = Union[Tuple[()], Tuple[int, str]]\nNormalizedName = NewType(\"NormalizedName\", str)\n\n\nclass InvalidName(ValueError):\n    \"\"\"\n    An invalid distribution name; users should refer to the packaging user guide.\n    \"\"\"\n\n\nclass InvalidWheelFilename(ValueError):\n    \"\"\"\n    An invalid wheel filename was found, users should refer to PEP 427.\n    \"\"\"\n\n\nclass InvalidSdistFilename(ValueError):\n    \"\"\"\n    An invalid sdist filename was found, users should refer to the packaging user guide.\n    \"\"\"\n\n\n# Core metadata spec for `Name`\n_validate_regex = re.compile(\n    r\"^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$\", re.IGNORECASE\n)\n_canonicalize_regex = re.compile(r\"[-_.]+\")\n_normalized_regex = re.compile(r\"^([a-z0-9]|[a-z0-9]([a-z0-9-](?!--))*[a-z0-9])$\")\n# PEP 427: The build number must start with a digit.\n_build_tag_regex = re.compile(r\"(\\d+)(.*)\")\n\n\ndef canonicalize_name(name: str, *, validate: bool = False) -> NormalizedName:\n    if validate and not _validate_regex.match(name):\n        raise InvalidName(f\"name is invalid: {name!r}\")\n    # This is taken from PEP 503.\n    value = _canonicalize_regex.sub(\"-\", name).lower()\n    return cast(NormalizedName, value)\n\n\ndef is_normalized_name(name: str) -> bool:\n    return _normalized_regex.match(name) is not None\n\n\ndef canonicalize_version(\n    version: Union[Version, str], *, strip_trailing_zero: bool = True\n) -> str:\n    \"\"\"\n    This is very similar to Version.__str__, but has one subtle difference\n    with the way it handles the release segment.\n    \"\"\"\n    if isinstance(version, str):\n        try:\n            parsed = Version(version)\n        except InvalidVersion:\n            # Legacy versions cannot be normalized\n            return version\n    else:\n        parsed = version\n\n    parts = []\n\n    # Epoch\n    if parsed.epoch != 0:\n        parts.append(f\"{parsed.epoch}!\")\n\n    # Release segment\n    release_segment = \".\".join(str(x) for x in parsed.release)\n    if strip_trailing_zero:\n        # NB: This strips trailing '.0's to normalize\n        release_segment = re.sub(r\"(\\.0)+$\", \"\", release_segment)\n    parts.append(release_segment)\n\n    # Pre-release\n    if parsed.pre is not None:\n        parts.append(\"\".join(str(x) for x in parsed.pre))\n\n    # Post-release\n    if parsed.post is not None:\n        parts.append(f\".post{parsed.post}\")\n\n    # Development release\n    if parsed.dev is not None:\n        parts.append(f\".dev{parsed.dev}\")\n\n    # Local version segment\n    if parsed.local is not None:\n        parts.append(f\"+{parsed.local}\")\n\n    return \"\".join(parts)\n\n\ndef parse_wheel_filename(\n    filename: str,\n) -> Tuple[NormalizedName, Version, BuildTag, FrozenSet[Tag]]:\n    if not filename.endswith(\".whl\"):\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (extension must be '.whl'): {filename}\"\n        )\n\n    filename = filename[:-4]\n    dashes = filename.count(\"-\")\n    if dashes not in (4, 5):\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (wrong number of parts): {filename}\"\n        )\n\n    parts = filename.split(\"-\", dashes - 2)\n    name_part = parts[0]\n    # See PEP 427 for the rules on escaping the project name.\n    if \"__\" in name_part or re.match(r\"^[\\w\\d._]*$\", name_part, re.UNICODE) is None:\n        raise InvalidWheelFilename(f\"Invalid project name: {filename}\")\n    name = canonicalize_name(name_part)\n\n    try:\n        version = Version(parts[1])\n    except InvalidVersion as e:\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (invalid version): {filename}\"\n        ) from e\n\n    if dashes == 5:\n        build_part = parts[2]\n        build_match = _build_tag_regex.match(build_part)\n        if build_match is None:\n            raise InvalidWheelFilename(\n                f\"Invalid build number: {build_part} in '{filename}'\"\n            )\n        build = cast(BuildTag, (int(build_match.group(1)), build_match.group(2)))\n    else:\n        build = ()\n    tags = parse_tag(parts[-1])\n    return (name, version, build, tags)\n\n\ndef parse_sdist_filename(filename: str) -> Tuple[NormalizedName, Version]:\n    if filename.endswith(\".tar.gz\"):\n        file_stem = filename[: -len(\".tar.gz\")]\n    elif filename.endswith(\".zip\"):\n        file_stem = filename[: -len(\".zip\")]\n    else:\n        raise InvalidSdistFilename(\n            f\"Invalid sdist filename (extension must be '.tar.gz' or '.zip'):\"\n            f\" {filename}\"\n        )\n\n    # We are requiring a PEP 440 version, which cannot contain dashes,\n    # so we split on the last dash.\n    name_part, sep, version_part = file_stem.rpartition(\"-\")\n    if not sep:\n        raise InvalidSdistFilename(f\"Invalid sdist filename: {filename}\")\n\n    name = canonicalize_name(name_part)\n\n    try:\n        version = Version(version_part)\n    except InvalidVersion as e:\n        raise InvalidSdistFilename(\n            f\"Invalid sdist filename (invalid version): {filename}\"\n        ) from e\n\n    return (name, version)\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/vendored/packaging/version.py","size":16234,"sha1":"9e48a008c94d48159224be4714f5f49414873153","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\"\"\"\n.. testsetup::\n\n    from packaging.version import parse, Version\n\"\"\"\n\nimport itertools\nimport re\nfrom typing import Any, Callable, NamedTuple, Optional, SupportsInt, Tuple, Union\n\nfrom ._structures import Infinity, InfinityType, NegativeInfinity, NegativeInfinityType\n\n__all__ = [\"VERSION_PATTERN\", \"parse\", \"Version\", \"InvalidVersion\"]\n\nLocalType = Tuple[Union[int, str], ...]\n\nCmpPrePostDevType = Union[InfinityType, NegativeInfinityType, Tuple[str, int]]\nCmpLocalType = Union[\n    NegativeInfinityType,\n    Tuple[Union[Tuple[int, str], Tuple[NegativeInfinityType, Union[int, str]]], ...],\n]\nCmpKey = Tuple[\n    int,\n    Tuple[int, ...],\n    CmpPrePostDevType,\n    CmpPrePostDevType,\n    CmpPrePostDevType,\n    CmpLocalType,\n]\nVersionComparisonMethod = Callable[[CmpKey, CmpKey], bool]\n\n\nclass _Version(NamedTuple):\n    epoch: int\n    release: Tuple[int, ...]\n    dev: Optional[Tuple[str, int]]\n    pre: Optional[Tuple[str, int]]\n    post: Optional[Tuple[str, int]]\n    local: Optional[LocalType]\n\n\ndef parse(version: str) -> \"Version\":\n    \"\"\"Parse the given version string.\n\n    >>> parse('1.0.dev1')\n    <Version('1.0.dev1')>\n\n    :param version: The version string to parse.\n    :raises InvalidVersion: When the version string is not a valid version.\n    \"\"\"\n    return Version(version)\n\n\nclass InvalidVersion(ValueError):\n    \"\"\"Raised when a version string is not a valid version.\n\n    >>> Version(\"invalid\")\n    Traceback (most recent call last):\n        ...\n    packaging.version.InvalidVersion: Invalid version: 'invalid'\n    \"\"\"\n\n\nclass _BaseVersion:\n    _key: Tuple[Any, ...]\n\n    def __hash__(self) -> int:\n        return hash(self._key)\n\n    # Please keep the duplicated `isinstance` check\n    # in the six comparisons hereunder\n    # unless you find a way to avoid adding overhead function calls.\n    def __lt__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key < other._key\n\n    def __le__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key <= other._key\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key == other._key\n\n    def __ge__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key >= other._key\n\n    def __gt__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key > other._key\n\n    def __ne__(self, other: object) -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented\n\n        return self._key != other._key\n\n\n# Deliberately not anchored to the start and end of the string, to make it\n# easier for 3rd party code to reuse\n_VERSION_PATTERN = r\"\"\"\n    v?\n    (?:\n        (?:(?P<epoch>[0-9]+)!)?                           # epoch\n        (?P<release>[0-9]+(?:\\.[0-9]+)*)                  # release segment\n        (?P<pre>                                          # pre-release\n            [-_\\.]?\n            (?P<pre_l>alpha|a|beta|b|preview|pre|c|rc)\n            [-_\\.]?\n            (?P<pre_n>[0-9]+)?\n        )?\n        (?P<post>                                         # post release\n            (?:-(?P<post_n1>[0-9]+))\n            |\n            (?:\n                [-_\\.]?\n                (?P<post_l>post|rev|r)\n                [-_\\.]?\n                (?P<post_n2>[0-9]+)?\n            )\n        )?\n        (?P<dev>                                          # dev release\n            [-_\\.]?\n            (?P<dev_l>dev)\n            [-_\\.]?\n            (?P<dev_n>[0-9]+)?\n        )?\n    )\n    (?:\\+(?P<local>[a-z0-9]+(?:[-_\\.][a-z0-9]+)*))?       # local version\n\"\"\"\n\nVERSION_PATTERN = _VERSION_PATTERN\n\"\"\"\nA string containing the regular expression used to match a valid version.\n\nThe pattern is not anchored at either end, and is intended for embedding in larger\nexpressions (for example, matching a version number as part of a file name). The\nregular expression should be compiled with the ``re.VERBOSE`` and ``re.IGNORECASE``\nflags set.\n\n:meta hide-value:\n\"\"\"\n\n\nclass Version(_BaseVersion):\n    \"\"\"This class abstracts handling of a project's versions.\n\n    A :class:`Version` instance is comparison aware and can be compared and\n    sorted using the standard Python interfaces.\n\n    >>> v1 = Version(\"1.0a5\")\n    >>> v2 = Version(\"1.0\")\n    >>> v1\n    <Version('1.0a5')>\n    >>> v2\n    <Version('1.0')>\n    >>> v1 < v2\n    True\n    >>> v1 == v2\n    False\n    >>> v1 > v2\n    False\n    >>> v1 >= v2\n    False\n    >>> v1 <= v2\n    True\n    \"\"\"\n\n    _regex = re.compile(r\"^\\s*\" + VERSION_PATTERN + r\"\\s*$\", re.VERBOSE | re.IGNORECASE)\n    _key: CmpKey\n\n    def __init__(self, version: str) -> None:\n        \"\"\"Initialize a Version object.\n\n        :param version:\n            The string representation of a version which will be parsed and normalized\n            before use.\n        :raises InvalidVersion:\n            If the ``version`` does not conform to PEP 440 in any way then this\n            exception will be raised.\n        \"\"\"\n\n        # Validate the version and parse it into pieces\n        match = self._regex.search(version)\n        if not match:\n            raise InvalidVersion(f\"Invalid version: '{version}'\")\n\n        # Store the parsed out pieces of the version\n        self._version = _Version(\n            epoch=int(match.group(\"epoch\")) if match.group(\"epoch\") else 0,\n            release=tuple(int(i) for i in match.group(\"release\").split(\".\")),\n            pre=_parse_letter_version(match.group(\"pre_l\"), match.group(\"pre_n\")),\n            post=_parse_letter_version(\n                match.group(\"post_l\"), match.group(\"post_n1\") or match.group(\"post_n2\")\n            ),\n            dev=_parse_letter_version(match.group(\"dev_l\"), match.group(\"dev_n\")),\n            local=_parse_local_version(match.group(\"local\")),\n        )\n\n        # Generate a key which will be used for sorting\n        self._key = _cmpkey(\n            self._version.epoch,\n            self._version.release,\n            self._version.pre,\n            self._version.post,\n            self._version.dev,\n            self._version.local,\n        )\n\n    def __repr__(self) -> str:\n        \"\"\"A representation of the Version that shows all internal state.\n\n        >>> Version('1.0.0')\n        <Version('1.0.0')>\n        \"\"\"\n        return f\"<Version('{self}')>\"\n\n    def __str__(self) -> str:\n        \"\"\"A string representation of the version that can be rounded-tripped.\n\n        >>> str(Version(\"1.0a5\"))\n        '1.0a5'\n        \"\"\"\n        parts = []\n\n        # Epoch\n        if self.epoch != 0:\n            parts.append(f\"{self.epoch}!\")\n\n        # Release segment\n        parts.append(\".\".join(str(x) for x in self.release))\n\n        # Pre-release\n        if self.pre is not None:\n            parts.append(\"\".join(str(x) for x in self.pre))\n\n        # Post-release\n        if self.post is not None:\n            parts.append(f\".post{self.post}\")\n\n        # Development release\n        if self.dev is not None:\n            parts.append(f\".dev{self.dev}\")\n\n        # Local version segment\n        if self.local is not None:\n            parts.append(f\"+{self.local}\")\n\n        return \"\".join(parts)\n\n    @property\n    def epoch(self) -> int:\n        \"\"\"The epoch of the version.\n\n        >>> Version(\"2.0.0\").epoch\n        0\n        >>> Version(\"1!2.0.0\").epoch\n        1\n        \"\"\"\n        return self._version.epoch\n\n    @property\n    def release(self) -> Tuple[int, ...]:\n        \"\"\"The components of the \"release\" segment of the version.\n\n        >>> Version(\"1.2.3\").release\n        (1, 2, 3)\n        >>> Version(\"2.0.0\").release\n        (2, 0, 0)\n        >>> Version(\"1!2.0.0.post0\").release\n        (2, 0, 0)\n\n        Includes trailing zeroes but not the epoch or any pre-release / development /\n        post-release suffixes.\n        \"\"\"\n        return self._version.release\n\n    @property\n    def pre(self) -> Optional[Tuple[str, int]]:\n        \"\"\"The pre-release segment of the version.\n\n        >>> print(Version(\"1.2.3\").pre)\n        None\n        >>> Version(\"1.2.3a1\").pre\n        ('a', 1)\n        >>> Version(\"1.2.3b1\").pre\n        ('b', 1)\n        >>> Version(\"1.2.3rc1\").pre\n        ('rc', 1)\n        \"\"\"\n        return self._version.pre\n\n    @property\n    def post(self) -> Optional[int]:\n        \"\"\"The post-release number of the version.\n\n        >>> print(Version(\"1.2.3\").post)\n        None\n        >>> Version(\"1.2.3.post1\").post\n        1\n        \"\"\"\n        return self._version.post[1] if self._version.post else None\n\n    @property\n    def dev(self) -> Optional[int]:\n        \"\"\"The development number of the version.\n\n        >>> print(Version(\"1.2.3\").dev)\n        None\n        >>> Version(\"1.2.3.dev1\").dev\n        1\n        \"\"\"\n        return self._version.dev[1] if self._version.dev else None\n\n    @property\n    def local(self) -> Optional[str]:\n        \"\"\"The local version segment of the version.\n\n        >>> print(Version(\"1.2.3\").local)\n        None\n        >>> Version(\"1.2.3+abc\").local\n        'abc'\n        \"\"\"\n        if self._version.local:\n            return \".\".join(str(x) for x in self._version.local)\n        else:\n            return None\n\n    @property\n    def public(self) -> str:\n        \"\"\"The public portion of the version.\n\n        >>> Version(\"1.2.3\").public\n        '1.2.3'\n        >>> Version(\"1.2.3+abc\").public\n        '1.2.3'\n        >>> Version(\"1.2.3+abc.dev1\").public\n        '1.2.3'\n        \"\"\"\n        return str(self).split(\"+\", 1)[0]\n\n    @property\n    def base_version(self) -> str:\n        \"\"\"The \"base version\" of the version.\n\n        >>> Version(\"1.2.3\").base_version\n        '1.2.3'\n        >>> Version(\"1.2.3+abc\").base_version\n        '1.2.3'\n        >>> Version(\"1!1.2.3+abc.dev1\").base_version\n        '1!1.2.3'\n\n        The \"base version\" is the public version of the project without any pre or post\n        release markers.\n        \"\"\"\n        parts = []\n\n        # Epoch\n        if self.epoch != 0:\n            parts.append(f\"{self.epoch}!\")\n\n        # Release segment\n        parts.append(\".\".join(str(x) for x in self.release))\n\n        return \"\".join(parts)\n\n    @property\n    def is_prerelease(self) -> bool:\n        \"\"\"Whether this version is a pre-release.\n\n        >>> Version(\"1.2.3\").is_prerelease\n        False\n        >>> Version(\"1.2.3a1\").is_prerelease\n        True\n        >>> Version(\"1.2.3b1\").is_prerelease\n        True\n        >>> Version(\"1.2.3rc1\").is_prerelease\n        True\n        >>> Version(\"1.2.3dev1\").is_prerelease\n        True\n        \"\"\"\n        return self.dev is not None or self.pre is not None\n\n    @property\n    def is_postrelease(self) -> bool:\n        \"\"\"Whether this version is a post-release.\n\n        >>> Version(\"1.2.3\").is_postrelease\n        False\n        >>> Version(\"1.2.3.post1\").is_postrelease\n        True\n        \"\"\"\n        return self.post is not None\n\n    @property\n    def is_devrelease(self) -> bool:\n        \"\"\"Whether this version is a development release.\n\n        >>> Version(\"1.2.3\").is_devrelease\n        False\n        >>> Version(\"1.2.3.dev1\").is_devrelease\n        True\n        \"\"\"\n        return self.dev is not None\n\n    @property\n    def major(self) -> int:\n        \"\"\"The first item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").major\n        1\n        \"\"\"\n        return self.release[0] if len(self.release) >= 1 else 0\n\n    @property\n    def minor(self) -> int:\n        \"\"\"The second item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").minor\n        2\n        >>> Version(\"1\").minor\n        0\n        \"\"\"\n        return self.release[1] if len(self.release) >= 2 else 0\n\n    @property\n    def micro(self) -> int:\n        \"\"\"The third item of :attr:`release` or ``0`` if unavailable.\n\n        >>> Version(\"1.2.3\").micro\n        3\n        >>> Version(\"1\").micro\n        0\n        \"\"\"\n        return self.release[2] if len(self.release) >= 3 else 0\n\n\ndef _parse_letter_version(\n    letter: Optional[str], number: Union[str, bytes, SupportsInt, None]\n) -> Optional[Tuple[str, int]]:\n    if letter:\n        # We consider there to be an implicit 0 in a pre-release if there is\n        # not a numeral associated with it.\n        if number is None:\n            number = 0\n\n        # We normalize any letters to their lower case form\n        letter = letter.lower()\n\n        # We consider some words to be alternate spellings of other words and\n        # in those cases we want to normalize the spellings to our preferred\n        # spelling.\n        if letter == \"alpha\":\n            letter = \"a\"\n        elif letter == \"beta\":\n            letter = \"b\"\n        elif letter in [\"c\", \"pre\", \"preview\"]:\n            letter = \"rc\"\n        elif letter in [\"rev\", \"r\"]:\n            letter = \"post\"\n\n        return letter, int(number)\n    if not letter and number:\n        # We assume if we are given a number, but we are not given a letter\n        # then this is using the implicit post release syntax (e.g. 1.0-1)\n        letter = \"post\"\n\n        return letter, int(number)\n\n    return None\n\n\n_local_version_separators = re.compile(r\"[\\._-]\")\n\n\ndef _parse_local_version(local: Optional[str]) -> Optional[LocalType]:\n    \"\"\"\n    Takes a string like abc.1.twelve and turns it into (\"abc\", 1, \"twelve\").\n    \"\"\"\n    if local is not None:\n        return tuple(\n            part.lower() if not part.isdigit() else int(part)\n            for part in _local_version_separators.split(local)\n        )\n    return None\n\n\ndef _cmpkey(\n    epoch: int,\n    release: Tuple[int, ...],\n    pre: Optional[Tuple[str, int]],\n    post: Optional[Tuple[str, int]],\n    dev: Optional[Tuple[str, int]],\n    local: Optional[LocalType],\n) -> CmpKey:\n    # When we compare a release version, we want to compare it with all of the\n    # trailing zeros removed. So we'll use a reverse the list, drop all the now\n    # leading zeros until we come to something non zero, then take the rest\n    # re-reverse it back into the correct order and make it a tuple and use\n    # that for our sorting key.\n    _release = tuple(\n        reversed(list(itertools.dropwhile(lambda x: x == 0, reversed(release))))\n    )\n\n    # We need to \"trick\" the sorting algorithm to put 1.0.dev0 before 1.0a0.\n    # We'll do this by abusing the pre segment, but we _only_ want to do this\n    # if there is not a pre or a post segment. If we have one of those then\n    # the normal sorting rules will handle this case correctly.\n    if pre is None and post is None and dev is not None:\n        _pre: CmpPrePostDevType = NegativeInfinity\n    # Versions without a pre-release (except as noted above) should sort after\n    # those with one.\n    elif pre is None:\n        _pre = Infinity\n    else:\n        _pre = pre\n\n    # Versions without a post segment should sort before those with one.\n    if post is None:\n        _post: CmpPrePostDevType = NegativeInfinity\n\n    else:\n        _post = post\n\n    # Versions without a development segment should sort after those with one.\n    if dev is None:\n        _dev: CmpPrePostDevType = Infinity\n\n    else:\n        _dev = dev\n\n    if local is None:\n        # Versions without a local segment should sort before those with one.\n        _local: CmpLocalType = NegativeInfinity\n    else:\n        # Versions with a local segment need that segment parsed to implement\n        # the sorting rules in PEP440.\n        # - Alpha numeric segments sort before numeric segments\n        # - Alpha numeric segments sort lexicographically\n        # - Numeric segments sort numerically\n        # - Shorter versions sort before longer versions when the prefixes\n        #   match exactly\n        _local = tuple(\n            (i, \"\") if isinstance(i, int) else (NegativeInfinity, i) for i in local\n        )\n\n    return epoch, _release, _pre, _post, _dev, _local\n"},{"path":".local/share/virtualenv/wheel/3.11/image/1/CopyPipInstall/wheel-0.45.1-py3-none-any/wheel/wheelfile.py","size":8411,"sha1":"2d53f69bdbe1c49f38fc6605c3b399c6073d03f9","mtime":1754403963,"is_binary":false,"encoding":"utf-8","content":"from __future__ import annotations\n\nimport csv\nimport hashlib\nimport os.path\nimport re\nimport stat\nimport time\nfrom io import StringIO, TextIOWrapper\nfrom typing import IO, TYPE_CHECKING, Literal\nfrom zipfile import ZIP_DEFLATED, ZipFile, ZipInfo\n\nfrom wheel.cli import WheelError\nfrom wheel.util import log, urlsafe_b64decode, urlsafe_b64encode\n\nif TYPE_CHECKING:\n    from typing import Protocol, Sized, Union\n\n    from typing_extensions import Buffer\n\n    StrPath = Union[str, os.PathLike[str]]\n\n    class SizedBuffer(Sized, Buffer, Protocol): ...\n\n\n# Non-greedy matching of an optional build number may be too clever (more\n# invalid wheel filenames will match). Separate regex for .dist-info?\nWHEEL_INFO_RE = re.compile(\n    r\"\"\"^(?P<namever>(?P<name>[^\\s-]+?)-(?P<ver>[^\\s-]+?))(-(?P<build>\\d[^\\s-]*))?\n     -(?P<pyver>[^\\s-]+?)-(?P<abi>[^\\s-]+?)-(?P<plat>\\S+)\\.whl$\"\"\",\n    re.VERBOSE,\n)\nMINIMUM_TIMESTAMP = 315532800  # 1980-01-01 00:00:00 UTC\n\n\ndef get_zipinfo_datetime(timestamp: float | None = None):\n    # Some applications need reproducible .whl files, but they can't do this without\n    # forcing the timestamp of the individual ZipInfo objects. See issue #143.\n    timestamp = int(os.environ.get(\"SOURCE_DATE_EPOCH\", timestamp or time.time()))\n    timestamp = max(timestamp, MINIMUM_TIMESTAMP)\n    return time.gmtime(timestamp)[0:6]\n\n\nclass WheelFile(ZipFile):\n    \"\"\"A ZipFile derivative class that also reads SHA-256 hashes from\n    .dist-info/RECORD and checks any read files against those.\n    \"\"\"\n\n    _default_algorithm = hashlib.sha256\n\n    def __init__(\n        self,\n        file: StrPath,\n        mode: Literal[\"r\", \"w\", \"x\", \"a\"] = \"r\",\n        compression: int = ZIP_DEFLATED,\n    ):\n        basename = os.path.basename(file)\n        self.parsed_filename = WHEEL_INFO_RE.match(basename)\n        if not basename.endswith(\".whl\") or self.parsed_filename is None:\n            raise WheelError(f\"Bad wheel filename {basename!r}\")\n\n        ZipFile.__init__(self, file, mode, compression=compression, allowZip64=True)\n\n        self.dist_info_path = \"{}.dist-info\".format(\n            self.parsed_filename.group(\"namever\")\n        )\n        self.record_path = self.dist_info_path + \"/RECORD\"\n        self._file_hashes: dict[str, tuple[None, None] | tuple[int, bytes]] = {}\n        self._file_sizes = {}\n        if mode == \"r\":\n            # Ignore RECORD and any embedded wheel signatures\n            self._file_hashes[self.record_path] = None, None\n            self._file_hashes[self.record_path + \".jws\"] = None, None\n            self._file_hashes[self.record_path + \".p7s\"] = None, None\n\n            # Fill in the expected hashes by reading them from RECORD\n            try:\n                record = self.open(self.record_path)\n            except KeyError:\n                raise WheelError(f\"Missing {self.record_path} file\") from None\n\n            with record:\n                for line in csv.reader(\n                    TextIOWrapper(record, newline=\"\", encoding=\"utf-8\")\n                ):\n                    path, hash_sum, size = line\n                    if not hash_sum:\n                        continue\n\n                    algorithm, hash_sum = hash_sum.split(\"=\")\n                    try:\n                        hashlib.new(algorithm)\n                    except ValueError:\n                        raise WheelError(\n                            f\"Unsupported hash algorithm: {algorithm}\"\n                        ) from None\n\n                    if algorithm.lower() in {\"md5\", \"sha1\"}:\n                        raise WheelError(\n                            f\"Weak hash algorithm ({algorithm}) is not permitted by \"\n                            f\"PEP 427\"\n                        )\n\n                    self._file_hashes[path] = (\n                        algorithm,\n                        urlsafe_b64decode(hash_sum.encode(\"ascii\")),\n                    )\n\n    def open(\n        self,\n        name_or_info: str | ZipInfo,\n        mode: Literal[\"r\", \"w\"] = \"r\",\n        pwd: bytes | None = None,\n    ) -> IO[bytes]:\n        def _update_crc(newdata: bytes) -> None:\n            eof = ef._eof\n            update_crc_orig(newdata)\n            running_hash.update(newdata)\n            if eof and running_hash.digest() != expected_hash:\n                raise WheelError(f\"Hash mismatch for file '{ef_name}'\")\n\n        ef_name = (\n            name_or_info.filename if isinstance(name_or_info, ZipInfo) else name_or_info\n        )\n        if (\n            mode == \"r\"\n            and not ef_name.endswith(\"/\")\n            and ef_name not in self._file_hashes\n        ):\n            raise WheelError(f\"No hash found for file '{ef_name}'\")\n\n        ef = ZipFile.open(self, name_or_info, mode, pwd)\n        if mode == \"r\" and not ef_name.endswith(\"/\"):\n            algorithm, expected_hash = self._file_hashes[ef_name]\n            if expected_hash is not None:\n                # Monkey patch the _update_crc method to also check for the hash from\n                # RECORD\n                running_hash = hashlib.new(algorithm)\n                update_crc_orig, ef._update_crc = ef._update_crc, _update_crc\n\n        return ef\n\n    def write_files(self, base_dir: str):\n        log.info(f\"creating '{self.filename}' and adding '{base_dir}' to it\")\n        deferred: list[tuple[str, str]] = []\n        for root, dirnames, filenames in os.walk(base_dir):\n            # Sort the directory names so that `os.walk` will walk them in a\n            # defined order on the next iteration.\n            dirnames.sort()\n            for name in sorted(filenames):\n                path = os.path.normpath(os.path.join(root, name))\n                if os.path.isfile(path):\n                    arcname = os.path.relpath(path, base_dir).replace(os.path.sep, \"/\")\n                    if arcname == self.record_path:\n                        pass\n                    elif root.endswith(\".dist-info\"):\n                        deferred.append((path, arcname))\n                    else:\n                        self.write(path, arcname)\n\n        deferred.sort()\n        for path, arcname in deferred:\n            self.write(path, arcname)\n\n    def write(\n        self,\n        filename: str,\n        arcname: str | None = None,\n        compress_type: int | None = None,\n    ) -> None:\n        with open(filename, \"rb\") as f:\n            st = os.fstat(f.fileno())\n            data = f.read()\n\n        zinfo = ZipInfo(\n            arcname or filename, date_time=get_zipinfo_datetime(st.st_mtime)\n        )\n        zinfo.external_attr = (stat.S_IMODE(st.st_mode) | stat.S_IFMT(st.st_mode)) << 16\n        zinfo.compress_type = compress_type or self.compression\n        self.writestr(zinfo, data, compress_type)\n\n    def writestr(\n        self,\n        zinfo_or_arcname: str | ZipInfo,\n        data: SizedBuffer | str,\n        compress_type: int | None = None,\n    ):\n        if isinstance(zinfo_or_arcname, str):\n            zinfo_or_arcname = ZipInfo(\n                zinfo_or_arcname, date_time=get_zipinfo_datetime()\n            )\n            zinfo_or_arcname.compress_type = self.compression\n            zinfo_or_arcname.external_attr = (0o664 | stat.S_IFREG) << 16\n\n        if isinstance(data, str):\n            data = data.encode(\"utf-8\")\n\n        ZipFile.writestr(self, zinfo_or_arcname, data, compress_type)\n        fname = (\n            zinfo_or_arcname.filename\n            if isinstance(zinfo_or_arcname, ZipInfo)\n            else zinfo_or_arcname\n        )\n        log.info(f\"adding '{fname}'\")\n        if fname != self.record_path:\n            hash_ = self._default_algorithm(data)\n            self._file_hashes[fname] = (\n                hash_.name,\n                urlsafe_b64encode(hash_.digest()).decode(\"ascii\"),\n            )\n            self._file_sizes[fname] = len(data)\n\n    def close(self):\n        # Write RECORD\n        if self.fp is not None and self.mode == \"w\" and self._file_hashes:\n            data = StringIO()\n            writer = csv.writer(data, delimiter=\",\", quotechar='\"', lineterminator=\"\\n\")\n            writer.writerows(\n                (\n                    (fname, algorithm + \"=\" + hash_, self._file_sizes[fname])\n                    for fname, (algorithm, hash_) in self._file_hashes.items()\n                )\n            )\n            writer.writerow((format(self.record_path), \"\", \"\"))\n            self.writestr(self.record_path, data.getvalue())\n\n        ZipFile.close(self)\n"},{"path":".upm/store.json","size":147,"sha1":"954e912f2af5cbf21dbbf21051f8d4e91b81791c","mtime":1754843078,"is_binary":false,"encoding":"utf-8","content":"{\"version\":2,\"languages\":{\"python3-poetry\":{\"specfileHash\":\"4d328ae8354b056cd3301858e49736a8\",\"lockfileHash\":\"910731419f6ccfe890a5c5b74fca342a\"}}}\n"},{"path":"age_index_cleaner.py","size":3081,"sha1":"139ae2fb04fd2a7332fc990900d26bd52fa281dc","mtime":1755104694,"is_binary":false,"encoding":"utf-8","content":"# -*- coding: utf-8 -*-\nimport json, os, re, unicodedata\nfrom typing import Tuple\n\nREF_YEAR = int(os.getenv(\"REF_YEAR\", \"2025\"))\nIN_PATH  = os.getenv(\"AGE_INDEX_PATH\", \"./data/age_index.json\")\nOUT_PATH = os.getenv(\"AGE_INDEX_CLEANED_PATH\", \"./data/age_index.cleaned.json\")\n\ndef strip_accents(s: str) -> str:\n    s = unicodedata.normalize(\"NFKD\", s)\n    return \"\".join(c for c in s if not unicodedata.combining(c))\n\ndef norm_text(s: str) -> str:\n    if not s: return \"\"\n    s = strip_accents(s).lower()\n    s = re.sub(r\"\\b(f\\.?c\\.?|a\\.?c\\.?|u\\.?s\\.?|ssd|ss|ssc|ud|spa|calcio|club|1907|1913|1919|1927|1909|1905)\\b\",\" \",s)\n    s = s.replace(\".\", \" \").replace(\"-\", \" \")\n    s = re.sub(r\"[^a-z0-9\\s]\", \" \", s)\n    s = re.sub(r\"\\s+\", \" \", s).strip()\n    aliases = {\n        \"juventus fc\":\"juventus\",\"juventus\":\"juventus\",\"juve\":\"juventus\",\n        \"inter\":\"inter\",\"internazionale\":\"inter\",\"inter milano\":\"inter\",\n        \"milan\":\"milan\",\"ac milan\":\"milan\",\n        \"napoli\":\"napoli\",\"ssc napoli\":\"napoli\",\n        \"lazio\":\"lazio\",\"ss lazio\":\"lazio\",\n        \"roma\":\"roma\",\"as roma\":\"roma\",\n        \"atalanta bc\":\"atalanta\",\"atalanta\":\"atalanta\",\n        \"bologna fc\":\"bologna\",\"bologna\":\"bologna\",\n        \"udinese calcio\":\"udinese\",\"udinese\":\"udinese\",\n        \"acf fiorentina\":\"fiorentina\",\"fiorentina\":\"fiorentina\",\n        \"torino fc\":\"torino\",\"torino\":\"torino\",\n        \"hellas verona\":\"verona\",\"verona\":\"verona\",\n        \"genoa\":\"genoa\",\"como\":\"como\",\"monza\":\"monza\",\n        \"sassuolo\":\"sassuolo\",\"lecce\":\"lecce\",\"empoli\":\"empoli\",\n        \"cagliari\":\"cagliari\",\"parma\":\"parma\",\"venezia fc\":\"venezia\",\"venezia\":\"venezia\",\n        \"cremonese\":\"cremonese\",\"bari\":\"bari\",\n        \"como 1907\":\"como\",\"pisa sporting club\":\"pisa\",\n        \"football club torinese\":\"torino\",\n        \"unione sportiva internazionale napoli\":\"napoli\",\n        \"alba roma 1907\":\"roma\",\n    }\n    return aliases.get(s, s)\n\ndef split_key(k: str) -> Tuple[str,str]:\n    if \"@@\" in k:\n        a,b = k.split(\"@@\",1)\n    elif \"|\" in k:\n        a,b = k.split(\"|\",1)\n    else:\n        a,b = k,\"\"\n    return norm_text(a), norm_text(b)\n\ndef valid_by(x) -> int|None:\n    try:\n        x = int(x)\n    except:\n        return None\n    if x < 1900 or x > REF_YEAR: return None\n    if x > REF_YEAR-14: return None\n    return x\n\ndef main():\n    if not os.path.exists(IN_PATH):\n        print(f\"❌ file non trovato: {IN_PATH}\")\n        return\n    raw = json.load(open(IN_PATH,\"r\",encoding=\"utf-8\"))\n    if not isinstance(raw, dict):\n        print(\"❌ age_index deve essere un dict { 'name@@team': birth_year | {'birth_year':...} }\")\n        return\n    out = {}\n    bad = 0\n    for k, v in raw.items():\n        by = v.get(\"birth_year\") if isinstance(v, dict) else v\n        by = valid_by(by)\n        if by is None:\n            bad += 1\n            continue\n        nn, tn = split_key(k)\n        out[f\"{nn}@@{tn}\"] = by\n    json.dump(out, open(OUT_PATH,\"w\",encoding=\"utf-8\"), ensure_ascii=False, indent=2)\n    print(f\"✅ salvato {OUT_PATH} con {len(out)} righe pulite (scartate {bad})\")\n\nif __name__ == \"__main__\":\n    main()\n"},{"path":"app_changes.json","size":53623,"sha1":"8c63e45aff90af3debf2eb3000b2754bb3c2ef5b","mtime":1755447286,"is_binary":false,"encoding":"utf-8","content":"{\"generated_at\":\"2025-08-17T16:14:46.073284Z\",\"root\":\"/home/runner/workspace\",\"git\":{\"head\":\"7b7135163eb4227ef98e4c2d7b4ab78ea306bd73\",\"branch\":\"main\",\"status\":\" M corrections.db\\n?? export_changes.py\\n\"},\"filters\":{\"git_range\":null,\"since\":null,\"include_ext\":[\".cfg\",\".css\",\".env\",\".htm\",\".html\",\".ini\",\".jinja\",\".jinja2\",\".js\",\".json\",\".md\",\".py\",\".toml\",\".ts\",\".yaml\",\".yml\"],\"exclude_dirs\":[\".git\",\".ipynb_checkpoints\",\".mypy_cache\",\".pytest_cache\",\".pythonlibs\",\".venv\",\"__pycache__\",\"cache\",\"chroma_db\",\"data/exports\",\"node_modules\",\"venv\"],\"exclude_globs\":[\"*.bmp\",\"*.db\",\"*.feather\",\"*.gif\",\"*.gz\",\"*.ico\",\"*.jpeg\",\"*.jpg\",\"*.jsonl\",\"*.lock\",\"*.log\",\"*.parquet\",\"*.png\",\"*.sqlite\",\"*.sqlite3\",\"*.tar\",\"*.webp\",\"*.zip\"],\"max_file_bytes\":400000},\"summary\":{\"file_count\":2,\"total_bytes\":41075},\"files\":[{\"path\":\"corrections.db\",\"size\":32768,\"sha1\":\"b29e2c16e1c67eb115074ecf9b59e3f883187951\",\"mtime\":1755447066,\"is_binary\":true,\"encoding\":\"base64\",\"content_b64\":\"U1FMaXRlIGZvcm1hdCAzABAAAQEAQCAgAAAAJwAAAAgAAAAAAAAAAAAAABcAAAAEAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAnAC6KEQ0IOwAHA3EADXILlAnlCEMGIQf+A3EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACFLQgHFyMjAYohdGFibGVjb3JyZWN0aW9uc2NvcnJlY3Rpb25zAkNSRUFURSBUQUJMRSBjb3JyZWN0aW9ucyAoCiAgICAgICAgICAgICAgICAgICAgICAgIGlkIElOVEVHRVIgUFJJTUFSWSBLRVkgQVVUT0lOQ1JFTUVOVCwKICAgICAgICAgICAgICAgICAgICAgICAgcGxheWVyX25hbWUgVEVYVCBOT1QgTlVMTCwKICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVjdGlvbl90eXBlIFRFWFQgTk9UIE5VTEwsCiAgICAgICAgICAgICAgICAgICAgICAgIG9sZF92YWx1ZSBURVhULAogICAgICAgICAgICAgICAgICAgICAgICBuZXdfdmFsdWUgVEVYVCBOT1QgTlVMTCwKICAgICAgICAgICAgICAgICAgICAgICAgc2Vhc29uIFRFWFQgREVGQVVMVCAnMjAyNC0yNScsCiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNpc3RlbnQgQk9PTEVBTiBERUZBVUxUIFRSVUUsCiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZWQgQk9PTEVBTiBERUZBVUxUIEZBTFNFLAogICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAgREFURVRJTUUgREVGQVVMVCBDVVJSRU5UX1RJTUVTVEFNUCwKICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uIFRFWFQsCiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQgVElNRVNUQU1QIERFRkFVTFQgQ1VSUkVOVF9USU1FU1RBTVAKICAgICAgICAgICAgICAgICAgICApg1oGBxcpKQGGb3RhYmxlYWN0aXZlX3BsYXllcnNhY3RpdmVfcGxheWVycwdDUkVBVEUgVEFCTEUgYWN0aXZlX3BsYXllcnMgKAogICAgICAgICAgICAgICAgICAgICAgICBpZCBJTlRFR0VSIFBSSU1BUlkgS0VZIEFVVE9JTkNSRU1FTlQsCiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllcl9uYW1lIFRFWFQgTk9UIE5VTEwgVU5JUVVFLAogICAgICAgICAgICAgICAgICAgICAgICB0ZWFtIFRFWFQgTk9UIE5VTEwsCiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGUgVEVYVCwKICAgICAgICAgICAgICAgICAgICAgICAgc2Vhc29uIFRFWFQgREVGQVVMVCAnMjAyNC0yNScsCiAgICAgICAgICAgICAgICAgICAgICAgIGlzX2FjdGl2ZSBCT09MRUFOIERFRkFVTFQgVFJVRSwKICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF91cGRhdGVkIERBVEVUSU1FIERFRkFVTFQgQ1VSUkVOVF9USU1FU1RBTVAKICAgICAgICAgICAgICAgICAgICApOwcGF08pAQBpbmRleHNxbGl0ZV9hdXRvaW5kZXhfYWN0aXZlX3BsYXllcnNfMWFjdGl2ZV9wbGF5ZXJzCA3EAAgAAAAAgx8FBxcjIwGGBXRhYmxlZGF0YV9pc3N1ZXNkYXRhX2lzc3VlcwZDUkVBVEUgVEFCTEUgZGF0YV9pc3N1ZXMgKAogICAgICAgICAgICAgICAgICAgICAgICBpZCBJTlRFR0VSIFBSSU1BUlkgS0VZIEFVVE9JTkNSRU1FTlQsCiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlX3R5cGUgVEVYVCBOT1QgTlVMTCwKICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gVEVYVCwKICAgICAgICAgICAgICAgICAgICAgICAgc2V2ZXJpdHkgVEVYVCBERUZBVUxUICdtZWRpdW0nLAogICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgVEVYVCBERUZBVUxUICdvcGVuJywKICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZF9hdCBEQVRFVElNRSBERUZBVUxUIENVUlJFTlRfVElNRVNUQU1QCiAgICAgICAgICAgICAgICAgICAgKYMsBAcXLy8Bhgd0YWJsZXJlc3BvbnNlX3BhdHRlcm5zcmVzcG9uc2VfcGF0dGVybnMFQ1JFQVRFIFRBQkxFIHJlc3BvbnNlX3BhdHRlcm5zICgKICAgICAgICAgICAgICAgIGlkIElOVEVHRVIgUFJJTUFSWSBLRVkgQVVUT0lOQ1JFTUVOVCwKICAgICAgICAgICAgICAgIHBhdHRlcm5fdGV4dCBURVhUIE5PVCBOVUxMLAogICAgICAgICAgICAgICAgcGF0dGVybl90eXBlIFRFWFQgTk9UIE5VTEwsCiAgICAgICAgICAgICAgICByZXBsYWNlbWVudF90ZXh0IFRFWFQgTk9UIE5VTEwsCiAgICAgICAgICAgICAgICByZWdleF9wYXR0ZXJuIFRFWFQsCiAgICAgICAgICAgICAgICBjcmVhdGVkX2F0IFRJTUVTVEFNUCBERUZBVUxUIENVUlJFTlRfVElNRVNUQU1QLAogICAgICAgICAgICAgICAgc3RhdHVzIFRFWFQgREVGQVVMVCAnYWN0aXZlJwogICAgICAgICAgICApg1sDBxcxMQGGYXRhYmxlcGxheWVyX2NvcnJlY3Rpb25zcGxheWVyX2NvcnJlY3Rpb25zBENSRUFURSBUQUJMRSBwbGF5ZXJfY29ycmVjdGlvbnMgKAogICAgICAgICAgICAgICAgaWQgSU5URUdFUiBQUklNQVJZIEtFWSBBVVRPSU5DUkVNRU5ULAogICAgICAgICAgICAgICAgcGxheWVyX25hbWUgVEVYVCBOT1QgTlVMTCwKICAgICAgICAgICAgICAgIGZpZWxkX25hbWUgVEVYVCBOT1QgTlVMTCwKICAgICAgICAgICAgICAgIG9sZF92YWx1ZSBURVhULAogICAgICAgICAgICAgICAgbmV3X3ZhbHVlIFRFWFQgTk9UIE5VTEwsCiAgICAgICAgICAgICAgICByZWFzb24gVEVYVCwKICAgICAgICAgICAgICAgIHNvdXJjZSBURVhULAogICAgICAgICAgICAgICAgY3JlYXRlZF9hdCBUSU1FU1RBTVAgREVGQVVMVCBDVVJSRU5UX1RJTUVTVEFNUCwKICAgICAgICAgICAgICAgIHN0YXR1cyBURVhUIERFRkFVTFQgJ2FjdGl2ZScKICAgICAgICAgICAgKVACBhcrKwFZdGFibGVzcWxpdGVfc2VxdWVuY2VzcWxpdGVfc2VxdWVuY2UDQ1JFQVRFIFRBQkxFIHNxbGl0ZV9zZXF1ZW5jZShuYW1lLHNlcSkAAAI8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0AAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAg/bAA/vD9sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAgMpAWFjdGl2ZV9wbGF5ZXJzAg8BAyMBZGF0YV9pc3N1ZXMODQAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0AAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAAAADgnuAA+aDysOuQ5IDd0NcAz3DJEMIguwCz8K1ApnCe4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdw4IACmBGRUVM1BMQVlFUl9SRU1PVkFMUGxheWVyIEtodmljaGEgS3ZhcmF0c2toZWxpYSByZW1vdmVkOiBUcmFuc2ZlcnJlZCB0byBQU0cgKG5vbi1TZXJpZSBBKWhpZ2hvcGVuMjAyNS0wOC0xNCAxODowNDozM2sNCAApgQEVFTNQTEFZRVJfUkVNT1ZBTFBsYXllciBEYXZpZGUgQ2FsYWJyaWEgcmVtb3ZlZDogT3V0ZGF0ZWQvaW5jb25zaXN0ZW50IGRhdGFoaWdob3BlbjIwMjUtMDgtMTQgMTg6MDQ6MjJpDAcAKX8VFTNQTEFZRVJfUkVNT1ZBTFBsYXllciBNaWxhbiBTa3JpbmlhciByZW1vdmVkOiBQbGF5cyBmb3IgUFNHLCBub3QgU2VyaWUgQWhpZ2hvcGVuMjAyNS0wOC0xNCAxODowNDoyMm8LCAApgQkVFTNQTEFZRVJfUkVNT1ZBTFBsYXllciBNYXJjbyBTaWx2ZXN0cmkgcmVtb3ZlZDogTm90IGZpcnN0IGNob2ljZS9vdXRkYXRlZCBkYXRhaGlnaG9wZW4yMDI1LTA4LTE0IDE4OjA0OjIycAoIACmBCxUVM1BMQVlFUl9SRU1PVkFMUGxheWVyIEdpYW5sdWlnaSBEb25uYXJ1bW1hIHJlbW92ZWQ6IFBsYXlzIGZvciBQU0csIG5vdCBTZXJpZSBBaGlnaG9wZW4yMDI1LTA4LTE0IDE4OjA0OjIybQkIACmBBRUVM1BMQVlFUl9SRU1PVkFMUGxheWVyIFdvamNpZWNoIFN6Y3plc255IHJlbW92ZWQ6IFRyYW5zZmVycmVkL25vdCBpbiBTZXJpZSBBaGlnaG9wZW4yMDI1LTA4LTE0IDE4OjA0OjIyZAgHACl1FRUzUExBWUVSX1JFTU9WQUxQbGF5ZXIgU2FtaXIgSGFuZGFub3ZpYyByZW1vdmVkOiBSZXRpcmVkL25vdCBwbGF5aW5naGlnaG9wZW4yMDI1LTA4LTE0IDE4OjA0OjIydwcIACmBGRUVM1BMQVlFUl9SRU1PVkFMUGxheWVyIEtodmljaGEgS3ZhcmF0c2toZWxpYSByZW1vdmVkOiBUcmFuc2ZlcnJlZCB0byBQU0cgKG5vbi1TZXJpZSBBKWhpZ2hvcGVuMjAyNS0wOC0xNCAxODowMzo0OGsGCAApgQEVFTNQTEFZRVJfUkVNT1ZBTFBsYXllciBEYXZpZGUgQ2FsYWJyaWEgcmVtb3ZlZDogT3V0ZGF0ZWQvaW5jb25zaXN0ZW50IGRhdGFoaWdob3BlbjIwMjUtMDgtMTQgMTg6MDM6NDhpBQcAKX8VFTNQTEFZRVJfUkVNT1ZBTFBsYXllciBNaWxhbiBTa3JpbmlhciByZW1vdmVkOiBQbGF5cyBmb3IgUFNHLCBub3QgU2VyaWUgQWhpZ2hvcGVuMjAyNS0wOC0xNCAxODowMzo0OG8ECAApgQkVFTNQTEFZRVJfUkVNT1ZBTFBsYXllciBNYXJjbyBTaWx2ZXN0cmkgcmVtb3ZlZDogTm90IGZpcnN0IGNob2ljZS9vdXRkYXRlZCBkYXRhaGlnaG9wZW4yMDI1LTA4LTE0IDE4OjAzOjQ4cAMIACmBCxUVM1BMQVlFUl9SRU1PVkFMUGxheWVyIEdpYW5sdWlnaSBEb25uYXJ1bW1hIHJlbW92ZWQ6IFBsYXlzIGZvciBQU0csIG5vdCBTZXJpZSBBaGlnaG9wZW4yMDI1LTA4LTE0IDE4OjAzOjQ4bQIIACmBBRUVM1BMQVlFUl9SRU1PVkFMUGxheWVyIFdvamNpZWNoIFN6Y3plc255IHJlbW92ZWQ6IFRyYW5zZmVycmVkL25vdCBpbiBTZXJpZSBBaGlnaG9wZW4yMDI1LTA4LTE0IDE4OjAzOjQ4ZAEHACl1FRUzUExBWUVSX1JFTU9WQUxQbGF5ZXIgU2FtaXIgSGFuZGFub3ZpYyByZW1vdmVkOiBSZXRpcmVkL25vdCBwbGF5aW5naGlnaG9wZW4yMDI1LTA4LTE0IDE4OjAzOjQ4DQAAAAEPywAPywAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAzAggAJxUAGwkzQWx2YXJvIE1vcmF0YUNvbW8yMDI0LTI1MjAyNS0wOC0xNCAxODowNDozMwoAAAABD+4AD+4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARAycBQWx2YXJvIE1vcmF0YQI=\"},{\"path\":\"export_changes.py\",\"size\":8307,\"sha1\":\"e24ac904aafec91ecde560e3e38bfe9105e172a0\",\"mtime\":1755447231,\"is_binary\":false,\"encoding\":\"utf-8\",\"content\":\"# export_changes.py\\n# Create a compact JSON payload of changed files in your repo.\\n# Works with or without git; can split output to multiple JSON parts if large.\\n\\nimport os, sys, json, base64, hashlib, argparse, subprocess, shlex, time, datetime\\nfrom pathlib import Path\\n\\nDEFAULT_INCLUDE_EXT = {\\n    \\\".py\\\",\\\".html\\\",\\\".htm\\\",\\\".js\\\",\\\".ts\\\",\\\".css\\\",\\\".json\\\",\\\".yml\\\",\\\".yaml\\\",\\n    \\\".jinja\\\",\\\".jinja2\\\",\\\".env\\\",\\\".ini\\\",\\\".cfg\\\",\\\".toml\\\",\\\".md\\\"\\n}\\nDEFAULT_EXCLUDE_DIRS = {\\n    \\\".git\\\",\\\"node_modules\\\",\\\".venv\\\",\\\"venv\\\",\\\"__pycache__\\\",\\\".mypy_cache\\\",\\n    \\\".pytest_cache\\\",\\\".ipynb_checkpoints\\\",\\\".pythonlibs\\\",\\\"chroma_db\\\",\\\"cache\\\",\\\"data/exports\\\"\\n}\\nDEFAULT_EXCLUDE_GLOBS = {\\n    \\\"*.png\\\",\\\"*.jpg\\\",\\\"*.jpeg\\\",\\\"*.webp\\\",\\\"*.gif\\\",\\\"*.bmp\\\",\\\"*.ico\\\",\\n    \\\"*.db\\\",\\\"*.sqlite\\\",\\\"*.sqlite3\\\",\\\"*.parquet\\\",\\\"*.feather\\\",\\n    \\\"*.jsonl\\\",\\\"*.log\\\",\\\"*.lock\\\",\\\"*.zip\\\",\\\"*.tar\\\",\\\"*.gz\\\"\\n}\\n\\ndef sha1_bytes(b: bytes) -> str:\\n    h = hashlib.sha1(); h.update(b); return h.hexdigest()\\n\\ndef is_text_bytes(b: bytes) -> bool:\\n    # naive but effective: try utf-8\\n    try:\\n        b.decode(\\\"utf-8\\\")\\n        return True\\n    except UnicodeDecodeError:\\n        return False\\n\\ndef git_available() -> bool:\\n    try:\\n        subprocess.check_output([\\\"git\\\",\\\"rev-parse\\\",\\\"--is-inside-work-tree\\\"], stderr=subprocess.DEVNULL)\\n        return True\\n    except Exception:\\n        return False\\n\\ndef run(cmd: str) -> str:\\n    return subprocess.check_output(shlex.split(cmd), stderr=subprocess.DEVNULL).decode(\\\"utf-8\\\", \\\"ignore\\\")\\n\\ndef list_changed_with_git(git_range: str|None) -> list[str]:\\n    # Priority 1: explicit range (origin/main...HEAD, HEAD~20..HEAD, etc.)\\n    if git_range:\\n        out = run(f\\\"git diff --name-only {git_range}\\\")\\n        files = [p.strip() for p in out.splitlines() if p.strip()]\\n        if files:\\n            return files\\n    # Priority 2: unstaged + untracked\\n    out = run(\\\"git ls-files -m -o --exclude-standard\\\")\\n    files = [p.strip() for p in out.splitlines() if p.strip()]\\n    return files\\n\\ndef looks_excluded(path: Path, exclude_dirs: set[str], exclude_globs: set[str]) -> bool:\\n    parts = set(p.lower() for p in path.parts)\\n    if any(d.lower() in parts for d in exclude_dirs):\\n        return True\\n    name = path.name.lower()\\n    for pat in exclude_globs:\\n        if Path(name).match(pat):\\n            return True\\n    return False\\n\\ndef fallback_scan(root: Path, since_ts: float | None, include_ext: set[str],\\n                  exclude_dirs: set[str], exclude_globs: set[str]) -> list[str]:\\n    picked: list[str] = []\\n    for p in root.rglob(\\\"*\\\"):\\n        if not p.is_file():\\n            continue\\n        if looks_excluded(p.relative_to(root), exclude_dirs, exclude_globs):\\n            continue\\n        if p.suffix.lower() not in include_ext:\\n            continue\\n        if since_ts is not None:\\n            try:\\n                if p.stat().st_mtime < since_ts:\\n                    continue\\n            except Exception:\\n                continue\\n        picked.append(str(p.relative_to(root)))\\n    return picked\\n\\ndef collect_files(root: Path, rel_paths: list[str], max_file_bytes: int) -> list[dict]:\\n    items = []\\n    for rel in rel_paths:\\n        abs_p = root / rel\\n        try:\\n            b = abs_p.read_bytes()\\n        except Exception:\\n            continue\\n        if len(b) > max_file_bytes:\\n            # skip too large files for chat purposes\\n            continue\\n        meta = {\\n            \\\"path\\\": rel.replace(\\\"\\\\\\\\\\\",\\\"/\\\"),\\n            \\\"size\\\": len(b),\\n            \\\"sha1\\\": sha1_bytes(b),\\n            \\\"mtime\\\": int(abs_p.stat().st_mtime),\\n        }\\n        if is_text_bytes(b):\\n            meta[\\\"is_binary\\\"] = False\\n            meta[\\\"encoding\\\"] = \\\"utf-8\\\"\\n            meta[\\\"content\\\"] = b.decode(\\\"utf-8\\\")\\n        else:\\n            meta[\\\"is_binary\\\"] = True\\n            meta[\\\"encoding\\\"] = \\\"base64\\\"\\n            meta[\\\"content_b64\\\"] = base64.b64encode(b).decode(\\\"ascii\\\")\\n        items.append(meta)\\n    return items\\n\\ndef write_payload(payload: dict, out_path: Path, max_bytes: int|None):\\n    js = json.dumps(payload, ensure_ascii=False, separators=(\\\",\\\",\\\":\\\"))\\n    if max_bytes and len(js.encode(\\\"utf-8\\\")) > max_bytes:\\n        # split into parts\\n        files = payload[\\\"files\\\"]\\n        header = {k:v for k,v in payload.items() if k!=\\\"files\\\"}\\n        parts = []\\n        chunk = []\\n        current = 0\\n        idx = 1\\n        for f in files:\\n            test = json.dumps({\\\"files\\\":[f]}, ensure_ascii=False, separators=(\\\",\\\",\\\":\\\")).encode(\\\"utf-8\\\")\\n            if current + len(test) > max_bytes and chunk:\\n                parts.append(chunk); chunk=[]; current=0\\n            chunk.append(f)\\n            current += len(test)\\n        if chunk:\\n            parts.append(chunk)\\n        written = []\\n        for i,chunk in enumerate(parts, start=1):\\n            part_payload = dict(header); part_payload[\\\"files\\\"] = chunk\\n            part_name = out_path.with_name(out_path.stem + f\\\".part{i}\\\" + out_path.suffix)\\n            part_name.write_text(json.dumps(part_payload, ensure_ascii=False, separators=(\\\",\\\",\\\":\\\")), encoding=\\\"utf-8\\\")\\n            written.append(str(part_name))\\n        return written\\n    else:\\n        out_path.write_text(js, encoding=\\\"utf-8\\\")\\n        return [str(out_path)]\\n\\ndef main():\\n    ap = argparse.ArgumentParser(description=\\\"Export changed app files to JSON.\\\")\\n    ap.add_argument(\\\"--root\\\", default=\\\".\\\", help=\\\"Project root\\\")\\n    ap.add_argument(\\\"--git-range\\\", default=None, help=\\\"Git diff range, e.g. origin/main...HEAD\\\")\\n    ap.add_argument(\\\"--since\\\", default=None, help=\\\"Only include files modified since ISO time (e.g. 2025-08-13T00:00:00)\\\")\\n    ap.add_argument(\\\"--max-file-bytes\\\", type=int, default=400_000, help=\\\"Skip any single file larger than this\\\")\\n    ap.add_argument(\\\"--max-json-bytes\\\", type=int, default=900_000, help=\\\"Split JSON into parts under this size (UTF-8 bytes)\\\")\\n    ap.add_argument(\\\"--include-ext\\\", default=\\\",\\\".join(sorted(DEFAULT_INCLUDE_EXT)))\\n    ap.add_argument(\\\"--exclude-dirs\\\", default=\\\",\\\".join(sorted(DEFAULT_EXCLUDE_DIRS)))\\n    ap.add_argument(\\\"--exclude-globs\\\", default=\\\",\\\".join(sorted(DEFAULT_EXCLUDE_GLOBS)))\\n    ap.add_argument(\\\"--out\\\", default=\\\"app_changes.json\\\", help=\\\"Output JSON (or prefix for parts)\\\")\\n    args = ap.parse_args()\\n\\n    root = Path(args.root).resolve()\\n    include_ext = set(s.strip().lower() for s in args.include_ext.split(\\\",\\\") if s.strip())\\n    exclude_dirs = set(s.strip() for s in args.exclude_dirs.split(\\\",\\\") if s.strip())\\n    exclude_globs = set(s.strip() for s in args.exclude_globs.split(\\\",\\\") if s.strip())\\n\\n    since_ts = None\\n    if args.since:\\n        try:\\n            dt = datetime.datetime.fromisoformat(args.since)\\n            since_ts = dt.timestamp()\\n        except Exception:\\n            print(f\\\"Warning: could not parse --since '{args.since}', ignoring.\\\", file=sys.stderr)\\n\\n    if git_available():\\n        rel_paths = list_changed_with_git(args.git_range)\\n    else:\\n        rel_paths = []\\n\\n    if not rel_paths:\\n        # fallback scan (recent or by extension)\\n        rel_paths = fallback_scan(root, since_ts, include_ext, exclude_dirs, exclude_globs)\\n\\n    rel_paths = sorted(set(rel_paths))\\n    files = collect_files(root, rel_paths, args.max_file_bytes)\\n\\n    git_info = {}\\n    if git_available():\\n        try:\\n            git_info[\\\"head\\\"] = run(\\\"git rev-parse HEAD\\\").strip()\\n            git_info[\\\"branch\\\"] = run(\\\"git rev-parse --abbrev-ref HEAD\\\").strip()\\n            git_info[\\\"status\\\"] = run(\\\"git status --porcelain\\\")\\n        except Exception:\\n            pass\\n\\n    payload = {\\n        \\\"generated_at\\\": datetime.datetime.utcnow().isoformat() + \\\"Z\\\",\\n        \\\"root\\\": str(root),\\n        \\\"git\\\": git_info,\\n        \\\"filters\\\": {\\n            \\\"git_range\\\": args.git_range,\\n            \\\"since\\\": args.since,\\n            \\\"include_ext\\\": sorted(include_ext),\\n            \\\"exclude_dirs\\\": sorted(exclude_dirs),\\n            \\\"exclude_globs\\\": sorted(exclude_globs),\\n            \\\"max_file_bytes\\\": args.max_file_bytes\\n        },\\n        \\\"summary\\\": {\\n            \\\"file_count\\\": len(files),\\n            \\\"total_bytes\\\": sum(f[\\\"size\\\"] for f in files)\\n        },\\n        \\\"files\\\": files\\n    }\\n\\n    out_path = (Path.cwd() / args.out).resolve()\\n    written = write_payload(payload, out_path, args.max_json_bytes)\\n    kb = payload[\\\"summary\\\"][\\\"total_bytes\\\"]/1024.0\\n    print(f\\\"✓ Exported {len(files)} files ({kb:.1f} KB payload) ->\\\")\\n    for p in written:\\n        print(\\\"   \\\", p)\\n\\nif __name__ == \\\"__main__\\\":\\n    main()\\n\"}]}"},{"path":"app_config.json","size":626,"sha1":"458ce8ca4c47183abfd7ab883839e4190210ef50","mtime":1754932833,"is_binary":false,"encoding":"utf-8","content":"{\n  \"web_fallback_enabled\": true,\n  \"web_fallback_sources\": [\"wikipedia\"], \n  \"web_fallback_timeout_s\": 6,\n  \"web_fallback_ttl_s\": 86400,\n  \"openai_model_primary\": \"gpt-4o-mini\",\n  \"temperature\": 0.3,\n  \"max_tokens\": 700,\n  \"chroma_collection\": \"fantacalcio_knowledge\"\n}\n{\n  \"openai_model_primary\": \"gpt-4o-mini\",\n  \"openai_model_secondary\": \"gpt-3.5-turbo\", \n  \"temperature\": 0.3,\n  \"max_tokens\": 600,\n  \"web_fallback_enabled\": false,\n  \"web_fallback_sources\": [\"wikipedia\"],\n  \"web_fallback_timeout_s\": 6,\n  \"web_fallback_ttl_s\": 86400,\n  \"response_cache_size\": 50,\n  \"knowledge_base_enabled\": true,\n  \"debug_mode\": false\n}\n"},{"path":"checklist.yaml","size":2287,"sha1":"14bdd9806f36bcd19a0607642fa4433ff569c986","mtime":1754920295,"is_binary":false,"encoding":"utf-8","content":"project: FantaCalcio-AI\nowner: @daviserra3\ngoals:\n  - Risposte accurate, citate e fresche su trasferimenti/infortuni/valori\n  - Confronti giocatori robusti (fuzzy + merge KB/statici)\n  - ETL legale e ripetibile, con validazione e versioning\n\nsprint_1_quick_wins:\n  timeframe: 3-5 giorni\n  tasks:\n    - Blocca scritture durante le richieste (ALLOW_KB_WRITES=false in prod)\n    - Patch Chroma 'where' only-if-present\n    - Merge REAL+STATIC per /api/compare con normalizzazione cognomi/diacritici\n    - Fallback “Non so + Aggiorna dati ora” se RAG povero\n  acceptance:\n    - 0 warning \"Add of existing embedding ID\" durante /api/compare\n    - 95% dei confronti di 20 duelli comuni trovano entrambi i giocatori\n  metrics:\n    - cache_hit_rate >= 60%\n    - % risposte con citazioni >= 90%\n\nsprint_2_retrieval:\n  timeframe: 1 settimana\n  tasks:\n    - Hybrid retrieval (BM25 + e5) + re-ranker cross-encoder (top-50 → top-8)\n    - Query-rewrite per intent (transfer/injury/value/fixtures)\n    - Filtri freschezza: valid_to >= today; season match\n  acceptance:\n    - MRR@10 +15% su suite di test\n    - Latency P95 < 2.5s (senza web fallback)\n\nsprint_3_data_etl_legale:\n  timeframe: 1 settimana\n  tasks:\n    - ETL lega/squadra idempotente (JSONL per lega; checksum)\n    - Metadati uniformi: {type, season, league, team, player, source_url, source_date, valid_from, valid_to}\n    - Rifiuto documenti stantii (trasferimenti > 8 settimane)\n  acceptance:\n    - `manage.py etl league --league \"Serie A\" --season 2025-26` gira senza errori\n    - 0 record con metadata None\n\nsprint_4_ui_compare_chat:\n  timeframe: 3-5 giorni\n  tasks:\n    - /api/compare: filtri ?role=&season=&league=; head-to-head + value ratio + risk\n    - UI: chip “duelli popolari”, confidence pill, citazioni con date\n  acceptance:\n    - Tasso di click “vedi fonti” > 30%\n    - Feedback “risposta ripetitiva” < 5%\n\nsprint_5_obs_ops:\n  timeframe: 3-5 giorni\n  tasks:\n    - Logs strutturati + Sentry\n    - /metrics: cache_hit_rate, rag_quality_bucket, web_fallback_rate\n    - Warm-up all’avvio + regression Q&A suite\n  acceptance:\n    - Errori 5xx < 0.5%\n    - Suite test verde su 25 domande canoniche\n\nongoing:\n  - Aggiornare stoplist fuzzy matching e dizionari alias\n  - Manutenzione KB (vacuum/rebuild mensile)\n"},{"path":"config.py","size":2127,"sha1":"22c46f8717b24d170420044020b6ccb2ad64ab33","mtime":1755183422,"is_binary":false,"encoding":"utf-8","content":"# -*- coding: utf-8 -*-\nimport os\nimport logging\n\nLOG = logging.getLogger(\"config\")\n\ndef _load_dotenv(path: str = \".env\"):\n    if not os.path.exists(path):\n        return\n    try:\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            for line in f:\n                line=line.strip()\n                if not line or line.startswith(\"#\"): \n                    continue\n                if \"=\" not in line:\n                    continue\n                k,v = line.split(\"=\",1)\n                k=k.strip(); v=v.strip()\n                if (v.startswith('\"') and v.endswith('\"')) or (v.startswith(\"'\") and v.endswith(\"'\")):\n                    v=v[1:-1]\n                os.environ.setdefault(k, v)\n        LOG.info(\"[config] .env caricato\")\n    except Exception as e:\n        LOG.warning(\"[config] .env non caricato: %s\", e)\n\n_load_dotenv()\n\ndef env_str(key: str, default: str) -> str:\n    return os.environ.get(key, default)\n\ndef env_int(key: str, default: int) -> int:\n    try:\n        return int(os.environ.get(key, str(default)))\n    except Exception:\n        return default\n\ndef env_bool(key: str, default: bool) -> bool:\n    val = os.environ.get(key)\n    if val is None: return default\n    return str(val).strip().lower() in {\"1\",\"true\",\"yes\",\"y\",\"on\"}\n\n# ---- Chiavi unificate ----\nHOST          = env_str(\"HOST\", \"0.0.0.0\")\nPORT          = env_int(\"PORT\", 5000)\nLOG_LEVEL     = env_str(\"LOG_LEVEL\", \"INFO\")\n\nROSTER_JSON_PATH   = env_str(\"ROSTER_JSON_PATH\", \"./season_roster.json\")\nCHROMA_PATH        = env_str(\"CHROMA_PATH\", \"./chroma_db\")\nSEASON_FILTER      = env_str(\"SEASON_FILTER\", \"\")  # se vuoto auto-detect\nREF_YEAR           = env_int(\"REF_YEAR\", 2025)\n\nAGE_INDEX_PATH     = env_str(\"AGE_INDEX_PATH\", \"./data/age_index.cleaned.json\")\nAGE_OVERRIDES_PATH = env_str(\"AGE_OVERRIDES_PATH\", \"./data/age_overrides.json\")\n\nENABLE_WEB_FALLBACK = env_bool(\"ENABLE_WEB_FALLBACK\", False)\n\nOPENAI_API_KEY     = env_str(\"OPENAI_API_KEY\", \"\")\nOPENAI_MODEL       = env_str(\"OPENAI_MODEL\", \"gpt-4o-mini\")\nOPENAI_TEMPERATURE = float(env_str(\"OPENAI_TEMPERATURE\", \"0.20\"))\nOPENAI_MAX_TOKENS  = env_int(\"OPENAI_MAX_TOKENS\", 600)\n"},{"path":"corrections_manager.py","size":30308,"sha1":"5e57f41811c4d9947d52c6771bc395f2b4e81cbd","mtime":1755444169,"is_binary":false,"encoding":"utf-8","content":"import json\nimport logging\nimport re\nimport sqlite3\nimport os\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Any, Tuple\n\nlogger = logging.getLogger(__name__)\n\nclass CorrectionsManager:\n    \"\"\"Enhanced corrections manager with better retrieval and application\"\"\"\n\n    def __init__(self, knowledge_manager=None):\n        self.knowledge_manager = knowledge_manager\n        self._correction_cache = {}  # Cache for faster lookups\n        self.db_path = \"corrections.db\"\n        self._init_db()\n        self.current_season = \"2024-25\"\n\n    def add_correction(self, correction_type: str, incorrect_info: str,\n                      correct_info: str, context: str = None):\n        \"\"\"Add a new correction to the system\"\"\"\n        if not self.knowledge_manager:\n            return \"corrections_disabled\"\n\n        try:\n            correction_text = f\"CORREZIONE: Sostituisci '{incorrect_info}' con '{correct_info}'\"\n            metadata = {\n                \"type\": \"correction\",\n                \"correction_type\": correction_type,\n                \"wrong\": incorrect_info,\n                \"correct\": correct_info,\n                \"context\": context or \"\",\n                \"created_at\": datetime.now().isoformat(),\n                \"priority\": \"high\"\n            }\n\n            # Add to Chroma collection directly\n            import uuid\n            doc_id = str(uuid.uuid4())\n            self.knowledge_manager.collection.add(\n                documents=[correction_text],\n                metadatas=[metadata],\n                ids=[doc_id]\n            )\n\n            # Update cache\n            self._update_correction_cache(incorrect_info, correct_info)\n\n            logger.info(f\"Added correction: {correction_text}\")\n            return doc_id\n        except Exception as e:\n            logger.error(f\"Failed to add correction: {e}\")\n            return None\n\n    def add_player_correction(self, player_name: str, field_name: str,\n                            old_value: str, new_value: str, reason: str = None):\n        \"\"\"Add a player-specific correction\"\"\"\n        return self.add_correction(\n            \"player_data\",\n            f\"{player_name} {field_name}: {old_value}\",\n            f\"{player_name} {field_name}: {new_value}\",\n            reason\n        )\n\n    def _update_correction_cache(self, wrong_info: str, correct_info: str):\n        \"\"\"Update internal cache for fast correction lookup\"\"\"\n        # Extract player names and teams for caching\n        players = re.findall(r'\\b[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*\\b', wrong_info + \" \" + correct_info)\n        for player in players:\n            if len(player) > 3:  # Avoid short words\n                self._correction_cache[player.lower()] = {\n                    \"wrong\": wrong_info,\n                    \"correct\": correct_info,\n                    \"timestamp\": datetime.now().isoformat()\n                }\n\n    def get_relevant_corrections(self, query: str, limit: int = 10) -> List[Dict]:\n        \"\"\"Get corrections relevant to the query\"\"\"\n        if not self.knowledge_manager:\n            return []\n\n        try:\n            # Search for corrections related to the query\n            where_filter = {\n                \"$and\": [\n                    {\"type\": {\"$eq\": \"correction\"}},\n                    {\"priority\": {\"$eq\": \"high\"}}\n                ]\n            }\n\n            results = self.knowledge_manager.search_knowledge(\n                text=query,\n                where=where_filter,\n                n_results=limit,\n                include=[\"documents\", \"metadatas\"]\n            )\n\n            corrections = []\n            if results and \"metadatas\" in results:\n                metadatas = results[\"metadatas\"]\n                documents = results.get(\"documents\", [])\n\n                # Handle both single query and multiple query results\n                if isinstance(metadatas[0], list):\n                    metadatas = metadatas[0]\n                    documents = documents[0] if documents else []\n\n                for i, metadata in enumerate(metadatas):\n                    if metadata and metadata.get(\"type\") == \"correction\":\n                        correction = {\n                            \"wrong\": metadata.get(\"wrong\", \"\"),\n                            \"correct\": metadata.get(\"correct\", \"\"),\n                            \"context\": metadata.get(\"context\", \"\"),\n                            \"created_at\": metadata.get(\"created_at\", \"\"),\n                            \"document\": documents[i] if i < len(documents) else \"\"\n                        }\n                        corrections.append(correction)\n\n            return corrections\n\n        except Exception as e:\n            logger.error(f\"Failed to get relevant corrections: {e}\")\n            return []\n\n    def apply_corrections_to_text(self, text: str) -> Tuple[str, List[str]]:\n        \"\"\"Apply stored corrections to text\"\"\"\n        if not text:\n            return text, []\n\n        corrections = self.get_corrections()\n        if not corrections:\n            return text, []\n\n        corrected_text = text\n        applied_corrections = []\n\n        for correction in corrections:\n            try:\n                wrong = correction.get(\"wrong\", \"\")\n                correct = correction.get(\"correct\", \"\")\n                context = correction.get(\"context\", \"\")\n\n                if not (wrong and correct):\n                    continue\n\n                # Try to extract player and team info from correction fields\n                wrong_info = wrong.strip()\n                correct_info = correct.strip()\n\n                # Extract player name (should be in both wrong and correct)\n                player_match = re.search(r'^(\\w+(?:\\s+\\w+)*)\\s+team:', wrong_info)\n                if not player_match:\n                    continue\n\n                player_name = player_match.group(1).strip()\n\n                # Check if this player appears in the text\n                if player_name.lower() not in corrected_text.lower():\n                    continue\n\n                # Extract old and new team info\n                old_team_match = re.search(r'team:\\s*(.+?)(?:\\s*->|\\s*$)', wrong_info)\n                new_team_match = re.search(r'team:\\s*(.+?)(?:\\s*->|\\s*$)', correct_info)\n\n                if not (old_team_match and new_team_match):\n                    continue\n\n                old_team = old_team_match.group(1).strip()\n                new_team = new_team_match.group(1).strip()\n\n                # Determine the replacement team\n                if new_team in [\"trasferito\", \"nuovo club\", \"nuovo team\"]:\n                    replacement_team = \"nuovo club\"\n                else:\n                    replacement_team = new_team\n\n                # Pattern 1: \"**Player Name** (Team)\" format\n                player_pattern = re.escape(player_name)\n                team_pattern = rf'(\\*\\*{player_pattern}\\*\\*)\\s*\\(([^)]+)\\)'\n\n                def replace_team(match):\n                    player_part = match.group(1)\n                    current_team = match.group(2).strip()\n                    applied_corrections.append(f\"Corrected {player_name}: {current_team} → {replacement_team}\")\n                    return f\"{player_part} ({replacement_team})\"\n\n                # Apply the correction\n                new_text = re.sub(team_pattern, replace_team, corrected_text, flags=re.IGNORECASE)\n                if new_text != corrected_text:\n                    corrected_text = new_text\n                    continue\n\n                # Pattern 2: More general pattern for any team name in parentheses after player\n                general_pattern = rf'({re.escape(player_name)})\\s*\\(([^)]+)\\)'\n\n                def replace_general_team(match):\n                    player_part = match.group(1)\n                    current_team = match.group(2).strip()\n                    applied_corrections.append(f\"Corrected {player_name}: {current_team} → {replacement_team}\")\n                    return f\"{player_part} ({replacement_team})\"\n\n                corrected_text = re.sub(general_pattern, replace_general_team, corrected_text, flags=re.IGNORECASE)\n\n            except Exception as e:\n                logger.error(f\"Error applying single correction: {e}\")\n\n        return corrected_text, applied_corrections\n\n    def get_recent_corrections(self, limit: int = 20) -> List[Dict]:\n        \"\"\"Get most recent corrections\"\"\"\n        if not self.knowledge_manager:\n            return []\n\n        try:\n            where_filter = {\"type\": {\"$eq\": \"correction\"}}\n            results = self.knowledge_manager.search_knowledge(\n                text=None,\n                where=where_filter,\n                n_results=limit,\n                include=[\"metadatas\"]\n            )\n\n            corrections = []\n            if results and \"metadatas\" in results:\n                metadatas = results[\"metadatas\"]\n                # Handle both single query and multiple query results\n                if isinstance(metadatas[0], list):\n                    metadatas = metadatas[0]\n\n                for metadata in metadatas:\n                    if metadata and metadata.get(\"type\") == \"correction\":\n                        corrections.append(metadata)\n\n            # Sort by creation time (most recent first)\n            corrections.sort(\n                key=lambda x: x.get(\"created_at\", \"\"),\n                reverse=True\n            )\n\n            return corrections[:limit]\n\n        except Exception as e:\n            logger.error(f\"Failed to get recent corrections: {e}\")\n            return []\n\n    def search_knowledge(self, query: str, n_results: int = 10):\n        \"\"\"Search corrections using knowledge manager\"\"\"\n        return self.get_relevant_corrections(query, n_results)\n\n    def get_corrections(self, limit: int = 50) -> List[Dict]:\n        \"\"\"Get all corrections\"\"\"\n        return self.get_recent_corrections(limit)\n\n    def _init_db(self):\n        \"\"\"Initialize SQLite database for persistent corrections\"\"\"\n        try:\n            with sqlite3.connect(self.db_path) as conn:\n                # Drop and recreate table to fix schema issues\n                conn.execute(\"DROP TABLE IF EXISTS corrections\")\n                conn.execute(\"\"\"\n                    CREATE TABLE corrections (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        player_name TEXT NOT NULL,\n                        correction_type TEXT NOT NULL,\n                        old_value TEXT,\n                        new_value TEXT NOT NULL,\n                        season TEXT DEFAULT '2024-25',\n                        persistent BOOLEAN DEFAULT TRUE,\n                        applied BOOLEAN DEFAULT FALSE,\n                        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n                        reason TEXT,\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                    )\n                \"\"\")\n                # Data quality issues table\n                conn.execute('''\n                    CREATE TABLE IF NOT EXISTS data_issues (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        issue_type TEXT NOT NULL,\n                        description TEXT,\n                        severity TEXT DEFAULT 'medium',\n                        status TEXT DEFAULT 'open',\n                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n                    )\n                ''')\n                # Current active players table (for quick filtering)\n                conn.execute('''\n                    CREATE TABLE IF NOT EXISTS active_players (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        player_name TEXT NOT NULL UNIQUE,\n                        team TEXT NOT NULL,\n                        role TEXT,\n                        season TEXT DEFAULT '2024-25',\n                        is_active BOOLEAN DEFAULT TRUE,\n                        last_updated DATETIME DEFAULT CURRENT_TIMESTAMP\n                    )\n                ''')\n                conn.commit()\n                \n                # Add missing columns if they don't exist (for existing databases)\n                try:\n                    conn.execute(\"ALTER TABLE corrections ADD COLUMN correction_type TEXT\")\n                except sqlite3.OperationalError:\n                    pass  # Column already exists\n                \n                try:\n                    conn.execute(\"ALTER TABLE corrections ADD COLUMN season TEXT DEFAULT '2024-25'\")\n                except sqlite3.OperationalError:\n                    pass  # Column already exists\n                    \n                try:\n                    conn.execute(\"ALTER TABLE corrections ADD COLUMN persistent BOOLEAN DEFAULT TRUE\")\n                except sqlite3.OperationalError:\n                    pass  # Column already exists\n                    \n                try:\n                    conn.execute(\"ALTER TABLE corrections ADD COLUMN applied BOOLEAN DEFAULT FALSE\")\n                except sqlite3.OperationalError:\n                    pass  # Column already exists\n                    \n                try:\n                    conn.execute(\"ALTER TABLE corrections ADD COLUMN timestamp DATETIME DEFAULT CURRENT_TIMESTAMP\")\n                except sqlite3.OperationalError:\n                    pass  # Column already exists\n                    \n                conn.commit()\n                \n        except Exception as e:\n            logger.error(f\"Failed to initialize corrections database: {e}\")\n\n    def add_persistent_correction(self, player_name: str, field_name: str, \n                                old_value: str, new_value: str, reason: str = None):\n        \"\"\"Add correction to persistent database\"\"\"\n        try:\n            with sqlite3.connect(self.db_path) as conn:\n                conn.execute(\"\"\"\n                    INSERT INTO corrections (player_name, field_name, old_value, new_value, reason)\n                    VALUES (?, ?, ?, ?, ?)\n                \"\"\", (player_name, field_name, old_value, new_value, reason))\n                conn.commit()\n                return True\n        except Exception as e:\n            logger.error(f\"Failed to add persistent correction: {e}\")\n            return False\n\n    def get_persistent_corrections(self, limit: int = 50) -> List[Dict]:\n        \"\"\"Get corrections from persistent database\"\"\"\n        try:\n            with sqlite3.connect(self.db_path) as conn:\n                cursor = conn.execute(\"\"\"\n                    SELECT player_name, field_name, old_value, new_value, reason, created_at\n                    FROM corrections \n                    ORDER BY created_at DESC \n                    LIMIT ?\n                \"\"\", (limit,))\n\n                corrections = []\n                for row in cursor.fetchall():\n                    corrections.append({\n                        \"player_name\": row[0],\n                        \"field_name\": row[1], \n                        \"old_value\": row[2],\n                        \"new_value\": row[3],\n                        \"reason\": row[4],\n                        \"created_at\": row[5]\n                    })\n                return corrections\n        except Exception as e:\n            logger.error(f\"Failed to get persistent corrections: {e}\")\n            return []\n\n    def add_correction_to_db(self, player_name: str, correction_type: str, old_value: str = None, new_value: str = None, persistent: bool = True):\n        \"\"\"Add correction to the database, with options for persistence and current season.\"\"\"\n        try:\n            with sqlite3.connect(self.db_path) as conn:\n                cursor = conn.cursor()\n                \n                # Check table schema first\n                cursor.execute(\"PRAGMA table_info(corrections)\")\n                columns = [row[1] for row in cursor.fetchall()]\n                \n                if 'player_name' in columns:\n                    cursor.execute('''\n                        INSERT INTO corrections (player_name, correction_type, old_value, new_value, season, persistent)\n                        VALUES (?, ?, ?, ?, ?, ?)\n                    ''', (player_name, correction_type, old_value, new_value, self.current_season, persistent))\n                else:\n                    # Use alternative column names if schema is different\n                    cursor.execute('''\n                        INSERT INTO corrections (field_name, old_value, new_value, reason, created_at)\n                        VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)\n                    ''', (player_name, old_value or correction_type, new_value, f\"{correction_type}: {player_name}\"))\n                \n                conn.commit()\n                logger.info(f\"Added correction to DB: {player_name} - {correction_type}\")\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to add correction: {e}\")\n            return False\n\n    def get_corrections(self, applied: bool = None, persistent_only: bool = True):\n        \"\"\"Retrieve corrections, with options to filter by applied status and persistence.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n\n        query = 'SELECT * FROM corrections WHERE 1=1'\n        params = []\n\n        if applied is not None:\n            query += ' AND applied = ?'\n            params.append(applied)\n\n        if persistent_only:\n            query += ' AND persistent = TRUE'\n        \n        query += ' ORDER BY timestamp DESC'\n\n        cursor.execute(query, params)\n        corrections = cursor.fetchall()\n        conn.close()\n        return corrections\n\n    def mark_applied(self, correction_id: int):\n        \"\"\"Mark a specific correction as applied.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        cursor.execute('UPDATE corrections SET applied = TRUE WHERE id = ?', (correction_id,))\n        conn.commit()\n        conn.close()\n\n    def remove_player(self, player_name: str, reason: str = \"User request\"):\n        \"\"\"Permanently remove a player from all recommendations.\"\"\"\n        try:\n            # Add to corrections database with persistent flag\n            success = self.add_correction_to_db(player_name, \"REMOVE\", None, \"EXCLUDED\", persistent=True)\n            \n            # Also add to knowledge manager for immediate effect\n            if self.knowledge_manager:\n                correction_text = f\"PLAYER_REMOVED: {player_name} - Reason: {reason}\"\n                metadata = {\n                    \"type\": \"player_removal\",\n                    \"player_name\": player_name,\n                    \"action\": \"REMOVE\",\n                    \"reason\": reason,\n                    \"created_at\": datetime.now().isoformat(),\n                    \"persistent\": True\n                }\n                \n                import uuid\n                doc_id = str(uuid.uuid4())\n                self.knowledge_manager.collection.add(\n                    documents=[correction_text],\n                    metadatas=[metadata],\n                    ids=[doc_id]\n                )\n            \n            if success:\n                self.log_data_issue(\"PLAYER_REMOVAL\", f\"Player {player_name} removed: {reason}\", \"high\")\n                # Force immediate application by clearing any cached data\n                self._clear_correction_cache()\n                logger.info(f\"Successfully removed player {player_name} persistently\")\n                return f\"✅ {player_name} è stato rimosso permanentemente da tutte le raccomandazioni (persistente tra sessioni).\"\n            else:\n                return f\"❌ Errore nel rimuovere {player_name} dal database.\"\n        except Exception as e:\n            logger.error(f\"Error in remove_player for {player_name}: {e}\")\n            return f\"❌ Errore nel rimuovere {player_name}: {e}\"\n\n    def update_player_team(self, player_name: str, old_team: str, new_team: str):\n        \"\"\"Update player's team affiliation and log the change.\"\"\"\n        self.add_correction_to_db(player_name, \"TEAM_UPDATE\", old_team, new_team, persistent=True)\n        self.update_active_player(player_name, new_team)\n        return f\"Updated {player_name}: {old_team} → {new_team}\"\n\n    def update_active_player(self, player_name: str, team: str, role: str = None):\n        \"\"\"Update or insert active player data, marking them as active for the current season.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n\n        cursor.execute('''\n            INSERT OR REPLACE INTO active_players (player_name, team, role, season, is_active, last_updated)\n            VALUES (?, ?, ?, ?, TRUE, CURRENT_TIMESTAMP)\n        ''', (player_name, team, role, self.current_season))\n\n        conn.commit()\n        conn.close()\n\n    def deactivate_player(self, player_name: str):\n        \"\"\"Mark a player as inactive in the active_players table.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        cursor.execute('UPDATE active_players SET is_active = FALSE WHERE player_name = ?', (player_name,))\n        conn.commit()\n        conn.close()\n\n    def log_data_issue(self, issue_type: str, description: str, severity: str = \"medium\"):\n        \"\"\"Log data quality issues for tracking and reporting.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        cursor.execute('''\n            INSERT INTO data_issues (issue_type, description, severity)\n            VALUES (?, ?, ?)\n        ''', (issue_type, description, severity))\n        conn.commit()\n        conn.close()\n\n    def get_excluded_players(self):\n        \"\"\"Retrieve a list of player names marked for exclusion.\"\"\"\n        # Use cached version if available\n        if hasattr(self, '_excluded_players_cache'):\n            return self._excluded_players_cache\n            \n        # Fetch all persistent corrections from database\n        try:\n            with sqlite3.connect(self.db_path) as conn:\n                cursor = conn.cursor()\n                \n                # Check if the table exists and get its schema\n                cursor.execute(\"PRAGMA table_info(corrections)\")\n                columns = [row[1] for row in cursor.fetchall()]\n                \n                if not columns:\n                    # Table doesn't exist yet\n                    self._excluded_players_cache = []\n                    return []\n                \n                # Use the correct column name based on the schema\n                if 'player_name' in columns:\n                    player_col = 'player_name'\n                elif 'name' in columns:\n                    player_col = 'name'\n                else:\n                    # Fallback: get the first text column\n                    cursor.execute(\"SELECT * FROM corrections LIMIT 1\")\n                    if cursor.fetchone():\n                        player_col = columns[1] if len(columns) > 1 else columns[0]\n                    else:\n                        self._excluded_players_cache = []\n                        return []\n                \n                # Query with the correct column name\n                if 'correction_type' in columns:\n                    cursor.execute(f\"\"\"\n                        SELECT {player_col} FROM corrections \n                        WHERE correction_type = 'REMOVE' \n                        AND new_value = 'EXCLUDED' \n                        AND persistent = TRUE\n                    \"\"\")\n                else:\n                    # Fallback for older schema\n                    cursor.execute(f\"\"\"\n                        SELECT {player_col} FROM corrections \n                        WHERE old_value IS NULL \n                        AND new_value = 'EXCLUDED'\n                    \"\"\")\n                \n                excluded = [row[0] for row in cursor.fetchall()]\n                \n                # Cache the result\n                self._excluded_players_cache = excluded\n                return excluded\n        except Exception as e:\n            logger.error(f\"Error retrieving excluded players: {e}\")\n            return []\n\n    def apply_corrections_to_data(self, players_data: list):\n        \"\"\"Apply all persistent corrections and filters to a list of player dictionaries.\"\"\"\n        excluded_players = set(self.get_excluded_players())\n        corrections = self.get_corrections(persistent_only=True)\n\n        # Build correction maps for efficient lookup\n        team_updates = {}\n        for correction in corrections:\n            player_name, correction_type, old_value, new_value = correction[1], correction[2], correction[3], correction[4]\n            if correction_type == \"TEAM_UPDATE\":\n                team_updates[player_name] = new_value\n\n        # Apply corrections and filters\n        filtered_data = []\n        for player in players_data:\n            player_name = player.get(\"name\", \"\")\n\n            # Skip players marked for exclusion (case-insensitive matching)\n            if any(player_name.lower() == excluded.lower() for excluded in excluded_players):\n                continue\n\n            # Apply team updates if available\n            if player_name in team_updates:\n                player[\"team\"] = team_updates[player_name]\n\n            # Filter to include only Serie A teams for the current season\n            if self.is_serie_a_team(player.get(\"team\", \"\")):\n                filtered_data.append(player)\n\n        return filtered_data\n\n    def _clear_correction_cache(self):\n        \"\"\"Clear any internal correction caches to force fresh data loading.\"\"\"\n        self._correction_cache = {}\n        # Force re-initialization of any cached data\n        if hasattr(self, '_excluded_players_cache'):\n            delattr(self, '_excluded_players_cache')\n\n    def is_serie_a_team(self, team: str) -> bool:\n        \"\"\"Check if a given team name is part of the current Serie A league.\"\"\"\n        if not team:\n            return False\n            \n        team_norm = team.lower().strip()\n        \n        # Current Serie A 2024-25 teams\n        serie_a_teams = {\n            \"atalanta\", \"bologna\", \"cagliari\", \"como\", \"empoli\", \"fiorentina\",\n            \"genoa\", \"inter\", \"juventus\", \"lazio\", \"lecce\", \"milan\",\n            \"monza\", \"napoli\", \"parma\", \"roma\", \"torino\", \"udinese\",\n            \"venezia\", \"verona\", \"hellas verona\"\n        }\n        \n        # Handle common variations and full names\n        team_mappings = {\n            \"hellas verona\": \"verona\",\n            \"ac milan\": \"milan\",\n            \"fc inter\": \"inter\", \n            \"internazionale\": \"inter\",\n            \"inter milan\": \"inter\",\n            \"juventus fc\": \"juventus\",\n            \"as roma\": \"roma\",\n            \"ss lazio\": \"lazio\",\n            \"ssc napoli\": \"napoli\",\n            \"atalanta bc\": \"atalanta\",\n            \"bologna fc\": \"bologna\",\n            \"cagliari calcio\": \"cagliari\",\n            \"como 1907\": \"como\",\n            \"empoli fc\": \"empoli\",\n            \"acf fiorentina\": \"fiorentina\",\n            \"genoa cfc\": \"genoa\",\n            \"us lecce\": \"lecce\",\n            \"ac monza\": \"monza\",\n            \"parma calcio\": \"parma\",\n            \"torino fc\": \"torino\",\n            \"udinese calcio\": \"udinese\",\n            \"venezia fc\": \"venezia\",\n            # International teams that should be excluded\n            \"newcastle\": False,\n            \"newcastle united\": False,\n            \"psg\": False,\n            \"paris saint-germain\": False,\n            \"al hilal\": False,\n            \"tottenham\": False,\n            \"tottenham hotspur\": False,\n            \"arsenal\": False,\n            \"manchester united\": False,\n            \"manchester city\": False,\n            \"chelsea\": False,\n            \"liverpool\": False,\n            \"real madrid\": False,\n            \"barcelona\": False,\n            \"atletico madrid\": False,\n            \"bayern munich\": False,\n            \"borussia dortmund\": False\n        }\n        \n        # Check direct exclusions first\n        if team_mappings.get(team_norm) is False:\n            return False\n            \n        # Check direct match\n        if team_norm in serie_a_teams:\n            return True\n            \n        # Check mappings\n        mapped_team = team_mappings.get(team_norm)\n        if mapped_team and mapped_team in serie_a_teams:\n            return True\n            \n        return False\n\n    def get_corrected_name(self, name: str) -> Optional[str]:\n        \"\"\"Get the corrected name for a player if one exists\"\"\"\n        try:\n            corrections = self.get_corrections(persistent_only=True)\n            for correction in corrections:\n                if len(correction) > 4 and correction[2] == \"NAME_UPDATE\" and correction[1] == name:\n                    return correction[4]  # new_value\n            return None\n        except Exception as e:\n            logger.error(f\"Error getting corrected name for {name}: {e}\")\n            return None\n\n    def get_corrected_team(self, player_name: str, current_team: str) -> Optional[str]:\n        \"\"\"Get the corrected team for a player if one exists\"\"\"\n        try:\n            corrections = self.get_corrections(persistent_only=True)\n            for correction in corrections:\n                if len(correction) > 4 and correction[2] == \"TEAM_UPDATE\" and correction[1] == player_name:\n                    return correction[4]  # new_value\n            return None\n        except Exception as e:\n            logger.error(f\"Error getting corrected team for {player_name}: {e}\")\n            return None\n\n    def get_data_quality_report(self):\n        \"\"\"Generate a comprehensive report on data quality issues and corrections.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n\n        # Count open issues by type and severity\n        cursor.execute('''\n            SELECT issue_type, severity, COUNT(*) as count\n            FROM data_issues \n            WHERE status = 'open'\n            GROUP BY issue_type, severity\n        ''')\n        issues = cursor.fetchall()\n\n        # Count total persistent corrections made\n        cursor.execute('SELECT COUNT(*) FROM corrections WHERE persistent = TRUE')\n        corrections_count = cursor.fetchone()[0]\n\n        conn.close()\n\n        # Return a dictionary summarizing the data quality status\n        return {\n            \"issues_by_type\": issues,\n            \"total_corrections\": corrections_count,\n            \"excluded_players\": len(self.get_excluded_players())\n        }"},{"path":"data/age_index.cleaned.json","size":6501,"sha1":"ba3b627d5d419e90df8e210d8e19308f53e937d8","mtime":1755346590,"is_binary":false,"encoding":"utf-8","content":"{\n  \"Honest Ahanor@@Atalanta\": 2008,\n  \"Giovanni Bonfanti@@Atalanta\": 2003,\n  \"Marco Palestra@@Atalanta\": 2005,\n  \"Giorgio Scalvini@@Atalanta\": 2003,\n  \"Ibrahim Sulemana@@Atalanta\": 2003,\n  \"Santiago Castro@@Bologna\": 2004,\n  \"Tommaso Corazza@@Bologna\": 2004,\n  \"Benja Domínguez@@Bologna\": 2003,\n  \"Giovanni Fabbian@@Bologna\": 2003,\n  \"Mihajlo Ilić@@Bologna\": 2003,\n  \"Kacper Urbanski@@Bologna\": 2004,\n  \"Martin Vitík@@Bologna\": 2003,\n  \"Alessandro Bolzan@@Cagliari\": 2005,\n  \"Nicolò Cavuoti@@Cagliari\": 2003,\n  \"Riyad Idrissi@@Cagliari\": 2005,\n  \"Semih Kılıçsoy@@Cagliari\": 2005,\n  \"Nicola Pintus@@Cagliari\": 2005,\n  \"Matteo Prati@@Cagliari\": 2003,\n  \"Davide Veroli@@Cagliari\": 2003,\n  \"Alessandro Vinciguerra@@Cagliari\": 2005,\n  \"Jayden Addai@@Como\": 2005,\n  \"Assane Diao@@Como\": 2005,\n  \"Fellipe Jack@@Como\": 2006,\n  \"Ali Jasim@@Como\": 2004,\n  \"Giuseppe Mazzaglia@@Como\": 2006,\n  \"Nico Paz@@Como\": 2004,\n  \"Máximo Perrone@@Como\": 2003,\n  \"Jacobo Ramón@@Como\": 2005,\n  \"Naj Razi@@Como\": 2006,\n  \"Jesús Rodríguez@@Como\": 2005,\n  \"Álex Valle@@Como\": 2004,\n  \"Ank Asmussen@@Empoli\": 2005,\n  \"Thomas Campaniello@@Empoli\": 2008,\n  \"Gabriele Guarino@@Empoli\": 2004,\n  \"Rareș Ilie@@Empoli\": 2003,\n  \"Lorenzo Ignacchiti@@Empoli\": 2004,\n  \"Iwo Kaczmarski@@Empoli\": 2004,\n  \"Ismaël Konaté@@Empoli\": 2006,\n  \"Brando Moruzzi@@Empoli\": 2004,\n  \"Stiven Shpendi@@Empoli\": 2003,\n  \"Andrea Sodero@@Empoli\": 2004,\n  \"Lovro Stubljar@@Empoli\": 2004,\n  \"Lorenzo Tosto@@Empoli\": 2005,\n  \"Maat Daniel Caprini@@Fiorentina\": 2005,\n  \"Pietro Comuzzo@@Fiorentina\": 2005,\n  \"Jacopo Fazzini@@Fiorentina\": 2003,\n  \"Niccolò Fortini@@Fiorentina\": 2006,\n  \"Gino Infantino@@Fiorentina\": 2003,\n  \"Michael Kayode@@Fiorentina\": 2004,\n  \"Eman Kospo@@Fiorentina\": 2007,\n  \"Tommaso Martinelli@@Fiorentina\": 2006,\n  \"Cher Ndour@@Fiorentina\": 2004,\n  \"Tommaso Rubino@@Fiorentina\": 2006,\n  \"Valentín Carboni@@Genoa\": 2005,\n  \"Hugo Cuenca@@Genoa\": 2005,\n  \"Jeff Ekhator@@Genoa\": 2006,\n  \"Seydou Fini@@Genoa\": 2006,\n  \"Lior Kassa@@Genoa\": 2005,\n  \"Alan Matturro@@Genoa\": 2004,\n  \"Fabio Miretti@@Genoa\": 2003,\n  \"Brooke Norton-Cuffy@@Genoa\": 2004,\n  \"Sebastian Otoa@@Genoa\": 2004,\n  \"Christos Papadopoulos@@Genoa\": 2004,\n  \"Lorenzo Venturino@@Genoa\": 2006,\n  \"Junior Ajayi@@Hellas Verona\": 2004,\n  \"Fallou Cham@@Hellas Verona\": 2006,\n  \"Alphadjo Cissè@@Hellas Verona\": 2006,\n  \"Diego Coppola@@Hellas Verona\": 2003,\n  \"Christian Corradi@@Hellas Verona\": 2005,\n  \"Mathis Lambourde@@Hellas Verona\": 2006,\n  \"Federico Magro@@Hellas Verona\": 2005,\n  \"Tobias Slotsager@@Hellas Verona\": 2006,\n  \"Mike Aidoo@@Inter Milan\": 2004,\n  \"Ebenezer Akinsanmiro@@Inter Milan\": 2004,\n  \"Ange-Yoan Bonny@@Inter Milan\": 2003,\n  \"Franco Carboni@@Inter Milan\": 2003,\n  \"Pio Esposito@@Inter Milan\": 2005,\n  \"Tomás Palacios@@Inter Milan\": 2003,\n  \"Petar Sučić@@Inter Milan\": 2003,\n  \"Vasilije Adžić@@Juventus\": 2006,\n  \"Alberto Costa@@Juventus\": 2004,\n  \"Facundo González@@Juventus\": 2003,\n  \"Dean Huijsen@@Juventus\": 2005,\n  \"Samuel Mbangula@@Juventus\": 2004,\n  \"Jonas Rouhi@@Juventus\": 2004,\n  \"Nicolò Savona@@Juventus\": 2003,\n  \"Renato Veiga@@Juventus\": 2003,\n  \"Kenan Yıldız@@Juventus\": 2005,\n  \"Reda Belahyane@@Lazio\": 2004,\n  \"Filipe Bordon@@Lazio\": 2005,\n  \"Saná Fernandes@@Lazio\": 2006,\n  \"Diego González@@Lazio\": 2003,\n  \"Arijon Ibrahimovic@@Lazio\": 2005,\n  \"Cristo Muñoz@@Lazio\": 2005,\n  \"Romano Floriani Mussolini@@Lazio\": 2003,\n  \"Davide Renzetti@@Lazio\": 2006,\n  \"Fabio Andrea Ruggeri@@Lazio\": 2004,\n  \"Vernon Addo@@Lecce\": 2005,\n  \"Medon Berisha@@Lecce\": 2003,\n  \"Francesco Camarda@@Lecce\": 2008,\n  \"Giacomo Faticanti@@Lecce\": 2004,\n  \"Olaf Gorter@@Lecce\": 2005,\n  \"Lovro Herceg@@Lecce\": 2005,\n  \"Niko Kovač@@Lecce\": 2005,\n  \"Ed McJannet@@Lecce\": 2004,\n  \"Matías Pérez@@Lecce\": 2005,\n  \"Daniel Samek@@Lecce\": 2004,\n  \"Jasper Samooja@@Lecce\": 2003,\n  \"Tiago Gabriel@@Lecce\": 2004,\n  \"Yacine Adli@@AC Milan\": 2000,\n  \"Zachary Athekame@@AC Milan\": 2004,\n  \"Davide Bartesaghi@@AC Milan\": 2005,\n  \"Warren Bondo@@AC Milan\": 2003,\n  \"Álex Jiménez@@AC Milan\": 2005,\n  \"Luka Romero@@AC Milan\": 2004,\n  \"Jan-Carlo Simić@@AC Milan\": 2005,\n  \"Lorenzo Torriani@@AC Milan\": 2005,\n  \"Chaka Traorè@@AC Milan\": 2004,\n  \"Kevin Zeroli@@AC Milan\": 2005,\n  \"Leonardo Colombo@@Monza\": 2005,\n  \"Omari Forson@@Monza\": 2004,\n  \"Stefan Leković@@Monza\": 2004,\n  \"Kevin Martins@@Monza\": 2005,\n  \"Andrea Mazza@@Monza\": 2004,\n  \"Kacper Urbanski@@Monza\": 2004,\n  \"Samuele Vignato@@Monza\": 2004,\n  \"Giuseppe Ambrosino@@Napoli\": 2003,\n  \"Mathias Ferrante@@Napoli\": 2006,\n  \"Luis Hasa@@Napoli\": 2004,\n  \"Luca Marianucci@@Napoli\": 2004,\n  \"Nosa Edward Obaretin@@Napoli\": 2003,\n  \"Antonio Vergara@@Napoli\": 2003,\n  \"Nathan Buayi-Kiala@@Parma\": 2004,\n  \"Anas Haj Mohamed@@Parma\": 2005,\n  \"Mateusz Kowalski@@Parma\": 2005,\n  \"Giovanni Leoni@@Parma\": 2006,\n  \"Daniel Mikolajewski@@Parma\": 2006,\n  \"Manuel Moretta@@Parma\": 2005,\n  \"Elia Plicco@@Parma\": 2006,\n  \"Dario Sits@@Parma\": 2004,\n  \"Nicolas Trabucchi@@Parma\": 2007,\n  \"Antonello Vona@@Parma\": 2004,\n  \"Tommaso Baldanzi@@AS Roma\": 2003,\n  \"Luigi Cherubini@@AS Roma\": 2004,\n  \"João Costa@@AS Roma\": 2005,\n  \"Evan Ferguson@@AS Roma\": 2004,\n  \"Daniele Ghilardi@@AS Roma\": 2003,\n  \"Mattia Mannini@@AS Roma\": 2006,\n  \"Riccardo Pagano@@AS Roma\": 2004,\n  \"Niccolò Pisilli@@AS Roma\": 2004,\n  \"Matteo Plaia@@AS Roma\": 2006,\n  \"Devyne Rensch@@AS Roma\": 2003,\n  \"Buba Sangaré@@AS Roma\": 2007,\n  \"Matías Soulé@@AS Roma\": 2003,\n  \"Wesley@@AS Roma\": 2003,\n  \"Radoslaw Zelezny@@AS Roma\": 2006,\n  \"Côme Bianay Balcot@@Torino\": 2005,\n  \"Aaron Ciammaglichella@@Torino\": 2005,\n  \"Ali Dembélé@@Torino\": 2004,\n  \"Gvidas Gineitis@@Torino\": 2004,\n  \"Emirhan İlkhan@@Torino\": 2004,\n  \"Senan Mullen@@Torino\": 2005,\n  \"Alieu Njie@@Torino\": 2005,\n  \"Sergiu Perciun@@Torino\": 2006,\n  \"Francesco Plaia@@Torino\": 2006,\n  \"Zanos Savva@@Torino\": 2005,\n  \"Arthur Atta@@Udinese\": 2003,\n  \"Nicolò Bertola@@Udinese\": 2003,\n  \"Iker Bravo@@Udinese\": 2005,\n  \"Sekou Diawara@@Udinese\": 2004,\n  \"Gonçalo Esteves@@Udinese\": 2004,\n  \"Saba Goglichidze@@Udinese\": 2004,\n  \"Lennon Miller@@Udinese\": 2006,\n  \"Alessandro Nunziante@@Udinese\": 2007,\n  \"Simone Pafundi@@Udinese\": 2006,\n  \"Matteo Palma@@Udinese\": 2008,\n  \"David Pejičić@@Udinese\": 2007,\n  \"Damián Pizarro@@Udinese\": 2005,\n  \"Vivaldo Semedo@@Udinese\": 2005,\n  \"Issa Doumbia@@Venezia\": 2003,\n  \"Saad El Haddad@@Venezia\": 2005,\n  \"Alessandro Pietrelli@@Venezia\": 2003,\n  \"Richie Sagrado@@Venezia\": 2004,\n  \"Federico Tavernaro@@Venezia\": 2005,\n  \"Alvin Okoro@@Venezia\": 2005\n}"},{"path":"data/age_index.json","size":13260,"sha1":"fe6c39cf30ee706117142f53c143f8d35be25a9f","mtime":1755104811,"is_binary":false,"encoding":"utf-8","content":"{\n  \"abdelkader ghezzal|como 1907\": {\n    \"birth_year\": 2010\n  },\n  \"andrea ardito|como 1907\": {\n    \"birth_year\": 2001\n  },\n  \"sergi roberto|como 1907\": {\n    \"birth_year\": 2010\n  },\n  \"simone scuffet|como 1907\": {\n    \"birth_year\": 2015\n  },\n  \"daniel bessa|como 1907\": {\n    \"birth_year\": 2016\n  },\n  \"giovanni trainini|como 1907\": {\n    \"birth_year\": 1982\n  },\n  \"vittorio parigini|como 1907\": {\n    \"birth_year\": 2016\n  },\n  \"giovanni fietta|como 1907\": {\n    \"birth_year\": 1982\n  },\n  \"tiago casasola|como 1907\": {\n    \"birth_year\": 2015\n  },\n  \"eric lanini|como 1907\": {\n    \"birth_year\": 2014\n  },\n  \"roberto ennas|como 1907\": {\n    \"birth_year\": 2007\n  },\n  \"alberto moreno pérez|como 1907\": {\n    \"birth_year\": 2012\n  },\n  \"andrea belotti|como 1907\": {\n    \"birth_year\": 2018\n  },\n  \"daniel cappelletti|como 1907\": {\n    \"birth_year\": 2009\n  },\n  \"lorenzo andrenacci|como 1907\": {\n    \"birth_year\": 2021\n  },\n  \"riccardo idda|como 1907\": {\n    \"birth_year\": 2000\n  },\n  \"assane diao|como 1907\": {\n    \"birth_year\": 2023\n  },\n  \"nicola madonna|como 1907\": {\n    \"birth_year\": 2009\n  },\n  \"joshua brillante|como 1907\": {\n    \"birth_year\": 2012\n  },\n  \"achille sacchi|como 1907\": {\n    \"birth_year\": 1995\n  },\n  \"carlo sabatini|como 1907\": {\n    \"birth_year\": 1982\n  },\n  \"federico gerardi|como 1907\": {\n    \"birth_year\": 1982\n  },\n  \"giacomo paniccia|como 1907\": {\n    \"birth_year\": 1997\n  },\n  \"giovanni la camera|como 1907\": {\n    \"birth_year\": 2014\n  },\n  \"massimiliano notari|como 1907\": {\n    \"birth_year\": 1993\n  },\n  \"pasquale sensibile|como 1907\": {\n    \"birth_year\": 2012\n  },\n  \"simone ganz|como 1907\": {\n    \"birth_year\": 2021\n  },\n  \"matteo bianchetti|como 1907\": {\n    \"birth_year\": 1980\n  },\n  \"stefano pettinari|como 1907\": {\n    \"birth_year\": 2017\n  },\n  \"dele alli|como 1907\": {\n    \"birth_year\": 2015\n  },\n  \"luca scapuzzi|como 1907\": {\n    \"birth_year\": 2017\n  },\n  \"marco giambruno|como 1907\": {\n    \"birth_year\": 1980\n  },\n  \"matteo lanzoni|como 1907\": {\n    \"birth_year\": 2012\n  },\n  \"luca lulli|como 1907\": {\n    \"birth_year\": 1993\n  },\n  \"ben greenhalgh|como 1907\": {\n    \"birth_year\": 1994\n  },\n  \"isaac ntow|como 1907\": {\n    \"birth_year\": 1994\n  },\n  \"diamante crispino|como 1907\": {\n    \"birth_year\": 2012\n  },\n  \"edoardo bovolon|como 1907\": {\n    \"birth_year\": 2023\n  },\n  \"carmelo malgeri|como 1907\": {\n    \"birth_year\": 2003\n  },\n  \"alessio cristiani|como 1907\": {\n    \"birth_year\": 1982\n  },\n  \"filippo damian|como 1907\": {\n    \"birth_year\": 2010\n  },\n  \"matteo cortesi|como 1907\": {\n    \"birth_year\": 1998\n  },\n  \"alex redolfi|como 1907\": {\n    \"birth_year\": 2013\n  },\n  \"marco piredda|como 1907\": {\n    \"birth_year\": 2013\n  },\n  \"roberto rudi|como 1907\": {\n    \"birth_year\": 1980\n  },\n  \"gennaro esposito|como 1907\": {\n    \"birth_year\": 1980\n  },\n  \"bruno hervat|unione sportiva fiumana\": {\n    \"birth_year\": 2012\n  },\n  \"juan cuadrado|pisa sporting club\": {\n    \"birth_year\": 1995\n  },\n  \"umberto eusepi|pisa sporting club\": {\n    \"birth_year\": 2020\n  },\n  \"artur ioniță|pisa sporting club\": {\n    \"birth_year\": 2012\n  },\n  \"ignacio lores varela|pisa sporting club\": {\n    \"birth_year\": 2010\n  },\n  \"pier luigi meciani|pisa sporting club\": {\n    \"birth_year\": 1995\n  },\n  \"renato miele|pisa sporting club\": {\n    \"birth_year\": 1991\n  },\n  \"stefano dicuonzo|pisa sporting club\": {\n    \"birth_year\": 1994\n  },\n  \"tommaso biasci|pisa sporting club\": {\n    \"birth_year\": 1994\n  },\n  \"gabriele piccinini|pisa sporting club\": {\n    \"birth_year\": 1995\n  },\n  \"francesco di tacchio|pisa sporting club\": {\n    \"birth_year\": 1993\n  },\n  \"paolo rozzio|pisa sporting club\": {\n    \"birth_year\": 2020\n  },\n  \"andrea tabanelli|pisa sporting club\": {\n    \"birth_year\": 2019\n  },\n  \"andrea sbrana|pisa sporting club\": {\n    \"birth_year\": 1995\n  },\n  \"ettore gliozzi|pisa sporting club\": {\n    \"birth_year\": 2020\n  },\n  \"antonio franceschi|pisa sporting club\": {\n    \"birth_year\": 1995\n  },\n  \"loris zonta|pisa sporting club\": {\n    \"birth_year\": 2018\n  },\n  \"marius marin|pisa sporting club\": {\n    \"birth_year\": 1995\n  },\n  \"giulio melecchi|pisa sporting club\": {\n    \"birth_year\": 2013\n  },\n  \"adrián rus|pisa sporting club\": {\n    \"birth_year\": 1995\n  },\n  \"stefano moreo|pisa sporting club\": {\n    \"birth_year\": 2025\n  },\n  \"matteo ton|pisa sporting club\": {\n    \"birth_year\": 2024\n  },\n  \"giulio sanseverino|pisa sporting club\": {\n    \"birth_year\": 2018\n  },\n  \"roberto floriano|pisa sporting club\": {\n    \"birth_year\": 1994\n  },\n  \"francesco favasuli|pisa sporting club\": {\n    \"birth_year\": 2020\n  },\n  \"adriano louzada|pisa sporting club\": {\n    \"birth_year\": 2002\n  },\n  \"antonio montella|pisa sporting club\": {\n    \"birth_year\": 2019\n  },\n  \"césar medina|pisa sporting club\": {\n    \"birth_year\": 1996\n  },\n  \"daniele cardelli|pisa sporting club\": {\n    \"birth_year\": 1984\n  },\n  \"luca ricciardi|pisa sporting club\": {\n    \"birth_year\": 1993\n  },\n  \"matteo campani|pisa sporting club\": {\n    \"birth_year\": 1995\n  },\n  \"alessandro bacci|pisa sporting club\": {\n    \"birth_year\": 2025\n  },\n  \"davide de marino|pisa sporting club\": {\n    \"birth_year\": 1995\n  },\n  \"alessio castellini|pisa sporting club\": {\n    \"birth_year\": 1995\n  },\n  \"louis thomas buffon|pisa sporting club\": {\n    \"birth_year\": 2004\n  },\n  \"samuele angori|pisa sporting club\": {\n    \"birth_year\": 1995\n  },\n  \"renato lucchi|venezia fc\": {\n    \"birth_year\": 2000\n  },\n  \"renzo ragonesi|venezia fc\": {\n    \"birth_year\": 2010\n  },\n  \"salvatore tarantino|venezia fc\": {\n    \"birth_year\": 1985\n  },\n  \"silvio giusti|venezia fc\": {\n    \"birth_year\": 2011\n  },\n  \"simone salviato|venezia fc\": {\n    \"birth_year\": 2021\n  },\n  \"stefano trevisanello|venezia fc\": {\n    \"birth_year\": 1987\n  },\n  \"trevor trevisan|venezia fc\": {\n    \"birth_year\": 2024\n  },\n  \"carlo bianchi|venezia fc\": {\n    \"birth_year\": 2015\n  },\n  \"marco modolo|venezia fc\": {\n    \"birth_year\": 2014\n  },\n  \"giovanni calegari|venezia fc\": {\n    \"birth_year\": 2015\n  },\n  \"silvano colusso|venezia fc\": {\n    \"birth_year\": 1987\n  },\n  \"giannino di teodoro|venezia fc\": {\n    \"birth_year\": 2019\n  },\n  \"pietro d'este|venezia fc\": {\n    \"birth_year\": 2015\n  },\n  \"carlo rosa|venezia fc\": {\n    \"birth_year\": 2015\n  },\n  \"carlo trevisanello|venezia fc\": {\n    \"birth_year\": 1983\n  },\n  \"cesidio oddi|venezia fc\": {\n    \"birth_year\": 1980\n  },\n  \"claudio venturi|venezia fc\": {\n    \"birth_year\": 1990\n  },\n  \"dandolo flumini|venezia fc\": {\n    \"birth_year\": 1981\n  },\n  \"daniele danieli|venezia fc\": {\n    \"birth_year\": 2023\n  },\n  \"danilo venturi|venezia fc\": {\n    \"birth_year\": 2019\n  },\n  \"dino d'alessi|venezia fc\": {\n    \"birth_year\": 1982\n  },\n  \"elvi pianca|venezia fc\": {\n    \"birth_year\": 1980\n  },\n  \"eraldo mancin|venezia fc\": {\n    \"birth_year\": 1980\n  },\n  \"eugenio patti|venezia fc\": {\n    \"birth_year\": 1996\n  },\n  \"ezio lombardi|venezia fc\": {\n    \"birth_year\": 2015\n  },\n  \"fulvio fellet|venezia fc\": {\n    \"birth_year\": 1980\n  },\n  \"gennaro rambone|venezia fc\": {\n    \"birth_year\": 1982\n  },\n  \"gianfranco de marchi|venezia fc\": {\n    \"birth_year\": 2008\n  },\n  \"giorgio rossi|venezia fc\": {\n    \"birth_year\": 2002\n  },\n  \"giovanni ivaldi|venezia fc\": {\n    \"birth_year\": 2023\n  },\n  \"davide bertolucci|venezia fc\": {\n    \"birth_year\": 2008\n  },\n  \"gianluca giovannini|venezia fc\": {\n    \"birth_year\": 2025\n  },\n  \"marco antônio|venezia fc\": {\n    \"birth_year\": 2015\n  },\n  \"massimiliano taddei|venezia fc\": {\n    \"birth_year\": 2018\n  },\n  \"marco antônio de freitas filho|venezia fc\": {\n    \"birth_year\": 1999\n  },\n  \"andrea menegon|venezia fc\": {\n    \"birth_year\": 2006\n  },\n  \"pier graziano gori|venezia fc\": {\n    \"birth_year\": 1995\n  },\n  \"alberto acquadro|venezia fc\": {\n    \"birth_year\": 2024\n  },\n  \"loris tortori|venezia fc\": {\n    \"birth_year\": 1986\n  },\n  \"luigi luciani|venezia fc\": {\n    \"birth_year\": 2015\n  },\n  \"filippo serena|venezia fc\": {\n    \"birth_year\": 2006\n  },\n  \"emilio volpicelli|venezia fc\": {\n    \"birth_year\": 1992\n  },\n  \"lorenzo gavioli|venezia fc\": {\n    \"birth_year\": 2019\n  },\n  \"tommaso rocchi|venezia fc\": {\n    \"birth_year\": 1993\n  },\n  \"salvatore foti|venezia fc\": {\n    \"birth_year\": 2012\n  },\n  \"salvatore sirigu|venezia fc\": {\n    \"birth_year\": 2007\n  },\n  \"facundo zabala|venezia fc\": {\n    \"birth_year\": 2020\n  },\n  \"gaetano oristanio|venezia fc\": {\n    \"birth_year\": 2018\n  },\n  \"armando varini|venezia fc\": {\n    \"birth_year\": 2015\n  },\n  \"antonio zani|venezia fc\": {\n    \"birth_year\": 2008\n  },\n  \"cesare bianchini|venezia fc\": {\n    \"birth_year\": 1981\n  },\n  \"simone edera|venezia fc\": {\n    \"birth_year\": 2014\n  },\n  \"vincenzo alberto annese|venezia fc\": {\n    \"birth_year\": 2016\n  },\n  \"roberto venturato|venezia fc\": {\n    \"birth_year\": 1993\n  },\n  \"renato marchiaro|venezia fc\": {\n    \"birth_year\": 2017\n  },\n  \"adriano maschietto|venezia fc\": {\n    \"birth_year\": 2016\n  },\n  \"angelo del favero|venezia fc\": {\n    \"birth_year\": 1985\n  },\n  \"antonio de bellis|venezia fc\": {\n    \"birth_year\": 1983\n  },\n  \"benedetto de angelis|venezia fc\": {\n    \"birth_year\": 1992\n  },\n  \"pietro broccini|venezia fc\": {\n    \"birth_year\": 2006\n  },\n  \"andrea capitanio|venezia fc\": {\n    \"birth_year\": 2015\n  },\n  \"luigi capuzzo|venezia fc\": {\n    \"birth_year\": 2014\n  },\n  \"piero castello|venezia fc\": {\n    \"birth_year\": 2015\n  },\n  \"roberto catterina|venezia fc\": {\n    \"birth_year\": 1980\n  },\n  \"daniele catto|venezia fc\": {\n    \"birth_year\": 1988\n  },\n  \"giuseppe chiesa|venezia fc\": {\n    \"birth_year\": 2015\n  },\n  \"luigi milan|venezia fc\": {\n    \"birth_year\": 1982\n  },\n  \"corrado corradi|venezia fc\": {\n    \"birth_year\": 1992\n  },\n  \"pierino fanna|venezia fc\": {\n    \"birth_year\": 1984\n  },\n  \"bruno dante|venezia fc\": {\n    \"birth_year\": 2015\n  },\n  \"leo zavatti|venezia fc\": {\n    \"birth_year\": 2023\n  },\n  \"marcello neri|venezia fc\": {\n    \"birth_year\": 1991\n  },\n  \"marco zanotto|venezia fc\": {\n    \"birth_year\": 2015\n  },\n  \"mario ferrari|venezia fc\": {\n    \"birth_year\": 2015\n  },\n  \"mario tesconi|venezia fc\": {\n    \"birth_year\": 2015\n  },\n  \"marzio lugnan|venezia fc\": {\n    \"birth_year\": 2009\n  },\n  \"nicolò sciacca|venezia fc\": {\n    \"birth_year\": 1988\n  },\n  \"oscar lesca|venezia fc\": {\n    \"birth_year\": 1982\n  },\n  \"philippe fuchs|venezia fc\": {\n    \"birth_year\": 1995\n  },\n  \"samuele longo|venezia fc\": {\n    \"birth_year\": 2012\n  },\n  \"pietro ghedin|venezia fc\": {\n    \"birth_year\": 1998\n  },\n  \"maurizio domizzi|venezia fc\": {\n    \"birth_year\": 2001\n  },\n  \"giandomenico baldisseri|venezia fc\": {\n    \"birth_year\": 2007\n  },\n  \"walter ballarin|venezia fc\": {\n    \"birth_year\": 2002\n  },\n  \"mario barbon|venezia fc\": {\n    \"birth_year\": 2015\n  },\n  \"matteo serafini|venezia fc\": {\n    \"birth_year\": 2002\n  },\n  \"candido beretta|venezia fc\": {\n    \"birth_year\": 1982\n  },\n  \"edoardo bosio|football club torinese\": {\n    \"birth_year\": 2002\n  },\n  \"george beaton|football club torinese\": {\n    \"birth_year\": 2005\n  },\n  \"renato pastori|alba roma 1907\": {\n    \"birth_year\": 2014\n  },\n  \"leslie walter minter|unione sportiva internazionale napoli\": {\n    \"birth_year\": 2015\n  },\n  \"george johnson|ss lazio\": {\n    \"birth_year\": 1990\n  },\n  \"senad lulić|ss lazio\": {\n    \"birth_year\": 2014\n  },\n  \"alessandro zamperini|ss lazio\": {\n    \"birth_year\": 2006\n  },\n  \"davide di gennaro|ss lazio\": {\n    \"birth_year\": 2016\n  },\n  \"dušan basta|ss lazio\": {\n    \"birth_year\": 2009\n  },\n  \"fabrizio grillo|ss lazio\": {\n    \"birth_year\": 2014\n  },\n  \"francesco acerbi|ss lazio\": {\n    \"birth_year\": 2012\n  },\n  \"aleandro rosi|ss lazio\": {\n    \"birth_year\": 2011\n  },\n  \"pajtim kasami|ss lazio\": {\n    \"birth_year\": 2010\n  },\n  \"ravel morrison|ss lazio\": {\n    \"birth_year\": 2011\n  },\n  \"felipe anderson|ss lazio\": {\n    \"birth_year\": 2000\n  },\n  \"alessio romagnoli|ss lazio\": {\n    \"birth_year\": 2014\n  },\n  \"mario desiderio|ss lazio\": {\n    \"birth_year\": 1984\n  },\n  \"federico peluso|ss lazio\": {\n    \"birth_year\": 2012\n  },\n  \"renato antolini|ss lazio\": {\n    \"birth_year\": 2002\n  },\n  \"ferdinando sforzini|ss lazio\": {\n    \"birth_year\": 2011\n  },\n  \"francesco carbone|ss lazio\": {\n    \"birth_year\": 2012\n  },\n  \"pablo pintos|ss lazio\": {\n    \"birth_year\": 2010\n  },\n  \"matías vecino|ss lazio\": {\n    \"birth_year\": 2020\n  },\n  \"antonio rozzi|ss lazio\": {\n    \"birth_year\": 2012\n  },\n  \"sandro ciotti|ss lazio\": {\n    \"birth_year\": 1995\n  },\n  \"andrea russotto|ss lazio\": {\n    \"birth_year\": 2015\n  },\n  \"rômulo souza orestes caldeira|ss lazio\": {\n    \"birth_year\": 2023\n  },\n  \"diego martín rodríguez|ss lazio\": {\n    \"birth_year\": 1986\n  },\n  \"marco d'alessandro|ss lazio\": {\n    \"birth_year\": 2000\n  },\n  \"elio capradossi|ss lazio\": {\n    \"birth_year\": 2015\n  },\n  \"mattéo guendouzi|ss lazio\": {\n    \"birth_year\": 2018\n  },\n  \"fabrizio melara|ss lazio\": {\n    \"birth_year\": 2003\n  },\n  \"moustapha seck|ss lazio\": {\n    \"birth_year\": 2013\n  },\n  \"mattia zaccagni|ss lazio\": {\n    \"birth_year\": 2022\n  },\n  \"simone palombi|ss lazio\": {\n    \"birth_year\": 1999\n  },\n  \"luca germoni|ss lazio\": {\n    \"birth_year\": 1997\n  },\n  \"manuel lazzari|ss lazio\": {\n    \"birth_year\": 2021\n  },\n  \"sergio guenza|ss lazio\": {\n    \"birth_year\": 1981\n  },\n  \"antonio calabro|ss lazio\": {\n    \"birth_year\": 1995\n  },\n  \"valentín castellanos|ss lazio\": {\n    \"birth_year\": 2021\n  },\n  \"roger ibañez da silva|ss lazio\": {\n    \"birth_year\": 2016\n  }\n}"},{"path":"data/age_overrides.json","size":13051,"sha1":"beecc07a30a7de43f1ccd6692e5e292bfc9cd9c3","mtime":1755352975,"is_binary":false,"encoding":"utf-8","content":"\n{\n  \"Honest Ahanor@@Atalanta\": {\n    \"year\": 2008,\n    \"role\": \"D\"\n  },\n  \"Giovanni Bonfanti@@Atalanta\": {\n    \"year\": 2003,\n    \"role\": \"P\"\n  },\n  \"Marco Palestra@@Atalanta\": {\n    \"year\": 2005,\n    \"role\": \"C\"\n  },\n  \"Giorgio Scalvini@@Atalanta\": {\n    \"year\": 2003,\n    \"role\": \"D\"\n  },\n  \"Ibrahim Sulemana@@Atalanta\": {\n    \"year\": 2003,\n    \"role\": \"C\"\n  },\n  \"Santiago Castro@@Bologna\": {\n    \"year\": 2004,\n    \"role\": \"A\"\n  },\n  \"Tommaso Corazza@@Bologna\": {\n    \"year\": 2004,\n    \"role\": \"D\"\n  },\n  \"Benja Domínguez@@Bologna\": {\n    \"year\": 2003,\n    \"role\": \"A\"\n  },\n  \"Giovanni Fabbian@@Bologna\": {\n    \"year\": 2003,\n    \"role\": \"C\"\n  },\n  \"Mihajlo Ilić@@Bologna\": {\n    \"year\": 2003,\n    \"role\": \"D\"\n  },\n  \"Kacper Urbanski@@Bologna\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Martin Vitík@@Bologna\": {\n    \"year\": 2003,\n    \"role\": \"D\"\n  },\n  \"Alessandro Bolzan@@Cagliari\": {\n    \"year\": 2005,\n    \"role\": \"D\"\n  },\n  \"Nicolò Cavuoti@@Cagliari\": {\n    \"year\": 2003,\n    \"role\": \"D\"\n  },\n  \"Riyad Idrissi@@Cagliari\": {\n    \"year\": 2005,\n    \"role\": \"C\"\n  },\n  \"Semih Kılıçsoy@@Cagliari\": {\n    \"year\": 2005,\n    \"role\": \"A\"\n  },\n  \"Nicola Pintus@@Cagliari\": {\n    \"year\": 2005,\n    \"role\": \"D\"\n  },\n  \"Matteo Prati@@Cagliari\": {\n    \"year\": 2003,\n    \"role\": \"C\"\n  },\n  \"Davide Veroli@@Cagliari\": {\n    \"year\": 2003,\n    \"role\": \"D\"\n  },\n  \"Alessandro Vinciguerra@@Cagliari\": {\n    \"year\": 2005,\n    \"role\": \"P\"\n  },\n  \"Jayden Addai@@Como\": {\n    \"year\": 2005,\n    \"role\": \"A\"\n  },\n  \"Assane Diao@@Como\": {\n    \"year\": 2005,\n    \"role\": \"A\"\n  },\n  \"Fellipe Jack@@Como\": {\n    \"year\": 2006,\n    \"role\": \"A\"\n  },\n  \"Ali Jasim@@Como\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Giuseppe Mazzaglia@@Como\": {\n    \"year\": 2006,\n    \"role\": \"P\"\n  },\n  \"Nico Paz@@Como\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Máximo Perrone@@Como\": {\n    \"year\": 2003,\n    \"role\": \"C\"\n  },\n  \"Jacobo Ramón@@Como\": {\n    \"year\": 2005,\n    \"role\": \"D\"\n  },\n  \"Naj Razi@@Como\": {\n    \"year\": 2006,\n    \"role\": \"A\"\n  },\n  \"Jesús Rodríguez@@Como\": {\n    \"year\": 2005,\n    \"role\": \"A\"\n  },\n  \"Álex Valle@@Como\": {\n    \"year\": 2004,\n    \"role\": \"D\"\n  },\n  \"Ank Asmussen@@Empoli\": {\n    \"year\": 2005,\n    \"role\": \"D\"\n  },\n  \"Thomas Campaniello@@Empoli\": {\n    \"year\": 2008,\n    \"role\": \"P\"\n  },\n  \"Gabriele Guarino@@Empoli\": {\n    \"year\": 2004,\n    \"role\": \"D\"\n  },\n  \"Rareș Ilie@@Empoli\": {\n    \"year\": 2003,\n    \"role\": \"C\"\n  },\n  \"Lorenzo Ignacchiti@@Empoli\": {\n    \"year\": 2004,\n    \"role\": \"D\"\n  },\n  \"Iwo Kaczmarski@@Empoli\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Ismaël Konaté@@Empoli\": {\n    \"year\": 2006,\n    \"role\": \"A\"\n  },\n  \"Brando Moruzzi@@Empoli\": {\n    \"year\": 2004,\n    \"role\": \"D\"\n  },\n  \"Stiven Shpendi@@Empoli\": {\n    \"year\": 2003,\n    \"role\": \"A\"\n  },\n  \"Andrea Sodero@@Empoli\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Lovro Stubljar@@Empoli\": {\n    \"year\": 2004,\n    \"role\": \"P\"\n  },\n  \"Lorenzo Tosto@@Empoli\": {\n    \"year\": 2005,\n    \"role\": \"C\"\n  },\n  \"Maat Daniel Caprini@@Fiorentina\": {\n    \"year\": 2005,\n    \"role\": \"D\"\n  },\n  \"Pietro Comuzzo@@Fiorentina\": {\n    \"year\": 2005,\n    \"role\": \"D\"\n  },\n  \"Jacopo Fazzini@@Fiorentina\": {\n    \"year\": 2003,\n    \"role\": \"C\"\n  },\n  \"Niccolò Fortini@@Fiorentina\": {\n    \"year\": 2006,\n    \"role\": \"D\"\n  },\n  \"Gino Infantino@@Fiorentina\": {\n    \"year\": 2003,\n    \"role\": \"C\"\n  },\n  \"Michael Kayode@@Fiorentina\": {\n    \"year\": 2004,\n    \"role\": \"D\"\n  },\n  \"Eman Kospo@@Fiorentina\": {\n    \"year\": 2007,\n    \"role\": \"A\"\n  },\n  \"Tommaso Martinelli@@Fiorentina\": {\n    \"year\": 2006,\n    \"role\": \"P\"\n  },\n  \"Cher Ndour@@Fiorentina\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Tommaso Rubino@@Fiorentina\": {\n    \"year\": 2006,\n    \"role\": \"C\"\n  },\n  \"Valentín Carboni@@Genoa\": {\n    \"year\": 2005,\n    \"role\": \"C\"\n  },\n  \"Hugo Cuenca@@Genoa\": {\n    \"year\": 2005,\n    \"role\": \"C\"\n  },\n  \"Jeff Ekhator@@Genoa\": {\n    \"year\": 2006,\n    \"role\": \"A\"\n  },\n  \"Seydou Fini@@Genoa\": {\n    \"year\": 2006,\n    \"role\": \"A\"\n  },\n  \"Lior Kassa@@Genoa\": {\n    \"year\": 2005,\n    \"role\": \"D\"\n  },\n  \"Alan Matturro@@Genoa\": {\n    \"year\": 2004,\n    \"role\": \"D\"\n  },\n  \"Fabio Miretti@@Genoa\": {\n    \"year\": 2003,\n    \"role\": \"C\"\n  },\n  \"Brooke Norton-Cuffy@@Genoa\": {\n    \"year\": 2004,\n    \"role\": \"D\"\n  },\n  \"Sebastian Otoa@@Genoa\": {\n    \"year\": 2004,\n    \"role\": \"D\"\n  },\n  \"Christos Papadopoulos@@Genoa\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Lorenzo Venturino@@Genoa\": {\n    \"year\": 2006,\n    \"role\": \"P\"\n  },\n  \"Junior Ajayi@@Hellas Verona\": {\n    \"year\": 2004,\n    \"role\": \"A\"\n  },\n  \"Fallou Cham@@Hellas Verona\": {\n    \"year\": 2006,\n    \"role\": \"A\"\n  },\n  \"Alphadjo Cissè@@Hellas Verona\": {\n    \"year\": 2006,\n    \"role\": \"D\"\n  },\n  \"Diego Coppola@@Hellas Verona\": {\n    \"year\": 2003,\n    \"role\": \"D\"\n  },\n  \"Christian Corradi@@Hellas Verona\": {\n    \"year\": 2005,\n    \"role\": \"C\"\n  },\n  \"Mathis Lambourde@@Hellas Verona\": {\n    \"year\": 2006,\n    \"role\": \"C\"\n  },\n  \"Federico Magro@@Hellas Verona\": {\n    \"year\": 2005,\n    \"role\": \"C\"\n  },\n  \"Tobias Slotsager@@Hellas Verona\": {\n    \"year\": 2006,\n    \"role\": \"P\"\n  },\n  \"Mike Aidoo@@Inter Milan\": {\n    \"year\": 2004,\n    \"role\": \"D\"\n  },\n  \"Ebenezer Akinsanmiro@@Inter Milan\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Ange-Yoan Bonny@@Inter Milan\": {\n    \"year\": 2003,\n    \"role\": \"A\"\n  },\n  \"Franco Carboni@@Inter Milan\": {\n    \"year\": 2003,\n    \"role\": \"D\"\n  },\n  \"Pio Esposito@@Inter Milan\": {\n    \"year\": 2005,\n    \"role\": \"A\"\n  },\n  \"Tomás Palacios@@Inter Milan\": {\n    \"year\": 2003,\n    \"role\": \"D\"\n  },\n  \"Petar Sučić@@Inter Milan\": {\n    \"year\": 2003,\n    \"role\": \"C\"\n  },\n  \"Vasilije Adžić@@Juventus\": {\n    \"year\": 2006,\n    \"role\": \"C\"\n  },\n  \"Alberto Costa@@Juventus\": {\n    \"year\": 2004,\n    \"role\": \"D\"\n  },\n  \"Facundo González@@Juventus\": {\n    \"year\": 2003,\n    \"role\": \"D\"\n  },\n  \"Dean Huijsen@@Juventus\": {\n    \"year\": 2005,\n    \"role\": \"D\"\n  },\n  \"Samuel Mbangula@@Juventus\": {\n    \"year\": 2004,\n    \"role\": \"A\"\n  },\n  \"Jonas Rouhi@@Juventus\": {\n    \"year\": 2004,\n    \"role\": \"D\"\n  },\n  \"Nicolò Savona@@Juventus\": {\n    \"year\": 2003,\n    \"role\": \"D\"\n  },\n  \"Renato Veiga@@Juventus\": {\n    \"year\": 2003,\n    \"role\": \"D\"\n  },\n  \"Kenan Yıldız@@Juventus\": {\n    \"year\": 2005,\n    \"role\": \"A\"\n  },\n  \"Reda Belahyane@@Lazio\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Filipe Bordon@@Lazio\": {\n    \"year\": 2005,\n    \"role\": \"D\"\n  },\n  \"Saná Fernandes@@Lazio\": {\n    \"year\": 2006,\n    \"role\": \"A\"\n  },\n  \"Diego González@@Lazio\": {\n    \"year\": 2003,\n    \"role\": \"D\"\n  },\n  \"Arijon Ibrahimovic@@Lazio\": {\n    \"year\": 2005,\n    \"role\": \"A\"\n  },\n  \"Cristo Muñoz@@Lazio\": {\n    \"year\": 2005,\n    \"role\": \"A\"\n  },\n  \"Romano Floriani Mussolini@@Lazio\": {\n    \"year\": 2003,\n    \"role\": \"D\"\n  },\n  \"Davide Renzetti@@Lazio\": {\n    \"year\": 2006,\n    \"role\": \"C\"\n  },\n  \"Fabio Andrea Ruggeri@@Lazio\": {\n    \"year\": 2004,\n    \"role\": \"D\"\n  },\n  \"Vernon Addo@@Lecce\": {\n    \"year\": 2005,\n    \"role\": \"D\"\n  },\n  \"Medon Berisha@@Lecce\": {\n    \"year\": 2003,\n    \"role\": \"C\"\n  },\n  \"Francesco Camarda@@Lecce\": {\n    \"year\": 2008,\n    \"role\": \"A\"\n  },\n  \"Giacomo Faticanti@@Lecce\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Olaf Gorter@@Lecce\": {\n    \"year\": 2005,\n    \"role\": \"P\"\n  },\n  \"Lovro Herceg@@Lecce\": {\n    \"year\": 2005,\n    \"role\": \"D\"\n  },\n  \"Niko Kovač@@Lecce\": {\n    \"year\": 2005,\n    \"role\": \"C\"\n  },\n  \"Ed McJannet@@Lecce\": {\n    \"year\": 2004,\n    \"role\": \"D\"\n  },\n  \"Matías Pérez@@Lecce\": {\n    \"year\": 2005,\n    \"role\": \"C\"\n  },\n  \"Daniel Samek@@Lecce\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Jasper Samooja@@Lecce\": {\n    \"year\": 2003,\n    \"role\": \"P\"\n  },\n  \"Tiago Gabriel@@Lecce\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Yacine Adli@@AC Milan\": {\n    \"year\": 2000,\n    \"role\": \"C\"\n  },\n  \"Zachary Athekame@@AC Milan\": {\n    \"year\": 2004,\n    \"role\": \"D\"\n  },\n  \"Davide Bartesaghi@@AC Milan\": {\n    \"year\": 2005,\n    \"role\": \"D\"\n  },\n  \"Warren Bondo@@AC Milan\": {\n    \"year\": 2003,\n    \"role\": \"C\"\n  },\n  \"Álex Jiménez@@AC Milan\": {\n    \"year\": 2005,\n    \"role\": \"D\"\n  },\n  \"Luka Romero@@AC Milan\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Jan-Carlo Simić@@AC Milan\": {\n    \"year\": 2005,\n    \"role\": \"D\"\n  },\n  \"Lorenzo Torriani@@AC Milan\": {\n    \"year\": 2005,\n    \"role\": \"P\"\n  },\n  \"Chaka Traorè@@AC Milan\": {\n    \"year\": 2004,\n    \"role\": \"A\"\n  },\n  \"Kevin Zeroli@@AC Milan\": {\n    \"year\": 2005,\n    \"role\": \"C\"\n  },\n  \"Leonardo Colombo@@Monza\": {\n    \"year\": 2005,\n    \"role\": \"A\"\n  },\n  \"Omari Forson@@Monza\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Stefan Leković@@Monza\": {\n    \"year\": 2004,\n    \"role\": \"D\"\n  },\n  \"Kevin Martins@@Monza\": {\n    \"year\": 2005,\n    \"role\": \"C\"\n  },\n  \"Andrea Mazza@@Monza\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Samuele Vignato@@Monza\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Giuseppe Ambrosino@@Napoli\": {\n    \"year\": 2003,\n    \"role\": \"A\"\n  },\n  \"Mathias Ferrante@@Napoli\": {\n    \"year\": 2006,\n    \"role\": \"C\"\n  },\n  \"Luis Hasa@@Napoli\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Luca Marianucci@@Napoli\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Nosa Edward Obaretin@@Napoli\": {\n    \"year\": 2003,\n    \"role\": \"D\"\n  },\n  \"Antonio Vergara@@Napoli\": {\n    \"year\": 2003,\n    \"role\": \"A\"\n  },\n  \"Nathan Buayi-Kiala@@Parma\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Anas Haj Mohamed@@Parma\": {\n    \"year\": 2005,\n    \"role\": \"C\"\n  },\n  \"Mateusz Kowalski@@Parma\": {\n    \"year\": 2005,\n    \"role\": \"C\"\n  },\n  \"Giovanni Leoni@@Parma\": {\n    \"year\": 2006,\n    \"role\": \"D\"\n  },\n  \"Daniel Mikolajewski@@Parma\": {\n    \"year\": 2006,\n    \"role\": \"C\"\n  },\n  \"Manuel Moretta@@Parma\": {\n    \"year\": 2005,\n    \"role\": \"C\"\n  },\n  \"Elia Plicco@@Parma\": {\n    \"year\": 2006,\n    \"role\": \"C\"\n  },\n  \"Dario Sits@@Parma\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Nicolas Trabucchi@@Parma\": {\n    \"year\": 2007,\n    \"role\": \"P\"\n  },\n  \"Antonello Vona@@Parma\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Tommaso Baldanzi@@AS Roma\": {\n    \"year\": 2003,\n    \"role\": \"C\"\n  },\n  \"Luigi Cherubini@@AS Roma\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"João Costa@@AS Roma\": {\n    \"year\": 2005,\n    \"role\": \"D\"\n  },\n  \"Evan Ferguson@@AS Roma\": {\n    \"year\": 2004,\n    \"role\": \"A\"\n  },\n  \"Daniele Ghilardi@@AS Roma\": {\n    \"year\": 2003,\n    \"role\": \"D\"\n  },\n  \"Mattia Mannini@@AS Roma\": {\n    \"year\": 2006,\n    \"role\": \"C\"\n  },\n  \"Riccardo Pagano@@AS Roma\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Niccolò Pisilli@@AS Roma\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Matteo Plaia@@AS Roma\": {\n    \"year\": 2006,\n    \"role\": \"C\"\n  },\n  \"Devyne Rensch@@AS Roma\": {\n    \"year\": 2003,\n    \"role\": \"D\"\n  },\n  \"Buba Sangaré@@AS Roma\": {\n    \"year\": 2007,\n    \"role\": \"A\"\n  },\n  \"Matías Soulé@@AS Roma\": {\n    \"year\": 2003,\n    \"role\": \"A\"\n  },\n  \"Wesley@@AS Roma\": {\n    \"year\": 2003,\n    \"role\": \"A\"\n  },\n  \"Radoslaw Zelezny@@AS Roma\": {\n    \"year\": 2006,\n    \"role\": \"C\"\n  },\n  \"Côme Bianay Balcot@@Torino\": {\n    \"year\": 2005,\n    \"role\": \"C\"\n  },\n  \"Aaron Ciammaglichella@@Torino\": {\n    \"year\": 2005,\n    \"role\": \"C\"\n  },\n  \"Ali Dembélé@@Torino\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Gvidas Gineitis@@Torino\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Emirhan İlkhan@@Torino\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Senan Mullen@@Torino\": {\n    \"year\": 2005,\n    \"role\": \"D\"\n  },\n  \"Alieu Njie@@Torino\": {\n    \"year\": 2005,\n    \"role\": \"A\"\n  },\n  \"Sergiu Perciun@@Torino\": {\n    \"year\": 2006,\n    \"role\": \"C\"\n  },\n  \"Francesco Plaia@@Torino\": {\n    \"year\": 2006,\n    \"role\": \"C\"\n  },\n  \"Zanos Savva@@Torino\": {\n    \"year\": 2005,\n    \"role\": \"C\"\n  },\n  \"Arthur Atta@@Udinese\": {\n    \"year\": 2003,\n    \"role\": \"C\"\n  },\n  \"Nicolò Bertola@@Udinese\": {\n    \"year\": 2003,\n    \"role\": \"D\"\n  },\n  \"Iker Bravo@@Udinese\": {\n    \"year\": 2005,\n    \"role\": \"A\"\n  },\n  \"Sekou Diawara@@Udinese\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Gonçalo Esteves@@Udinese\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Saba Goglichidze@@Udinese\": {\n    \"year\": 2004,\n    \"role\": \"D\"\n  },\n  \"Lennon Miller@@Udinese\": {\n    \"year\": 2006,\n    \"role\": \"C\"\n  },\n  \"Alessandro Nunziante@@Udinese\": {\n    \"year\": 2007,\n    \"role\": \"P\"\n  },\n  \"Simone Pafundi@@Udinese\": {\n    \"year\": 2006,\n    \"role\": \"A\"\n  },\n  \"Matteo Palma@@Udinese\": {\n    \"year\": 2008,\n    \"role\": \"C\"\n  },\n  \"David Pejičić@@Udinese\": {\n    \"year\": 2007,\n    \"role\": \"C\"\n  },\n  \"Damián Pizarro@@Udinese\": {\n    \"year\": 2005,\n    \"role\": \"A\"\n  },\n  \"Vivaldo Semedo@@Udinese\": {\n    \"year\": 2005,\n    \"role\": \"C\"\n  },\n  \"Issa Doumbia@@Venezia\": {\n    \"year\": 2003,\n    \"role\": \"C\"\n  },\n  \"Saad El Haddad@@Venezia\": {\n    \"year\": 2005,\n    \"role\": \"C\"\n  },\n  \"Alessandro Pietrelli@@Venezia\": {\n    \"year\": 2003,\n    \"role\": \"D\"\n  },\n  \"Richie Sagrado@@Venezia\": {\n    \"year\": 2004,\n    \"role\": \"C\"\n  },\n  \"Federico Tavernaro@@Venezia\": {\n    \"year\": 2005,\n    \"role\": \"C\"\n  },\n  \"Alvin Okoro@@Venezia\": {\n    \"year\": 2005,\n    \"role\": \"A\"\n  },\n  \"Nicolò Fagioli@@Juventus\": {\n    \"year\": 2001,\n    \"role\": \"C\"\n  },\n  \"Cesare Casadei@@Chelsea\": {\n    \"year\": 2003,\n    \"role\": \"C\"\n  }\n}\n"},{"path":"data/serie_a_teams_2025_26.json","size":251,"sha1":"a584262d9d2af3c4a8b176aa30d1253da386f475","mtime":1755030727,"is_binary":false,"encoding":"utf-8","content":"[\n  \"Inter\",\n  \"Milan\",\n  \"Juventus\",\n  \"Napoli\",\n  \"Roma\",\n  \"Lazio\",\n  \"Atalanta\",\n  \"Fiorentina\",\n  \"Bologna\",\n  \"Torino\",\n  \"Genoa\",\n  \"Monza\",\n  \"Udinese\",\n  \"Lecce\",\n  \"Empoli\",\n  \"Cagliari\",\n  \"Hellas Verona\",\n  \"Parma\",\n  \"Como\",\n  \"Venezia\"\n]"},{"path":"data_enricher.py","size":5626,"sha1":"c62bdbe642e5dc3416d3b8bffb24535fdb14bf05","mtime":1754418767,"is_binary":false,"encoding":"utf-8","content":"\nimport json\nfrom fantacalcio_data import SAMPLE_PLAYERS, League, AuctionHelper\nfrom knowledge_manager import KnowledgeManager\n\ndef generate_player_knowledge():\n    \"\"\"Generate knowledge entries for all sample players\"\"\"\n    knowledge_entries = []\n    \n    for player in SAMPLE_PLAYERS:\n        # Basic player info\n        basic_info = f\"{player.name} è {'un portiere' if player.role == 'P' else 'un difensore' if player.role == 'D' else 'un centrocampista' if player.role == 'C' else 'un attaccante'} {f'del {player.team}' if player.team else ''} con fantamedia {player.fantamedia} e prezzo consigliato {player.price}. Ha giocato {player.appearances} partite nella stagione.\"\n        \n        knowledge_entries.append({\n            \"text\": basic_info,\n            \"metadata\": {\n                \"type\": \"player_info\",\n                \"role\": player.role,\n                \"team\": player.team,\n                \"player\": player.name,\n                \"price\": player.price,\n                \"fantamedia\": player.fantamedia\n            },\n            \"id\": f\"{player.name.lower().replace(' ', '_')}_basic\"\n        })\n        \n        # Price analysis\n        if player.price > 30:\n            price_analysis = f\"{player.name} costa {player.price} crediti, è un investimento importante. Con fantamedia {player.fantamedia}, {'si ripaga' if player.fantamedia > 6.5 else 'potrebbe essere rischioso'}.\"\n            knowledge_entries.append({\n                \"text\": price_analysis,\n                \"metadata\": {\n                    \"type\": \"price_analysis\",\n                    \"role\": player.role,\n                    \"player\": player.name,\n                    \"price_tier\": \"premium\"\n                },\n                \"id\": f\"{player.name.lower().replace(' ', '_')}_price\"\n            })\n        \n        # Role-specific advice\n        if player.role == \"A\" and player.fantamedia > 6.5:\n            advice = f\"{player.name} è un attaccante affidabile per il fantacalcio. Con fantamedia {player.fantamedia}, è una scelta sicura per l'attacco.\"\n            knowledge_entries.append({\n                \"text\": advice,\n                \"metadata\": {\n                    \"type\": \"role_recommendation\",\n                    \"role\": \"A\",\n                    \"player\": player.name,\n                    \"tier\": \"top\"\n                },\n                \"id\": f\"{player.name.lower().replace(' ', '_')}_recommendation\"\n            })\n    \n    return knowledge_entries\n\ndef generate_strategy_knowledge():\n    \"\"\"Generate strategic knowledge for different league types\"\"\"\n    strategies = []\n    \n    # Budget strategies\n    budgets = [300, 500, 750, 1000]\n    for budget in budgets:\n        strategy = f\"Con budget {budget}, consiglia di distribuire: {int(budget*0.22)}% per l'attacco ({int(budget*0.22)} crediti), {int(budget*0.32)}% per il centrocampo ({int(budget*0.32)} crediti), {int(budget*0.28)}% per la difesa ({int(budget*0.28)} crediti), {int(budget*0.18)}% per i portieri ({int(budget*0.18)} crediti).\"\n        \n        strategies.append({\n            \"text\": strategy,\n            \"metadata\": {\n                \"type\": \"budget_strategy\",\n                \"budget\": budget,\n                \"category\": \"distribution\"\n            },\n            \"id\": f\"budget_strategy_{budget}\"\n        })\n    \n    # League type strategies\n    league_strategies = {\n        \"Classic\": \"Nel Classic, punta su giocatori con fantamedia alta e bonus frequenti. Evita scommesse rischiose.\",\n        \"Mantra\": \"Nel Mantra, gli assist valgono di più. Priorizza centrocampisti creativi e esterni offensivi.\",\n        \"Draft\": \"Nel Draft non c'è budget. Prendi prima i migliori giocatori disponibili, indipendentemente dal ruolo.\",\n        \"Superscudetto\": \"Nel Superscudetto, i premi extra giustificano investimenti su top player. Meglio pochi fenomeni che tanti buoni.\"\n    }\n    \n    for league_type, strategy in league_strategies.items():\n        strategies.append({\n            \"text\": strategy,\n            \"metadata\": {\n                \"type\": \"league_strategy\",\n                \"league_type\": league_type\n            },\n            \"id\": f\"strategy_{league_type.lower()}\"\n        })\n    \n    return strategies\n\ndef enrich_knowledge_base():\n    \"\"\"Enrich the knowledge base with generated data\"\"\"\n    km = KnowledgeManager()\n    \n    # Generate and add player knowledge\n    player_knowledge = generate_player_knowledge()\n    for entry in player_knowledge:\n        km.add_knowledge(entry[\"text\"], entry[\"metadata\"], entry[\"id\"])\n    \n    # Generate and add strategy knowledge\n    strategy_knowledge = generate_strategy_knowledge()\n    for entry in strategy_knowledge:\n        km.add_knowledge(entry[\"text\"], entry[\"metadata\"], entry[\"id\"])\n    \n    print(f\"✅ Added {len(player_knowledge)} player entries and {len(strategy_knowledge)} strategy entries to knowledge base\")\n\ndef export_to_jsonl(filename=\"extended_training_data.jsonl\"):\n    \"\"\"Export all generated knowledge to JSONL for fine-tuning\"\"\"\n    all_entries = []\n    \n    # Get player and strategy knowledge\n    all_entries.extend(generate_player_knowledge())\n    all_entries.extend(generate_strategy_knowledge())\n    \n    # Write to JSONL\n    with open(filename, 'w', encoding='utf-8') as f:\n        for entry in all_entries:\n            f.write(json.dumps(entry, ensure_ascii=False) + '\\n')\n    \n    print(f\"✅ Exported {len(all_entries)} entries to {filename}\")\n\nif __name__ == \"__main__\":\n    print(\"🔄 Enriching knowledge base...\")\n    enrich_knowledge_base()\n    \n    print(\"📄 Exporting to JSONL...\")\n    export_to_jsonl()\n    \n    print(\"✅ Knowledge base enrichment completed!\")\n"},{"path":"data_quality_manager.py","size":9039,"sha1":"be390599174ef6306b038a534182fb8a37477911","mtime":1755192266,"is_binary":false,"encoding":"utf-8","content":"\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\nData Quality Manager - Comprehensive tool for managing obsolete and incorrect data\n\"\"\"\n\nimport json\nimport sqlite3\nfrom typing import Dict, List, Any\nfrom corrections_manager import CorrectionsManager\n\n# Import the correct FantacalcioAssistant\nimport sys\nimport os\nsys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))\n\nfrom fantacalcio_assistant import FantacalcioAssistant\n\nclass DataQualityManager:\n    def __init__(self):\n        self.corrections_manager = CorrectionsManager()\n        self.assistant = FantacalcioAssistant()\n        \n        # Known problematic data for 2024-25 season\n        self.obsolete_players = {\n            \"Samir Handanovic\": {\"reason\": \"Retired/not playing\", \"replacement\": None},\n            \"Wojciech Szczesny\": {\"reason\": \"Transferred/not in Serie A\", \"replacement\": None},\n            \"Gianluigi Donnarumma\": {\"reason\": \"Plays for PSG, not Serie A\", \"replacement\": None},\n            \"Marco Silvestri\": {\"reason\": \"Not first choice/outdated data\", \"replacement\": None},\n            \"Milan Skriniar\": {\"reason\": \"Plays for PSG, not Serie A\", \"replacement\": None},\n            \"Davide Calabria\": {\"reason\": \"Outdated/inconsistent data\", \"replacement\": None}\n        }\n        \n        self.team_updates = {\n            \"Alvaro Morata\": \"Como\",\n            \"Khvicha Kvaratskhelia\": \"PSG\",  # Transferred out of Serie A\n        }\n        \n        # Current Serie A 2024-25 teams\n        self.current_serie_a = {\n            \"Atalanta\", \"Bologna\", \"Cagliari\", \"Como\", \"Empoli\", \"Fiorentina\",\n            \"Genoa\", \"Inter\", \"Juventus\", \"Lazio\", \"Lecce\", \"Milan\",\n            \"Monza\", \"Napoli\", \"Parma\", \"Roma\", \"Torino\", \"Udinese\",\n            \"Venezia\", \"Verona\"\n        }\n    \n    def clean_obsolete_data(self):\n        \"\"\"Remove all known obsolete players\"\"\"\n        print(\"🧹 Cleaning obsolete player data...\")\n        \n        removed_count = 0\n        for player_name, info in self.obsolete_players.items():\n            try:\n                result = self.corrections_manager.remove_player(player_name, info[\"reason\"])\n                print(f\"✅ {result}\")\n                removed_count += 1\n            except Exception as e:\n                print(f\"❌ Failed to remove {player_name}: {e}\")\n        \n        print(f\"\\n📊 Removed {removed_count} obsolete players\")\n        return removed_count\n    \n    def update_team_transfers(self):\n        \"\"\"Update known team transfers\"\"\"\n        print(\"🔄 Updating team transfers...\")\n        \n        updated_count = 0\n        for player_name, new_team in self.team_updates.items():\n            try:\n                # Check if new team is Serie A\n                if new_team in self.current_serie_a:\n                    result = self.corrections_manager.update_player_team(player_name, \"Previous Team\", new_team)\n                    print(f\"✅ {result}\")\n                else:\n                    # If transferred outside Serie A, remove\n                    result = self.corrections_manager.remove_player(player_name, f\"Transferred to {new_team} (non-Serie A)\")\n                    print(f\"🚫 {result}\")\n                updated_count += 1\n            except Exception as e:\n                print(f\"❌ Failed to update {player_name}: {e}\")\n        \n        print(f\"\\n📊 Updated {updated_count} player transfers\")\n        return updated_count\n    \n    def filter_non_serie_a_teams(self):\n        \"\"\"Identify and mark non-Serie A players for removal\"\"\"\n        print(\"🏟️ Filtering non-Serie A teams...\")\n        \n        all_players = self.assistant._collect_all_players()\n        non_serie_a_count = 0\n        \n        for player in all_players:\n            team = player.get(\"team\", \"\").strip()\n            player_name = player.get(\"name\", \"\").strip()\n            \n            if team and player_name:\n                # Normalize team name for comparison\n                team_normalized = team.lower().replace(\" \", \"\").replace(\"-\", \"\")\n                serie_a_normalized = {t.lower().replace(\" \", \"\").replace(\"-\", \"\") for t in self.current_serie_a}\n                \n                if team_normalized not in serie_a_normalized:\n                    try:\n                        self.corrections_manager.remove_player(player_name, f\"Non-Serie A team: {team}\")\n                        print(f\"🚫 Removed {player_name} (plays for {team})\")\n                        non_serie_a_count += 1\n                    except Exception as e:\n                        print(f\"❌ Failed to remove {player_name}: {e}\")\n        \n        print(f\"\\n📊 Filtered {non_serie_a_count} non-Serie A players\")\n        return non_serie_a_count\n    \n    def validate_data_integrity(self):\n        \"\"\"Validate and report on data integrity issues\"\"\"\n        print(\"🔍 Validating data integrity...\")\n        \n        all_players = self.assistant._collect_all_players()\n        issues = {\n            \"missing_price\": [],\n            \"missing_fantamedia\": [],\n            \"invalid_roles\": [],\n            \"suspicious_names\": []\n        }\n        \n        valid_roles = {\"P\", \"D\", \"C\", \"A\"}\n        \n        for player in all_players:\n            name = player.get(\"name\", \"\").strip()\n            price = player.get(\"price\")\n            fantamedia = player.get(\"fantamedia\")\n            role = player.get(\"role\", \"\").strip().upper()\n            \n            if not price:\n                issues[\"missing_price\"].append(name)\n            \n            if not fantamedia:\n                issues[\"missing_fantamedia\"].append(name)\n            \n            if role not in valid_roles:\n                issues[\"invalid_roles\"].append(f\"{name} (role: {role})\")\n            \n            # Check for suspicious names\n            if len(name) < 3 or any(char.isdigit() for char in name):\n                issues[\"suspicious_names\"].append(name)\n        \n        # Report issues\n        print(\"\\n📋 Data Integrity Report:\")\n        for issue_type, players in issues.items():\n            if players:\n                print(f\"• {issue_type.replace('_', ' ').title()}: {len(players)} players\")\n                if len(players) <= 10:  # Show first 10\n                    for player in players[:10]:\n                        print(f\"  - {player}\")\n                else:\n                    print(f\"  - {players[0]} (and {len(players)-1} others)\")\n        \n        return issues\n    \n    def run_comprehensive_cleanup(self):\n        \"\"\"Run all cleanup operations\"\"\"\n        print(\"🚀 Starting comprehensive data cleanup...\\n\")\n        \n        # Get initial stats\n        initial_report = self.assistant.get_data_quality_report()\n        print(f\"📊 Initial stats: {initial_report['roster_stats']['total_players']} total players\")\n        \n        # Run cleanup operations\n        removed = self.clean_obsolete_data()\n        updated = self.update_team_transfers()\n        filtered = self.filter_non_serie_a_teams()\n        \n        # Validate remaining data\n        issues = self.validate_data_integrity()\n        \n        # Get final stats\n        final_report = self.assistant.get_data_quality_report()\n        \n        print(f\"\\n🎯 Cleanup Summary:\")\n        print(f\"• Obsolete players removed: {removed}\")\n        print(f\"• Team transfers updated: {updated}\")\n        print(f\"• Non-Serie A players filtered: {filtered}\")\n        print(f\"• Final player count: {final_report['roster_stats']['total_players']}\")\n        print(f\"• Data completeness: {final_report['roster_stats']['data_completeness']}%\")\n        \n        return {\n            \"removed\": removed,\n            \"updated\": updated,\n            \"filtered\": filtered,\n            \"final_stats\": final_report\n        }\n\ndef main():\n    manager = DataQualityManager()\n    \n    print(\"Data Quality Manager - Fantasy Football Assistant\")\n    print(\"=\" * 50)\n    \n    while True:\n        print(\"\\nChoose an option:\")\n        print(\"1. Run comprehensive cleanup\")\n        print(\"2. Clean obsolete players only\")\n        print(\"3. Update team transfers only\")\n        print(\"4. Filter non-Serie A teams only\")\n        print(\"5. Validate data integrity\")\n        print(\"6. Get data quality report\")\n        print(\"0. Exit\")\n        \n        choice = input(\"\\nEnter your choice (0-6): \").strip()\n        \n        if choice == \"0\":\n            print(\"👋 Goodbye!\")\n            break\n        elif choice == \"1\":\n            manager.run_comprehensive_cleanup()\n        elif choice == \"2\":\n            manager.clean_obsolete_data()\n        elif choice == \"3\":\n            manager.update_team_transfers()\n        elif choice == \"4\":\n            manager.filter_non_serie_a_teams()\n        elif choice == \"5\":\n            manager.validate_data_integrity()\n        elif choice == \"6\":\n            report = manager.assistant.get_data_quality_report()\n            print(f\"\\n📊 Current Data Quality Report:\")\n            print(json.dumps(report, indent=2))\n        else:\n            print(\"❌ Invalid choice. Please try again.\")\n\nif __name__ == \"__main__\":\n    main()\n"},{"path":"debug_corrections.py","size":2630,"sha1":"95a5909ef5ac4dd629f2aef07b38f30dc6f0dac6","mtime":1755186267,"is_binary":false,"encoding":"utf-8","content":"\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport os\nimport sys\nfrom knowledge_manager import KnowledgeManager\nfrom corrections_manager import CorrectionsManager\n\ndef main():\n    print(\"=== CORRECTIONS DEBUG ===\")\n    \n    # Initialize managers\n    km = KnowledgeManager()\n    cm = CorrectionsManager(knowledge_manager=km)\n    \n    print(f\"ChromaDB collection count: {km.collection.count()}\")\n    \n    # Check for existing corrections\n    print(\"\\n=== RECENT CORRECTIONS ===\")\n    recent_corrections = cm.get_recent_corrections(limit=10)\n    \n    if recent_corrections:\n        for i, corr in enumerate(recent_corrections, 1):\n            print(f\"{i}. Wrong: {corr.get('wrong', '')}\")\n            print(f\"   Correct: {corr.get('correct', '')}\")\n            print(f\"   Created: {corr.get('created_at', '')}\")\n            print(f\"   Context: {corr.get('context', '')}\")\n            print()\n    else:\n        print(\"No corrections found\")\n    \n    # Test adding a specific correction for Kvaratskhelia\n    print(\"\\n=== ADDING TEST CORRECTION ===\")\n    test_correction_id = cm.add_player_correction(\n        player_name=\"Khvicha Kvaratskhelia\",\n        field_name=\"team\",\n        old_value=\"Napoli\",\n        new_value=\"Paris Saint-Germain\",\n        reason=\"Transferred to PSG in France\"\n    )\n    print(f\"Added correction ID: {test_correction_id}\")\n    \n    # Test correction retrieval for specific queries\n    print(\"\\n=== TESTING CORRECTIONS FOR COMMON QUERIES ===\")\n    test_queries = [\n        \"Kvaratskhelia\",\n        \"Khvicha\", \n        \"Napoli\",\n        \"PSG\"\n    ]\n    \n    for query in test_queries:\n        print(f\"\\nQuery: '{query}'\")\n        relevant = cm.get_relevant_corrections(query, limit=3)\n        if relevant:\n            for corr in relevant:\n                print(f\"  - Wrong: {corr.get('wrong', '')}\")\n                print(f\"    Correct: {corr.get('correct', '')}\")\n        else:\n            print(\"  No relevant corrections found\")\n    \n    # Test correction application\n    print(\"\\n=== TESTING CORRECTION APPLICATION ===\")\n    test_texts = [\n        \"**Khvicha Kvaratskhelia** (Napoli) — € 37\",\n        \"Migliori attaccanti: **Khvicha Kvaratskhelia** (Napoli)\",\n        \"Kvaratskhelia gioca nel Napoli\",\n        \"Il Como ha fatto ottimi acquisti\"\n    ]\n    \n    for text in test_texts:\n        corrected, applied = cm.apply_corrections_to_text(text)\n        print(f\"\\nOriginal: {text}\")\n        print(f\"Corrected: {corrected}\")\n        if applied:\n            print(f\"Applied: {', '.join(applied)}\")\n        else:\n            print(\"No corrections applied\")\n\nif __name__ == \"__main__\":\n    main()\n"},{"path":"debug_dump_km_text.py","size":0,"sha1":"da39a3ee5e6b4b0d3255bfef95601890afd80709","mtime":1755076395,"is_binary":false,"encoding":"utf-8","content":""},{"path":"debug_knowledge.py","size":1736,"sha1":"25c51214a6aba4fbee7506b0876047e9070f44de","mtime":1754821886,"is_binary":false,"encoding":"utf-8","content":"\n#!/usr/bin/env python3\n\nimport os\nfrom knowledge_manager import KnowledgeManager\nfrom retrieval.helpers import dump_chroma_texts_ids\nfrom retrieval.rag_pipeline import RAGPipeline\n\ndef diagnose_knowledge_base():\n    print(\"🔍 Diagnosing knowledge base...\")\n    \n    # Initialize knowledge manager\n    km = KnowledgeManager()\n    print(f\"📊 Collection count: {km.count()}\")\n    \n    # Sample some documents\n    print(\"\\n📄 Sample documents:\")\n    try:\n        results = km.search_knowledge(\"Osimhen\", n_results=3)\n        for i, result in enumerate(results):\n            print(f\"  {i+1}. {result['text'][:100]}...\")\n            print(f\"     Metadata: {result.get('metadata', {})}\")\n            print()\n    except Exception as e:\n        print(f\"❌ Error searching: {e}\")\n    \n    # Test RAG pipeline\n    print(\"🔄 Testing RAG pipeline...\")\n    try:\n        texts, ids = dump_chroma_texts_ids(km.collection)\n        rag = RAGPipeline(km.collection, texts, ids)\n        \n        # Test query\n        result = rag.retrieve(\"migliori attaccanti\", final_k=5)\n        print(f\"✅ RAG Results: {len(result['results'])} documents\")\n        print(f\"   Grounded: {result['grounded']}\")\n        print(f\"   Has conflicts: {result['has_conflict']}\")\n        print(f\"   Citations: {len(result['citations'])}\")\n        \n        if result['results']:\n            print(\"   First result:\")\n            first = result['results'][0]\n            print(f\"     Text: {first.get('text', '')[:100]}...\")\n            print(f\"     Metadata: {first.get('metadata', {})}\")\n    \n    except Exception as e:\n        print(f\"❌ RAG Error: {e}\")\n        import traceback\n        traceback.print_exc()\n\nif __name__ == \"__main__\":\n    diagnose_knowledge_base()\n"},{"path":"debug_scan_young.py","size":19991,"sha1":"4d3039f5fc7c1761122da6fc2488a0aae771c170","mtime":1755036037,"is_binary":false,"encoding":"utf-8","content":"# fantacalcio_assistant.py\n# -*- coding: utf-8 -*-\n\nimport os\nimport re\nimport json\nimport time\nimport httpx\nimport logging\nfrom datetime import datetime\nfrom typing import Any, Dict, List, Optional\n\nfrom knowledge_manager import KnowledgeManager\n\nLOG = logging.getLogger(\"fantacalcio_assistant\")\nlogging.basicConfig(\n    level=os.environ.get(\"LOG_LEVEL\", \"INFO\"),\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\n\n\ndef _env_true(val: Optional[str]) -> bool:\n    if val is None:\n        return False\n    return str(val).strip().lower() in {\"1\", \"true\", \"yes\", \"y\", \"on\"}\n\n\ndef _safe_float(x: Any, default: float = 0.0) -> float:\n    try:\n        return float(x)\n    except Exception:\n        return default\n\n\ndef _safe_int(x: Any) -> Optional[int]:\n    try:\n        return int(str(x).strip())\n    except Exception:\n        return None\n\n\nclass FantacalcioAssistant:\n    \"\"\"\n    Orchestrazione:\n    - prompt.json (regole)\n    - KnowledgeManager (Chroma + embeddings)\n    - roster locale (season_roster.json)\n    - fallback su cache esterna U21/U23 (file JSON prodotto da ETL web)\n\n    Novità:\n    - Estrazione età robusta (age, birth_year, dob YYYY-MM-DD / DD/MM/YYYY / YYYY)\n    - U21 su tutti i ruoli (o per ruolo se richiesto)\n    - Fallback automatico U23\n    - Se ancora vuoto → usa cache esterna (EXTERNAL_YOUTH_CACHE)\n    \"\"\"\n\n    def __init__(self) -> None:\n        LOG.info(\"Initializing FantacalcioAssistant...\")\n\n        self.enable_web_fallback: bool = _env_true(os.getenv(\"ENABLE_WEB_FALLBACK\", \"0\"))\n        LOG.info(\"[Assistant] ENABLE_WEB_FALLBACK raw='%s' parsed=%s\",\n                 os.getenv(\"ENABLE_WEB_FALLBACK\", \"0\"), self.enable_web_fallback)\n\n        self.roster_json_path: str = os.getenv(\"ROSTER_JSON_PATH\", \"./season_roster.json\")\n        LOG.info(\"[Assistant] ROSTER_JSON_PATH=%s\", self.roster_json_path)\n\n        self.external_youth_cache_path: str = os.getenv(\n            \"EXTERNAL_YOUTH_CACHE\", \"./cache/under21_cache.json\"\n        )\n        LOG.info(\"[Assistant] EXTERNAL_YOUTH_CACHE=%s\", self.external_youth_cache_path)\n\n        self.openai_api_key: str = os.getenv(\"OPENAI_API_KEY\", \"\")\n        self.openai_model: str = os.getenv(\"OPENAI_MODEL\", \"gpt-4o-mini\")\n        self.openai_temperature: float = float(os.getenv(\"OPENAI_TEMPERATURE\", \"0.20\"))\n        self.openai_max_tokens: int = int(os.getenv(\"OPENAI_MAX_TOKENS\", \"600\"))\n        LOG.info(\"[Assistant] OpenAI model=%s temp=%.2f max_tokens=%d\",\n                 self.openai_model, self.openai_temperature, self.openai_max_tokens)\n\n        self.system_prompt: str = self._load_prompt_json(\"./prompt.json\")\n\n        self.km: KnowledgeManager = KnowledgeManager()\n        LOG.info(\"[Assistant] KnowledgeManager attivo\")\n\n        self.roster: List[Dict[str, Any]] = self._load_and_normalize_roster(self.roster_json_path)\n        self.external_youth_cache: List[Dict[str, Any]] = self._load_external_youth_cache()\n\n        LOG.info(\"[Assistant] Inizializzazione completata\")\n\n    # ---------------------------\n    # Prompt\n    # ---------------------------\n    def _load_prompt_json(self, path: str) -> str:\n        try:\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                cfg = json.load(f)\n        except Exception as e:\n            LOG.error(\"[Assistant] Errore caricamento prompt: %s\", e)\n            return (\"Sei un assistente fantacalcio. Rispondi in modo conciso e pratico in italiano; \"\n                    \"non inventare dati e dichiara incertezza se mancano fonti.\")\n        if isinstance(cfg, dict):\n            if \"system\" in cfg and isinstance(cfg[\"system\"], dict):\n                sys = cfg[\"system\"]\n                name = sys.get(\"name\", \"fantacalcio_system\")\n                content = sys.get(\"content\", \"\")\n                style = sys.get(\"style\", \"\")\n                language = sys.get(\"language\", \"it\")\n                system_text = f\"[{name}] ({language}, {style})\\n{content}\".strip()\n                LOG.info(\"[Assistant] prompt.json caricato correttamente\")\n                return system_text\n            if \"prompt\" in cfg and isinstance(cfg[\"prompt\"], str):\n                LOG.info(\"[Assistant] prompt.json caricato correttamente\")\n                return cfg[\"prompt\"]\n        LOG.error(\"[Assistant] prompt.json non contiene 'system' o 'prompt' validi\")\n        return (\"Sei un assistente fantacalcio. Rispondi in modo conciso e pratico in italiano; \"\n                \"non inventare dati e dichiara incertezza se mancano fonti.\")\n\n    # ---------------------------\n    # Roster\n    # ---------------------------\n    def _load_and_normalize_roster(self, path: str) -> List[Dict[str, Any]]:\n        out: List[Dict[str, Any]] = []\n        if not os.path.exists(path):\n            LOG.warning(\"[Assistant] Roster file non trovato: %s\", path)\n            return out\n        try:\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                data = json.load(f)\n        except Exception as e:\n            LOG.error(\"[Assistant] Errore apertura roster: %s\", e)\n            return out\n\n        if not isinstance(data, list):\n            LOG.warning(\"[Assistant] roster non è una lista, lo ignoro\")\n            return out\n\n        cnt_total = len(data)\n        for item in data:\n            if not isinstance(item, dict):\n                continue\n            name = (item.get(\"name\") or item.get(\"player\") or \"\").strip()\n            role = (item.get(\"role\") or item.get(\"position\") or \"\").strip().upper()\n            team = (item.get(\"team\") or item.get(\"club\") or \"\").strip()\n\n            birth_year = item.get(\"birth_year\") or item.get(\"year_of_birth\")\n            dob = item.get(\"dob\") or item.get(\"date_of_birth\") or item.get(\"birthdate\")\n            age = item.get(\"age\") or item.get(\"eta\") or item.get(\"Age\")\n\n            price = item.get(\"price\") or item.get(\"cost\")\n            fm = item.get(\"fantamedia\") or item.get(\"avg\")\n\n            out.append({\n                \"name\": name, \"role\": role, \"team\": team,\n                \"birth_year\": birth_year, \"dob\": dob, \"age\": age,\n                \"price\": price, \"fantamedia\": fm\n            })\n\n        LOG.info(\"[Assistant] Roster normalizzato: %d/%d record utili\", len(out), cnt_total)\n        return out\n\n    # ---------------------------\n    # External youth cache\n    # ---------------------------\n    def _load_external_youth_cache(self) -> List[Dict[str, Any]]:\n        path = self.external_youth_cache_path\n        if not os.path.exists(path):\n            LOG.warning(\"[Assistant] Cache esterno U21 non trovato: %s\", path)\n            return []\n        try:\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                data = json.load(f)\n            if isinstance(data, list):\n                LOG.info(\"[Assistant] Youth cache caricato: %d record\", len(data))\n                return data\n            LOG.warning(\"[Assistant] Youth cache non-list, ignorato\")\n            return []\n        except Exception as e:\n            LOG.error(\"[Assistant] Errore lettura youth cache: %s\", e)\n            return []\n\n    # ---------------------------\n    # Helpers età / ruolo\n    # ---------------------------\n    def _extract_age_years(self, rec: Dict[str, Any], ref_date: Optional[datetime] = None) -> Optional[int]:\n        if ref_date is None:\n            ref_date = datetime(2025, 8, 1)  # stagione 2025-26 approx\n\n        # age diretto\n        for k in (\"age\", \"eta\", \"age_years\", \"Age\"):\n            v = rec.get(k)\n            iv = _safe_int(v)\n            if iv is not None and 0 < iv < 60:\n                return iv\n\n        # birth_year\n        for k in (\"birth_year\", \"year_of_birth\"):\n            by = _safe_int(rec.get(k))\n            if by and 1900 < by <= ref_date.year:\n                return ref_date.year - by\n\n        # date strings\n        for k in (\"dob\", \"date_of_birth\", \"birthdate\"):\n            s = str(rec.get(k) or \"\").strip()\n            if not s:\n                continue\n            # YYYY-MM-DD\n            m = re.match(r\"^\\s*(\\d{4})-(\\d{1,2})-(\\d{1,2})\\s*$\", s)\n            if m:\n                y = int(m.group(1))\n                if 1900 < y <= ref_date.year:\n                    return ref_date.year - y\n            # DD/MM/YYYY\n            m = re.match(r\"^\\s*(\\d{1,2})/(\\d{1,2})/(\\d{4})\\s*$\", s)\n            if m:\n                y = int(m.group(3))\n                if 1900 < y <= ref_date.year:\n                    return ref_date.year - y\n            # YYYY\n            m = re.match(r\"^\\s*(\\d{4})\\s*$\", s)\n            if m:\n                y = int(m.group(1))\n                if 1900 < y <= ref_date.year:\n                    return ref_date.year - y\n\n        return None\n\n    def _role_bucket(self, raw_role: str) -> str:\n        r = (raw_role or \"\").strip().upper()\n        if not r:\n            return \"\"\n        if r in {\"P\", \"GK\", \"POR\"}:\n            return \"P\"\n        if r in {\"D\", \"DEF\", \"DC\", \"CB\", \"RB\", \"LB\", \"TD\", \"TS\", \"BR\"}:\n            return \"D\"\n        if r in {\"C\", \"CM\", \"MED\", \"M\", \"MEZ\", \"RM\", \"LM\", \"CC\", \"TQ\", \"AM\", \"TRE\"}:\n            return \"C\"\n        if r in {\"A\", \"ATT\", \"ST\", \"SS\", \"PUN\", \"EST\", \"W\", \"LW\", \"RW\"}:\n            return \"A\"\n        if r and r[0] in {\"P\", \"D\", \"C\", \"A\"}:\n            return r[0]\n        return \"\"\n\n    # ---------------------------\n    # KM fetch\n    # ---------------------------\n    def _km_fetch_players(self, seasons: Optional[List[str]] = None, limit: int = 5000) -> List[Dict[str, Any]]:\n        seasons = seasons or [\"2025-26\", \"2024-25\"]\n        collected: List[Dict[str, Any]] = []\n\n        where = {\"$and\": [\n            {\"type\": {\"$in\": [\"player_info\", \"current_player\"]}},\n            {\"season\": {\"$in\": seasons}}\n        ]}\n        include = [\"metadatas\"]\n\n        try:\n            # firma “nuova” vista in alcuni log\n            res = self.km.search_knowledge(text=None, where=where, n_results=limit, include=include)\n            metas = res.get(\"metadatas\") or []\n        except TypeError:\n            # firma “vecchia”\n            res = self.km.search_knowledge(where=where, limit=limit, include=include)  # type: ignore\n            metas = res.get(\"metadatas\") or []\n        except Exception as e:\n            LOG.error(\"[Assistant] _km_fetch_players error: %s\", e)\n            metas = []\n\n        for m in metas:\n            if not isinstance(m, dict):\n                continue\n            name = (m.get(\"name\") or m.get(\"player\") or \"\").strip()\n            role = (m.get(\"role\") or m.get(\"position\") or \"\").strip().upper()\n            team = (m.get(\"team\") or m.get(\"club\") or \"\").strip()\n            birth_year = m.get(\"birth_year\") or m.get(\"year_of_birth\")\n            dob = m.get(\"dob\") or m.get(\"date_of_birth\") or m.get(\"birthdate\")\n            age = m.get(\"age\") or m.get(\"eta\")\n            price = m.get(\"price\") or m.get(\"cost\")\n            fm = m.get(\"fantamedia\") or m.get(\"avg\")\n\n            collected.append({\n                \"name\": name, \"role\": role, \"team\": team,\n                \"birth_year\": birth_year, \"dob\": dob, \"age\": age,\n                \"price\": price, \"fantamedia\": fm\n            })\n\n        LOG.info(\"[Assistant] _km_fetch_players: %d record\", len(collected))\n        return collected\n\n    # ---------------------------\n    # Merge roster + KM\n    # ---------------------------\n    def _collect_all_players(self) -> List[Dict[str, Any]]:\n        all_players = list(self.roster)\n        try:\n            all_players.extend(self._km_fetch_players())\n        except Exception as e:\n            LOG.error(\"[Assistant] errore nel fetch KM: %s\", e)\n\n        seen = set()\n        deduped: List[Dict[str, Any]] = []\n        for p in all_players:\n            if not isinstance(p, dict):\n                continue\n            name = (p.get(\"name\") or \"\").strip()\n            if not name:\n                continue\n            key = name.lower()\n            if key in seen:\n                continue\n            seen.add(key)\n            deduped.append(p)\n        return deduped\n\n    # ---------------------------\n    # Fallback cache esterno (U21/U23)\n    # ---------------------------\n    def _fallback_youth_from_cache(self, max_age: int, target_buckets: Optional[List[str]], k: int) -> List[Dict[str, Any]]:\n        pool = self.external_youth_cache or []\n        out: List[Dict[str, Any]] = []\n\n        for p in pool:\n            if not isinstance(p, dict):\n                continue\n            role_bucket = self._role_bucket(p.get(\"role\") or p.get(\"position\") or \"\")\n            if target_buckets and role_bucket not in target_buckets:\n                continue\n\n            # accetto età pronta o calcolo da birth_year/dob\n            age = None\n            if p.get(\"age\") is not None:\n                age = _safe_int(p.get(\"age\"))\n            if age is None:\n                age = self._extract_age_years(p)\n\n            if age is None or age > max_age:\n                continue\n\n            out.append({\n                \"name\": p.get(\"name\"),\n                \"team\": p.get(\"team\") or p.get(\"club\"),\n                \"role_bucket\": role_bucket or \"\",\n                \"age\": age,\n                \"fantamedia\": _safe_float(p.get(\"fantamedia\"), 0.0),\n                \"price\": _safe_float(p.get(\"price\"), 0.0),\n                \"_source\": \"external_cache\"\n            })\n\n        out.sort(key=lambda x: (-_safe_float(x.get(\"fantamedia\"), 0.0),\n                                _safe_float(x.get(\"price\"), 9999.0),\n                                (x.get(\"name\") or \"\")))\n        return out[:k]\n\n    # ---------------------------\n    # Suggeritori giovani (roster+KM)\n    # ---------------------------\n    def _suggest_young(self, max_age: int, target_buckets: Optional[List[str]] = None, k: int = 3) -> List[Dict[str, Any]]:\n        pool = self._collect_all_players()\n        candidates: List[Dict[str, Any]] = []\n\n        for p in pool:\n            role_bucket = self._role_bucket(p.get(\"role\") or \"\")\n            if target_buckets and role_bucket not in target_buckets:\n                continue\n            age = self._extract_age_years(p)\n            if age is None or age > max_age:\n                continue\n            candidates.append({\n                \"name\": p.get(\"name\"),\n                \"team\": p.get(\"team\"),\n                \"role_bucket\": role_bucket or \"\",\n                \"age\": age,\n                \"fantamedia\": _safe_float(p.get(\"fantamedia\"), 0.0),\n                \"price\": _safe_float(p.get(\"price\"), 0.0),\n                \"_source\": \"local_or_km\"\n            })\n\n        candidates.sort(key=lambda x: (-_safe_float(x.get(\"fantamedia\"), 0.0),\n                                       _safe_float(x.get(\"price\"), 9999.0),\n                                       (x.get(\"name\") or \"\")))\n        return candidates[:k]\n\n    # ---------------------------\n    # LLM (fallback generico)\n    # ---------------------------\n    def _llm_complete(self, user_text: str, context_messages: Optional[List[Dict[str, str]]] = None) -> str:\n        if not self.openai_api_key:\n            return (\"⚠️ Servizio AI temporaneamente non disponibile. \"\n                    \"Configura OPENAI_API_KEY e riavvia.\")\n        messages = [{\"role\": \"system\", \"content\": self.system_prompt}]\n        if context_messages:\n            messages.extend(context_messages)\n        messages.append({\"role\": \"user\", \"content\": user_text})\n        headers = {\"Authorization\": f\"Bearer {self.openai_api_key}\", \"Content-Type\": \"application/json\"}\n        payload = {\"model\": self.openai_model, \"temperature\": self.openai_temperature,\n                   \"max_tokens\": self.openai_max_tokens, \"messages\": messages}\n        try:\n            with httpx.Client(timeout=60.0) as client:\n                resp = client.post(\"https://api.openai.com/v1/chat/completions\",\n                                   headers=headers, json=payload)\n                resp.raise_for_status()\n                data = resp.json()\n                return data[\"choices\"][0][\"message\"][\"content\"].strip()\n        except Exception as e:\n            LOG.error(\"[Assistant] Errore OpenAI: %s\", e)\n            return \"⚠️ Servizio momentaneamente non disponibile. Riprova tra poco.\"\n\n    # ---------------------------\n    # Intent routing\n    # ---------------------------\n    def _extract_requested_k(self, user_text: str, default: int = 3) -> int:\n        m = re.search(r\"\\b(\\d{1,2})\\b\", user_text)\n        if not m:\n            return default\n        try:\n            val = int(m.group(1))\n            return max(1, min(10, val))\n        except Exception:\n            return default\n\n    def _format_young_answer(self, items: List[Dict[str, Any]], label: str, age_cap: int) -> str:\n        if not items:\n            return (f\"Nei miei dati non trovo profili **Under {age_cap}** con età certa per questo filtro. \"\n                    \"Se vuoi, posso proporti alternative senza filtro età.\")\n        lines = []\n        for p in items:\n            bits = [f\"**{p.get('name')}**\"]\n            team = p.get(\"team\")\n            if team:\n                bits.append(f\"({team})\")\n            meta = []\n            if p.get(\"age\") is not None:\n                meta.append(f\"{int(p['age'])} anni\")\n            if p.get(\"fantamedia\"):\n                meta.append(f\"FM {_safe_float(p['fantamedia']):.2f}\")\n            if p.get(\"price\"):\n                meta.append(f\"€ {int(_safe_float(p['price']))}\")\n            src = p.get(\"_source\")\n            if src == \"external_cache\":\n                meta.append(\"fonte: cache esterna\")\n            if meta:\n                bits.append(\" — \" + \", \".join(meta))\n            lines.append(\" \".join(bits))\n        return f\"Ecco {label} Under {age_cap}:\\n- \" + \"\\n- \".join(lines)\n\n    def get_response(self, user_text: str, mode: str = \"classic\",\n                     context: Optional[Dict[str, Any]] = None) -> str:\n        lt = user_text.lower()\n        u21_trigger = any(x in lt for x in [\"under 21\", \"under21\", \"u21\", \"under-21\"])\n\n        if u21_trigger:\n            k = self._extract_requested_k(user_text, default=3)\n            want_def = any(x in lt for x in [\"difensori\", \"difensore\", \"defender\", \"difensor\"])\n            want_mid = any(x in lt for x in [\"centrocampisti\", \"centrocampista\", \"midfielder\", \"mezz\", \"mediano\"])\n            want_fwd = any(x in lt for x in [\"attaccanti\", \"attaccante\", \"forward\", \"punta\", \"esterno offensivo\"])\n            bucket = None\n            if want_def:\n                bucket = [\"D\"]\n            elif want_mid:\n                bucket = [\"C\"]\n            elif want_fwd:\n                bucket = [\"A\"]\n\n            # 1) U21 locali/KM\n            items = self._suggest_young(max_age=20, target_buckets=bucket, k=k)\n            if items:\n                return self._format_young_answer(items, f\"{k} profili\", 21)\n\n            # 2) U23 locali/KM (fallback leggero)\n            items = self._suggest_young(max_age=22, target_buckets=bucket, k=k)\n            if items:\n                return (\"Non trovo U21 con età certa per quel filtro. \" +\n                        self._format_young_answer(items, f\"{k} alternative\", 23))\n\n            # 3) Fallback cache esterno se abilitato\n            if self.enable_web_fallback and self.external_youth_cache:\n                ext = self._fallback_youth_from_cache(max_age=20, target_buckets=bucket, k=k)\n                if ext:\n                    return (\"(Fallback esterno) \" +\n                            self._format_young_answer(ext, f\"{k} profili\", 21))\n\n                ext = self._fallback_youth_from_cache(max_age=22, target_buckets=bucket, k=k)\n                if ext:\n                    return (\"(Fallback esterno) Non ho U21 certi. \" +\n                            self._format_young_answer(ext, f\"{k} alternative\", 23))\n\n            # 4) Nessun dato\n            return (\"Non ho Under 21 affidabili con età nota per questo filtro. \"\n                    \"Se vuoi, abilita/aggiorna il cache esterno (EXTERNAL_YOUTH_CACHE) o togli il vincolo di età.\")\n\n        # fallback generico: LLM\n        return self._llm_complete(user_text, context_messages=[])\n"},{"path":"diagnose_chroma.py","size":1211,"sha1":"72bd3d53efdb433c7f47c3d63c121864ed00163a","mtime":1754982357,"is_binary":false,"encoding":"utf-8","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport os\nimport logging\nimport chromadb\n\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s - diag - %(levelname)s - %(message)s\")\nlog = logging.getLogger(\"diag\")\n\nDB_PATH = os.getenv(\"CHROMA_DB_PATH\", \"./chroma\")\nCOLL = os.getenv(\"CHROMA_COLLECTION\", \"fantacalcio_knowledge\")\n\ndef main():\n    log.info(\"CHROMA_DB_PATH=%s\", DB_PATH)\n    log.info(\"CHROMA_COLLECTION=%s\", COLL)\n\n    client = chromadb.PersistentClient(path=DB_PATH)\n\n    cols = client.list_collections()\n    if not cols:\n        log.warning(\"Nessuna collezione trovata nel path indicato.\")\n    else:\n        for c in cols:\n            try:\n                _c = client.get_collection(c.name)\n                cnt = _c.count()\n                log.info(\"Collection: %s -> %s items\", c.name, cnt)\n            except Exception as e:\n                log.error(\"Errore su collection %s: %s\", c.name, e)\n\n    try:\n        coll = client.get_or_create_collection(COLL)\n        cnt = coll.count()\n        log.info(\"Selezionata collection '%s' -> %s items\", COLL, cnt)\n    except Exception as e:\n        log.error(\"Errore apertura collection selezionata: %s\", e)\n\nif __name__ == \"__main__\":\n    main()\n"},{"path":"entity_guard.py","size":2998,"sha1":"8650f2d1eb3ac6875109de4bfbd51e1baba11728","mtime":1754980864,"is_binary":false,"encoding":"utf-8","content":"# entity_guard.py\n# -*- coding: utf-8 -*-\nimport json\nimport logging\nfrom typing import List, Dict, Any, Optional\nfrom difflib import get_close_matches\nfrom datetime import datetime\n\nlogger = logging.getLogger(\"entity_guard\")\nlogger.setLevel(logging.INFO)\n\nclass RosterStore:\n    def __init__(self, path: str = \"season_roster.json\"):\n        self.path = path\n\n    def load(self) -> Dict[str, Any]:\n        try:\n            with open(self.path, \"r\", encoding=\"utf-8\") as f:\n                return json.load(f)\n        except Exception:\n            return {\n                \"season\": None,\n                \"league\": \"Serie A\",\n                \"updated_at\": None,\n                \"players\": []\n            }\n\n    def save(self, roster: Dict[str, Any]) -> None:\n        roster = dict(roster)\n        if \"updated_at\" not in roster or not roster[\"updated_at\"]:\n            roster[\"updated_at\"] = datetime.utcnow().isoformat(timespec=\"seconds\") + \"Z\"\n        with open(self.path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(roster, f, ensure_ascii=False, indent=2)\n\ndef load_roster_safe(store: RosterStore) -> Dict[str, Any]:\n    roster = store.load()\n    # normalizza campi player\n    cleaned: List[Dict[str, Any]] = []\n    for p in roster.get(\"players\", []):\n        if not p.get(\"player\") or not p.get(\"team\") or not p.get(\"role\"):\n            continue\n        # normalizza tipi\n        if isinstance(p.get(\"age\"), str):\n            try:\n                p[\"age\"] = int(p[\"age\"])\n            except Exception:\n                p[\"age\"] = None\n        # fm/price\n        for k in (\"fantamedia\", \"price\", \"starter_probability\"):\n            if isinstance(p.get(k), str):\n                try:\n                    p[k] = float(p[k])\n                except Exception:\n                    pass\n        cleaned.append(p)\n    roster[\"players\"] = cleaned\n    return roster\n\ndef canonicalize_player_names(players: List[Dict[str, Any]], requested: List[str], cutoff: float = 0.82) -> List[Dict[str, Any]]:\n    \"\"\"\n    Ritorna i record corrispondenti alle richieste, con fuzzy matching ma\n    solo su nomi presenti nel roster.\n    \"\"\"\n    names = {p[\"player\"]: p for p in players}\n    name_list = list(names.keys())\n    output: List[Dict[str, Any]] = []\n    for req in requested:\n        matches = get_close_matches(req, name_list, n=1, cutoff=cutoff)\n        if matches:\n            output.append(names[matches[0]])\n    return output\n\ndef filter_players_by(players: List[Dict[str, Any]],\n                      min_age: Optional[int] = None,\n                      max_age: Optional[int] = None,\n                      role: Optional[str] = None) -> List[Dict[str, Any]]:\n    out = []\n    for p in players:\n        if role and p.get(\"role\") != role:\n            continue\n        age = p.get(\"age\")\n        if min_age is not None and (age is None or age < min_age):\n            continue\n        if max_age is not None and (age is None or age > max_age):\n            continue\n        out.append(p)\n    return out\n"},{"path":"etl_build_roster.py","size":3098,"sha1":"ba064371bbb2f3a0d5cbe7b596b05182a1730f18","mtime":1755359402,"is_binary":false,"encoding":"utf-8","content":"# etl_build_roster.py\n# -*- coding: utf-8 -*-\nimport os\nimport json\nimport logging\nfrom typing import Any, Dict, List\nfrom knowledge_manager import KnowledgeManager\n\nLOG = logging.getLogger(\"etl_build_roster\")\nlogging.basicConfig(\n    level=os.environ.get(\"LOG_LEVEL\", \"INFO\"),\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\n\nOUT_PATH = os.getenv(\"ROSTER_JSON_PATH\", \"./season_roster.json\")\n\ndef normalize_player(m: Dict[str, Any]) -> Dict[str, Any]:\n    def _num(x, default=None):\n        try:\n            if x is None or x == \"\":\n                return default\n            return float(x)\n        except Exception:\n            return default\n    def _int(x, default=0):\n        try:\n            return int(x)\n        except Exception:\n            return default\n\n    return {\n        \"name\": (m.get(\"name\") or m.get(\"player\") or \"\").strip(),\n        \"role\": (m.get(\"role\") or m.get(\"position\") or \"\").strip().upper(),\n        \"team\": (m.get(\"team\") or m.get(\"club\") or \"\").strip(),\n        \"birth_year\": m.get(\"birth_year\") or m.get(\"birthyear\"),\n        \"price\": _num(m.get(\"price\") or m.get(\"cost\"), default=None),\n        \"fantamedia\": _num(m.get(\"fantamedia\") or m.get(\"avg\"), default=None),\n        \"appearances\": _int(m.get(\"appearances\") or m.get(\"apps\") or 0, 0),\n    }\n\ndef fetch_players_from_kb(km: KnowledgeManager, seasons: List[str], limit: int = 5000) -> List[Dict[str, Any]]:\n    out: List[Dict[str, Any]] = []\n    for season in seasons:\n        where = {\"$and\": [\n            {\"type\": {\"$in\": [\"player_info\", \"current_player\"]}},\n            {\"season\": {\"$eq\": season}}\n        ]}\n        res = km.get_by_filter(where=where, limit=limit, include=[\"metadatas\"])\n        metas = res.get(\"metadatas\") or []\n        for m in metas:\n            if isinstance(m, dict):\n                out.append(normalize_player(m))\n    return out\n\ndef main():\n    LOG.info(\"[ETL] Costruzione roster…\")\n    km = KnowledgeManager()\n    seasons = [\"2025-26\", \"2024-25\"]\n    players = fetch_players_from_kb(km, seasons=seasons, limit=50000)\n\n    # dedup per name-team-role\n    seen = set()\n    clean = []\n    for p in players:\n        key = (p[\"name\"], p[\"team\"], p[\"role\"])\n        if key in seen:\n            continue\n        seen.add(key)\n        clean.append(p)\n\n    # Don't overwrite if we have 0 players (likely indicates data issue)\n    if len(clean) == 0:\n        LOG.warning(\"[ETL] Non sovrascrivo %s - 0 giocatori trovati (possibile problema dati)\", OUT_PATH)\n        # Check if file exists and has content\n        try:\n            with open(OUT_PATH, \"r\", encoding=\"utf-8\") as f:\n                existing = json.load(f)\n            if isinstance(existing, list) and len(existing) > 0:\n                LOG.info(\"[ETL] Mantengo roster esistente con %d giocatori\", len(existing))\n                return\n        except Exception:\n            pass\n    \n    with open(OUT_PATH, \"w\", encoding=\"utf-8\") as f:\n        json.dump(clean, f, ensure_ascii=False, indent=2)\n    LOG.info(\"[ETL] Salvato %s con %d giocatori\", OUT_PATH, len(clean))\n\nif __name__ == \"__main__\":\n    main()\n"},{"path":"etl_enrich_age_wikipedia.py","size":7850,"sha1":"bb194d03c861ee52e8c2b568f83231475adc3eee","mtime":1755077717,"is_binary":false,"encoding":"utf-8","content":"# etl_enrich_age_wikipedia.py\n# -*- coding: utf-8 -*-\nimport os, re, json, time, argparse, logging\nfrom typing import Optional, Tuple, Dict, Any, List\n\nimport requests\n\nLOG = logging.getLogger(\"etl_enrich_age_wikipedia\")\nlogging.basicConfig(level=os.environ.get(\"LOG_LEVEL\", \"INFO\"),\n                    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n\nWIKI_SEARCH_URL = \"https://{lang}.wikipedia.org/w/api.php\"\nHEADERS = {\n    \"User-Agent\": \"FantacalcioAssistant/1.0 (+github.com/your-org)\"\n}\n\nIT_MONTHS = (\"gennaio\",\"febbraio\",\"marzo\",\"aprile\",\"maggio\",\"giugno\",\n             \"luglio\",\"agosto\",\"settembre\",\"ottobre\",\"novembre\",\"dicembre\")\n\nRE_PATTERNS = [\n    re.compile(r\"nato(?:\\s+a\\s+[A-Za-zÀ-ÿ\\s]+)?\\s*(?:il\\s*)?\\d{1,2}\\s+(%s)\\s+(19|20)\\d{2}\" % \"|\".join(IT_MONTHS), re.I),\n    re.compile(r\"nato\\s+nel\\s+(19|20)\\d{2}\", re.I),\n    re.compile(r\"classe\\s+(?:'|’)?0?(\\d{2}|\\d{4})\", re.I),\n    re.compile(r\"born\\s+(?:on\\s+)?[A-Za-z]+\\s+\\d{1,2},\\s+(19|20)\\d{2}\", re.I),\n    re.compile(r\"born\\s+\\d{1,2}\\s+[A-Za-z]+\\s+(19|20)\\d{2}\", re.I),\n    re.compile(r\"\\((?:born\\s+)?\\d{1,2}\\s+[A-Za-z]+\\s+(19|20)\\d{2}\\)\", re.I),\n    re.compile(r\"\\(\\d{1,2}\\s+(%s)\\s+(19|20)\\d{2}\\)\" % \"|\".join(IT_MONTHS), re.I),\n    re.compile(r\"\\b(19|20)\\d{2}\\b\")  # fallback, filtrato dopo\n]\n\ndef safe_int(x: Any) -> Optional[int]:\n    try: return int(x)\n    except: return None\n\ndef two_to_year(s: str) -> Optional[int]:\n    s = s.strip(\"’'\")\n    y = safe_int(s)\n    if y is None: return None\n    if y < 100: y += 2000\n    return y\n\ndef extract_year(text: str) -> Optional[int]:\n    \"\"\"Heuristica: privilegia pattern espliciti, poi fallback generico.\"\"\"\n    if not text: return None\n    t = text.replace(\"–\",\"-\")\n    # rimuovi pattern stagione “2025-26” che confondono\n    t = re.sub(r\"\\b(20\\d{2})\\s*[-/]\\s*\\d{2}\\b\", r\"\", t)\n    # prova pattern in ordine\n    for rx in RE_PATTERNS[:-1]:\n        m = rx.search(t)\n        if not m: continue\n        groups = [g for g in m.groups() if g]\n        # ultimo gruppo è spesso l'anno\n        if not groups: continue\n        last = groups[-1]\n        if isinstance(last, tuple): last = last[-1]\n        year = None\n        # caso “classe ’03”\n        if rx.pattern.startswith(\"classe\"):\n            year = two_to_year(last)\n        else:\n            year = safe_int(last) or two_to_year(last)\n        if year and 1980 <= year <= 2025:\n            return year\n\n    # fallback: primo anno plausibile vicino a “nato/born”\n    m = RE_PATTERNS[-1].finditer(t)\n    near_hits = []\n    for mm in m:\n        y = safe_int(mm.group(0))\n        if not y or not (1980 <= y <= 2025): continue\n        # controlla contesto\n        start = max(0, mm.start()-80)\n        ctx = t[start:mm.end()+10].lower()\n        if (\"nato\" in ctx) or (\"born\" in ctx) or (\"classe\" in ctx):\n            near_hits.append(y)\n    if near_hits:\n        return near_hits[0]\n    return None\n\ndef wiki_search(name: str, team: str, lang: str=\"it\", session: Optional[requests.Session]=None) -> Optional[int]:\n    \"\"\"Cerca pagina e prova a estrarre anno di nascita.\"\"\"\n    S = session or requests.Session()\n    q = f\"{name} calciatore {team}\".strip()\n    params = {\n        \"action\":\"query\",\"list\":\"search\",\"srsearch\": q, \"srlimit\":5,\n        \"format\":\"json\",\"origin\":\"*\"\n    }\n    try:\n        r = S.get(WIKI_SEARCH_URL.format(lang=lang), params=params, headers=HEADERS, timeout=15)\n        if r.status_code == 429:\n            time.sleep(1.5)\n            r = S.get(WIKI_SEARCH_URL.format(lang=lang), params=params, headers=HEADERS, timeout=15)\n        r.raise_for_status()\n        data = r.json()\n    except Exception as e:\n        LOG.warning(\"[WIKI] search fail %s: %s\", lang, e); return None\n\n    hits = data.get(\"query\",{}).get(\"search\",[]) or []\n    if not hits:\n        # prova senza team\n        params[\"srsearch\"] = f\"{name} calciatore\".strip()\n        try:\n            r = S.get(WIKI_SEARCH_URL.format(lang=lang), params=params, headers=HEADERS, timeout=15)\n            r.raise_for_status()\n            data = r.json()\n            hits = data.get(\"query\",{}).get(\"search\",[]) or []\n        except: hits = []\n\n    if not hits:\n        return None\n\n    # prendi la pagina più promettente e scarica estratto\n    pageid = hits[0].get(\"pageid\")\n    if not pageid: return None\n\n    params2 = {\n        \"action\":\"query\",\"prop\":\"extracts\",\"explaintext\":1,\"pageids\":pageid,\"format\":\"json\",\"origin\":\"*\"\n    }\n    try:\n        r2 = S.get(WIKI_SEARCH_URL.format(lang=lang), params=params2, headers=HEADERS, timeout=15)\n        if r2.status_code == 429:\n            time.sleep(1.5)\n            r2 = S.get(WIKI_SEARCH_URL.format(lang=lang), params=params2, headers=HEADERS, timeout=15)\n        r2.raise_for_status()\n        d2 = r2.json()\n        pages = d2.get(\"query\",{}).get(\"pages\",{}) or {}\n        page = pages.get(str(pageid)) or {}\n        text = page.get(\"extract\",\"\")\n        return extract_year(text)\n    except Exception as e:\n        LOG.warning(\"[WIKI] extract fail %s: %s\", lang, e)\n        return None\n\ndef resolve_birth_year(name: str, team: str, session: requests.Session) -> Optional[int]:\n    # IT first, then EN\n    y = wiki_search(name, team, \"it\", session=session)\n    if y: return y\n    return wiki_search(name, team, \"en\", session=session)\n\ndef load_age_cache(path: str) -> Dict[str, Any]:\n    if os.path.exists(path):\n        try:\n            return json.load(open(path,\"r\",encoding=\"utf-8\"))\n        except Exception:\n            return {}\n    return {}\n\ndef save_age_cache(path: str, data: Dict[str, Any]) -> None:\n    os.makedirs(os.path.dirname(path) or \".\", exist_ok=True)\n    json.dump(data, open(path,\"w\",encoding=\"utf-8\"), ensure_ascii=False, indent=2)\n\ndef key_for(name: str, team: str) -> str:\n    return f\"{name.strip().lower()}|{team.strip().lower()}\"\n\ndef main():\n    ap = argparse.ArgumentParser()\n    ap.add_argument(\"--input\", default=\"./season_roster.json\", help=\"roster di partenza\")\n    ap.add_argument(\"--out\", default=\"./cache/age_index.json\", help=\"output cache età\")\n    ap.add_argument(\"--limit\", type=int, default=400, help=\"limite giocatori da processare\")\n    ap.add_argument(\"--sleep\", type=float, default=0.6, help=\"sleep tra richieste\")\n    ap.add_argument(\"--force\", action=\"store_true\", help=\"ricalcola anche se già in cache\")\n    args = ap.parse_args()\n\n    try:\n        roster = json.load(open(args.input,\"r\",encoding=\"utf-8\"))\n        if not isinstance(roster, list):\n            LOG.error(\"Roster non è una lista\"); return\n    except Exception as e:\n        LOG.error(\"Errore apertura roster: %s\", e); return\n\n    cache = load_age_cache(args.out)\n    S = requests.Session()\n\n    processed = 0\n    hits = 0\n    for item in roster:\n        if processed >= args.limit: break\n        if not isinstance(item, dict): continue\n        name = (item.get(\"name\") or item.get(\"player\") or \"\").strip()\n        team = (item.get(\"team\") or item.get(\"club\") or \"\").strip()\n        if not name: continue\n\n        # se già ho birth_year nel roster, salvalo in cache e salta\n        by = item.get(\"birth_year\") or item.get(\"year_of_birth\")\n        if by:\n            k = key_for(name, team)\n            cache.setdefault(k, {})[\"birth_year\"] = int(by)\n            continue\n\n        k = key_for(name, team)\n        if not args.force and k in cache and cache[k].get(\"birth_year\"):\n            continue\n\n        processed += 1\n        y = resolve_birth_year(name, team, session=S)\n        if y:\n            hits += 1\n            cache.setdefault(k, {})[\"birth_year\"] = int(y)\n            LOG.info(\"[AGE] %s (%s) -> %s\", name, team, y)\n        else:\n            LOG.info(\"[AGE] %s (%s) -> nd\", name, team)\n\n        save_age_cache(args.out, cache)\n        time.sleep(args.sleep)\n\n    LOG.info(\"Fatto. Processati=%d, trovati=%d. Cache: %s\", processed, hits, args.out)\n\nif __name__ == \"__main__\":\n    main()\n"},{"path":"etl_ingest_json.py","size":4054,"sha1":"9d85935fbf520e07450cf578c8ae37eed63c5fbb","mtime":1754982810,"is_binary":false,"encoding":"utf-8","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport os\nimport glob\nimport json\nimport uuid\nimport logging\nfrom typing import List, Dict, Any, Optional\n\nimport chromadb\nfrom chromadb.utils import embedding_functions\n\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s - ingest - %(levelname)s - %(message)s\")\nlog = logging.getLogger(\"ingest\")\n\nDB_PATH = os.getenv(\"CHROMA_DB_PATH\", \"./chroma\")\nCOLL = os.getenv(\"CHROMA_COLLECTION\", \"fantacalcio_knowledge\")\nINPUT_DIR = os.getenv(\"KB_INPUT_DIR\", \"knowledge_base\")\nST_MODEL = os.getenv(\"ST_MODEL\", \"all-MiniLM-L6-v2\")\n\ndef load_jsonl(path: str) -> List[Dict[str, Any]]:\n    rows: List[Dict[str, Any]] = []\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        for line in f:\n            line = line.strip()\n            if not line:\n                continue\n            try:\n                rows.append(json.loads(line))\n            except Exception as e:\n                log.warning(\"Riga non valida in %s: %s\", path, e)\n    return rows\n\ndef to_doc_and_meta(row: Dict[str, Any]) -> (str, Dict[str, Any]):\n    \"\"\"\n    Costruisce il testo indicizzabile e i metadati da una riga JSON.\n    Regole base:\n      - 'text' o 'content' come corpo principale\n      - metadati normalizzati per le query (type, league, season, player, team, role, source_date...)\n    \"\"\"\n    text = row.get(\"text\") or row.get(\"content\") or \"\"\n    if not text:\n        # fallback ridotto da metadati, per non saltare l'item\n        text = \" \".join(str(v) for k, v in row.items() if isinstance(v, (str, int, float)) and k not in (\"id\",))\n\n    meta = {\n        \"type\": row.get(\"type\"),\n        \"league\": row.get(\"league\") or \"Serie A\",\n        \"season\": row.get(\"season\") or os.getenv(\"SEASON\", \"2024-25\"),\n        \"player\": row.get(\"player\"),\n        \"team\": row.get(\"team\"),\n        \"role\": row.get(\"role\"),\n        \"fantamedia\": row.get(\"fantamedia\"),\n        \"price\": row.get(\"price\"),\n        \"age\": row.get(\"age\"),\n        \"is_u21\": row.get(\"is_u21\"),\n        \"source\": row.get(\"source\"),\n        \"source_date\": row.get(\"source_date\"),\n    }\n    # pulizia None -> rimuovi chiavi vuote\n    meta = {k: v for k, v in meta.items() if v is not None}\n    return text, meta\n\ndef main():\n    log.info(\"Ingest da: %s\", INPUT_DIR)\n    files = sorted(glob.glob(os.path.join(INPUT_DIR, \"*.jsonl\")))\n    if not files:\n        log.warning(\"Nessun .jsonl trovato in %s\", INPUT_DIR)\n        return\n\n    client = chromadb.PersistentClient(path=DB_PATH)\n    # Preferisco usare embeddings lato Chroma con SentenceTransformer\n    emb_fn = embedding_functions.SentenceTransformerEmbeddingFunction(model_name=ST_MODEL)\n\n    coll = client.get_or_create_collection(\n        name=COLL,\n        metadata={\"hnsw:space\": \"cosine\"},\n        embedding_function=emb_fn,\n    )\n\n    total_added = 0\n    for fp in files:\n        rows = load_jsonl(fp)\n        if not rows:\n            continue\n\n        docs: List[str] = []\n        metas: List[Dict[str, Any]] = []\n        ids: List[str] = []\n        for r in rows:\n            doc, meta = to_doc_and_meta(r)\n            if not doc.strip():\n                continue\n            docs.append(doc)\n            metas.append(meta)\n            rid = r.get(\"id\") or str(uuid.uuid4())\n            ids.append(rid)\n\n        if docs:\n            log.info(\"Indicizzo %s righe da %s…\", len(docs), os.path.basename(fp))\n            # per sicurezza, spezzetta in batch\n            B = 256\n            for i in range(0, len(docs), B):\n                batch_docs = docs[i:i+B]\n                batch_metas = metas[i:i+B]\n                batch_ids = ids[i:i+B]\n                coll.add(documents=batch_docs, metadatas=batch_metas, ids=batch_ids)\n                total_added += len(batch_docs)\n\n    log.info(\"Ingest completato. Aggiunti documenti: %s\", total_added)\n    # Stampa conteggio finale\n    try:\n        cnt = coll.count()\n        log.info(\"Collection '%s' conteggio finale: %s\", COLL, cnt)\n    except Exception as e:\n        log.warning(\"Impossibile leggere count: %s\", e)\n\nif __name__ == \"__main__\":\n    main()\n"},{"path":"etl_league_batch.py","size":13131,"sha1":"67905bbbbf7541d00c5d7badf88b4e4e9ed73ef8","mtime":1754834001,"is_binary":false,"encoding":"utf-8","content":"import os\nimport sys\nimport json\nimport time\nimport argparse\nimport sqlite3\nfrom typing import List, Dict, Optional\n\nimport requests\n\n# -------------------- Config di base --------------------\nUSER_AGENT = os.environ.get(\"USER_AGENT\", \"FantacalcioETL/1.0 (replit)\")\nSPARQL_ENDPOINT = \"https://query.wikidata.org/sparql\"\nWIKIDATA_SEARCH = \"https://www.wikidata.org/w/api.php\"\nDB_PATH = os.environ.get(\"ETL_DB\", \"./fantacalcio.db\")\n\n# KnowledgeManager (opzionale per Chroma)\ntry:\n    from knowledge_manager import KnowledgeManager\nexcept Exception:\n    KnowledgeManager = None  # permette --no-chroma\n\n# -------------------- Sanitizzazione metadati (per Chroma) --------------------\ndef _sanitize_meta(meta: dict) -> dict:\n    \"\"\"Rimuove tipi non primitivi e converte None -> '' per compatibilita' Chroma.\"\"\"\n    out = {}\n    for k, v in (meta or {}).items():\n        if v is None:\n            out[k] = \"\"\n        elif isinstance(v, (str, int, float, bool)):\n            out[k] = v\n        else:\n            out[k] = str(v)\n    return out\n\n# -------------------- Helper HTTP/SPARQL/Wikidata --------------------\ndef wbsearchentities(name: str, lang: str = \"it\", type_hint: Optional[str] = None) -> Optional[Dict]:\n    \"\"\"Cerca entita' su Wikidata. Ritorna {'id','label'} o None.\"\"\"\n    params = {\n        \"action\": \"wbsearchentities\",\n        \"search\": name,\n        \"language\": lang,\n        \"uselang\": lang,\n        \"format\": \"json\",\n        \"limit\": 10,\n        \"type\": type_hint or \"item\",\n    }\n    r = requests.get(WIKIDATA_SEARCH, params=params, headers={\"User-Agent\": USER_AGENT}, timeout=12)\n    r.raise_for_status()\n    data = r.json()\n    res = data.get(\"search\", [])\n    if not res:\n        return None\n\n    def score(item):\n        desc = (item.get(\"description\") or \"\").lower()\n        s = 0\n        if \"football\" in desc or \"calcio\" in desc or \"club\" in desc or \"societa\" in desc or \"società\" in desc:\n            s += 10\n        if \"club\" in desc and \"football\" in desc:\n            s += 5\n        return s\n\n    res.sort(key=score, reverse=True)\n    top = res[0]\n    return {\"id\": top.get(\"id\"), \"label\": top.get(\"label\")}\n\ndef sparql_select(query: str) -> List[Dict]:\n    headers = {\n        \"User-Agent\": USER_AGENT,\n        \"Accept\": \"application/sparql-results+json\",\n    }\n    r = requests.get(SPARQL_ENDPOINT, params={\"query\": query, \"format\": \"json\"}, headers=headers, timeout=30)\n    r.raise_for_status()\n    data = r.json()\n    return data.get(\"results\", {}).get(\"bindings\", [])\n\ndef fetch_current_roster(club_qid: str, lang: str = \"it\") -> List[Dict]:\n    \"\"\"\n    Rosa attuale: giocatori con P54 = club e SENZA qualifier P582 (end time).\n    Ritorna dict con player_qid, player_label, wiki_page (it se disponibile), position.\n    \"\"\"\n    query = f\"\"\"\n    SELECT ?player ?playerLabel ?wpPage ?positionLabel WHERE {{\n      BIND(wd:{club_qid} AS ?club)\n      ?player p:P54 ?st .\n      ?st ps:P54 ?club .\n      FILTER NOT EXISTS {{ ?st pq:P582 ?end . }}\n\n      OPTIONAL {{ ?player wdt:P413 ?position . }}\n\n      OPTIONAL {{\n        ?wpPage schema:about ?player ;\n                schema:isPartOf <https://{lang}.wikipedia.org/> .\n      }}\n\n      SERVICE wikibase:label {{\n        bd:serviceParam wikibase:language \"{lang},en\" .\n        ?player rdfs:label ?playerLabel .\n      }}\n    }}\n    \"\"\"\n    rows = sparql_select(query)\n    out = []\n    for b in rows:\n        def val(x): return b.get(x, {}).get(\"value\")\n        out.append({\n            \"player_qid\": (val(\"player\").split(\"/\")[-1]) if val(\"player\") else None,\n            \"player_label\": val(\"playerLabel\"),\n            \"wiki_page\": val(\"wpPage\"),\n            \"position\": val(\"positionLabel\"),\n        })\n    # dedup per player_qid/label\n    seen, uniq = set(), []\n    for r in out:\n        key = r.get(\"player_qid\") or r.get(\"player_label\")\n        if key and key not in seen:\n            seen.add(key)\n            uniq.append(r)\n    return uniq\n\n# -------------------- SQLite schema & upsert --------------------\nSCHEMA_SQL = \"\"\"\nCREATE TABLE IF NOT EXISTS clubs (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL,\n  wikidata_id TEXT,\n  country TEXT\n);\n\nCREATE TABLE IF NOT EXISTS players (\n  id TEXT PRIMARY KEY,\n  full_name TEXT NOT NULL,\n  wikidata_id TEXT,\n  position TEXT\n);\n\nCREATE TABLE IF NOT EXISTS memberships (\n  player_id TEXT NOT NULL,\n  club_id TEXT NOT NULL,\n  start_date TEXT,\n  end_date TEXT,\n  source_url TEXT,\n  source_date TEXT,\n  PRIMARY KEY (player_id, club_id, start_date),\n  FOREIGN KEY (player_id) REFERENCES players(id),\n  FOREIGN KEY (club_id) REFERENCES clubs(id)\n);\n\"\"\"\n\ndef ensure_db(conn: sqlite3.Connection):\n    conn.executescript(SCHEMA_SQL)\n    conn.commit()\n\ndef upsert_club(conn: sqlite3.Connection, club_id: str, name: str, wikidata_id: Optional[str]):\n    conn.execute(\n        \"INSERT INTO clubs(id, name, wikidata_id) VALUES(?,?,?) \"\n        \"ON CONFLICT(id) DO UPDATE SET name=excluded.name, wikidata_id=excluded.wikidata_id\",\n        (club_id, name, wikidata_id)\n    )\n    conn.commit()\n\ndef upsert_player(conn: sqlite3.Connection, pid: str, full_name: str, wikidata_id: Optional[str], position: Optional[str]):\n    conn.execute(\n        \"INSERT INTO players(id, full_name, wikidata_id, position) VALUES(?,?,?,?) \"\n        \"ON CONFLICT(id) DO UPDATE SET full_name=excluded.full_name, wikidata_id=excluded.wikidata_id, position=excluded.position\",\n        (pid, full_name, wikidata_id, position)\n    )\n\ndef upsert_membership(conn: sqlite3.Connection, pid: str, cid: str, start_date: Optional[str], source_url: Optional[str], source_date: Optional[str]):\n    conn.execute(\n        \"INSERT OR REPLACE INTO memberships(player_id, club_id, start_date, end_date, source_url, source_date) VALUES(?,?,?,?,?,?)\",\n        (pid, cid, start_date or \"0000-00-00\", None, source_url, source_date)\n    )\n\n# -------------------- Helpers vari --------------------\ndef normalize_id(label: str) -> str:\n    return (\n        label.lower()\n        .replace(\" \", \"_\")\n        .replace(\"'\", \"\")\n        .replace(\".\", \"\")\n        .replace(\"-\", \"_\")\n        .replace(\"/\", \"_\")\n    )\n\n# -------------------- ETL per SQUADRA (inline) --------------------\ndef ingest_team(team_name: str, season: str, valid_to: str, lang: str = \"it\", no_chroma: bool = False) -> Dict:\n    # 1) risolvi club su Wikidata\n    club = wbsearchentities(team_name, lang=lang, type_hint=\"item\")\n    if not club:\n        raise RuntimeError(f\"Club non trovato su Wikidata: {team_name}\")\n\n    club_qid = club[\"id\"]\n    club_label = club[\"label\"] or team_name\n    club_row_id = f\"club_{normalize_id(club_label)}\"\n\n    # 2) roster attuale\n    roster = fetch_current_roster(club_qid, lang=lang)\n\n    # 3) scrivi su SQLite\n    conn = sqlite3.connect(DB_PATH)\n    ensure_db(conn)\n    upsert_club(conn, club_row_id, club_label, club_qid)\n\n    now = time.strftime(\"%Y-%m-%d\")\n    for r in roster:\n        name = r.get(\"player_label\") or \"Giocatore\"\n        pid = f\"pl_{normalize_id(name)}\"\n        upsert_player(conn, pid, name, r.get(\"player_qid\"), r.get(\"position\"))\n        upsert_membership(conn, pid, club_row_id, start_date=now, source_url=r.get(\"wiki_page\"), source_date=now)\n    conn.commit()\n\n    # 4) indicizza in Chroma (facoltativo)\n    added_docs = 0\n    if not no_chroma and KnowledgeManager is not None:\n        km = KnowledgeManager()\n        items = []\n        for r in roster:\n            name = r.get(\"player_label\") or \"Giocatore\"\n            pid = f\"pl_{normalize_id(name)}\"\n            text = f\"{name} e' un calciatore del {club_label}.\"\n            md = {\n                \"type\": \"player_info\",\n                \"player\": name or \"\",\n                \"player_id\": pid,\n                \"team\": club_label or \"\",\n                \"position\": r.get(\"position\") or \"\",\n                \"title\": f\"Profilo {name or ''}\",\n                \"source\": r.get(\"wiki_page\") or (f\"https://www.wikidata.org/wiki/{r.get('player_qid')}\" if r.get(\"player_qid\") else \"internal://wikidata\"),\n                \"date\": now or \"\",\n                \"valid_to\": valid_to or \"2099-01-01\",\n                \"season\": season or \"\",\n            }\n            md = _sanitize_meta(md)\n            items.append({\"id\": pid, \"text\": text, \"metadata\": md})\n\n        stats = km.add_many(items)\n        added_docs = stats.get(\"added\", 0)\n\n    return {\n        \"club_qid\": club_qid,\n        \"club\": club_label,\n        \"players\": len(roster),\n        \"db_path\": DB_PATH,\n        \"chroma_indexed\": added_docs,\n    }\n\n# -------------------- Resolve LEAGUE & clubs --------------------\ndef resolve_league(league_name: str, lang: str = \"it\") -> Optional[Dict]:\n    \"\"\"Trova l'item Wikidata della lega (es. Serie A, Premier League).\"\"\"\n    return wbsearchentities(league_name, lang=lang, type_hint=\"item\")\n\ndef fetch_league_clubs(league_qid: str, lang: str = \"it\", country_hint: Optional[str] = None, limit: Optional[int] = None) -> List[Dict]:\n    \"\"\"\n    Trova i club che militano nella lega: team con proprieta' wdt:P118 = wd:<league_qid>.\n    Se country_hint e' valorizzato, prova a filtrare per P17 (paese).\n    \"\"\"\n    country_filter = \"\"\n    if country_hint:\n        country_filter = f\"\"\"\n        OPTIONAL {{ ?club wdt:P17 ?country . }}\n        ?country rdfs:label ?countryLabel FILTER(LANG(?countryLabel)='{lang}' || LANG(?countryLabel)='en').\n        FILTER(CONTAINS(LCASE(?countryLabel), LCASE(\"{country_hint}\")))\n        \"\"\"\n\n    limit_clause = f\"LIMIT {int(limit)}\" if limit and int(limit) > 0 else \"\"\n\n    query = f\"\"\"\n    SELECT DISTINCT ?club ?clubLabel WHERE {{\n      ?club wdt:P118 wd:{league_qid} .\n      SERVICE wikibase:label {{ bd:serviceParam wikibase:language \"{lang},en\". }}\n      {country_filter}\n    }}\n    {limit_clause}\n    \"\"\"\n    rows = sparql_select(query)\n    out = []\n    for b in rows:\n        uri = b.get(\"club\", {}).get(\"value\")\n        label = b.get(\"clubLabel\", {}).get(\"value\")\n        if not uri or not label:\n            continue\n        qid = uri.split(\"/\")[-1]\n        out.append({\"id\": qid, \"label\": label})\n    return out\n\n# -------------------- MAIN --------------------\ndef main():\n    ap = argparse.ArgumentParser(description=\"ETL batch per LEGA: risolve la lega su Wikidata e ingesta tutti i club della lega (SQLite + Chroma).\")\n    ap.add_argument(\"--league\", required=True, help='Nome lega (es. \"Serie A\", \"Premier League\")')\n    ap.add_argument(\"--season\", default=os.environ.get(\"SEASON_DEFAULT\", \"2025-26\"), help='Stagione nei metadati (es. \"2025-26\")')\n    ap.add_argument(\"--valid-to\", default=\"2099-01-01\", help=\"Data validita' dei documenti (YYYY-MM-DD)\")\n    ap.add_argument(\"--lang\", default=\"it\", help=\"Lingua preferita (default: it)\")\n    ap.add_argument(\"--country\", default=None, help='Hint paese per filtrare i club (es. \"Italy\", \"England\")')\n    ap.add_argument(\"--limit\", type=int, default=None, help=\"Limita il numero di club da processare (per test)\")\n    ap.add_argument(\"--no-chroma\", action=\"store_true\", help=\"Non indicizzare in Chroma (solo DB locale)\")\n    ap.add_argument(\"--sleep\", type=float, default=1.0, help=\"Sleep tra club (secondi) per essere gentili con gli endpoint)\")\n    args = ap.parse_args()\n\n    # 1) Risolvi la LEGA\n    league = resolve_league(args.league, lang=args.lang)\n    if not league:\n        print(json.dumps({\"ok\": False, \"error\": f\"Lega non trovata: {args.league}\"}))\n        sys.exit(1)\n\n    league_qid = league[\"id\"]\n    league_label = league[\"label\"]\n    print(json.dumps({\"ok\": True, \"league_qid\": league_qid, \"league\": league_label}, ensure_ascii=False))\n\n    # 2) Trova i club che militano nella lega\n    try:\n        clubs = fetch_league_clubs(league_qid, lang=args.lang, country_hint=args.country, limit=args.limit)\n    except Exception as e:\n        print(json.dumps({\"ok\": False, \"error\": f\"Errore SPARQL club: {e}\"}))\n        sys.exit(2)\n\n    if not clubs:\n        print(json.dumps({\"ok\": False, \"error\": f\"Nessun club trovato per la lega {league_label}\"}))\n        sys.exit(3)\n\n    print(f\"[ETL-LEAGUE] Club trovati: {len(clubs)}\")\n\n    results = []\n    for i, c in enumerate(clubs, 1):\n        name = c[\"label\"]\n        print(f\"[{i}/{len(clubs)}] Ingest team: {name} ...\")\n        try:\n            res = ingest_team(\n                team_name=name,\n                season=args.season,\n                valid_to=args.valid_to,\n                lang=args.lang,\n                no_chroma=args.no_chroma,\n            )\n            results.append({\"team\": name, **res})\n        except Exception as e:\n            print(f\"[ETL-LEAGUE] Errore ingest '{name}': {e}\", file=sys.stderr)\n        time.sleep(max(0.0, args.sleep))\n\n    # 3) Report finale\n    total_players = sum(r.get(\"players\", 0) for r in results)\n    total_indexed = sum(r.get(\"chroma_indexed\", 0) for r in results)\n    out = {\n        \"ok\": True,\n        \"league\": league_label,\n        \"teams_processed\": len(results),\n        \"players_total\": total_players,\n        \"chroma_indexed_total\": total_indexed,\n        \"season\": args.season,\n        \"valid_to\": args.valid_to,\n        \"details\": results[-5:],  # ultimi 5 per quick check\n    }\n    print(json.dumps(out, ensure_ascii=False, indent=2))\n\n\nif __name__ == \"__main__\":\n    main()"},{"path":"etl_runner.py","size":3935,"sha1":"db3fa530bc37d50f360ef70bea3d7c9252f39d0c","mtime":1755034370,"is_binary":false,"encoding":"utf-8","content":"# etl_runner.py\n# -*- coding: utf-8 -*-\n\"\"\"\nRunner ETL in background per ricostruire il roster (season_roster.json).\nEspone refresh_roster_async() usato da web_interface.py.\n\n- Esegue per default: ETL_CMD=\"python etl_build_roster.py\"\n- Debounce/cooldown per evitare flood\n- Logga ogni riga dello stdout dell'ETL con prefisso [ETL]\n\"\"\"\n\nimport os\nimport shlex\nimport time\nimport logging\nimport threading\nimport subprocess\nfrom typing import Optional, Dict\n\nLOG = logging.getLogger(\"etl_runner\")\nlogging.basicConfig(\n    level=os.environ.get(\"LOG_LEVEL\", \"INFO\"),\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\n\n_ETL_LOCK = threading.Lock()\n_IS_RUNNING = False\n_LAST_START = 0.0\n\n\ndef _run_etl_once() -> None:\n    \"\"\"Esegue l'ETL una volta, catturando lo stdout e loggandolo riga per riga.\"\"\"\n    cmd = os.getenv(\"ETL_CMD\", \"python etl_build_roster.py\")\n    LOG.info(\"[ETL] Eseguo: %s\", cmd)\n    try:\n        proc = subprocess.Popen(\n            shlex.split(cmd),\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            bufsize=1,\n            text=True,\n        )\n    except Exception as e:\n        LOG.error(\"[ETL] Avvio processo fallito: %s\", e)\n        return\n\n    try:\n        assert proc.stdout is not None\n        for line in iter(proc.stdout.readline, \"\"):\n            LOG.info(\"[ETL] %s\", line.rstrip(\"\\n\"))\n        proc.wait()\n        LOG.info(\"[ETL] Exit code: %s\", proc.returncode)\n    except Exception as e:\n        LOG.error(\"[ETL] Errore in esecuzione: %s\", e)\n\n\ndef refresh_roster_async(cooldown_sec: int = 60) -> bool:\n    \"\"\"\n    Lancia l'ETL in un thread di background.\n    Ritorna True se lancia davvero, False se è già in esecuzione o in cooldown.\n    \"\"\"\n    global _IS_RUNNING, _LAST_START\n    now = time.time()\n    with _ETL_LOCK:\n        if _IS_RUNNING:\n            LOG.info(\"[ETL] Già in esecuzione, skip.\")\n            return False\n        if now - _LAST_START < cooldown_sec:\n            LOG.info(\"[ETL] In cooldown (%ds), skip.\", cooldown_sec)\n            return False\n\n        _IS_RUNNING = True\n\n        def _worker():\n            global _IS_RUNNING, _LAST_START\n            try:\n                _run_etl_once()\n            finally:\n                with _ETL_LOCK:\n                    _IS_RUNNING = False\n                    _LAST_START = time.time()\n                LOG.info(\"[ETL] Refresh roster completato\")\n\n        t = threading.Thread(target=_worker, daemon=True)\n        t.start()\n        LOG.info(\"[ETL] Job di refresh lanciato (thread id=%s)\", t.ident)\n        return True\n\n\ndef refresh_roster_sync() -> None:\n    \"\"\"Versione sincrona (bloccante) dell'ETL.\"\"\"\n    global _IS_RUNNING, _LAST_START\n    with _ETL_LOCK:\n        if _IS_RUNNING:\n            LOG.info(\"[ETL] Già in esecuzione; uscita senza lanciare doppione.\")\n            return\n        _IS_RUNNING = True\n    try:\n        _run_etl_once()\n    finally:\n        with _ETL_LOCK:\n            _IS_RUNNING = False\n            _LAST_START = time.time()\n        LOG.info(\"[ETL] Refresh roster completato (sync)\")\n\n\ndef is_running() -> bool:\n    with _ETL_LOCK:\n        return _IS_RUNNING\n\n\ndef status() -> Dict[str, Optional[float]]:\n    with _ETL_LOCK:\n        return {\"running\": _IS_RUNNING, \"last_start\": _LAST_START}\n\n\nif __name__ == \"__main__\":\n    import argparse\n    parser = argparse.ArgumentParser(description=\"ETL runner\")\n    parser.add_argument(\"--sync\", action=\"store_true\", help=\"Esegui in modo sincrono\")\n    parser.add_argument(\"--cooldown\", type=int, default=60, help=\"Cooldown in secondi\")\n    args = parser.parse_args()\n\n    if args.sync:\n        refresh_roster_sync()\n    else:\n        launched = refresh_roster_async(cooldown_sec=args.cooldown)\n        if launched:\n            # attende finché il thread non termina\n            while is_running():\n                time.sleep(0.5)\n        else:\n            LOG.info(\"[ETL] Non lanciato (in esecuzione o in cooldown)\")\n"},{"path":"etl_tm_serie_a_full.py","size":16785,"sha1":"9d118b07b1771c787db85898807c77f85df04dfc","mtime":1754993962,"is_binary":false,"encoding":"utf-8","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\netl_tm_serie_a_full.py — One-shot ETL Transfermarkt per tutta la Serie A\n\nEsempi:\n  # Run standard (arrivi+cessioni) su mapping built-in, stagione 2025-26, con merge roster e ingest KB\n  python etl_tm_serie_a_full.py --season 2025-26 --write-roster --ingest\n\n  # Solo arrivi, 2s di delay tra club, output in ./data/etl_2025_serie_a/\n  python etl_tm_serie_a_full.py --season 2025-26 --arrivals-only --delay 2 --out-dir ./data/etl_2025_serie_a --write-roster\n\n  # Override mapping da file JSON (team->Transfermarkt URL)\n  python etl_tm_serie_a_full.py --season 2025-26 --urls-json ./config/serie_a_transfermarkt_urls.json --write-roster\n\nFormato JSON override (esempio):\n{\n  \"Juventus\": \"https://www.transfermarkt.it/juventus-fc/transfers/verein/506\",\n  \"Inter\": \"https://www.transfermarkt.it/inter-mailand/transfers/verein/46\"\n}\n\"\"\"\n\nimport os\nimport sys\nimport csv\nimport json\nimport time\nimport uuid\nimport argparse\nimport logging\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, List, Any, Optional, Tuple\n\nimport requests\nfrom bs4 import BeautifulSoup\n\n# KnowledgeManager opzionale: usato solo se disponibile e si passa --ingest\ntry:\n    from knowledge_manager import KnowledgeManager\n    KM_AVAILABLE = True\nexcept Exception:\n    KM_AVAILABLE = False\n\nLOG = logging.getLogger(\"etl_tm_serie_a_full\")\nlogging.basicConfig(\n    level=os.environ.get(\"LOG_LEVEL\", \"INFO\"),\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\n\nDATA_DIR = Path(\"./data\")\nDATA_DIR.mkdir(parents=True, exist_ok=True)\n\n# -----------------------------------------------------------------------------\n# Built-in mapping (ragionevole per molte installazioni; puoi override via JSON/env)\n# NB: gli slug/ID Transfermarkt possono cambiare: se qualche URL 404a, override via file JSON.\n# -----------------------------------------------------------------------------\nDEFAULT_TM_URLS: Dict[str, str] = {\n    \"Atalanta\":  \"https://www.transfermarkt.it/atalanta-bergamo/transfers/verein/800\",\n    \"Bologna\":   \"https://www.transfermarkt.it/bologna-fc-1909/transfers/verein/1025\",\n    \"Cagliari\":  \"https://www.transfermarkt.it/cagliari-calcio/transfers/verein/1390\",\n    \"Como\":      \"https://www.transfermarkt.it/como-1907/transfers/verein/280\",\n    \"Empoli\":    \"https://www.transfermarkt.it/empoli-fc/transfers/verein/749\",\n    \"Fiorentina\":\"https://www.transfermarkt.it/acf-fiorentina/transfers/verein/430\",\n    \"Genoa\":     \"https://www.transfermarkt.it/genoa-cfc/transfers/verein/252\",\n    \"Inter\":     \"https://www.transfermarkt.it/inter-mailand/transfers/verein/46\",\n    \"Juventus\":  \"https://www.transfermarkt.it/juventus-fc/transfers/verein/506\",\n    \"Lazio\":     \"https://www.transfermarkt.it/ss-lazio/transfers/verein/398\",\n    \"Lecce\":     \"https://www.transfermarkt.it/us-lecce/transfers/verein/1020\",\n    \"Milan\":     \"https://www.transfermarkt.it/ac-mailand/transfers/verein/5\",\n    \"Monza\":     \"https://www.transfermarkt.it/ac-monza/transfers/verein/2919\",\n    \"Napoli\":    \"https://www.transfermarkt.it/ssc-neapel/transfers/verein/6195\",\n    \"Parma\":     \"https://www.transfermarkt.it/parma-calcio-1913/transfers/verein/130\",\n    \"Roma\":      \"https://www.transfermarkt.it/as-roma/transfers/verein/12\",\n    \"Torino\":    \"https://www.transfermarkt.it/torino-fc/transfers/verein/416\",\n    \"Udinese\":   \"https://www.transfermarkt.it/udinese-calcio/transfers/verein/410\",\n    \"Verona\":    \"https://www.transfermarkt.it/hellas-verona/transfers/verein/276\",\n    \"Venezia\":   \"https://www.transfermarkt.it/venezia-fc/transfers/verein/907\",\n}\n\n# -----------------------------------------------------------------------------\n# Helpers\n# -----------------------------------------------------------------------------\ndef now_iso_date() -> str:\n    return datetime.now().strftime(\"%Y-%m-%d\")\n\ndef safe_text(s: Optional[str]) -> str:\n    return \" \".join((s or \"\").split())\n\ndef jsonl_path(out_dir: Path, team: str, season: str) -> Path:\n    slug = team.lower().replace(\" \", \"_\")\n    return out_dir / f\"tm_transfers_{slug}_{season.replace('/','-').replace(' ','_')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.jsonl\"\n\ndef load_json(p: Path) -> Optional[Any]:\n    if not p.exists(): return None\n    try:\n        with p.open(\"r\", encoding=\"utf-8\") as f:\n            return json.load(f)\n    except Exception:\n        return None\n\ndef save_json(p: Path, obj: Any) -> None:\n    p.parent.mkdir(parents=True, exist_ok=True)\n    with p.open(\"w\", encoding=\"utf-8\") as f:\n        json.dump(obj, f, ensure_ascii=False, indent=2)\n\ndef append_jsonl(p: Path, items: List[Dict[str, Any]]) -> None:\n    p.parent.mkdir(parents=True, exist_ok=True)\n    with p.open(\"a\", encoding=\"utf-8\") as f:\n        for it in items:\n            f.write(json.dumps(it, ensure_ascii=False) + \"\\n\")\n\n# -----------------------------------------------------------------------------\n# Scrape Transfermarkt HTML: Arrivi/Cessioni\n# -----------------------------------------------------------------------------\nARRIVALS_KEYS = {\"arrivi\", \"acquisti\", \"zugänge\", \"arrivals\", \"incoming\"}\nDEPARTURES_KEYS = {\"cessioni\", \"abgänge\", \"departures\", \"outgoing\", \"uscite\"}\n\ndef infer_direction_from_context(table: BeautifulSoup) -> str:\n    \"\"\"\n    Prova a inferire 'in' o 'out' guardando heading/caption attorno alla table.items\n    \"\"\"\n    # caption\n    cap = table.find(\"caption\")\n    cap_txt = safe_text(cap.get_text(\" \", strip=True).lower()) if cap else \"\"\n    if any(k in cap_txt for k in ARRIVALS_KEYS):\n        return \"in\"\n    if any(k in cap_txt for k in DEPARTURES_KEYS):\n        return \"out\"\n\n    # heading immediatamente precedente (h2/h3/h4)\n    prev = table.find_previous([\"h2\",\"h3\",\"h4\"])\n    if prev:\n        pt = safe_text(prev.get_text(\" \", strip=True).lower())\n        if any(k in pt for k in ARRIVALS_KEYS):\n            return \"in\"\n        if any(k in pt for k in DEPARTURES_KEYS):\n            return \"out\"\n\n    # fallback: se il titolo pagina contiene “arrivals” ecc. (poco affidabile, ma meglio di nulla)\n    return \"in\"\n\ndef parse_tm_table(table: BeautifulSoup, team: str, season: str, direction_hint: Optional[str]) -> List[Dict[str, Any]]:\n    rows: List[Dict[str, Any]] = []\n    direction = direction_hint or infer_direction_from_context(table)\n    for tr in table.select(\"tbody > tr\"):\n        tds = tr.find_all(\"td\")\n        if len(tds) < 2:\n            continue\n\n        # giocatore: spesso nel td con un <a> su /profil/spieler/ o simile\n        a_player = tr.select_one(\"a[href*='/profil/spieler/'], a[href*='/player/'], a[href*='spieler']\")\n        player = safe_text(a_player.get_text()) if a_player else safe_text(tds[0].get_text())\n\n        if len(player) < 2:\n            continue\n\n        # club from/to (c'è un link /verein/)\n        a_club = tr.select_one(\"td a[href*='/verein/']\")\n        club_txt = safe_text(a_club.get_text()) if a_club else \"\"\n\n        # fee: tipicamente un td \"rechts\" o \"rechts hauptlink\"\n        fee_td = tr.find(\"td\", class_=\"rechts\") or tr.find(\"td\", class_=\"rechts hauptlink\")\n        fee = safe_text(fee_td.get_text()) if fee_td else \"\"\n\n        rec = {\n            \"id\": f\"tr_{uuid.uuid4().hex[:10]}\",\n            \"type\": \"transfer\",\n            \"season\": season,\n            \"team\": team,\n            \"player\": player,\n            \"direction\": direction,\n            \"from_team\": club_txt if direction == \"in\" else team,   # semantica: da dove arriva / dove va\n            \"to_team\":   team if direction == \"in\" else club_txt,\n            \"fee\": fee,\n            \"source\": \"transfermarkt_html\",\n            \"source_date\": now_iso_date(),\n            \"valid_from\": now_iso_date(),\n            \"valid_to\": \"2099-12-31\",\n        }\n        rows.append(rec)\n    return rows\n\ndef scrape_tm_team(url: str, team: str, season: str, arrivals_only: bool = False, departures_only: bool = False) -> List[Dict[str, Any]]:\n    headers = {\n        \"User-Agent\": os.environ.get(\"TM_USER_AGENT\",\n                                     \"Mozilla/5.0 (compatible; FantaETL/1.0; +https://example.local)\")\n    }\n    LOG.info(\"[TM] GET %s\", url)\n    r = requests.get(url, headers=headers, timeout=30)\n    if r.status_code != 200:\n        LOG.error(\"[TM] HTTP %s su %s\", r.status_code, url)\n        return []\n    soup = BeautifulSoup(r.text, \"html.parser\")\n\n    all_rows: List[Dict[str, Any]] = []\n    for table in soup.select(\"table.items\"):\n        direction = infer_direction_from_context(table)\n        if arrivals_only and direction != \"in\":\n            continue\n        if departures_only and direction != \"out\":\n            continue\n        chunk = parse_tm_table(table, team, season, direction_hint=direction)\n        all_rows.extend(chunk)\n\n    LOG.info(\"[TM] %s: %d trasferimenti estratti (%s)\", team, len(all_rows),\n             \"solo arrivi\" if arrivals_only else (\"solo cessioni\" if departures_only else \"totale\"))\n    return all_rows\n\n# -----------------------------------------------------------------------------\n# Roster merge & ingest\n# -----------------------------------------------------------------------------\ndef merge_into_roster(transfers: List[Dict[str, Any]], roster_path: Path) -> int:\n    roster = load_json(roster_path) or []\n    # indicizzazione: (name, team)\n    def key(p: Dict[str, Any]) -> Tuple[str, str]:\n        return (p.get(\"name\",\"\").lower(), p.get(\"team\",\"\").lower())\n\n    idx = { key(p): p for p in roster }\n    updates = 0\n    for tr in transfers:\n        if tr.get(\"direction\") != \"in\":\n            continue  # il roster locale rappresenta i giocatori ATTUALI della squadra\n        nm = tr.get(\"player\",\"\")\n        tm = tr.get(\"team\",\"\")\n        if not nm or not tm:\n            continue\n        k = (nm.lower(), tm.lower())\n        if k not in idx:\n            rec = {\n                \"name\": nm,\n                \"team\": tm,\n                \"role\": tr.get(\"role\") or \"NA\",\n                \"season\": tr.get(\"season\"),\n                \"type\": \"current_player\",\n                \"source\": tr.get(\"source\"),\n                \"source_date\": tr.get(\"source_date\"),\n            }\n            roster.append(rec)\n            idx[k] = rec\n            updates += 1\n        else:\n            rec = idx[k]\n            rec[\"season\"] = tr.get(\"season\")\n            rec[\"source\"] = tr.get(\"source\")\n            rec[\"source_date\"] = tr.get(\"source_date\")\n            updates += 1\n    save_json(roster_path, roster)\n    LOG.info(\"[ROSTER] upsert=%d; totale=%d\", updates, len(roster))\n    return updates\n\ndef ingest_into_kb(transfers: List[Dict[str, Any]]) -> int:\n    if not KM_AVAILABLE:\n        LOG.warning(\"[INGEST] KnowledgeManager non disponibile\")\n        return 0\n    try:\n        km = KnowledgeManager()\n        docs, metas, ids = [], [], []\n        for tr in transfers:\n            direction_str = \"IN\" if tr.get(\"direction\") == \"in\" else \"OUT\"\n            docs.append(\n                f\"Transfer {direction_str}: {tr.get('player')} \"\n                f\"{'->' if direction_str=='IN' else '<-'} {tr.get('team')} ({tr.get('season')}). \"\n                f\"From: {tr.get('from_team','n/a')} To: {tr.get('to_team','n/a')}. Fee: {tr.get('fee','n/a')}.\"\n            )\n            metas.append({\n                \"type\": \"transfer\",\n                \"player\": tr.get(\"player\"),\n                \"team\": tr.get(\"team\"),\n                \"season\": tr.get(\"season\"),\n                \"direction\": tr.get(\"direction\"),\n                \"from_team\": tr.get(\"from_team\",\"\"),\n                \"to_team\": tr.get(\"to_team\",\"\"),\n                \"fee\": tr.get(\"fee\",\"\"),\n                \"source\": tr.get(\"source\"),\n                \"source_date\": tr.get(\"source_date\"),\n                \"valid_from\": tr.get(\"valid_from\"),\n                \"valid_to\": tr.get(\"valid_to\"),\n            })\n            ids.append(tr.get(\"id\") or f\"tr_{uuid.uuid4().hex[:10]}\")\n        n = km.upsert(docs=docs, metadatas=metas, ids=ids)\n        LOG.info(\"[INGEST] upsert KB: %s\", n)\n        return int(n or 0)\n    except Exception as e:\n        LOG.error(\"[INGEST] errore: %s\", e)\n        return 0\n\n# -----------------------------------------------------------------------------\n# Mapping loader (override da JSON o ENV)\n# -----------------------------------------------------------------------------\ndef load_urls_mapping(urls_json: Optional[str]) -> Dict[str, str]:\n    mapping = DEFAULT_TM_URLS.copy()\n    # override via JSON file\n    if urls_json:\n        p = Path(urls_json)\n        if p.exists():\n            try:\n                with p.open(\"r\", encoding=\"utf-8\") as f:\n                    user_map = json.load(f)\n                for k, v in (user_map or {}).items():\n                    if isinstance(v, str) and v.startswith(\"http\"):\n                        mapping[k] = v\n                LOG.info(\"[CONF] Loaded URLs from %s (n=%d)\", p, len(user_map))\n            except Exception as e:\n                LOG.warning(\"[CONF] Impossibile leggere %s: %s\", p, e)\n\n    # override per singola squadra via env TRANSFERMARKT_URL_<TEAM_UPPER>\n    for team in list(mapping.keys()):\n        env_key = f\"TRANSFERMARKT_URL_{team.upper().replace(' ','_')}\"\n        if os.environ.get(env_key):\n            mapping[team] = os.environ[env_key]\n\n    # filtro opzionale via SERIE_A_TEAMS (lista separata da virgole)\n    teams_env = os.environ.get(\"SERIE_A_TEAMS\")\n    if teams_env:\n        requested = [t.strip() for t in teams_env.split(\",\") if t.strip()]\n        mapping = { t: mapping[t] for t in requested if t in mapping }\n        LOG.info(\"[CONF] Filtrate squadre da SERIE_A_TEAMS: %s\", \", \".join(mapping.keys()))\n\n    return mapping\n\n# -----------------------------------------------------------------------------\n# Main\n# -----------------------------------------------------------------------------\ndef main():\n    ap = argparse.ArgumentParser(description=\"One-shot ETL Transfermarkt Serie A\")\n    ap.add_argument(\"--season\", default=\"2025-26\", help=\"Stagione (es. 2025-26)\")\n    ap.add_argument(\"--urls-json\", help=\"JSON mapping team->Transfermarkt URL per override\")\n    ap.add_argument(\"--arrivals-only\", action=\"store_true\", help=\"Solo Arrivi\")\n    ap.add_argument(\"--departures-only\", action=\"store_true\", help=\"Solo Cessioni\")\n    ap.add_argument(\"--out-dir\", default=\"./data\", help=\"Cartella output JSONL\")\n    ap.add_argument(\"--delay\", type=float, default=1.0, help=\"Delay tra squadre (secondi)\")\n    ap.add_argument(\"--write-roster\", action=\"store_true\", help=\"Aggiorna season_roster.json con gli Arrivi\")\n    ap.add_argument(\"--ingest\", action=\"store_true\", help=\"Ingerisci in Knowledge Base (Chroma) se disponibile\")\n    args = ap.parse_args()\n\n    if args.arrivals_only and args.departures_only:\n        LOG.error(\"Non puoi usare --arrivals-only e --departures-only insieme.\")\n        sys.exit(2)\n\n    out_dir = Path(args.out_dir)\n    out_dir.mkdir(parents=True, exist_ok=True)\n\n    mapping = load_urls_mapping(args.urls_json)\n    if not mapping:\n        LOG.error(\"Nessuna squadra configurata (mapping vuoto).\")\n        sys.exit(2)\n\n    LOG.info(\"[ETL] Serie A — squadre=%d — stagione=%s\", len(mapping), args.season)\n\n    combined: List[Dict[str, Any]] = []\n    for i, (team, url) in enumerate(mapping.items(), start=1):\n        LOG.info(\"(%d/%d) %s\", i, len(mapping), team)\n        try:\n            items = scrape_tm_team(\n                url=url,\n                team=team,\n                season=args.season,\n                arrivals_only=args.arrivals_only,\n                departures_only=args.departures_only\n            )\n        except Exception as e:\n            LOG.error(\"[ETL] Errore scraping %s: %s\", team, e)\n            items = []\n\n        if not items:\n            LOG.warning(\"[ETL] Nessun trasferimento trovato per %s\", team)\n        else:\n            path = jsonl_path(out_dir, team, args.season)\n            append_jsonl(path, items)\n            LOG.info(\"[OUT] %s (righe=%d)\", path, len(items))\n            combined.extend(items)\n\n        # delay tra richieste per non stressare TM\n        time.sleep(max(0.2, args.delay))\n\n    # Combined file (utile per audit)\n    if combined:\n        combo_path = out_dir / f\"tm_transfers_SERIE_A_{args.season.replace('/','-')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.jsonl\"\n        append_jsonl(combo_path, combined)\n        LOG.info(\"[OUT] combined: %s (righe=%d)\", combo_path, len(combined))\n\n    # Aggiorna roster solo con ARRIVI\n    if args.write_roster and combined:\n        only_in = [x for x in combined if x.get(\"direction\") == \"in\"]\n        merge_into_roster(only_in, Path(\"./season_roster.json\"))\n\n    # Ingest in KB\n    if args.ingest and combined:\n        ingest_into_kb(combined)\n\n    LOG.info(\"[ETL] Done. Squadre processate: %d — Trasferimenti totali: %d\",\n             len(mapping), len(combined))\n\nif __name__ == \"__main__\":\n    main()\n"},{"path":"etl_transfers_job.py","size":7331,"sha1":"a365026dfdb66152e0397621de6bfbb026dcfa16","mtime":1754945722,"is_binary":false,"encoding":"utf-8","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\netl_transfers_job.py\nJob ETL per aggiornare automaticamente gli \"acquisti\" delle squadre nel KB.\n\nFonti:\n- Wikipedia (calciomercato estivo 2025 IT) via WebFallback\n- RSS/Ufficiali (se configurati)\n- Transfermarkt (OPZIONALE) via web_fallback_tm.TransfermarktFallback\n  => Abilita con env TRANSFERMARKT_FALLBACK=1 (rispetta ToS/robots, rate limit basso)\n\nEsecuzione:\n- Manuale: python etl_transfers_job.py\n- Periodica (Replit): usa replit \"Secrets\" per env e un cron semplice (p. es. UptimeRobot/cron esterno)\n- Loop interno: setta JOB_INTERVAL_MIN>0 per un loop (non consigliato in Replit free)\n\nScrive in Chroma tramite KnowledgeManager.add_knowledge(...)\n\"\"\"\n\nimport os\nimport re\nimport time\nimport json\nimport logging\nimport datetime as dt\nfrom typing import List, Dict, Any, Optional\n\nfrom knowledge_manager import KnowledgeManager\nfrom web_fallback import WebFallback  # Wikipedia fallback (il tuo file precedente)\n# Transfermarkt fallback è opzionale\ntry:\n    from web_fallback_tm import TransfermarktFallback\nexcept Exception:\n    TransfermarktFallback = None\n\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\nlogger = logging.getLogger(\"etl_transfers_job\")\n\n# Config\nCHROMA_DIR = os.environ.get(\"CHROMA_DIR\", \"./chroma_db\")\nCHROMA_COLLECTION = os.environ.get(\"CHROMA_COLLECTION\", \"fantacalcio_knowledge\")\nEMBED_MODEL = os.environ.get(\"EMBED_MODEL\", \"all-MiniLM-L6-v2\")\n\nSEASON = os.environ.get(\"SEASON\", \"2025-26\")\nUSE_TM = os.environ.get(\"TRANSFERMARKT_FALLBACK\", \"0\") == \"1\"\nREQUEST_DELAY = float(os.environ.get(\"REQUEST_DELAY\", \"2.0\"))  # delay tra chiamate per educazione\nJOB_INTERVAL_MIN = int(os.environ.get(\"JOB_INTERVAL_MIN\", \"0\"))  # se >0, loop periodico\n\nSERIE_A_TEAMS = [\n    \"Atalanta\", \"Bologna\", \"Cagliari\", \"Como\", \"Empoli\", \"Fiorentina\", \"Genoa\",\n    \"Inter\", \"Juventus\", \"Lazio\", \"Lecce\", \"Milan\", \"Monza\", \"Napoli\", \"Parma\",\n    \"Roma\", \"Torino\", \"Udinese\", \"Venezia\", \"Hellas Verona\",\n]\n\n# Opzionale: RSS/ufficiali (metti qui feed del club se li hai)\nTEAM_RSS: Dict[str, List[str]] = {\n    # \"Genoa\": [\"https://www.genoacfc.it/feed/\"],  # esempio se esistesse un feed compatibile\n}\n\ndef slugify(s: str) -> str:\n    s = s.strip().lower()\n    s = re.sub(r\"[^a-z0-9]+\", \"-\", s)\n    return re.sub(r\"-+\", \"-\", s).strip(\"-\")\n\ndef _unique(seq: List[str]) -> List[str]:\n    out = []\n    seen = set()\n    for x in seq:\n        k = x.lower().strip()\n        if k and k not in seen:\n            out.append(x.strip())\n            seen.add(k)\n    return out\n\ndef upsert_transfer(km: KnowledgeManager, team: str, player: str, sources: List[str], season: str, source_label: str):\n    \"\"\"Scrive/aggiorna un documento di tipo 'transfer' (direction=in) nel KB.\"\"\"\n    today = dt.date.today().isoformat()\n    doc_id = f\"transfer:{season}:{slugify(team)}:{slugify(player)}\"\n    text = f\"{player} è stato acquistato dal {team} per la stagione {season}.\"\n\n    try:\n        km.add_knowledge(\n            text=text,\n            metadata={\n                \"id\": doc_id,\n                \"type\": \"transfer\",\n                \"direction\": \"in\",\n                \"team\": team,\n                \"player\": player,\n                \"season\": season,\n                \"source\": source_label,\n                \"source_url\": \", \".join(sources) if sources else source_label,\n                \"source_date\": today,\n                \"updated_at\": today,\n            }\n        )\n        logger.info(\"Upsert transfer OK: %s\", doc_id)\n    except Exception as e:\n        logger.warning(\"Upsert transfer FAIL %s: %s\", doc_id, e)\n\ndef _merge_sources(*args: List[str]) -> List[str]:\n    merged = []\n    for group in args:\n        if not group:\n            continue\n        for s in group:\n            if s not in merged:\n                merged.append(s)\n    return merged\n\ndef fetch_from_wikipedia(team: str) -> Dict[str, Any]:\n    wf = WebFallback(timeout_s=float(os.environ.get(\"WEB_TIMEOUT\", \"6.5\")))\n    res = wf.fetch_team_transfers(team)\n    return {\n        \"players\": res.get(\"acquisti\", []) or [],\n        \"sources\": res.get(\"sources\", []) or [],\n        \"elapsed\": res.get(\"elapsed\", 0.0),\n        \"label\": \"Wikipedia\",\n    }\n\ndef fetch_from_tm(team: str) -> Dict[str, Any]:\n    if not USE_TM or TransfermarktFallback is None:\n        return {\"players\": [], \"sources\": [], \"elapsed\": 0.0, \"label\": \"TM (disabled)\"}\n    tm = TransfermarktFallback(timeout_s=float(os.environ.get(\"WEB_TIMEOUT\", \"7.5\")))\n    res = tm.fetch_team_transfers(team_name=team, season=SEASON)\n    return {\n        \"players\": res.get(\"acquisti\", []) or [],\n        \"sources\": res.get(\"sources\", []) or [],\n        \"elapsed\": res.get(\"elapsed\", 0.0),\n        \"label\": \"Transfermarkt\",\n    }\n\ndef fetch_from_rss(team: str) -> Dict[str, Any]:\n    \"\"\"Placeholder semplice: se configuri feed RSS ufficiali, qui puoi parsare 'nuovo giocatore'.\"\"\"\n    # Non implementato in dettaglio perché i feed variano. Fornisco struttura compatibile.\n    # Se aggiungi feed, estrai i titoli tipo \"UFFICIALE: Nome Cognome al TEAM\".\n    feeds = TEAM_RSS.get(team, [])\n    if not feeds:\n        return {\"players\": [], \"sources\": [], \"elapsed\": 0.0, \"label\": \"RSS (none)\"}\n    # TODO: implementare parsing feed con 'feedparser' se lo aggiungi ai requirements.\n    return {\"players\": [], \"sources\": feeds, \"elapsed\": 0.0, \"label\": \"RSS\"}\n\ndef run_once():\n    logger.info(\"[ETL] Avvio job transfers — season=%s\", SEASON)\n\n    km = KnowledgeManager(\n        collection_name=CHROMA_COLLECTION,\n        persist_dir=CHROMA_DIR,\n        embed_model_name=EMBED_MODEL,\n    )\n\n    total_upserts = 0\n    for i, team in enumerate(SERIE_A_TEAMS, start=1):\n        logger.info(\"[ETL] (%d/%d) %s\", i, len(SERIE_A_TEAMS), team)\n\n        # 1) Wikipedia\n        wiki = fetch_from_wikipedia(team)\n        time.sleep(REQUEST_DELAY)\n\n        # 2) Transfermarkt (opzionale)\n        tm = fetch_from_tm(team)\n        if USE_TM:\n            time.sleep(REQUEST_DELAY)\n\n        # 3) RSS/ufficiali (se configurati)\n        rss = fetch_from_rss(team)\n\n        # Merge dedup\n        merged_players = _unique(wiki[\"players\"] + tm[\"players\"] + rss[\"players\"])\n        merged_sources = _merge_sources(wiki[\"sources\"], tm[\"sources\"], rss[\"sources\"])\n\n        if not merged_players:\n            logger.info(\"[ETL] Nessun acquisto trovato per %s (fonti: %s, %s, %s)\",\n                        team, wiki[\"label\"], tm[\"label\"], rss[\"label\"])\n            continue\n\n        for name in merged_players:\n            upsert_transfer(km, team, name, merged_sources, SEASON, source_label=\";\".join(\n                [lbl for lbl in [wiki[\"label\"], tm[\"label\"] if USE_TM else None, rss[\"label\"] if rss[\"sources\"] else None] if lbl]\n            ))\n            total_upserts += 1\n\n        logger.info(\"[ETL] %s: %d acquisti aggiornati\", team, len(merged_players))\n\n    logger.info(\"[ETL] Completato. Upsert totali: %d\", total_upserts)\n\ndef main():\n    if JOB_INTERVAL_MIN > 0:\n        logger.info(\"[ETL] Loop periodico attivo: ogni %d minuti\", JOB_INTERVAL_MIN)\n        while True:\n            try:\n                run_once()\n            except Exception as e:\n                logger.error(\"[ETL] Errore run_once: %s\", e)\n            time.sleep(JOB_INTERVAL_MIN * 60)\n    else:\n        run_once()\n\nif __name__ == \"__main__\":\n    main()\n"},{"path":"etl_web_transfermarkt.py","size":902,"sha1":"c220d956fafb9c69da1c950768a116a6f7e4113f","mtime":1755031868,"is_binary":false,"encoding":"utf-8","content":"# etl_web_transfermarkt.py\n# -*- coding: utf-8 -*-\nimport os\nimport time\nimport json\nimport logging\nfrom typing import Dict, List\n\nLOG = logging.getLogger(\"etl_web_transfermarkt\")\nlogging.basicConfig(\n    level=os.environ.get(\"LOG_LEVEL\", \"INFO\"),\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\n\ndef main():\n    import argparse\n    ap = argparse.ArgumentParser()\n    ap.add_argument(\"--team\", type=str, default=\"\", help=\"Nome squadra (es. Juventus)\")\n    ap.add_argument(\"--season\", type=str, default=\"2025-26\")\n    ap.add_argument(\"--write-roster\", action=\"store_true\")\n    args = ap.parse_args()\n\n    LOG.info(\"[ETL-WEB] Stub attivo — questa versione non effettua scraping live per evitare 429/ban.\")\n    LOG.info(\"[ETL-WEB] Team=%s season=%s\", args.team, args.season)\n    print(json.dumps({\"ok\": True, \"items\": []}, ensure_ascii=False))\n\nif __name__ == \"__main__\":\n    main()\n"},{"path":"etl_youth_cache_transfermarkt.py","size":9001,"sha1":"71944034d049518ed9013baa4a6d558d24cdf6ab","mtime":1755036930,"is_binary":false,"encoding":"utf-8","content":"# etl_youth_cache_transfermarkt.py\n# -*- coding: utf-8 -*-\n\nimport os\nimport re\nimport json\nimport time\nimport httpx\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\n\nLOG = logging.getLogger(\"etl_youth_cache\")\nlogging.basicConfig(\n    level=os.environ.get(\"LOG_LEVEL\", \"INFO\"),\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\n\nWIKI_API = \"https://it.wikipedia.org/w/api.php\"\nOUT_PATH = os.getenv(\"EXTERNAL_YOUTH_CACHE\", \"./cache/under21_cache.json\")\nREF_DATE = datetime(2025, 8, 1)\n\nSERIE_A_TEAMS = [\n    \"Atalanta\", \"Bologna\", \"Cagliari\", \"Como\", \"Empoli\", \"Fiorentina\",\n    \"Genoa\", \"Inter\", \"Juventus\", \"Lazio\", \"Lecce\", \"Milan\",\n    \"Monza\", \"Napoli\", \"Parma\", \"Roma\", \"Torino\", \"Udinese\"\n]\n\nHEADERS = {\n    \"User-Agent\": \"FantacalcioAssistant/1.1 (ETL cache U21; mailto:example@example.com)\"\n}\n\nITALIAN_MONTHS = {\n    \"gennaio\",\"febbraio\",\"marzo\",\"aprile\",\"maggio\",\"giugno\",\n    \"luglio\",\"agosto\",\"settembre\",\"ottobre\",\"novembre\",\"dicembre\"\n}\n\ntry:\n    from bs4 import BeautifulSoup  # type: ignore\n    HAVE_BS4 = True\nexcept Exception:\n    HAVE_BS4 = False\n\n\ndef _age_from_text_date(s: str) -> Optional[int]:\n    s = s.strip()\n    # YYYY-MM-DD\n    m = re.search(r\"(\\d{4})-(\\d{1,2})-(\\d{1,2})\", s)\n    if m:\n        y = int(m.group(1))\n        if 1900 < y <= REF_DATE.year:\n            return REF_DATE.year - y\n    # DD/MM/YYYY\n    m = re.search(r\"(\\d{1,2})/(\\d{1,2})/(\\d{4})\", s)\n    if m:\n        y = int(m.group(3))\n        if 1900 < y <= REF_DATE.year:\n            return REF_DATE.year - y\n    # YYYY\n    m = re.search(r\"\\b(19\\d{2}|20\\d{2})\\b\", s)\n    if m:\n        y = int(m.group(1))\n        if 1900 < y <= REF_DATE.year:\n            return REF_DATE.year - y\n    return None\n\n\ndef _looks_like_calendar_row(text: str) -> bool:\n    low = text.lower()\n    if \"giornata\" in low or \"classifica\" in low or \"calendario\" in low:\n        return True\n    if \"ore\" in low or \"cet\" in low or \"cest\" in low:\n        return True\n    if any(m in low for m in ITALIAN_MONTHS):\n        return True\n    # tante cifre spesso indicano data/orari/punteggi\n    if sum(ch.isdigit() for ch in low) >= 4:\n        return True\n    return False\n\n\ndef wiki_search_team_page(client: httpx.Client, team: str) -> Optional[str]:\n    for season in (\"2025-2026\", \"2024-2025\"):\n        q = f\"{team} {season}\"\n        try:\n            r = client.get(WIKI_API, params={\n                \"action\": \"query\", \"list\": \"search\", \"srsearch\": q,\n                \"format\": \"json\", \"srlimit\": 5\n            }, headers=HEADERS, timeout=30.0)\n            r.raise_for_status()\n            js = r.json()\n            hits = js.get(\"query\", {}).get(\"search\", [])\n            for h in hits:\n                title = h.get(\"title\")\n                # preferisci pagina che contiene il team e la stagione\n                if title and team.lower() in title.lower():\n                    return title\n        except Exception as e:\n            LOG.warning(\"[WIKI] search error for %s: %s\", q, e)\n            time.sleep(1.0)\n    return None\n\n\ndef wiki_parse_players_with_bs4(html: str, team_title: str) -> List[Dict]:\n    out: List[Dict] = []\n    soup = BeautifulSoup(html, \"html.parser\")\n\n    # prendi solo tabelle con classe wikitable (tipico per rosa)\n    tables = soup.find_all(\"table\", class_=\"wikitable\")\n    for tbl in tables:\n        # skip se la tabella sembra calendario/risultati\n        header_text = \" \".join(th.get_text(\" \", strip=True) for th in tbl.find_all(\"th\"))\n        if _looks_like_calendar_row(header_text):\n            continue\n\n        # cerco header che abbiano 'Nome'/'Giocatore'/'Calciatore' o 'Ruolo'\n        header_ok = any(\n            k in header_text.lower()\n            for k in [\"nome\", \"giocatore\", \"calciatore\", \"ruolo\", \"posizione\", \"nascita\", \"data di nascita\"]\n        )\n        if not header_ok:\n            continue\n\n        for tr in tbl.find_all(\"tr\"):\n            tds = tr.find_all([\"td\"])\n            ths = tr.find_all([\"th\"])\n            if not tds or ths and not tds:\n                continue\n            row_text = tr.get_text(\" \", strip=True)\n            if _looks_like_calendar_row(row_text):\n                continue\n\n            # euristica: prima cella = nome\n            name = tds[0].get_text(\" \", strip=True) if tds else \"\"\n            # pulizia nome: via parentesi finali\n            name = re.sub(r\"\\s*\\(.*?\\)\\s*$\", \"\", name).strip()\n\n            if not name or any(ch.isdigit() for ch in name):\n                continue\n            if any(m in name.lower() for m in ITALIAN_MONTHS):\n                continue\n            if len(name) < 2:\n                continue\n\n            # ruolo: prova cella successiva o cerca nel resto\n            role = \"\"\n            if len(tds) >= 2:\n                role = tds[1].get_text(\" \", strip=True).upper()\n\n            # data di nascita in riga\n            age = _age_from_text_date(row_text)\n            if age is None or age < 15 or age > 22:\n                continue\n\n            # mapping ruolo\n            rb = \"A\"\n            R = role.upper()\n            if R.startswith((\"P\", \"POR\", \"GK\")):\n                rb = \"P\"\n            elif any(x in R for x in [\"D\", \"DEF\", \"CB\", \"RB\", \"LB\", \"TD\", \"TS\"]):\n                rb = \"D\"\n            elif any(x in R for x in [\"C\", \"CM\", \"MED\", \"MEZ\", \"AM\", \"TQ\", \"M \"]):\n                rb = \"C\"\n\n            out.append({\n                \"name\": name,\n                \"team\": team_title.split(\" 20\")[0],\n                \"role\": rb,\n                \"age\": age\n            })\n    return out\n\n\ndef wiki_parse_players_regex(html: str, team_title: str) -> List[Dict]:\n    out: List[Dict] = []\n    rows = re.findall(r\"<tr[^>]*>(.*?)</tr>\", html, flags=re.S | re.I)\n    for row in rows:\n        # scarta righe da calendario\n        row_text = re.sub(r\"<[^>]+>\", \" \", row)\n        row_text = re.sub(r\"\\s+\", \" \", row_text).strip()\n        if _looks_like_calendar_row(row_text):\n            continue\n\n        cells = re.findall(r\"<t[hd][^>]*>(.*?)</t[hd]>\", row, flags=re.S | re.I)\n        if len(cells) < 2:\n            continue\n\n        def strip_html(s: str) -> str:\n            s = re.sub(r\"<[^>]+>\", \" \", s)\n            s = re.sub(r\"\\s+\", \" \", s)\n            return s.strip()\n\n        name = strip_html(cells[0])\n        name = re.sub(r\"\\s*\\(.*?\\)\\s*$\", \"\", name).strip()\n        if not name or any(ch.isdigit() for ch in name):\n            continue\n        if any(m in name.lower() for m in ITALIAN_MONTHS):\n            continue\n\n        role = strip_html(cells[1]).upper() if len(cells) >= 2 else \"\"\n        age = _age_from_text_date(row_text)\n        if age is None or age < 15 or age > 22:\n            continue\n\n        rb = \"A\"\n        R = role.upper()\n        if R.startswith((\"P\", \"POR\", \"GK\")):\n            rb = \"P\"\n        elif any(x in R for x in [\"D\", \"DEF\", \"CB\", \"RB\", \"LB\", \"TD\", \"TS\"]):\n            rb = \"D\"\n        elif any(x in R for x in [\"C\", \"CM\", \"MED\", \"MEZ\", \"AM\", \"TQ\", \"M \"]):\n            rb = \"C\"\n\n        out.append({\n            \"name\": name,\n            \"team\": team_title.split(\" 20\")[0],\n            \"role\": rb,\n            \"age\": age\n        })\n    return out\n\n\ndef main():\n    os.makedirs(os.path.dirname(OUT_PATH), exist_ok=True)\n    results: List[Dict] = []\n\n    with httpx.Client(follow_redirects=True, headers=HEADERS, timeout=30.0) as client:\n        for team in SERIE_A_TEAMS:\n            LOG.info(\"[ETL-YOUTH] Cerco pagina Wiki per %s\", team)\n            title = wiki_search_team_page(client, team)\n            if not title:\n                LOG.warning(\"[ETL-YOUTH] Nessuna pagina trovata per %s\", team)\n                continue\n\n            # Carica HTML\n            try:\n                r = client.get(WIKI_API, params={\n                    \"action\": \"parse\", \"page\": title, \"prop\": \"text\", \"format\": \"json\"\n                })\n                r.raise_for_status()\n                html = r.json().get(\"parse\", {}).get(\"text\", {}).get(\"*\", \"\")\n            except Exception as e:\n                LOG.warning(\"[WIKI] parse error for %s: %s\", title, e)\n                continue\n\n            if not html:\n                continue\n\n            players = wiki_parse_players_with_bs4(html, title) if HAVE_BS4 else wiki_parse_players_regex(html, title)\n            LOG.info(\"[ETL-YOUTH] %s: estratti %d\", team, len(players))\n            results.extend(players)\n            time.sleep(0.6)\n\n    # dedup per nome+team, tieni età minore (più “giovane”)\n    dedup: Dict[str, Dict] = {}\n    for r in results:\n        key = (r[\"name\"].lower() + \"|\" + r[\"team\"].lower())\n        if key in dedup:\n            if r[\"age\"] < dedup[key][\"age\"]:\n                dedup[key] = r\n        else:\n            dedup[key] = r\n\n    final = list(dedup.values())\n\n    os.makedirs(os.path.dirname(OUT_PATH), exist_ok=True)\n    with open(OUT_PATH, \"w\", encoding=\"utf-8\") as f:\n        json.dump(final, f, ensure_ascii=False, indent=2)\n\n    LOG.info(\"[ETL-YOUTH] Salvato %s con %d record\", OUT_PATH, len(final))\n\n\nif __name__ == \"__main__\":\n    main()\n"},{"path":"etl_youth_from_km.py","size":6522,"sha1":"e19487a3fc97e2f5ad1d0bd19ff58bcbac47518b","mtime":1755076793,"is_binary":false,"encoding":"utf-8","content":"# etl_youth_from_km.py\n# -*- coding: utf-8 -*-\nimport os, re, json, math, logging\nfrom knowledge_manager import KnowledgeManager\n\nLOG = logging.getLogger(\"etl_youth_from_km\")\nlogging.basicConfig(level=os.environ.get(\"LOG_LEVEL\",\"INFO\"),\n                    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n\nREF_YEAR  = int(os.getenv(\"REF_YEAR\",\"2025\"))\nAGE_CUTOFF= int(os.getenv(\"AGE_CUTOFF\",\"23\"))\nOUT_PATH  = os.getenv(\"EXTERNAL_YOUTH_CACHE\",\"./cache/under21_cache.json\")\n\nMIN_YEAR = REF_YEAR - AGE_CUTOFF     # 23 anni → 2002\nMAX_YEAR = REF_YEAR - 15             # 10–15 anni come filtro superiore\nITALIAN_MONTHS = r\"(gennaio|febbraio|marzo|aprile|maggio|giugno|luglio|agosto|settembre|ottobre|novembre|dicembre)\"\n\n# Più pattern: anno esplicito (ampi), '03, (2004), * 2005, \"X anni\"\nRE_ANNI = [\n    re.compile(r\"nato(?:\\s+il)?\\s+\\d{1,2}[\\/\\-\\.\\s](?:\\d{1,2}|\" + ITALIAN_MONTHS + r\")[\\/\\-\\.\\s](20\\d{2}|19\\d{2})\", re.I),\n    re.compile(r\"\\b\\d{1,2}\\s+\" + ITALIAN_MONTHS + r\"\\s+(20\\d{2}|19\\d{2})\\b\", re.I),\n    re.compile(r\"\\bclasse\\s+('?|’)?0?(\\d{2}|\\d{4})\\b\", re.I),   # classe '03, classe 2004\n    re.compile(r\"\\bnato\\s+nel\\s+(20\\d{2}|19\\d{2})\\b\", re.I),\n    re.compile(r\"\\(\\s*(20\\d{2}|19\\d{2})\\s*\\)\"),               # (2004)\n    re.compile(r\"[*]\\s*(20\\d{2}|19\\d{2})\"),                   # * 2004\n    re.compile(r\"\\b(20\\d{2}|19\\d{2})\\b\"),                     # anno isolato (filtriamo dopo)\n]\nRE_AGE = re.compile(r\"\\b(\\d{1,2})\\s+anni\\b\", re.I)            # “19 anni”\n\ndef _to_int(x):\n    try: return int(x)\n    except: return None\n\ndef norm_role(r: str) -> str:\n    if not r: return \"\"\n    r=r.strip().upper()\n    if r in {\"P\",\"POR\",\"GK\",\"PORTIERE\"}: return \"P\"\n    if r in {\"D\",\"DEF\",\"DC\",\"TD\",\"TS\",\"BR\",\"CB\",\"RB\",\"LB\"}: return \"D\"\n    if r in {\"C\",\"CC\",\"MED\",\"CM\",\"MD\",\"ME\",\"EST\",\"M\"}: return \"C\"\n    if r in {\"A\",\"ATT\",\"ATTACCANTE\",\"F\",\"FW\",\"SS\",\"PUNTA\"}: return \"A\"\n    return r[:1]\n\ndef age_from_year(by: int) -> int | None:\n    try: return REF_YEAR - int(by)\n    except: return None\n\ndef clamp_birth_year(y: int | None) -> int | None:\n    if not y: return None\n    if y < 1980 or y > REF_YEAR: return None\n    return y\n\ndef extract_years(txt: str):\n    \"\"\"Restituisce (best_birth_year, fallback_year_from_age)\"\"\"\n    if not txt: return (None, None)\n    clean = txt.replace(\"–\",\"-\")\n    # rimuovi pattern stagione “2025-26” → 2025\n    clean = re.sub(r\"\\b(20\\d{2})\\s*[-/]\\s*(\\d{2})\\b\", r\"\\1\", clean)\n\n    # 1) prova anni espliciti\n    for pat in RE_ANNI:\n        for m in pat.finditer(clean):\n            groups = [g for g in m.groups() if g]\n            # normalizza '03 → 2003\n            cand = None\n            for g in groups[::-1]:\n                g = g.strip(\"’'\")\n                y = _to_int(g)\n                if y is None: continue\n                if y < 100: y += 2000\n                cand = clamp_birth_year(y)\n                if cand: break\n            if cand and MIN_YEAR <= cand <= MAX_YEAR:\n                return (cand, None)\n\n    # 2) prova età “X anni” → REF_YEAR - X (fallback)\n    m = RE_AGE.search(clean)\n    if m:\n        age = _to_int(m.group(1))\n        if age is not None and 15 <= age <= AGE_CUTOFF:\n            y = REF_YEAR - age\n            if MIN_YEAR <= y <= MAX_YEAR:\n                return (None, y)\n\n    return (None, None)\n\ndef safe_float(x):\n    try: return float(x)\n    except: return None\n\ndef main():\n    km = KnowledgeManager()\n    raw = km.collection.get(include=[\"metadatas\",\"documents\"])\n    metas = raw.get(\"metadatas\") or []\n    docs  = raw.get(\"documents\") or []\n    LOG.info(\"[YOUTH] records: %d\", len(metas))\n\n    out=[]\n    for m,doc in zip(metas, docs):\n        if not isinstance(m, dict): continue\n        name = (m.get(\"name\") or m.get(\"player\") or \"\").strip()\n        if not name: continue\n        role = norm_role(m.get(\"role\") or m.get(\"position\") or \"\")\n        team = (m.get(\"team\") or m.get(\"club\") or \"\").strip()\n\n        # hard fields first\n        for key in (\"birth_year\",\"year_of_birth\",\"anno_nascita\",\"born_year\"):\n            by = _to_int(m.get(key))\n            if by and MIN_YEAR <= by <= MAX_YEAR:\n                age = age_from_year(by)\n                out.append({\"name\":name,\"role\":role,\"team\":team,\"birth_year\":by,\"age\":age,\n                            \"fantamedia\":safe_float(m.get(\"fantamedia\")),\n                            \"price\":safe_float(m.get(\"price\") or m.get(\"cost\")),\n                            \"source\":\"km-meta\"})\n                break\n        else:\n            # extract dal testo\n            best, fallback = extract_years(doc or \"\")\n            by = best or fallback\n            if by and MIN_YEAR <= by <= MAX_YEAR:\n                age = age_from_year(by)\n                out.append({\"name\":name,\"role\":role,\"team\":team,\"birth_year\":by,\"age\":age,\n                            \"fantamedia\":safe_float(m.get(\"fantamedia\")),\n                            \"price\":safe_float(m.get(\"price\") or m.get(\"cost\")),\n                            \"source\":\"km-text\" if best else \"km-age\"})\n\n    # dedup (name, team)\n    dedup={}\n    for p in out:\n        key=(p[\"name\"].lower(), (p.get(\"team\") or \"\").lower())\n        prev=dedup.get(key)\n        if not prev: dedup[key]=p\n        else:\n            # preferisci chi ha birth_year “best” da testo/metadati (km-meta/ km-text) rispetto “km-age”\n            rank = {\"km-meta\":2,\"km-text\":2,\"km-age\":1}\n            if rank.get(p[\"source\"],0) > rank.get(prev.get(\"source\"),0):\n                dedup[key]=p\n            elif rank.get(p[\"source\"],0) == rank.get(prev.get(\"source\"),0):\n                # pari: FM maggiore → prezzo minore\n                pfm = (prev.get(\"fantamedia\") or -math.inf)\n                nfm = (p.get(\"fantamedia\") or -math.inf)\n                if nfm > pfm: dedup[key]=p\n                elif nfm == pfm:\n                    ppr = p.get(\"price\") or math.inf\n                    pprev= prev.get(\"price\") or math.inf\n                    if ppr < pprev: dedup[key]=p\n\n    out=list(dedup.values())\n    out.sort(key=lambda x: (-(x.get(\"fantamedia\") or 0.0), x.get(\"price\") or 1e9, x[\"name\"]))\n\n    os.makedirs(os.path.dirname(OUT_PATH) or \".\", exist_ok=True)\n    json.dump(out, open(OUT_PATH,\"w\",encoding=\"utf-8\"), ensure_ascii=False, indent=2)\n\n    n_u23=sum(1 for x in out if x.get(\"age\") is not None and x[\"age\"]<=23)\n    n_u21=sum(1 for x in out if x.get(\"age\") is not None and x[\"age\"]<=21)\n    LOG.info(\"[YOUTH] salvato %s con %d profili U23 (di cui %d U21).\", OUT_PATH, n_u23, n_u21)\n\nif __name__==\"__main__\":\n    main()\n"},{"path":"etl_youth_from_roster.py","size":4513,"sha1":"7149c4c8f12fce13434e49753bf0b20840d5dbab","mtime":1755075797,"is_binary":false,"encoding":"utf-8","content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n\"\"\"\nFallback: costruisce la cache U23/U21 dal season_roster.json.\nUtile se i metadati/doc di Chroma non contengono l'anno.\n\nENV:\n  ROSTER_JSON_PATH=./season_roster.json\n  EXTERNAL_YOUTH_CACHE=./cache/under21_cache.json\n  REF_YEAR=2025\n  AGE_CUTOFF=23\n\"\"\"\n\nimport os\nimport re\nimport json\nimport math\nimport logging\n\nLOG = logging.getLogger(\"etl_youth_from_roster\")\nlogging.basicConfig(\n    level=os.environ.get(\"LOG_LEVEL\", \"INFO\"),\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\n\nREF_YEAR = int(os.getenv(\"REF_YEAR\", \"2025\"))\nAGE_CUTOFF = int(os.getenv(\"AGE_CUTOFF\", \"23\"))\nROSTER_PATH = os.getenv(\"ROSTER_JSON_PATH\", \"./season_roster.json\")\nOUT_PATH = os.getenv(\"EXTERNAL_YOUTH_CACHE\", \"./cache/under21_cache.json\")\n\nYEAR_RE = re.compile(r\"\\b(20\\d{2}|19\\d{2})\\b\")\n\ndef _to_int(x):\n    try:\n        return int(x)\n    except Exception:\n        return None\n\ndef norm_role(role: str) -> str:\n    if not role: return \"\"\n    r = role.strip().upper()\n    if r in {\"P\",\"POR\",\"GK\",\"PORTIERE\"}: return \"P\"\n    if r in {\"D\",\"DEF\",\"DC\",\"TD\",\"TS\",\"BR\",\"CB\",\"RB\",\"LB\"}: return \"D\"\n    if r in {\"C\",\"CC\",\"MED\",\"CM\",\"MD\",\"ME\",\"EST\",\"M\"}: return \"C\"\n    if r in {\"A\",\"ATT\",\"ATTACCANTE\",\"F\",\"FW\",\"SS\",\"PUNTA\"}: return \"A\"\n    return r[:1]\n\ndef age_from_year(by: int) -> int | None:\n    try: return REF_YEAR - int(by)\n    except Exception: return None\n\ndef guess_year(obj: dict) -> int | None:\n    for k in (\"birth_year\",\"year_of_birth\",\"born_year\",\"anno_nascita\"):\n        y=_to_int(obj.get(k))\n        if y and (REF_YEAR-AGE_CUTOFF) <= y <= REF_YEAR:  # plausibile U23\n            return y\n    # eventualmente prova a estrarre numeri da eventuali campi descrittivi\n    for k in (\"bio\",\"notes\",\"extra\"):\n        val=obj.get(k)\n        if isinstance(val,str):\n            m=YEAR_RE.search(val)\n            if m:\n                y=_to_int(m.group(1))\n                if y and (REF_YEAR-AGE_CUTOFF) <= y <= REF_YEAR:\n                    return y\n    return None\n\ndef safe_float(x):\n    try: return float(x)\n    except Exception: return None\n\ndef main():\n    if not os.path.exists(ROSTER_PATH):\n        LOG.warning(\"[ETL-Y-ROSTER] roster non trovato: %s\", ROSTER_PATH)\n        return\n\n    try:\n        data=json.load(open(ROSTER_PATH,encoding=\"utf-8\"))\n    except Exception as e:\n        LOG.error(\"[ETL-Y-ROSTER] errore lettura roster: %s\", e)\n        return\n\n    if not isinstance(data,list):\n        LOG.warning(\"[ETL-Y-ROSTER] roster non è una lista, stop\")\n        return\n\n    out=[]\n    for r in data:\n        if not isinstance(r,dict): continue\n        name=(r.get(\"name\") or r.get(\"player\") or \"\").strip()\n        if not name: continue\n        role=norm_role(r.get(\"role\") or r.get(\"position\") or \"\")\n        team=(r.get(\"team\") or r.get(\"club\") or \"\").strip()\n        by = guess_year(r)\n        if not by: continue\n        age = age_from_year(by)\n        if age is None or age > AGE_CUTOFF: continue\n\n        fm = safe_float(r.get(\"fantamedia\") or r.get(\"avg\"))\n        price = safe_float(r.get(\"price\") or r.get(\"cost\"))\n\n        out.append({\n            \"name\": name,\n            \"role\": role,\n            \"team\": team,\n            \"birth_year\": by,\n            \"age\": age,\n            \"fantamedia\": fm,\n            \"price\": price,\n            \"source\": \"roster\"\n        })\n\n    # dedup per (name, team), preferisci FM maggiore poi prezzo minore\n    dedup={}\n    for p in out:\n        key=(p[\"name\"].lower(), (p.get(\"team\") or \"\").lower())\n        prev=dedup.get(key)\n        if not prev:\n            dedup[key]=p\n        else:\n            pfm = prev.get(\"fantamedia\") or -math.inf\n            nfm = p.get(\"fantamedia\") or -math.inf\n            if nfm > pfm:\n                dedup[key]=p\n            elif nfm == pfm:\n                ppr = p.get(\"price\") or math.inf\n                pprev = prev.get(\"price\") or math.inf\n                if ppr < pprev:\n                    dedup[key]=p\n\n    out=list(dedup.values())\n    out.sort(key=lambda x: (-(x.get(\"fantamedia\") or 0.0), x.get(\"price\") or 1e9, x[\"name\"]))\n\n    os.makedirs(os.path.dirname(OUT_PATH) or \".\", exist_ok=True)\n    json.dump(out, open(OUT_PATH,\"w\",encoding=\"utf-8\"), ensure_ascii=False, indent=2)\n\n    n_u23=sum(1 for x in out if x.get(\"age\") is not None and x[\"age\"]<=23)\n    n_u21=sum(1 for x in out if x.get(\"age\") is not None and x[\"age\"]<=21)\n\n    LOG.info(\"[ETL-Y-ROSTER] Salvato %s con %d profili U23 (di cui %d U21).\", OUT_PATH, n_u23, n_u21)\n\nif __name__==\"__main__\":\n    main()\n"},{"path":"export_changes.py","size":8154,"sha1":"abcc5f10a7ec80f4c2f4bbfd7525248525bc3b06","mtime":1755461035,"is_binary":false,"encoding":"utf-8","content":"# export_changes.py\n# Create a compact JSON payload of changed files in your repo.\n# Works with or without git; can split output to multiple JSON parts if large.\n\nimport os, sys, json, base64, hashlib, argparse, subprocess, shlex, datetime\nfrom pathlib import Path\n\nDEFAULT_INCLUDE_EXT = {\n    \".py\",\".html\",\".htm\",\".js\",\".ts\",\".css\",\".json\",\".yml\",\".yaml\",\n    \".jinja\",\".jinja2\",\".env\",\".ini\",\".cfg\",\".toml\",\".md\"\n}\nDEFAULT_EXCLUDE_DIRS = {\n    \".git\",\"node_modules\",\".venv\",\"venv\",\"__pycache__\",\".mypy_cache\",\n    \".pytest_cache\",\".ipynb_checkpoints\",\".pythonlibs\",\"chroma_db\",\"cache\",\"data/exports\"\n}\nDEFAULT_EXCLUDE_GLOBS = {\n    \"*.png\",\"*.jpg\",\"*.jpeg\",\"*.webp\",\"*.gif\",\"*.bmp\",\"*.ico\",\n    \"*.db\",\"*.sqlite\",\"*.sqlite3\",\"*.parquet\",\"*.feather\",\n    \"*.jsonl\",\"*.log\",\"*.lock\",\"*.zip\",\"*.tar\",\"*.gz\"\n}\n\ndef sha1_bytes(b: bytes) -> str:\n    h = hashlib.sha1(); h.update(b); return h.hexdigest()\n\ndef is_text_bytes(b: bytes) -> bool:\n    try:\n        b.decode(\"utf-8\")\n        return True\n    except UnicodeDecodeError:\n        return False\n\ndef git_available() -> bool:\n    try:\n        subprocess.check_output([\"git\",\"rev-parse\",\"--is-inside-work-tree\"], stderr=subprocess.DEVNULL)\n        return True\n    except Exception:\n        return False\n\ndef run(cmd: str) -> str:\n    return subprocess.check_output(shlex.split(cmd), stderr=subprocess.DEVNULL).decode(\"utf-8\", \"ignore\")\n\ndef list_changed_with_git(git_range: str|None) -> list[str]:\n    if git_range:\n        out = run(f\"git diff --name-only {git_range}\")\n        files = [p.strip() for p in out.splitlines() if p.strip()]\n        if files:\n            return files\n    out = run(\"git ls-files -m -o --exclude-standard\")\n    files = [p.strip() for p in out.splitlines() if p.strip()]\n    return files\n\ndef looks_excluded(path: Path, exclude_dirs: set[str], exclude_globs: set[str]) -> bool:\n    parts = set(p.lower() for p in path.parts)\n    if any(d.lower() in parts for d in exclude_dirs):\n        return True\n    name = path.name.lower()\n    for pat in exclude_globs:\n        if Path(name).match(pat):\n            return True\n    return False\n\ndef fallback_scan(root: Path, since_ts: float | None, include_ext: set[str],\n                  exclude_dirs: set[str], exclude_globs: set[str]) -> list[str]:\n    picked: list[str] = []\n    for p in root.rglob(\"*\"):\n        if not p.is_file():\n            continue\n        if looks_excluded(p.relative_to(root), exclude_dirs, exclude_globs):\n            continue\n        if p.suffix.lower() not in include_ext:\n            continue\n        if since_ts is not None:\n            try:\n                if p.stat().st_mtime < since_ts:\n                    continue\n            except Exception:\n                continue\n        picked.append(str(p.relative_to(root)))\n    return picked\n\ndef collect_files(root: Path, rel_paths: list[str], max_file_bytes: int) -> list[dict]:\n    items = []\n    for rel in rel_paths:\n        abs_p = root / rel\n        try:\n            b = abs_p.read_bytes()\n        except Exception:\n            continue\n        if len(b) > max_file_bytes:\n            continue\n        meta = {\n            \"path\": rel.replace(\"\\\\\",\"/\"),\n            \"size\": len(b),\n            \"sha1\": sha1_bytes(b),\n            \"mtime\": int(abs_p.stat().st_mtime),\n        }\n        if is_text_bytes(b):\n            meta[\"is_binary\"] = False\n            meta[\"encoding\"] = \"utf-8\"\n            meta[\"content\"] = b.decode(\"utf-8\")\n        else:\n            meta[\"is_binary\"] = True\n            meta[\"encoding\"] = \"base64\"\n            meta[\"content_b64\"] = base64.b64encode(b).decode(\"ascii\")\n        items.append(meta)\n    return items\n\ndef write_payload(payload: dict, out_path: Path, max_bytes: int|None):\n    js = json.dumps(payload, ensure_ascii=False, separators=(\",\",\":\"))\n    if max_bytes and len(js.encode(\"utf-8\")) > max_bytes:\n        files = payload[\"files\"]\n        header = {k:v for k,v in payload.items() if k!=\"files\"}\n        parts = []\n        chunk = []\n        current = 0\n        for f in files:\n            test = json.dumps({\"files\":[f]}, ensure_ascii=False, separators=(\",\",\":\")).encode(\"utf-8\")\n            if current + len(test) > max_bytes and chunk:\n                parts.append(chunk); chunk=[]; current=0\n            chunk.append(f)\n            current += len(test)\n        if chunk:\n            parts.append(chunk)\n        written = []\n        for i,chunk in enumerate(parts, start=1):\n            part_payload = dict(header); part_payload[\"files\"] = chunk\n            part_name = out_path.with_name(out_path.stem + f\".part{i}\" + out_path.suffix)\n            part_name.write_text(json.dumps(part_payload, ensure_ascii=False, separators=(\",\",\":\")), encoding=\"utf-8\")\n            written.append(str(part_name))\n        return written\n    else:\n        out_path.write_text(js, encoding=\"utf-8\")\n        return [str(out_path)]\n\ndef main():\n    ap = argparse.ArgumentParser(description=\"Export changed app files to JSON.\")\n    ap.add_argument(\"--root\", default=\".\", help=\"Project root\")\n    ap.add_argument(\"--git-range\", default=None, help=\"Git diff range, e.g. origin/main...HEAD\")\n    ap.add_argument(\"--since\", default=None, help=\"Only include files modified since ISO time (e.g. 2025-08-13T00:00:00)\")\n    ap.add_argument(\"--max-file-bytes\", type=int, default=400_000, help=\"Skip any single file larger than this\")\n    ap.add_argument(\"--max-json-bytes\", type=int, default=900_000, help=\"Split JSON into parts under this size (UTF-8 bytes)\")\n    ap.add_argument(\"--include-ext\", default=\",\".join(sorted(DEFAULT_INCLUDE_EXT)))\n    ap.add_argument(\"--exclude-dirs\", default=\",\".join(sorted(DEFAULT_EXCLUDE_DIRS)))\n    ap.add_argument(\"--exclude-globs\", default=\",\".join(sorted(DEFAULT_EXCLUDE_GLOBS)))\n    ap.add_argument(\"--out\", default=\"app_changes.json\", help=\"Output JSON (or prefix for parts)\")\n    ap.add_argument(\"--force-scan\", action=\"store_true\", help=\"Ignore git and scan the tree (respects --since if provided)\")\n    args = ap.parse_args()\n\n    root = Path(args.root).resolve()\n    include_ext = set(s.strip().lower() for s in args.include_ext.split(\",\") if s.strip())\n    exclude_dirs = set(s.strip() for s in args.exclude_dirs.split(\",\") if s.strip())\n    exclude_globs = set(s.strip() for s in args.exclude_globs.split(\",\") if s.strip())\n\n    since_ts = None\n    if args.since:\n        try:\n            dt = datetime.datetime.fromisoformat(args.since)\n            since_ts = dt.timestamp()\n        except Exception:\n            print(f\"Warning: could not parse --since '{args.since}', ignoring.\", file=sys.stderr)\n\n    if git_available() and not args.force_scan:\n        rel_paths = list_changed_with_git(args.git_range)\n    else:\n        rel_paths = []\n\n    if not rel_paths:\n        rel_paths = fallback_scan(root, since_ts, include_ext, exclude_dirs, exclude_globs)\n\n    rel_paths = sorted(set(rel_paths))\n    files = collect_files(root, rel_paths, args.max_file_bytes)\n\n    git_info = {}\n    if git_available():\n        try:\n            git_info[\"head\"] = run(\"git rev-parse HEAD\").strip()\n            git_info[\"branch\"] = run(\"git rev-parse --abbrev-ref HEAD\").strip()\n            git_info[\"status\"] = run(\"git status --porcelain\")\n        except Exception:\n            pass\n\n    payload = {\n        \"generated_at\": datetime.datetime.utcnow().isoformat() + \"Z\",\n        \"root\": str(root),\n        \"git\": git_info,\n        \"filters\": {\n            \"git_range\": args.git_range,\n            \"since\": args.since,\n            \"include_ext\": sorted(include_ext),\n            \"exclude_dirs\": sorted(exclude_dirs),\n            \"exclude_globs\": sorted(exclude_globs),\n            \"max_file_bytes\": args.max_file_bytes\n        },\n        \"summary\": {\n            \"file_count\": len(files),\n            \"total_bytes\": sum(f[\"size\"] for f in files)\n        },\n        \"files\": files\n    }\n\n    out_path = (Path.cwd() / args.out).resolve()\n    written = write_payload(payload, out_path, args.max_json_bytes)\n    kb = payload[\"summary\"][\"total_bytes\"]/1024.0\n    print(f\"✓ Exported {len(files)} files ({kb:.1f} KB payload) ->\")\n    for p in written:\n        print(\"   \", p)\n\nif __name__ == \"__main__\":\n    main()\n"}]}